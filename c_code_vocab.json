{"stoi": {"<UNK>": 0, "\n": 1, "!": 2, "!=": 3, "\"\n\t\t\t\t\t   \"": 4, "\"\n\t\t\t\t\t  \"": 5, "\"\n\t\t\t\t\t\"": 6, "\"\n\t\t\t\t     \"": 7, "\"\n\t\t\t\t    \"": 8, "\"\n\t\t\t\t   \"": 9, "\"\n\t\t\t\t\"": 10, "\"\n\t\t\t       \"": 11, "\"\n\t\t\t     \"": 12, "\"\n\t\t\t   \"": 13, "\"\n\t\t\t\"": 14, "\"\n\t\t\tgoto cpy_name;\n\t\t}\n\t\t\n\t\tname = d_path(&file->f_path, buf, path_max - sizeof(u64));\n\t\tif (is_err(name)) {\n\t\t\tname = \"": 15, "\"\n\t\t       \"": 16, "\"\n\t\t    \"": 17, "\"\n\t\t   \"": 18, "\"\n\t\t \"": 19, "\"\n\t\t\"": 20, "\"\n\t\tgoto cpy_name;\n\t}\n\ncpy_name:\n\tstrlcpy(tmp, name, sizeof(tmp));\n\tname = tmp;\ngot_name:\n\t\n\tsize = strlen(name)+1;\n\twhile (!is_aligned(size, sizeof(u64)))\n\t\tname[size++] = '\\0';\n\n\tmmap_event->file_name = name;\n\tmmap_event->file_size = size;\n\tmmap_event->maj = maj;\n\tmmap_event->min = min;\n\tmmap_event->ino = ino;\n\tmmap_event->ino_generation = gen;\n\tmmap_event->prot = prot;\n\tmmap_event->flags = flags;\n\n\tif (!(vma->vm_flags & vm_exec))\n\t\tmmap_event->event_id.header.misc |= perf_record_misc_mmap_data;\n\n\tmmap_event->event_id.header.size = sizeof(mmap_event->event_id) + size;\n\n\tperf_event_aux(perf_event_mmap_output,\n\t\t       mmap_event,\n\t\t       null);\n\n\tkfree(buf);\n}\n\nvoid perf_event_mmap(struct vm_area_struct *vma)\n{\n\tstruct perf_mmap_event mmap_event;\n\n\tif (!atomic_read(&nr_mmap_events))\n\t\treturn;\n\n\tmmap_event = (struct perf_mmap_event){\n\t\t.vma\t= vma,\n\t\t\n\t\t\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = perf_record_mmap,\n\t\t\t\t.misc = perf_record_misc_user,\n\t\t\t\t\n\t\t\t},\n\t\t\t\n\t\t\t\n\t\t\t.start  = vma->vm_start,\n\t\t\t.len    = vma->vm_end - vma->vm_start,\n\t\t\t.pgoff  = (u64)vma->vm_pgoff << page_shift,\n\t\t},\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t};\n\n\tperf_event_mmap_event(&mmap_event);\n}\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = perf_record_aux,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n\n\nstatic void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = perf_record_throttle,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_event_clock(event),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = perf_record_unthrottle;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n\nstatic void perf_log_itrace_start(struct perf_event *event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header        header;\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t} rec;\n\tint ret;\n\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\tif (!(event->pmu->capabilities & perf_pmu_cap_itrace) ||\n\t    event->hw.itrace_started)\n\t\treturn;\n\n\tevent->hw.itrace_started = 1;\n\n\trec.header.type\t= perf_record_itrace_start;\n\trec.header.misc\t= 0;\n\trec.header.size\t= sizeof(rec);\n\trec.pid\t= perf_event_pid(event, current);\n\trec.tid\t= perf_event_tid(event, current);\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n\n\nstatic int __perf_event_overflow(struct perf_event *event,\n\t\t\t\t   int throttle, struct perf_sample_data *data,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tint events = atomic_read(&event->event_limit);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 seq;\n\tint ret = 0;\n\n\t\n\tif (unlikely(!is_sampling_event(event)))\n\t\treturn 0;\n\n\tseq = __this_cpu_read(perf_throttled_seq);\n\tif (seq != hwc->interrupts_seq) {\n\t\thwc->interrupts_seq = seq;\n\t\thwc->interrupts = 1;\n\t} else {\n\t\thwc->interrupts++;\n\t\tif (unlikely(throttle\n\t\t\t     && hwc->interrupts >= max_samples_per_tick)) {\n\t\t\t__this_cpu_inc(perf_throttled_count);\n\t\t\thwc->interrupts = max_interrupts;\n\t\t\tperf_log_throttle(event, 0);\n\t\t\ttick_nohz_full_kick();\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (event->attr.freq) {\n\t\tu64 now = perf_clock();\n\t\ts64 delta = now - hwc->freq_time_stamp;\n\n\t\thwc->freq_time_stamp = now;\n\n\t\tif (delta > 0 && delta < 2*tick_nsec)\n\t\t\tperf_adjust_period(event, delta, hwc->last_period, true);\n\t}\n\n\t\n\n\tevent->pending_kill = poll_in;\n\tif (events && atomic_dec_and_test(&event->event_limit)) {\n\t\tret = 1;\n\t\tevent->pending_kill = poll_hup;\n\t\tevent->pending_disable = 1;\n\t\tirq_work_queue(&event->pending);\n\t}\n\n\tif (event->overflow_handler)\n\t\tevent->overflow_handler(event, data, regs);\n\telse\n\t\tperf_event_output(event, data, regs);\n\n\tif (event->fasync && event->pending_kill) {\n\t\tevent->pending_wakeup = 1;\n\t\tirq_work_queue(&event->pending);\n\t}\n\n\treturn ret;\n}\n\nint perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}\n\n\n\nstruct swevent_htable {\n\tstruct swevent_hlist\t\t*swevent_hlist;\n\tstruct mutex\t\t\thlist_mutex;\n\tint\t\t\t\thlist_refcount;\n\n\t\n\tint\t\t\t\trecursion[perf_nr_contexts];\n\n\t\n\tbool\t\t\t\tonline;\n};\n\nstatic define_per_cpu(struct swevent_htable, swevent_htable);\n\n\n\nu64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}\n\nstatic void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == max_interrupts)\n\t\treturn;\n\n\tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, throttle,\n\t\t\t\t\t    data, regs)) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n}\n\nstatic void perf_swevent_event(struct perf_event *event, u64 nr,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_add(nr, &event->count);\n\n\tif (!regs)\n\t\treturn;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tif ((event->attr.sample_type & perf_sample_period) && !event->attr.freq) {\n\t\tdata->period = nr;\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\t} else\n\t\tdata->period = event->hw.last_period;\n\n\tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\n\tif (local64_add_negative(nr, &hwc->period_left))\n\t\treturn;\n\n\tperf_swevent_overflow(event, 0, data, regs);\n}\n\nstatic int perf_exclude_event(struct perf_event *event,\n\t\t\t      struct pt_regs *regs)\n{\n\tif (event->hw.state & perf_hes_stopped)\n\t\treturn 1;\n\n\tif (regs) {\n\t\tif (event->attr.exclude_user && user_mode(regs))\n\t\t\treturn 1;\n\n\t\tif (event->attr.exclude_kernel && !user_mode(regs))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_swevent_match(struct perf_event *event,\n\t\t\t\tenum perf_type_id type,\n\t\t\t\tu32 event_id,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->attr.type != type)\n\t\treturn 0;\n\n\tif (event->attr.config != event_id)\n\t\treturn 0;\n\n\tif (perf_exclude_event(event, regs))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline u64 swevent_hash(u64 type, u32 event_id)\n{\n\tu64 val = event_id | (type << 32);\n\n\treturn hash_64(val, swevent_hlist_bits);\n}\n\nstatic inline struct hlist_head *\n__find_swevent_head(struct swevent_hlist *hlist, u64 type, u32 event_id)\n{\n\tu64 hash = swevent_hash(type, event_id);\n\n\treturn &hlist->heads[hash];\n}\n\n\nstatic inline struct hlist_head *\nfind_swevent_head_rcu(struct swevent_htable *swhash, u64 type, u32 event_id)\n{\n\tstruct swevent_hlist *hlist;\n\n\thlist = rcu_dereference(swhash->swevent_hlist);\n\tif (!hlist)\n\t\treturn null;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\n\nstatic inline struct hlist_head *\nfind_swevent_head(struct swevent_htable *swhash, struct perf_event *event)\n{\n\tstruct swevent_hlist *hlist;\n\tu32 event_id = event->attr.config;\n\tu64 type = event->attr.type;\n\n\t\n\thlist = rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t  lockdep_is_held(&event->ctx->lock));\n\tif (!hlist)\n\t\treturn null;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\nstatic void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, data, regs);\n\t}\nend:\n\trcu_read_unlock();\n}\n\ndefine_per_cpu(struct pt_regs, __perf_regs[4]);\n\nint perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}\nexport_symbol_gpl(perf_swevent_get_recursion_context);\n\ninline void perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}\n\nvoid ___perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\n\tif (warn_on_once(!regs))\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdo_perf_sw_event(perf_type_software, event_id, nr, &data, regs);\n}\n\nvoid __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (unlikely(rctx < 0))\n\t\tgoto fail;\n\n\t___perf_sw_event(event_id, nr, regs, addr);\n\n\tperf_swevent_put_recursion_context(rctx);\nfail:\n\tpreempt_enable_notrace();\n}\n\nstatic void perf_swevent_read(struct perf_event *event)\n{\n}\n\nstatic int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & perf_ef_start);\n\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\t\n\t\twarn_on_once(swhash->online);\n\t\treturn -einval;\n\t}\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void perf_swevent_del(struct perf_event *event, int flags)\n{\n\thlist_del_rcu(&event->hlist_entry);\n}\n\nstatic void perf_swevent_start(struct perf_event *event, int flags)\n{\n\tevent->hw.state = 0;\n}\n\nstatic void perf_swevent_stop(struct perf_event *event, int flags)\n{\n\tevent->hw.state = perf_hes_stopped;\n}\n\n\nstatic inline struct swevent_hlist *\nswevent_hlist_deref(struct swevent_htable *swhash)\n{\n\treturn rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t lockdep_is_held(&swhash->hlist_mutex));\n}\n\nstatic void swevent_hlist_release(struct swevent_htable *swhash)\n{\n\tstruct swevent_hlist *hlist = swevent_hlist_deref(swhash);\n\n\tif (!hlist)\n\t\treturn;\n\n\trcu_init_pointer(swhash->swevent_hlist, null);\n\tkfree_rcu(hlist, rcu_head);\n}\n\nstatic void swevent_hlist_put_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!--swhash->hlist_refcount)\n\t\tswevent_hlist_release(swhash);\n\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n\nstatic void swevent_hlist_put(struct perf_event *event)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tswevent_hlist_put_cpu(event, cpu);\n}\n\nstatic int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), gfp_kernel);\n\t\tif (!hlist) {\n\t\t\terr = -enomem;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n\nstatic int swevent_hlist_get(struct perf_event *event)\n{\n\tint err;\n\tint cpu, failed_cpu;\n\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\terr = swevent_hlist_get_cpu(event, cpu);\n\t\tif (err) {\n\t\t\tfailed_cpu = cpu;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\treturn 0;\nfail:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tswevent_hlist_put_cpu(event, cpu);\n\t}\n\n\tput_online_cpus();\n\treturn err;\n}\n\nstruct static_key perf_swevent_enabled[perf_count_sw_max];\n\nstatic void sw_perf_event_destroy(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\twarn_on(event->parent);\n\n\tstatic_key_slow_dec(&perf_swevent_enabled[event_id]);\n\tswevent_hlist_put(event);\n}\n\nstatic int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != perf_type_software)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\tswitch (event_id) {\n\tcase perf_count_sw_cpu_clock:\n\tcase perf_count_sw_task_clock:\n\t\treturn -enoent;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= perf_count_sw_max)\n\t\treturn -enoent;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pmu perf_swevent = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= perf_pmu_cap_no_nmi,\n\n\t.event_init\t= perf_swevent_init,\n\t.add\t\t= perf_swevent_add,\n\t.del\t\t= perf_swevent_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\n#ifdef config_event_tracing\n\nstatic int perf_tp_filter_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data)\n{\n\tvoid *record = data->raw->data;\n\n\tif (likely(!event->filter) || filter_match_preds(event->filter, record))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int perf_tp_event_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->hw.state & perf_hes_stopped)\n\t\treturn 0;\n\t\n\tif (event->attr.exclude_kernel)\n\t\treturn 0;\n\n\tif (!perf_tp_filter_match(event, data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx,\n\t\t   struct task_struct *task)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\n\tstruct perf_raw_record raw = {\n\t\t.size = entry_size,\n\t\t.data = record,\n\t};\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdata.raw = &raw;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, &data, regs);\n\t}\n\n\t\n\tif (task && task != current) {\n\t\tstruct perf_event_context *ctx;\n\t\tstruct trace_entry *entry = record;\n\n\t\trcu_read_lock();\n\t\tctx = rcu_dereference(task->perf_event_ctxp[perf_sw_context]);\n\t\tif (!ctx)\n\t\t\tgoto unlock;\n\n\t\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\t\tif (event->attr.type != perf_type_tracepoint)\n\t\t\t\tcontinue;\n\t\t\tif (event->attr.config != entry->type)\n\t\t\t\tcontinue;\n\t\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\t\tperf_swevent_event(event, count, &data, regs);\n\t\t}\nunlock:\n\t\trcu_read_unlock();\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}\nexport_symbol_gpl(perf_tp_event);\n\nstatic void tp_perf_event_destroy(struct perf_event *event)\n{\n\tperf_trace_destroy(event);\n}\n\nstatic int perf_tp_event_init(struct perf_event *event)\n{\n\tint err;\n\n\tif (event->attr.type != perf_type_tracepoint)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\terr = perf_trace_init(event);\n\tif (err)\n\t\treturn err;\n\n\tevent->destroy = tp_perf_event_destroy;\n\n\treturn 0;\n}\n\nstatic struct pmu perf_tracepoint = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.event_init\t= perf_tp_event_init,\n\t.add\t\t= perf_trace_add,\n\t.del\t\t= perf_trace_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\nstatic inline void perf_tp_register(void)\n{\n\tperf_pmu_register(&perf_tracepoint, \"": 21, "\"\n\t\"": 22, "\"\n\n\n\n#ifdef config_smp\nstatic int\nselect_task_rq_stop(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\treturn task_cpu(p); \n}\n#endif \n\nstatic void\ncheck_preempt_curr_stop(struct rq *rq, struct task_struct *p, int flags)\n{\n\t\n}\n\nstatic struct task_struct *\npick_next_task_stop(struct rq *rq, struct task_struct *prev)\n{\n\tstruct task_struct *stop = rq->stop;\n\n\tif (!stop || !task_on_rq_queued(stop))\n\t\treturn null;\n\n\tput_prev_task(rq, prev);\n\n\tstop->se.exec_start = rq_clock_task(rq);\n\n\treturn stop;\n}\n\nstatic void\nenqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)\n{\n\tadd_nr_running(rq, 1);\n}\n\nstatic void\ndequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)\n{\n\tsub_nr_running(rq, 1);\n}\n\nstatic void yield_task_stop(struct rq *rq)\n{\n\tbug(); \n}\n\nstatic void put_prev_task_stop(struct rq *rq, struct task_struct *prev)\n{\n\tstruct task_struct *curr = rq->curr;\n\tu64 delta_exec;\n\n\tdelta_exec = rq_clock_task(rq) - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec < 0))\n\t\tdelta_exec = 0;\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t\tmax(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = rq_clock_task(rq);\n\tcpuacct_charge(curr, delta_exec);\n}\n\nstatic void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)\n{\n}\n\nstatic void set_curr_task_stop(struct rq *rq)\n{\n\tstruct task_struct *stop = rq->stop;\n\n\tstop->se.exec_start = rq_clock_task(rq);\n}\n\nstatic void switched_to_stop(struct rq *rq, struct task_struct *p)\n{\n\tbug(); \n}\n\nstatic void\nprio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tbug(); \n}\n\nstatic unsigned int\nget_rr_interval_stop(struct rq *rq, struct task_struct *task)\n{\n\treturn 0;\n}\n\nstatic void update_curr_stop(struct rq *rq)\n{\n}\n\n\nconst struct sched_class stop_sched_class = {\n\t.next\t\t\t= &dl_sched_class,\n\n\t.enqueue_task\t\t= enqueue_task_stop,\n\t.dequeue_task\t\t= dequeue_task_stop,\n\t.yield_task\t\t= yield_task_stop,\n\n\t.check_preempt_curr\t= check_preempt_curr_stop,\n\n\t.pick_next_task\t\t= pick_next_task_stop,\n\t.put_prev_task\t\t= put_prev_task_stop,\n\n#ifdef config_smp\n\t.select_task_rq\t\t= select_task_rq_stop,\n#endif\n\n\t.set_curr_task          = set_curr_task_stop,\n\t.task_tick\t\t= task_tick_stop,\n\n\t.get_rr_interval\t= get_rr_interval_stop,\n\n\t.prio_changed\t\t= prio_changed_stop,\n\t.switched_to\t\t= switched_to_stop,\n\t.update_curr\t\t= update_curr_stop,\n};\n\n\n#include <linux/module.h>\n#include <linux/ftrace.h>\n\n#include \"": 23, "\"\n\n\n\n#ifndef config_have_futex_cmpxchg\nint __read_mostly futex_cmpxchg_enabled;\n#endif\n\n\n#define flags_shared\t\t0x01\n#define flags_clockrt\t\t0x02\n#define flags_has_timeout\t0x04\n\n\nstruct futex_pi_state {\n\t\n\tstruct list_head list;\n\n\t\n\tstruct rt_mutex pi_mutex;\n\n\tstruct task_struct *owner;\n\tatomic_t refcount;\n\n\tunion futex_key key;\n};\n\n\nstruct futex_q {\n\tstruct plist_node list;\n\n\tstruct task_struct *task;\n\tspinlock_t *lock_ptr;\n\tunion futex_key key;\n\tstruct futex_pi_state *pi_state;\n\tstruct rt_mutex_waiter *rt_waiter;\n\tunion futex_key *requeue_pi_key;\n\tu32 bitset;\n};\n\nstatic const struct futex_q futex_q_init = {\n\t\n\t.key = futex_key_init,\n\t.bitset = futex_bitset_match_any\n};\n\n\nstruct futex_hash_bucket {\n\tatomic_t waiters;\n\tspinlock_t lock;\n\tstruct plist_head chain;\n} ____cacheline_aligned_in_smp;\n\nstatic unsigned long __read_mostly futex_hashsize;\n\nstatic struct futex_hash_bucket *futex_queues;\n\nstatic inline void futex_get_mm(union futex_key *key)\n{\n\tatomic_inc(&key->private.mm->mm_count);\n\t\n\tsmp_mb__after_atomic();\n}\n\n\nstatic inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef config_smp\n\tatomic_inc(&hb->waiters);\n\t\n\tsmp_mb__after_atomic();\n#endif\n}\n\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef config_smp\n\tatomic_dec(&hb->waiters);\n#endif\n}\n\nstatic inline int hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef config_smp\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}\n\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}\n\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}\n\n\nstatic void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\tswitch (key->both.offset & (fut_off_inode|fut_off_mmshared)) {\n\tcase fut_off_inode:\n\t\tihold(key->shared.inode); \n\t\tbreak;\n\tcase fut_off_mmshared:\n\t\tfutex_get_mm(key); \n\t\tbreak;\n\tdefault:\n\t\t\n\t\tsmp_mb(); \n\t}\n}\n\n\nstatic void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t\n\t\twarn_on_once(1);\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (fut_off_inode|fut_off_mmshared)) {\n\tcase fut_off_inode:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase fut_off_mmshared:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}\n\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *page_head;\n\tint err, ro = 0;\n\n\t\n\tkey->both.offset = address % page_size;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -einval;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -efault;\n\n\t\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  \n\t\treturn 0;\n\t}\n\nagain:\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t\n\tif (err == -efault && rw == verify_read) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n#ifdef config_transparent_hugepage\n\tpage_head = page;\n\tif (unlikely(pagetail(page))) {\n\t\tput_page(page);\n\t\t\n\t\tlocal_irq_disable();\n\t\tif (likely(__get_user_pages_fast(address, 1, !ro, &page) == 1)) {\n\t\t\tpage_head = compound_head(page);\n\t\t\t\n\t\t\tif (page != page_head) {\n\t\t\t\tget_page(page_head);\n\t\t\t\tput_page(page);\n\t\t\t}\n\t\t\tlocal_irq_enable();\n\t\t} else {\n\t\t\tlocal_irq_enable();\n\t\t\tgoto again;\n\t\t}\n\t}\n#else\n\tpage_head = compound_head(page);\n\tif (page != page_head) {\n\t\tget_page(page_head);\n\t\tput_page(page);\n\t}\n#endif\n\n\tlock_page(page_head);\n\n\t\n\tif (!page_head->mapping) {\n\t\tint shmem_swizzled = pageswapcache(page_head);\n\t\tunlock_page(page_head);\n\t\tput_page(page_head);\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\t\treturn -efault;\n\t}\n\n\t\n\tif (pageanon(page_head)) {\n\t\t\n\t\tif (ro) {\n\t\t\terr = -efault;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= fut_off_mmshared; \n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t} else {\n\t\tkey->both.offset |= fut_off_inode; \n\t\tkey->shared.inode = page_head->mapping->host;\n\t\tkey->shared.pgoff = basepage_index(page);\n\t}\n\n\tget_futex_key_refs(key); \n\nout:\n\tunlock_page(page_head);\n\tput_page(page_head);\n\treturn err;\n}\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}\n\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       fault_flag_write);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}\n\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn null;\n}\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dest, from, sizeof(u32));\n\tpagefault_enable();\n\n\treturn ret ? -efault : 0;\n}\n\n\n\nstatic int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), gfp_kernel);\n\n\tif (!pi_state)\n\t\treturn -enomem;\n\n\tinit_list_head(&pi_state->list);\n\t\n\tpi_state->owner = null;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = futex_key_init;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}\n\nstatic struct futex_pi_state * alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\twarn_on(!pi_state);\n\tcurrent->pi_state_cache = null;\n\n\treturn pi_state;\n}\n\n\nstatic void free_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t\n\tif (pi_state->owner) {\n\t\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, pi_state->owner);\n\t}\n\n\tif (current->pi_state_cache)\n\t\tkfree(pi_state);\n\telse {\n\t\t\n\t\tpi_state->owner = null;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}\n\n\nstatic struct task_struct * futex_find_get_task(pid_t pid)\n{\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p)\n\t\tget_task_struct(p);\n\n\trcu_read_unlock();\n\n\treturn p;\n}\n\n\nvoid exit_pi_state_list(struct task_struct *curr)\n{\n\tstruct list_head *next, *head = &curr->pi_state_list;\n\tstruct futex_pi_state *pi_state;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key = futex_key_init;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\t\n\traw_spin_lock_irq(&curr->pi_lock);\n\twhile (!list_empty(head)) {\n\n\t\tnext = head->next;\n\t\tpi_state = list_entry(next, struct futex_pi_state, list);\n\t\tkey = pi_state->key;\n\t\thb = hash_futex(&key);\n\t\traw_spin_unlock_irq(&curr->pi_lock);\n\n\t\tspin_lock(&hb->lock);\n\n\t\traw_spin_lock_irq(&curr->pi_lock);\n\t\t\n\t\tif (head->next != next) {\n\t\t\tspin_unlock(&hb->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\twarn_on(pi_state->owner != curr);\n\t\twarn_on(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\tpi_state->owner = null;\n\t\traw_spin_unlock_irq(&curr->pi_lock);\n\n\t\trt_mutex_unlock(&pi_state->pi_mutex);\n\n\t\tspin_unlock(&hb->lock);\n\n\t\traw_spin_lock_irq(&curr->pi_lock);\n\t}\n\traw_spin_unlock_irq(&curr->pi_lock);\n}\n\n\n\n\nstatic int attach_to_pi_state(u32 uval, struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & futex_tid_mask;\n\n\t\n\tif (unlikely(!pi_state))\n\t\treturn -einval;\n\n\twarn_on(!atomic_read(&pi_state->refcount));\n\n\t\n\tif (uval & futex_owner_died) {\n\t\t\n\t\tif (!pi_state->owner) {\n\t\t\t\n\t\t\tif (pid)\n\t\t\t\treturn -einval;\n\t\t\t\n\t\t\tgoto out_state;\n\t\t}\n\n\t\t\n\t\tif (!pid)\n\t\t\tgoto out_state;\n\t} else {\n\t\t\n\t\tif (!pi_state->owner)\n\t\t\treturn -einval;\n\t}\n\n\t\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\treturn -einval;\nout_state:\n\tatomic_inc(&pi_state->refcount);\n\t*ps = pi_state;\n\treturn 0;\n}\n\n\nstatic int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & futex_tid_mask;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t\n\tif (!pid)\n\t\treturn -esrch;\n\tp = futex_find_get_task(pid);\n\tif (!p)\n\t\treturn -esrch;\n\n\tif (unlikely(p->flags & pf_kthread)) {\n\t\tput_task_struct(p);\n\t\treturn -eperm;\n\t}\n\n\t\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & pf_exiting)) {\n\t\t\n\t\tint ret = (p->flags & pf_exitpidone) ? -esrch : -eagain;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t\n\tpi_state = alloc_pi_state();\n\n\t\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t\n\tpi_state->key = *key;\n\n\twarn_on(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}\n\nstatic int lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n\t\t\t   union futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_q *match = futex_top_waiter(hb, key);\n\n\t\n\tif (match)\n\t\treturn attach_to_pi_state(uval, match->pi_state, ps);\n\n\t\n\treturn attach_to_pi_owner(uval, key, ps);\n}\n\nstatic int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tu32 uninitialized_var(curval);\n\n\tif (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)))\n\t\treturn -efault;\n\n\t\n\treturn curval != uval ? -eagain : 0;\n}\n\n\nstatic int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *match;\n\tint ret;\n\n\t\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -efault;\n\n\t\n\tif ((unlikely((uval & futex_tid_mask) == vpid)))\n\t\treturn -edeadlk;\n\n\t\n\tmatch = futex_top_waiter(hb, key);\n\tif (match)\n\t\treturn attach_to_pi_state(uval, match->pi_state, ps);\n\n\t\n\tif (!(uval & futex_tid_mask)) {\n\t\t\n\t\tnewval = uval & futex_owner_died;\n\t\tnewval |= vpid;\n\n\t\t\n\t\tif (set_waiters)\n\t\t\tnewval |= futex_waiters;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t\n\tnewval = uval | futex_waiters;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t\n\treturn attach_to_pi_owner(uval, key, ps);\n}\n\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (warn_on_smp(!q->lock_ptr || !spin_is_locked(q->lock_ptr))\n\t    || warn_on(plist_node_empty(&q->list)))\n\t\treturn;\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}\n\n\nstatic void wake_futex(struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (warn(q->pi_state || q->rt_waiter, \"": 24, "\"\n\n\n\nstatic void\nrt_mutex_set_owner(struct rt_mutex *lock, struct task_struct *owner)\n{\n\tunsigned long val = (unsigned long)owner;\n\n\tif (rt_mutex_has_waiters(lock))\n\t\tval |= rt_mutex_has_waiters;\n\n\tlock->owner = (struct task_struct *)val;\n}\n\nstatic inline void clear_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tlock->owner = (struct task_struct *)\n\t\t\t((unsigned long)lock->owner & ~rt_mutex_has_waiters);\n}\n\nstatic void fixup_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tif (!rt_mutex_has_waiters(lock))\n\t\tclear_rt_mutex_waiters(lock);\n}\n\n\n#if defined(__have_arch_cmpxchg) && !defined(config_debug_rt_mutexes)\n# define rt_mutex_cmpxchg(l,c,n)\t(cmpxchg(&l->owner, c, n) == c)\nstatic inline void mark_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tunsigned long owner, *p = (unsigned long *) &lock->owner;\n\n\tdo {\n\t\towner = *p;\n\t} while (cmpxchg(p, owner, owner | rt_mutex_has_waiters) != owner);\n}\n\n\nstatic inline bool unlock_rt_mutex_safe(struct rt_mutex *lock)\n\t__releases(lock->wait_lock)\n{\n\tstruct task_struct *owner = rt_mutex_owner(lock);\n\n\tclear_rt_mutex_waiters(lock);\n\traw_spin_unlock(&lock->wait_lock);\n\t\n\treturn rt_mutex_cmpxchg(lock, owner, null);\n}\n\n#else\n# define rt_mutex_cmpxchg(l,c,n)\t(0)\nstatic inline void mark_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tlock->owner = (struct task_struct *)\n\t\t\t((unsigned long)lock->owner | rt_mutex_has_waiters);\n}\n\n\nstatic inline bool unlock_rt_mutex_safe(struct rt_mutex *lock)\n\t__releases(lock->wait_lock)\n{\n\tlock->owner = null;\n\traw_spin_unlock(&lock->wait_lock);\n\treturn true;\n}\n#endif\n\nstatic inline int\nrt_mutex_waiter_less(struct rt_mutex_waiter *left,\n\t\t     struct rt_mutex_waiter *right)\n{\n\tif (left->prio < right->prio)\n\t\treturn 1;\n\n\t\n\tif (dl_prio(left->prio))\n\t\treturn (left->task->dl.deadline < right->task->dl.deadline);\n\n\treturn 0;\n}\n\nstatic void\nrt_mutex_enqueue(struct rt_mutex *lock, struct rt_mutex_waiter *waiter)\n{\n\tstruct rb_node **link = &lock->waiters.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct rt_mutex_waiter *entry;\n\tint leftmost = 1;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct rt_mutex_waiter, tree_entry);\n\t\tif (rt_mutex_waiter_less(waiter, entry)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tlock->waiters_leftmost = &waiter->tree_entry;\n\n\trb_link_node(&waiter->tree_entry, parent, link);\n\trb_insert_color(&waiter->tree_entry, &lock->waiters);\n}\n\nstatic void\nrt_mutex_dequeue(struct rt_mutex *lock, struct rt_mutex_waiter *waiter)\n{\n\tif (rb_empty_node(&waiter->tree_entry))\n\t\treturn;\n\n\tif (lock->waiters_leftmost == &waiter->tree_entry)\n\t\tlock->waiters_leftmost = rb_next(&waiter->tree_entry);\n\n\trb_erase(&waiter->tree_entry, &lock->waiters);\n\trb_clear_node(&waiter->tree_entry);\n}\n\nstatic void\nrt_mutex_enqueue_pi(struct task_struct *task, struct rt_mutex_waiter *waiter)\n{\n\tstruct rb_node **link = &task->pi_waiters.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct rt_mutex_waiter *entry;\n\tint leftmost = 1;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct rt_mutex_waiter, pi_tree_entry);\n\t\tif (rt_mutex_waiter_less(waiter, entry)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\ttask->pi_waiters_leftmost = &waiter->pi_tree_entry;\n\n\trb_link_node(&waiter->pi_tree_entry, parent, link);\n\trb_insert_color(&waiter->pi_tree_entry, &task->pi_waiters);\n}\n\nstatic void\nrt_mutex_dequeue_pi(struct task_struct *task, struct rt_mutex_waiter *waiter)\n{\n\tif (rb_empty_node(&waiter->pi_tree_entry))\n\t\treturn;\n\n\tif (task->pi_waiters_leftmost == &waiter->pi_tree_entry)\n\t\ttask->pi_waiters_leftmost = rb_next(&waiter->pi_tree_entry);\n\n\trb_erase(&waiter->pi_tree_entry, &task->pi_waiters);\n\trb_clear_node(&waiter->pi_tree_entry);\n}\n\n\nint rt_mutex_getprio(struct task_struct *task)\n{\n\tif (likely(!task_has_pi_waiters(task)))\n\t\treturn task->normal_prio;\n\n\treturn min(task_top_pi_waiter(task)->prio,\n\t\t   task->normal_prio);\n}\n\nstruct task_struct *rt_mutex_get_top_task(struct task_struct *task)\n{\n\tif (likely(!task_has_pi_waiters(task)))\n\t\treturn null;\n\n\treturn task_top_pi_waiter(task)->task;\n}\n\n\nint rt_mutex_check_prio(struct task_struct *task, int newprio)\n{\n\tif (!task_has_pi_waiters(task))\n\t\treturn 0;\n\n\treturn task_top_pi_waiter(task)->task->prio <= newprio;\n}\n\n\nstatic void __rt_mutex_adjust_prio(struct task_struct *task)\n{\n\tint prio = rt_mutex_getprio(task);\n\n\tif (task->prio != prio || dl_prio(prio))\n\t\trt_mutex_setprio(task, prio);\n}\n\n\nstatic void rt_mutex_adjust_prio(struct task_struct *task)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\t__rt_mutex_adjust_prio(task);\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n}\n\n\nstatic bool rt_mutex_cond_detect_deadlock(struct rt_mutex_waiter *waiter,\n\t\t\t\t\t  enum rtmutex_chainwalk chwalk)\n{\n\t\n\treturn debug_rt_mutex_detect_deadlock(waiter, chwalk);\n}\n\n\nint max_lock_depth = 1024;\n\nstatic inline struct rt_mutex *task_blocked_on_lock(struct task_struct *p)\n{\n\treturn p->pi_blocked_on ? p->pi_blocked_on->lock : null;\n}\n\n\nstatic int rt_mutex_adjust_prio_chain(struct task_struct *task,\n\t\t\t\t      enum rtmutex_chainwalk chwalk,\n\t\t\t\t      struct rt_mutex *orig_lock,\n\t\t\t\t      struct rt_mutex *next_lock,\n\t\t\t\t      struct rt_mutex_waiter *orig_waiter,\n\t\t\t\t      struct task_struct *top_task)\n{\n\tstruct rt_mutex_waiter *waiter, *top_waiter = orig_waiter;\n\tstruct rt_mutex_waiter *prerequeue_top_waiter;\n\tint ret = 0, depth = 0;\n\tstruct rt_mutex *lock;\n\tbool detect_deadlock;\n\tunsigned long flags;\n\tbool requeue = true;\n\n\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);\n\n\t\n again:\n\t\n\tif (++depth > max_lock_depth) {\n\t\tstatic int prev_max;\n\n\t\t\n\t\tif (prev_max != max_lock_depth) {\n\t\t\tprev_max = max_lock_depth;\n\t\t\tprintk(kern_warning \"": 25, "\"\n\n\ndefine_per_cpu(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\n\t.lock = __raw_spin_lock_unlocked(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = hrtimer_base_monotonic,\n\t\t\t.clockid = clock_monotonic,\n\t\t\t.get_time = &ktime_get,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t\t{\n\t\t\t.index = hrtimer_base_realtime,\n\t\t\t.clockid = clock_realtime,\n\t\t\t.get_time = &ktime_get_real,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t\t{\n\t\t\t.index = hrtimer_base_boottime,\n\t\t\t.clockid = clock_boottime,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t\t{\n\t\t\t.index = hrtimer_base_tai,\n\t\t\t.clockid = clock_tai,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t}\n};\n\nstatic const int hrtimer_clock_to_base_table[max_clocks] = {\n\t[clock_realtime]\t= hrtimer_base_realtime,\n\t[clock_monotonic]\t= hrtimer_base_monotonic,\n\t[clock_boottime]\t= hrtimer_base_boottime,\n\t[clock_tai]\t\t= hrtimer_base_tai,\n};\n\nstatic inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\treturn hrtimer_clock_to_base_table[clock_id];\n}\n\n\n\nstatic void hrtimer_get_softirq_time(struct hrtimer_cpu_base *base)\n{\n\tktime_t xtim, mono, boot, tai;\n\tktime_t off_real, off_boot, off_tai;\n\n\tmono = ktime_get_update_offsets_tick(&off_real, &off_boot, &off_tai);\n\tboot = ktime_add(mono, off_boot);\n\txtim = ktime_add(mono, off_real);\n\ttai = ktime_add(mono, off_tai);\n\n\tbase->clock_base[hrtimer_base_realtime].softirq_time = xtim;\n\tbase->clock_base[hrtimer_base_monotonic].softirq_time = mono;\n\tbase->clock_base[hrtimer_base_boottime].softirq_time = boot;\n\tbase->clock_base[hrtimer_base_tai].softirq_time = tai;\n}\n\n\n#ifdef config_smp\n\n\nstatic\nstruct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base;\n\n\tfor (;;) {\n\t\tbase = timer->base;\n\t\tif (likely(base != null)) {\n\t\t\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\t\t\tif (likely(base == timer->base))\n\t\t\t\treturn base;\n\t\t\t\n\t\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}\n\n\nstatic int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n#ifdef config_high_res_timers\n\tktime_t expires;\n\n\tif (!new_base->cpu_base->hres_active)\n\t\treturn 0;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires.tv64 <= new_base->cpu_base->expires_next.tv64;\n#else\n\treturn 0;\n#endif\n}\n\n\nstatic inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_clock_base *new_base;\n\tstruct hrtimer_cpu_base *new_cpu_base;\n\tint this_cpu = smp_processor_id();\n\tint cpu = get_nohz_timer_target(pinned);\n\tint basenum = base->index;\n\nagain:\n\tnew_cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t\n\t\ttimer->base = null;\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (cpu != this_cpu && hrtimer_check_target(timer, new_base)) {\n\t\t\tcpu = this_cpu;\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\ttimer->base = base;\n\t\t\tgoto again;\n\t\t}\n\t\ttimer->base = new_base;\n\t} else {\n\t\tif (cpu != this_cpu && hrtimer_check_target(timer, new_base)) {\n\t\t\tcpu = this_cpu;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}\n\n#else \n\nstatic inline struct hrtimer_clock_base *\nlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\n\treturn base;\n}\n\n# define switch_hrtimer_base(t, b, p)\t(b)\n\n#endif\t\n\n\n#if bits_per_long < 64\n\nu64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tu64 dclc;\n\tint sft = 0;\n\n\tdclc = ktime_to_ns(kt);\n\t\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\tdclc >>= sft;\n\tdo_div(dclc, (unsigned long) div);\n\n\treturn dclc;\n}\nexport_symbol_gpl(__ktime_divns);\n#endif \n\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add(lhs, rhs);\n\n\t\n\tif (res.tv64 < 0 || res.tv64 < lhs.tv64 || res.tv64 < rhs.tv64)\n\t\tres = ktime_set(ktime_sec_max, 0);\n\n\treturn res;\n}\n\nexport_symbol_gpl(ktime_add_safe);\n\n#ifdef config_debug_objects_timers\n\nstatic struct debug_obj_descr hrtimer_debug_descr;\n\nstatic void *hrtimer_debug_hint(void *addr)\n{\n\treturn ((struct hrtimer *) addr)->function;\n}\n\n\nstatic int hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase odebug_state_active:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nstatic int hrtimer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tswitch (state) {\n\n\tcase odebug_state_notavailable:\n\t\twarn_on_once(1);\n\t\treturn 0;\n\n\tcase odebug_state_active:\n\t\twarn_on(1);\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nstatic int hrtimer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase odebug_state_active:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_free(timer, &hrtimer_debug_descr);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic struct debug_obj_descr hrtimer_debug_descr = {\n\t.name\t\t= \"": 26, "\"\n\n\ndefine_per_cpu(struct tick_device, tick_cpu_device);\n\nktime_t tick_next_period;\nktime_t tick_period;\n\n\nint tick_do_timer_cpu __read_mostly = tick_do_timer_boot;\n\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}\n\n\nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & clock_evt_feat_oneshot))\n\t\treturn 0;\n\tif (!(dev->features & clock_evt_feat_c3stop))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}\n\n\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(cpu_profiling);\n}\n\n\nvoid tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n\tif (dev->state != clock_evt_state_oneshot)\n\t\treturn;\n\tfor (;;) {\n\t\t\n\t\tnext = ktime_add(next, tick_period);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t\n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}\n\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & clock_evt_feat_periodic) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_set_state(dev, clock_evt_state_periodic);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_set_state(dev, clock_evt_state_oneshot);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}\n\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tktime_t next_event;\n\tvoid (*handler)(struct clock_event_device *) = null;\n\n\t\n\tif (!td->evtdev) {\n\t\t\n\t\tif (tick_do_timer_cpu == tick_do_timer_boot) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = tick_do_timer_none;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = ktime_set(0, nsec_per_sec / hz);\n\t\t}\n\n\t\t\n\t\ttd->mode = tickdev_mode_periodic;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == tickdev_mode_periodic)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & clock_evt_feat_oneshot)\n\t\ttick_oneshot_notify();\n}\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t\n\tif (!(newdev->features & clock_evt_feat_oneshot)) {\n\t\tif (curdev && (curdev->features & clock_evt_feat_oneshot))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}\n\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}\n\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\tgoto out_bc;\n\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = null;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & clock_evt_feat_oneshot)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t\n\ttick_install_broadcast_device(newdev);\n}\n\n#ifdef config_hotplug_cpu\n\nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id()) {\n\t\tint cpu = cpumask_first(cpu_online_mask);\n\n\t\ttick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\n\t\t\ttick_do_timer_none;\n\t}\n}\n\n\nvoid tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = tickdev_mode_periodic;\n\tif (dev) {\n\t\t\n\t\tdev->state = clock_evt_state_detached;\n\t\tdev->mode = clock_evt_mode_unused;\n\t\tclockevents_exchange_device(dev, null);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = null;\n\t}\n}\n#endif\n\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}\n\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == tickdev_mode_periodic)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}\n\n\nvoid tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}\n\n\nvoid tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}\n\nstatic define_raw_spinlock(tick_freeze_lock);\nstatic unsigned int tick_freeze_depth;\n\n\nvoid tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus())\n\t\ttimekeeping_suspend();\n\telse\n\t\ttick_suspend_local();\n\n\traw_spin_unlock(&tick_freeze_lock);\n}\n\n\nvoid tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus())\n\t\ttimekeeping_resume();\n\telse\n\t\ttick_resume_local();\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}\n\n\nvoid __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}\n\n\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/utsname.h>\n#include <linux/mempolicy.h>\n\n#include \"": 27, "\"\n\n\nenum {\n\ttrace_nop_opt_accept = 0x1,\n\ttrace_nop_opt_refuse = 0x2\n};\n\n\nstatic struct tracer_opt nop_opts[] = {\n\t\n\t{ tracer_opt(test_nop_accept, trace_nop_opt_accept) },\n\t\n\t{ tracer_opt(test_nop_refuse, trace_nop_opt_refuse) },\n\t{ } \n};\n\nstatic struct tracer_flags nop_flags = {\n\t\n\t.val = 0, \n\t.opts = nop_opts\n};\n\nstatic struct trace_array\t*ctx_trace;\n\nstatic void start_nop_trace(struct trace_array *tr)\n{\n\t\n}\n\nstatic void stop_nop_trace(struct trace_array *tr)\n{\n\t\n}\n\nstatic int nop_trace_init(struct trace_array *tr)\n{\n\tctx_trace = tr;\n\tstart_nop_trace(tr);\n\treturn 0;\n}\n\nstatic void nop_trace_reset(struct trace_array *tr)\n{\n\tstop_nop_trace(tr);\n}\n\n\nstatic int nop_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\t\n\tif (bit == trace_nop_opt_accept) {\n\t\tprintk(kern_debug \"": 28, "\"\n\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == cpupri_invalid)\n\t\tcpupri = cpupri_invalid;\n\telse if (prio == max_prio)\n\t\tcpupri = cpupri_idle;\n\telse if (prio >= max_rt_prio)\n\t\tcpupri = cpupri_normal;\n\telse\n\t\tcpupri = max_rt_prio - prio + 1;\n\n\treturn cpupri;\n}\n\n\nint cpupri_find(struct cpupri *cp, struct task_struct *p,\n\t\tstruct cpumask *lowest_mask)\n{\n\tint idx = 0;\n\tint task_pri = convert_prio(p->prio);\n\n\tbug_on(task_pri >= cpupri_nr_priorities);\n\n\tfor (idx = 0; idx < task_pri; idx++) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[idx];\n\t\tint skip = 0;\n\n\t\tif (!atomic_read(&(vec)->count))\n\t\t\tskip = 1;\n\t\t\n\t\tsmp_rmb();\n\n\t\t\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tif (cpumask_any_and(&p->cpus_allowed, vec->mask) >= nr_cpu_ids)\n\t\t\tcontinue;\n\n\t\tif (lowest_mask) {\n\t\t\tcpumask_and(lowest_mask, &p->cpus_allowed, vec->mask);\n\n\t\t\t\n\t\t\tif (cpumask_any(lowest_mask) >= nr_cpu_ids)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tbug_on(newpri >= cpupri_nr_priorities);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t\n\tif (likely(newpri != cpupri_invalid)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != cpupri_invalid)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}\n\n\nint cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tmemset(cp, 0, sizeof(*cp));\n\n\tfor (i = 0; i < cpupri_nr_priorities; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, gfp_kernel))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), gfp_kernel);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = cpupri_invalid;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -enomem;\n}\n\n\nvoid cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < cpupri_nr_priorities; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}\n\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/tty.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/freezer.h>\n#include <linux/binfmts.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/ptrace.h>\n#include <linux/profile.h>\n#include <linux/mount.h>\n#include <linux/proc_fs.h>\n#include <linux/kthread.h>\n#include <linux/mempolicy.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/signal.h>\n#include <linux/posix-timers.h>\n#include <linux/cn_proc.h>\n#include <linux/mutex.h>\n#include <linux/futex.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/audit.h> \n#include <linux/resource.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/tracehook.h>\n#include <linux/fs_struct.h>\n#include <linux/init_task.h>\n#include <linux/perf_event.h>\n#include <trace/events/sched.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/oom.h>\n#include <linux/writeback.h>\n#include <linux/shm.h>\n\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n\nstatic void exit_mm(struct task_struct *tsk);\n\nstatic void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, pidtype_pid);\n\tif (group_dead) {\n\t\tdetach_pid(p, pidtype_pgid);\n\t\tdetach_pid(p, pidtype_sid);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}\n\n\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *uninitialized_var(tty);\n\tcputime_t utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead) {\n\t\tposix_cpu_timers_exit_group(tsk);\n\t\ttty = sig->tty;\n\t\tsig->tty = null;\n\t} else {\n\t\t\n\t\tif (unlikely(has_group_leader_pid(tsk)))\n\t\t\tposix_cpu_timers_exit_group(tsk);\n\n\t\t\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\t\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = null;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, tif_sigpending);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}\n\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == exit_zombie) {\n\t\t\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = exit_dead;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}\n\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, pidtype_pgid, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, pidtype_pgid, p);\n\n\treturn 1;\n}\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), null);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}\n\nstatic bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, pidtype_pgid, p) {\n\t\tif (p->signal->flags & signal_stop_stopped)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, pidtype_pgid, p);\n\n\treturn false;\n}\n\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t\n\t\tparent = tsk->real_parent;\n\telse\n\t\t\n\t\tignored_task = null;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(sighup, send_sig_priv, pgrp);\n\t\t__kill_pgrp_info(sigcont, send_sig_priv, pgrp);\n\t}\n}\n\n#ifdef config_memcg\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t\n\tif (mm->owner != p)\n\t\treturn;\n\t\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tmm->owner = null;\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t\n\tfor_each_process(g) {\n\t\tif (g->flags & pf_kthread)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t\n\tmm->owner = null;\n\treturn;\n\nassign_new_owner:\n\tbug_on(c == p);\n\tget_task_struct(c);\n\t\n\ttask_lock(c);\n\t\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tmm->owner = c;\n\ttask_unlock(c);\n\tput_task_struct(c);\n}\n#endif \n\n\nstatic void exit_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(tsk, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\t\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = tsk;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_task_state(tsk, task_uninterruptible);\n\t\t\tif (!self.task) \n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_task_state(tsk, task_running);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tatomic_inc(&mm->mm_count);\n\tbug_on(mm != tsk->active_mm);\n\t\n\ttask_lock(tsk);\n\ttsk->mm = null;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\ttask_unlock(tsk);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(tif_memdie))\n\t\tunmark_oom_victim();\n}\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & pf_exiting))\n\t\t\treturn t;\n\t}\n\treturn null;\n}\n\nstatic struct task_struct *find_child_reaper(struct task_struct *father)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (unlikely(pid_ns == &init_pid_ns)) {\n\t\tpanic(\"": 29, "\"\n\n\nstruct module_signature {\n\tu8\talgo;\t\t\n\tu8\thash;\t\t\n\tu8\tid_type;\t\n\tu8\tsigner_len;\t\n\tu8\tkey_id_len;\t\n\tu8\t__pad[3];\n\t__be32\tsig_len;\t\n};\n\n\nstatic struct public_key_signature *mod_make_digest(enum hash_algo hash,\n\t\t\t\t\t\t    const void *mod,\n\t\t\t\t\t\t    unsigned long modlen)\n{\n\tstruct public_key_signature *pks;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tsize_t digest_size, desc_size;\n\tint ret;\n\n\tpr_devel(\"": 30, "\"\n\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}\n\n\nstatic struct clocksource *curr_clocksource;\nstatic list_head(clocksource_list);\nstatic define_mutex(clocksource_mutex);\nstatic char override_name[cs_name_len];\nstatic int finished_booting;\n\n#ifdef config_clocksource_watchdog\nstatic void clocksource_watchdog_work(struct work_struct *work);\nstatic void clocksource_select(void);\n\nstatic list_head(watchdog_list);\nstatic struct clocksource *watchdog;\nstatic struct timer_list watchdog_timer;\nstatic declare_work(watchdog_work, clocksource_watchdog_work);\nstatic define_spinlock(watchdog_lock);\nstatic int watchdog_running;\nstatic atomic_t watchdog_reset_pending;\n\nstatic int clocksource_watchdog_kthread(void *data);\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating);\n\n\n#define watchdog_interval (hz >> 1)\n#define watchdog_threshold (nsec_per_sec >> 4)\n\nstatic void clocksource_watchdog_work(struct work_struct *work)\n{\n\t\n\tkthread_run(clocksource_watchdog_kthread, null, \"": 31, "\"\n\n#define cmd_buflen 256\nchar kdb_prompt_str[cmd_buflen];\n\nint kdb_trap_printk;\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tkdb_state_set(kgdb_trans);\n\t\tkdb_printf(\"": 32, "\"\n\n#define kprobe_event_system \"": 33, "\"\n\n#define suspend_console\t(max_nr_consoles-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nstatic define_mutex(vt_switch_mutex);\n\nstruct pm_vt_switch {\n\tstruct list_head head;\n\tstruct device *dev;\n\tbool required;\n};\n\nstatic list_head(pm_vt_switch_list);\n\n\n\nvoid pm_vt_switch_required(struct device *dev, bool required)\n{\n\tstruct pm_vt_switch *entry, *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\t\n\t\t\ttmp->required = required;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tentry = kmalloc(sizeof(*entry), gfp_kernel);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->required = required;\n\tentry->dev = dev;\n\n\tlist_add(&entry->head, &pm_vt_switch_list);\nout:\n\tmutex_unlock(&vt_switch_mutex);\n}\nexport_symbol(pm_vt_switch_required);\n\n\nvoid pm_vt_switch_unregister(struct device *dev)\n{\n\tstruct pm_vt_switch *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\tlist_del(&tmp->head);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vt_switch_mutex);\n}\nexport_symbol(pm_vt_switch_unregister);\n\n\nstatic bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}\n\nint pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn 0;\n\n\torig_fgconsole = vt_move_to_console(suspend_console, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn 1;\n\n\torig_kmsg = vt_kmsg_redirect(suspend_console);\n\treturn 0;\n}\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}\n\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <crypto/public_key.h>\n#include <crypto/hash.h>\n#include <keys/asymmetric-type.h>\n#include <keys/system_keyring.h>\n#include \"": 34, "\"\n\n#include <linux/slab.h>\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !rb_empty_node(&dl_se->rb_node);\n}\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->rb_leftmost == &dl_se->rb_node;\n}\n\nvoid init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == runtime_inf)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}\n\nvoid init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->rb_root = rb_root;\n\n#ifdef config_smp\n\t\n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = rb_root;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n}\n\n#ifdef config_smp\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}\n\nstatic void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}\n\nstatic void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}\n\n\nstatic void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_node **link = &dl_rq->pushable_dl_tasks_root.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct task_struct *entry;\n\tint leftmost = 1;\n\n\tbug_on(!rb_empty_node(&p->pushable_dl_tasks));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct task_struct,\n\t\t\t\t pushable_dl_tasks);\n\t\tif (dl_entity_preempt(&p->dl, &entry->dl))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tdl_rq->pushable_dl_tasks_leftmost = &p->pushable_dl_tasks;\n\n\trb_link_node(&p->pushable_dl_tasks, parent, link);\n\trb_insert_color(&p->pushable_dl_tasks, &dl_rq->pushable_dl_tasks_root);\n}\n\nstatic void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (rb_empty_node(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tif (dl_rq->pushable_dl_tasks_leftmost == &p->pushable_dl_tasks) {\n\t\tstruct rb_node *next_node;\n\n\t\tnext_node = rb_next(&p->pushable_dl_tasks);\n\t\tdl_rq->pushable_dl_tasks_leftmost = next_node;\n\t}\n\n\trb_erase(&p->pushable_dl_tasks, &dl_rq->pushable_dl_tasks_root);\n\trb_clear_node(&p->pushable_dl_tasks);\n}\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !rb_empty_root(&rq->dl.pushable_dl_tasks_root);\n}\n\nstatic int push_dl_task(struct rq *rq);\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn dl_task(prev);\n}\n\nstatic inline void set_post_schedule(struct rq *rq)\n{\n\trq->post_schedule = has_pushable_dl_tasks(rq);\n}\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq);\n\nstatic void dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = null;\n\tbool fallback = false;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t\n\t\tfallback = true;\n\t\tcpu = cpumask_any_and(cpu_active_mask, tsk_cpus_allowed(p));\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t\n\t\t\tbug_on(dl_bandwidth_enabled());\n\n\t\t\t\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tdeactivate_task(rq, p, 0);\n\tset_task_cpu(p, later_rq->cpu);\n\tactivate_task(later_rq, p, enqueue_replenish);\n\n\tif (!fallback)\n\t\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n}\n\n#else\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}\n\nstatic inline int pull_dl_task(struct rq *rq)\n{\n\treturn 0;\n}\n\nstatic inline void set_post_schedule(struct rq *rq)\n{\n}\n#endif \n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags);\n\n\nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\t       struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\twarn_on(!dl_se->dl_new || dl_se->dl_throttled);\n\n\t\n\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\tdl_se->runtime = pi_se->dl_runtime;\n\tdl_se->dl_new = 0;\n}\n\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tbug_on(pi_se->dl_runtime <= 0);\n\n\t\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\t\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"": 35, "\"\n\nchar *_braille_console_setup(char **str, char **brl_options)\n{\n\tif (!memcmp(*str, \"": 36, "\"\n\nconst char *pm_labels[] = { \"": 37, "\"\n#endif\n\t\"": 38, "\"\n#endif\n\nstruct trace_option_dentry {\n\tstruct tracer_opt\t\t*opt;\n\tstruct tracer_flags\t\t*flags;\n\tstruct trace_array\t\t*tr;\n\tstruct dentry\t\t\t*entry;\n};\n\nstatic ssize_t\ntrace_options_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t\tloff_t *ppos)\n{\n\tstruct trace_option_dentry *topt = filp->private_data;\n\tchar *buf;\n\n\tif (topt->flags->val & topt->opt->bit)\n\t\tbuf = \"": 39, "\"\n#endif\n#endif \n\t\"": 40, "\"\n#endif\n#ifdef config_function_graph_tracer\n\t\"": 41, "\"\n#endif\n#ifdef config_stack_tracer\n\t\"": 42, "\"\n#endif\n#ifdef config_tracer_snapshot\n\t\"": 43, "\"\n#endif \n#ifdef config_function_tracer\n\t\"": 44, "\"\n#ifdef config_dynamic_ftrace\n\t\"": 45, "\"\n#ifdef config_stacktrace\n\t\"": 46, "\"\n#ifdef config_x86_64\n\t\"": 47, "\"\n#include \"": 48, "\"\n;\n\nstatic ssize_t\ntracing_readme_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\treadme_msg, strlen(readme_msg));\n}\n\nstatic const struct file_operations tracing_readme_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_readme_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic void *saved_cmdlines_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tunsigned int *ptr = v;\n\n\tif (*pos || m->count)\n\t\tptr++;\n\n\t(*pos)++;\n\n\tfor (; ptr < &savedcmd->map_cmdline_to_pid[savedcmd->cmdline_num];\n\t     ptr++) {\n\t\tif (*ptr == -1 || *ptr == no_cmdline_map)\n\t\t\tcontinue;\n\n\t\treturn ptr;\n\t}\n\n\treturn null;\n}\n\nstatic void *saved_cmdlines_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *v;\n\tloff_t l = 0;\n\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\tv = &savedcmd->map_cmdline_to_pid[0];\n\twhile (l <= *pos) {\n\t\tv = saved_cmdlines_next(m, v, &l);\n\t\tif (!v)\n\t\t\treturn null;\n\t}\n\n\treturn v;\n}\n\nstatic void saved_cmdlines_stop(struct seq_file *m, void *v)\n{\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n\nstatic int saved_cmdlines_show(struct seq_file *m, void *v)\n{\n\tchar buf[task_comm_len];\n\tunsigned int *pid = v;\n\n\t__trace_find_cmdline(*pid, buf);\n\tseq_printf(m, \"": 49, "\"                 \"": 50, "\"                \"": 51, "\"               function calls\\n\"": 52, "\"               |   |   |   |\\n\"": 53, "\"              events:    %ld\\n\"": 54, "\"            task   pid         tree-key  switches  prio\"": 55, "\"         check your cmos/bios settings.\\n\"": 56, "\"         lost events:   %ld\\n\"": 57, "\"         please report this, consider using a different clocksource, if possible.\\n\"": 58, "\"         read events:   %ld\\n\"": 59, "\"         timekeeping: your kernel is sick, but tries to cope by capping time updates\\n\"": 60, "\"         your kernel is probably still fine.\\n\"": 61, "\"        -----    ----   --------\\n\"": 62, "\"        depth    size   location    (%d entries)\\n\"": 63, "\"        depth    size   location\"": 64, "\"        total events:   %ld\\n\"": 65, "\"       --------                \"": 66, "\"       ----\\n\"": 67, "\"       alloced bytes:    %ld\\n\"": 68, "\"       biggest event:    %d\\n\"": 69, "\"       cpu0\\n\"": 70, "\"       dropped bytes:    %ld\\n\"": 71, "\"       function                \"": 72, "\"       written bytes:    %ld\\n\"": 73, "\"      %s %s %.*s\\n\"": 74, "\"      smallest event:    %d\\n\"": 75, "\"      time (secs)        count\\n\"": 76, "\"      timekeeping: your kernel is still fine, but is feeling a bit nervous\\n\"": 77, "\"      |         \"": 78, "\"     exec-runtime         sum-exec        sum-sleep\\n\"": 79, "\"     last function: %pf\\n\"": 80, "\"     the %s domain not a subset of the %s domain\\n\"": 81, "\"     time       \"": 82, "\"    \"": 83, "\"    (%d entries)\\n\"": 84, "\"    balk: nt=%lu egt=%lu bt=%lu nb=%lu ny=%lu nos=%lu\\n\"": 85, "\"    delayed:\"": 86, "\"    in-flight:\"": 87, "\"    lock(\"": 88, "\"    pending:\"": 89, "\"    |\\n\"": 90, "\"   (ftrace buffer empty)\\n\"": 91, "\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"": 92, "\"   miss      hit    % \"": 93, "\"   pattern or ^pattern or pattern$ or ^pattern$\\n\"": 94, "\"   |    |        \"": 95, "\"   |   |      \"": 96, "\"  \"": 97, "\"  %-11.11s \"": 98, "\"  %-30.30s  %10lu\"": 99, "\"  %ps flags:%lx\\n\"": 100, "\"  %s %-44s %15lu\\n\"": 101, "\"  %s\"": 102, "\"  'grep' is just a key word.\\n\"": 103, "\"  +\"": 104, "\"  ----              ----\\n\"": 105, "\"  --------                               \"": 106, "\"  --------                               ---\\n\"": 107, "\"  .%-15s: %lu nsecs\\n\"": 108, "\"  .%-15s: %lu\\n\"": 109, "\"  .%-30s: %d\\n\"": 110, "\"  .%-30s: %ld.%06ld\\n\"": 111, "\"  .%-30s: %ld\\n\"": 112, "\"  .%-30s: %lld.%06ld\\n\"": 113, "\"  .%-30s: %lld\\n\"": 114, "\"  .%-30s: %lu\\n\"": 115, "\"  .%-40s: %d (%s)\\n\"": 116, "\"  .%-40s: %ld.%06ld\\n\"": 117, "\"  .%-40s: %ld\\n\"": 118, "\"  ...\\n\"": 119, "\"  <interrupt>\\n\"": 120, "\"  and if there are spaces in the pattern, you may \"": 121, "\"  any command's output may be filtered through an \"": 122, "\"  change the kernel config_debug_rodata=n\\n\"": 123, "\"  duration   \"": 124, "\"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\"": 125, "\"  error: does not match running \"": 126, "\"  error: no saved data for this cpu\\n\"": 127, "\"  file              line\\n\"": 128, "\"  from func %ps return to %lx\\n\"": 129, "\"  func:file:line\\n\"": 130, "\"  function                               \"": 131, "\"  function                               hit\\n\"": 132, "\"  lock(\"": 133, "\"  ok  \"": 134, "\"  or use hw breaks: help bph\\n\"": 135, "\"  pwq %d:\"": 136, "\"  recorded len bytes:   %ld\\n\"": 137, "\"  task                        pc stack   pid father\\n\"": 138, "\"  task                pc stack   pid father\\n\"": 139, "\"  task %d\\n\"": 140, "\"  task/pid       \"": 141, "\"  the pattern may include a very limited set of \"": 142, "\" \"": 143, "\" #%d\"": 144, "\" %*d\"": 145, "\" %*pbl\"": 146, "\" %-8s\"": 147, "\" %12llu: \"": 148, "\" %14lu \"": 149, "\" %4lld: \"": 150, "\" %4lldus%c: \"": 151, "\" %5d:%3d:%c %s [%03d] %5d:%3d:%c %s\\n\"": 152, "\" %5lu.%06lu: \"": 153, "\" %8s\"": 154, "\" %d\"": 155, "\" %d(%ld,%ld)\"": 156, "\" %i \"": 157, "\" %llx\"": 158, "\" %lx <-- %lx\"": 159, "\" %ps\"": 160, "\" %s does not support one-shot mode.\\n\"": 161, "\" %s is not functional.\\n\"": 162, "\" %s\"": 163, "\" %s%d\"": 164, "\" %s%s\"": 165, "\" %s+%u\"": 166, "\" %s:0x%p\"": 167, "\" %s=\"": 168, "\" %s=%s\"": 169, "\" %s=(fault)\"": 170, "\" %s=\\\"%s\\\"\"": 171, "\" %s\\n\"": 172, "\" %u %u %u %u %u %u %u %u %u %u %u %u\\n\"": 173, "\" '-'.\\n\"": 174, "\" (\"": 175, "\" (%ld)%s\"": 176, "\" (%s)\"": 177, "\" (cpu_capacity = %d)\"": 178, "\" (live)\"": 179, "\" (loading)\"": 180, "\" (overruns: %lu)\\n\"": 181, "\" (owned by %s)\\n\"": 182, "\" (t=%lu jiffies g=%ld c=%ld q=%lu)\\n\"": 183, "\" (unloading)\"": 184, "\" */\\n\"": 185, "\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (console_drivers != null && console->flags & con_consdev)\n\t\tconsole_drivers->flags |= con_consdev;\n\n\tconsole->flags &= ~con_enabled;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}\nexport_symbol(unregister_console);\n\nstatic int __init printk_late_init(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con) {\n\t\tif (!keep_bootcon && con->flags & con_boot) {\n\t\t\tunregister_console(con);\n\t\t}\n\t}\n\thotcpu_notifier(console_cpu_notify, 0);\n\treturn 0;\n}\nlate_initcall(printk_late_init);\n\n#if defined config_printk\n\n#define printk_pending_wakeup\t0x01\n#define printk_pending_output\t0x02\n\nstatic define_per_cpu(int, printk_pending);\n\nstatic void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = __this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & printk_pending_output) {\n\t\t\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & printk_pending_wakeup)\n\t\twake_up_interruptible(&log_wait);\n}\n\nstatic define_per_cpu(struct irq_work, wake_up_klogd_work) = {\n\t.func = wake_up_klogd_work_func,\n\t.flags = irq_work_lazy,\n};\n\nvoid wake_up_klogd(void)\n{\n\tpreempt_disable();\n\tif (waitqueue_active(&log_wait)) {\n\t\tthis_cpu_or(printk_pending, printk_pending_wakeup);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tpreempt_disable();\n\tva_start(args, fmt);\n\tr = vprintk_emit(0, loglevel_sched, null, 0, fmt, args);\n\tva_end(args);\n\n\t__this_cpu_or(printk_pending, printk_pending_output);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n\n\treturn r;\n}\n\n\ndefine_ratelimit_state(printk_ratelimit_state, 5 * hz, 10);\n\nint __printk_ratelimit(const char *func)\n{\n\treturn ___ratelimit(&printk_ratelimit_state, func);\n}\nexport_symbol(__printk_ratelimit);\n\n\nbool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\tunsigned int interval_msecs)\n{\n\tunsigned long elapsed = jiffies - *caller_jiffies;\n\n\tif (*caller_jiffies && elapsed <= msecs_to_jiffies(interval_msecs))\n\t\treturn false;\n\n\t*caller_jiffies = jiffies;\n\treturn true;\n}\nexport_symbol(printk_timed_ratelimit);\n\nstatic define_spinlock(dump_list_lock);\nstatic list_head(dump_list);\n\n\nint kmsg_dump_register(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -ebusy;\n\n\t\n\tif (!dumper->dump)\n\t\treturn -einval;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\t\n\tif (!dumper->registered) {\n\t\tdumper->registered = 1;\n\t\tlist_add_tail_rcu(&dumper->list, &dump_list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\n\treturn err;\n}\nexport_symbol_gpl(kmsg_dump_register);\n\n\nint kmsg_dump_unregister(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -einval;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\tif (dumper->registered) {\n\t\tdumper->registered = 0;\n\t\tlist_del_rcu(&dumper->list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\tsynchronize_rcu();\n\n\treturn err;\n}\nexport_symbol_gpl(kmsg_dump_unregister);\n\nstatic bool always_kmsg_dump;\nmodule_param_named(always_kmsg_dump, always_kmsg_dump, bool, s_irugo | s_iwusr);\n\n\nvoid kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dumper *dumper;\n\tunsigned long flags;\n\n\tif ((reason > kmsg_dump_oops) && !always_kmsg_dump)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list) {\n\t\tif (dumper->max_reason && reason > dumper->max_reason)\n\t\t\tcontinue;\n\n\t\t\n\t\tdumper->active = true;\n\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tdumper->cur_seq = clear_seq;\n\t\tdumper->cur_idx = clear_idx;\n\t\tdumper->next_seq = log_next_seq;\n\t\tdumper->next_idx = log_next_idx;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\t\t\n\t\tdumper->dump(dumper, reason);\n\n\t\t\n\t\tdumper->active = false;\n\t}\n\trcu_read_unlock();\n}\n\n\nbool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, 0, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}\n\n\nbool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\treturn ret;\n}\nexport_symbol_gpl(kmsg_dump_get_line);\n\n\nbool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t  char *buf, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tu64 seq;\n\tu32 idx;\n\tu64 next_seq;\n\tu32 next_idx;\n\tenum log_flags prev;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t\n\tif (dumper->cur_seq >= dumper->next_seq) {\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\tgoto out;\n\t}\n\n\t\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\tprev = 0;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, prev, true, null, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t\tprev = msg->flags;\n\t}\n\n\t\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\tprev = 0;\n\twhile (l > size && seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl -= msg_print_text(msg, prev, true, null, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t\tprev = msg->flags;\n\t}\n\n\t\n\tnext_seq = seq;\n\tnext_idx = idx;\n\n\tl = 0;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, prev, syslog, buf + l, size - l);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t\tprev = msg->flags;\n\t}\n\n\tdumper->next_seq = next_seq;\n\tdumper->next_idx = next_idx;\n\tret = true;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}\nexport_symbol_gpl(kmsg_dump_get_buffer);\n\n\nvoid kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}\n\n\nvoid kmsg_dump_rewind(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tkmsg_dump_rewind_nolock(dumper);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n}\nexport_symbol_gpl(kmsg_dump_rewind);\n\nstatic char dump_stack_arch_desc_str[128];\n\n\nvoid __init dump_stack_set_arch_desc(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(dump_stack_arch_desc_str, sizeof(dump_stack_arch_desc_str),\n\t\t  fmt, args);\n\tva_end(args);\n}\n\n\nvoid dump_stack_print_info(const char *log_lvl)\n{\n\tprintk(\"": 186, "\" ,\n\t\tnewcon->name, newcon->index);\n\tif (bcon &&\n\t    ((newcon->flags & (con_consdev | con_boot)) == con_consdev) &&\n\t    !keep_bootcon) {\n\t\t\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & con_boot)\n\t\t\t\tunregister_console(bcon);\n\t}\n}\nexport_symbol(register_console);\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"": 187, "\" - unable to \"": 188, "\" ------- ---------  - \"": 189, "\" ------------------------------------------\\n\"": 190, "\" -> [%p] \"": 191, "\" ... kernel command line filter set: force pass ... \"": 192, "\" 0x%p\"": 193, "\" 0x%pk\"": 194, "\" : \"": 195, "\" <\"": 196, "\" <- \"": 197, "\" <-\"": 198, "\" = \"": 199, "\" => \"": 200, "\" [ \"": 201, "\" [%p] {%s:%d}\\n\"": 202, "\" [%p] {%s}\\n\"": 203, "\" [%s]\"": 204, "\" [debug]\"": 205, "\" [last unloaded: %s]\"": 206, "\" \\n\"": 207, "\" \\t\"": 208, "\" a%d\"": 209, "\" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\"": 210, "\" active=%d/%d%s\\n\"": 211, "\" actual: \"": 212, "\" all direct dependencies:       %11lu\\n\"": 213, "\" alloced and written from above\\n\"": 214, "\" and \"": 215, "\" and 15 (pass and disconnect)\\n\"": 216, "\" auid=%u ses=%u\"": 217, "\" b=%ld\"": 218, "\" bd:%5ld\"": 219, "\" call or barrier ops missing for %s,\\n\"": 220, "\" cap_fe=%d cap_fver=%x\"": 221, "\" chain lookup hits:             %11llu\\n\"": 222, "\" chain lookup misses:           %11llu\\n\"": 223, "\" ci=%lu nci=%lu co=%lu ca=%lu\\n\"": 224, "\" cleared\\n\"": 225, "\" combined max dependencies:     %11u\\n\"": 226, "\" comm=\"": 227, "\" correct incorrect  % \"": 228, "\" cpu\"": 229, "\" cpu%d\\n\"": 230, "\" cpus=%*pbl\"": 231, "\" cwd=\"": 232, "\" cyclic checks:                 %11llu\\n\"": 233, "\" debug_locks:                   %11u\\n\"": 234, "\" dependency chain hlocks:       %11d [max: %lu]\\n\"": 235, "\" dependency chains:             %11lu [max: %lu]\\n\"": 236, "\" dev=%02x:%02x mode=%#ho\"": 237, "\" dir=\"": 238, "\" direct dependencies:           %11lu [max: %lu]\\n\"": 239, "\" disabled\\n\"": 240, "\" disables this message.\\n\"": 241, "\" dt=%d/%llx/%d df=%lu\"": 242, "\" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\"": 243, "\" enabled\"": 244, "\" euid=%u suid=%u fsuid=%u\"": 245, "\" exe=\"": 246, "\" exe=(null)\"": 247, "\" expected tramp: %lx\\n\"": 248, "\" fd:%5ld\"": 249, "\" fe=%d\"": 250, "\" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\"": 251, "\" field_string_func \"": 252, "\" field_string_ip;\n\t} else {\n\t\tfmt = \"": 253, "\" field_string_retip;\n\t}\n\n\t\n#define len_or_zero (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, len_or_zero, \"": 254, "\" find-mask backwards checks:    %11llu\\n\"": 255, "\" find-mask forwards checks:     %11llu\\n\"": 256, "\" flags=0x%x nice=%d\"": 257, "\" fmt\n\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/string.h>\n\n#include \"": 258, "\" fp%d=%s\"": 259, "\" grace periods expedited from boot/sysfs for %s,\\n\"": 260, "\" hardirq off events:            %11llu\\n\"": 261, "\" hardirq on events:             %11llu\\n\"": 262, "\" hardirq-read-safe locks:       %11lu\\n\"": 263, "\" hardirq-read-unsafe locks:     %11lu\\n\"": 264, "\" hardirq-safe locks:            %11lu\\n\"": 265, "\" hardirq-unsafe locks:          %11lu\\n\"": 266, "\" has parent\"": 267, "\" if %s\\n\"": 268, "\" ignoring it.\\n\"": 269, "\" in-hardirq chains:             %11u\\n\"": 270, "\" in-process chains:             %11u\\n\"": 271, "\" in-softirq chains:             %11u\\n\"": 272, "\" indirect dependencies:         %11lu\\n\"": 273, "\" inode=%lu\"": 274, "\" irq-read-safe locks:           %11lu\\n\"": 275, "\" irq-read-unsafe locks:         %11lu\\n\"": 276, "\" irq-safe locks:                %11lu\\n\"": 277, "\" irq-unsafe locks:              %11lu\\n\"": 278, "\" key=\"": 279, "\" kt=%d/%c ktl=%x\"": 280, "\" list=%d res=%d\"": 281, "\" list=%d res=1\"": 282, "\" lock-classes:                  %11lu [max: %lu]\\n\"": 283, "\" lock: %ps, .magic: %08x, .owner: %s/%d, \"": 284, "\" locked it.\\n\"": 285, "\" mag %x, put %p, usage %d, subscr %d\\n\"": 286, "\" manager: %d\"": 287, "\" max bfs queue depth:           %11u\\n\"": 288, "\" max locking depth:             %11u\\n\"": 289, "\" may be due to missing lock nesting notation\\n\\n\"": 290, "\" mayday\"": 291, "\" mems_allowed=%*pbl\\n\"": 292, "\" misfeature support will be removed\\n\"": 293, "\" miss \"": 294, "\" name=\"": 295, "\" name=(null)\"": 296, "\" nametype=\"": 297, "\" nestedness limit pid/tgid=%d/%d\\n\"": 298, "\" no tick device\\n\"": 299, "\" node=%d\"": 300, "\" obj=%s\"": 301, "\" obj=(none)\"": 302, "\" ocomm=\"": 303, "\" of=%lu\"": 304, "\" old-auid=%u auid=%u old-ses=%u ses=%u res=%d\"": 305, "\" old-log_passwd=%d new-log_passwd=%d res=%d\"": 306, "\" op=\"": 307, "\" op=tty_set old-enabled=%d new-enabled=%d\"": 308, "\" ops:%8ld\"": 309, "\" or \\\"^pat tern$\\\"\\n\"": 310, "\" osid=%u\"": 311, "\" ouid=%u ogid=%u rdev=%02x:%02x\"": 312, "\" p%d\"": 313, "\" path=\"": 314, "\" per=%lx\"": 315, "\" pid=%d comm=\"": 316, "\" possible unsafe locking scenario:\\n\\n\"": 317, "\" ppid=%d pid=%d auid=%u uid=%u gid=%u\"": 318, "\" probe to kernel_sched_migrate_task\\n\"": 319, "\" probe to kernel_sched_switch\\n\"": 320, "\" probe to kernel_sched_wakeup\\n\"": 321, "\" probe to kernel_sched_wakeup_new\\n\"": 322, "\" protection\"": 323, "\" ql=%ld/%ld qs=%c%c%c%c\"": 324, "\" r\"": 325, "\" r%d=%s\"": 326, "\" rcu barrier testing omitted from run.\\n\"": 327, "\" recorded size bytes:   %ld\\n\"": 328, "\" redundant hardirq offs:        %11llu\\n\"": 329, "\" redundant hardirq ons:         %11llu\\n\"": 330, "\" redundant softirq offs:        %11llu\\n\"": 331, "\" redundant softirq ons:         %11llu\\n\"": 332, "\" res=%d\"": 333, "\" res=0\"": 334, "\" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\"": 335, "\" sig=%ld\"": 336, "\" softirq off events:            %11llu\\n\"": 337, "\" softirq on events:             %11llu\\n\"": 338, "\" softirq-read-safe locks:       %11lu\\n\"": 339, "\" softirq-read-unsafe locks:     %11lu\\n\"": 340, "\" softirq-safe locks:            %11lu\\n\"": 341, "\" softirq-unsafe locks:          %11lu\\n\"": 342, "\" stack-trace entries:           %11lu [max: %lu]\\n\"": 343, "\" subj=%s\"": 344, "\" subsystem\\n\"": 345, "\" success=%s exit=%ld\"": 346, "\" suppressed,\\nuse 'ps a' to see all.\\n\"": 347, "\" testing of dynamic grace-period expediting diabled.\\n\"": 348, "\" threaded [<%p>] %pf\"": 349, "\" uncategorized locks:           %11lu\\n\"": 350, "\" unused locks:                  %11lu\\n\"": 351, "\" with dropped events, record len and size may not match\\n\"": 352, "\" workers=%d\"": 353, "\" zero suppressed\\n\"": 354, "\" {\"": 355, "\" |  \"": 356, "\" | \"": 357, "\"!!! \"": 358, "\"!!!\"": 359, "\"!\"": 360, "\"!=\"": 361, "\"!@#$%^&*()?+\\\\?+|:';\\\",.<>/?abcdefghijklmnopqrstuv\"": 362, "\"\"": 363, "\"#              | |       |          |         |   \"": 364, "\"#           task-pid    cpu#    timestamp  correct\"": 365, "\"#  stack tracer disabled\\n\"": 366, "\"#  |     |     |           |   |   |\\n\"": 367, "\"# available triggers:\\n\"": 368, "\"# bursts in flood, zero to disable\"": 369, "\"# callbacks per burst in flood\"": 370, "\"# dev   cpu timestamp     pid act flg\\n\"": 371, "\"# if no events are modified, an error message will be displayed here\"": 372, "\"# kernel command line\\n\"": 373, "\"# of callbacks/kthreads for barrier testing\"": 374, "\"# of writes between timestamp readings\"": 375, "\"# only events with the given fields will be affected.\\n\"": 376, "\"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"": 377, "\"# to enable the stack tracer, either add 'stacktrace' to the\\n\"": 378, "\"# use this to set filters for multiple events.\\n\"": 379, "\"### global filter ###\\n\"": 380, "\"#%.*s  _-----=> irqs-off        \\n\"": 381, "\"#%.*s / _----=> need-resched    \\n\"": 382, "\"#%.*s| / _---=> hardirq/softirq \\n\"": 383, "\"#%.*s|| / _--=> preempt-depth   \\n\"": 384, "\"#%.*s||| /                      \\n\"": 385, "\"#%d\"": 386, "\"#\\n\"": 387, "\"#subsys_name\\thierarchy\\tnum_cgroups\\tenabled\\n\"": 388, "\"$retval\"": 389, "\"$stack $stack0 +0($stack)\"": 390, "\"%%0%dlx \"": 391, "\"%%16.16l%c \"": 392, "\"%%2.2l%c \"": 393, "\"%%4.4l%c \"": 394, "\"%%8.8l%c \"": 395, "\"%*c\"": 396, "\"%*c[<%p>] %ps\\n\"": 397, "\"%*d: \"": 398, "\"%*pb\"": 399, "\"%*pb\\n\"": 400, "\"%*pbl\\n\"": 401, "\"%*s domain %d: \"": 402, "\"%*s groups:\"": 403, "\"%*s%0*llx-%0*llx : %s\\n\"": 404, "\"%-*s      pid   parent [*] cpu state %-*s command\\n\"": 405, "\"%-15.15s %-20.20s %s\\n\"": 406, "\"%-15.15s %-20s%s%s\\n\"": 407, "\"%-15.15s %c\"": 408, "\"%-20s%8u  0x%p \"": 409, "\"%-40s: %ld.%06ld\\n\"": 410, "\"%-40s: %ld\\n\"": 411, "\"%-45s:%14ld.%06ld\\n\"": 412, "\"%-45s:%21ld\\n\"": 413, "\"%016lx tail class: [%p] %s\\n\"": 414, "\"%016lx\"": 415, "\"%02ld:%02ld\\n\"": 416, "\"%02lx 0x%lx %d\\n\"": 417, "\"%02x \"": 418, "\"%08lx\"": 419, "\"%08x\"": 420, "\"%10u \"": 421, "\"%10u %10u %10u\\n\"": 422, "\"%14lu \"": 423, "\"%14s %14s\\n\"": 424, "\"%14s set\\n\"": 425, "\"%15ld %15ld %15ld.%06ld %15ld.%06ld %15ld.%06ld\"": 426, "\"%15s %5d %9ld.%06ld %9ld %5d \"": 427, "\"%16s %5d %3d %d %08x %08lx \"": 428, "\"%16s-%-5d [%03d] \"": 429, "\"%16s:%5d [%p, %3d]\"": 430, "\"%38s-r:\"": 431, "\"%38s-w:\"": 432, "\"%3d%cc=%ld g=%ld pq=%d/%d qp=%d\"": 433, "\"%3d%cnp=%ld \"": 434, "\"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \"": 435, "\"%3d,%-3d %2s %3s \"": 436, "\"%3ld) %8d   %5d   \"": 437, "\"%40s %14lu %29s %ps\\n\"": 438, "\"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"": 439, "\"%40s:\"": 440, "\"%4d \"": 441, "\"%5d \"": 442, "\"%5lu %5d %6d 0x%08lx\\n\"": 443, "\"%5lu.%06lu |  \"": 444, "\"%8.8s-%-5d %3d\"": 445, "\"%8lu %8lu \"": 446, "\"%9ld.%06ld %9ld.%06ld %9ld.%06ld\"": 447, "\"%=\"": 448, "\"%c\"": 449, "\"%c%c%c\"": 450, "\"%c:%s/%s\"": 451, "\"%c_%s_0x%lx\"": 452, "\"%d %d %c %d %d %d %c\\n\"": 453, "\"%d %d\"": 454, "\"%d day%s \"": 455, "\"%d idle process%s (state i)%s\\n\"": 456, "\"%d lock%s held by %s/%d:\\n\"": 457, "\"%d sleeping system daemon (state m) \"": 458, "\"%d\"": 459, "\"%d: %d: %s\\n\"": 460, "\"%d:%d tasks=%c%c%c%c kt=%c ntb=%lu neb=%lu nnb=%lu \"": 461, "\"%d:%d%s\"": 462, "\"%d\\n\"": 463, "\"%hhu\"": 464, "\"%hi\"": 465, "\"%hu\"": 466, "\"%i %lu %lu\"": 467, "\"%i\"": 468, "\"%i\\n\"": 469, "\"%ld\"": 470, "\"%ld\\n\"": 471, "\"%li\"": 472, "\"%lld\\n\"": 473, "\"%llu \"": 474, "\"%llu + %u <- (%d,%d) %llu\\n\"": 475, "\"%llu + %u [%d]\\n\"": 476, "\"%llu + %u [%s]\\n\"": 477, "\"%llu / %llu [%s]\\n\"": 478, "\"%llu [%d]\\n\"": 479, "\"%llu\"": 480, "\"%llu\\n\"": 481, "\"%llx\"": 482, "\"%lu\"": 483, "\"%lx %lx %lx %d %x %x\"": 484, "\"%lx %lx %lx %d %x\"": 485, "\"%lx %lx\\n\"": 486, "\"%lx/%lx->%lx %c%c>%c %d:%d ^%d    \"": 487, "\"%p  %s  %p \"": 488, "\"%p  %s  %s+0x%x  %s \"": 489, "\"%p\"": 490, "\"%p: %c%c nvcsw: %lu/%lu holdout: %d idle_cpu: %d/%d\\n\"": 491, "\"%pk %c %s\\n\"": 492, "\"%pk %c %s\\t[%s]\\n\"": 493, "\"%ps() {\\n\"": 494, "\"%ps();\\n\"": 495, "\"%ps: %s\"": 496, "\"%ps:\"": 497, "\"%ps:%ps\"": 498, "\"%ps:%s\"": 499, "\"%ps\\n\"": 500, "\"%s \"": 501, "\"%s %.*s %s\\n\"": 502, "\"%s %d%s:%pf\"": 503, "\"%s %lld\\n\"": 504, "\"%s %pf\"": 505, "\"%s %u\"": 506, "\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. nested cgroups may change behavior in the future.\\n\"": 507, "\"%s (%d): error creating kset\\n\"": 508, "\"%s (%d, #threads: %d)\\n\"": 509, "\"%s -> 0x%lx\\n\"": 510, "\"%s = \"": 511, "\"%s already dying\\n\"": 512, "\"%s bar(%d)\"": 513, "\"%s called for unknown object.\"": 514, "\"%s calls setitimer() with new_value null pointer.\"": 515, "\"%s cpuset=\"": 516, "\"%s depends on broadcast, but no broadcast function available\\n\"": 517, "\"%s didn't like hwirq-0x%lx to virq%i mapping (rc=%d)\\n\"": 518, "\"%s does not use %s!\\n\"": 519, "\"%s entered refrigerator\\n\"": 520, "\"%s kthread starved for %ld jiffies!\\n\"": 521, "\"%s left refrigerator\\n\"": 522, "\"%s type has no corresponding fetch method.\\n\"": 523, "\"%s unusing %s\\n\"": 524, "\"%s uses %s!\\n\"": 525, "\"%s\"": 526, "\"%s%s \"": 527, "\"%s%s per-cpu(idx=%d):\"": 528, "\"%s%s%s%s\\n\"": 529, "\"%s(\"": 530, "\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\"": 531, "\"%s(, %lx) called with null domain\\n\"": 532, "\"%s, func %p help %s\\n\"": 533, "\"%s,\"": 534, "\"%s-%ld\"": 535, "\"%s.%s\"": 536, "\"%s/%d [hc%u[%lu]:sc%u[%lu]:he%u:se%u] takes:\\n\"": 537, "\"%s/%d is deadlocking current task %s/%d\\n\\n\"": 538, "\"%s/%d is leaving the kernel with locks still held!\\n\"": 539, "\"%s/%d is trying to acquire lock:\\n\"": 540, "\"%s/%d is trying to contend lock (\"": 541, "\"%s/%d is trying to lock:\\n\"": 542, "\"%s/%d is trying to release lock (\"": 543, "\"%s/%d\"": 544, "\"%s/%d, %p\\n\"": 545, "\"%s/%s.%s\"": 546, "\"%s:  total: %lld  max/min: %ld/%ld %s  fail: %d %s\\n\"": 547, "\"%s: \"": 548, "\"%s: %016llx\"": 549, "\"%s: %02x\"": 550, "\"%s: %04x\"": 551, "\"%s: %08x\"": 552, "\"%s: %d\\n\"": 553, "\"%s: %lx%s\"": 554, "\"%s: %s: kernel tainted.\\n\"": 555, "\"%s: '%s'->init suspiciously returned %d, it should \"": 556, "\"%s: (\"": 557, "\"%s: (0x%lx <- 0x%lx)\"": 558, "\"%s: (0x%lx)\"": 559, "\"%s: 0x%%0%zulx%s\"": 560, "\"%s: ??\"": 561, "\"%s: `%s' invalid for parameter `%s'\\n\"": 562, "\"%s: `%s' too large for parameter `%s'\\n\"": 563, "\"%s: attempt to bring up cpu %u failed\\n\"": 564, "\"%s: attempt to take down cpu %u failed\\n\"": 565, "\"%s: bad constraints on qos?\\n\"": 566, "\"%s: bad qos param!\\n\"": 567, "\"%s: bp %d bp_enabled %d\\n\"": 568, "\"%s: bp_installed %d\\n\"": 569, "\"%s: can only take %i arguments\\n\"": 570, "\"%s: could not allocate %lu bytes percpu data\\n\"": 571, "\"%s: debug_kmalloc memory leak dah_first %d\\n\"": 572, "\"%s: delayed bp\\n\"": 573, "\"%s: disagrees about version of symbol %s\\n\"": 574, "\"%s: exports duplicate symbol %s\"": 575, "\"%s: failed to add %s, err=%d\\n\"": 576, "\"%s: failed to set breakpoint at 0x%lx\\n\"": 577, "\"%s: h_used %p size %d caller %p\\n\"": 578, "\"%s: h_used %p size %d\\n\"": 579, "\"%s: has both .ctors and .init_array.\\n\"": 580, "\"%s: ignoring obsolete parameters\\n\"": 581, "\"%s: loading module anyway...\\n\"": 582, "\"%s: module has bad taint, not creating trace events\\n\"": 583, "\"%s: module has no symbols (stripped?)\\n\"": 584, "\"%s: module is already loaded\\n\"": 585, "\"%s: module is from the staging directory, the quality \"": 586, "\"%s: module license '%s' taints kernel.\\n\"": 587, "\"%s: module sysfs not initialized\\n\"": 588, "\"%s: module verification failed: signature \"": 589, "\"%s: option '%s' enabled irq's!\\n\"": 590, "\"%s: out of memory loading\\n\"": 591, "\"%s: parameters '%s' after `--' ignored\\n\"": 592, "\"%s: per-cpu alignment %li > %li\\n\"": 593, "\"%s: please compile with -fno-common\\n\"": 594, "\"%s: string doesn't fit in %u chars.\\n\"": 595, "\"%s: string parameter too long\\n\"": 596, "\"%s: unknown parameter '%s' ignored\\n\"": 597, "\"%s: unknown parameter `%s'\\n\"": 598, "\"%s: unknown symbol %s (err %li)\\n\"": 599, "\"%s: version magic '%s' should be '%s'\\n\"": 600, "\"%s: wait state: %d ->state: %#lx\\n\"": 601, "\"%s:\"": 602, "\"%s:%d %s!\\n\"": 603, "\"%s:%s:%s\"": 604, "\"%s=%u old=%u\"": 605, "\"%s\\\" \\\"%s\\\"\\n\"": 606, "\"%s\\n\"": 607, "\"%s\\t%d\\t%d\\t%d\\n\"": 608, "\"%sname=%s\"": 609, "\"%sworkqueue: %s %pf\"": 610, "\"%u \"": 611, "\"%u\"": 612, "\"%u:%s:%s (%u)\"": 613, "\"%u:%u:%u  ==+ %u:%u:%u [%03u]\"": 614, "\"%u:%u:%u  ==> %u:%u:%u [%03u]\"": 615, "\"%u\\n\"": 616, "\"%x\"": 617, "\"%zu\\n\"": 618, "\"&\"": 619, "\"&&\"": 620, "\"&=\"": 621, "\"&struct->lockfield\"": 622, "\"'function_profile_enabled' entry\\n\"": 623, "\"'kprobe_events' entry\\n\"": 624, "\"'kprobe_profile' entry\\n\"": 625, "\"'trace_stat' entry\\n\"": 626, "\"(\"": 627, "\"(%02x) %s\\n\"": 628, "\"(%02x) %sr%d %s %s%d\\n\"": 629, "\"(%02x) %sr%d %s %sr%d\\n\"": 630, "\"(%02x) *(%s *)(r%d %+d) = %d\\n\"": 631, "\"(%02x) *(%s *)(r%d %+d) = r%d\\n\"": 632, "\"(%02x) call %d\\n\"": 633, "\"(%02x) exit\\n\"": 634, "\"(%02x) goto pc%+d\\n\"": 635, "\"(%02x) if r%d %s 0x%x goto pc%+d\\n\"": 636, "\"(%02x) if r%d %s r%d goto pc%+d\\n\"": 637, "\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\"": 638, "\"(%02x) r%d = *(%s *)(r%d %+d)\\n\"": 639, "\"(%02x) r%d = 0x%x\\n\"": 640, "\"(%02x) r0 = *(%s *)skb[%d]\\n\"": 641, "\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\"": 642, "\"(%d %d %d %d %d) \"": 643, "\"((((((((a == 1) && (b == 1)) || (c == 1)) && (d == 1)) || \"": 644, "\"((((((((a == 1) || (b == 1)) && (c == 1)) || (d == 1)) && \"": 645, "\"((a == 1 || b == 1) || (c == 1 || d == 1) || \"": 646, "\"(a == 1 && b == 1) && (c == 1 && d == 1) && \"": 647, "\"(a == 1 && b == 1) || (c == 1 && d == 1) || \"": 648, "\"(a == 1 || b == 1) && (c == 1 || d == 1) && \"": 649, "\"(detected by %d, t=%ld jiffies, g=%ld, c=%ld, q=%lu)\\n\"": 650, "\"(e == 1 && f == 1) || (g == 1 && h == 1)\"": 651, "\"(e == 1 || f == 1) && (g == 1 || h == 1)\"": 652, "\"(e == 1 || f == 1)) && (g == 1 || h == 1)\"": 653, "\"(e == 1)) && (f == 1)) || (g == 1)) && (h == 1))\"": 654, "\"(e == 1)) || (f == 1)) && (g == 1)) || (h == 1))\"": 655, "\"(incompatible version)\\n\"": 656, "\"(ks=%d,vs=%d)\"": 657, "\"(no arch support)\"": 658, "\"(none)\"": 659, "\"(null)\"": 660, "\"(out of memory)\\n\"": 661, "\"(rescuer)\"": 662, "\"(test in progress)\"": 663, "\"(u32) \"": 664, "\")\n};\n\n#ifdef config_debug_lock_alloc\n#include <linux/kernel_stat.h>\n\nint rcu_scheduler_active __read_mostly;\nexport_symbol_gpl(rcu_scheduler_active);\n\n\nvoid __init rcu_scheduler_starting(void)\n{\n\twarn_on(nr_context_switches() > 0);\n\trcu_scheduler_active = 1;\n}\n\n#endif \n\n#ifdef config_rcu_trace\n\nstatic void rcu_trace_sub_qlen(struct rcu_ctrlblk *rcp, int n)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcp->qlen -= n;\n\tlocal_irq_restore(flags);\n}\n\n\nstatic int show_tiny_stats(struct seq_file *m, void *unused)\n{\n\tseq_printf(m, \"": 665, "\")\n};\n\nstatic struct rcu_ctrlblk rcu_bh_ctrlblk = {\n\t.donetail\t= &rcu_bh_ctrlblk.rcucblist,\n\t.curtail\t= &rcu_bh_ctrlblk.rcucblist,\n\trcu_trace(.name = \"": 666, "\") == 0 || !strlen(glob)))\n\t\tglob = null;\n\telse if (glob) {\n\t\tint not;\n\n\t\ttype = filter_parse_regex(glob, strlen(glob), &search, &not);\n\t\tlen = strlen(search);\n\n\t\t\n\t\tif (warn_on(not))\n\t\t\treturn;\n\t}\n\n\tmutex_lock(&trace_probe_ops.func_hash->regex_lock);\n\n\thash = alloc_and_copy_ftrace_hash(ftrace_hash_default_bits, *orig_hash);\n\tif (!hash)\n\t\t\n\t\tgoto out_unlock;\n\n\tinit_list_head(&free_list);\n\n\tfor (i = 0; i < ftrace_func_hashsize; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\n\t\thlist_for_each_entry_safe(entry, tmp, hhd, node) {\n\n\t\t\t\n\t\t\tif ((flags & probe_test_func) && entry->ops != ops)\n\t\t\t\tcontinue;\n\n\t\t\tif ((flags & probe_test_data) && entry->data != data)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tif (glob) {\n\t\t\t\tkallsyms_lookup(entry->ip, null, null,\n\t\t\t\t\t\tnull, str);\n\t\t\t\tif (!ftrace_match(str, glob, len, type))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trec_entry = ftrace_lookup_ip(hash, entry->ip);\n\t\t\t\n\t\t\tif (rec_entry)\n\t\t\t\tfree_hash_entry(hash, rec_entry);\n\n\t\t\thlist_del_rcu(&entry->node);\n\t\t\tlist_add(&entry->free_list, &free_list);\n\t\t}\n\t}\n\tmutex_lock(&ftrace_lock);\n\t__disable_ftrace_function_probe();\n\t\n\tret = ftrace_hash_move(&trace_probe_ops, 1, orig_hash, hash);\n\tsynchronize_sched();\n\tif (!ret)\n\t\tfree_ftrace_hash_rcu(old_hash);\n\n\tlist_for_each_entry_safe(entry, p, &free_list, free_list) {\n\t\tlist_del(&entry->free_list);\n\t\tftrace_free_entry(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\t\t\n out_unlock:\n\tmutex_unlock(&trace_probe_ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n}\n\nvoid\nunregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,\n\t\t\t\tvoid *data)\n{\n\t__unregister_ftrace_function_probe(glob, ops, data,\n\t\t\t\t\t  probe_test_func | probe_test_data);\n}\n\nvoid\nunregister_ftrace_function_probe_func(char *glob, struct ftrace_probe_ops *ops)\n{\n\t__unregister_ftrace_function_probe(glob, ops, null, probe_test_func);\n}\n\nvoid unregister_ftrace_function_probe_all(char *glob)\n{\n\t__unregister_ftrace_function_probe(glob, null, null, 0);\n}\n\nstatic list_head(ftrace_commands);\nstatic define_mutex(ftrace_cmd_mutex);\n\n\n__init int register_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -ebusy;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &ftrace_commands);\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}\n\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -enodev;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}\n\nstatic int ftrace_process_regex(struct ftrace_hash *hash,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -einval;\n\n\tfunc = strsep(&next, \"": 667, "\") == 0 || strcmp(buff, \"": 668, "\") == 0)\n\t\tbuff[0] = 0;\n\n\t\n\tif (strcmp(buff, \"": 669, "\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"": 670, "\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"": 671, "\") == 0) {\n\t\tbuff[0] = 0;\n\t\tnot = 1;\n\t}\n\n\treturn match_records(hash, buff, strlen(buff), mod, not);\n}\n\n\n\nstatic int\nftrace_mod_callback(struct ftrace_hash *hash,\n\t\t    char *func, char *cmd, char *param, int enable)\n{\n\tchar *mod;\n\tint ret = -einval;\n\n\t\n\n\t\n\tif (!param)\n\t\treturn ret;\n\n\tmod = strsep(&param, \"": 672, "\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   kdb_enable_always_safe);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn kdb_notimp;\n\ts->command = kzalloc((s->count + 1) * sizeof(*(s->command)), gfp_kdb);\n\tif (!s->command) {\n\t\tkdb_printf(\"": 673, "\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~kdb_debug_flag_mask) {\n\t\t\tkdb_printf(\"": 674, "\") ?: \"": 675, "\") at:\\n\"": 676, "\")\"": 677, "\"))\n\t\t\treturn -einval;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"": 678, "\"))\n\t\thrtimer_hres_enabled = 0;\n\telse if (!strcmp(str, \"": 679, "\"))\n\t\thrtimer_hres_enabled = 1;\n\telse\n\t\treturn 0;\n\treturn 1;\n}\n\n__setup(\"": 680, "\"))\n\t\treturn;\n\n\t\n\tget_task_struct(p);\n\n\t__unqueue_futex(q);\n\t\n\tsmp_wmb();\n\tq->lock_ptr = null;\n\n\twake_up_state(p, task_normal);\n\tput_task_struct(p);\n}\n\nstatic int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)\n{\n\tstruct task_struct *new_owner;\n\tstruct futex_pi_state *pi_state = this->pi_state;\n\tu32 uninitialized_var(curval), newval;\n\tint ret = 0;\n\n\tif (!pi_state)\n\t\treturn -einval;\n\n\t\n\tif (pi_state->owner != current)\n\t\treturn -einval;\n\n\traw_spin_lock(&pi_state->pi_mutex.wait_lock);\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\n\t\n\tif (!new_owner)\n\t\tnew_owner = this->task;\n\n\t\n\tnewval = futex_waiters | task_pid_vnr(new_owner);\n\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\tret = -efault;\n\telse if (curval != uval)\n\t\tret = -einval;\n\tif (ret) {\n\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\t\treturn ret;\n\t}\n\n\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\twarn_on(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\n\traw_spin_lock_irq(&new_owner->pi_lock);\n\twarn_on(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock_irq(&new_owner->pi_lock);\n\n\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\trt_mutex_unlock(&pi_state->pi_mutex);\n\n\treturn 0;\n}\n\n\nstatic inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, single_depth_nesting);\n\t} else { \n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, single_depth_nesting);\n\t}\n}\n\nstatic inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}\n\n\nstatic int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = futex_key_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -einval;\n\n\tret = get_futex_key(uaddr, flags & flags_shared, &key, verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -einval;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\twake_futex(this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}\n\n\nstatic int\nfutex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t      int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = futex_key_init, key2 = futex_key_init;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\nretry:\n\tret = get_futex_key(uaddr1, flags & flags_shared, &key1, verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & flags_shared, &key2, verify_write);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\n\t\tdouble_unlock_hb(hb1, hb2);\n\n#ifndef config_mmu\n\t\t\n\t\tret = op_ret;\n\t\tgoto out_put_keys;\n#endif\n\n\t\tif (unlikely(op_ret != -efault)) {\n\t\t\tret = op_ret;\n\t\t\tgoto out_put_keys;\n\t\t}\n\n\t\tret = fault_in_user_writeable(uaddr2);\n\t\tif (ret)\n\t\t\tgoto out_put_keys;\n\n\t\tif (!(flags & flags_shared))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&key2);\n\t\tput_futex_key(&key1);\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (match_futex (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -einval;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\twake_futex(this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (match_futex (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -einval;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\twake_futex(this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret;\n}\n\n\nstatic inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t\n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\thb_waiters_dec(hb1);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\thb_waiters_inc(hb2);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tget_futex_key_refs(key2);\n\tq->key = *key2;\n}\n\n\nstatic inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\twarn_on(!q->rt_waiter);\n\tq->rt_waiter = null;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, task_normal);\n}\n\n\nstatic int futex_proxy_trylock_atomic(u32 __user *pifutex,\n\t\t\t\t struct futex_hash_bucket *hb1,\n\t\t\t\t struct futex_hash_bucket *hb2,\n\t\t\t\t union futex_key *key1, union futex_key *key2,\n\t\t\t\t struct futex_pi_state **ps, int set_waiters)\n{\n\tstruct futex_q *top_waiter = null;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -efault;\n\n\t\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -einval;\n\n\t\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t\treturn vpid;\n\t}\n\treturn ret;\n}\n\n\nstatic int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = futex_key_init, key2 = futex_key_init;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = null;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\n\tif (requeue_pi) {\n\t\t\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -einval;\n\n\t\t\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -enomem;\n\t\t\n\t\tif (nr_wake != 1)\n\t\t\treturn -einval;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & flags_shared, &key1, verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & flags_shared, &key2,\n\t\t\t    requeue_pi ? verify_write : verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -einval;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != null)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & flags_shared))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -eagain;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t\n\t\tif (ret > 0) {\n\t\t\twarn_on(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t\n\t\t\tret = lookup_pi_state(ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -efault:\n\t\t\tfree_pi_state(pi_state);\n\t\t\tpi_state = null;\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -eagain:\n\t\t\t\n\t\t\tfree_pi_state(pi_state);\n\t\t\tpi_state = null;\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\twake_futex(this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (requeue_pi) {\n\t\t\t\n\t\t\tatomic_inc(&pi_state->refcount);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t\n\t\t\t\tthis->pi_state = null;\n\t\t\t\tfree_pi_state(pi_state);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\nout_unlock:\n\tfree_pi_state(pi_state);\n\tdouble_unlock_hb(hb1, hb2);\n\thb_waiters_dec(hb2);\n\n\t\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}\n\n\nstatic inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); \n\treturn hb;\n}\n\nstatic inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}\n\n\nstatic inline void queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tint prio;\n\n\t\n\tprio = min(current->normal_prio, max_rt_prio);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n\tspin_unlock(&hb->lock);\n}\n\n\nstatic int unqueue_me(struct futex_q *q)\n{\n\tspinlock_t *lock_ptr;\n\tint ret = 0;\n\n\t\nretry:\n\tlock_ptr = q->lock_ptr;\n\tbarrier();\n\tif (lock_ptr != null) {\n\t\tspin_lock(lock_ptr);\n\t\t\n\t\tif (unlikely(lock_ptr != q->lock_ptr)) {\n\t\t\tspin_unlock(lock_ptr);\n\t\t\tgoto retry;\n\t\t}\n\t\t__unqueue_futex(q);\n\n\t\tbug_on(q->pi_state);\n\n\t\tspin_unlock(lock_ptr);\n\t\tret = 1;\n\t}\n\n\tdrop_futex_key_refs(&q->key);\n\treturn ret;\n}\n\n\nstatic void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tbug_on(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = null;\n\n\tspin_unlock(q->lock_ptr);\n}\n\n\nstatic int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *newowner)\n{\n\tu32 newtid = task_pid_vnr(newowner) | futex_waiters;\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tstruct task_struct *oldowner = pi_state->owner;\n\tu32 uval, uninitialized_var(curval), newval;\n\tint ret;\n\n\t\n\tif (!pi_state->owner)\n\t\tnewtid |= futex_owner_died;\n\n\t\nretry:\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\twhile (1) {\n\t\tnewval = (uval & futex_owner_died) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t\n\tif (pi_state->owner != null) {\n\t\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\t\twarn_on(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock_irq(&newowner->pi_lock);\n\twarn_on(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock_irq(&newowner->pi_lock);\n\treturn 0;\n\n\t\nhandle_fault:\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\n\t\n\tif (pi_state->owner != oldowner)\n\t\treturn 0;\n\n\tif (ret)\n\t\treturn ret;\n\n\tgoto retry;\n}\n\nstatic long futex_wait_restart(struct restart_block *restart);\n\n\nstatic int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tstruct task_struct *owner;\n\tint ret = 0;\n\n\tif (locked) {\n\t\t\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t\n\tif (q->pi_state->owner == current) {\n\t\t\n\t\tif (rt_mutex_trylock(&q->pi_state->pi_mutex)) {\n\t\t\tlocked = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t\n\t\traw_spin_lock(&q->pi_state->pi_mutex.wait_lock);\n\t\towner = rt_mutex_owner(&q->pi_state->pi_mutex);\n\t\tif (!owner)\n\t\t\towner = rt_mutex_next_owner(&q->pi_state->pi_mutex);\n\t\traw_spin_unlock(&q->pi_state->pi_mutex.wait_lock);\n\t\tret = fixup_pi_state_owner(uaddr, q, owner);\n\t\tgoto out;\n\t}\n\n\t\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current)\n\t\tprintk(kern_err \"": 681, "\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_recursive(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}\n\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\t\n\tif (irq_domain_is_auto_recursive(domain))\n\t\treturn 0;\n\n\tdomain = domain->parent;\n\tif (domain)\n\t\treturn irq_domain_alloc_irqs_recursive(domain, irq_base,\n\t\t\t\t\t\t       nr_irqs, arg);\n\treturn -enosys;\n}\n\n\nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\t\n\tif (!irq_domain_is_auto_recursive(domain) && domain->parent)\n\t\tirq_domain_free_irqs_recursive(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs);\n}\n\n\nvoid irq_domain_activate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (irq_data->parent_data)\n\t\t\tirq_domain_activate_irq(irq_data->parent_data);\n\t\tif (domain->ops->activate)\n\t\t\tdomain->ops->activate(domain, irq_data);\n\t}\n}\n\n\nvoid irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\tirq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t\n\tif (domain->ops->alloc)\n\t\tdomain->flags |= irq_domain_flag_hierarchy;\n}\n#else\t\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : null;\n}\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}\n#endif\t\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/osq_lock.h>\n\n\nstatic define_per_cpu_shared_aligned(struct optimistic_spin_node, osq_node);\n\n\nstatic inline int encode_cpu(int cpu_nr)\n{\n\treturn cpu_nr + 1;\n}\n\nstatic inline struct optimistic_spin_node *decode_cpu(int encoded_cpu_val)\n{\n\tint cpu_nr = encoded_cpu_val - 1;\n\n\treturn per_cpu_ptr(&osq_node, cpu_nr);\n}\n\n\nstatic inline struct optimistic_spin_node *\nosq_wait_next(struct optimistic_spin_queue *lock,\n\t      struct optimistic_spin_node *node,\n\t      struct optimistic_spin_node *prev)\n{\n\tstruct optimistic_spin_node *next = null;\n\tint curr = encode_cpu(smp_processor_id());\n\tint old;\n\n\t\n\told = prev ? prev->cpu : osq_unlocked_val;\n\n\tfor (;;) {\n\t\tif (atomic_read(&lock->tail) == curr &&\n\t\t    atomic_cmpxchg(&lock->tail, curr, old) == curr) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (node->next) {\n\t\t\tnext = xchg(&node->next, null);\n\t\t\tif (next)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax_lowlatency();\n\t}\n\n\treturn next;\n}\n\nbool osq_lock(struct optimistic_spin_queue *lock)\n{\n\tstruct optimistic_spin_node *node = this_cpu_ptr(&osq_node);\n\tstruct optimistic_spin_node *prev, *next;\n\tint curr = encode_cpu(smp_processor_id());\n\tint old;\n\n\tnode->locked = 0;\n\tnode->next = null;\n\tnode->cpu = curr;\n\n\told = atomic_xchg(&lock->tail, curr);\n\tif (old == osq_unlocked_val)\n\t\treturn true;\n\n\tprev = decode_cpu(old);\n\tnode->prev = prev;\n\twrite_once(prev->next, node);\n\n\t\n\n\twhile (!read_once(node->locked)) {\n\t\t\n\t\tif (need_resched())\n\t\t\tgoto unqueue;\n\n\t\tcpu_relax_lowlatency();\n\t}\n\treturn true;\n\nunqueue:\n\t\n\n\tfor (;;) {\n\t\tif (prev->next == node &&\n\t\t    cmpxchg(&prev->next, node, null) == node)\n\t\t\tbreak;\n\n\t\t\n\t\tif (smp_load_acquire(&node->locked))\n\t\t\treturn true;\n\n\t\tcpu_relax_lowlatency();\n\n\t\t\n\t\tprev = read_once(node->prev);\n\t}\n\n\t\n\n\tnext = osq_wait_next(lock, node, prev);\n\tif (!next)\n\t\treturn false;\n\n\t\n\n\twrite_once(next->prev, prev);\n\twrite_once(prev->next, next);\n\n\treturn false;\n}\n\nvoid osq_unlock(struct optimistic_spin_queue *lock)\n{\n\tstruct optimistic_spin_node *node, *next;\n\tint curr = encode_cpu(smp_processor_id());\n\n\t\n\tif (likely(atomic_cmpxchg(&lock->tail, curr, osq_unlocked_val) == curr))\n\t\treturn;\n\n\t\n\tnode = this_cpu_ptr(&osq_node);\n\tnext = xchg(&node->next, null);\n\tif (next) {\n\t\twrite_once(next->locked, 1);\n\t\treturn;\n\t}\n\n\tnext = osq_wait_next(lock, node, null);\n\tif (next)\n\t\twrite_once(next->locked, 1);\n}\n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/jhash.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/tracepoint.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/static_key.h>\n\nextern struct tracepoint * const __start___tracepoints_ptrs[];\nextern struct tracepoint * const __stop___tracepoints_ptrs[];\n\n\nstatic const int tracepoint_debug;\n\n#ifdef config_modules\n\nstatic define_mutex(tracepoint_module_list_mutex);\n\n\nstatic list_head(tracepoint_module_list);\n#endif \n\n\nstatic define_mutex(tracepoints_mutex);\n\n\nstruct tp_probes {\n\tstruct rcu_head rcu;\n\tstruct tracepoint_func probes[0];\n};\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), gfp_kernel);\n\treturn p == null ? null : p->probes;\n}\n\nstatic void rcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(kern_debug \"": 682, "\"))\n\t\tstrcpy(buf, \"": 683, "\")) {\n\t\tprintk(\"": 684, "\"),\n\t\t\t\tstate, false);\n\t\t\tevents_check_enabled = false;\n\t\t}\n\t\tsyscore_resume();\n\t}\n\n\tarch_suspend_enable_irqs();\n\tbug_on(irqs_disabled());\n\n enable_cpus:\n\tenable_nonboot_cpus();\n\n platform_wake:\n\tplatform_resume_noirq(state);\n\tdpm_resume_noirq(pmsg_resume);\n\n platform_early_resume:\n\tplatform_resume_early(state);\n\n devices_early_resume:\n\tdpm_resume_early(pmsg_resume);\n\n platform_finish:\n\tplatform_resume_finish(state);\n\treturn error;\n}\n\n\nint suspend_devices_and_enter(suspend_state_t state)\n{\n\tint error;\n\tbool wakeup = false;\n\n\tif (!sleep_state_supported(state))\n\t\treturn -enosys;\n\n\terror = platform_suspend_begin(state);\n\tif (error)\n\t\tgoto close;\n\n\tsuspend_console();\n\tsuspend_test_start();\n\terror = dpm_suspend_start(pmsg_suspend);\n\tif (error) {\n\t\tpr_err(\"": 685, "\"),\n\t\t\t\tstate, true);\n\t\t\terror = suspend_ops->enter(state);\n\t\t\ttrace_suspend_resume(tps(\"": 686, "\"),\n\t       init_utsname()->version);\n\n\tif (dump_stack_arch_desc_str[0] != '\\0')\n\t\tprintk(\"": 687, "\"), 0, false);\n\tif (!error)\n\t\treturn 0;\n\n\tsuspend_stats.failed_freeze++;\n\tdpm_save_failed_step(suspend_freeze);\n finish:\n\tpm_notifier_call_chain(pm_post_suspend);\n\tpm_restore_console();\n\treturn error;\n}\n\n\nvoid __weak arch_suspend_disable_irqs(void)\n{\n\tlocal_irq_disable();\n}\n\n\nvoid __weak arch_suspend_enable_irqs(void)\n{\n\tlocal_irq_enable();\n}\n\n\nstatic int suspend_enter(suspend_state_t state, bool *wakeup)\n{\n\tint error;\n\n\terror = platform_suspend_prepare(state);\n\tif (error)\n\t\tgoto platform_finish;\n\n\terror = dpm_suspend_late(pmsg_suspend);\n\tif (error) {\n\t\tprintk(kern_err \"": 688, "\"), 0, false);\n\n\tpr_debug(\"": 689, "\"), 0, true);\n\terror = suspend_freeze_processes();\n\ttrace_suspend_resume(tps(\"": 690, "\"), 0, true);\n\tprintk(kern_info \"": 691, "\"), state, false);\n\t\tgoto platform_wake;\n\t}\n\n\terror = disable_nonboot_cpus();\n\tif (error || suspend_test(test_cpus))\n\t\tgoto enable_cpus;\n\n\tarch_suspend_disable_irqs();\n\tbug_on(!irqs_disabled());\n\n\terror = syscore_suspend();\n\tif (!error) {\n\t\t*wakeup = pm_wakeup_pending();\n\t\tif (!(suspend_test(test_core) || *wakeup)) {\n\t\t\ttrace_suspend_resume(tps(\"": 692, "\"), state, false);\n\tpr_debug(\"": 693, "\"), state, false);\n\n close:\n\tplatform_resume_end(state);\n\treturn error;\n\n recover_platform:\n\tplatform_recover(state);\n\tgoto resume_devices;\n}\n\n\nstatic void suspend_finish(void)\n{\n\tsuspend_thaw_processes();\n\tpm_notifier_call_chain(pm_post_suspend);\n\tpm_restore_console();\n}\n\n\nstatic int enter_state(suspend_state_t state)\n{\n\tint error;\n\n\ttrace_suspend_resume(tps(\"": 694, "\"), state, true);\n\t\tfreeze_enter();\n\t\ttrace_suspend_resume(tps(\"": 695, "\"), state, true);\n\tif (state == pm_suspend_freeze) {\n#ifdef config_pm_debug\n\t\tif (pm_test_level != test_none && pm_test_level <= test_cpus) {\n\t\t\tpr_warning(\"": 696, "\"), state, true);\n\tresume_console();\n\ttrace_suspend_resume(tps(\"": 697, "\");\n\t\t\t\tkdb_state_set(doing_kgdb);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"": 698, "\");\n\t\t\t\tkdb_state_set(doing_kgdb);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}\n\n\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, cmd_buflen);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t\n\treturn kdb_read(buffer, bufsize);\n}\n\n\n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}\n\n\n\nstatic char kdb_buffer[256];\t\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\n\nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint saved_trap_printk;\n\tint got_printf_lock = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tchar *cp, *cp2, *cphold = null, replaced_byte = ' ';\n\tchar *moreprompt = \"": 699, "\");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += kdb_grepping_flag_search;\n\t\t\tsuspend_grep = 1; \n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t\n\t\t\tsuspend_grep = 1; \n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"": 700, "\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: \n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"": 701, "\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"": 702, "\");\n\t\t\terr = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\tdentry = relay_create_buf_file(chan, chan->buf[i], i);\n\t\tif (unlikely(!dentry)) {\n\t\t\terr = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (curr_cpu == i) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trelay_set_buf_dentry(chan->buf[i], dentry);\n\t\t\tlocal_irq_restore(flags);\n\t\t} else {\n\t\t\tdisp.buf = chan->buf[i];\n\t\t\tdisp.dentry = dentry;\n\t\t\tsmp_mb();\n\t\t\t\n\t\t\terr = smp_call_function_single(i,\n\t\t\t\t\t\t       __relay_set_buf_dentry,\n\t\t\t\t\t\t       &disp, 1);\n\t\t}\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\tput_cpu();\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn err;\n}\n\n\nsize_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\n{\n\tvoid *old, *new;\n\tsize_t old_subbuf, new_subbuf;\n\n\tif (unlikely(length > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\tif (buf->offset != buf->chan->subbuf_size + 1) {\n\t\tbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\n\t\told_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\t\tbuf->padding[old_subbuf] = buf->prev_padding;\n\t\tbuf->subbufs_produced++;\n\t\tif (buf->dentry)\n\t\t\td_inode(buf->dentry)->i_size +=\n\t\t\t\tbuf->chan->subbuf_size -\n\t\t\t\tbuf->padding[old_subbuf];\n\t\telse\n\t\t\tbuf->early_bytes += buf->chan->subbuf_size -\n\t\t\t\t\t    buf->padding[old_subbuf];\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&buf->read_wait))\n\t\t\t\n\t\t\tmod_timer(&buf->timer, jiffies + 1);\n\t}\n\n\told = buf->data;\n\tnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\tnew = buf->start + new_subbuf * buf->chan->subbuf_size;\n\tbuf->offset = 0;\n\tif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\n\t\tbuf->offset = buf->chan->subbuf_size + 1;\n\t\treturn 0;\n\t}\n\tbuf->data = new;\n\tbuf->padding[new_subbuf] = 0;\n\n\tif (unlikely(length + buf->offset > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\treturn length;\n\ntoobig:\n\tbuf->chan->last_toobig = length;\n\treturn 0;\n}\nexport_symbol_gpl(relay_switch_subbuf);\n\n\nvoid relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (cpu >= nr_cpus || !chan->buf[cpu] ||\n\t\t\t\t\tsubbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tbuf = chan->buf[cpu];\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}\nexport_symbol_gpl(relay_subbufs_consumed);\n\n\nvoid relay_close(struct rchan *chan)\n{\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && chan->buf[0])\n\t\trelay_close_buf(chan->buf[0]);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif (chan->buf[i])\n\t\t\t\trelay_close_buf(chan->buf[i]);\n\n\tif (chan->last_toobig)\n\t\tprintk(kern_warning \"": 703, "\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (kallsyms_symbol_next(p_tmp, i) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"": 704, "\");\n\t\t\tkdb_getstr(kdb_grep_string, kdb_grep_strlen,\n\t\t\t\t   kdbgetenv(\"": 705, "\");\n\t\t\tkdb_printf(\"": 706, "\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: \n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"": 707, "\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"": 708, "\");\n\t\t\tkdb_state_set(doing_kgdb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int kdb_read_get_key(char *buffer, size_t bufsize)\n{\n#define escape_udelay 1000\n#define escape_delay (2*1000000/escape_udelay) \n\tchar escape_data[5];\t\n\tchar *ped = escape_data;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_escape = null;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == null) {\n\t\t\t\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\t\tif (escape_delay == 2) {\n\t\t\t*ped = '\\0';\n\t\t\tped = escape_data;\n\t\t\t--escape_delay;\n\t\t}\n\t\tif (escape_delay == 1) {\n\t\t\tkey = *ped++;\n\t\t\tif (!*ped)\n\t\t\t\t--escape_delay;\n\t\t\tbreak;\n\t\t}\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(escape_udelay);\n\t\t\t\t--escape_delay;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bufsize <= 2) {\n\t\t\tif (key == '\\r')\n\t\t\t\tkey = '\\n';\n\t\t\t*buffer++ = key;\n\t\t\t*buffer = '\\0';\n\t\t\treturn -1;\n\t\t}\n\t\tif (escape_delay == 0 && key == '\\e') {\n\t\t\tescape_delay = escape_delay;\n\t\t\tped = escape_data;\n\t\t\tf_escape = f;\n\t\t}\n\t\tif (escape_delay) {\n\t\t\t*ped++ = key;\n\t\t\tif (f_escape != f) {\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ped - escape_data == 1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 2) {\n\t\t\t\t\n\t\t\t\tif (key != '[')\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 3) {\n\t\t\t\t\n\t\t\t\tint mapkey = 0;\n\t\t\t\tswitch (key) {\n\t\t\t\tcase 'a': \n\t\t\t\t\tmapkey = 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b': \n\t\t\t\t\tmapkey = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c': \n\t\t\t\t\tmapkey = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd': \n\t\t\t\t\tmapkey = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1': \n\t\t\t\tcase '3': \n\t\t\t\t\n\t\t\t\tcase '4':\n\t\t\t\t\tmapkey = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mapkey != -1) {\n\t\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 4) {\n\t\t\t\t\n\t\t\t\tint mapkey = 0;\n\t\t\t\tif (key == '~') {\n\t\t\t\t\tswitch (escape_data[2]) {\n\t\t\t\t\tcase '1': \n\t\t\t\t\t\tmapkey = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '3': \n\t\t\t\t\t\tmapkey = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '4': \n\t\t\t\t\t\tmapkey = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t}\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\t\n\t}\n\treturn key;\n}\n\n\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[cmd_buflen];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"": 709, "\");\n\t\t\tprint_name_offset(m, dev->set_state_oneshot);\n\t\t\tseq_printf(m, \"": 710, "\");\n\t\t\tprint_name_offset(m, dev->set_state_periodic);\n\t\t\tseq_printf(m, \"": 711, "\");\n\t\t\tprint_name_offset(m, dev->set_state_shutdown);\n\t\t\tseq_printf(m, \"": 712, "\");\n\t\t\tprint_name_offset(m, dev->tick_resume);\n\t\t\tseq_printf(m, \"": 713, "\");\n\t\t\tprint_stack_trace(class->usage_traces + bit, len);\n\t\t}\n\t}\n\tprintk(\"": 714, "\");\n\t\t\treturn -eagain;\n\t\t}\n#endif\n\t} else if (!valid_state(state)) {\n\t\treturn -einval;\n\t}\n\tif (!mutex_trylock(&pm_mutex))\n\t\treturn -ebusy;\n\n\tif (state == pm_suspend_freeze)\n\t\tfreeze_begin();\n\n\ttrace_suspend_resume(tps(\"": 715, "\");\n\t\t\tseq_printf(m, \"": 716, "\");\n\t\t\tsuspend_grep = 1; \n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"": 717, "\");\n\t\t\tsuspend_grep = 1; \n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"": 718, "\");\n\t\t\ttest_ftrace_alive(m);\n\t\t}\n\t\tif (iter->snapshot && trace_empty(iter))\n\t\t\tprint_snapshot_help(m, iter);\n\t\telse if (iter->trace && iter->trace->print_header)\n\t\t\titer->trace->print_header(m);\n\t\telse\n\t\t\ttrace_default_header(m);\n\n\t} else if (iter->leftover) {\n\t\t\n\t\tret = trace_print_seq(m, &iter->seq);\n\n\t\t\n\t\titer->leftover = ret;\n\n\t} else {\n\t\tprint_trace_line(iter);\n\t\tret = trace_print_seq(m, &iter->seq);\n\t\t\n\t\titer->leftover = ret;\n\t}\n\n\treturn 0;\n}\n\n\nstatic inline int tracing_get_cpu(struct inode *inode)\n{\n\tif (inode->i_cdev) \n\t\treturn (long)inode->i_cdev - 1;\n\treturn ring_buffer_all_cpus;\n}\n\nstatic const struct seq_operations tracer_seq_ops = {\n\t.start\t\t= s_start,\n\t.next\t\t= s_next,\n\t.stop\t\t= s_stop,\n\t.show\t\t= s_show,\n};\n\nstatic struct trace_iterator *\n__tracing_open(struct inode *inode, struct file *file, bool snapshot)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint cpu;\n\n\tif (tracing_disabled)\n\t\treturn err_ptr(-enodev);\n\n\titer = __seq_open_private(file, &tracer_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn err_ptr(-enomem);\n\n\titer->buffer_iter = kzalloc(sizeof(*iter->buffer_iter) * num_possible_cpus(),\n\t\t\t\t    gfp_kernel);\n\tif (!iter->buffer_iter)\n\t\tgoto release;\n\n\t\n\tmutex_lock(&trace_types_lock);\n\titer->trace = kzalloc(sizeof(*iter->trace), gfp_kernel);\n\tif (!iter->trace)\n\t\tgoto fail;\n\n\t*iter->trace = *tr->current_trace;\n\n\tif (!zalloc_cpumask_var(&iter->started, gfp_kernel))\n\t\tgoto fail;\n\n\titer->tr = tr;\n\n#ifdef config_tracer_max_trace\n\t\n\tif (tr->current_trace->print_max || snapshot)\n\t\titer->trace_buffer = &tr->max_buffer;\n\telse\n#endif\n\t\titer->trace_buffer = &tr->trace_buffer;\n\titer->snapshot = snapshot;\n\titer->pos = -1;\n\titer->cpu_file = tracing_get_cpu(inode);\n\tmutex_init(&iter->mutex);\n\n\t\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t\n\tif (ring_buffer_overruns(iter->trace_buffer->buffer))\n\t\titer->iter_flags |= trace_file_annotate;\n\n\t\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\titer->iter_flags |= trace_file_time_in_ns;\n\n\t\n\tif (!iter->snapshot)\n\t\ttracing_stop_tr(tr);\n\n\tif (iter->cpu_file == ring_buffer_all_cpus) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer->buffer_iter[cpu] =\n\t\t\t\tring_buffer_read_prepare(iter->trace_buffer->buffer, cpu);\n\t\t}\n\t\tring_buffer_read_prepare_sync();\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tring_buffer_read_start(iter->buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(iter, cpu);\n\t\t}\n\t} else {\n\t\tcpu = iter->cpu_file;\n\t\titer->buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter->trace_buffer->buffer, cpu);\n\t\tring_buffer_read_prepare_sync();\n\t\tring_buffer_read_start(iter->buffer_iter[cpu]);\n\t\ttracing_iter_reset(iter, cpu);\n\t}\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn iter;\n\n fail:\n\tmutex_unlock(&trace_types_lock);\n\tkfree(iter->trace);\n\tkfree(iter->buffer_iter);\nrelease:\n\tseq_release_private(inode, file);\n\treturn err_ptr(-enomem);\n}\n\nint tracing_open_generic(struct inode *inode, struct file *filp)\n{\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tfilp->private_data = inode->i_private;\n\treturn 0;\n}\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}\n\n\nstatic int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}\n\nstatic int tracing_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_iterator *iter;\n\tint cpu;\n\n\tif (!(file->f_mode & fmode_read)) {\n\t\ttrace_array_put(tr);\n\t\treturn 0;\n\t}\n\n\t\n\titer = m->private;\n\tmutex_lock(&trace_types_lock);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter->buffer_iter[cpu])\n\t\t\tring_buffer_read_finish(iter->buffer_iter[cpu]);\n\t}\n\n\tif (iter->trace && iter->trace->close)\n\t\titer->trace->close(iter);\n\n\tif (!iter->snapshot)\n\t\t\n\t\ttracing_start_tr(tr);\n\n\t__trace_array_put(tr);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tmutex_destroy(&iter->mutex);\n\tfree_cpumask_var(iter->started);\n\tkfree(iter->trace);\n\tkfree(iter->buffer_iter);\n\tseq_release_private(inode, file);\n\n\treturn 0;\n}\n\nstatic int tracing_release_generic_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\treturn 0;\n}\n\nstatic int tracing_single_release_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn single_release(inode, file);\n}\n\nstatic int tracing_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint ret = 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\t\n\tif ((file->f_mode & fmode_write) && (file->f_flags & o_trunc)) {\n\t\tint cpu = tracing_get_cpu(inode);\n\n\t\tif (cpu == ring_buffer_all_cpus)\n\t\t\ttracing_reset_online_cpus(&tr->trace_buffer);\n\t\telse\n\t\t\ttracing_reset(&tr->trace_buffer, cpu);\n\t}\n\n\tif (file->f_mode & fmode_read) {\n\t\titer = __tracing_open(inode, file, false);\n\t\tif (is_err(iter))\n\t\t\tret = ptr_err(iter);\n\t\telse if (trace_flags & trace_iter_latency_fmt)\n\t\t\titer->iter_flags |= trace_file_lat_fmt;\n\t}\n\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\n\nstatic bool\ntrace_ok_for_array(struct tracer *t, struct trace_array *tr)\n{\n\treturn (tr->flags & trace_array_fl_global) || t->allow_instances;\n}\n\n\nstatic struct tracer *\nget_tracer_for_array(struct trace_array *tr, struct tracer *t)\n{\n\twhile (t && !trace_ok_for_array(t, tr))\n\t\tt = t->next;\n\n\treturn t;\n}\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t = v;\n\n\t(*pos)++;\n\n\tif (t)\n\t\tt = get_tracer_for_array(tr, t->next);\n\n\treturn t;\n}\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tt = get_tracer_for_array(tr, trace_types);\n\tfor (; t && l < *pos; t = t_next(m, t, &l))\n\t\t\t;\n\n\treturn t;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&trace_types_lock);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct tracer *t = v;\n\n\tif (!t)\n\t\treturn 0;\n\n\tseq_puts(m, t->name);\n\tif (t->next)\n\t\tseq_putc(m, ' ');\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations show_traces_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};\n\nstatic int show_traces_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tret = seq_open(file, &show_traces_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = tr;\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_write_stub(struct file *filp, const char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nloff_t tracing_lseek(struct file *file, loff_t offset, int whence)\n{\n\tint ret;\n\n\tif (file->f_mode & fmode_read)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 0;\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_fops = {\n\t.open\t\t= tracing_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tracing_write_stub,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= tracing_release,\n};\n\nstatic const struct file_operations show_traces_fops = {\n\t.open\t\t= show_traces_open,\n\t.read\t\t= seq_read,\n\t.release\t= seq_release,\n\t.llseek\t\t= seq_lseek,\n};\n\n\nstatic define_mutex(tracing_cpumask_update_lock);\n\n\nstatic char mask_str[nr_cpus + 1];\n\nstatic ssize_t\ntracing_cpumask_read(struct file *filp, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct trace_array *tr = file_inode(filp)->i_private;\n\tint len;\n\n\tmutex_lock(&tracing_cpumask_update_lock);\n\n\tlen = snprintf(mask_str, count, \"": 719, "\");\n\t\t\n\t\tret = ftrace_set_func(table, count, ftrace_graph_max_funcs, func);\n\t\tif (ret)\n\t\t\tprintk(kern_debug \"": 720, "\");\n\t\t\n\t\ttsk->flags |= pf_exitpidone;\n\t\tset_current_state(task_uninterruptible);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  \n\t\n\tsmp_mb();\n\traw_spin_unlock_wait(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic()))\n\t\tpr_info(\"": 721, "\");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(\"": 722, "\");\n\t\t__print_lock_name(parent);\n\t\tprintk(\"": 723, "\");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(\"": 724, "\");\n\t\t__print_lock_name(source);\n\t\tprintk(\"": 725, "\");\n\t\t__print_lock_name(target);\n\t\tprintk(\"": 726, "\");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(\"": 727, "\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}\n\n\nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se,\n\t\t\t       struct sched_dl_entity *pi_se, u64 t)\n{\n\tu64 left, right;\n\n\t\n\tleft = (pi_se->dl_period >> dl_scale) * (dl_se->runtime >> dl_scale);\n\tright = ((dl_se->deadline - t) >> dl_scale) *\n\t\t(pi_se->dl_runtime >> dl_scale);\n\n\treturn dl_time_before(right, left);\n}\n\n\nstatic void update_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t     struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t\n\tif (dl_se->dl_new) {\n\t\tsetup_new_dl_entity(dl_se, pi_se);\n\t\treturn;\n\t}\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n}\n\n\nstatic int start_dl_timer(struct sched_dl_entity *dl_se, bool boosted)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\tktime_t now, act;\n\tktime_t soft, hard;\n\tunsigned long range;\n\ts64 delta;\n\n\tif (boosted)\n\t\treturn 0;\n\t\n\tact = ns_to_ktime(dl_se->deadline);\n\tnow = hrtimer_cb_get_time(&dl_se->dl_timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\thrtimer_set_expires(&dl_se->dl_timer, act);\n\n\tsoft = hrtimer_get_softexpires(&dl_se->dl_timer);\n\thard = hrtimer_get_expires(&dl_se->dl_timer);\n\trange = ktime_to_ns(ktime_sub(hard, soft));\n\t__hrtimer_start_range_ns(&dl_se->dl_timer, soft,\n\t\t\t\t range, hrtimer_mode_abs, 0);\n\n\treturn hrtimer_active(&dl_se->dl_timer);\n}\n\n\nstatic enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tunsigned long flags;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &flags);\n\n\t\n\tif (!dl_task(p) || dl_se->dl_new ||\n\t    dl_se->dl_boosted || !dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n#ifdef config_smp\n\t\n\tif (unlikely(!rq->online)) {\n\t\tdl_task_offline_migration(rq, p);\n\t\tgoto unlock;\n\t}\n#endif\n\n\t\n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se, dl_se);\n\t\tgoto unlock;\n\t}\n\n\tenqueue_task_dl(rq, p, enqueue_replenish);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n#ifdef config_smp\n\t\n\tif (has_pushable_dl_tasks(rq))\n\t\tpush_dl_task(rq);\n#endif\nunlock:\n\ttask_rq_unlock(rq, p, &flags);\n\n\treturn hrtimer_norestart;\n}\n\nvoid init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, clock_monotonic, hrtimer_mode_rel);\n\ttimer->function = dl_task_timer;\n}\n\nstatic\nint dl_runtime_exceeded(struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}\n\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t\n\tdelta_exec = rq_clock_task(rq) - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0))\n\t\treturn;\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = rq_clock_task(rq);\n\tcpuacct_charge(curr, delta_exec);\n\n\tsched_rt_avg_update(rq, delta_exec);\n\n\tdl_se->runtime -= dl_se->dl_yielded ? 0 : delta_exec;\n\tif (dl_runtime_exceeded(rq, dl_se)) {\n\t\tdl_se->dl_throttled = 1;\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(!start_dl_timer(dl_se, curr->dl.dl_boosted)))\n\t\t\tenqueue_task_dl(rq, curr, enqueue_replenish);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}\n\n#ifdef config_smp\n\nstatic struct task_struct *pick_next_earliest_dl_task(struct rq *rq, int cpu);\n\nstatic inline u64 next_deadline(struct rq *rq)\n{\n\tstruct task_struct *next = pick_next_earliest_dl_task(rq, rq->cpu);\n\n\tif (next && dl_prio(next->prio))\n\t\treturn next->dl.deadline;\n\telse\n\t\treturn 0;\n}\n\nstatic void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\t\n\t\tdl_rq->earliest_dl.next = dl_rq->earliest_dl.curr;\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline, 1);\n\t} else if (dl_rq->earliest_dl.next == 0 ||\n\t\t   dl_time_before(deadline, dl_rq->earliest_dl.next)) {\n\t\t\n\t\tdl_rq->earliest_dl.next = next_deadline(rq);\n\t}\n}\n\nstatic void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t\n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, 0, 0);\n\t} else {\n\t\tstruct rb_node *leftmost = dl_rq->rb_leftmost;\n\t\tstruct sched_dl_entity *entry;\n\n\t\tentry = rb_entry(leftmost, struct sched_dl_entity, rb_node);\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tdl_rq->earliest_dl.next = next_deadline(rq);\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline, 1);\n\t}\n}\n\n#else\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}\n\n#endif \n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\twarn_on(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\twarn_on(!dl_prio(prio));\n\twarn_on(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rb_node **link = &dl_rq->rb_root.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct sched_dl_entity *entry;\n\tint leftmost = 1;\n\n\tbug_on(!rb_empty_node(&dl_se->rb_node));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_dl_entity, rb_node);\n\t\tif (dl_time_before(dl_se->deadline, entry->deadline))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tdl_rq->rb_leftmost = &dl_se->rb_node;\n\n\trb_link_node(&dl_se->rb_node, parent, link);\n\trb_insert_color(&dl_se->rb_node, &dl_rq->rb_root);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (rb_empty_node(&dl_se->rb_node))\n\t\treturn;\n\n\tif (dl_rq->rb_leftmost == &dl_se->rb_node) {\n\t\tstruct rb_node *next_node;\n\n\t\tnext_node = rb_next(&dl_se->rb_node);\n\t\tdl_rq->rb_leftmost = next_node;\n\t}\n\n\trb_erase(&dl_se->rb_node, &dl_rq->rb_root);\n\trb_clear_node(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se,\n\t\t  struct sched_dl_entity *pi_se, int flags)\n{\n\tbug_on(on_dl_rq(dl_se));\n\n\t\n\tif (dl_se->dl_new || flags & enqueue_wakeup)\n\t\tupdate_dl_entity(dl_se, pi_se);\n\telse if (flags & enqueue_replenish)\n\t\treplenish_dl_entity(dl_se, pi_se);\n\n\t__enqueue_dl_entity(dl_se);\n}\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t\n\tif (pi_task && p->dl.dl_boosted && dl_prio(pi_task->normal_prio)) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t\n\t\tbug_on(!p->dl.dl_boosted || flags != enqueue_replenish);\n\t\treturn;\n\t}\n\n\t\n\tif (p->dl.dl_throttled && !(flags & enqueue_replenish))\n\t\treturn;\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}\n\nstatic void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n}\n\n\nstatic void yield_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\t\n\tif (p->dl.runtime > 0) {\n\t\trq->curr->dl.dl_yielded = 1;\n\t\tp->dl.runtime = 0;\n\t}\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t\n\trq_clock_skip_update(rq, true);\n}\n\n#ifdef config_smp\n\nstatic int find_later_rq(struct task_struct *task);\n\nstatic int\nselect_task_rq_dl(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\tstruct task_struct *curr;\n\tstruct rq *rq;\n\n\tif (sd_flag != sd_balance_wake)\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = access_once(rq->curr); \n\n\t\n\tif (unlikely(dl_task(curr)) &&\n\t    (curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t    (p->nr_cpus_allowed > 1)) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1)\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    cpudl_find(&rq->rd->cpudl, rq->curr, null) == -1)\n\t\treturn;\n\n\t\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, null) != -1)\n\t\treturn;\n\n\tresched_curr(rq);\n}\n\nstatic int pull_dl_task(struct rq *this_rq);\n\n#endif \n\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef config_smp\n\t\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif \n}\n\n#ifdef config_sched_hrtick\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}\n#else \nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}\n#endif\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = dl_rq->rb_leftmost;\n\n\tif (!left)\n\t\treturn null;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}\n\nstruct task_struct *pick_next_task_dl(struct rq *rq, struct task_struct *prev)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct task_struct *p;\n\tstruct dl_rq *dl_rq;\n\n\tdl_rq = &rq->dl;\n\n\tif (need_pull_dl_task(rq, prev)) {\n\t\tpull_dl_task(rq);\n\t\t\n\t\tif (rq->stop && task_on_rq_queued(rq->stop))\n\t\t\treturn retry_task;\n\t}\n\n\t\n\tif (prev->sched_class == &dl_sched_class)\n\t\tupdate_curr_dl(rq);\n\n\tif (unlikely(!dl_rq->dl_nr_running))\n\t\treturn null;\n\n\tput_prev_task(rq, prev);\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tbug_on(!dl_se);\n\n\tp = dl_task_of(dl_se);\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t\n       dequeue_pushable_dl_task(rq, p);\n\n\tif (hrtick_enabled(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tset_post_schedule(rq);\n\n\treturn p;\n}\n\nstatic void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tupdate_curr_dl(rq);\n\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}\n\nstatic void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\t\n\tif (hrtick_enabled(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}\n\nstatic void task_fork_dl(struct task_struct *p)\n{\n\t\n}\n\nstatic void task_dead_dl(struct task_struct *p)\n{\n\tstruct hrtimer *timer = &p->dl.dl_timer;\n\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\n\traw_spin_lock_irq(&dl_b->lock);\n\t\n\tdl_b->total_bw -= p->dl.dl_bw;\n\traw_spin_unlock_irq(&dl_b->lock);\n\n\thrtimer_cancel(timer);\n}\n\nstatic void set_curr_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t\n\tdequeue_pushable_dl_task(rq, p);\n}\n\n#ifdef config_smp\n\n\n#define dl_max_tries 3\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, tsk_cpus_allowed(p)))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic struct task_struct *pick_next_earliest_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.rb_leftmost;\n\tstruct sched_dl_entity *dl_se;\n\tstruct task_struct *p = null;\n\nnext_node:\n\tnext_node = rb_next(next_node);\n\tif (next_node) {\n\t\tdl_se = rb_entry(next_node, struct sched_dl_entity, rb_node);\n\t\tp = dl_task_of(dl_se);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tgoto next_node;\n\t}\n\n\treturn null;\n}\n\nstatic define_per_cpu(cpumask_var_t, local_cpu_mask_dl);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint best_cpu, cpu = task_cpu(task);\n\n\t\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t\n\tbest_cpu = cpudl_find(&task_rq(task)->rd->cpudl,\n\t\t\ttask, later_mask);\n\tif (best_cpu == -1)\n\t\treturn -1;\n\n\t\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & sd_wake_affine) {\n\n\t\t\t\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (best_cpu < nr_cpu_ids &&\n\t\t\t    cpumask_test_cpu(best_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}\n\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = null;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < dl_max_tries; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\t\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu,\n\t\t\t\t                       &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = null;\n\t}\n\n\treturn later_rq;\n}\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn null;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tbug_on(rq->cpu != task_cpu(p));\n\tbug_on(task_current(rq, p));\n\tbug_on(p->nr_cpus_allowed <= 1);\n\n\tbug_on(!task_on_rq_queued(p));\n\tbug_on(!dl_task(p));\n\n\treturn p;\n}\n\n\nstatic int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\tif (unlikely(next_task == rq->curr)) {\n\t\twarn_on(1);\n\t\treturn 0;\n\t}\n\n\t\n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\t\n\tget_task_struct(next_task);\n\n\t\n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t\n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task_cpu(next_task) == rq->cpu && task == next_task) {\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t\n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tset_task_cpu(next_task, later_rq->cpu);\n\tactivate_task(later_rq, next_task, 0);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t\n\twhile (push_dl_task(rq))\n\t\t;\n}\n\nstatic int pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, ret = 0, cpu;\n\tstruct task_struct *p;\n\tstruct rq *src_rq;\n\tu64 dmin = long_max;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn 0;\n\n\t\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_next_earliest_dl_task(src_rq, this_cpu);\n\n\t\t\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\twarn_on(p == src_rq->curr);\n\t\t\twarn_on(!task_on_rq_queued(p));\n\n\t\t\t\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tret = 1;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\treturn ret;\n}\n\nstatic void post_schedule_dl(struct rq *rq)\n{\n\tpush_dl_tasks(rq);\n}\n\n\nstatic void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_running(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    has_pushable_dl_tasks(rq) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}\n\nstatic void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tconst struct cpumask *new_mask)\n{\n\tstruct rq *rq;\n\tstruct root_domain *src_rd;\n\tint weight;\n\n\tbug_on(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t\n\tif (!cpumask_intersects(src_rd->span, new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t\n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_clear(src_dl_b, p->dl.dl_bw);\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\t\n\tif (!on_dl_rq(&p->dl))\n\t\treturn;\n\n\tweight = cpumask_weight(new_mask);\n\n\t\n\tif ((p->nr_cpus_allowed > 1) == (weight > 1))\n\t\treturn;\n\n\t\n\tif (weight <= 1) {\n\t\tif (!task_current(rq, p))\n\t\t\tdequeue_pushable_dl_task(rq, p);\n\t\tbug_on(!rq->dl.dl_nr_migratory);\n\t\trq->dl.dl_nr_migratory--;\n\t} else {\n\t\tif (!task_current(rq, p))\n\t\t\tenqueue_pushable_dl_task(rq, p);\n\t\trq->dl.dl_nr_migratory++;\n\t}\n\n\tupdate_dl_migration(&rq->dl);\n}\n\n\nstatic void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr, 1);\n}\n\n\nstatic void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_set(&rq->rd->cpudl, rq->cpu, 0, 0);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}\n\nvoid init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tgfp_kernel, cpu_to_node(i));\n}\n\n#endif \n\n\nstatic void cancel_dl_timer(struct rq *rq, struct task_struct *p)\n{\n\tstruct hrtimer *dl_timer = &p->dl.dl_timer;\n\n\t\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (hrtimer_active(dl_timer)) {\n\t\tint ret = hrtimer_try_to_cancel(dl_timer);\n\n\t\tif (unlikely(ret == -1)) {\n\t\t\t\n\t\t\traw_spin_unlock(&rq->lock);\n\t\t\thrtimer_cancel(dl_timer);\n\t\t\traw_spin_lock(&rq->lock);\n\t\t}\n\t}\n}\n\nstatic void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t\n\tcancel_dl_timer(rq, p);\n\t__dl_clear_params(p);\n\n\t\n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tif (pull_dl_task(rq))\n\t\tresched_curr(rq);\n}\n\n\nstatic void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tint check_resched = 1;\n\n\tif (task_on_rq_queued(p) && rq->curr != p) {\n#ifdef config_smp\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded &&\n\t\t\tpush_dl_task(rq) && rq != task_rq(p))\n\t\t\t\n\t\t\tcheck_resched = 0;\n#endif \n\t\tif (check_resched) {\n\t\t\tif (dl_task(rq->curr))\n\t\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\t\telse\n\t\t\t\tresched_curr(rq);\n\t\t}\n\t}\n}\n\n\nstatic void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (task_on_rq_queued(p) || rq->curr == p) {\n#ifdef config_smp\n\t\t\n\t\tif (!rq->dl.overloaded)\n\t\t\tpull_dl_task(rq);\n\n\t\t\n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline) &&\n\t\t    rq->curr == p)\n\t\t\tresched_curr(rq);\n#else\n\t\t\n\t\tresched_curr(rq);\n#endif \n\t} else\n\t\tswitched_to_dl(rq, p);\n}\n\nconst struct sched_class dl_sched_class = {\n\t.next\t\t\t= &rt_sched_class,\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\n#ifdef config_smp\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.post_schedule\t\t= post_schedule_dl,\n\t.task_woken\t\t= task_woken_dl,\n#endif\n\n\t.set_curr_task\t\t= set_curr_task_dl,\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\t.task_dead\t\t= task_dead_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\n#ifdef config_sched_debug\nextern void print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq);\n\nvoid print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}\n#endif \n\n\n#include <linux/latencytop.h>\n#include <linux/sched.h>\n#include <linux/cpumask.h>\n#include <linux/cpuidle.h>\n#include <linux/slab.h>\n#include <linux/profile.h>\n#include <linux/interrupt.h>\n#include <linux/mempolicy.h>\n#include <linux/migrate.h>\n#include <linux/task_work.h>\n\n#include <trace/events/sched.h>\n\n#include \"": 728, "\");\n\t\telse\n\t\t\tseq_puts(m, \"": 729, "\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}\n\nstatic void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef config_function_graph_tracer\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif \n}\n\nint ftrace_regex_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct trace_parser *parser;\n\tint filter_hash;\n\tint ret;\n\n\tif (file->f_mode & fmode_read) {\n\t\titer = m->private;\n\t\tseq_release(inode, file);\n\t} else\n\t\titer = file->private_data;\n\n\tparser = &iter->parser;\n\tif (trace_parser_loaded(parser)) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tftrace_match_records(iter->hash, parser->buffer, parser->idx);\n\t}\n\n\ttrace_parser_put(parser);\n\n\tmutex_lock(&iter->ops->func_hash->regex_lock);\n\n\tif (file->f_mode & fmode_write) {\n\t\tfilter_hash = !!(iter->flags & ftrace_iter_filter);\n\n\t\tif (filter_hash)\n\t\t\torig_hash = &iter->ops->func_hash->filter_hash;\n\t\telse\n\t\t\torig_hash = &iter->ops->func_hash->notrace_hash;\n\n\t\tmutex_lock(&ftrace_lock);\n\t\told_hash = *orig_hash;\n\t\told_hash_ops.filter_hash = iter->ops->func_hash->filter_hash;\n\t\told_hash_ops.notrace_hash = iter->ops->func_hash->notrace_hash;\n\t\tret = ftrace_hash_move(iter->ops, filter_hash,\n\t\t\t\t       orig_hash, iter->hash);\n\t\tif (!ret) {\n\t\t\tftrace_ops_update_code(iter->ops, &old_hash_ops);\n\t\t\tfree_ftrace_hash_rcu(old_hash);\n\t\t}\n\t\tmutex_unlock(&ftrace_lock);\n\t}\n\n\tmutex_unlock(&iter->ops->func_hash->regex_lock);\n\tfree_ftrace_hash(iter->hash);\n\tkfree(iter);\n\n\treturn 0;\n}\n\nstatic const struct file_operations ftrace_avail_fops = {\n\t.open = ftrace_avail_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic const struct file_operations ftrace_enabled_fops = {\n\t.open = ftrace_enabled_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic const struct file_operations ftrace_filter_fops = {\n\t.open = ftrace_filter_open,\n\t.read = seq_read,\n\t.write = ftrace_filter_write,\n\t.llseek = tracing_lseek,\n\t.release = ftrace_regex_release,\n};\n\nstatic const struct file_operations ftrace_notrace_fops = {\n\t.open = ftrace_notrace_open,\n\t.read = seq_read,\n\t.write = ftrace_notrace_write,\n\t.llseek = tracing_lseek,\n\t.release = ftrace_regex_release,\n};\n\n#ifdef config_function_graph_tracer\n\nstatic define_mutex(graph_lock);\n\nint ftrace_graph_count;\nint ftrace_graph_notrace_count;\nunsigned long ftrace_graph_funcs[ftrace_graph_max_funcs] __read_mostly;\nunsigned long ftrace_graph_notrace_funcs[ftrace_graph_max_funcs] __read_mostly;\n\nstruct ftrace_graph_data {\n\tunsigned long *table;\n\tsize_t size;\n\tint *count;\n\tconst struct seq_operations *seq_ops;\n};\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tif (*pos >= *fgd->count)\n\t\treturn null;\n\treturn &fgd->table[*pos];\n}\n\nstatic void *\ng_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}\n\nstatic void *g_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tmutex_lock(&graph_lock);\n\n\t\n\tif (!*fgd->count && !*pos)\n\t\treturn (void *)1;\n\n\treturn __g_next(m, pos);\n}\n\nstatic void g_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&graph_lock);\n}\n\nstatic int g_show(struct seq_file *m, void *v)\n{\n\tunsigned long *ptr = v;\n\n\tif (!ptr)\n\t\treturn 0;\n\n\tif (ptr == (unsigned long *)1) {\n\t\tstruct ftrace_graph_data *fgd = m->private;\n\n\t\tif (fgd->table == ftrace_graph_funcs)\n\t\t\tseq_puts(m, \"": 730, "\");\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"": 731, "\");\n\t\tgoto platform_early_resume;\n\t}\n\terror = platform_suspend_prepare_noirq(state);\n\tif (error)\n\t\tgoto platform_wake;\n\n\tif (suspend_test(test_platform))\n\t\tgoto platform_wake;\n\n\t\n\tif (state == pm_suspend_freeze) {\n\t\ttrace_suspend_resume(tps(\"": 732, "\");\n\t\tgoto platform_finish;\n\t}\n\terror = platform_suspend_prepare_late(state);\n\tif (error)\n\t\tgoto devices_early_resume;\n\n\terror = dpm_suspend_noirq(pmsg_suspend);\n\tif (error) {\n\t\tprintk(kern_err \"": 733, "\");\n\t\tgoto recover_platform;\n\t}\n\tsuspend_test_finish(\"": 734, "\");\n\t\tif (moreprompt == null)\n\t\t\tmoreprompt = \"": 735, "\");\n\t\tif (rec->flags & ftrace_fl_tramp_en) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops)\n\t\t\t\tseq_printf(m, \"": 736, "\");\n\t\titer.cpu_file = ring_buffer_all_cpus;\n\t}\n\n\tprintk(kern_trace \"": 737, "\");\n\t\tkdb_defcmd2(\"": 738, "\");\n\t\tprint_name_offset(m, (unsigned long)entry->expire_func);\n\t\tseq_puts(m, \"": 739, "\");\n\t\tprint_name_offset(m, dev->set_mode);\n\t\tseq_printf(m, \"": 740, "\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"": 741, "\");\n\t\tprintk(\"": 742, "\");\n\t\treturn -enosys;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"": 743, "\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"": 744, "\");\n\t\treturn 0;\n\t}\n\n\trec = iter->func;\n\n\tif (!rec)\n\t\treturn 0;\n\n\tseq_printf(m, \"": 745, "\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"": 746, "\");\n\t\treturn boot_override_clocksource(\"": 747, "\");\n\t\treturn buffer;\n\tcase 4: \n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"": 748, "\");\n\t\treturn err_ptr(-enomem);\n\t}\n\n\treturn null;\n}\n\nextern struct trace_enum_map *__start_ftrace_enum_maps[];\nextern struct trace_enum_map *__stop_ftrace_enum_maps[];\n\nstatic void __init trace_enum_init(void)\n{\n\tint len;\n\n\tlen = __stop_ftrace_enum_maps - __start_ftrace_enum_maps;\n\ttrace_insert_enum_map(null, __start_ftrace_enum_maps, len);\n}\n\n#ifdef config_modules\nstatic void trace_module_add_enums(struct module *mod)\n{\n\tif (!mod->num_trace_enums)\n\t\treturn;\n\n\t\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn;\n\n\ttrace_insert_enum_map(mod, mod->trace_enums, mod->num_trace_enums);\n}\n\n#ifdef config_trace_enum_map_file\nstatic void trace_module_remove_enums(struct module *mod)\n{\n\tunion trace_enum_map_item *map;\n\tunion trace_enum_map_item **last = &trace_enum_maps;\n\n\tif (!mod->num_trace_enums)\n\t\treturn;\n\n\tmutex_lock(&trace_enum_mutex);\n\n\tmap = trace_enum_maps;\n\n\twhile (map) {\n\t\tif (map->head.mod == mod)\n\t\t\tbreak;\n\t\tmap = trace_enum_jmp_to_tail(map);\n\t\tlast = &map->tail.next;\n\t\tmap = map->tail.next;\n\t}\n\tif (!map)\n\t\tgoto out;\n\n\t*last = trace_enum_jmp_to_tail(map)->tail.next;\n\tkfree(map);\n out:\n\tmutex_unlock(&trace_enum_mutex);\n}\n#else\nstatic inline void trace_module_remove_enums(struct module *mod) { }\n#endif \n\nstatic int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tswitch (val) {\n\tcase module_state_coming:\n\t\ttrace_module_add_enums(mod);\n\t\tbreak;\n\tcase module_state_going:\n\t\ttrace_module_remove_enums(mod);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block trace_module_nb = {\n\t.notifier_call = trace_module_notify,\n\t.priority = 0,\n};\n#endif \n\nstatic __init int tracer_init_tracefs(void)\n{\n\tstruct dentry *d_tracer;\n\n\ttrace_access_lock_init();\n\n\td_tracer = tracing_init_dentry();\n\tif (is_err(d_tracer))\n\t\treturn 0;\n\n\tinit_tracer_tracefs(&global_trace, d_tracer);\n\n\ttrace_create_file(\"": 749, "\");\n\t\treturn kdb_badreg;\n\t}\n\treturn 0;\n}\n\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t\n\tif (!kdb_check_flags(kdb_enable_mem_read | kdb_enable_flow_ctrl,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn kdb_noperm;\n\n\t\n\n\tif (*nextarg > argc)\n\t\treturn kdb_argcount;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t\n\tcp = strpbrk(symname, \"": 750, "\");\n\t\treturn null;\n\t}\n\n\treturn tr->options;\n}\n\nstatic void\ncreate_trace_option_file(struct trace_array *tr,\n\t\t\t struct trace_option_dentry *topt,\n\t\t\t struct tracer_flags *flags,\n\t\t\t struct tracer_opt *opt)\n{\n\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn;\n\n\ttopt->flags = flags;\n\ttopt->opt = opt;\n\ttopt->tr = tr;\n\n\ttopt->entry = trace_create_file(opt->name, 0644, t_options, topt,\n\t\t\t\t    &trace_options_fops);\n\n}\n\nstatic struct trace_option_dentry *\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer)\n{\n\tstruct trace_option_dentry *topts;\n\tstruct tracer_flags *flags;\n\tstruct tracer_opt *opts;\n\tint cnt;\n\n\tif (!tracer)\n\t\treturn null;\n\n\tflags = tracer->flags;\n\n\tif (!flags || !flags->opts)\n\t\treturn null;\n\n\topts = flags->opts;\n\n\tfor (cnt = 0; opts[cnt].name; cnt++)\n\t\t;\n\n\ttopts = kcalloc(cnt + 1, sizeof(*topts), gfp_kernel);\n\tif (!topts)\n\t\treturn null;\n\n\tfor (cnt = 0; opts[cnt].name; cnt++)\n\t\tcreate_trace_option_file(tr, &topts[cnt], flags,\n\t\t\t\t\t &opts[cnt]);\n\n\treturn topts;\n}\n\nstatic void\ndestroy_trace_option_files(struct trace_option_dentry *topts)\n{\n\tint cnt;\n\n\tif (!topts)\n\t\treturn;\n\n\tfor (cnt = 0; topts[cnt].opt; cnt++)\n\t\ttracefs_remove(topts[cnt].entry);\n\n\tkfree(topts);\n}\n\nstatic struct dentry *\ncreate_trace_option_core_file(struct trace_array *tr,\n\t\t\t      const char *option, long index)\n{\n\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn null;\n\n\treturn trace_create_file(option, 0644, t_options, (void *)index,\n\t\t\t\t    &trace_options_core_fops);\n}\n\nstatic __init void create_trace_options_dir(struct trace_array *tr)\n{\n\tstruct dentry *t_options;\n\tint i;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn;\n\n\tfor (i = 0; trace_options[i]; i++)\n\t\tcreate_trace_option_core_file(tr, trace_options[i], i);\n}\n\nstatic ssize_t\nrb_simple_read(struct file *filp, char __user *ubuf,\n\t       size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = tracer_tracing_is_on(tr);\n\tr = sprintf(buf, \"": 751, "\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"": 752, "\");\n\t\treturn;\n\t}\n\n\tif (pid > pid_max_default) {\n\t\tstrcpy(comm, \"": 753, "\");\n\t\treturn;\n\t}\n\n\tmap = savedcmd->map_pid_to_cmdline[pid];\n\tif (map != no_cmdline_map)\n\t\tstrcpy(comm, get_saved_cmdlines(map));\n\telse\n\t\tstrcpy(comm, \"": 754, "\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&trace_enum_mutex);\n\n\tif (!trace_enum_maps)\n\t\ttrace_enum_maps = map_array;\n\telse {\n\t\tptr = trace_enum_maps;\n\t\tfor (;;) {\n\t\t\tptr = trace_enum_jmp_to_tail(ptr);\n\t\t\tif (!ptr->tail.next)\n\t\t\t\tbreak;\n\t\t\tptr = ptr->tail.next;\n\n\t\t}\n\t\tptr->tail.next = map_array;\n\t}\n\tmap_array->head.mod = mod;\n\tmap_array->head.length = len;\n\tmap_array++;\n\n\tfor (map = start; (unsigned long)map < (unsigned long)stop; map++) {\n\t\tmap_array->map = **map;\n\t\tmap_array++;\n\t}\n\tmemset(map_array, 0, sizeof(*map_array));\n\n\tmutex_unlock(&trace_enum_mutex);\n}\n\nstatic void trace_create_enum_file(struct dentry *d_tracer)\n{\n\ttrace_create_file(\"": 755, "\");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"": 756, "\");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"": 757, "\");\n\t\tseq_print_ip_sym(s, *p, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_stack_funcs = {\n\t.trace\t\t= trace_stack_print,\n};\n\nstatic struct trace_event trace_stack_event = {\n\t.type\t\t= trace_stack,\n\t.funcs\t\t= &trace_stack_funcs,\n};\n\n\nstatic enum print_line_t trace_user_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t\tint flags, struct trace_event *event)\n{\n\tstruct userstack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_puts(s, \"": 758, "\");\n\t\tstrncpy(buf + 4, str, sizeof(buf) - 5);\n\t} else {\n\t\tstrncpy(buf, str, sizeof(buf) - 1);\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\toptions = strchr(str, ',');\n\tif (options)\n\t\t*(options++) = 0;\n#ifdef __sparc__\n\tif (!strcmp(str, \"": 759, "\");\n\t\ttrace_set_options(&global_trace, option);\n\t}\n\n\tregister_snapshot_cmd();\n\n\treturn 0;\n\nout_free_savedcmd:\n\tfree_saved_cmdlines_buffer(savedcmd);\nout_free_temp_buffer:\n\tring_buffer_free(temp_buffer);\nout_free_cpumask:\n\tfree_cpumask_var(global_trace.tracing_cpumask);\nout_free_buffer_mask:\n\tfree_cpumask_var(tracing_buffer_mask);\nout:\n\treturn ret;\n}\n\nvoid __init trace_init(void)\n{\n\tif (tracepoint_printk) {\n\t\ttracepoint_print_iter =\n\t\t\tkmalloc(sizeof(*tracepoint_print_iter), gfp_kernel);\n\t\tif (warn_on(!tracepoint_print_iter))\n\t\t\ttracepoint_printk = 0;\n\t}\n\ttracer_alloc_buffers();\n\ttrace_event_init();\n}\n\n__init static int clear_boot_tracer(void)\n{\n\t\n\tif (!default_bootup_tracer)\n\t\treturn 0;\n\n\tprintk(kern_info \"": 760, "\");\n\t\twarn_on(1);\n\t\tgoto out_free_savedcmd;\n\t}\n\n\tif (global_trace.buffer_disabled)\n\t\ttracing_off();\n\n\tif (trace_boot_clock) {\n\t\tret = tracing_set_clock(&global_trace, trace_boot_clock);\n\t\tif (ret < 0)\n\t\t\tpr_warning(\"": 761, "\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; \n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\tif (kdb_state(printf_lock) && got_printf_lock) {\n\t\tgot_printf_lock = 0;\n\t\tspin_unlock_irqrestore(&kdb_printf_lock, flags);\n\t\tkdb_state_clear(printf_lock);\n\t\tatomic_dec(&kdb_event);\n\t} else {\n\t\t__release(kdb_printf_lock);\n\t}\n\tkdb_trap_printk = saved_trap_printk;\n\tpreempt_enable();\n\treturn retlen;\n}\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(kdb_msgsrc_internal, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}\nexport_symbol_gpl(kdb_printf);\n\n#include <linux/ftrace_event.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_clock.h>\n#include <linux/trace_seq.h>\n#include <linux/spinlock.h>\n#include <linux/irq_work.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\t\n#include <linux/kmemcheck.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n\n#include <asm/local.h>\n\nstatic void update_pages_handler(struct work_struct *work);\n\n\nint ring_buffer_print_entry_header(struct trace_seq *s)\n{\n\ttrace_seq_puts(s, \"": 762, "\");\n\t\t}\n\t}\n\n\tseq_printf(m, \"": 763, "\");\n\t\t}\n\n\t\tif (dev->set_state_oneshot) {\n\t\t\tseq_printf(m, \"": 764, "\");\n\t\t}\n\n\t\tif (dev->set_state_periodic) {\n\t\t\tseq_printf(m, \"": 765, "\");\n\t\t}\n\n\t\tif (dev->tick_resume) {\n\t\t\tseq_printf(m, \"": 766, "\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"": 767, "\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t\n\t\t\tsuspend_grep = 1; \n\t\t\tkdb_printf(\"": 768, "\");\n\t\n\twait_event(suspend_freeze_wait_head,\n\t\t   suspend_freeze_state == freeze_state_wake);\n\tpr_debug(\"": 769, "\");\n\t__print_lock_name(middle_class);\n\tprintk(\"": 770, "\");\n\t__print_lock_name(parent);\n\tprintk(\"": 771, "\");\n\t__print_lock_name(safe_class);\n\tprintk(\"": 772, "\");\n\t__print_lock_name(source);\n\tprintk(\"": 773, "\");\n\t__print_lock_name(target);\n\tprintk(\"": 774, "\");\n\t__print_lock_name(unsafe_class);\n\tprintk(\"": 775, "\");\n\tbug();\n}\nexport_symbol(__validate_process_creds);\n\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"": 776, "\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}\n\n\nstatic int console_cpu_notify(struct notifier_block *self,\n\tunsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase cpu_online:\n\tcase cpu_dead:\n\tcase cpu_down_failed:\n\tcase cpu_up_canceled:\n\t\tconsole_lock();\n\t\tconsole_unlock();\n\t}\n\treturn notify_ok;\n}\n\n\nvoid console_lock(void)\n{\n\tmight_sleep();\n\n\tdown_console_sem();\n\tif (console_suspended)\n\t\treturn;\n\tconsole_locked = 1;\n\tconsole_may_schedule = 1;\n}\nexport_symbol(console_lock);\n\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}\nexport_symbol(console_trylock);\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}\n\nstatic void console_cont_flush(char *text, size_t size)\n{\n\tunsigned long flags;\n\tsize_t len;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\n\tif (!cont.len)\n\t\tgoto out;\n\n\t\n\tif (console_seq < log_next_seq && !cont.cons)\n\t\tgoto out;\n\n\tlen = cont_print_text(text, size);\n\traw_spin_unlock(&logbuf_lock);\n\tstop_critical_timings();\n\tcall_console_drivers(cont.level, text, len);\n\tstart_critical_timings();\n\tlocal_irq_restore(flags);\n\treturn;\nout:\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n}\n\n\nvoid console_unlock(void)\n{\n\tstatic char text[log_line_max + prefix_max];\n\tstatic u64 seen_seq;\n\tunsigned long flags;\n\tbool wake_klogd = false;\n\tbool retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tconsole_may_schedule = 0;\n\n\t\n\tconsole_cont_flush(text, sizeof(text));\nagain:\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t len;\n\t\tint level;\n\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tif (seen_seq != log_next_seq) {\n\t\t\twake_klogd = true;\n\t\t\tseen_seq = log_next_seq;\n\t\t}\n\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text, \"": 777, "\");\n\tdump_stack();\n\n\treturn 0;\n}\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t\n\twarn(1, \"": 778, "\");\n\telse\n\t\tprintk(kern_trace \"": 779, "\");\n\telse\n\t\tseq_printf(m, \"": 780, "\");\n\telse\n\t\tseq_puts(m, \"": 781, "\");\n\tif (!save_trace(&prev_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(backwards_entry, prev_root);\n\n\tprintk(\"": 782, "\");\n\tif (!strcmp(str, \"": 783, "\");\n\tif (!strlen(mod))\n\t\treturn ret;\n\n\tret = ftrace_match_module_records(hash, func, mod);\n\tif (!ret)\n\t\tret = -einval;\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct ftrace_func_command ftrace_mod_cmd = {\n\t.name\t\t\t= \"": 784, "\");\n\tif (!type)\n\t\treturn null;\n\tmnt = vfs_kern_mount(type, 0, \"": 785, "\");\n\tif (cp != null) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t\n\t\treturn kdb_notimp;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn kdb_invaddrfmt;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"": 786, "\");\n\tif (iter->cpu_file == ring_buffer_all_cpus)\n\t\tshow_snapshot_main_help(m);\n\telse\n\t\tshow_snapshot_percpu_help(m);\n}\n#else\n\nstatic inline void print_snapshot_help(struct seq_file *m, struct trace_iterator *iter) { }\n#endif\n\nstatic int s_show(struct seq_file *m, void *v)\n{\n\tstruct trace_iterator *iter = v;\n\tint ret;\n\n\tif (iter->ent == null) {\n\t\tif (iter->tr) {\n\t\t\tseq_printf(m, \"": 787, "\");\n\tif (suspend_test(test_devices))\n\t\tgoto recover_platform;\n\n\tdo {\n\t\terror = suspend_enter(state, &wakeup);\n\t} while (!error && !wakeup && platform_suspend_again(state));\n\n resume_devices:\n\tsuspend_test_start();\n\tdpm_resume_end(pmsg_resume);\n\tsuspend_test_finish(\"": 788, "\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"": 789, "\");\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(domain, &irq_domain_list, link) {\n\t\tint count = 0;\n\t\tradix_tree_for_each_slot(slot, &domain->revmap_tree, &iter, 0)\n\t\t\tcount++;\n\t\tseq_printf(m, \"": 790, "\");\n\tpr_warning(\"": 791, "\");\n\tprint_active_timers(m, base, now);\n}\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tseq_printf(m, \"": 792, "\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"": 793, "\");\n\tprint_ip_sym((unsigned long)class->key);\n}\n\n\nstatic void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"": 794, "\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"": 795, "\");\n\tprint_kernel_ident();\n\tprintk(\"": 796, "\");\n\tprint_lock(check_tgt);\n\tprintk(\"": 797, "\");\n\tprint_lock(prev);\n\tprintk(\"": 798, "\");\n\tprint_lock_name(class);\n\tprintk(\"": 799, "\");\n\tprint_lock_name(hlock_class(next));\n\tprintk(\"": 800, "\");\n\tprint_lock_name(hlock_class(prev));\n\tprintk(\"": 801, "\");\n\tprint_name_offset(m, base->get_time);\n\tseq_printf(m,   \"": 802, "\");\n\tprint_name_offset(m, dev->event_handler);\n\tseq_printf(m, \"": 803, "\");\n\tprint_name_offset(m, dev->set_next_event);\n\tseq_printf(m, \"": 804, "\");\n\tprint_name_offset(m, timer->function);\n\tseq_printf(m, \"": 805, "\");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, task_comm_len);\n\ttmp[task_comm_len] = 0;\n\tseq_printf(m, \"": 806, "\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}\n\nstatic void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t\n\tif (parent != source) {\n\t\tprintk(\"": 807, "\");\n\tprintk(\"": 808, "\");\n\tprintk(kern_err \"": 809, "\");\n\treturn -enomem;\n}\n\nstatic int buffers_allocated;\n\nvoid trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t\n\n\tpr_warning(\"": 810, "\");\n\treturn boot_override_clocksource(str);\n}\n\n__setup(\"": 811, "\");\n\tseq_print_userip_objs(field, s, flags);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_user_stack_funcs = {\n\t.trace\t\t= trace_user_stack_print,\n};\n\nstatic struct trace_event trace_user_stack_event = {\n\t.type\t\t= trace_user_stack,\n\t.funcs\t\t= &trace_user_stack_funcs,\n};\n\n\nstatic enum print_line_t\ntrace_bputs_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \"": 812, "\");\n\tseq_printf(m, \"": 813, "\");\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic int tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < array_size(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == array_size(trace_clocks))\n\t\treturn -einval;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->trace_buffer.buffer, trace_clocks[i].func);\n\n\t\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n#ifdef config_tracer_max_trace\n\tif (tr->flags & trace_array_fl_global && tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic ssize_t tracing_clock_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t   size_t cnt, loff_t *fpos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tchar buf[64];\n\tconst char *clockstr;\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -einval;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -efault;\n\n\tbuf[cnt] = 0;\n\n\tclockstr = strstrip(buf);\n\n\tret = tracing_set_clock(tr, clockstr);\n\tif (ret)\n\t\treturn ret;\n\n\t*fpos += cnt;\n\n\treturn cnt;\n}\n\nstatic int tracing_clock_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr))\n\t\treturn -enodev;\n\n\tret = single_open(file, tracing_clock_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstruct ftrace_buffer_info {\n\tstruct trace_iterator\titer;\n\tvoid\t\t\t*spare;\n\tunsigned int\t\tread;\n};\n\n#ifdef config_tracer_snapshot\nstatic int tracing_snapshot_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tif (file->f_mode & fmode_read) {\n\t\titer = __tracing_open(inode, file, true);\n\t\tif (is_err(iter))\n\t\t\tret = ptr_err(iter);\n\t} else {\n\t\t\n\t\tret = -enomem;\n\t\tm = kzalloc(sizeof(*m), gfp_kernel);\n\t\tif (!m)\n\t\t\tgoto out;\n\t\titer = kzalloc(sizeof(*iter), gfp_kernel);\n\t\tif (!iter) {\n\t\t\tkfree(m);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 0;\n\n\t\titer->tr = tr;\n\t\titer->trace_buffer = &tr->max_buffer;\n\t\titer->cpu_file = tracing_get_cpu(inode);\n\t\tm->private = iter;\n\t\tfile->private_data = m;\n\t}\nout:\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_snapshot_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long val;\n\tint ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (tr->current_trace->use_max_tr) {\n\t\tret = -ebusy;\n\t\tgoto out;\n\t}\n\n\tswitch (val) {\n\tcase 0:\n\t\tif (iter->cpu_file != ring_buffer_all_cpus) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n\t\tif (tr->allocated_snapshot)\n\t\t\tfree_snapshot(tr);\n\t\tbreak;\n\tcase 1:\n\n#ifndef config_ring_buffer_allow_swap\n\t\tif (iter->cpu_file != ring_buffer_all_cpus) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tif (!tr->allocated_snapshot) {\n\t\t\tret = alloc_snapshot(tr);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tlocal_irq_disable();\n\t\t\n\t\tif (iter->cpu_file == ring_buffer_all_cpus)\n\t\t\tupdate_max_tr(tr, current, smp_processor_id());\n\t\telse\n\t\t\tupdate_max_tr_single(tr, current, iter->cpu_file);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tdefault:\n\t\tif (tr->allocated_snapshot) {\n\t\t\tif (iter->cpu_file == ring_buffer_all_cpus)\n\t\t\t\ttracing_reset_online_cpus(&tr->max_buffer);\n\t\t\telse\n\t\t\t\ttracing_reset(&tr->max_buffer, iter->cpu_file);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (ret >= 0) {\n\t\t*ppos += cnt;\n\t\tret = cnt;\n\t}\nout:\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}\n\nstatic int tracing_snapshot_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tint ret;\n\n\tret = tracing_release(inode, file);\n\n\tif (file->f_mode & fmode_read)\n\t\treturn ret;\n\n\t\n\tif (m)\n\t\tkfree(m->private);\n\tkfree(m);\n\n\treturn 0;\n}\n\nstatic int tracing_buffers_open(struct inode *inode, struct file *filp);\nstatic ssize_t tracing_buffers_read(struct file *filp, char __user *ubuf,\n\t\t\t\t    size_t count, loff_t *ppos);\nstatic int tracing_buffers_release(struct inode *inode, struct file *file);\nstatic ssize_t tracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t   struct pipe_inode_info *pipe, size_t len, unsigned int flags);\n\nstatic int snapshot_raw_open(struct inode *inode, struct file *filp)\n{\n\tstruct ftrace_buffer_info *info;\n\tint ret;\n\n\tret = tracing_buffers_open(inode, filp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo = filp->private_data;\n\n\tif (info->iter.trace->use_max_tr) {\n\t\ttracing_buffers_release(inode, filp);\n\t\treturn -ebusy;\n\t}\n\n\tinfo->iter.snapshot = true;\n\tinfo->iter.trace_buffer = &info->iter.tr->max_buffer;\n\n\treturn ret;\n}\n\n#endif \n\n\nstatic const struct file_operations tracing_thresh_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_thresh_read,\n\t.write\t\t= tracing_thresh_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations tracing_max_lat_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_max_lat_read,\n\t.write\t\t= tracing_max_lat_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations set_tracer_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_set_trace_read,\n\t.write\t\t= tracing_set_trace_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations tracing_pipe_fops = {\n\t.open\t\t= tracing_open_pipe,\n\t.poll\t\t= tracing_poll_pipe,\n\t.read\t\t= tracing_read_pipe,\n\t.splice_read\t= tracing_splice_read_pipe,\n\t.release\t= tracing_release_pipe,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic const struct file_operations tracing_entries_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_entries_read,\n\t.write\t\t= tracing_entries_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_total_entries_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_total_entries_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_free_buffer_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_free_buffer_write,\n\t.release\t= tracing_free_buffer_release,\n};\n\nstatic const struct file_operations tracing_mark_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_mark_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations trace_clock_fops = {\n\t.open\t\t= tracing_clock_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n\t.write\t\t= tracing_clock_write,\n};\n\n#ifdef config_tracer_snapshot\nstatic const struct file_operations snapshot_fops = {\n\t.open\t\t= tracing_snapshot_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tracing_snapshot_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= tracing_snapshot_release,\n};\n\nstatic const struct file_operations snapshot_raw_fops = {\n\t.open\t\t= snapshot_raw_open,\n\t.read\t\t= tracing_buffers_read,\n\t.release\t= tracing_buffers_release,\n\t.splice_read\t= tracing_buffers_splice_read,\n\t.llseek\t\t= no_llseek,\n};\n\n#endif \n\nstatic int tracing_buffers_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct ftrace_buffer_info *info;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tinfo = kzalloc(sizeof(*info), gfp_kernel);\n\tif (!info) {\n\t\ttrace_array_put(tr);\n\t\treturn -enomem;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\tinfo->iter.tr\t\t= tr;\n\tinfo->iter.cpu_file\t= tracing_get_cpu(inode);\n\tinfo->iter.trace\t= tr->current_trace;\n\tinfo->iter.trace_buffer = &tr->trace_buffer;\n\tinfo->spare\t\t= null;\n\t\n\tinfo->read\t\t= (unsigned int)-1;\n\n\tfilp->private_data = info;\n\n\ttr->current_trace->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\n\tret = nonseekable_open(inode, filp);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic unsigned int\ntracing_buffers_poll(struct file *filp, poll_table *poll_table)\n{\n\tstruct ftrace_buffer_info *info = filp->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\n\treturn trace_poll(iter, filp, poll_table);\n}\n\nstatic ssize_t\ntracing_buffers_read(struct file *filp, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ftrace_buffer_info *info = filp->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tssize_t ret;\n\tssize_t size;\n\n\tif (!count)\n\t\treturn 0;\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -ebusy;\n#endif\n\n\tif (!info->spare)\n\t\tinfo->spare = ring_buffer_alloc_read_page(iter->trace_buffer->buffer,\n\t\t\t\t\t\t\t  iter->cpu_file);\n\tif (!info->spare)\n\t\treturn -enomem;\n\n\t\n\tif (info->read < page_size)\n\t\tgoto read;\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tret = ring_buffer_read_page(iter->trace_buffer->buffer,\n\t\t\t\t    &info->spare,\n\t\t\t\t    count,\n\t\t\t\t    iter->cpu_file, 0);\n\ttrace_access_unlock(iter->cpu_file);\n\n\tif (ret < 0) {\n\t\tif (trace_empty(iter)) {\n\t\t\tif ((filp->f_flags & o_nonblock))\n\t\t\t\treturn -eagain;\n\n\t\t\tret = wait_on_pipe(iter, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tgoto again;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinfo->read = 0;\n read:\n\tsize = page_size - info->read;\n\tif (size > count)\n\t\tsize = count;\n\n\tret = copy_to_user(ubuf, info->spare + info->read, size);\n\tif (ret == size)\n\t\treturn -efault;\n\n\tsize -= ret;\n\n\t*ppos += size;\n\tinfo->read += size;\n\n\treturn size;\n}\n\nstatic int tracing_buffers_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\n\tmutex_lock(&trace_types_lock);\n\n\titer->tr->current_trace->ref--;\n\n\t__trace_array_put(iter->tr);\n\n\tif (info->spare)\n\t\tring_buffer_free_read_page(iter->trace_buffer->buffer, info->spare);\n\tkfree(info);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstruct buffer_ref {\n\tstruct ring_buffer\t*buffer;\n\tvoid\t\t\t*page;\n\tint\t\t\tref;\n};\n\nstatic void buffer_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (--ref->ref)\n\t\treturn;\n\n\tring_buffer_free_read_page(ref->buffer, ref->page);\n\tkfree(ref);\n\tbuf->private = 0;\n}\n\nstatic void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tref->ref++;\n}\n\n\nstatic const struct pipe_buf_operations buffer_pipe_buf_ops = {\n\t.can_merge\t\t= 0,\n\t.confirm\t\t= generic_pipe_buf_confirm,\n\t.release\t\t= buffer_pipe_buf_release,\n\t.steal\t\t\t= generic_pipe_buf_steal,\n\t.get\t\t\t= buffer_pipe_buf_get,\n};\n\n\nstatic void buffer_spd_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tstruct buffer_ref *ref =\n\t\t(struct buffer_ref *)spd->partial[i].private;\n\n\tif (--ref->ref)\n\t\treturn;\n\n\tring_buffer_free_read_page(ref->buffer, ref->page);\n\tkfree(ref);\n\tspd->partial[i].private = 0;\n}\n\nstatic ssize_t\ntracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t\t    struct pipe_inode_info *pipe, size_t len,\n\t\t\t    unsigned int flags)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tstruct partial_page partial_def[pipe_def_buffers];\n\tstruct page *pages_def[pipe_def_buffers];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages_max\t= pipe_def_buffers,\n\t\t.flags\t\t= flags,\n\t\t.ops\t\t= &buffer_pipe_buf_ops,\n\t\t.spd_release\t= buffer_spd_release,\n\t};\n\tstruct buffer_ref *ref;\n\tint entries, size, i;\n\tssize_t ret = 0;\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -ebusy;\n#endif\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -enomem;\n\n\tif (*ppos & (page_size - 1))\n\t\treturn -einval;\n\n\tif (len & (page_size - 1)) {\n\t\tif (len < page_size)\n\t\t\treturn -einval;\n\t\tlen &= page_mask;\n\t}\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tentries = ring_buffer_entries_cpu(iter->trace_buffer->buffer, iter->cpu_file);\n\n\tfor (i = 0; i < spd.nr_pages_max && len && entries; i++, len -= page_size) {\n\t\tstruct page *page;\n\t\tint r;\n\n\t\tref = kzalloc(sizeof(*ref), gfp_kernel);\n\t\tif (!ref) {\n\t\t\tret = -enomem;\n\t\t\tbreak;\n\t\t}\n\n\t\tref->ref = 1;\n\t\tref->buffer = iter->trace_buffer->buffer;\n\t\tref->page = ring_buffer_alloc_read_page(ref->buffer, iter->cpu_file);\n\t\tif (!ref->page) {\n\t\t\tret = -enomem;\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\n\t\tr = ring_buffer_read_page(ref->buffer, &ref->page,\n\t\t\t\t\t  len, iter->cpu_file, 1);\n\t\tif (r < 0) {\n\t\t\tring_buffer_free_read_page(ref->buffer, ref->page);\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tsize = ring_buffer_page_len(ref->page);\n\t\tif (size < page_size)\n\t\t\tmemset(ref->page + size, 0, page_size - size);\n\n\t\tpage = virt_to_page(ref->page);\n\n\t\tspd.pages[i] = page;\n\t\tspd.partial[i].len = page_size;\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].private = (unsigned long)ref;\n\t\tspd.nr_pages++;\n\t\t*ppos += page_size;\n\n\t\tentries = ring_buffer_entries_cpu(iter->trace_buffer->buffer, iter->cpu_file);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\tspd.nr_pages = i;\n\n\t\n\tif (!spd.nr_pages) {\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((file->f_flags & o_nonblock) || (flags & splice_f_nonblock))\n\t\t\treturn -eagain;\n\n\t\tret = wait_on_pipe(iter, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgoto again;\n\t}\n\n\tret = splice_to_pipe(pipe, &spd);\n\tsplice_shrink_spd(&spd);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_buffers_fops = {\n\t.open\t\t= tracing_buffers_open,\n\t.read\t\t= tracing_buffers_read,\n\t.poll\t\t= tracing_buffers_poll,\n\t.release\t= tracing_buffers_release,\n\t.splice_read\t= tracing_buffers_splice_read,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic ssize_t\ntracing_stats_read(struct file *filp, char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_buffer *trace_buf = &tr->trace_buffer;\n\tint cpu = tracing_get_cpu(inode);\n\tstruct trace_seq *s;\n\tunsigned long cnt;\n\tunsigned long long t;\n\tunsigned long usec_rem;\n\n\ts = kmalloc(sizeof(*s), gfp_kernel);\n\tif (!s)\n\t\treturn -enomem;\n\n\ttrace_seq_init(s);\n\n\tcnt = ring_buffer_entries_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"": 814, "\");\n\tsuspend_finish();\n unlock:\n\tmutex_unlock(&pm_mutex);\n\treturn error;\n}\n\n\nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= pm_suspend_on || state >= pm_suspend_max)\n\t\treturn -einval;\n\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\treturn error;\n}\nexport_symbol(pm_suspend);\n\n\n\n\n#include <linux/time.h>\n#include <linux/module.h>\n\n\nstatic int __isleap(long year)\n{\n\treturn (year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0);\n}\n\n\nstatic long math_div(long a, long b)\n{\n\treturn a / b - (a % b < 0);\n}\n\n\nstatic long leaps_between(long y1, long y2)\n{\n\tlong leaps1 = math_div(y1 - 1, 4) - math_div(y1 - 1, 100)\n\t\t+ math_div(y1 - 1, 400);\n\tlong leaps2 = math_div(y2 - 1, 4) - math_div(y2 - 1, 100)\n\t\t+ math_div(y2 - 1, 400);\n\treturn leaps2 - leaps1;\n}\n\n\nstatic const unsigned short __mon_yday[2][13] = {\n\t\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\n#define secs_per_hour\t(60 * 60)\n#define secs_per_day\t(secs_per_hour * 24)\n\n\nvoid time_to_tm(time_t totalsecs, int offset, struct tm *result)\n{\n\tlong days, rem, y;\n\tconst unsigned short *ip;\n\n\tdays = totalsecs / secs_per_day;\n\trem = totalsecs % secs_per_day;\n\trem += offset;\n\twhile (rem < 0) {\n\t\trem += secs_per_day;\n\t\t--days;\n\t}\n\twhile (rem >= secs_per_day) {\n\t\trem -= secs_per_day;\n\t\t++days;\n\t}\n\n\tresult->tm_hour = rem / secs_per_hour;\n\trem %= secs_per_hour;\n\tresult->tm_min = rem / 60;\n\tresult->tm_sec = rem % 60;\n\n\t\n\tresult->tm_wday = (4 + days) % 7;\n\tif (result->tm_wday < 0)\n\t\tresult->tm_wday += 7;\n\n\ty = 1970;\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\t\n\t\tlong yg = y + math_div(days, 365);\n\n\t\t\n\t\tdays -= (yg - y) * 365 + leaps_between(y, yg);\n\t\ty = yg;\n\t}\n\n\tresult->tm_year = y - 1900;\n\n\tresult->tm_yday = days;\n\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < ip[y]; y--)\n\t\tcontinue;\n\tdays -= ip[y];\n\n\tresult->tm_mon = y;\n\tresult->tm_mday = days + 1;\n}\nexport_symbol(time_to_tm);\n#ifndef _linux_cpupri_h\n#define _linux_cpupri_h\n\n#include <linux/sched.h>\n\n#define cpupri_nr_priorities\t(max_rt_prio + 2)\n\n#define cpupri_invalid -1\n#define cpupri_idle     0\n#define cpupri_normal   1\n\n\nstruct cpupri_vec {\n\tatomic_t\tcount;\n\tcpumask_var_t\tmask;\n};\n\nstruct cpupri {\n\tstruct cpupri_vec pri_to_cpu[cpupri_nr_priorities];\n\tint *cpu_to_pri;\n};\n\n#ifdef config_smp\nint  cpupri_find(struct cpupri *cp,\n\t\t struct task_struct *p, struct cpumask *lowest_mask);\nvoid cpupri_set(struct cpupri *cp, int cpu, int pri);\nint cpupri_init(struct cpupri *cp);\nvoid cpupri_cleanup(struct cpupri *cp);\n#endif\n\n#endif \n#include \"": 815, "\");\n\tsys_sync();\n\tprintk(\"": 816, "\");\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\n\nstatic enum print_line_t\ntrace_bprint_raw(struct trace_iterator *iter, int flags,\n\t\t struct trace_event *event)\n{\n\tstruct bprint_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"": 817, "\");\n\ttrace_seq_putc(s, '\\n');\n\ttrace_seq_printf(s, \"": 818, "\");\n\ttrace_seq_puts(s, \"": 819, "\");\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\n\nstatic enum print_line_t\ntrace_bputs_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct bputs_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"": 820, "\");\n\ttrace_suspend_resume(tps(\"": 821, "\");\n\twarn(!perf_wq, \"": 822, "\");\n\t}\n\tif (argc == 0) {\n\t\tint i;\n\t\tfor (s = defcmd_set; s < defcmd_set + defcmd_set_count; ++s) {\n\t\t\tkdb_printf(\"": 823, "\");\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\n\tseq_printf(m, \"": 824, "\");\n\t}\n\tprintk(\"": 825, "\");\n\t}\n\n\t\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(kern_trace \"": 826, "\");\n\t}\n\n\tprintk(\"": 827, "\");\n\t}\n\n\tseq_puts(m, \"": 828, "\");\n\t} else\n\t\tr = sprintf(buf, \"": 829, "\");\n\t} else {\n\t\tif (dev->set_state_shutdown) {\n\t\t\tseq_printf(m, \"": 830, "\");\n\n\t\t\tdata = irq_desc_get_chip_data(desc);\n\t\t\tseq_printf(m, data ? \"": 831, "\");\n\n\t\tcnt++;\n\n\t\t\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= trace_file_lat_fmt;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != null) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != trace_type_no_consume)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(kern_trace \"": 832, "\");\n\n\t\tevents += entry->count;\n\t}\n\n\tms += period.tv_sec * 1000;\n\tif (!ms)\n\t\tms = 1;\n\n\tif (events && period.tv_sec)\n\t\tseq_printf(m, \"": 833, "\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"": 834, "\");\n\n\t\t}\n\t\tadd_trampoline_func(m, ops, rec);\n\t}\t\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations show_ftrace_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.stop = t_stop,\n\t.show = t_show,\n};\n\nstatic int\nftrace_avail_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (iter) {\n\t\titer->pg = ftrace_pages_start;\n\t\titer->ops = &global_ops;\n\t}\n\n\treturn iter ? 0 : -enomem;\n}\n\nstatic int\nftrace_enabled_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (iter) {\n\t\titer->pg = ftrace_pages_start;\n\t\titer->flags = ftrace_iter_enabled;\n\t\titer->ops = &global_ops;\n\t}\n\n\treturn iter ? 0 : -enomem;\n}\n\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\titer = kzalloc(sizeof(*iter), gfp_kernel);\n\tif (!iter)\n\t\treturn -enomem;\n\n\tif (trace_parser_get_init(&iter->parser, ftrace_buff_max)) {\n\t\tkfree(iter);\n\t\treturn -enomem;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & ftrace_iter_notrace)\n\t\thash = ops->func_hash->notrace_hash;\n\telse\n\t\thash = ops->func_hash->filter_hash;\n\n\tif (file->f_mode & fmode_write) {\n\t\tconst int size_bits = ftrace_hash_default_bits;\n\n\t\tif (file->f_flags & o_trunc)\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -enomem;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (file->f_mode & fmode_read) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}\n\nstatic int\nftrace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops,\n\t\t\tftrace_iter_filter | ftrace_iter_do_hash,\n\t\t\tinode, file);\n}\n\nstatic int\nftrace_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops, ftrace_iter_notrace,\n\t\t\t\t inode, file);\n}\n\nstatic int ftrace_match(char *str, char *regex, int len, int type)\n{\n\tint matched = 0;\n\tint slen;\n\n\tswitch (type) {\n\tcase match_full:\n\t\tif (strcmp(str, regex) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase match_front_only:\n\t\tif (strncmp(str, regex, len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase match_middle_only:\n\t\tif (strstr(str, regex))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase match_end_only:\n\t\tslen = strlen(str);\n\t\tif (slen >= len && memcmp(str + slen - len, regex, len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int not)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (not) {\n\t\t\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, char *mod,\n\t\t    char *regex, int len, int type)\n{\n\tchar str[ksym_symbol_len];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, null, null, &modname, str);\n\n\tif (mod) {\n\t\t\n\t\tif (!modname || strcmp(modname, mod))\n\t\t\treturn 0;\n\n\t\t\n\t\tif (!len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, regex, len, type);\n}\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *buff,\n\t      int len, char *mod, int not)\n{\n\tunsigned search_len = 0;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tint type = match_full;\n\tchar *search = buff;\n\tint found = 0;\n\tint ret;\n\n\tif (len) {\n\t\ttype = filter_parse_regex(buff, len, &search, &not);\n\t\tsearch_len = strlen(search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tif (ftrace_match_record(rec, mod, search, search_len, type)) {\n\t\t\tret = enter_record(hash, rec, not);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, null, 0);\n}\n\nstatic int\nftrace_match_module_records(struct ftrace_hash *hash, char *buff, char *mod)\n{\n\tint not = 0;\n\n\t\n\tif (strcmp(buff, \"": 835, "\");\n\n\t\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"": 836, "\");\n\n\t\n\tretrigger_next_event(null);\n\t\n\tclock_was_set_delayed();\n}\n\nstatic inline void timer_stats_hrtimer_set_start_info(struct hrtimer *timer)\n{\n#ifdef config_timer_stats\n\tif (timer->start_site)\n\t\treturn;\n\ttimer->start_site = __builtin_return_address(0);\n\tmemcpy(timer->start_comm, current->comm, task_comm_len);\n\ttimer->start_pid = current->pid;\n#endif\n}\n\nstatic inline void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer)\n{\n#ifdef config_timer_stats\n\ttimer->start_site = null;\n#endif\n}\n\nstatic inline void timer_stats_account_hrtimer(struct hrtimer *timer)\n{\n#ifdef config_timer_stats\n\tif (likely(!timer_stats_active))\n\t\treturn;\n\ttimer_stats_update_stats(timer, timer->start_pid, timer->start_site,\n\t\t\t\t timer->function, timer->start_comm, 0);\n#endif\n}\n\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}\n\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now.tv64)\n\t\t\treturn orun;\n\t\t\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}\nexport_symbol_gpl(hrtimer_forward);\n\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base)\n{\n\tdebug_activate(timer);\n\n\ttimerqueue_add(&base->active, &timer->node);\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t\n\ttimer->state |= hrtimer_state_enqueued;\n\n\treturn (&timer->node == base->active.next);\n}\n\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     unsigned long newstate, int reprogram)\n{\n\tstruct timerqueue_node *next_timer;\n\tif (!(timer->state & hrtimer_state_enqueued))\n\t\tgoto out;\n\n\tnext_timer = timerqueue_getnext(&base->active);\n\ttimerqueue_del(&base->active, &timer->node);\n\tif (&timer->node == next_timer) {\n#ifdef config_high_res_timers\n\t\t\n\t\tif (reprogram && hrtimer_hres_active()) {\n\t\t\tktime_t expires;\n\n\t\t\texpires = ktime_sub(hrtimer_get_expires(timer),\n\t\t\t\t\t    base->offset);\n\t\t\tif (base->cpu_base->expires_next.tv64 == expires.tv64)\n\t\t\t\thrtimer_force_reprogram(base->cpu_base, 1);\n\t\t}\n#endif\n\t}\n\tif (!timerqueue_getnext(&base->active))\n\t\tbase->cpu_base->active_bases &= ~(1 << base->index);\nout:\n\ttimer->state = newstate;\n}\n\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tunsigned long state;\n\t\tint reprogram;\n\n\t\t\n\t\tdebug_deactivate(timer);\n\t\ttimer_stats_hrtimer_clear_start_info(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\t\t\n\t\tstate = timer->state & hrtimer_state_callback;\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\tunsigned long delta_ns, const enum hrtimer_mode mode,\n\t\tint wakeup)\n{\n\tstruct hrtimer_clock_base *base, *new_base;\n\tunsigned long flags;\n\tint ret, leftmost;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\t\n\tret = remove_hrtimer(timer, base);\n\n\tif (mode & hrtimer_mode_rel) {\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\t\t\n#ifdef config_time_low_res\n\t\ttim = ktime_add_safe(tim, base->resolution);\n#endif\n\t}\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t\n\tnew_base = switch_hrtimer_base(timer, base, mode & hrtimer_mode_pinned);\n\n\ttimer_stats_hrtimer_set_start_info(timer);\n\n\tleftmost = enqueue_hrtimer(timer, new_base);\n\n\tif (!leftmost) {\n\t\tunlock_hrtimer_base(timer, &flags);\n\t\treturn ret;\n\t}\n\n\tif (!hrtimer_is_hres_active(timer)) {\n\t\t\n\t\twake_up_nohz_cpu(new_base->cpu_base->cpu);\n\t} else if (new_base->cpu_base == this_cpu_ptr(&hrtimer_bases) &&\n\t\t\thrtimer_reprogram(timer, new_base)) {\n\t\t\n\t\tif (wakeup) {\n\t\t\t\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traise_softirq_irqoff(hrtimer_softirq);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t__raise_softirq_irqoff(hrtimer_softirq);\n\t\t}\n\t}\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n}\nexport_symbol_gpl(__hrtimer_start_range_ns);\n\n\nint hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\tunsigned long delta_ns, const enum hrtimer_mode mode)\n{\n\treturn __hrtimer_start_range_ns(timer, tim, delta_ns, mode, 1);\n}\nexport_symbol_gpl(hrtimer_start_range_ns);\n\n\nint\nhrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)\n{\n\treturn __hrtimer_start_range_ns(timer, tim, 0, mode, 1);\n}\nexport_symbol_gpl(hrtimer_start);\n\n\n\nint hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}\nexport_symbol_gpl(hrtimer_try_to_cancel);\n\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}\nexport_symbol_gpl(hrtimer_cancel);\n\n\nktime_t hrtimer_get_remaining(const struct hrtimer *timer)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}\nexport_symbol_gpl(hrtimer_get_remaining);\n\n#ifdef config_no_hz_common\n\nktime_t hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t mindelta = { .tv64 = ktime_max };\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!hrtimer_hres_active())\n\t\tmindelta = ktime_sub(__hrtimer_get_next_event(cpu_base),\n\t\t\t\t     ktime_get());\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tif (mindelta.tv64 < 0)\n\t\tmindelta.tv64 = 0;\n\treturn mindelta;\n}\n#endif\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\tif (clock_id == clock_realtime && mode != hrtimer_mode_abs)\n\t\tclock_id = clock_monotonic;\n\n\tbase = hrtimer_clockid_to_base(clock_id);\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n\n#ifdef config_timer_stats\n\ttimer->start_site = null;\n\ttimer->start_pid = -1;\n\tmemset(timer->start_comm, 0, task_comm_len);\n#endif\n}\n\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}\nexport_symbol_gpl(hrtimer_init);\n\n\nint hrtimer_get_res(const clockid_t which_clock, struct timespec *tp)\n{\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base = hrtimer_clockid_to_base(which_clock);\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\t*tp = ktime_to_timespec(cpu_base->clock_base[base].resolution);\n\n\treturn 0;\n}\nexport_symbol_gpl(hrtimer_get_res);\n\nstatic void __run_hrtimer(struct hrtimer *timer, ktime_t *now)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tint restart;\n\n\twarn_on(!irqs_disabled());\n\n\tdebug_deactivate(timer);\n\t__remove_hrtimer(timer, base, hrtimer_state_callback, 0);\n\ttimer_stats_account_hrtimer(timer);\n\tfn = timer->function;\n\n\t\n\traw_spin_unlock(&cpu_base->lock);\n\ttrace_hrtimer_expire_entry(timer, now);\n\trestart = fn(timer);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock(&cpu_base->lock);\n\n\t\n\tif (restart != hrtimer_norestart) {\n\t\tbug_on(timer->state != hrtimer_state_callback);\n\t\tenqueue_hrtimer(timer, base);\n\t}\n\n\twarn_on_once(!(timer->state & hrtimer_state_callback));\n\n\ttimer->state &= ~hrtimer_state_callback;\n}\n\n#ifdef config_high_res_timers\n\n\nvoid hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tint i, retries = 0;\n\n\tbug_on(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event.tv64 = ktime_max;\n\n\traw_spin_lock(&cpu_base->lock);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t\n\tcpu_base->expires_next.tv64 = ktime_max;\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tstruct hrtimer_clock_base *base;\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tif (!(cpu_base->active_bases & (1 << i)))\n\t\t\tcontinue;\n\n\t\tbase = cpu_base->clock_base + i;\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t\n\t\t\tif (basenow.tv64 < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(timer, &basenow);\n\t\t}\n\t}\n\t\n\texpires_next = __hrtimer_get_next_event(cpu_base);\n\t\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock(&cpu_base->lock);\n\n\t\n\tif (expires_next.tv64 == ktime_max ||\n\t    !tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t\n\traw_spin_lock(&cpu_base->lock);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock(&cpu_base->lock);\n\tdelta = ktime_sub(now, entry_time);\n\tif (delta.tv64 > cpu_base->max_hang_time.tv64)\n\t\tcpu_base->max_hang_time = delta;\n\t\n\tif (delta.tv64 > 100 * nsec_per_msec)\n\t\texpires_next = ktime_add_ns(now, 100 * nsec_per_msec);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tprintk_once(kern_warning \"": 837, "\");\n\n\t\n\tset_fs(user_ds);\n\n\tptrace_event(ptrace_event_exit, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t\n\tif (unlikely(tsk->flags & pf_exiting)) {\n\t\tpr_alert(\"": 838, "\");\n\n\t\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t\n\tif (global_trace.trace_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}\n\nvoid trace_printk_start_comm(void)\n{\n\t\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}\n\nstatic void trace_printk_start_stop_comm(int enabled)\n{\n\tif (!buffers_allocated)\n\t\treturn;\n\n\tif (enabled)\n\t\ttracing_start_cmdline_record();\n\telse\n\t\ttracing_stop_cmdline_record();\n}\n\n\nint trace_vbprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct ftrace_event_call *call = &event_bprint;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct trace_array *tr = &global_trace;\n\tstruct bprint_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\tint len = 0, size, pc;\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\t\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out;\n\t}\n\n\tlen = vbin_printf((u32 *)tbuffer, trace_buf_size/sizeof(int), fmt, args);\n\n\tif (len > trace_buf_size/sizeof(int) || len < 0)\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + sizeof(u32) * len;\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, trace_bprint, size,\n\t\t\t\t\t  flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->fmt\t\t\t= fmt;\n\n\tmemcpy(entry->buf, tbuffer, sizeof(u32) * len);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(buffer, flags, 6, pc);\n\t}\n\nout:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\nexport_symbol_gpl(trace_vbprintk);\n\nstatic int\n__trace_array_vprintk(struct ring_buffer *buffer,\n\t\t      unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct ftrace_event_call *call = &event_print;\n\tstruct ring_buffer_event *event;\n\tint len = 0, size, pc;\n\tstruct print_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn 0;\n\n\t\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out;\n\t}\n\n\tlen = vscnprintf(tbuffer, trace_buf_size, fmt, args);\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + len + 1;\n\tevent = trace_buffer_lock_reserve(buffer, trace_print, size,\n\t\t\t\t\t  flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, tbuffer, len + 1);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(buffer, flags, 6, pc);\n\t}\n out:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\n\nint trace_array_vprintk(struct trace_array *tr,\n\t\t\tunsigned long ip, const char *fmt, va_list args)\n{\n\treturn __trace_array_vprintk(tr->trace_buffer.buffer, ip, fmt, args);\n}\n\nint trace_array_printk(struct trace_array *tr,\n\t\t       unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(trace_flags & trace_iter_printk))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_array_vprintk(tr, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nint trace_array_printk_buf(struct ring_buffer *buffer,\n\t\t\t   unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(trace_flags & trace_iter_printk))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = __trace_array_vprintk(buffer, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nint trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}\nexport_symbol_gpl(trace_vprintk);\n\nstatic void trace_iterator_increment(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, iter->cpu);\n\n\titer->idx++;\n\tif (buf_iter)\n\t\tring_buffer_read(buf_iter, null);\n}\n\nstatic struct trace_entry *\npeek_next_entry(struct trace_iterator *iter, int cpu, u64 *ts,\n\t\tunsigned long *lost_events)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, cpu);\n\n\tif (buf_iter)\n\t\tevent = ring_buffer_iter_peek(buf_iter, ts);\n\telse\n\t\tevent = ring_buffer_peek(iter->trace_buffer->buffer, cpu, ts,\n\t\t\t\t\t lost_events);\n\n\tif (event) {\n\t\titer->ent_size = ring_buffer_event_length(event);\n\t\treturn ring_buffer_event_data(event);\n\t}\n\titer->ent_size = 0;\n\treturn null;\n}\n\nstatic struct trace_entry *\n__find_next_entry(struct trace_iterator *iter, int *ent_cpu,\n\t\t  unsigned long *missing_events, u64 *ent_ts)\n{\n\tstruct ring_buffer *buffer = iter->trace_buffer->buffer;\n\tstruct trace_entry *ent, *next = null;\n\tunsigned long lost_events = 0, next_lost = 0;\n\tint cpu_file = iter->cpu_file;\n\tu64 next_ts = 0, ts;\n\tint next_cpu = -1;\n\tint next_size = 0;\n\tint cpu;\n\n\t\n\tif (cpu_file > ring_buffer_all_cpus) {\n\t\tif (ring_buffer_empty_cpu(buffer, cpu_file))\n\t\t\treturn null;\n\t\tent = peek_next_entry(iter, cpu_file, ent_ts, missing_events);\n\t\tif (ent_cpu)\n\t\t\t*ent_cpu = cpu_file;\n\n\t\treturn ent;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\n\t\tif (ring_buffer_empty_cpu(buffer, cpu))\n\t\t\tcontinue;\n\n\t\tent = peek_next_entry(iter, cpu, &ts, &lost_events);\n\n\t\t\n\t\tif (ent && (!next || ts < next_ts)) {\n\t\t\tnext = ent;\n\t\t\tnext_cpu = cpu;\n\t\t\tnext_ts = ts;\n\t\t\tnext_lost = lost_events;\n\t\t\tnext_size = iter->ent_size;\n\t\t}\n\t}\n\n\titer->ent_size = next_size;\n\n\tif (ent_cpu)\n\t\t*ent_cpu = next_cpu;\n\n\tif (ent_ts)\n\t\t*ent_ts = next_ts;\n\n\tif (missing_events)\n\t\t*missing_events = next_lost;\n\n\treturn next;\n}\n\n\nstruct trace_entry *trace_find_next_entry(struct trace_iterator *iter,\n\t\t\t\t\t  int *ent_cpu, u64 *ent_ts)\n{\n\treturn __find_next_entry(iter, ent_cpu, null, ent_ts);\n}\n\n\nvoid *trace_find_next_entry_inc(struct trace_iterator *iter)\n{\n\titer->ent = __find_next_entry(iter, &iter->cpu,\n\t\t\t\t      &iter->lost_events, &iter->ts);\n\n\tif (iter->ent)\n\t\ttrace_iterator_increment(iter);\n\n\treturn iter->ent ? iter : null;\n}\n\nstatic void trace_consume(struct trace_iterator *iter)\n{\n\tring_buffer_consume(iter->trace_buffer->buffer, iter->cpu, &iter->ts,\n\t\t\t    &iter->lost_events);\n}\n\nstatic void *s_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tint i = (int)*pos;\n\tvoid *ent;\n\n\twarn_on_once(iter->leftover);\n\n\t(*pos)++;\n\n\t\n\tif (iter->idx > i)\n\t\treturn null;\n\n\tif (iter->idx < 0)\n\t\tent = trace_find_next_entry_inc(iter);\n\telse\n\t\tent = iter;\n\n\twhile (ent && iter->idx < i)\n\t\tent = trace_find_next_entry_inc(iter);\n\n\titer->pos = *pos;\n\n\treturn ent;\n}\n\nvoid tracing_iter_reset(struct trace_iterator *iter, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_iter *buf_iter;\n\tunsigned long entries = 0;\n\tu64 ts;\n\n\tper_cpu_ptr(iter->trace_buffer->data, cpu)->skipped_entries = 0;\n\n\tbuf_iter = trace_buffer_iter(iter, cpu);\n\tif (!buf_iter)\n\t\treturn;\n\n\tring_buffer_iter_reset(buf_iter);\n\n\t\n\twhile ((event = ring_buffer_iter_peek(buf_iter, &ts))) {\n\t\tif (ts >= iter->trace_buffer->time_start)\n\t\t\tbreak;\n\t\tentries++;\n\t\tring_buffer_read(buf_iter, null);\n\t}\n\n\tper_cpu_ptr(iter->trace_buffer->data, cpu)->skipped_entries = entries;\n}\n\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu_file = iter->cpu_file;\n\tvoid *p = null;\n\tloff_t l = 0;\n\tint cpu;\n\n\t\n\tmutex_lock(&trace_types_lock);\n\tif (unlikely(tr->current_trace && iter->trace->name != tr->current_trace->name))\n\t\t*iter->trace = *tr->current_trace;\n\tmutex_unlock(&trace_types_lock);\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->trace->use_max_tr)\n\t\treturn err_ptr(-ebusy);\n#endif\n\n\tif (!iter->snapshot)\n\t\tatomic_inc(&trace_record_cmdline_disabled);\n\n\tif (*pos != iter->pos) {\n\t\titer->ent = null;\n\t\titer->cpu = 0;\n\t\titer->idx = -1;\n\n\t\tif (cpu_file == ring_buffer_all_cpus) {\n\t\t\tfor_each_tracing_cpu(cpu)\n\t\t\t\ttracing_iter_reset(iter, cpu);\n\t\t} else\n\t\t\ttracing_iter_reset(iter, cpu_file);\n\n\t\titer->leftover = 0;\n\t\tfor (p = iter; p && l < *pos; p = s_next(m, p, &l))\n\t\t\t;\n\n\t} else {\n\t\t\n\t\tif (iter->leftover)\n\t\t\tp = iter;\n\t\telse {\n\t\t\tl = *pos - 1;\n\t\t\tp = s_next(m, p, &l);\n\t\t}\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(cpu_file);\n\treturn p;\n}\n\nstatic void s_stop(struct seq_file *m, void *p)\n{\n\tstruct trace_iterator *iter = m->private;\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->trace->use_max_tr)\n\t\treturn;\n#endif\n\n\tif (!iter->snapshot)\n\t\tatomic_dec(&trace_record_cmdline_disabled);\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n}\n\nstatic void\nget_total_entries(struct trace_buffer *buf,\n\t\t  unsigned long *total, unsigned long *entries)\n{\n\tunsigned long count;\n\tint cpu;\n\n\t*total = 0;\n\t*entries = 0;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tcount = ring_buffer_entries_cpu(buf->buffer, cpu);\n\t\t\n\t\tif (per_cpu_ptr(buf->data, cpu)->skipped_entries) {\n\t\t\tcount -= per_cpu_ptr(buf->data, cpu)->skipped_entries;\n\t\t\t\n\t\t\t*total += count;\n\t\t} else\n\t\t\t*total += count +\n\t\t\t\tring_buffer_overrun_cpu(buf->buffer, cpu);\n\t\t*entries += count;\n\t}\n}\n\nstatic void print_lat_help_header(struct seq_file *m)\n{\n\tseq_puts(m, \"": 839, "\");\n\n\tcpuidle_pause();\n\tput_online_cpus();\n\n\tspin_lock_irq(&suspend_freeze_lock);\n\n out:\n\tsuspend_freeze_state = freeze_state_none;\n\tspin_unlock_irq(&suspend_freeze_lock);\n}\n\nvoid freeze_wake(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&suspend_freeze_lock, flags);\n\tif (suspend_freeze_state > freeze_state_none) {\n\t\tsuspend_freeze_state = freeze_state_wake;\n\t\twake_up(&suspend_freeze_wait_head);\n\t}\n\tspin_unlock_irqrestore(&suspend_freeze_lock, flags);\n}\nexport_symbol_gpl(freeze_wake);\n\nstatic bool valid_state(suspend_state_t state)\n{\n\t\n\treturn suspend_ops && suspend_ops->valid && suspend_ops->valid(state);\n}\n\n\nstatic bool relative_states;\n\nstatic int __init sleep_states_setup(char *str)\n{\n\trelative_states = !strncmp(str, \"": 840, "\");\n\n\tfor (bit = 0; bit < lock_usage_states; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"": 841, "\");\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\tentry = entries + i;\n\t\tif (entry->timer_flag & timer_stats_flag_deferrable) {\n\t\t\tseq_printf(m, \"": 842, "\");\n\n\tfor (i = 1; i < nr_irqs; i++) {\n\t\tdesc = irq_to_desc(i);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tdomain = desc->irq_data.domain;\n\n\t\tif (domain) {\n\t\t\tstruct irq_chip *chip;\n\t\t\tint hwirq = desc->irq_data.hwirq;\n\t\t\tbool direct;\n\n\t\t\tseq_printf(m, \"": 843, "\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -einval;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t\n\n\tcommand = strsep(&next, \"": 844, "\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, ops, count);\n\n\tif (ret >= 0)\n\t\talloc_snapshot(&global_trace);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic struct ftrace_func_command ftrace_snapshot_cmd = {\n\t.name\t\t\t= \"": 845, "\");\n\n\tif (count == -1)\n\t\tseq_puts(m, \"": 846, "\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"": 847, "\");\n\n\tif (dev->set_mode) {\n\t\tseq_printf(m, \"": 848, "\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & fmode_read) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\t\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter->hash, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}\n\nssize_t\nftrace_filter_write(struct file *file, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 1);\n}\n\nssize_t\nftrace_notrace_write(struct file *file, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 0);\n}\n\nstatic int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -einval;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -enoent;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}\n\nstatic void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & ftrace_ops_fl_enabled) {\n\t\tftrace_run_modify_code(ops, ftrace_update_calls, old_hash);\n\t\treturn;\n\t}\n\n\t\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & ftrace_ops_fl_enabled) {\n\t\t\tftrace_run_modify_code(op, ftrace_update_calls, old_hash);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(ftrace_hash_default_bits);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(ftrace_hash_default_bits, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -enomem;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -einval;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}\n\nstatic int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);\n}\n\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}\nexport_symbol_gpl(ftrace_set_filter_ip);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}\n\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}\nexport_symbol_gpl(ftrace_set_filter);\n\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}\nexport_symbol_gpl(ftrace_set_notrace);\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}\nexport_symbol_gpl(ftrace_set_global_filter);\n\n\nvoid ftrace_set_global_notrace(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 0);\n}\nexport_symbol_gpl(ftrace_set_global_notrace);\n\n\n#define ftrace_filter_size\t\tcommand_line_size\nstatic char ftrace_notrace_buf[ftrace_filter_size] __initdata;\nstatic char ftrace_filter_buf[ftrace_filter_size] __initdata;\n\n\nbool ftrace_filter_param __initdata;\n\nstatic int __init set_ftrace_notrace(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_notrace_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"": 849, "\");\n\n\tprint_circular_bug_entry(entry, depth);\n\n\treturn 0;\n}\n\nstatic inline int class_equal(struct lock_list *entry, void *data)\n{\n\treturn entry->class == data;\n}\n\nstatic noinline int print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tif (!save_trace(&this->trace))\n\t\treturn 0;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"": 850, "\");\n\n\tprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\n\n\tprintk(\"": 851, "\");\n\n\tprintk(\"": 852, "\");\n\n\treturn 0;\n}\n\nearly_param(\"": 853, "\");\n\n\treturn count;\n}\n\n\nstatic device_attr(current_clocksource, 0644, sysfs_show_current_clocksources,\n\t\t   sysfs_override_clocksource);\n\nstatic device_attr(unbind_clocksource, 0200, null, sysfs_unbind_clocksource);\n\nstatic device_attr(available_clocksource, 0444,\n\t\t   sysfs_show_available_clocksources, null);\n\nstatic struct bus_type clocksource_subsys = {\n\t.name = \"": 854, "\");\n\n\treturn ret;\n}\n__initcall(init_tracepoints);\n#endif \n\nstatic void for_each_tracepoint_range(struct tracepoint * const *begin,\n\t\tstruct tracepoint * const *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tstruct tracepoint * const *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(*iter, priv);\n}\n\n\nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}\nexport_symbol_gpl(for_each_kernel_tracepoint);\n\n#ifdef config_have_syscall_tracepoints\n\n\nstatic int sys_tracepoint_refcount;\n\nvoid syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_tsk_thread_flag(t, tif_syscall_tracepoint);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n}\n\nvoid syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_tsk_thread_flag(t, tif_syscall_tracepoint);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n#endif\n\n#include <linux/cred.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <asm/uaccess.h>\n\nstruct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *group_info;\n\tint nblocks;\n\tint i;\n\n\tnblocks = (gidsetsize + ngroups_per_block - 1) / ngroups_per_block;\n\t\n\tnblocks = nblocks ? : 1;\n\tgroup_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), gfp_user);\n\tif (!group_info)\n\t\treturn null;\n\tgroup_info->ngroups = gidsetsize;\n\tgroup_info->nblocks = nblocks;\n\tatomic_set(&group_info->usage, 1);\n\n\tif (gidsetsize <= ngroups_small)\n\t\tgroup_info->blocks[0] = group_info->small_block;\n\telse {\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tkgid_t *b;\n\t\t\tb = (void *)__get_free_page(gfp_user);\n\t\t\tif (!b)\n\t\t\t\tgoto out_undo_partial_alloc;\n\t\t\tgroup_info->blocks[i] = b;\n\t\t}\n\t}\n\treturn group_info;\n\nout_undo_partial_alloc:\n\twhile (--i >= 0) {\n\t\tfree_page((unsigned long)group_info->blocks[i]);\n\t}\n\tkfree(group_info);\n\treturn null;\n}\n\nexport_symbol(groups_alloc);\n\nvoid groups_free(struct group_info *group_info)\n{\n\tif (group_info->blocks[0] != group_info->small_block) {\n\t\tint i;\n\t\tfor (i = 0; i < group_info->nblocks; i++)\n\t\t\tfree_page((unsigned long)group_info->blocks[i]);\n\t}\n\tkfree(group_info);\n}\n\nexport_symbol(groups_free);\n\n\nstatic int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_at(group_info, i));\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -efault;\n\t}\n\treturn 0;\n}\n\n\nstatic int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -efault;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -einval;\n\n\t\tgroup_at(group_info, i) = kgid;\n\t}\n\treturn 0;\n}\n\n\nstatic void groups_sort(struct group_info *group_info)\n{\n\tint base, max, stride;\n\tint gidsetsize = group_info->ngroups;\n\n\tfor (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)\n\t\t; \n\tstride /= 3;\n\n\twhile (stride) {\n\t\tmax = gidsetsize - stride;\n\t\tfor (base = 0; base < max; base++) {\n\t\t\tint left = base;\n\t\t\tint right = left + stride;\n\t\t\tkgid_t tmp = group_at(group_info, right);\n\n\t\t\twhile (left >= 0 && gid_gt(group_at(group_info, left), tmp)) {\n\t\t\t\tgroup_at(group_info, right) =\n\t\t\t\t    group_at(group_info, left);\n\t\t\t\tright = left;\n\t\t\t\tleft -= stride;\n\t\t\t}\n\t\t\tgroup_at(group_info, right) = tmp;\n\t\t}\n\t\tstride /= 3;\n\t}\n}\n\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_at(group_info, mid)))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_at(group_info, mid)))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tgroups_sort(group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}\n\nexport_symbol(set_groups);\n\n\nint set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\n\tset_groups(new, group_info);\n\treturn commit_creds(new);\n}\n\nexport_symbol(set_current_groups);\n\nsyscall_define2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -einval;\n\n\t\n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -einval;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -efault;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}\n\nbool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable(user_ns, cap_setgid) &&\n\t\tuserns_may_setgroups(user_ns);\n}\n\n\n\nsyscall_define2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -eperm;\n\tif ((unsigned)gidsetsize > ngroups_max)\n\t\treturn -einval;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -enomem;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}\n\n\nint in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n\nexport_symbol(in_group_p);\n\nint in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n\nexport_symbol(in_egroup_p);\n\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#include \"": 855, "\");\n\n\tseq_puts(m, \"": 856, "\");\n\n\n\n\n#include <linux/irqflags.h>\n#include <linux/kallsyms.h>\n#include <linux/notifier.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n\n#include <linux/hw_breakpoint.h>\n\nstruct bp_cpuinfo {\n\t\n\tunsigned int\tcpu_pinned;\n\t\n\tunsigned int\t*tsk_pinned;\n\t\n\tunsigned int\tflexible; \n};\n\nstatic define_per_cpu(struct bp_cpuinfo, bp_cpuinfo[type_max]);\nstatic int nr_slots[type_max];\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}\n\n\nstatic list_head(bp_task_head);\n\nstatic int constraints_initialized;\n\n\nstruct bp_busy_slots {\n\tunsigned int pinned;\n\tunsigned int flexible;\n};\n\n\nstatic define_mutex(nr_bp_mutex);\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}\n\nstatic inline enum bp_type_idx find_slot_idx(struct perf_event *bp)\n{\n\tif (bp->attr.bp_type & hw_breakpoint_rw)\n\t\treturn type_data;\n\n\treturn type_inst;\n}\n\n\nstatic unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}\n\n\nstatic void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}\n\n\nstatic void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}\n\n\nstatic void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}\n\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}\n\n\n__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t\n}\n\n\nstatic int __reserve_bp_slot(struct perf_event *bp)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t\n\tif (!constraints_initialized)\n\t\treturn -enomem;\n\n\t\n\tif (bp->attr.bp_type == hw_breakpoint_empty ||\n\t    bp->attr.bp_type == hw_breakpoint_invalid)\n\t\treturn -einval;\n\n\ttype = find_slot_idx(bp);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t\n\tfetch_this_slot(&slots, weight);\n\n\t\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -enospc;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}\n\nint reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\n\tret = __reserve_bp_slot(bp);\n\n\tmutex_unlock(&nr_bp_mutex);\n\n\treturn ret;\n}\n\nstatic void __release_bp_slot(struct perf_event *bp)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}\n\nvoid release_bp_slot(struct perf_event *bp)\n{\n\tmutex_lock(&nr_bp_mutex);\n\n\tarch_unregister_hw_breakpoint(bp);\n\t__release_bp_slot(bp);\n\n\tmutex_unlock(&nr_bp_mutex);\n}\n\n\nint dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp);\n}\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp);\n\n\treturn 0;\n}\n\nstatic int validate_hw_breakpoint(struct perf_event *bp)\n{\n\tint ret;\n\n\tret = arch_validate_hwbkpt_settings(bp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (arch_check_bp_in_kernelspace(bp)) {\n\t\tif (bp->attr.exclude_kernel)\n\t\t\treturn -einval;\n\t\t\n\t\tif (!capable(cap_sys_admin))\n\t\t\treturn -eperm;\n\t}\n\n\treturn 0;\n}\n\nint register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tint ret;\n\n\tret = reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = validate_hw_breakpoint(bp);\n\n\t\n\tif (ret)\n\t\trelease_bp_slot(bp);\n\n\treturn ret;\n}\n\n\nstruct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\n{\n\treturn perf_event_create_kernel_counter(attr, -1, tsk, triggered,\n\t\t\t\t\t\tcontext);\n}\nexport_symbol_gpl(register_user_hw_breakpoint);\n\n\nint modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\tu64 old_addr = bp->attr.bp_addr;\n\tu64 old_len = bp->attr.bp_len;\n\tint old_type = bp->attr.bp_type;\n\tint err = 0;\n\n\t\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\t__perf_event_disable(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\tbp->attr.bp_addr = attr->bp_addr;\n\tbp->attr.bp_type = attr->bp_type;\n\tbp->attr.bp_len = attr->bp_len;\n\n\tif (attr->disabled)\n\t\tgoto end;\n\n\terr = validate_hw_breakpoint(bp);\n\tif (!err)\n\t\tperf_event_enable(bp);\n\n\tif (err) {\n\t\tbp->attr.bp_addr = old_addr;\n\t\tbp->attr.bp_type = old_type;\n\t\tbp->attr.bp_len = old_len;\n\t\tif (!bp->attr.disabled)\n\t\t\tperf_event_enable(bp);\n\n\t\treturn err;\n\t}\n\nend:\n\tbp->attr.disabled = attr->disabled;\n\n\treturn 0;\n}\nexport_symbol_gpl(modify_user_hw_breakpoint);\n\n\nvoid unregister_hw_breakpoint(struct perf_event *bp)\n{\n\tif (!bp)\n\t\treturn;\n\tperf_event_release_kernel(bp);\n}\nexport_symbol_gpl(unregister_hw_breakpoint);\n\n\nstruct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\n{\n\tstruct perf_event * __percpu *cpu_events, *bp;\n\tlong err = 0;\n\tint cpu;\n\n\tcpu_events = alloc_percpu(typeof(*cpu_events));\n\tif (!cpu_events)\n\t\treturn (void __percpu __force *)err_ptr(-enomem);\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tbp = perf_event_create_kernel_counter(attr, cpu, null,\n\t\t\t\t\t\t      triggered, context);\n\t\tif (is_err(bp)) {\n\t\t\terr = ptr_err(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\tper_cpu(*cpu_events, cpu) = bp;\n\t}\n\tput_online_cpus();\n\n\tif (likely(!err))\n\t\treturn cpu_events;\n\n\tunregister_wide_hw_breakpoint(cpu_events);\n\treturn (void __percpu __force *)err_ptr(err);\n}\nexport_symbol_gpl(register_wide_hw_breakpoint);\n\n\nvoid unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}\nexport_symbol_gpl(unregister_wide_hw_breakpoint);\n\nstatic struct notifier_block hw_breakpoint_exceptions_nb = {\n\t.notifier_call = hw_breakpoint_exceptions_notify,\n\t\n\t.priority = 0x7fffffff\n};\n\nstatic void bp_perf_event_destroy(struct perf_event *event)\n{\n\trelease_bp_slot(event);\n}\n\nstatic int hw_breakpoint_event_init(struct perf_event *bp)\n{\n\tint err;\n\n\tif (bp->attr.type != perf_type_breakpoint)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(bp))\n\t\treturn -eopnotsupp;\n\n\terr = register_perf_hw_breakpoint(bp);\n\tif (err)\n\t\treturn err;\n\n\tbp->destroy = bp_perf_event_destroy;\n\n\treturn 0;\n}\n\nstatic int hw_breakpoint_add(struct perf_event *bp, int flags)\n{\n\tif (!(flags & perf_ef_start))\n\t\tbp->hw.state = perf_hes_stopped;\n\n\tif (is_sampling_event(bp)) {\n\t\tbp->hw.last_period = bp->hw.sample_period;\n\t\tperf_swevent_set_period(bp);\n\t}\n\n\treturn arch_install_hw_breakpoint(bp);\n}\n\nstatic void hw_breakpoint_del(struct perf_event *bp, int flags)\n{\n\tarch_uninstall_hw_breakpoint(bp);\n}\n\nstatic void hw_breakpoint_start(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = 0;\n}\n\nstatic void hw_breakpoint_stop(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = perf_hes_stopped;\n}\n\nstatic struct pmu perf_breakpoint = {\n\t.task_ctx_nr\t= perf_sw_context, \n\n\t.event_init\t= hw_breakpoint_event_init,\n\t.add\t\t= hw_breakpoint_add,\n\t.del\t\t= hw_breakpoint_del,\n\t.start\t\t= hw_breakpoint_start,\n\t.stop\t\t= hw_breakpoint_stop,\n\t.read\t\t= hw_breakpoint_pmu_read,\n};\n\nint __init init_hw_breakpoint(void)\n{\n\tint cpu, err_cpu;\n\tint i;\n\n\tfor (i = 0; i < type_max; i++)\n\t\tnr_slots[i] = hw_breakpoint_slots(i);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < type_max; i++) {\n\t\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, i);\n\n\t\t\tinfo->tsk_pinned = kcalloc(nr_slots[i], sizeof(int),\n\t\t\t\t\t\t\tgfp_kernel);\n\t\t\tif (!info->tsk_pinned)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\tconstraints_initialized = 1;\n\n\tperf_pmu_register(&perf_breakpoint, \"": 857, "\");\n\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tprintk(\"": 858, "\");\n\n out_enable:\n\ttrace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n \tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}\nexport_symbol_gpl(ftrace_dump);\n\n__init static int tracer_alloc_buffers(void)\n{\n\tint ring_buf_size;\n\tint ret = -enomem;\n\n\tif (!alloc_cpumask_var(&tracing_buffer_mask, gfp_kernel))\n\t\tgoto out;\n\n\tif (!alloc_cpumask_var(&global_trace.tracing_cpumask, gfp_kernel))\n\t\tgoto out_free_buffer_mask;\n\n\t\n\tif (__stop___trace_bprintk_fmt != __start___trace_bprintk_fmt)\n\t\t\n\t\ttrace_printk_init_buffers();\n\n\t\n\tif (ring_buffer_expanded)\n\t\tring_buf_size = trace_buf_size;\n\telse\n\t\tring_buf_size = 1;\n\n\tcpumask_copy(tracing_buffer_mask, cpu_possible_mask);\n\tcpumask_copy(global_trace.tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&global_trace.start_lock);\n\n\t\n\ttemp_buffer = ring_buffer_alloc(page_size, rb_fl_overwrite);\n\tif (!temp_buffer)\n\t\tgoto out_free_cpumask;\n\n\tif (trace_create_savedcmd() < 0)\n\t\tgoto out_free_temp_buffer;\n\n\t\n\tif (allocate_trace_buffers(&global_trace, ring_buf_size) < 0) {\n\t\tprintk(kern_err \"": 859, "\");\n\n#ifdef config_boot_printk_delay\n\nstatic int boot_delay; \nstatic unsigned long long loops_per_msec;\t\n\nstatic int __init boot_delay_setup(char *str)\n{\n\tunsigned long lpj;\n\n\tlpj = preset_lpj ? preset_lpj : 1000000;\t\n\tloops_per_msec = (unsigned long long)lpj / 1000 * hz;\n\n\tget_option(&str, &boot_delay);\n\tif (boot_delay > 10 * 1000)\n\t\tboot_delay = 0;\n\n\tpr_debug(\"": 860, "\");\n\n#ifdef config_tracer_snapshot\n\ttrace_create_file(\"": 861, "\");\n\nstatic void check_cpu_stall(struct rcu_ctrlblk *rcp)\n{\n\tunsigned long j;\n\tunsigned long js;\n\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\trcp->ticks_this_gp++;\n\tj = jiffies;\n\tjs = access_once(rcp->jiffies_stall);\n\tif (rcp->rcucblist && ulong_cmp_ge(j, js)) {\n\t\tpr_err(\"": 862, "\");\n#else\n\tseq_puts(m, \"": 863, "\");\n#endif\n\tfor (s = buf; *s; s++)\n\t\tif (isdigit(*s) || *s == ',')\n\t\t\tbreak;\n\tidx = simple_strtoul(s, null, 10);\n\t*s = 0;\n\n\t__add_preferred_console(buf, idx, options, brl_options);\n\tconsole_set_on_cmdline = 1;\n\treturn 1;\n}\n__setup(\"": 864, "\");\n#endif\n\tseq_puts(m, \"": 865, "\");\n#endif\n\nstatic int suspend_test(int level)\n{\n#ifdef config_pm_debug\n\tif (pm_test_level == level) {\n\t\tprintk(kern_info \"": 866, "\");\n#endif\n}\n#endif\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tseq_printf(m, \"": 867, "\");\n#ifdef config_high_res_timers\n\tseq_printf(m, \"": 868, "\");\n#ifdef config_ring_buffer_allow_swap\n\tseq_puts(m, \"": 869, "\");\nmodule_description(\"": 870, "\");\nmodule_license(\"": 871, "\");\n}\n\n\nstatic noinline int\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tprintk(\"": 872, "\");\n}\n\n#ifdef config_tracer_max_trace\nstatic void show_snapshot_main_help(struct seq_file *m)\n{\n\tseq_puts(m, \"": 873, "\");\n}\n\nstatic int\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tprintk(\"": 874, "\");\n}\n\nstatic int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef config_generic_clockevents\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}\n\nvoid sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(null, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(null, cpu, now);\n\n#ifdef config_generic_clockevents\n\ttimer_list_show_tickdevices_header(null);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(null, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef config_generic_clockevents\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn null;\n#else\n\t\t\treturn null;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}\n\nstatic void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}\n\nstatic void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}\n\nstatic void timer_list_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations timer_list_sops = {\n\t.start = timer_list_start,\n\t.next = timer_list_next,\n\t.stop = timer_list_stop,\n\t.show = timer_list_show,\n};\n\nstatic int timer_list_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open_private(filp, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter));\n}\n\nstatic const struct file_operations timer_list_fops = {\n\t.open\t\t= timer_list_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_private,\n};\n\nstatic int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create(\"": 875, "\");\n}\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(clock_source_valid_for_hres | clock_source_watchdog);\n\tcs->flags |= clock_source_unstable;\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}\n\n\nvoid clocksource_mark_unstable(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (!(cs->flags & clock_source_unstable)) {\n\t\tif (list_empty(&cs->wd_list))\n\t\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\t__clocksource_unstable(cs);\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}\n\nstatic void clocksource_watchdog(unsigned long data)\n{\n\tstruct clocksource *cs;\n\tcycle_t csnow, wdnow, cslast, wdlast, delta;\n\tint64_t wd_nsec, cs_nsec;\n\tint next_cpu, reset_pending;\n\n\tspin_lock(&watchdog_lock);\n\tif (!watchdog_running)\n\t\tgoto out;\n\n\treset_pending = atomic_read(&watchdog_reset_pending);\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list) {\n\n\t\t\n\t\tif (cs->flags & clock_source_unstable) {\n\t\t\tif (finished_booting)\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tcsnow = cs->read(cs);\n\t\twdnow = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\t\n\t\tif (!(cs->flags & clock_source_watchdog) ||\n\t\t    atomic_read(&watchdog_reset_pending)) {\n\t\t\tcs->flags |= clock_source_watchdog;\n\t\t\tcs->wd_last = wdnow;\n\t\t\tcs->cs_last = csnow;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta = clocksource_delta(wdnow, cs->wd_last, watchdog->mask);\n\t\twd_nsec = clocksource_cyc2ns(delta, watchdog->mult,\n\t\t\t\t\t     watchdog->shift);\n\n\t\tdelta = clocksource_delta(csnow, cs->cs_last, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\twdlast = cs->wd_last; \n\t\tcslast = cs->cs_last;\n\t\tcs->cs_last = csnow;\n\t\tcs->wd_last = wdnow;\n\n\t\tif (atomic_read(&watchdog_reset_pending))\n\t\t\tcontinue;\n\n\t\t\n\t\tif ((abs(cs_nsec - wd_nsec) > watchdog_threshold)) {\n\t\t\tpr_warn(\"": 876, "\");\n}\n\nstatic void print_event_info(struct trace_buffer *buf, struct seq_file *m)\n{\n\tunsigned long total;\n\tunsigned long entries;\n\n\tget_total_entries(buf, &total, &entries);\n\tseq_printf(m, \"": 877, "\");\n}\n\nstatic void print_func_help_header(struct trace_buffer *buf, struct seq_file *m)\n{\n\tprint_event_info(buf, m);\n\tseq_puts(m, \"": 878, "\");\n}\n\nstatic void print_func_help_header_irq(struct trace_buffer *buf, struct seq_file *m)\n{\n\tprint_event_info(buf, m);\n\tseq_puts(m, \"": 879, "\");\n}\n\nstatic void print_snapshot_help(struct seq_file *m, struct trace_iterator *iter)\n{\n\tif (iter->tr->allocated_snapshot)\n\t\tseq_puts(m, \"": 880, "\");\n}\n\nstatic void show_snapshot_percpu_help(struct seq_file *m)\n{\n\tseq_puts(m, \"": 881, "\");\n}\n\nstatic void test_cpu_buff_start(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (!(trace_flags & trace_iter_annotate))\n\t\treturn;\n\n\tif (!(iter->iter_flags & trace_file_annotate))\n\t\treturn;\n\n\tif (cpumask_test_cpu(iter->cpu, iter->started))\n\t\treturn;\n\n\tif (per_cpu_ptr(iter->trace_buffer->data, iter->cpu)->skipped_entries)\n\t\treturn;\n\n\tcpumask_set_cpu(iter->cpu, iter->started);\n\n\t\n\tif (iter->idx > 1)\n\t\ttrace_seq_printf(s, \"": 882, "\");\n}\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef config_generic_clockevents_broadcast\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tseq_printf(m, \"": 883, "\");\n}\n\nvoid\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (trace_flags & trace_iter_sym_mask);\n\tstruct trace_buffer *buf = iter->trace_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"": 884, "\");\n}\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n\nvoid tracing_record_cmdline(struct task_struct *tsk)\n{\n\tif (atomic_read(&trace_record_cmdline_disabled) || !tracing_is_on())\n\t\treturn;\n\n\tif (!__this_cpu_read(trace_cmdline_save))\n\t\treturn;\n\n\tif (trace_save_cmdline(tsk))\n\t\t__this_cpu_write(trace_cmdline_save, false);\n}\n\nvoid\ntracing_generic_entry_update(struct trace_entry *entry, unsigned long flags,\n\t\t\t     int pc)\n{\n\tstruct task_struct *tsk = current;\n\n\tentry->preempt_count\t\t= pc & 0xff;\n\tentry->pid\t\t\t= (tsk) ? tsk->pid : 0;\n\tentry->flags =\n#ifdef config_trace_irqflags_support\n\t\t(irqs_disabled_flags(flags) ? trace_flag_irqs_off : 0) |\n#else\n\t\ttrace_flag_irqs_nosupport |\n#endif\n\t\t((pc & hardirq_mask) ? trace_flag_hardirq : 0) |\n\t\t((pc & softirq_mask) ? trace_flag_softirq : 0) |\n\t\t(tif_need_resched() ? trace_flag_need_resched : 0) |\n\t\t(test_preempt_need_resched() ? trace_flag_preempt_resched : 0);\n}\nexport_symbol_gpl(tracing_generic_entry_update);\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *event;\n\n\tevent = ring_buffer_lock_reserve(buffer, len);\n\tif (event != null) {\n\t\tstruct trace_entry *ent = ring_buffer_event_data(event);\n\n\t\ttracing_generic_entry_update(ent, flags, pc);\n\t\tent->type = type;\n\t}\n\n\treturn event;\n}\n\nvoid\n__buffer_unlock_commit(struct ring_buffer *buffer, struct ring_buffer_event *event)\n{\n\t__this_cpu_write(trace_cmdline_save, true);\n\tring_buffer_unlock_commit(buffer, event);\n}\n\nstatic inline void\n__trace_buffer_unlock_commit(struct ring_buffer *buffer,\n\t\t\t     struct ring_buffer_event *event,\n\t\t\t     unsigned long flags, int pc)\n{\n\t__buffer_unlock_commit(buffer, event);\n\n\tftrace_trace_stack(buffer, flags, 6, pc);\n\tftrace_trace_userstack(buffer, flags, pc);\n}\n\nvoid trace_buffer_unlock_commit(struct ring_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *event,\n\t\t\t\tunsigned long flags, int pc)\n{\n\t__trace_buffer_unlock_commit(buffer, event, flags, pc);\n}\nexport_symbol_gpl(trace_buffer_unlock_commit);\n\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct ftrace_event_file *ftrace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\n\t*current_rb = ftrace_file->tr->trace_buffer.buffer;\n\tentry = trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t type, len, flags, pc);\n\t\n\tif (!entry && ftrace_file->flags & ftrace_event_fl_trigger_cond) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t  type, len, flags, pc);\n\t}\n\treturn entry;\n}\nexport_symbol_gpl(trace_event_buffer_lock_reserve);\n\nstruct ring_buffer_event *\ntrace_current_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t\t  int type, unsigned long len,\n\t\t\t\t  unsigned long flags, int pc)\n{\n\t*current_rb = global_trace.trace_buffer.buffer;\n\treturn trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t type, len, flags, pc);\n}\nexport_symbol_gpl(trace_current_buffer_lock_reserve);\n\nvoid trace_current_buffer_unlock_commit(struct ring_buffer *buffer,\n\t\t\t\t\tstruct ring_buffer_event *event,\n\t\t\t\t\tunsigned long flags, int pc)\n{\n\t__trace_buffer_unlock_commit(buffer, event, flags, pc);\n}\nexport_symbol_gpl(trace_current_buffer_unlock_commit);\n\nvoid trace_buffer_unlock_commit_regs(struct ring_buffer *buffer,\n\t\t\t\t     struct ring_buffer_event *event,\n\t\t\t\t     unsigned long flags, int pc,\n\t\t\t\t     struct pt_regs *regs)\n{\n\t__buffer_unlock_commit(buffer, event);\n\n\tftrace_trace_stack_regs(buffer, flags, 0, pc, regs);\n\tftrace_trace_userstack(buffer, flags, pc);\n}\nexport_symbol_gpl(trace_buffer_unlock_commit_regs);\n\nvoid trace_current_buffer_discard_commit(struct ring_buffer *buffer,\n\t\t\t\t\t struct ring_buffer_event *event)\n{\n\tring_buffer_discard_commit(buffer, event);\n}\nexport_symbol_gpl(trace_current_buffer_discard_commit);\n\nvoid\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct ftrace_event_call *call = &event_function;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\t\n\tif (unlikely(__this_cpu_read(ftrace_cpu_disabled)))\n\t\treturn;\n\n\tevent = trace_buffer_lock_reserve(buffer, trace_fn, sizeof(*entry),\n\t\t\t\t\t  flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n}\n\n#ifdef config_stacktrace\n\n#define ftrace_stack_max_entries (page_size / sizeof(unsigned long))\nstruct ftrace_stack {\n\tunsigned long\t\tcalls[ftrace_stack_max_entries];\n};\n\nstatic define_per_cpu(struct ftrace_stack, ftrace_stack);\nstatic define_per_cpu(int, ftrace_stack_reserve);\n\nstatic void __ftrace_trace_stack(struct ring_buffer *buffer,\n\t\t\t\t unsigned long flags,\n\t\t\t\t int skip, int pc, struct pt_regs *regs)\n{\n\tstruct ftrace_event_call *call = &event_kernel_stack;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\tstruct stack_trace trace;\n\tint use_stack;\n\tint size = ftrace_stack_entries;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.skip\t\t= skip;\n\n\t\n\tpreempt_disable_notrace();\n\n\tuse_stack = __this_cpu_inc_return(ftrace_stack_reserve);\n\t\n\tbarrier();\n\tif (use_stack == 1) {\n\t\ttrace.entries\t\t= this_cpu_ptr(ftrace_stack.calls);\n\t\ttrace.max_entries\t= ftrace_stack_max_entries;\n\n\t\tif (regs)\n\t\t\tsave_stack_trace_regs(regs, &trace);\n\t\telse\n\t\t\tsave_stack_trace(&trace);\n\n\t\tif (trace.nr_entries > size)\n\t\t\tsize = trace.nr_entries;\n\t} else\n\t\t\n\t\tuse_stack = 0;\n\n\tsize *= sizeof(unsigned long);\n\n\tevent = trace_buffer_lock_reserve(buffer, trace_stack,\n\t\t\t\t\t  sizeof(*entry) + size, flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\n\tmemset(&entry->caller, 0, size);\n\n\tif (use_stack)\n\t\tmemcpy(&entry->caller, trace.entries,\n\t\t       trace.nr_entries * sizeof(unsigned long));\n\telse {\n\t\ttrace.max_entries\t= ftrace_stack_entries;\n\t\ttrace.entries\t\t= entry->caller;\n\t\tif (regs)\n\t\t\tsave_stack_trace_regs(regs, &trace);\n\t\telse\n\t\t\tsave_stack_trace(&trace);\n\t}\n\n\tentry->size = trace.nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n\n out:\n\t\n\tbarrier();\n\t__this_cpu_dec(ftrace_stack_reserve);\n\tpreempt_enable_notrace();\n\n}\n\nvoid ftrace_trace_stack_regs(struct ring_buffer *buffer, unsigned long flags,\n\t\t\t     int skip, int pc, struct pt_regs *regs)\n{\n\tif (!(trace_flags & trace_iter_stacktrace))\n\t\treturn;\n\n\t__ftrace_trace_stack(buffer, flags, skip, pc, regs);\n}\n\nvoid ftrace_trace_stack(struct ring_buffer *buffer, unsigned long flags,\n\t\t\tint skip, int pc)\n{\n\tif (!(trace_flags & trace_iter_stacktrace))\n\t\treturn;\n\n\t__ftrace_trace_stack(buffer, flags, skip, pc, null);\n}\n\nvoid __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\t__ftrace_trace_stack(tr->trace_buffer.buffer, flags, skip, pc, null);\n}\n\n\nvoid trace_dump_stack(int skip)\n{\n\tunsigned long flags;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\n\t\n\tskip += 3;\n\t__ftrace_trace_stack(global_trace.trace_buffer.buffer,\n\t\t\t     flags, skip, preempt_count(), null);\n}\n\nstatic define_per_cpu(int, user_stack_count);\n\nvoid\nftrace_trace_userstack(struct ring_buffer *buffer, unsigned long flags, int pc)\n{\n\tstruct ftrace_event_call *call = &event_user_stack;\n\tstruct ring_buffer_event *event;\n\tstruct userstack_entry *entry;\n\tstruct stack_trace trace;\n\n\tif (!(trace_flags & trace_iter_userstacktrace))\n\t\treturn;\n\n\t\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\t\n\tpreempt_disable();\n\tif (__this_cpu_read(user_stack_count))\n\t\tgoto out;\n\n\t__this_cpu_inc(user_stack_count);\n\n\tevent = trace_buffer_lock_reserve(buffer, trace_user_stack,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\tgoto out_drop_count;\n\tentry\t= ring_buffer_event_data(event);\n\n\tentry->tgid\t\t= current->tgid;\n\tmemset(&entry->caller, 0, sizeof(entry->caller));\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= ftrace_stack_entries;\n\ttrace.skip\t\t= 0;\n\ttrace.entries\t\t= entry->caller;\n\n\tsave_stack_trace_user(&trace);\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n\n out_drop_count:\n\t__this_cpu_dec(user_stack_count);\n out:\n\tpreempt_enable();\n}\n\n#ifdef unused\nstatic void __trace_userstack(struct trace_array *tr, unsigned long flags)\n{\n\tftrace_trace_userstack(tr, flags, preempt_count());\n}\n#endif \n\n#endif \n\n\nstruct trace_buffer_struct {\n\tchar buffer[trace_buf_size];\n};\n\nstatic struct trace_buffer_struct *trace_percpu_buffer;\nstatic struct trace_buffer_struct *trace_percpu_sirq_buffer;\nstatic struct trace_buffer_struct *trace_percpu_irq_buffer;\nstatic struct trace_buffer_struct *trace_percpu_nmi_buffer;\n\n\nstatic char *get_trace_buf(void)\n{\n\tstruct trace_buffer_struct *percpu_buffer;\n\n\t\n\tif (in_nmi())\n\t\tpercpu_buffer = trace_percpu_nmi_buffer;\n\telse if (in_irq())\n\t\tpercpu_buffer = trace_percpu_irq_buffer;\n\telse if (in_softirq())\n\t\tpercpu_buffer = trace_percpu_sirq_buffer;\n\telse\n\t\tpercpu_buffer = trace_percpu_buffer;\n\n\tif (!percpu_buffer)\n\t\treturn null;\n\n\treturn this_cpu_ptr(&percpu_buffer->buffer[0]);\n}\n\nstatic int alloc_percpu_trace_buffer(void)\n{\n\tstruct trace_buffer_struct *buffers;\n\tstruct trace_buffer_struct *sirq_buffers;\n\tstruct trace_buffer_struct *irq_buffers;\n\tstruct trace_buffer_struct *nmi_buffers;\n\n\tbuffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!buffers)\n\t\tgoto err_warn;\n\n\tsirq_buffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!sirq_buffers)\n\t\tgoto err_sirq;\n\n\tirq_buffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!irq_buffers)\n\t\tgoto err_irq;\n\n\tnmi_buffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!nmi_buffers)\n\t\tgoto err_nmi;\n\n\ttrace_percpu_buffer = buffers;\n\ttrace_percpu_sirq_buffer = sirq_buffers;\n\ttrace_percpu_irq_buffer = irq_buffers;\n\ttrace_percpu_nmi_buffer = nmi_buffers;\n\n\treturn 0;\n\n err_nmi:\n\tfree_percpu(irq_buffers);\n err_irq:\n\tfree_percpu(sirq_buffers);\n err_sirq:\n\tfree_percpu(buffers);\n err_warn:\n\twarn(1, \"": 885, "\");\\n\"": 886, "\")\\n\"": 887, "\")\\n\\t=> (\"": 888, "\"){%s}\"": 889, "\"*\"": 890, "\"*** can not use snapshot (sorry) ***\\n\"": 891, "\"*** latency tracer active ***\\n\"": 892, "\"*** snapshot called from nmi context ***\\n\"": 893, "\"*** snapshot is being ignored        ***\\n\"": 894, "\"*** snapshot not allocated ***\\n\"": 895, "\"*** stopping trace here!   ***\\n\"": 896, "\"*=\"": 897, "\"*callback never called* \"": 898, "\"*callback not called expected 2 times (%d)* \"": 899, "\"*callback not called once (%d)* \"": 900, "\"*callback received null regs* \"": 901, "\"*callback received regs without arch support* \"": 902, "\"*could not register callback* \"": 903, "\"*could not set filter* \"": 904, "\"*registered save-regs without arch support* \"": 905, "\"*warning* lock debugging disabled!! - possibly due to a lockdep warning\\n\"": 906, "\"+%#lx/%#lx\"": 907, "\"++=\"": 908, "\"+0x%lx\"": 909, "\"+=\"": 910, "\"+rm\"": 911, "\",\t\t\t\n kdb_platform_env,\n \"": 912, "\",\n\t\t\t\t\t\t\t\tt, usec_rem);\n\n\t\tt = ns2usecs(ring_buffer_time_stamp(trace_buf->buffer, cpu));\n\t\tusec_rem = do_div(t, usec_per_sec);\n\t\ttrace_seq_printf(s, \"": 913, "\",\n\t\t\t\t\t    size >> 10,\n\t\t\t\t\t    trace_buf_size >> 10);\n\t\t\telse\n\t\t\t\tr = sprintf(buf, \"": 914, "\",\n\t\t\t\t\t   (void *)ops->trampoline);\n\t\t\telse\n\t\t\t\tseq_puts(m, \"": 915, "\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"": 916, "\",\n\t\t\t\t\tbcon->name, bcon->index))\n\t\t\t\treturn;\n\n\t\n\tif (console_drivers && newcon->flags & con_boot) {\n\t\t\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & con_boot)) {\n\t\t\t\tpr_info(\"": 917, "\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & con_boot)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\t\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == null ||\n\t\t    newcon->setup(newcon, null) == 0) {\n\t\t\tnewcon->flags |= con_enabled;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= con_consdev;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0, c = console_cmdline;\n\t     i < max_cmdlineconsoles && c->name[0];\n\t     i++, c++) {\n\t\tif (!newcon->match ||\n\t\t    newcon->match(newcon, c->name, c->index, c->options) != 0) {\n\t\t\t\n\t\t\tbuild_bug_on(sizeof(c->name) != sizeof(newcon->name));\n\t\t\tif (strcmp(c->name, newcon->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index >= 0 &&\n\t\t\t    newcon->index != c->index)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index < 0)\n\t\t\t\tnewcon->index = c->index;\n\n\t\t\tif (_braille_register_console(newcon, c))\n\t\t\t\treturn;\n\n\t\t\tif (newcon->setup &&\n\t\t\t    newcon->setup(newcon, c->options) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnewcon->flags |= con_enabled;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= con_consdev;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & con_enabled))\n\t\treturn;\n\n\t\n\tif (bcon && ((newcon->flags & (con_consdev | con_boot)) == con_consdev))\n\t\tnewcon->flags &= ~con_printbuffer;\n\n\t\n\tconsole_lock();\n\tif ((newcon->flags & con_consdev) || console_drivers == null) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~con_consdev;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & con_printbuffer) {\n\t\t\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tconsole_seq = syslog_seq;\n\t\tconsole_idx = syslog_idx;\n\t\tconsole_prev = syslog_prev;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t\n\tpr_info(\"": 918, "\",\n\t\t\t\t      (unsigned)(log_first_seq - console_seq));\n\n\t\t\t\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t\tconsole_prev = 0;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (msg->flags & log_nocons) {\n\t\t\t\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\t\n\t\t\tmsg->flags &= ~log_nocons;\n\t\t\tconsole_prev = msg->flags;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tlevel = msg->level;\n\t\tlen += msg_print_text(msg, console_prev, false,\n\t\t\t\t      text + len, sizeof(text) - len);\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\tconsole_prev = msg->flags;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\tstop_critical_timings();\t\n\t\tcall_console_drivers(level, text, len);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\n\t\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = null;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}\nexport_symbol(console_unlock);\n\n\nvoid __sched console_conditional_schedule(void)\n{\n\tif (console_may_schedule)\n\t\tcond_resched();\n}\nexport_symbol(console_conditional_schedule);\n\nvoid console_unblank(void)\n{\n\tstruct console *c;\n\n\t\n\tif (oops_in_progress) {\n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\tfor_each_console(c)\n\t\tif ((c->flags & con_enabled) && c->unblank)\n\t\t\tc->unblank();\n\tconsole_unlock();\n}\n\n\nstruct tty_driver *console_device(int *index)\n{\n\tstruct console *c;\n\tstruct tty_driver *driver = null;\n\n\tconsole_lock();\n\tfor_each_console(c) {\n\t\tif (!c->device)\n\t\t\tcontinue;\n\t\tdriver = c->device(c, index);\n\t\tif (driver)\n\t\t\tbreak;\n\t}\n\tconsole_unlock();\n\treturn driver;\n}\n\n\nvoid console_stop(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags &= ~con_enabled;\n\tconsole_unlock();\n}\nexport_symbol(console_stop);\n\nvoid console_start(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags |= con_enabled;\n\tconsole_unlock();\n}\nexport_symbol(console_start);\n\nstatic int __read_mostly keep_bootcon;\n\nstatic int __init keep_bootcon_setup(char *str)\n{\n\tkeep_bootcon = 1;\n\tpr_info(\"": 919, "\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags &\n\t\t\t     ~(kdb_debug_flag_mask << kdb_debug_flag_shift))\n\t\t\t| (debugflags << kdb_debug_flag_shift);\n\n\t\treturn 0;\n\t}\n\n\t\n\tvarlen = strlen(argv[1]);\n\tvallen = strlen(argv[2]);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn kdb_envbuffull;\n\n\tsprintf(ep, \"": 920, "\",\n\t\t\t\t   (hwirq < domain->revmap_size) ? \"": 921, "\",\n\t\t\t\t   direct ? \"": 922, "\",\n\t\t\t\t   trace_boot_clock);\n\t}\n\n\t\n\tglobal_trace.current_trace = &nop_trace;\n\n\tglobal_trace.max_lock = (arch_spinlock_t)__arch_spin_lock_unlocked;\n\n\tftrace_init_global_array_ops(&global_trace);\n\n\tregister_tracer(&nop_trace);\n\n\t\n\ttracing_disabled = 0;\n\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &trace_panic_notifier);\n\n\tregister_die_notifier(&trace_die_notifier);\n\n\tglobal_trace.flags = trace_array_fl_global;\n\n\tinit_list_head(&global_trace.systems);\n\tinit_list_head(&global_trace.events);\n\tlist_add(&global_trace.list, &ftrace_trace_arrays);\n\n\twhile (trace_boot_options) {\n\t\tchar *option;\n\n\t\toption = strsep(&trace_boot_options, \"": 923, "\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\treturn 0;\n\t\t}\n\t\treturn -eperm;\n\t}\n\treturn security_syslog(type);\n}\n\n\n\nstruct devkmsg_user {\n\tu64 seq;\n\tu32 idx;\n\tenum log_flags prev;\n\tstruct mutex lock;\n\tchar buf[8192];\n};\n\nstatic ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tchar *buf, *line;\n\tint i;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret = len;\n\n\tif (len > log_line_max)\n\t\treturn -einval;\n\tbuf = kmalloc(len+1, gfp_kernel);\n\tif (buf == null)\n\t\treturn -enomem;\n\n\tbuf[len] = '\\0';\n\tif (copy_from_iter(buf, len, from) != len) {\n\t\tkfree(buf);\n\t\treturn -efault;\n\t}\n\n\t\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = null;\n\n\t\ti = simple_strtoul(line+1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = i & 7;\n\t\t\tif (i >> 3)\n\t\t\t\tfacility = i >> 3;\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\n\tprintk_emit(facility, level, null, 0, \"": 924, "\",\n\t\t\t\t entry->pid, iter->cpu, iter->ts);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn trace_type_partial_line;\n\n\tevent = ftrace_find_event(entry->type);\n\tif (event)\n\t\treturn event->funcs->raw(iter, 0, event);\n\n\ttrace_seq_printf(s, \"": 925, "\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"": 926, "\",\n\t\t\t\t iter->cpu, iter->lost_events);\n\t\tif (trace_seq_has_overflowed(&iter->seq))\n\t\t\treturn trace_type_partial_line;\n\t}\n\n\tif (iter->trace && iter->trace->print_line) {\n\t\tret = iter->trace->print_line(iter);\n\t\tif (ret != trace_type_unhandled)\n\t\t\treturn ret;\n\t}\n\n\tif (iter->ent->type == trace_bputs &&\n\t\t\ttrace_flags & trace_iter_printk &&\n\t\t\ttrace_flags & trace_iter_printk_msgonly)\n\t\treturn trace_print_bputs_msg_only(iter);\n\n\tif (iter->ent->type == trace_bprint &&\n\t\t\ttrace_flags & trace_iter_printk &&\n\t\t\ttrace_flags & trace_iter_printk_msgonly)\n\t\treturn trace_print_bprintk_msg_only(iter);\n\n\tif (iter->ent->type == trace_print &&\n\t\t\ttrace_flags & trace_iter_printk &&\n\t\t\ttrace_flags & trace_iter_printk_msgonly)\n\t\treturn trace_print_printk_msg_only(iter);\n\n\tif (trace_flags & trace_iter_bin)\n\t\treturn print_bin_fmt(iter);\n\n\tif (trace_flags & trace_iter_hex)\n\t\treturn print_hex_fmt(iter);\n\n\tif (trace_flags & trace_iter_raw)\n\t\treturn print_raw_fmt(iter);\n\n\treturn print_trace_fmt(iter);\n}\n\nvoid trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\n\t\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & trace_file_lat_fmt)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(trace_flags & trace_iter_verbose))\n\t\tprint_lat_help_header(m);\n}\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\n\tif (!(trace_flags & trace_iter_context_info))\n\t\treturn;\n\n\tif (iter->iter_flags & trace_file_lat_fmt) {\n\t\t\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & trace_iter_verbose))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & trace_iter_verbose)) {\n\t\t\tif (trace_flags & trace_iter_irq_info)\n\t\t\t\tprint_func_help_header_irq(iter->trace_buffer, m);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->trace_buffer, m);\n\t\t}\n\t}\n}\n\nstatic void test_ftrace_alive(struct seq_file *m)\n{\n\tif (!ftrace_is_dead())\n\t\treturn;\n\tseq_puts(m, \"": 927, "\",\n\t\t\t\tcs->name, csnow, cslast, cs->mask);\n\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(cs->flags & clock_source_valid_for_hres) &&\n\t\t    (cs->flags & clock_source_is_continuous) &&\n\t\t    (watchdog->flags & clock_source_is_continuous)) {\n\t\t\t\n\t\t\tcs->flags |= clock_source_valid_for_hres;\n\n\t\t\t\n\t\t\tif (!finished_booting)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tif (cs != curr_clocksource) {\n\t\t\t\tcs->flags |= clock_source_reselect;\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\t} else {\n\t\t\t\ttick_clock_notify();\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (reset_pending)\n\t\tatomic_dec(&watchdog_reset_pending);\n\n\t\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(cpu_online_mask);\n\twatchdog_timer.expires += watchdog_interval;\n\tadd_timer_on(&watchdog_timer, next_cpu);\nout:\n\tspin_unlock(&watchdog_lock);\n}\n\nstatic inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\tinit_timer(&watchdog_timer);\n\twatchdog_timer.function = clocksource_watchdog;\n\twatchdog_timer.expires = jiffies + watchdog_interval;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}\n\nstatic inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~clock_source_watchdog;\n}\n\nstatic void clocksource_resume_watchdog(void)\n{\n\tatomic_inc(&watchdog_reset_pending);\n}\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (cs->flags & clock_source_must_verify) {\n\t\t\n\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\tcs->flags &= ~clock_source_watchdog;\n\t} else {\n\t\t\n\t\tif (cs->flags & clock_source_is_continuous)\n\t\t\tcs->flags |= clock_source_valid_for_hres;\n\t\t\n\t\tif (!watchdog || cs->rating > watchdog->rating) {\n\t\t\twatchdog = cs;\n\t\t\t\n\t\t\tclocksource_reset_watchdog();\n\t\t}\n\t}\n\t\n\tclocksource_start_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}\n\nstatic void clocksource_dequeue_watchdog(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (cs != watchdog) {\n\t\tif (cs->flags & clock_source_must_verify) {\n\t\t\t\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t\n\t\t\tclocksource_stop_watchdog();\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}\n\nstatic int __clocksource_watchdog_kthread(void)\n{\n\tstruct clocksource *cs, *tmp;\n\tunsigned long flags;\n\tlist_head(unstable);\n\tint select = 0;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tlist_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {\n\t\tif (cs->flags & clock_source_unstable) {\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\tlist_add(&cs->wd_list, &unstable);\n\t\t\tselect = 1;\n\t\t}\n\t\tif (cs->flags & clock_source_reselect) {\n\t\t\tcs->flags &= ~clock_source_reselect;\n\t\t\tselect = 1;\n\t\t}\n\t}\n\t\n\tclocksource_stop_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n\n\t\n\tlist_for_each_entry_safe(cs, tmp, &unstable, wd_list) {\n\t\tlist_del_init(&cs->wd_list);\n\t\t__clocksource_change_rating(cs, 0);\n\t}\n\treturn select;\n}\n\nstatic int clocksource_watchdog_kthread(void *data)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (__clocksource_watchdog_kthread())\n\t\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs)\n{\n\treturn cs == watchdog;\n}\n\n#else \n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & clock_source_is_continuous)\n\t\tcs->flags |= clock_source_valid_for_hres;\n}\n\nstatic inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }\nstatic inline void clocksource_resume_watchdog(void) { }\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }\nstatic bool clocksource_is_watchdog(struct clocksource *cs) { return false; }\nvoid clocksource_mark_unstable(struct clocksource *cs) { }\n\n#endif \n\n\nvoid clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}\n\n\nvoid clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}\n\n\nvoid clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}\n\n\nstatic u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}\n\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t\n\tmax_cycles = ullong_max;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}\n\n\nstatic inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}\n\n#ifndef config_arch_uses_gettimeoffset\n\nstatic struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn null;\n\n\t\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & clock_source_valid_for_hres))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn null;\n}\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\t\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t\n\t\tif (!(cs->flags & clock_source_valid_for_hres) && oneshot) {\n\t\t\t\n\t\t\tprintk(kern_warning \"": 928, "\",\n\t\t\t\tentry->count, entry->pid, entry->comm);\n\t\t}\n\n\t\tprint_name_offset(m, (unsigned long)entry->start_func);\n\t\tseq_puts(m, \"": 929, "\",\n\t\t\t\tentry->count, entry->pid, entry->comm);\n\t\t} else {\n\t\t\tseq_printf(m, \"": 930, "\",\n\t\t\t\titer->cpu);\n}\n\nstatic enum print_line_t print_trace_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long sym_flags = (trace_flags & trace_iter_sym_mask);\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\ttest_cpu_buff_start(iter);\n\n\tevent = ftrace_find_event(entry->type);\n\n\tif (trace_flags & trace_iter_context_info) {\n\t\tif (iter->iter_flags & trace_file_lat_fmt)\n\t\t\ttrace_print_lat_context(iter);\n\t\telse\n\t\t\ttrace_print_context(iter);\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn trace_type_partial_line;\n\n\tif (event)\n\t\treturn event->funcs->trace(iter, sym_flags, event);\n\n\ttrace_seq_printf(s, \"": 931, "\",\n\t\t\t\tpm_test_delay);\n\t\tmdelay(pm_test_delay * 1000);\n\t\treturn 1;\n\t}\n#endif \n\treturn 0;\n}\n\n\nstatic int suspend_prepare(suspend_state_t state)\n{\n\tint error;\n\n\tif (!sleep_state_supported(state))\n\t\treturn -eperm;\n\n\tpm_prepare_console();\n\n\terror = pm_notifier_call_chain(pm_suspend_prepare);\n\tif (error)\n\t\tgoto finish;\n\n\ttrace_suspend_resume(tps(\"": 932, "\",\n\t\t\t\tring_buffer_oldest_event_ts(trace_buf->buffer, cpu));\n\n\t\ttrace_seq_printf(s, \"": 933, "\",\n\t\t\t\tring_buffer_time_stamp(trace_buf->buffer, cpu));\n\t}\n\n\tcnt = ring_buffer_dropped_events_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"": 934, "\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t__group_send_sig_info(sigxcpu, send_sig_priv, tsk);\n\t\t}\n\t}\n}\n\nstatic void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cputimer->lock, flags);\n\tcputimer->running = 0;\n\traw_spin_unlock_irqrestore(&cputimer->lock, flags);\n}\n\nstatic u32 onecputick;\n\nstatic void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     unsigned long long *expires,\n\t\t\t     unsigned long long cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr) {\n\t\t\tit->expires += it->incr;\n\t\t\tit->error += it->incr_error;\n\t\t\tif (it->error >= onecputick) {\n\t\t\t\tit->expires -= cputime_one_jiffy;\n\t\t\t\tit->error -= onecputick;\n\t\t\t}\n\t\t} else {\n\t\t\tit->expires = 0;\n\t\t}\n\n\t\ttrace_itimer_expire(signo == sigprof ?\n\t\t\t\t    itimer_prof : itimer_virtual,\n\t\t\t\t    tsk->signal->leader_pid, cur_time);\n\t\t__group_send_sig_info(signo, send_sig_priv, tsk);\n\t}\n\n\tif (it->expires && (!*expires || it->expires < *expires)) {\n\t\t*expires = it->expires;\n\t}\n}\n\n\nstatic void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tunsigned long long utime, ptime, virt_expires, prof_expires;\n\tunsigned long long sum_sched_runtime, sched_expires;\n\tstruct list_head *timers = sig->cpu_timers;\n\tstruct task_cputime cputime;\n\tunsigned long soft;\n\n\t\n\tthread_group_cputimer(tsk, &cputime);\n\tutime = cputime_to_expires(cputime.utime);\n\tptime = utime + cputime_to_expires(cputime.stime);\n\tsum_sched_runtime = cputime.sum_exec_runtime;\n\n\tprof_expires = check_timers_list(timers, firing, ptime);\n\tvirt_expires = check_timers_list(++timers, firing, utime);\n\tsched_expires = check_timers_list(++timers, firing, sum_sched_runtime);\n\n\t\n\tcheck_cpu_itimer(tsk, &sig->it[cpuclock_prof], &prof_expires, ptime,\n\t\t\t sigprof);\n\tcheck_cpu_itimer(tsk, &sig->it[cpuclock_virt], &virt_expires, utime,\n\t\t\t sigvtalrm);\n\tsoft = access_once(sig->rlim[rlimit_cpu].rlim_cur);\n\tif (soft != rlim_infinity) {\n\t\tunsigned long psecs = cputime_to_secs(ptime);\n\t\tunsigned long hard =\n\t\t\taccess_once(sig->rlim[rlimit_cpu].rlim_max);\n\t\tcputime_t x;\n\t\tif (psecs >= hard) {\n\t\t\t\n\t\t\t__group_send_sig_info(sigkill, send_sig_priv, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (psecs >= soft) {\n\t\t\t\n\t\t\t__group_send_sig_info(sigxcpu, send_sig_priv, tsk);\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft++;\n\t\t\t\tsig->rlim[rlimit_cpu].rlim_cur = soft;\n\t\t\t}\n\t\t}\n\t\tx = secs_to_cputime(soft);\n\t\tif (!prof_expires || x < prof_expires) {\n\t\t\tprof_expires = x;\n\t\t}\n\t}\n\n\tsig->cputime_expires.prof_exp = expires_to_cputime(prof_expires);\n\tsig->cputime_expires.virt_exp = expires_to_cputime(virt_expires);\n\tsig->cputime_expires.sched_exp = sched_expires;\n\tif (task_cputime_zero(&sig->cputime_expires))\n\t\tstop_process_timers(sig);\n}\n\n\nvoid posix_cpu_timer_schedule(struct k_itimer *timer)\n{\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tunsigned long long now;\n\n\twarn_on_once(p == null);\n\n\t\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\tif (unlikely(p->exit_state))\n\t\t\tgoto out;\n\n\t\t\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\tgoto out;\n\t} else {\n\t\t\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == null)) {\n\t\t\t\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\tgoto out;\n\t\t} else if (unlikely(p->exit_state) && thread_group_empty(p)) {\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\t\n\t}\n\n\t\n\twarn_on_once(!irqs_disabled());\n\tarm_timer(timer);\n\tunlock_task_sighand(p, &flags);\n\n\t\n\tposix_cpu_timer_kick_nohz();\nout:\n\ttimer->it_overrun_last = timer->it_overrun;\n\ttimer->it_overrun = -1;\n\t++timer->it_requeue_pending;\n}\n\n\nstatic inline int task_cputime_expired(const struct task_cputime *sample,\n\t\t\t\t\tconst struct task_cputime *expires)\n{\n\tif (expires->utime && sample->utime >= expires->utime)\n\t\treturn 1;\n\tif (expires->stime && sample->utime + sample->stime >= expires->stime)\n\t\treturn 1;\n\tif (expires->sum_exec_runtime != 0 &&\n\t    sample->sum_exec_runtime >= expires->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic inline int fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\tcputime_t utime, stime;\n\n\ttask_cputime(tsk, &utime, &stime);\n\n\tif (!task_cputime_zero(&tsk->cputime_expires)) {\n\t\tstruct task_cputime task_sample = {\n\t\t\t.utime = utime,\n\t\t\t.stime = stime,\n\t\t\t.sum_exec_runtime = tsk->se.sum_exec_runtime\n\t\t};\n\n\t\tif (task_cputime_expired(&task_sample, &tsk->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tsig = tsk->signal;\n\tif (sig->cputimer.running) {\n\t\tstruct task_cputime group_sample;\n\n\t\traw_spin_lock(&sig->cputimer.lock);\n\t\tgroup_sample = sig->cputimer.cputime;\n\t\traw_spin_unlock(&sig->cputimer.lock);\n\n\t\tif (task_cputime_expired(&group_sample, &sig->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nvoid run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tlist_head(firing);\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags;\n\n\twarn_on_once(!irqs_disabled());\n\n\t\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\t\n\tcheck_thread_timers(tsk, &firing);\n\t\n\tif (tsk->signal->cputimer.running)\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\n\tunlock_task_sighand(tsk, &flags);\n\n\t\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint cpu_firing;\n\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}\n\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   cputime_t *newval, cputime_t *oldval)\n{\n\tunsigned long long now;\n\n\twarn_on_once(clock_idx == cpuclock_sched);\n\tcpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval) {\n\t\t\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t\n\t\t\t\t*oldval = cputime_one_jiffy;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\tgoto out;\n\t\t*newval += now;\n\t}\n\n\t\n\tswitch (clock_idx) {\n\tcase cpuclock_prof:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\nout:\n\tposix_cpu_timer_kick_nohz();\n}\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    struct timespec *rqtp, struct itimerspec *it)\n{\n\tstruct k_itimer timer;\n\tint error;\n\n\t\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec zero_it;\n\n\t\tmemset(it, 0, sizeof *it);\n\t\tit->it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, it, null);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t\n\t\t\t__set_current_state(task_interruptible);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t\n\t\tsample_to_timespec(which_clock, timer.it.cpu.expires, rqtp);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, it);\n\t\tif (!error) {\n\t\t\t\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == timer_retry) {\n\t\t\t\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it->it_value.tv_sec | it->it_value.tv_nsec) == 0) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -erestart_restartblock;\n\t}\n\n\treturn error;\n}\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    struct timespec *rqtp, struct timespec __user *rmtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tstruct itimerspec it;\n\tint error;\n\n\t\n\tif (cpuclock_perthread(which_clock) &&\n\t    (cpuclock_pid(which_clock) == 0 ||\n\t     cpuclock_pid(which_clock) == current->pid))\n\t\treturn -einval;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp, &it);\n\n\tif (error == -erestart_restartblock) {\n\n\t\tif (flags & timer_abstime)\n\t\t\treturn -erestartnohand;\n\t\t\n\t\tif (rmtp && copy_to_user(rmtp, &it.it_value, sizeof *rmtp))\n\t\t\treturn -efault;\n\n\t\trestart_block->fn = posix_cpu_nsleep_restart;\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t\trestart_block->nanosleep.rmtp = rmtp;\n\t\trestart_block->nanosleep.expires = timespec_to_ns(rqtp);\n\t}\n\treturn error;\n}\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\tclockid_t which_clock = restart_block->nanosleep.clockid;\n\tstruct timespec t;\n\tstruct itimerspec it;\n\tint error;\n\n\tt = ns_to_timespec(restart_block->nanosleep.expires);\n\n\terror = do_cpu_nanosleep(which_clock, timer_abstime, &t, &it);\n\n\tif (error == -erestart_restartblock) {\n\t\tstruct timespec __user *rmtp = restart_block->nanosleep.rmtp;\n\t\t\n\t\tif (rmtp && copy_to_user(rmtp, &it.it_value, sizeof *rmtp))\n\t\t\treturn -efault;\n\n\t\trestart_block->nanosleep.expires = timespec_to_ns(&t);\n\t}\n\treturn error;\n\n}\n\n#define process_clock\tmake_process_cpuclock(0, cpuclock_sched)\n#define thread_clock\tmake_thread_cpuclock(0, cpuclock_sched)\n\nstatic int process_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t    struct timespec *tp)\n{\n\treturn posix_cpu_clock_getres(process_clock, tp);\n}\nstatic int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec *tp)\n{\n\treturn posix_cpu_clock_get(process_clock, tp);\n}\nstatic int process_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = process_clock;\n\treturn posix_cpu_timer_create(timer);\n}\nstatic int process_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      struct timespec *rqtp,\n\t\t\t      struct timespec __user *rmtp)\n{\n\treturn posix_cpu_nsleep(process_clock, flags, rqtp, rmtp);\n}\nstatic long process_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\treturn -einval;\n}\nstatic int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec *tp)\n{\n\treturn posix_cpu_clock_getres(thread_clock, tp);\n}\nstatic int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec *tp)\n{\n\treturn posix_cpu_clock_get(thread_clock, tp);\n}\nstatic int thread_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = thread_clock;\n\treturn posix_cpu_timer_create(timer);\n}\n\nstruct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.nsleep_restart\t= posix_cpu_nsleep_restart,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n};\n\nstatic __init int init_posix_cpu_timers(void)\n{\n\tstruct k_clock process = {\n\t\t.clock_getres\t= process_cpu_clock_getres,\n\t\t.clock_get\t= process_cpu_clock_get,\n\t\t.timer_create\t= process_cpu_timer_create,\n\t\t.nsleep\t\t= process_cpu_nsleep,\n\t\t.nsleep_restart\t= process_cpu_nsleep_restart,\n\t};\n\tstruct k_clock thread = {\n\t\t.clock_getres\t= thread_cpu_clock_getres,\n\t\t.clock_get\t= thread_cpu_clock_get,\n\t\t.timer_create\t= thread_cpu_timer_create,\n\t};\n\tstruct timespec ts;\n\n\tposix_timers_register_clock(clock_process_cputime_id, &process);\n\tposix_timers_register_clock(clock_thread_cputime_id, &thread);\n\n\tcputime_to_timespec(cputime_one_jiffy, &ts);\n\tonecputick = ts.tv_nsec;\n\twarn_on(ts.tv_sec != 0);\n\n\treturn 0;\n}\n__initcall(init_posix_cpu_timers);\n\n\n#include <linux/export.h>\n#include <linux/uts.h>\n#include <linux/utsname.h>\n#include <linux/sysctl.h>\n#include <linux/wait.h>\n\n#ifdef config_proc_sysctl\n\nstatic void *get_uts(struct ctl_table *table, int write)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\tif (!write)\n\t\tdown_read(&uts_sem);\n\telse\n\t\tdown_write(&uts_sem);\n\treturn which;\n}\n\nstatic void put_uts(struct ctl_table *table, int write, void *which)\n{\n\tif (!write)\n\t\tup_read(&uts_sem);\n\telse\n\t\tup_write(&uts_sem);\n}\n\n\nstatic int proc_do_uts_string(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table uts_table;\n\tint r;\n\tmemcpy(&uts_table, table, sizeof(uts_table));\n\tuts_table.data = get_uts(table, write);\n\tr = proc_dostring(&uts_table, write, buffer, lenp, ppos);\n\tput_uts(table, write, uts_table.data);\n\n\tif (write)\n\t\tproc_sys_poll_notify(table->poll);\n\n\treturn r;\n}\n#else\n#define proc_do_uts_string null\n#endif\n\nstatic define_ctl_table_poll(hostname_poll);\nstatic define_ctl_table_poll(domainname_poll);\n\nstatic struct ctl_table uts_kern_table[] = {\n\t{\n\t\t.procname\t= \"": 935, "\",\n\t\t\t\twatchdog->name, wdnow, wdlast, watchdog->mask);\n\t\t\tpr_warn(\"": 936, "\",\n\t\t\t       event->type);\n\t\t\twarn_on_once(1);\n\t\t}\n\t}\n\n\treturn 0;\n}\nearly_initcall(init_events);\n\n#ifndef _kernel_workqueue_internal_h\n#define _kernel_workqueue_internal_h\n\n#include <linux/workqueue.h>\n#include <linux/kthread.h>\n\nstruct worker_pool;\n\n\nstruct worker {\n\t\n\tunion {\n\t\tstruct list_head\tentry;\t\n\t\tstruct hlist_node\thentry;\t\n\t};\n\n\tstruct work_struct\t*current_work;\t\n\twork_func_t\t\tcurrent_func;\t\n\tstruct pool_workqueue\t*current_pwq; \n\tbool\t\t\tdesc_valid;\t\n\tstruct list_head\tscheduled;\t\n\n\t\n\n\tstruct task_struct\t*task;\t\t\n\tstruct worker_pool\t*pool;\t\t\n\t\t\t\t\t\t\n\tstruct list_head\tnode;\t\t\n\t\t\t\t\t\t\n\n\tunsigned long\t\tlast_active;\t\n\tunsigned int\t\tflags;\t\t\n\tint\t\t\tid;\t\t\n\n\t\n\tchar\t\t\tdesc[worker_desc_len];\n\n\t\n\tstruct workqueue_struct\t*rescue_wq;\t\n};\n\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (current->flags & pf_wq_worker)\n\t\treturn kthread_data(current);\n\treturn null;\n}\n\n\nvoid wq_worker_waking_up(struct task_struct *task, int cpu);\nstruct task_struct *wq_worker_sleeping(struct task_struct *task, int cpu);\n\n#endif \n\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/hrtimer.h>\n#include <linux/interrupt.h>\n#include <linux/percpu.h>\n#include <linux/profile.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#include <asm/irq_regs.h>\n\n#include \"": 937, "\",\n\t\t\t     avg_local_sample_len, allowed_ns >> 1,\n\t\t\t     sysctl_perf_event_sample_rate);\n\t}\n}\n\nstatic atomic64_t perf_event_id;\n\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\n\nvoid __weak perf_event_print_debug(void)\t{ }\n\nextern __weak const char *perf_pmu_name(void)\n{\n\treturn \"": 938, "\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn kdb_notimp;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, gfp_kdb);\n\tkfree(save_command);\n\treturn 0;\n}\n\nstatic int kdb_defcmd(int argc, const char **argv)\n{\n\tstruct defcmd_set *save_defcmd_set = defcmd_set, *s;\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"": 939, "\",\n\t\t\t   domain == irq_default_domain ? '*' : ' ', domain->name,\n\t\t\t   domain->revmap_size + count, domain->revmap_size,\n\t\t\t   domain->revmap_direct_max_irq,\n\t\t\t   domain->of_node ? of_node_full_name(domain->of_node) : \"": 940, "\",\n\t\t\t   events, events * 1000 / ms,\n\t\t\t   (events * 1000000 / ms) % 1000);\n\telse\n\t\tseq_printf(m, \"": 941, "\",\n\t\t\t   ftrace_rec_count(rec),\n\t\t\t   rec->flags & ftrace_fl_regs ? \"": 942, "\",\n\t\t\t   rec->flags & ftrace_fl_ipmodify ? \"": 943, "\",\n\t\t\t  iter->ent->type);\n\t}\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\n\t\n\tsret = trace_seq_to_user(&iter->seq, ubuf, cnt);\n\tif (iter->seq.seq.readpos >= trace_seq_used(&iter->seq))\n\t\ttrace_seq_init(&iter->seq);\n\n\t\n\tif (sret == -ebusy)\n\t\tgoto waitagain;\n\nout:\n\tmutex_unlock(&iter->mutex);\n\n\treturn sret;\n}\n\nstatic void tracing_spd_release_pipe(struct splice_pipe_desc *spd,\n\t\t\t\t     unsigned int idx)\n{\n\t__free_page(spd->pages[idx]);\n}\n\nstatic const struct pipe_buf_operations tracing_pipe_buf_ops = {\n\t.can_merge\t\t= 0,\n\t.confirm\t\t= generic_pipe_buf_confirm,\n\t.release\t\t= generic_pipe_buf_release,\n\t.steal\t\t\t= generic_pipe_buf_steal,\n\t.get\t\t\t= generic_pipe_buf_get,\n};\n\nstatic size_t\ntracing_fill_pipe_page(size_t rem, struct trace_iterator *iter)\n{\n\tsize_t count;\n\tint save_len;\n\tint ret;\n\n\t\n\tfor (;;) {\n\t\tsave_len = iter->seq.seq.len;\n\t\tret = print_trace_line(iter);\n\n\t\tif (trace_seq_has_overflowed(&iter->seq)) {\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (ret == trace_type_partial_line) {\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = trace_seq_used(&iter->seq) - save_len;\n\t\tif (rem < count) {\n\t\t\trem = 0;\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret != trace_type_no_consume)\n\t\t\ttrace_consume(iter);\n\t\trem -= count;\n\t\tif (!trace_find_next_entry_inc(iter))\t{\n\t\t\trem = 0;\n\t\t\titer->ent = null;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rem;\n}\n\nstatic ssize_t tracing_splice_read_pipe(struct file *filp,\n\t\t\t\t\tloff_t *ppos,\n\t\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct page *pages_def[pipe_def_buffers];\n\tstruct partial_page partial_def[pipe_def_buffers];\n\tstruct trace_iterator *iter = filp->private_data;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages\t= 0, \n\t\t.nr_pages_max\t= pipe_def_buffers,\n\t\t.flags\t\t= flags,\n\t\t.ops\t\t= &tracing_pipe_buf_ops,\n\t\t.spd_release\t= tracing_spd_release_pipe,\n\t};\n\tssize_t ret;\n\tsize_t rem;\n\tunsigned int i;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -enomem;\n\n\tmutex_lock(&iter->mutex);\n\n\tif (iter->trace->splice_read) {\n\t\tret = iter->trace->splice_read(iter, filp,\n\t\t\t\t\t       ppos, pipe, len, flags);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\tret = tracing_wait_pipe(filp);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\n\tif (!iter->ent && !trace_find_next_entry_inc(iter)) {\n\t\tret = -efault;\n\t\tgoto out_err;\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\n\t\n\tfor (i = 0, rem = len; i < spd.nr_pages_max && rem; i++) {\n\t\tspd.pages[i] = alloc_page(gfp_kernel);\n\t\tif (!spd.pages[i])\n\t\t\tbreak;\n\n\t\trem = tracing_fill_pipe_page(rem, iter);\n\n\t\t\n\t\tret = trace_seq_to_buffer(&iter->seq,\n\t\t\t\t\t  page_address(spd.pages[i]),\n\t\t\t\t\t  trace_seq_used(&iter->seq));\n\t\tif (ret < 0) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tbreak;\n\t\t}\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = trace_seq_used(&iter->seq);\n\n\t\ttrace_seq_init(&iter->seq);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\tmutex_unlock(&iter->mutex);\n\n\tspd.nr_pages = i;\n\n\tret = splice_to_pipe(pipe, &spd);\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n\nout_err:\n\tmutex_unlock(&iter->mutex);\n\tgoto out;\n}\n\nstatic ssize_t\ntracing_entries_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tint cpu = tracing_get_cpu(inode);\n\tchar buf[64];\n\tint r = 0;\n\tssize_t ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu == ring_buffer_all_cpus) {\n\t\tint cpu, buf_size_same;\n\t\tunsigned long size;\n\n\t\tsize = 0;\n\t\tbuf_size_same = 1;\n\t\t\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\t\n\t\t\tif (size == 0)\n\t\t\t\tsize = per_cpu_ptr(tr->trace_buffer.data, cpu)->entries;\n\t\t\tif (size != per_cpu_ptr(tr->trace_buffer.data, cpu)->entries) {\n\t\t\t\tbuf_size_same = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (buf_size_same) {\n\t\t\tif (!ring_buffer_expanded)\n\t\t\t\tr = sprintf(buf, \"": 944, "\",\n\t\t\t ringbuf_type_padding);\n\ttrace_seq_printf(s, \"": 945, "\",\n\t\t\t ringbuf_type_time_extend);\n\ttrace_seq_printf(s, \"": 946, "\",\n\t\t\t(unsigned long long)ktime_to_ns(base->resolution));\n\tseq_printf(m,   \"": 947, "\",\n\t\t\tbase->index);\n\tseq_printf(m, \"": 948, "\",\n\t\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}\nexport_symbol_gpl(__clocksource_update_freq_scale);\n\n\nint __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\n\t\n\t__clocksource_update_freq_scale(cs, scale, freq);\n\n\t\n\tmutex_lock(&clocksource_mutex);\n\tclocksource_enqueue(cs);\n\tclocksource_enqueue_watchdog(cs);\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}\nexport_symbol_gpl(__clocksource_register_scale);\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}\n\n\nvoid clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tmutex_lock(&clocksource_mutex);\n\t__clocksource_change_rating(cs, rating);\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n}\nexport_symbol(clocksource_change_rating);\n\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\t\n\tif (clocksource_is_watchdog(cs))\n\t\treturn -ebusy;\n\n\tif (cs == curr_clocksource) {\n\t\t\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -ebusy;\n\t}\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\treturn 0;\n}\n\n\nint clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}\nexport_symbol(clocksource_unregister);\n\n#ifdef config_sysfs\n\nstatic ssize_t\nsysfs_show_current_clocksources(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tcount = snprintf(buf, page_size, \"": 949, "\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\n\tacct_update_integrals(tsk);\n\t\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm(tsk);\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread();\n\n\t\n\tperf_event_exit_task(tsk);\n\n\tcgroup_exit(tsk);\n\n\t\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\ttasks_rcu(tasks_rcu_i = __srcu_read_lock(&tasks_rcu_exit_srcu));\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n#ifdef config_numa\n\ttask_lock(tsk);\n\tmpol_put(tsk->mempolicy);\n\ttsk->mempolicy = null;\n\ttask_unlock(tsk);\n#endif\n#ifdef config_futex\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t\n\tdebug_check_no_locks_held();\n\t\n\ttsk->flags |= pf_exitpidone;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\ttasks_rcu(__srcu_read_unlock(&tasks_rcu_exit_srcu, tasks_rcu_i));\n\n\t\n\tsmp_mb();\n\traw_spin_unlock_wait(&tsk->pi_lock);\n\n\t\n\ttsk->state = task_dead;\n\ttsk->flags |= pf_nofreeze;\t\n\tschedule();\n\tbug();\n\t\n\tfor (;;)\n\t\tcpu_relax();\t\n}\nexport_symbol_gpl(do_exit);\n\nvoid complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tdo_exit(code);\n}\nexport_symbol(complete_and_exit);\n\nsyscall_define1(exit, int, error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}\n\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tbug_on(exit_code & 0x80); \n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = signal_group_exit;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t\n}\n\n\nsyscall_define1(exit_group, int, error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n\t\n\treturn 0;\n}\n\nstruct wait_opts {\n\tenum pid_type\t\two_type;\n\tint\t\t\two_flags;\n\tstruct pid\t\t*wo_pid;\n\n\tstruct siginfo __user\t*wo_info;\n\tint __user\t\t*wo_stat;\n\tstruct rusage __user\t*wo_rusage;\n\n\twait_queue_t\t\tchild_wait;\n\tint\t\t\tnotask_error;\n};\n\nstatic inline\nstruct pid *task_pid_type(struct task_struct *task, enum pid_type type)\n{\n\tif (type != pidtype_pid)\n\t\ttask = task->group_leader;\n\treturn task->pids[type].pid;\n}\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == pidtype_max ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}\n\nstatic int eligible_child(struct wait_opts *wo, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\t\n\tif (((p->exit_signal != sigchld) ^ !!(wo->wo_flags & __wclone))\n\t    && !(wo->wo_flags & __wall))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int wait_noreap_copyout(struct wait_opts *wo, struct task_struct *p,\n\t\t\t\tpid_t pid, uid_t uid, int why, int status)\n{\n\tstruct siginfo __user *infop;\n\tint retval = wo->wo_rusage\n\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\n\tput_task_struct(p);\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif (!retval)\n\t\t\tretval = put_user(sigchld, &infop->si_signo);\n\t\tif (!retval)\n\t\t\tretval = put_user(0, &infop->si_errno);\n\t\tif (!retval)\n\t\t\tretval = put_user((short)why, &infop->si_code);\n\t\tif (!retval)\n\t\t\tretval = put_user(pid, &infop->si_pid);\n\t\tif (!retval)\n\t\t\tretval = put_user(uid, &infop->si_uid);\n\t\tif (!retval)\n\t\t\tretval = put_user(status, &infop->si_status);\n\t}\n\tif (!retval)\n\t\tretval = pid;\n\treturn retval;\n}\n\n\nstatic int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, retval, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct siginfo __user *infop;\n\n\tif (!likely(wo->wo_flags & wexited))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & wnowait)) {\n\t\tint exit_code = p->exit_code;\n\t\tint why;\n\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\n\t\tif ((exit_code & 0x7f) == 0) {\n\t\t\twhy = cld_exited;\n\t\t\tstatus = exit_code >> 8;\n\t\t} else {\n\t\t\twhy = (exit_code & 0x80) ? cld_dumped : cld_killed;\n\t\t\tstatus = exit_code & 0x7f;\n\t\t}\n\t\treturn wait_noreap_copyout(wo, p, pid, uid, why, status);\n\t}\n\t\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\texit_trace : exit_dead;\n\tif (cmpxchg(&p->exit_state, exit_zombie, state) != exit_zombie)\n\t\treturn 0;\n\t\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t\n\tif (state == exit_dead && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tcputime_t tgutime, tgstime;\n\n\t\t\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tretval = wo->wo_rusage\n\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\tstatus = (p->signal->flags & signal_group_exit)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\tif (!retval && wo->wo_stat)\n\t\tretval = put_user(status, wo->wo_stat);\n\n\tinfop = wo->wo_info;\n\tif (!retval && infop)\n\t\tretval = put_user(sigchld, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop) {\n\t\tint why;\n\n\t\tif ((status & 0x7f) == 0) {\n\t\t\twhy = cld_exited;\n\t\t\tstatus >>= 8;\n\t\t} else {\n\t\t\twhy = (status & 0x80) ? cld_dumped : cld_killed;\n\t\t\tstatus &= 0x7f;\n\t\t}\n\t\tretval = put_user((short)why, &infop->si_code);\n\t\tif (!retval)\n\t\t\tretval = put_user(status, &infop->si_status);\n\t}\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\n\tif (state == exit_trace) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t\n\t\tptrace_unlink(p);\n\n\t\t\n\t\tstate = exit_zombie;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = exit_dead;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == exit_dead)\n\t\trelease_task(p);\n\n\treturn retval;\n}\n\nstatic int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_stopped_or_traced(p) &&\n\t\t    !(p->jobctl & jobctl_listening))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & signal_stop_stopped)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn null;\n}\n\n\nstatic int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct siginfo __user *infop;\n\tint retval, exit_code, *p_code, why;\n\tuid_t uid = 0; \n\tpid_t pid;\n\n\t\n\tif (!ptrace && !(wo->wo_flags & wuntraced))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & wnowait))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? cld_trapped : cld_stopped;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\tif (unlikely(wo->wo_flags & wnowait))\n\t\treturn wait_noreap_copyout(wo, p, pid, uid, why, exit_code);\n\n\tretval = wo->wo_rusage\n\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\tif (!retval && wo->wo_stat)\n\t\tretval = put_user((exit_code << 8) | 0x7f, wo->wo_stat);\n\n\tinfop = wo->wo_info;\n\tif (!retval && infop)\n\t\tretval = put_user(sigchld, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop)\n\t\tretval = put_user((short)why, &infop->si_code);\n\tif (!retval && infop)\n\t\tretval = put_user(exit_code, &infop->si_status);\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\tput_task_struct(p);\n\n\tbug_on(!retval);\n\treturn retval;\n}\n\n\nstatic int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tint retval;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & wcontinued))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & signal_stop_continued))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t\n\tif (!(p->signal->flags & signal_stop_continued)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & wnowait))\n\t\tp->signal->flags &= ~signal_stop_continued;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\tif (!wo->wo_info) {\n\t\tretval = wo->wo_rusage\n\t\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\t\tput_task_struct(p);\n\t\tif (!retval && wo->wo_stat)\n\t\t\tretval = put_user(0xffff, wo->wo_stat);\n\t\tif (!retval)\n\t\t\tretval = pid;\n\t} else {\n\t\tretval = wait_noreap_copyout(wo, p, pid, uid,\n\t\t\t\t\t     cld_continued, sigcont);\n\t\tbug_on(retval == 0);\n\t}\n\n\treturn retval;\n}\n\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t\n\tint exit_state = access_once(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == exit_dead))\n\t\treturn 0;\n\n\tret = eligible_child(wo, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = security_task_wait(p);\n\tif (unlikely(ret < 0)) {\n\t\t\n\t\tif (wo->notask_error)\n\t\t\two->notask_error = ret;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(exit_state == exit_trace)) {\n\t\t\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t\n\tif (exit_state == exit_zombie) {\n\t\t\n\t\tif (!delay_group_leader(p)) {\n\t\t\t\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t\n\t\tif (likely(!ptrace) || (wo->wo_flags & (wcontinued | wexited)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t\n\t\two->notask_error = 0;\n\t}\n\n\t\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\treturn wait_task_continued(wo, p);\n}\n\n\nstatic int do_wait_thread(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\tint ret = wait_consider_task(wo, 0, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptrace_do_wait(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(wo, 1, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int child_wait_callback(wait_queue_t *wait, unsigned mode,\n\t\t\t\tint sync, void *key)\n{\n\tstruct wait_opts *wo = container_of(wait, struct wait_opts,\n\t\t\t\t\t\tchild_wait);\n\tstruct task_struct *p = key;\n\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\tif ((wo->wo_flags & __wnothread) && wait->private != p->parent)\n\t\treturn 0;\n\n\treturn default_wake_function(wait, mode, sync, key);\n}\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\ttask_interruptible, 1, p);\n}\n\nstatic long do_wait(struct wait_opts *wo)\n{\n\tstruct task_struct *tsk;\n\tint retval;\n\n\ttrace_sched_process_wait(wo->wo_pid);\n\n\tinit_waitqueue_func_entry(&wo->child_wait, child_wait_callback);\n\two->child_wait.private = current;\n\tadd_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);\nrepeat:\n\t\n\two->notask_error = -echild;\n\tif ((wo->wo_type < pidtype_max) &&\n\t   (!wo->wo_pid || hlist_empty(&wo->wo_pid->tasks[wo->wo_type])))\n\t\tgoto notask;\n\n\tset_current_state(task_interruptible);\n\tread_lock(&tasklist_lock);\n\ttsk = current;\n\tdo {\n\t\tretval = do_wait_thread(wo, tsk);\n\t\tif (retval)\n\t\t\tgoto end;\n\n\t\tretval = ptrace_do_wait(wo, tsk);\n\t\tif (retval)\n\t\t\tgoto end;\n\n\t\tif (wo->wo_flags & __wnothread)\n\t\t\tbreak;\n\t} while_each_thread(current, tsk);\n\tread_unlock(&tasklist_lock);\n\nnotask:\n\tretval = wo->notask_error;\n\tif (!retval && !(wo->wo_flags & wnohang)) {\n\t\tretval = -erestartsys;\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tgoto repeat;\n\t\t}\n\t}\nend:\n\t__set_current_state(task_running);\n\tremove_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);\n\treturn retval;\n}\n\nsyscall_define5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = null;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(wnohang|wnowait|wexited|wstopped|wcontinued))\n\t\treturn -einval;\n\tif (!(options & (wexited|wstopped|wcontinued)))\n\t\treturn -einval;\n\n\tswitch (which) {\n\tcase p_all:\n\t\ttype = pidtype_max;\n\t\tbreak;\n\tcase p_pid:\n\t\ttype = pidtype_pid;\n\t\tif (upid <= 0)\n\t\t\treturn -einval;\n\t\tbreak;\n\tcase p_pgid:\n\t\ttype = pidtype_pgid;\n\t\tif (upid <= 0)\n\t\t\treturn -einval;\n\t\tbreak;\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\tif (type < pidtype_max)\n\t\tpid = find_get_pid(upid);\n\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options;\n\two.wo_info\t= infop;\n\two.wo_stat\t= null;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\n\tif (ret > 0) {\n\t\tret = 0;\n\t} else if (infop) {\n\t\t\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_signo);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_errno);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_code);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_pid);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_uid);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_status);\n\t}\n\n\tput_pid(pid);\n\treturn ret;\n}\n\nsyscall_define4(wait4, pid_t, upid, int __user *, stat_addr,\n\t\tint, options, struct rusage __user *, ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = null;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(wnohang|wuntraced|wcontinued|\n\t\t\t__wnothread|__wclone|__wall))\n\t\treturn -einval;\n\n\tif (upid == -1)\n\t\ttype = pidtype_max;\n\telse if (upid < 0) {\n\t\ttype = pidtype_pgid;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = pidtype_pgid;\n\t\tpid = get_task_pid(current, pidtype_pgid);\n\t} else  {\n\t\ttype = pidtype_pid;\n\t\tpid = find_get_pid(upid);\n\t}\n\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | wexited;\n\two.wo_info\t= null;\n\two.wo_stat\t= stat_addr;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\n\treturn ret;\n}\n\n#ifdef __arch_want_sys_waitpid\n\n\nsyscall_define3(waitpid, pid_t, pid, int __user *, stat_addr, int, options)\n{\n\treturn sys_wait4(pid, stat_addr, options, null);\n}\n\n#endif\n\n\n#include <linux/cpu.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/hrtimer.h>\n#include <linux/notifier.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/tick.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/debugobjects.h>\n#include <linux/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/deadline.h>\n#include <linux/timer.h>\n#include <linux/freezer.h>\n\n#include <asm/uaccess.h>\n\n#include <trace/events/timer.h>\n\n#include \"": 950, "\",\n\t\t\tcurrent->comm, task_pid_nr(current), free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}\n#else\nstatic inline void check_stack_usage(void) {}\n#endif\n\nvoid do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\ttasks_rcu(int tasks_rcu_i);\n\n\tprofile_task_exit(tsk);\n\n\twarn_on(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"": 951, "\",\n\t\t\tfather->signal->group_exit_code ?: father->exit_code);\n\t}\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}\n\n\nstatic struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\t\n\t\tfor (reaper = father;\n\t\t     !same_thread_group(reaper, child_reaper);\n\t\t     reaper = reaper->real_parent) {\n\t\t\t\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}\n\n\nstatic void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == exit_dead))\n\t\treturn;\n\n\t\n\tp->exit_signal = sigchld;\n\n\t\n\tif (!p->ptrace &&\n\t    p->exit_state == exit_zombie && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = exit_dead;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}\n\n\nstatic void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t\n\treaper = find_child_reaper(father);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tt->real_parent = reaper;\n\t\t\tbug_on((!t->ptrace) != (t->parent == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    send_sig_noinfo, t);\n\t\t}\n\t\t\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}\n\n\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tlist_head(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, null);\n\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : sigchld;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\ttsk->exit_state = autoreap ? exit_dead : exit_zombie;\n\tif (tsk->exit_state == exit_dead)\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\n\t\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exit_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}\n\n#ifdef config_debug_stack_usage\nstatic void check_stack_usage(void)\n{\n\tstatic define_spinlock(low_water_lock);\n\tstatic int lowest_to_date = thread_size;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tpr_warn(\"": 952, "\",\n\t\t\ti == tr->clock_id ? \"": 953, "\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __log_buf_len - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __log_buf_len);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tpr_info(\"": 954, "\",\n\t\t\tof_node_full_name(irq_data->np));\n\t\treturn 0;\n\t}\n\n\t\n\tif (domain->ops->xlate == null)\n\t\thwirq = irq_data->args[0];\n\telse {\n\t\tif (domain->ops->xlate(domain, irq_data->np, irq_data->args,\n\t\t\t\t\tirq_data->args_count, &hwirq, &type))\n\t\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\t\n\t\tvirq = irq_find_mapping(domain, hwirq);\n\t\tif (virq)\n\t\t\treturn virq;\n\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, numa_no_node, irq_data);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\t\n\tif (type != irq_type_none &&\n\t    type != irq_get_trigger_type(virq))\n\t\tirq_set_irq_type(virq, type);\n\treturn virq;\n}\nexport_symbol_gpl(irq_create_of_mapping);\n\n\nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (warn_on(domain == null))\n\t\treturn;\n\n\tirq_domain_disassociate(domain, virq);\n\tirq_free_desc(virq);\n}\nexport_symbol_gpl(irq_dispose_mapping);\n\n\nunsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t\n\tif (domain == null)\n\t\tdomain = irq_default_domain;\n\tif (domain == null)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}\nexport_symbol_gpl(irq_find_mapping);\n\n#ifdef config_irq_domain_debug\nstatic int virq_debug_show(struct seq_file *m, void *private)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc;\n\tstruct irq_domain *domain;\n\tstruct radix_tree_iter iter;\n\tvoid *data, **slot;\n\tint i;\n\n\tseq_printf(m, \"": 955, "\",\n\t\t\tset);\n\t\treturn -einval;\n\t}\n\n\treturn 0;\n}\n\n\nstruct tracer nop_trace __read_mostly =\n{\n\t.name\t\t= \"": 956, "\",\n\t\t\tset);\n\t\treturn 0;\n\t}\n\n\tif (bit == trace_nop_opt_refuse) {\n\t\tprintk(kern_debug \"": 957, "\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}\n\n\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(kern_err \"": 958, "\",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}\n\nstatic size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)\n{\n\tsize_t len = 0;\n\tunsigned int prefix = (msg->facility << 3) | msg->level;\n\n\tif (syslog) {\n\t\tif (buf) {\n\t\t\tlen += sprintf(buf, \"": 959, "\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}\nexport_symbol_gpl(relay_close);\n\n\nvoid relay_flush(struct rchan *chan)\n{\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && chan->buf[0]) {\n\t\trelay_switch_subbuf(chan->buf[0], 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif (chan->buf[i])\n\t\t\trelay_switch_subbuf(chan->buf[i], 0);\n\tmutex_unlock(&relay_channels_mutex);\n}\nexport_symbol_gpl(relay_flush);\n\n\nstatic int relay_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = inode->i_private;\n\tkref_get(&buf->kref);\n\tfilp->private_data = buf;\n\n\treturn nonseekable_open(inode, filp);\n}\n\n\nstatic int relay_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\treturn relay_mmap_buf(buf, vma);\n}\n\n\nstatic unsigned int relay_file_poll(struct file *filp, poll_table *wait)\n{\n\tunsigned int mask = 0;\n\tstruct rchan_buf *buf = filp->private_data;\n\n\tif (buf->finalized)\n\t\treturn pollerr;\n\n\tif (filp->f_mode & fmode_read) {\n\t\tpoll_wait(filp, &buf->read_wait, wait);\n\t\tif (!relay_buf_empty(buf))\n\t\t\tmask |= pollin | pollrdnorm;\n\t}\n\n\treturn mask;\n}\n\n\nstatic int relay_file_release(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tkref_put(&buf->kref, relay_remove_buf);\n\n\treturn 0;\n}\n\n\nstatic void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}\n\n\nstatic int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t produced = buf->subbufs_produced;\n\tsize_t consumed = buf->subbufs_consumed;\n\n\trelay_file_read_consume(buf, read_pos, 0);\n\n\tconsumed = buf->subbufs_consumed;\n\n\tif (unlikely(buf->offset > subbuf_size)) {\n\t\tif (produced == consumed)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(produced - consumed >= n_subbufs)) {\n\t\tconsumed = produced - n_subbufs + 1;\n\t\tbuf->subbufs_consumed = consumed;\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\n\tconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\n\n\tif (consumed > produced)\n\t\tproduced += n_subbufs * subbuf_size;\n\n\tif (consumed == produced) {\n\t\tif (buf->offset == subbuf_size &&\n\t\t    buf->subbufs_produced > buf->subbufs_consumed)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic size_t relay_file_read_subbuf_avail(size_t read_pos,\n\t\t\t\t\t   struct rchan_buf *buf)\n{\n\tsize_t padding, avail = 0;\n\tsize_t read_subbuf, read_offset, write_subbuf, write_offset;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\n\twrite_subbuf = (buf->data - buf->start) / subbuf_size;\n\twrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\n\tread_subbuf = read_pos / subbuf_size;\n\tread_offset = read_pos % subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\n\tif (read_subbuf == write_subbuf) {\n\t\tif (read_offset + padding < write_offset)\n\t\t\tavail = write_offset - (read_offset + padding);\n\t} else\n\t\tavail = (subbuf_size - padding) - read_offset;\n\n\treturn avail;\n}\n\n\nstatic size_t relay_file_read_start_pos(size_t read_pos,\n\t\t\t\t\tstruct rchan_buf *buf)\n{\n\tsize_t read_subbuf, padding, padding_start, padding_end;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t consumed = buf->subbufs_consumed % n_subbufs;\n\n\tif (!read_pos)\n\t\tread_pos = consumed * subbuf_size + buf->bytes_consumed;\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tpadding_start = (read_subbuf + 1) * subbuf_size - padding;\n\tpadding_end = (read_subbuf + 1) * subbuf_size;\n\tif (read_pos >= padding_start && read_pos < padding_end) {\n\t\tread_subbuf = (read_subbuf + 1) % n_subbufs;\n\t\tread_pos = read_subbuf * subbuf_size;\n\t}\n\n\treturn read_pos;\n}\n\n\nstatic size_t relay_file_read_end_pos(struct rchan_buf *buf,\n\t\t\t\t      size_t read_pos,\n\t\t\t\t      size_t count)\n{\n\tsize_t read_subbuf, padding, end_pos;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tif (read_pos % subbuf_size + count + padding == subbuf_size)\n\t\tend_pos = (read_subbuf + 1) * subbuf_size;\n\telse\n\t\tend_pos = read_pos + count;\n\tif (end_pos >= subbuf_size * n_subbufs)\n\t\tend_pos = 0;\n\n\treturn end_pos;\n}\n\n\nstatic int subbuf_read_actor(size_t read_start,\n\t\t\t     struct rchan_buf *buf,\n\t\t\t     size_t avail,\n\t\t\t     read_descriptor_t *desc)\n{\n\tvoid *from;\n\tint ret = 0;\n\n\tfrom = buf->start + read_start;\n\tret = avail;\n\tif (copy_to_user(desc->arg.buf, from, avail)) {\n\t\tdesc->error = -efault;\n\t\tret = 0;\n\t}\n\tdesc->arg.data += ret;\n\tdesc->written += ret;\n\tdesc->count -= ret;\n\n\treturn ret;\n}\n\ntypedef int (*subbuf_actor_t) (size_t read_start,\n\t\t\t       struct rchan_buf *buf,\n\t\t\t       size_t avail,\n\t\t\t       read_descriptor_t *desc);\n\n\nstatic ssize_t relay_file_read_subbufs(struct file *filp, loff_t *ppos,\n\t\t\t\t\tsubbuf_actor_t subbuf_actor,\n\t\t\t\t\tread_descriptor_t *desc)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tsize_t read_start, avail;\n\tint ret;\n\n\tif (!desc->count)\n\t\treturn 0;\n\n\tmutex_lock(&file_inode(filp)->i_mutex);\n\tdo {\n\t\tif (!relay_file_read_avail(buf, *ppos))\n\t\t\tbreak;\n\n\t\tread_start = relay_file_read_start_pos(*ppos, buf);\n\t\tavail = relay_file_read_subbuf_avail(read_start, buf);\n\t\tif (!avail)\n\t\t\tbreak;\n\n\t\tavail = min(desc->count, avail);\n\t\tret = subbuf_actor(read_start, buf, avail, desc);\n\t\tif (desc->error < 0)\n\t\t\tbreak;\n\n\t\tif (ret) {\n\t\t\trelay_file_read_consume(buf, read_start, ret);\n\t\t\t*ppos = relay_file_read_end_pos(buf, read_start, ret);\n\t\t}\n\t} while (desc->count && ret);\n\tmutex_unlock(&file_inode(filp)->i_mutex);\n\n\treturn desc->written;\n}\n\nstatic ssize_t relay_file_read(struct file *filp,\n\t\t\t       char __user *buffer,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tread_descriptor_t desc;\n\tdesc.written = 0;\n\tdesc.count = count;\n\tdesc.arg.buf = buffer;\n\tdesc.error = 0;\n\treturn relay_file_read_subbufs(filp, ppos, subbuf_read_actor, &desc);\n}\n\nstatic void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\n{\n\trbuf->bytes_consumed += bytes_consumed;\n\n\tif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\n\t\trelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\n\t\trbuf->bytes_consumed %= rbuf->chan->subbuf_size;\n\t}\n}\n\nstatic void relay_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct rchan_buf *rbuf;\n\n\trbuf = (struct rchan_buf *)page_private(buf->page);\n\trelay_consume_bytes(rbuf, buf->private);\n}\n\nstatic const struct pipe_buf_operations relay_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = relay_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\n\nstatic void relay_page_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n}\n\n\nstatic ssize_t subbuf_splice_actor(struct file *in,\n\t\t\t       loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t       size_t len,\n\t\t\t       unsigned int flags,\n\t\t\t       int *nonpad_ret)\n{\n\tunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\n\tstruct rchan_buf *rbuf = in->private_data;\n\tunsigned int subbuf_size = rbuf->chan->subbuf_size;\n\tuint64_t pos = (uint64_t) *ppos;\n\tuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\n\tsize_t read_start = (size_t) do_div(pos, alloc_size);\n\tsize_t read_subbuf = read_start / subbuf_size;\n\tsize_t padding = rbuf->padding[read_subbuf];\n\tsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\n\tstruct page *pages[pipe_def_buffers];\n\tstruct partial_page partial[pipe_def_buffers];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.nr_pages = 0,\n\t\t.nr_pages_max = pipe_def_buffers,\n\t\t.partial = partial,\n\t\t.flags = flags,\n\t\t.ops = &relay_pipe_buf_ops,\n\t\t.spd_release = relay_page_release,\n\t};\n\tssize_t ret;\n\n\tif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\n\t\treturn 0;\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -enomem;\n\n\t\n\tif (len > (subbuf_size - read_start % subbuf_size))\n\t\tlen = subbuf_size - read_start % subbuf_size;\n\n\tsubbuf_pages = rbuf->chan->alloc_size >> page_shift;\n\tpidx = (read_start / page_size) % subbuf_pages;\n\tpoff = read_start & ~page_mask;\n\tnr_pages = min_t(unsigned int, subbuf_pages, spd.nr_pages_max);\n\n\tfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\n\t\tunsigned int this_len, this_end, private;\n\t\tunsigned int cur_pos = read_start + total_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tthis_len = min_t(unsigned long, len, page_size - poff);\n\t\tprivate = this_len;\n\n\t\tspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\n\t\tspd.partial[spd.nr_pages].offset = poff;\n\n\t\tthis_end = cur_pos + this_len;\n\t\tif (this_end >= nonpad_end) {\n\t\t\tthis_len = nonpad_end - cur_pos;\n\t\t\tprivate = this_len + padding;\n\t\t}\n\t\tspd.partial[spd.nr_pages].len = this_len;\n\t\tspd.partial[spd.nr_pages].private = private;\n\n\t\tlen -= this_len;\n\t\ttotal_len += this_len;\n\t\tpoff = 0;\n\t\tpidx = (pidx + 1) % subbuf_pages;\n\n\t\tif (this_end >= nonpad_end) {\n\t\t\tspd.nr_pages++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (!spd.nr_pages)\n\t\tgoto out;\n\n\tret = *nonpad_ret = splice_to_pipe(pipe, &spd);\n\tif (ret < 0 || ret < total_len)\n\t\tgoto out;\n\n        if (read_start + ret == nonpad_end)\n                ret += padding;\n\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}\n\nstatic ssize_t relay_file_splice_read(struct file *in,\n\t\t\t\t      loff_t *ppos,\n\t\t\t\t      struct pipe_inode_info *pipe,\n\t\t\t\t      size_t len,\n\t\t\t\t      unsigned int flags)\n{\n\tssize_t spliced;\n\tint ret;\n\tint nonpad_ret = 0;\n\n\tret = 0;\n\tspliced = 0;\n\n\twhile (len && !spliced) {\n\t\tret = subbuf_splice_actor(in, ppos, pipe, len, flags, &nonpad_ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (flags & splice_f_nonblock)\n\t\t\t\tret = -eagain;\n\t\t\tbreak;\n\t\t}\n\n\t\t*ppos += ret;\n\t\tif (ret > len)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen -= ret;\n\t\tspliced += nonpad_ret;\n\t\tnonpad_ret = 0;\n\t}\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}\n\nconst struct file_operations relay_file_operations = {\n\t.open\t\t= relay_file_open,\n\t.poll\t\t= relay_file_poll,\n\t.mmap\t\t= relay_file_mmap,\n\t.read\t\t= relay_file_read,\n\t.llseek\t\t= no_llseek,\n\t.release\t= relay_file_release,\n\t.splice_read\t= relay_file_splice_read,\n};\nexport_symbol_gpl(relay_file_operations);\n\nstatic __init int relay_init(void)\n{\n\n\thotcpu_notifier(relay_hotcpu_callback, 0);\n\treturn 0;\n}\n\nearly_initcall(relay_init);\n\n\n#include <linux/sched.h>\n#include <linux/completion.h>\n\n\nvoid complete(struct completion *x)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tx->done++;\n\t__wake_up_locked(&x->wait, task_normal, 1);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n}\nexport_symbol(complete);\n\n\nvoid complete_all(struct completion *x)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tx->done += uint_max/2;\n\t__wake_up_locked(&x->wait, task_normal, 0);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n}\nexport_symbol(complete_all);\n\nstatic inline long __sched\ndo_wait_for_common(struct completion *x,\n\t\t   long (*action)(long), long timeout, int state)\n{\n\tif (!x->done) {\n\t\tdeclare_waitqueue(wait, current);\n\n\t\t__add_wait_queue_tail_exclusive(&x->wait, &wait);\n\t\tdo {\n\t\t\tif (signal_pending_state(state, current)) {\n\t\t\t\ttimeout = -erestartsys;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__set_current_state(state);\n\t\t\tspin_unlock_irq(&x->wait.lock);\n\t\t\ttimeout = action(timeout);\n\t\t\tspin_lock_irq(&x->wait.lock);\n\t\t} while (!x->done && timeout);\n\t\t__remove_wait_queue(&x->wait, &wait);\n\t\tif (!x->done)\n\t\t\treturn timeout;\n\t}\n\tx->done--;\n\treturn timeout ?: 1;\n}\n\nstatic inline long __sched\n__wait_for_common(struct completion *x,\n\t\t  long (*action)(long), long timeout, int state)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&x->wait.lock);\n\ttimeout = do_wait_for_common(x, action, timeout, state);\n\tspin_unlock_irq(&x->wait.lock);\n\treturn timeout;\n}\n\nstatic long __sched\nwait_for_common(struct completion *x, long timeout, int state)\n{\n\treturn __wait_for_common(x, schedule_timeout, timeout, state);\n}\n\nstatic long __sched\nwait_for_common_io(struct completion *x, long timeout, int state)\n{\n\treturn __wait_for_common(x, io_schedule_timeout, timeout, state);\n}\n\n\nvoid __sched wait_for_completion(struct completion *x)\n{\n\twait_for_common(x, max_schedule_timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion);\n\n\nunsigned long __sched\nwait_for_completion_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion_timeout);\n\n\nvoid __sched wait_for_completion_io(struct completion *x)\n{\n\twait_for_common_io(x, max_schedule_timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion_io);\n\n\nunsigned long __sched\nwait_for_completion_io_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common_io(x, timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion_io_timeout);\n\n\nint __sched wait_for_completion_interruptible(struct completion *x)\n{\n\tlong t = wait_for_common(x, max_schedule_timeout, task_interruptible);\n\tif (t == -erestartsys)\n\t\treturn t;\n\treturn 0;\n}\nexport_symbol(wait_for_completion_interruptible);\n\n\nlong __sched\nwait_for_completion_interruptible_timeout(struct completion *x,\n\t\t\t\t\t  unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, task_interruptible);\n}\nexport_symbol(wait_for_completion_interruptible_timeout);\n\n\nint __sched wait_for_completion_killable(struct completion *x)\n{\n\tlong t = wait_for_common(x, max_schedule_timeout, task_killable);\n\tif (t == -erestartsys)\n\t\treturn t;\n\treturn 0;\n}\nexport_symbol(wait_for_completion_killable);\n\n\nlong __sched\nwait_for_completion_killable_timeout(struct completion *x,\n\t\t\t\t     unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, task_killable);\n}\nexport_symbol(wait_for_completion_killable_timeout);\n\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tint ret = 1;\n\n\t\n\tif (!read_once(x->done))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = 0;\n\telse\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}\nexport_symbol(try_wait_for_completion);\n\n\nbool completion_done(struct completion *x)\n{\n\tif (!read_once(x->done))\n\t\treturn false;\n\n\t\n\tsmp_rmb();\n\tspin_unlock_wait(&x->wait.lock);\n\treturn true;\n}\nexport_symbol(completion_done);\n\n\n#include <linux/kdb.h>\n#include <linux/keyboard.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n\n\n#define kbd_status_reg\t\t0x64\t\n#define kbd_data_reg\t\t0x60\t\n\n\n\n#define kbd_stat_obf \t\t0x01\t\n#define kbd_stat_mouse_obf\t0x20\t\n\nstatic int kbd_exists;\nstatic int kbd_last_ret;\n\n\nint kdb_get_kbd_char(void)\n{\n\tint scancode, scanstatus;\n\tstatic int shift_lock;\t\n\tstatic int shift_key;\t\n\tstatic int ctrl_key;\n\tu_short keychar;\n\n\tif (kdb_flag(no_i8042) || kdb_flag(no_vt_console) ||\n\t    (inb(kbd_status_reg) == 0xff && inb(kbd_data_reg) == 0xff)) {\n\t\tkbd_exists = 0;\n\t\treturn -1;\n\t}\n\tkbd_exists = 1;\n\n\tif ((inb(kbd_status_reg) & kbd_stat_obf) == 0)\n\t\treturn -1;\n\n\t\n\tscancode = inb(kbd_data_reg);\n\tscanstatus = inb(kbd_status_reg);\n\n\t\n\tif (scanstatus & kbd_stat_mouse_obf)\n\t\treturn -1;\n\n\t\n\n\tif (((scancode&0x7f) == 0x2a) || ((scancode&0x7f) == 0x36)) {\n\t\t\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tshift_key = 1;\n\t\telse\n\t\t\tshift_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode&0x7f) == 0x1d) {\n\t\t\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tctrl_key = 1;\n\t\telse\n\t\t\tctrl_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode & 0x80) != 0) {\n\t\tif (scancode == 0x9c)\n\t\t\tkbd_last_ret = 0;\n\t\treturn -1;\n\t}\n\n\tscancode &= 0x7f;\n\n\t\n\n\tif (scancode == 0x3a) {\n\t\t\n\t\tshift_lock ^= 1;\n\n#ifdef\tkdb_blink_led\n\t\tkdb_toggleled(0x4);\n#endif\n\t\treturn -1;\n\t}\n\n\tif (scancode == 0x0e) {\n\t\t\n\t\treturn 8;\n\t}\n\n\t\n\tswitch (scancode) {\n\tcase 0xf: \n\t\treturn 9;\n\tcase 0x53: \n\t\treturn 4;\n\tcase 0x47: \n\t\treturn 1;\n\tcase 0x4f: \n\t\treturn 5;\n\tcase 0x4b: \n\t\treturn 2;\n\tcase 0x48: \n\t\treturn 16;\n\tcase 0x50: \n\t\treturn 14;\n\tcase 0x4d: \n\t\treturn 6;\n\t}\n\n\tif (scancode == 0xe0)\n\t\treturn -1;\n\n\t\n\tif (scancode == 0x73)\n\t\tscancode = 0x59;\n\telse if (scancode == 0x7d)\n\t\tscancode = 0x7c;\n\n\tif (!shift_lock && !shift_key && !ctrl_key) {\n\t\tkeychar = plain_map[scancode];\n\t} else if ((shift_lock || shift_key) && key_maps[1]) {\n\t\tkeychar = key_maps[1][scancode];\n\t} else if (ctrl_key && key_maps[4]) {\n\t\tkeychar = key_maps[4][scancode];\n\t} else {\n\t\tkeychar = 0x0020;\n\t\tkdb_printf(\"": 960, "\",\n\t\t       cpumask_pr_args(tr->tracing_cpumask));\n\tif (len >= count) {\n\t\tcount = -einval;\n\t\tgoto out_err;\n\t}\n\tcount = simple_read_from_buffer(ubuf, count, ppos, mask_str, nr_cpus+1);\n\nout_err:\n\tmutex_unlock(&tracing_cpumask_update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\ntracing_cpumask_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t count, loff_t *ppos)\n{\n\tstruct trace_array *tr = file_inode(filp)->i_private;\n\tcpumask_var_t tracing_cpumask_new;\n\tint err, cpu;\n\n\tif (!alloc_cpumask_var(&tracing_cpumask_new, gfp_kernel))\n\t\treturn -enomem;\n\n\terr = cpumask_parse_user(ubuf, count, tracing_cpumask_new);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tmutex_lock(&tracing_cpumask_update_lock);\n\n\tlocal_irq_disable();\n\tarch_spin_lock(&tr->max_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\t\n\t\tif (cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\t!cpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_inc(&per_cpu_ptr(tr->trace_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_disable_cpu(tr->trace_buffer.buffer, cpu);\n\t\t}\n\t\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\tcpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_dec(&per_cpu_ptr(tr->trace_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_enable_cpu(tr->trace_buffer.buffer, cpu);\n\t\t}\n\t}\n\tarch_spin_unlock(&tr->max_lock);\n\tlocal_irq_enable();\n\n\tcpumask_copy(tr->tracing_cpumask, tracing_cpumask_new);\n\n\tmutex_unlock(&tracing_cpumask_update_lock);\n\tfree_cpumask_var(tracing_cpumask_new);\n\n\treturn count;\n\nerr_unlock:\n\tfree_cpumask_var(tracing_cpumask_new);\n\n\treturn err;\n}\n\nstatic const struct file_operations tracing_cpumask_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_cpumask_read,\n\t.write\t\t= tracing_cpumask_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int tracing_trace_options_show(struct seq_file *m, void *v)\n{\n\tstruct tracer_opt *trace_opts;\n\tstruct trace_array *tr = m->private;\n\tu32 tracer_flags;\n\tint i;\n\n\tmutex_lock(&trace_types_lock);\n\ttracer_flags = tr->current_trace->flags->val;\n\ttrace_opts = tr->current_trace->flags->opts;\n\n\tfor (i = 0; trace_options[i]; i++) {\n\t\tif (trace_flags & (1 << i))\n\t\t\tseq_printf(m, \"": 961, "\",\n\t\t       log_lvl, dump_stack_arch_desc_str);\n\n\tprint_worker_info(log_lvl, current);\n}\n\n\nvoid show_regs_print_info(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\n\tprintk(\"": 962, "\",\n\t\t       rcp->name, rcp->ticks_this_gp, dyntick_task_exit_idle,\n\t\t       jiffies - rcp->gp_start, rcp->qlen);\n\t\tdump_stack();\n\t\taccess_once(rcp->jiffies_stall) = jiffies +\n\t\t\t3 * rcu_jiffies_till_stall_check() + 3;\n\t} else if (ulong_cmp_ge(j, js)) {\n\t\taccess_once(rcp->jiffies_stall) = jiffies + rcu_jiffies_till_stall_check();\n\t}\n}\n\nstatic void reset_cpu_stall_ticks(struct rcu_ctrlblk *rcp)\n{\n\trcp->ticks_this_gp = 0;\n\trcp->gp_start = jiffies;\n\taccess_once(rcp->jiffies_stall) = jiffies + rcu_jiffies_till_stall_check();\n}\n\nstatic void check_cpu_stalls(void)\n{\n\trcu_trace(check_cpu_stall(&rcu_bh_ctrlblk));\n\trcu_trace(check_cpu_stall(&rcu_sched_ctrlblk));\n}\n\n#endif \n\n\n#include <linux/gfp.h>\n#include <linux/sched.h>\n#include <linux/sched/rt.h>\n#include <linux/slab.h>\n#include \"": 963, "\",\n\t\t      \"": 964, "\",\n\t\t      (msg->facility << 3) | msg->level,\n\t\t      user->seq, ts_usec, cont);\n\tuser->prev = msg->flags;\n\n\t\n\tfor (i = 0; i < msg->text_len; i++) {\n\t\tunsigned char c = log_text(msg)[i];\n\n\t\tif (c < ' ' || c >= 127 || c == '\\\\')\n\t\t\tlen += sprintf(user->buf + len, \"": 965, "\",\n\t\t     *ptr == (unsigned long)-1 ? -1 : nsecs_to_usecs(*ptr));\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\ntracing_nsecs_write(unsigned long *ptr, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*ptr = val * 1000;\n\n\treturn cnt;\n}\n\nstatic ssize_t\ntracing_thresh_read(struct file *filp, char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(&tracing_thresh, ubuf, cnt, ppos);\n}\n\nstatic ssize_t\ntracing_thresh_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\tret = tracing_nsecs_write(&tracing_thresh, ubuf, cnt, ppos);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (tr->current_trace->update_thresh) {\n\t\tret = tr->current_trace->update_thresh(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = cnt;\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_max_lat_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(filp->private_data, ubuf, cnt, ppos);\n}\n\nstatic ssize_t\ntracing_max_lat_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_write(filp->private_data, ubuf, cnt, ppos);\n}\n\nstatic int tracing_open_pipe(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint ret = 0;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tmutex_lock(&trace_types_lock);\n\n\t\n\titer = kzalloc(sizeof(*iter), gfp_kernel);\n\tif (!iter) {\n\t\tret = -enomem;\n\t\t__trace_array_put(tr);\n\t\tgoto out;\n\t}\n\n\ttrace_seq_init(&iter->seq);\n\titer->trace = tr->current_trace;\n\n\tif (!alloc_cpumask_var(&iter->started, gfp_kernel)) {\n\t\tret = -enomem;\n\t\tgoto fail;\n\t}\n\n\t\n\tcpumask_setall(iter->started);\n\n\tif (trace_flags & trace_iter_latency_fmt)\n\t\titer->iter_flags |= trace_file_lat_fmt;\n\n\t\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\titer->iter_flags |= trace_file_time_in_ns;\n\n\titer->tr = tr;\n\titer->trace_buffer = &tr->trace_buffer;\n\titer->cpu_file = tracing_get_cpu(inode);\n\tmutex_init(&iter->mutex);\n\tfilp->private_data = iter;\n\n\tif (iter->trace->pipe_open)\n\t\titer->trace->pipe_open(iter);\n\n\tnonseekable_open(inode, filp);\n\n\ttr->current_trace->ref++;\nout:\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n\nfail:\n\tkfree(iter->trace);\n\tkfree(iter);\n\t__trace_array_put(tr);\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}\n\nstatic int tracing_release_pipe(struct inode *inode, struct file *file)\n{\n\tstruct trace_iterator *iter = file->private_data;\n\tstruct trace_array *tr = inode->i_private;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->current_trace->ref--;\n\n\tif (iter->trace->pipe_close)\n\t\titer->trace->pipe_close(iter);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(iter->started);\n\tmutex_destroy(&iter->mutex);\n\tkfree(iter);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n\nstatic unsigned int\ntrace_poll(struct trace_iterator *iter, struct file *filp, poll_table *poll_table)\n{\n\t\n\tif (trace_buffer_iter(iter, iter->cpu_file))\n\t\treturn pollin | pollrdnorm;\n\n\tif (trace_flags & trace_iter_block)\n\t\t\n\t\treturn pollin | pollrdnorm;\n\telse\n\t\treturn ring_buffer_poll_wait(iter->trace_buffer->buffer, iter->cpu_file,\n\t\t\t\t\t     filp, poll_table);\n}\n\nstatic unsigned int\ntracing_poll_pipe(struct file *filp, poll_table *poll_table)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\n\treturn trace_poll(iter, filp, poll_table);\n}\n\n\nstatic int tracing_wait_pipe(struct file *filp)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\tint ret;\n\n\twhile (trace_empty(iter)) {\n\n\t\tif ((filp->f_flags & o_nonblock)) {\n\t\t\treturn -eagain;\n\t\t}\n\n\t\t\n\t\tif (!tracing_is_on() && iter->pos)\n\t\t\tbreak;\n\n\t\tmutex_unlock(&iter->mutex);\n\n\t\tret = wait_on_pipe(iter, false);\n\n\t\tmutex_lock(&iter->mutex);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 1;\n}\n\n\nstatic ssize_t\ntracing_read_pipe(struct file *filp, char __user *ubuf,\n\t\t  size_t cnt, loff_t *ppos)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\tssize_t sret;\n\n\t\n\tsret = trace_seq_to_user(&iter->seq, ubuf, cnt);\n\tif (sret != -ebusy)\n\t\treturn sret;\n\n\ttrace_seq_init(&iter->seq);\n\n\t\n\tmutex_lock(&iter->mutex);\n\tif (iter->trace->read) {\n\t\tsret = iter->trace->read(iter, filp, ubuf, cnt, ppos);\n\t\tif (sret)\n\t\t\tgoto out;\n\t}\n\nwaitagain:\n\tsret = tracing_wait_pipe(filp);\n\tif (sret <= 0)\n\t\tgoto out;\n\n\t\n\tif (trace_empty(iter)) {\n\t\tsret = 0;\n\t\tgoto out;\n\t}\n\n\tif (cnt >= page_size)\n\t\tcnt = page_size - 1;\n\n\t\n\tmemset(&iter->seq, 0,\n\t       sizeof(struct trace_iterator) -\n\t       offsetof(struct trace_iterator, seq));\n\tcpumask_clear(iter->started);\n\titer->pos = -1;\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\twhile (trace_find_next_entry_inc(iter) != null) {\n\t\tenum print_line_t ret;\n\t\tint save_len = iter->seq.seq.len;\n\n\t\tret = print_trace_line(iter);\n\t\tif (ret == trace_type_partial_line) {\n\t\t\t\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != trace_type_no_consume)\n\t\t\ttrace_consume(iter);\n\n\t\tif (trace_seq_used(&iter->seq) >= cnt)\n\t\t\tbreak;\n\n\t\t\n\t\twarn_once(iter->seq.full, \"": 966, "\",\n\t\t    ktime_to_ns(delta));\n}\n\n\nstatic void __hrtimer_peek_ahead_timers(void)\n{\n\tstruct tick_device *td;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tif (td && td->evtdev)\n\t\thrtimer_interrupt(td->evtdev);\n}\n\n\nvoid hrtimer_peek_ahead_timers(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_restore(flags);\n}\n\nstatic void run_hrtimer_softirq(struct softirq_action *h)\n{\n\thrtimer_peek_ahead_timers();\n}\n\n#else \n\nstatic inline void __hrtimer_peek_ahead_timers(void) { }\n\n#endif\t\n\n\nvoid hrtimer_run_pending(void)\n{\n\tif (hrtimer_hres_active())\n\t\treturn;\n\n\t\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled()))\n\t\thrtimer_switch_to_hres();\n}\n\n\nvoid hrtimer_run_queues(void)\n{\n\tstruct timerqueue_node *node;\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base;\n\tint index, gettime = 1;\n\n\tif (hrtimer_hres_active())\n\t\treturn;\n\n\tfor (index = 0; index < hrtimer_max_clock_bases; index++) {\n\t\tbase = &cpu_base->clock_base[index];\n\t\tif (!timerqueue_getnext(&base->active))\n\t\t\tcontinue;\n\n\t\tif (gettime) {\n\t\t\thrtimer_get_softirq_time(cpu_base);\n\t\t\tgettime = 0;\n\t\t}\n\n\t\traw_spin_lock(&cpu_base->lock);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\t\t\tif (base->softirq_time.tv64 <=\n\t\t\t\t\thrtimer_get_expires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(timer, &base->softirq_time);\n\t\t}\n\t\traw_spin_unlock(&cpu_base->lock);\n\t}\n}\n\n\nstatic enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)\n{\n\tstruct hrtimer_sleeper *t =\n\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);\n\tstruct task_struct *task = t->task;\n\n\tt->task = null;\n\tif (task)\n\t\twake_up_process(task);\n\n\treturn hrtimer_norestart;\n}\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}\nexport_symbol_gpl(hrtimer_init_sleeper);\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(task_interruptible);\n\t\thrtimer_start_expires(&t->timer, mode);\n\t\tif (!hrtimer_active(&t->timer))\n\t\t\tt->task = null;\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = hrtimer_mode_abs;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(task_running);\n\n\treturn t->task == null;\n}\n\nstatic int update_rmtp(struct hrtimer *timer, struct timespec __user *rmtp)\n{\n\tstruct timespec rmt;\n\tktime_t rem;\n\n\trem = hrtimer_expires_remaining(timer);\n\tif (rem.tv64 <= 0)\n\t\treturn 0;\n\trmt = ktime_to_timespec(rem);\n\n\tif (copy_to_user(rmtp, &rmt, sizeof(*rmtp)))\n\t\treturn -efault;\n\n\treturn 1;\n}\n\nlong __sched hrtimer_nanosleep_restart(struct restart_block *restart)\n{\n\tstruct hrtimer_sleeper t;\n\tstruct timespec __user  *rmtp;\n\tint ret = 0;\n\n\thrtimer_init_on_stack(&t.timer, restart->nanosleep.clockid,\n\t\t\t\thrtimer_mode_abs);\n\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);\n\n\tif (do_nanosleep(&t, hrtimer_mode_abs))\n\t\tgoto out;\n\n\trmtp = restart->nanosleep.rmtp;\n\tif (rmtp) {\n\t\tret = update_rmtp(&t.timer, rmtp);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\t\n\tret = -erestart_restartblock;\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}\n\nlong hrtimer_nanosleep(struct timespec *rqtp, struct timespec __user *rmtp,\n\t\t       const enum hrtimer_mode mode, const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tunsigned long slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_on_stack(&t.timer, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, timespec_to_ktime(*rqtp), slack);\n\tif (do_nanosleep(&t, mode))\n\t\tgoto out;\n\n\t\n\tif (mode == hrtimer_mode_abs) {\n\t\tret = -erestartnohand;\n\t\tgoto out;\n\t}\n\n\tif (rmtp) {\n\t\tret = update_rmtp(&t.timer, rmtp);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->fn = hrtimer_nanosleep_restart;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.rmtp = rmtp;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\n\tret = -erestart_restartblock;\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}\n\nsyscall_define2(nanosleep, struct timespec __user *, rqtp,\n\t\tstruct timespec __user *, rmtp)\n{\n\tstruct timespec tu;\n\n\tif (copy_from_user(&tu, rqtp, sizeof(tu)))\n\t\treturn -efault;\n\n\tif (!timespec_valid(&tu))\n\t\treturn -einval;\n\n\treturn hrtimer_nanosleep(&tu, rmtp, hrtimer_mode_rel, clock_monotonic);\n}\n\n\nstatic void init_hrtimers_cpu(int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\t\ttimerqueue_init_head(&cpu_base->clock_base[i].active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\thrtimer_init_hres(cpu_base);\n}\n\n#ifdef config_hotplug_cpu\n\nstatic void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tbug_on(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t\n\t\t__remove_hrtimer(timer, old_base, hrtimer_state_migrate, 0);\n\t\ttimer->base = new_base;\n\t\t\n\t\tenqueue_hrtimer(timer, new_base);\n\n\t\t\n\t\ttimer->state &= ~hrtimer_state_migrate;\n\t}\n}\n\nstatic void migrate_hrtimers(int scpu)\n{\n\tstruct hrtimer_cpu_base *old_base, *new_base;\n\tint i;\n\n\tbug_on(cpu_online(scpu));\n\ttick_cancel_sched_timer(scpu);\n\n\tlocal_irq_disable();\n\told_base = &per_cpu(hrtimer_bases, scpu);\n\tnew_base = this_cpu_ptr(&hrtimer_bases);\n\t\n\traw_spin_lock(&new_base->lock);\n\traw_spin_lock_nested(&old_base->lock, single_depth_nesting);\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tmigrate_hrtimer_list(&old_base->clock_base[i],\n\t\t\t\t     &new_base->clock_base[i]);\n\t}\n\n\traw_spin_unlock(&old_base->lock);\n\traw_spin_unlock(&new_base->lock);\n\n\t\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_enable();\n}\n\n#endif \n\nstatic int hrtimer_cpu_notify(struct notifier_block *self,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tint scpu = (long)hcpu;\n\n\tswitch (action) {\n\n\tcase cpu_up_prepare:\n\tcase cpu_up_prepare_frozen:\n\t\tinit_hrtimers_cpu(scpu);\n\t\tbreak;\n\n#ifdef config_hotplug_cpu\n\tcase cpu_dead:\n\tcase cpu_dead_frozen:\n\t\tmigrate_hrtimers(scpu);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notify_ok;\n}\n\nstatic struct notifier_block hrtimers_nb = {\n\t.notifier_call = hrtimer_cpu_notify,\n};\n\nvoid __init hrtimers_init(void)\n{\n\thrtimer_cpu_notify(&hrtimers_nb, (unsigned long)cpu_up_prepare,\n\t\t\t  (void *)(long)smp_processor_id());\n\tregister_cpu_notifier(&hrtimers_nb);\n#ifdef config_high_res_timers\n\topen_softirq(hrtimer_softirq, run_hrtimer_softirq);\n#endif\n}\n\n\nint __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, unsigned long delta,\n\t\t\t       const enum hrtimer_mode mode, int clock)\n{\n\tstruct hrtimer_sleeper t;\n\n\t\n\tif (expires && !expires->tv64) {\n\t\t__set_current_state(task_running);\n\t\treturn 0;\n\t}\n\n\t\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -eintr;\n\t}\n\n\thrtimer_init_on_stack(&t.timer, clock, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\n\thrtimer_init_sleeper(&t, current);\n\n\thrtimer_start_expires(&t.timer, mode);\n\tif (!hrtimer_active(&t.timer))\n\t\tt.task = null;\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(task_running);\n\n\treturn !t.task ? 0 : -eintr;\n}\n\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, unsigned long delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      clock_monotonic);\n}\nexport_symbol_gpl(schedule_hrtimeout_range);\n\n\nint __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}\nexport_symbol_gpl(schedule_hrtimeout);\n\n#include <linux/user-return-notifier.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nstatic define_per_cpu(struct hlist_head, return_notifier_list);\n\n\nvoid user_return_notifier_register(struct user_return_notifier *urn)\n{\n\tset_tsk_thread_flag(current, tif_user_return_notify);\n\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));\n}\nexport_symbol_gpl(user_return_notifier_register);\n\n\nvoid user_return_notifier_unregister(struct user_return_notifier *urn)\n{\n\thlist_del(&urn->link);\n\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))\n\t\tclear_tsk_thread_flag(current, tif_user_return_notify);\n}\nexport_symbol_gpl(user_return_notifier_unregister);\n\n\nvoid fire_user_return_notifiers(void)\n{\n\tstruct user_return_notifier *urn;\n\tstruct hlist_node *tmp2;\n\tstruct hlist_head *head;\n\n\thead = &get_cpu_var(return_notifier_list);\n\thlist_for_each_entry_safe(urn, tmp2, head, link)\n\t\turn->on_user_return(urn);\n\tput_cpu_var(return_notifier_list);\n}\n#define pr_fmt(fmt) kbuild_modname \"": 967, "\",\n\t\t   \"": 968, "\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tseq_printf(m, \"": 969, "\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tseq_printf(m, \"": 970, "\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tseq_printf(m,   \"": 971, "\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tseq_printf(m, \"": 972, "\",\n\t\t   cpumask_bits(tick_get_broadcast_mask())[0]);\n#ifdef config_tick_oneshot\n\tseq_printf(m, \"": 973, "\",\n\t\t   cpumask_bits(tick_get_broadcast_oneshot_mask())[0]);\n#endif\n\tseq_printf(m, \"": 974, "\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"": 975, "\",\n\t\t   entries, total, num_online_cpus());\n\tseq_puts(m, \"": 976, "\",\n\t\t   name, uts_release);\n\tseq_puts(m, \"": 977, "\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(config_preempt_none)\n\t\t   \"": 978, "\",\n\t\t   ptr->map.enum_string, ptr->map.enum_value,\n\t\t   ptr->map.system);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_enum_map_seq_ops = {\n\t.start\t\t= enum_map_start,\n\t.next\t\t= enum_map_next,\n\t.stop\t\t= enum_map_stop,\n\t.show\t\t= enum_map_show,\n};\n\nstatic int tracing_enum_map_open(struct inode *inode, struct file *filp)\n{\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\treturn seq_open(filp, &tracing_enum_map_seq_ops);\n}\n\nstatic const struct file_operations tracing_enum_map_fops = {\n\t.open\t\t= tracing_enum_map_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic inline union trace_enum_map_item *\ntrace_enum_jmp_to_tail(union trace_enum_map_item *ptr)\n{\n\t\n\treturn ptr + ptr->head.length + 1;\n}\n\nstatic void\ntrace_insert_enum_map_file(struct module *mod, struct trace_enum_map **start,\n\t\t\t   int len)\n{\n\tstruct trace_enum_map **stop;\n\tstruct trace_enum_map **map;\n\tunion trace_enum_map_item *map_array;\n\tunion trace_enum_map_item *ptr;\n\n\tstop = start + len;\n\n\t\n\tmap_array = kmalloc(sizeof(*map_array) * (len + 2), gfp_kernel);\n\tif (!map_array) {\n\t\tpr_warning(\"": 979, "\",\n\t\t(console->flags & con_boot) ? \"": 980, "\",\n\t\t(newcon->flags & con_boot) ? \"": 981, "\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tseq_printf(m, \"": 982, "\",\n\t\t.data\t\t= init_uts_ns.name.domainname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.domainname),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &domainname_poll,\n\t},\n\t{}\n};\n\nstatic struct ctl_table uts_root_table[] = {\n\t{\n\t\t.procname\t= \"": 983, "\",\n\t\t.data\t\t= init_uts_ns.name.nodename,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.nodename),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &hostname_poll,\n\t},\n\t{\n\t\t.procname\t= \"": 984, "\",\n\t\t.data\t\t= init_uts_ns.name.release,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.release),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"": 985, "\",\n\t\t.data\t\t= init_uts_ns.name.sysname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.sysname),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"": 986, "\",\n\t\t.data\t\t= init_uts_ns.name.version,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.version),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"": 987, "\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= uts_kern_table,\n\t},\n\t{}\n};\n\n#ifdef config_proc_sysctl\n\nvoid uts_proc_notify(enum uts_proc proc)\n{\n\tstruct ctl_table *table = &uts_kern_table[proc];\n\n\tproc_sys_poll_notify(table->poll);\n}\n#endif\n\nstatic int __init utsname_sysctl_init(void)\n{\n\tregister_sysctl_table(uts_root_table);\n\treturn 0;\n}\n\ndevice_initcall(utsname_sysctl_init);\n\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/relay.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/cpu.h>\n#include <linux/splice.h>\n\n\nstatic define_mutex(relay_channels_mutex);\nstatic list_head(relay_channels);\n\n\nstatic void relay_file_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = vma->vm_private_data;\n\tbuf->chan->cb->buf_unmapped(buf, vma->vm_file);\n}\n\n\nstatic int relay_buf_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tstruct rchan_buf *buf = vma->vm_private_data;\n\tpgoff_t pgoff = vmf->pgoff;\n\n\tif (!buf)\n\t\treturn vm_fault_oom;\n\n\tpage = vmalloc_to_page(buf->start + (pgoff << page_shift));\n\tif (!page)\n\t\treturn vm_fault_sigbus;\n\tget_page(page);\n\tvmf->page = page;\n\n\treturn 0;\n}\n\n\nstatic const struct vm_operations_struct relay_file_mmap_ops = {\n\t.fault = relay_buf_fault,\n\t.close = relay_file_mmap_close,\n};\n\n\nstatic struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > page_size)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, gfp_kernel);\n}\n\n\nstatic void relay_free_page_array(struct page **array)\n{\n\tif (is_vmalloc_addr(array))\n\t\tvfree(array);\n\telse\n\t\tkfree(array);\n}\n\n\nstatic int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\n{\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\tstruct file *filp = vma->vm_file;\n\n\tif (!buf)\n\t\treturn -ebadf;\n\n\tif (length != (unsigned long)buf->chan->alloc_size)\n\t\treturn -einval;\n\n\tvma->vm_ops = &relay_file_mmap_ops;\n\tvma->vm_flags |= vm_dontexpand;\n\tvma->vm_private_data = buf;\n\tbuf->chan->cb->buf_mapped(buf, filp);\n\n\treturn 0;\n}\n\n\nstatic void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\n{\n\tvoid *mem;\n\tunsigned int i, j, n_pages;\n\n\t*size = page_align(*size);\n\tn_pages = *size >> page_shift;\n\n\tbuf->page_array = relay_alloc_page_array(n_pages);\n\tif (!buf->page_array)\n\t\treturn null;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tbuf->page_array[i] = alloc_page(gfp_kernel);\n\t\tif (unlikely(!buf->page_array[i]))\n\t\t\tgoto depopulate;\n\t\tset_page_private(buf->page_array[i], (unsigned long)buf);\n\t}\n\tmem = vmap(buf->page_array, n_pages, vm_map, page_kernel);\n\tif (!mem)\n\t\tgoto depopulate;\n\n\tmemset(mem, 0, *size);\n\tbuf->page_count = n_pages;\n\treturn mem;\n\ndepopulate:\n\tfor (j = 0; j < i; j++)\n\t\t__free_page(buf->page_array[j]);\n\trelay_free_page_array(buf->page_array);\n\treturn null;\n}\n\n\nstatic struct rchan_buf *relay_create_buf(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\n\tif (chan->n_subbufs > uint_max / sizeof(size_t *))\n\t\treturn null;\n\n\tbuf = kzalloc(sizeof(struct rchan_buf), gfp_kernel);\n\tif (!buf)\n\t\treturn null;\n\tbuf->padding = kmalloc(chan->n_subbufs * sizeof(size_t *), gfp_kernel);\n\tif (!buf->padding)\n\t\tgoto free_buf;\n\n\tbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\n\tif (!buf->start)\n\t\tgoto free_buf;\n\n\tbuf->chan = chan;\n\tkref_get(&buf->chan->kref);\n\treturn buf;\n\nfree_buf:\n\tkfree(buf->padding);\n\tkfree(buf);\n\treturn null;\n}\n\n\nstatic void relay_destroy_channel(struct kref *kref)\n{\n\tstruct rchan *chan = container_of(kref, struct rchan, kref);\n\tkfree(chan);\n}\n\n\nstatic void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\tchan->buf[buf->cpu] = null;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}\n\n\nstatic void relay_remove_buf(struct kref *kref)\n{\n\tstruct rchan_buf *buf = container_of(kref, struct rchan_buf, kref);\n\trelay_destroy_buf(buf);\n}\n\n\nstatic int relay_buf_empty(struct rchan_buf *buf)\n{\n\treturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\n}\n\n\nint relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}\nexport_symbol_gpl(relay_buf_full);\n\n\n\n\n\n\nstatic int subbuf_start_default_callback (struct rchan_buf *buf,\n\t\t\t\t\t  void *subbuf,\n\t\t\t\t\t  void *prev_subbuf,\n\t\t\t\t\t  size_t prev_padding)\n{\n\tif (relay_buf_full(buf))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic void buf_mapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\tstruct file *filp)\n{\n}\n\n\nstatic void buf_unmapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\t  struct file *filp)\n{\n}\n\n\nstatic struct dentry *create_buf_file_default_callback(const char *filename,\n\t\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t\t       umode_t mode,\n\t\t\t\t\t\t       struct rchan_buf *buf,\n\t\t\t\t\t\t       int *is_global)\n{\n\treturn null;\n}\n\n\nstatic int remove_buf_file_default_callback(struct dentry *dentry)\n{\n\treturn -einval;\n}\n\n\nstatic struct rchan_callbacks default_channel_callbacks = {\n\t.subbuf_start = subbuf_start_default_callback,\n\t.buf_mapped = buf_mapped_default_callback,\n\t.buf_unmapped = buf_unmapped_default_callback,\n\t.create_buf_file = create_buf_file_default_callback,\n\t.remove_buf_file = remove_buf_file_default_callback,\n};\n\n\nstatic void wakeup_readers(unsigned long data)\n{\n\tstruct rchan_buf *buf = (struct rchan_buf *)data;\n\twake_up_interruptible(&buf->read_wait);\n}\n\n\nstatic void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tsetup_timer(&buf->timer, wakeup_readers, (unsigned long)buf);\n\t} else\n\t\tdel_timer_sync(&buf->timer);\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, null, 0);\n}\n\n\nvoid relay_reset(struct rchan *chan)\n{\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && chan->buf[0]) {\n\t\t__relay_reset(chan->buf[0], 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif (chan->buf[i])\n\t\t\t__relay_reset(chan->buf[i], 0);\n\tmutex_unlock(&relay_channels_mutex);\n}\nexport_symbol_gpl(relay_reset);\n\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}\n\nstatic struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(name_max + 1, gfp_kernel);\n\tif (!tmpname)\n\t\treturn null;\n\tsnprintf(tmpname, name_max, \"": 988, "\",\n\t\t__log_cpu_max_buf_len);\n\tpr_info(\"": 989, "\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tpr_debug(\"": 990, "\",\n\t\tboot_delay, preset_lpj, lpj, hz, loops_per_msec);\n\treturn 0;\n}\nearly_param(\"": 991, "\",\n\t\tcount, count / entries_per_page + 1);\n\n\tlast_ftrace_enabled = ftrace_enabled = 1;\n\n\tret = ftrace_process_locs(null,\n\t\t\t\t  __start_mcount_loc,\n\t\t\t\t  __stop_mcount_loc);\n\n\tret = register_module_notifier(&ftrace_module_exit_nb);\n\tif (ret)\n\t\tpr_warning(\"": 992, "\",\n\t\tcpu_extra);\n\tpr_info(\"": 993, "\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"": 994, "\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\tprintk(\"": 995, "\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tcurr->hardirq_context, hardirq_count() >> hardirq_shift,\n\t\tcurr->softirq_context, softirq_count() >> softirq_shift,\n\t\tcurr->hardirqs_enabled,\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tprintk(\"": 996, "\",\n\t\tfree, (free * 100) / __log_buf_len);\n}\n\nstatic bool __read_mostly ignore_loglevel;\n\nstatic int __init ignore_loglevel_setup(char *str)\n{\n\tignore_loglevel = true;\n\tpr_info(\"": 997, "\",\n\t\thwirq, of_node_full_name(domain->of_node), virq);\n\n\treturn virq;\n}\nexport_symbol_gpl(irq_create_mapping);\n\n\nint irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tint ret;\n\n\tret = irq_alloc_descs(irq_base, irq_base, count,\n\t\t\t      of_node_to_nid(domain->of_node));\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tirq_domain_associate_many(domain, irq_base, hwirq_base, count);\n\treturn 0;\n}\nexport_symbol_gpl(irq_create_strict_mappings);\n\nunsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_domain *domain;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = irq_type_none;\n\tint virq;\n\n\tdomain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain;\n\tif (!domain) {\n\t\tpr_warn(\"": 998, "\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tprintk(\"": 999, "\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tprintk(\"": 1000, "\",\n\t       default_bootup_tracer);\n\tdefault_bootup_tracer = null;\n\n\treturn 0;\n}\n\nfs_initcall(tracer_init_tracefs);\nlate_initcall(clear_boot_tracer);\n\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/deadline.h>\n#include <linux/timer.h>\n\n#include \"": 1001, "\",\n\t       log_lvl, current, current_thread_info(),\n\t       task_thread_info(current));\n}\n\n#endif\n\n\n#include <linux/sched.h>\n#include <linux/posix-timers.h>\n#include <linux/errno.h>\n#include <linux/math64.h>\n#include <asm/uaccess.h>\n#include <linux/kernel_stat.h>\n#include <trace/events/timer.h>\n#include <linux/random.h>\n#include <linux/tick.h>\n#include <linux/workqueue.h>\n\n\nvoid update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)\n{\n\tcputime_t cputime = secs_to_cputime(rlim_new);\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tset_process_cpu_timer(task, cpuclock_prof, &cputime, null);\n\tspin_unlock_irq(&task->sighand->siglock);\n}\n\nstatic int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = cpuclock_pid(which_clock);\n\n\tif (cpuclock_which(which_clock) >= cpuclock_max)\n\t\treturn -einval;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(cpuclock_perthread(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -einval;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nstatic inline unsigned long long\ntimespec_to_sample(const clockid_t which_clock, const struct timespec *tp)\n{\n\tunsigned long long ret;\n\n\tret = 0;\t\t\n\tif (cpuclock_which(which_clock) == cpuclock_sched) {\n\t\tret = (unsigned long long)tp->tv_sec * nsec_per_sec + tp->tv_nsec;\n\t} else {\n\t\tret = cputime_to_expires(timespec_to_cputime(tp));\n\t}\n\treturn ret;\n}\n\nstatic void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       unsigned long long expires,\n\t\t\t       struct timespec *tp)\n{\n\tif (cpuclock_which(which_clock) == cpuclock_sched)\n\t\t*tp = ns_to_timespec(expires);\n\telse\n\t\tcputime_to_timespec((__force cputime_t)expires, tp);\n}\n\n\nstatic void bump_cpu_timer(struct k_itimer *timer,\n\t\t\t   unsigned long long now)\n{\n\tint i;\n\tunsigned long long delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}\n\n\nstatic inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline unsigned long long prof_ticks(struct task_struct *p)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn cputime_to_expires(utime + stime);\n}\nstatic inline unsigned long long virt_ticks(struct task_struct *p)\n{\n\tcputime_t utime;\n\n\ttask_cputime(p, &utime, null);\n\n\treturn cputime_to_expires(utime);\n}\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((nsec_per_sec + hz - 1) / hz);\n\t\tif (cpuclock_which(which_clock) == cpuclock_sched) {\n\t\t\t\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}\n\nstatic int\nposix_cpu_clock_set(const clockid_t which_clock, const struct timespec *tp)\n{\n\t\n\tint error = check_clock(which_clock);\n\tif (error == 0) {\n\t\terror = -eperm;\n\t}\n\treturn error;\n}\n\n\n\nstatic int cpu_clock_sample(const clockid_t which_clock, struct task_struct *p,\n\t\t\t    unsigned long long *sample)\n{\n\tswitch (cpuclock_which(which_clock)) {\n\tdefault:\n\t\treturn -einval;\n\tcase cpuclock_prof:\n\t\t*sample = prof_ticks(p);\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\t*sample = virt_ticks(p);\n\t\tbreak;\n\tcase cpuclock_sched:\n\t\t*sample = task_sched_runtime(p);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void update_gt_cputime(struct task_cputime *a, struct task_cputime *b)\n{\n\tif (b->utime > a->utime)\n\t\ta->utime = b->utime;\n\n\tif (b->stime > a->stime)\n\t\ta->stime = b->stime;\n\n\tif (b->sum_exec_runtime > a->sum_exec_runtime)\n\t\ta->sum_exec_runtime = b->sum_exec_runtime;\n}\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\tunsigned long flags;\n\n\tif (!cputimer->running) {\n\t\t\n\t\tthread_group_cputime(tsk, &sum);\n\t\traw_spin_lock_irqsave(&cputimer->lock, flags);\n\t\tcputimer->running = 1;\n\t\tupdate_gt_cputime(&cputimer->cputime, &sum);\n\t} else\n\t\traw_spin_lock_irqsave(&cputimer->lock, flags);\n\t*times = cputimer->cputime;\n\traw_spin_unlock_irqrestore(&cputimer->lock, flags);\n}\n\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  unsigned long long *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (cpuclock_which(which_clock)) {\n\tdefault:\n\t\treturn -einval;\n\tcase cpuclock_prof:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime_to_expires(cputime.utime + cputime.stime);\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime_to_expires(cputime.utime);\n\t\tbreak;\n\tcase cpuclock_sched:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int posix_cpu_clock_get_task(struct task_struct *tsk,\n\t\t\t\t    const clockid_t which_clock,\n\t\t\t\t    struct timespec *tp)\n{\n\tint err = -einval;\n\tunsigned long long rtn;\n\n\tif (cpuclock_perthread(which_clock)) {\n\t\tif (same_thread_group(tsk, current))\n\t\t\terr = cpu_clock_sample(which_clock, tsk, &rtn);\n\t} else {\n\t\tif (tsk == current || thread_group_leader(tsk))\n\t\t\terr = cpu_clock_sample_group(which_clock, tsk, &rtn);\n\t}\n\n\tif (!err)\n\t\tsample_to_timespec(which_clock, rtn, tp);\n\n\treturn err;\n}\n\n\nstatic int posix_cpu_clock_get(const clockid_t which_clock, struct timespec *tp)\n{\n\tconst pid_t pid = cpuclock_pid(which_clock);\n\tint err = -einval;\n\n\tif (pid == 0) {\n\t\t\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}\n\n\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = cpuclock_pid(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (cpuclock_which(new_timer->it_clock) >= cpuclock_max)\n\t\treturn -einval;\n\n\tinit_list_head(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (cpuclock_perthread(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = null;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = null;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -einval;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n\nstatic int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\twarn_on_once(p == null);\n\n\t\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == null)) {\n\t\t\n\t\twarn_on_once(!list_empty(&timer->it.cpu.entry));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = timer_retry;\n\t\telse\n\t\t\tlist_del(&timer->it.cpu.entry);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tif (!ret)\n\t\tput_task_struct(p);\n\n\treturn ret;\n}\n\nstatic void cleanup_timers_list(struct list_head *head)\n{\n\tstruct cpu_timer_list *timer, *next;\n\n\tlist_for_each_entry_safe(timer, next, head, entry)\n\t\tlist_del_init(&timer->entry);\n}\n\n\nstatic void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}\n\n\nvoid posix_cpu_timers_exit(struct task_struct *tsk)\n{\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t\t\t\tsizeof(unsigned long long));\n\tcleanup_timers(tsk->cpu_timers);\n\n}\nvoid posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers);\n}\n\nstatic inline int expires_gt(cputime_t expires, cputime_t new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}\n\n\nstatic void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += cpuclock_which(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tunsigned long long exp = nt->expires;\n\n\t\t\n\n\t\tswitch (cpuclock_which(timer->it_clock)) {\n\t\tcase cpuclock_prof:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, expires_to_cputime(exp)))\n\t\t\t\tcputime_expires->prof_exp = expires_to_cputime(exp);\n\t\t\tbreak;\n\t\tcase cpuclock_virt:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, expires_to_cputime(exp)))\n\t\t\t\tcputime_expires->virt_exp = expires_to_cputime(exp);\n\t\t\tbreak;\n\t\tcase cpuclock_sched:\n\t\t\tif (cputime_expires->sched_exp == 0 ||\n\t\t\t    cputime_expires->sched_exp > exp)\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~sigev_thread_id) == sigev_none) {\n\t\t\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == null)) {\n\t\t\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t\n\t\tposix_cpu_timer_schedule(timer);\n\t}\n}\n\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  unsigned long long *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (cpuclock_which(which_clock)) {\n\tdefault:\n\t\treturn -einval;\n\tcase cpuclock_prof:\n\t\t*sample = cputime_to_expires(cputime.utime + cputime.stime);\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\t*sample = cputime_to_expires(cputime.utime);\n\t\tbreak;\n\tcase cpuclock_sched:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#ifdef config_no_hz_full\nstatic void nohz_kick_work_fn(struct work_struct *work)\n{\n\ttick_nohz_full_kick_all();\n}\n\nstatic declare_work(nohz_kick_work, nohz_kick_work_fn);\n\n\nstatic void posix_cpu_timer_kick_nohz(void)\n{\n\tif (context_tracking_is_enabled())\n\t\tschedule_work(&nohz_kick_work);\n}\n\nbool posix_cpu_timers_can_stop_tick(struct task_struct *tsk)\n{\n\tif (!task_cputime_zero(&tsk->cputime_expires))\n\t\treturn false;\n\n\tif (tsk->signal->cputimer.running)\n\t\treturn false;\n\n\treturn true;\n}\n#else\nstatic inline void posix_cpu_timer_kick_nohz(void) { }\n#endif\n\n\nstatic int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec *new, struct itimerspec *old)\n{\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tunsigned long long old_expires, new_expires, old_incr, val;\n\tint ret;\n\n\twarn_on_once(p == null);\n\n\tnew_expires = timespec_to_sample(timer->it_clock, &new->it_value);\n\n\t\n\tsighand = lock_task_sighand(p, &flags);\n\t\n\tif (unlikely(sighand == null)) {\n\t\treturn -esrch;\n\t}\n\n\t\n\twarn_on_once(!irqs_disabled());\n\n\tret = 0;\n\told_incr = timer->it.cpu.incr;\n\told_expires = timer->it.cpu.expires;\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = timer_retry;\n\t} else\n\t\tlist_del_init(&timer->it.cpu.entry);\n\n\t\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &val);\n\t} else {\n\t\tcpu_timer_sample_group(timer->it_clock, p, &val);\n\t}\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t\n\t\t\tbump_cpu_timer(timer, val);\n\t\t\tif (val < timer->it.cpu.expires) {\n\t\t\t\told_expires = timer->it.cpu.expires - val;\n\t\t\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t\t\t   old_expires,\n\t\t\t\t\t\t   &old->it_value);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & timer_abstime)) {\n\t\tnew_expires += val;\n\t}\n\n\t\n\ttimer->it.cpu.expires = new_expires;\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t\n\ttimer->it.cpu.incr = timespec_to_sample(timer->it_clock,\n\t\t\t\t\t\t&new->it_interval);\n\n\t\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~requeue_pending;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (new_expires != 0 && !(val < new_expires)) {\n\t\t\n\t\tcpu_timer_fire(timer);\n\t}\n\n\tret = 0;\n out:\n\tif (old) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   old_incr, &old->it_interval);\n\t}\n\tif (!ret)\n\t\tposix_cpu_timer_kick_nohz();\n\treturn ret;\n}\n\nstatic void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunsigned long long now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\twarn_on_once(p == null);\n\n\t\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\n\tif (timer->it.cpu.expires == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\n\t\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t} else {\n\t\tstruct sighand_struct *sighand;\n\t\tunsigned long flags;\n\n\t\t\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == null)) {\n\t\t\t\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t\t   &itp->it_value);\n\t\t} else {\n\t\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t}\n\t}\n\n\tif (now < timer->it.cpu.expires) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   timer->it.cpu.expires - now,\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\t\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}\n\nstatic unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct list_head *timers = tsk->cpu_timers;\n\tstruct signal_struct *const sig = tsk->signal;\n\tstruct task_cputime *tsk_expires = &tsk->cputime_expires;\n\tunsigned long long expires;\n\tunsigned long soft;\n\n\texpires = check_timers_list(timers, firing, prof_ticks(tsk));\n\ttsk_expires->prof_exp = expires_to_cputime(expires);\n\n\texpires = check_timers_list(++timers, firing, virt_ticks(tsk));\n\ttsk_expires->virt_exp = expires_to_cputime(expires);\n\n\ttsk_expires->sched_exp = check_timers_list(++timers, firing,\n\t\t\t\t\t\t   tsk->se.sum_exec_runtime);\n\n\t\n\tsoft = access_once(sig->rlim[rlimit_rttime].rlim_cur);\n\tif (soft != rlim_infinity) {\n\t\tunsigned long hard =\n\t\t\taccess_once(sig->rlim[rlimit_rttime].rlim_max);\n\n\t\tif (hard != rlim_infinity &&\n\t\t    tsk->rt.timeout > div_round_up(hard, usec_per_sec/hz)) {\n\t\t\t\n\t\t\t__group_send_sig_info(sigkill, send_sig_priv, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (tsk->rt.timeout > div_round_up(soft, usec_per_sec/hz)) {\n\t\t\t\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft += usec_per_sec;\n\t\t\t\tsig->rlim[rlimit_rttime].rlim_cur = soft;\n\t\t\t}\n\t\t\tprintk(kern_info\n\t\t\t\t\"": 1002, "\",\n\t       log_lvl, raw_smp_processor_id(), current->pid, current->comm,\n\t       print_tainted(), init_utsname()->release,\n\t       (int)strcspn(init_utsname()->version, \"": 1003, "\",\n\t.debug_hint\t= hrtimer_debug_hint,\n\t.fixup_init\t= hrtimer_fixup_init,\n\t.fixup_activate\t= hrtimer_fixup_activate,\n\t.fixup_free\t= hrtimer_fixup_free,\n};\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer)\n{\n\tdebug_object_init(timer, &hrtimer_debug_descr);\n}\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer)\n{\n\tdebug_object_deactivate(timer, &hrtimer_debug_descr);\n}\n\nstatic inline void debug_hrtimer_free(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode);\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}\nexport_symbol_gpl(hrtimer_init_on_stack);\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}\n\n#else\nstatic inline void debug_hrtimer_init(struct hrtimer *timer) { }\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer) { }\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }\n#endif\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}\n\nstatic inline void debug_activate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_activate(timer);\n\ttrace_hrtimer_start(timer);\n}\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}\n\n#if defined(config_no_hz_common) || defined(config_high_res_timers)\nstatic ktime_t __hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tstruct hrtimer_clock_base *base = cpu_base->clock_base;\n\tktime_t expires, expires_next = { .tv64 = ktime_max };\n\tint i;\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++, base++) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\tif (!next)\n\t\t\tcontinue;\n\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires.tv64 < expires_next.tv64)\n\t\t\texpires_next = expires;\n\t}\n\t\n\tif (expires_next.tv64 < 0)\n\t\texpires_next.tv64 = 0;\n\treturn expires_next;\n}\n#endif\n\n\n#ifdef config_high_res_timers\n\n\nstatic int hrtimer_hres_enabled __read_mostly  = 1;\n\n\nstatic int __init setup_hrtimer_hres(char *str)\n{\n\tif (!strcmp(str, \"": 1004, "\",\n\t.dev_groups\t= pmu_dev_groups,\n};\n\nstatic void pmu_dev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int pmu_dev_alloc(struct pmu *pmu)\n{\n\tint ret = -enomem;\n\n\tpmu->dev = kzalloc(sizeof(struct device), gfp_kernel);\n\tif (!pmu->dev)\n\t\tgoto out;\n\n\tpmu->dev->groups = pmu->attr_groups;\n\tdevice_initialize(pmu->dev);\n\tret = dev_set_name(pmu->dev, \"": 1005, "\",\n\t.dev_name = \"": 1006, "\",\n\t.func\t\t\t= ftrace_mod_callback,\n};\n\nstatic int __init ftrace_mod_cmd_init(void)\n{\n\treturn register_ftrace_command(&ftrace_mod_cmd);\n}\ncore_initcall(ftrace_mod_cmd_init);\n\nstatic void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t      struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct ftrace_func_probe *entry;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, ftrace_hash_bits);\n\n\thhd = &ftrace_func_hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn;\n\n\t\n\tpreempt_disable_notrace();\n\thlist_for_each_entry_rcu_notrace(entry, hhd, node) {\n\t\tif (entry->ip == ip)\n\t\t\tentry->ops->func(ip, parent_ip, &entry->data);\n\t}\n\tpreempt_enable_notrace();\n}\n\nstatic struct ftrace_ops trace_probe_ops __read_mostly =\n{\n\t.func\t\t= function_trace_probe_call,\n\t.flags\t\t= ftrace_ops_fl_initialized,\n\tinit_ops_hash(trace_probe_ops)\n};\n\nstatic int ftrace_probe_registered;\n\nstatic void __enable_ftrace_function_probe(struct ftrace_ops_hash *old_hash)\n{\n\tint ret;\n\tint i;\n\n\tif (ftrace_probe_registered) {\n\t\t\n\t\tif (ftrace_enabled)\n\t\t\tftrace_run_modify_code(&trace_probe_ops, ftrace_update_calls,\n\t\t\t\t\t       old_hash);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ftrace_func_hashsize; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\t\tif (hhd->first)\n\t\t\tbreak;\n\t}\n\t\n\tif (i == ftrace_func_hashsize)\n\t\treturn;\n\n\tret = ftrace_startup(&trace_probe_ops, 0);\n\n\tftrace_probe_registered = 1;\n}\n\nstatic void __disable_ftrace_function_probe(void)\n{\n\tint i;\n\n\tif (!ftrace_probe_registered)\n\t\treturn;\n\n\tfor (i = 0; i < ftrace_func_hashsize; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\t\tif (hhd->first)\n\t\t\treturn;\n\t}\n\n\t\n\tftrace_shutdown(&trace_probe_ops, 0);\n\n\tftrace_probe_registered = 0;\n}\n\n\nstatic void ftrace_free_entry(struct ftrace_func_probe *entry)\n{\n\tif (entry->ops->free)\n\t\tentry->ops->free(entry->ops, entry->ip, &entry->data);\n\tkfree(entry);\n}\n\nint\nregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,\n\t\t\t      void *data)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_probe *entry;\n\tstruct ftrace_hash **orig_hash = &trace_probe_ops.func_hash->filter_hash;\n\tstruct ftrace_hash *old_hash = *orig_hash;\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tint type, len, not;\n\tunsigned long key;\n\tint count = 0;\n\tchar *search;\n\tint ret;\n\n\ttype = filter_parse_regex(glob, strlen(glob), &search, &not);\n\tlen = strlen(search);\n\n\t\n\tif (warn_on(not))\n\t\treturn -einval;\n\n\tmutex_lock(&trace_probe_ops.func_hash->regex_lock);\n\n\told_hash_ops.filter_hash = old_hash;\n\t\n\told_hash_ops.notrace_hash = null;\n\n\thash = alloc_and_copy_ftrace_hash(ftrace_hash_default_bits, old_hash);\n\tif (!hash) {\n\t\tcount = -enomem;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tcount = -enodev;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (!ftrace_match_record(rec, null, search, len, type))\n\t\t\tcontinue;\n\n\t\tentry = kmalloc(sizeof(*entry), gfp_kernel);\n\t\tif (!entry) {\n\t\t\t\n\t\t\tif (!count)\n\t\t\t\tcount = -enomem;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tcount++;\n\n\t\tentry->data = data;\n\n\t\t\n\t\tif (ops->init) {\n\t\t\tif (ops->init(ops, rec->ip, &entry->data) < 0) {\n\t\t\t\t\n\t\t\t\tkfree(entry);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = enter_record(hash, rec, 0);\n\t\tif (ret < 0) {\n\t\t\tkfree(entry);\n\t\t\tcount = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tentry->ops = ops;\n\t\tentry->ip = rec->ip;\n\n\t\tkey = hash_long(entry->ip, ftrace_hash_bits);\n\t\thlist_add_head_rcu(&entry->node, &ftrace_func_hash[key]);\n\n\t} while_for_each_ftrace_rec();\n\n\tret = ftrace_hash_move(&trace_probe_ops, 1, orig_hash, hash);\n\n\t__enable_ftrace_function_probe(&old_hash_ops);\n\n\tif (!ret)\n\t\tfree_ftrace_hash_rcu(old_hash);\n\telse\n\t\tcount = ret;\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n out:\n\tmutex_unlock(&trace_probe_ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\treturn count;\n}\n\nenum {\n\tprobe_test_func\t\t= 1,\n\tprobe_test_data\t\t= 2\n};\n\nstatic void\n__unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,\n\t\t\t\t  void *data, int flags)\n{\n\tstruct ftrace_func_entry *rec_entry;\n\tstruct ftrace_func_probe *entry;\n\tstruct ftrace_func_probe *p;\n\tstruct ftrace_hash **orig_hash = &trace_probe_ops.func_hash->filter_hash;\n\tstruct ftrace_hash *old_hash = *orig_hash;\n\tstruct list_head free_list;\n\tstruct ftrace_hash *hash;\n\tstruct hlist_node *tmp;\n\tchar str[ksym_symbol_len];\n\tint type = match_full;\n\tint i, len = 0;\n\tchar *search;\n\tint ret;\n\n\tif (glob && (strcmp(glob, \"": 1007, "\",\n\t.func\t\t\t= ftrace_trace_snapshot_callback,\n};\n\nstatic __init int register_snapshot_cmd(void)\n{\n\treturn register_ftrace_command(&ftrace_snapshot_cmd);\n}\n#else\nstatic inline __init int register_snapshot_cmd(void) { return 0; }\n#endif \n\nstatic struct dentry *tracing_get_dentry(struct trace_array *tr)\n{\n\tif (warn_on(!tr->dir))\n\t\treturn err_ptr(-enodev);\n\n\t\n\tif (tr->flags & trace_array_fl_global)\n\t\treturn null;\n\n\t\n\treturn tr->dir;\n}\n\nstatic struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)\n{\n\tstruct dentry *d_tracer;\n\n\tif (tr->percpu_dir)\n\t\treturn tr->percpu_dir;\n\n\td_tracer = tracing_get_dentry(tr);\n\tif (is_err(d_tracer))\n\t\treturn null;\n\n\ttr->percpu_dir = tracefs_create_dir(\"": 1008, "\",\n\t.init\t\t= nop_trace_init,\n\t.reset\t\t= nop_trace_reset,\n#ifdef config_ftrace_selftest\n\t.selftest\t= trace_selftest_startup_nop,\n#endif\n\t.flags\t\t= &nop_flags,\n\t.set_flag\t= nop_set_flag,\n\t.allow_instances = true,\n};\n\n#ifdef config_rwsem_spin_on_owner\nstatic inline void rwsem_set_owner(struct rw_semaphore *sem)\n{\n\tsem->owner = current;\n}\n\nstatic inline void rwsem_clear_owner(struct rw_semaphore *sem)\n{\n\tsem->owner = null;\n}\n\n#else\nstatic inline void rwsem_set_owner(struct rw_semaphore *sem)\n{\n}\n\nstatic inline void rwsem_clear_owner(struct rw_semaphore *sem)\n{\n}\n#endif\n\n\n#include <linux/device.h>\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/sched.h> \n#include <linux/tick.h>\n#include <linux/kthread.h>\n\n#include \"": 1009, "\",\n \"": 1010, "\",\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n};\n\nstatic const int __nenv = array_size(__env);\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_tif_mca_init\n\tif ((task_thread_info(p)->flags & _tif_mca_init) && kdb_tsk(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}\n\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t\n\tpermissions &= kdb_enable_mask;\n\tpermissions |= kdb_enable_always_safe;\n\n\t\n\tif (no_args)\n\t\tpermissions |= permissions << kdb_enable_no_args_shift;\n\n\tflags |= kdb_enable_all;\n\n\treturn permissions & flags;\n}\n\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"": 1011, "\",\n#elif defined(config_preempt)\n\t\t   \"": 1012, "\",\n#elif defined(config_preempt_voluntary)\n\t\t   \"": 1013, "\",\n#else\n\t\t   \"": 1014, "\",\n#else\n \"": 1015, "\",\n#endif\n\t\t   \n\t\t   0, 0, 0, 0);\n#ifdef config_smp\n\tseq_printf(m, \"": 1016, "\",\n#endif\n \"": 1017, "\",\n};\n\nstatic struct device device_clocksource = {\n\t.id\t= 0,\n\t.bus\t= &clocksource_subsys,\n};\n\nstatic int __init init_clocksource_sysfs(void)\n{\n\tint error = subsys_system_register(&clocksource_subsys, null);\n\n\tif (!error)\n\t\terror = device_register(&device_clocksource);\n\tif (!error)\n\t\terror = device_create_file(\n\t\t\t\t&device_clocksource,\n\t\t\t\t&dev_attr_current_clocksource);\n\tif (!error)\n\t\terror = device_create_file(&device_clocksource,\n\t\t\t\t\t   &dev_attr_unbind_clocksource);\n\tif (!error)\n\t\terror = device_create_file(\n\t\t\t\t&device_clocksource,\n\t\t\t\t&dev_attr_available_clocksource);\n\treturn error;\n}\n\ndevice_initcall(init_clocksource_sysfs);\n#endif \n\n\nstatic int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}\n\n__setup(\"": 1018, "\", \"": 1019, "\", %s\"": 1020, "\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"": 1021, "\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"": 1022, "\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"": 1023, "\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t\n\n\t\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t\n\t\tcp++;\t \t     \n\t\treplaced_byte = *cp; \n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     \n\n\t\t\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= kdb_grepping_flag_search)\n\t\t\t\n\t\t\tkdb_grepping_flag = 0;\n\t\t\n\t}\nkdb_printit:\n\n\t\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_level(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = console_loglevel_silent;\n\t\tif (printk_get_level(kdb_buffer) || src == kdb_msgsrc_printk)\n\t\t\tprintk(\"": 1024, "\", &perf_fops, event,\n\t\t\t\t\tf_flags);\n\tif (is_err(event_file)) {\n\t\terr = ptr_err(event_file);\n\t\tgoto err_context;\n\t}\n\n\tif (move_group) {\n\t\tgctx = group_leader->ctx;\n\n\t\t\n\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\n\t\tperf_remove_from_context(group_leader, false);\n\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_remove_from_context(sibling, false);\n\t\t\tput_ctx(gctx);\n\t\t}\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t}\n\n\twarn_on_once(ctx->parent_ctx);\n\n\tif (move_group) {\n\t\t\n\t\tsynchronize_rcu();\n\n\t\t\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_event__state_init(sibling);\n\t\t\tperf_install_in_context(ctx, sibling, sibling->cpu);\n\t\t\tget_ctx(ctx);\n\t\t}\n\n\t\t\n\t\tperf_event__state_init(group_leader);\n\t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n\t\tget_ctx(ctx);\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -ebusy;\n\t\tmutex_unlock(&ctx->mutex);\n\t\tfput(event_file);\n\t\tgoto err_context;\n\t}\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\n\tif (move_group) {\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t}\n\tmutex_unlock(&ctx->mutex);\n\n\tput_online_cpus();\n\n\tevent->owner = current;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_add_tail(&event->owner_entry, &current->perf_event_list);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\t\n\tperf_event__header_size(event);\n\tperf_event__id_header_size(event);\n\n\t\n\tfdput(group);\n\tfd_install(event_fd, event_file);\n\treturn event_fd;\n\nerr_context:\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_alloc:\n\tfree_event(event);\nerr_cpus:\n\tput_online_cpus();\nerr_task:\n\tif (task)\n\t\tput_task_struct(task);\nerr_group_fd:\n\tfdput(group);\nerr_fd:\n\tput_unused_fd(event_fd);\n\treturn err;\n}\n\n\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t\n\n\tevent = perf_event_alloc(attr, cpu, task, null, null,\n\t\t\t\t overflow_handler, context, -1);\n\tif (is_err(event)) {\n\t\terr = ptr_err(event);\n\t\tgoto err;\n\t}\n\n\t\n\tevent->owner = event_owner_kernel;\n\n\taccount_event(event);\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (is_err(ctx)) {\n\t\terr = ptr_err(ctx);\n\t\tgoto err_free;\n\t}\n\n\twarn_on_once(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tperf_unpin_context(ctx);\n\t\tput_ctx(ctx);\n\t\terr = -ebusy;\n\t\tgoto err_free;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_free:\n\tfree_event(event);\nerr:\n\treturn err_ptr(err);\n}\nexport_symbol_gpl(perf_event_create_kernel_counter);\n\nvoid perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n{\n\tstruct perf_event_context *src_ctx;\n\tstruct perf_event_context *dst_ctx;\n\tstruct perf_event *event, *tmp;\n\tlist_head(events);\n\n\tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n\tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n\n\t\n\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n\t\t\t\t event_entry) {\n\t\tperf_remove_from_context(event, false);\n\t\tunaccount_event_cpu(event, src_cpu);\n\t\tput_ctx(src_ctx);\n\t\tlist_add(&event->migrate_entry, &events);\n\t}\n\n\t\n\tsynchronize_rcu();\n\n\t\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tif (event->group_leader == event)\n\t\t\tcontinue;\n\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= perf_event_state_off)\n\t\t\tevent->state = perf_event_state_inactive;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\n\t\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= perf_event_state_off)\n\t\t\tevent->state = perf_event_state_inactive;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\tmutex_unlock(&dst_ctx->mutex);\n\tmutex_unlock(&src_ctx->mutex);\n}\nexport_symbol_gpl(perf_pmu_migrate_context);\n\nstatic void sync_child_event(struct perf_event *child_event,\n\t\t\t       struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\tu64 child_val;\n\n\tif (child_event->attr.inherit_stat)\n\t\tperf_event_read_event(child_event, child);\n\n\tchild_val = perf_event_count(child_event);\n\n\t\n\tatomic64_add(child_val, &parent_event->child_count);\n\tatomic64_add(child_event->total_time_enabled,\n\t\t     &parent_event->child_total_time_enabled);\n\tatomic64_add(child_event->total_time_running,\n\t\t     &parent_event->child_total_time_running);\n\n\t\n\twarn_on_once(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_del_init(&child_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\t\n\tperf_event_wakeup(parent_event);\n\n\t\n\tput_event(parent_event);\n}\n\nstatic void\n__perf_event_exit_task(struct perf_event *child_event,\n\t\t\t struct perf_event_context *child_ctx,\n\t\t\t struct task_struct *child)\n{\n\t\n\tperf_remove_from_context(child_event, !!child_event->parent);\n\n\t\n\tif (child_event->parent) {\n\t\tsync_child_event(child_event, child);\n\t\tfree_event(child_event);\n\t} else {\n\t\tchild_event->state = perf_event_state_exit;\n\t\tperf_event_wakeup(child_event);\n\t}\n}\n\nstatic void perf_event_exit_task_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event *child_event, *next;\n\tstruct perf_event_context *child_ctx, *clone_ctx = null;\n\tunsigned long flags;\n\n\tif (likely(!child->perf_event_ctxp[ctxn])) {\n\t\tperf_event_task(child, null, 0);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\t\n\tchild_ctx = rcu_dereference_raw(child->perf_event_ctxp[ctxn]);\n\n\t\n\traw_spin_lock(&child_ctx->lock);\n\ttask_ctx_sched_out(child_ctx);\n\tchild->perf_event_ctxp[ctxn] = null;\n\n\t\n\tclone_ctx = unclone_ctx(child_ctx);\n\tupdate_context_time(child_ctx);\n\traw_spin_unlock_irqrestore(&child_ctx->lock, flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n\n\t\n\tperf_event_task(child, child_ctx, 0);\n\n\t\n\tmutex_lock(&child_ctx->mutex);\n\n\tlist_for_each_entry_safe(child_event, next, &child_ctx->event_list, event_entry)\n\t\t__perf_event_exit_task(child_event, child_ctx, child);\n\n\tmutex_unlock(&child_ctx->mutex);\n\n\tput_ctx(child_ctx);\n}\n\n\nvoid perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t\n\t\tsmp_wmb();\n\t\tevent->owner = null;\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n}\n\nstatic void perf_free_event(struct perf_event *event,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tstruct perf_event *parent = event->parent;\n\n\tif (warn_on_once(!parent))\n\t\treturn;\n\n\tmutex_lock(&parent->child_mutex);\n\tlist_del_init(&event->child_list);\n\tmutex_unlock(&parent->child_mutex);\n\n\tput_event(parent);\n\n\traw_spin_lock_irq(&ctx->lock);\n\tperf_group_detach(event);\n\tlist_del_event(event, ctx);\n\traw_spin_unlock_irq(&ctx->lock);\n\tfree_event(event);\n}\n\n\nvoid perf_event_free_task(struct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ctx->mutex);\nagain:\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->pinned_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->flexible_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tif (!list_empty(&ctx->pinned_groups) ||\n\t\t\t\t!list_empty(&ctx->flexible_groups))\n\t\t\tgoto again;\n\n\t\tmutex_unlock(&ctx->mutex);\n\n\t\tput_ctx(ctx);\n\t}\n}\n\nvoid perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\twarn_on_once(task->perf_event_ctxp[ctxn]);\n}\n\n\nstatic struct perf_event *\ninherit_event(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event *group_leader,\n\t      struct perf_event_context *child_ctx)\n{\n\tenum perf_event_active_state parent_state = parent_event->state;\n\tstruct perf_event *child_event;\n\tunsigned long flags;\n\n\t\n\tif (parent_event->parent)\n\t\tparent_event = parent_event->parent;\n\n\tchild_event = perf_event_alloc(&parent_event->attr,\n\t\t\t\t\t   parent_event->cpu,\n\t\t\t\t\t   child,\n\t\t\t\t\t   group_leader, parent_event,\n\t\t\t\t\t   null, null, -1);\n\tif (is_err(child_event))\n\t\treturn child_event;\n\n\tif (is_orphaned_event(parent_event) ||\n\t    !atomic_long_inc_not_zero(&parent_event->refcount)) {\n\t\tfree_event(child_event);\n\t\treturn null;\n\t}\n\n\tget_ctx(child_ctx);\n\n\t\n\tif (parent_state >= perf_event_state_inactive)\n\t\tchild_event->state = perf_event_state_inactive;\n\telse\n\t\tchild_event->state = perf_event_state_off;\n\n\tif (parent_event->attr.freq) {\n\t\tu64 sample_period = parent_event->hw.sample_period;\n\t\tstruct hw_perf_event *hwc = &child_event->hw;\n\n\t\thwc->sample_period = sample_period;\n\t\thwc->last_period   = sample_period;\n\n\t\tlocal64_set(&hwc->period_left, sample_period);\n\t}\n\n\tchild_event->ctx = child_ctx;\n\tchild_event->overflow_handler = parent_event->overflow_handler;\n\tchild_event->overflow_handler_context\n\t\t= parent_event->overflow_handler_context;\n\n\t\n\tperf_event__header_size(child_event);\n\tperf_event__id_header_size(child_event);\n\n\t\n\traw_spin_lock_irqsave(&child_ctx->lock, flags);\n\tadd_event_to_ctx(child_event, child_ctx);\n\traw_spin_unlock_irqrestore(&child_ctx->lock, flags);\n\n\t\n\twarn_on_once(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_add_tail(&child_event->child_list, &parent_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\treturn child_event;\n}\n\nstatic int inherit_group(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event_context *child_ctx)\n{\n\tstruct perf_event *leader;\n\tstruct perf_event *sub;\n\tstruct perf_event *child_ctr;\n\n\tleader = inherit_event(parent_event, parent, parent_ctx,\n\t\t\t\t child, null, child_ctx);\n\tif (is_err(leader))\n\t\treturn ptr_err(leader);\n\tlist_for_each_entry(sub, &parent_event->sibling_list, group_entry) {\n\t\tchild_ctr = inherit_event(sub, parent, parent_ctx,\n\t\t\t\t\t    child, leader, child_ctx);\n\t\tif (is_err(child_ctr))\n\t\t\treturn ptr_err(child_ctr);\n\t}\n\treturn 0;\n}\n\nstatic int\ninherit_task_group(struct perf_event *event, struct task_struct *parent,\n\t\t   struct perf_event_context *parent_ctx,\n\t\t   struct task_struct *child, int ctxn,\n\t\t   int *inherited_all)\n{\n\tint ret;\n\tstruct perf_event_context *child_ctx;\n\n\tif (!event->attr.inherit) {\n\t\t*inherited_all = 0;\n\t\treturn 0;\n\t}\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\tif (!child_ctx) {\n\t\t\n\n\t\tchild_ctx = alloc_perf_context(parent_ctx->pmu, child);\n\t\tif (!child_ctx)\n\t\t\treturn -enomem;\n\n\t\tchild->perf_event_ctxp[ctxn] = child_ctx;\n\t}\n\n\tret = inherit_group(event, parent, parent_ctx,\n\t\t\t    child, child_ctx);\n\n\tif (ret)\n\t\t*inherited_all = 0;\n\n\treturn ret;\n}\n\n\nstatic int perf_event_init_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event_context *child_ctx, *parent_ctx;\n\tstruct perf_event_context *cloned_ctx;\n\tstruct perf_event *event;\n\tstruct task_struct *parent = current;\n\tint inherited_all = 1;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (likely(!parent->perf_event_ctxp[ctxn]))\n\t\treturn 0;\n\n\t\n\tparent_ctx = perf_pin_task_context(parent, ctxn);\n\tif (!parent_ctx)\n\t\treturn 0;\n\n\t\n\n\t\n\tmutex_lock(&parent_ctx->mutex);\n\n\t\n\tlist_for_each_entry(event, &parent_ctx->pinned_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 1;\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\n\tlist_for_each_entry(event, &parent_ctx->flexible_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 0;\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\n\tif (child_ctx && inherited_all) {\n\t\t\n\t\tcloned_ctx = parent_ctx->parent_ctx;\n\t\tif (cloned_ctx) {\n\t\t\tchild_ctx->parent_ctx = cloned_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->parent_gen;\n\t\t} else {\n\t\t\tchild_ctx->parent_ctx = parent_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->generation;\n\t\t}\n\t\tget_ctx(child_ctx->parent_ctx);\n\t}\n\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\tmutex_unlock(&parent_ctx->mutex);\n\n\tperf_unpin_context(parent_ctx);\n\tput_ctx(parent_ctx);\n\n\treturn ret;\n}\n\n\nint perf_event_init_task(struct task_struct *child)\n{\n\tint ctxn, ret;\n\n\tmemset(child->perf_event_ctxp, 0, sizeof(child->perf_event_ctxp));\n\tmutex_init(&child->perf_event_mutex);\n\tinit_list_head(&child->perf_event_list);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tret = perf_event_init_context(child, ctxn);\n\t\tif (ret) {\n\t\t\tperf_event_free_task(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __init perf_event_init_all_cpus(void)\n{\n\tstruct swevent_htable *swhash;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tswhash = &per_cpu(swevent_htable, cpu);\n\t\tmutex_init(&swhash->hlist_mutex);\n\t\tinit_list_head(&per_cpu(active_ctx_list, cpu));\n\t}\n}\n\nstatic void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), gfp_kernel, cpu_to_node(cpu));\n\t\twarn_on(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n\n#if defined config_hotplug_cpu || defined config_kexec\nstatic void __perf_event_exit_context(void *__info)\n{\n\tstruct remove_event re = { .detach_group = true };\n\tstruct perf_event_context *ctx = __info;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(re.event, &ctx->event_list, event_entry)\n\t\t__perf_remove_from_context(&re);\n\trcu_read_unlock();\n}\n\nstatic void perf_event_exit_cpu_context(int cpu)\n{\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint idx;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tctx = &per_cpu_ptr(pmu->pmu_cpu_context, cpu)->ctx;\n\n\t\tmutex_lock(&ctx->mutex);\n\t\tsmp_call_function_single(cpu, __perf_event_exit_context, ctx, 1);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tsrcu_read_unlock(&pmus_srcu, idx);\n}\n\nstatic void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tperf_event_exit_cpu_context(cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n#else\nstatic inline void perf_event_exit_cpu(int cpu) { }\n#endif\n\nstatic int\nperf_reboot(struct notifier_block *notifier, unsigned long val, void *v)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tperf_event_exit_cpu(cpu);\n\n\treturn notify_ok;\n}\n\n\nstatic struct notifier_block perf_reboot_notifier = {\n\t.notifier_call = perf_reboot,\n\t.priority = int_min,\n};\n\nstatic int\nperf_cpu_notify(struct notifier_block *self, unsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (long)hcpu;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\n\tcase cpu_up_prepare:\n\tcase cpu_down_failed:\n\t\tperf_event_init_cpu(cpu);\n\t\tbreak;\n\n\tcase cpu_up_canceled:\n\tcase cpu_down_prepare:\n\t\tperf_event_exit_cpu(cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notify_ok;\n}\n\nvoid __init perf_event_init(void)\n{\n\tint ret;\n\n\tidr_init(&pmu_idr);\n\n\tperf_event_init_all_cpus();\n\tinit_srcu_struct(&pmus_srcu);\n\tperf_pmu_register(&perf_swevent, \"": 1025, "\", ((unsigned long)(rec->%s))\"": 1026, "\", (chip && chip->name) ? chip->name : \"": 1027, "\", (desc->action && desc->action->handler) ? '*' : ' ');\n\t\t\tdirect = (i == hwirq) && (i < domain->revmap_direct_max_irq);\n\t\t\tseq_printf(m, \"": 1028, "\", (int)(2 * sizeof(void *) + 2), \"": 1029, "\", (unsigned long long)now);\n\tseq_printf(m, \"": 1030, "\", (unsigned long)ts);\n\n\treturn sprintf(buf, \"": 1031, "\", (void *)*ptr);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations ftrace_graph_seq_ops = {\n\t.start = g_start,\n\t.next = g_next,\n\t.stop = g_stop,\n\t.show = g_show,\n};\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\n\tmutex_lock(&graph_lock);\n\tif ((file->f_mode & fmode_write) &&\n\t    (file->f_flags & o_trunc)) {\n\t\t*fgd->count = 0;\n\t\tmemset(fgd->table, 0, fgd->size * sizeof(*fgd->table));\n\t}\n\tmutex_unlock(&graph_lock);\n\n\tif (file->f_mode & fmode_read) {\n\t\tret = seq_open(file, fgd->seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\n\treturn ret;\n}\n\nstatic int\nftrace_graph_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\tfgd = kmalloc(sizeof(*fgd), gfp_kernel);\n\tif (fgd == null)\n\t\treturn -enomem;\n\n\tfgd->table = ftrace_graph_funcs;\n\tfgd->size = ftrace_graph_max_funcs;\n\tfgd->count = &ftrace_graph_count;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\treturn __ftrace_graph_open(inode, file, fgd);\n}\n\nstatic int\nftrace_graph_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\tfgd = kmalloc(sizeof(*fgd), gfp_kernel);\n\tif (fgd == null)\n\t\treturn -enomem;\n\n\tfgd->table = ftrace_graph_notrace_funcs;\n\tfgd->size = ftrace_graph_max_funcs;\n\tfgd->count = &ftrace_graph_notrace_count;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\treturn __ftrace_graph_open(inode, file, fgd);\n}\n\nstatic int\nftrace_graph_release(struct inode *inode, struct file *file)\n{\n\tif (file->f_mode & fmode_read) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tkfree(m->private);\n\t\tseq_release(inode, file);\n\t} else {\n\t\tkfree(file->private_data);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nftrace_set_func(unsigned long *array, int *idx, int size, char *buffer)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tint search_len;\n\tint fail = 1;\n\tint type, not;\n\tchar *search;\n\tbool exists;\n\tint i;\n\n\t\n\ttype = filter_parse_regex(buffer, strlen(buffer), &search, &not);\n\tif (!not && *idx >= size)\n\t\treturn -ebusy;\n\n\tsearch_len = strlen(search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -enodev;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (ftrace_match_record(rec, null, search, search_len, type)) {\n\t\t\t\n\t\t\texists = false;\n\t\t\tfor (i = 0; i < *idx; i++) {\n\t\t\t\tif (array[i] == rec->ip) {\n\t\t\t\t\texists = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\t\t\t\tif (!exists) {\n\t\t\t\t\tarray[(*idx)++] = rec->ip;\n\t\t\t\t\tif (*idx >= size)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (exists) {\n\t\t\t\t\tarray[i] = array[--(*idx)];\n\t\t\t\t\tarray[*idx] = 0;\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -einval;\n\n\treturn 0;\n}\n\nstatic ssize_t\nftrace_graph_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct trace_parser parser;\n\tssize_t read, ret = 0;\n\tstruct ftrace_graph_data *fgd = file->private_data;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (trace_parser_get_init(&parser, ftrace_buff_max))\n\t\treturn -enomem;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded((&parser))) {\n\t\tparser.buffer[parser.idx] = 0;\n\n\t\tmutex_lock(&graph_lock);\n\n\t\t\n\t\tret = ftrace_set_func(fgd->table, fgd->count, fgd->size,\n\t\t\t\t      parser.buffer);\n\n\t\tmutex_unlock(&graph_lock);\n\t}\n\n\tif (!ret)\n\t\tret = read;\n\n\ttrace_parser_put(&parser);\n\n\treturn ret;\n}\n\nstatic const struct file_operations ftrace_graph_fops = {\n\t.open\t\t= ftrace_graph_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= ftrace_graph_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_graph_release,\n};\n\nstatic const struct file_operations ftrace_graph_notrace_fops = {\n\t.open\t\t= ftrace_graph_notrace_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= ftrace_graph_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_graph_release,\n};\n#endif \n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"": 1032, "\", (void *)addr);\n\telse\n\t\tseq_printf(m, \"": 1033, "\", (void *)ip);\n\n\tseq_puts(m, \"": 1034, "\", (void *)rec->ip);\n\tif (iter->flags & ftrace_iter_enabled) {\n\t\tstruct ftrace_ops *ops = null;\n\n\t\tseq_printf(m, \"": 1035, "\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: \n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"": 1036, "\", *p);\n\n\tr += ftrace_arch_read_dyn_info(buf+r, (size-1)-r);\n\tbuf[r++] = '\\n';\n\n\tr = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n\n\tmutex_unlock(&dyn_info_mutex);\n\n\treturn r;\n}\n\nstatic const struct file_operations tracing_dyn_info_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_read_dyn_info,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif \n\n#if defined(config_tracer_snapshot) && defined(config_dynamic_ftrace)\nstatic void\nftrace_snapshot(unsigned long ip, unsigned long parent_ip, void **data)\n{\n\ttracing_snapshot();\n}\n\nstatic void\nftrace_count_snapshot(unsigned long ip, unsigned long parent_ip, void **data)\n{\n\tunsigned long *count = (long *)data;\n\n\tif (!*count)\n\t\treturn;\n\n\tif (*count != -1)\n\t\t(*count)--;\n\n\ttracing_snapshot();\n}\n\nstatic int\nftrace_snapshot_print(struct seq_file *m, unsigned long ip,\n\t\t      struct ftrace_probe_ops *ops, void *data)\n{\n\tlong count = (long)data;\n\n\tseq_printf(m, \"": 1037, "\", *pid, buf);\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_saved_cmdlines_seq_ops = {\n\t.start\t\t= saved_cmdlines_start,\n\t.next\t\t= saved_cmdlines_next,\n\t.stop\t\t= saved_cmdlines_stop,\n\t.show\t\t= saved_cmdlines_show,\n};\n\nstatic int tracing_saved_cmdlines_open(struct inode *inode, struct file *filp)\n{\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\treturn seq_open(filp, &tracing_saved_cmdlines_seq_ops);\n}\n\nstatic const struct file_operations tracing_saved_cmdlines_fops = {\n\t.open\t\t= tracing_saved_cmdlines_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic ssize_t\ntracing_saved_cmdlines_size_read(struct file *filp, char __user *ubuf,\n\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint r;\n\n\tarch_spin_lock(&trace_cmdline_lock);\n\tr = scnprintf(buf, sizeof(buf), \"": 1038, "\", -diag);\n}\n\n\nstruct defcmd_set {\n\tint count;\n\tint usable;\n\tchar *name;\n\tchar *usage;\n\tchar *help;\n\tchar **command;\n};\nstatic struct defcmd_set *defcmd_set;\nstatic int defcmd_set_count;\nstatic int defcmd_in_progress;\n\n\nstatic int kdb_exec_defcmd(int argc, const char **argv);\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"": 1039, "\", 0200, d_tracer,\n\t\t\t  tr, &tracing_free_buffer_fops);\n\n\ttrace_create_file(\"": 1040, "\", 0220, d_tracer,\n\t\t\t  tr, &tracing_mark_fops);\n\n\ttrace_create_file(\"": 1041, "\", 0444,\n\t\t\td_tracer, null, &ftrace_avail_fops);\n\n\ttrace_create_file(\"": 1042, "\", 0444,\n\t\t\td_tracer, null, &ftrace_enabled_fops);\n\n\tftrace_create_filter_files(&global_ops, d_tracer);\n\n#ifdef config_function_graph_tracer\n\ttrace_create_file(\"": 1043, "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &snapshot_raw_fops);\n#endif\n}\n\n#ifdef config_ftrace_selftest\n\n#include \"": 1044, "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_buffers_fops);\n\n\ttrace_create_cpu_file(\"": 1045, "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_entries_fops);\n\n#ifdef config_tracer_snapshot\n\ttrace_create_cpu_file(\"": 1046, "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_pipe_fops);\n\n\t\n\ttrace_create_cpu_file(\"": 1047, "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_stats_fops);\n\n\ttrace_create_cpu_file(\"": 1048, "\", 0444, d_tracer,\n\t\t\t\t    null,\n\t\t\t\t    &ftrace_graph_fops);\n\ttrace_create_file(\"": 1049, "\", 0444, d_tracer,\n\t\t\t\t    null,\n\t\t\t\t    &ftrace_graph_notrace_fops);\n#endif \n\n\treturn 0;\n}\n\nstatic int ftrace_cmp_ips(const void *a, const void *b)\n{\n\tconst unsigned long *ipa = a;\n\tconst unsigned long *ipb = b;\n\n\tif (*ipa > *ipb)\n\t\treturn 1;\n\tif (*ipa < *ipb)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void ftrace_swap_ips(void *a, void *b, int size)\n{\n\tunsigned long *ipa = a;\n\tunsigned long *ipb = b;\n\tunsigned long t;\n\n\tt = *ipa;\n\t*ipa = *ipb;\n\t*ipb = t;\n}\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; \n\tint ret = -enomem;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, ftrace_swap_ips);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -enomem;\n\n\tmutex_lock(&ftrace_lock);\n\n\t\n\tif (!mod) {\n\t\twarn_on(ftrace_pages || ftrace_pages_start);\n\t\t\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (warn_on(ftrace_pages->next)) {\n\t\t\t\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t\n\t\t\tif (warn_on(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t\n\twarn_on(pg->next);\n\n\t\n\tftrace_pages = pg;\n\n\t\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}\n\n#ifdef config_modules\n\n#define next_to_ftrace_page(p) container_of(p, struct ftrace_page, next)\n\nvoid ftrace_release_mod(struct module *mod)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\t\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module_core(rec->ip, mod)) {\n\t\t\t\n\t\t\tif (warn_on(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\t*last_pg = pg->next;\n\t\t\torder = get_count_order(pg->size / entries_per_page);\n\t\t\tfree_pages((unsigned long)pg->records, order);\n\t\t\tkfree(pg);\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n}\n\nstatic void ftrace_init_module(struct module *mod,\n\t\t\t       unsigned long *start, unsigned long *end)\n{\n\tif (ftrace_disabled || start == end)\n\t\treturn;\n\tftrace_process_locs(mod, start, end);\n}\n\nvoid ftrace_module_init(struct module *mod)\n{\n\tftrace_init_module(mod, mod->ftrace_callsites,\n\t\t\t   mod->ftrace_callsites +\n\t\t\t   mod->num_ftrace_callsites);\n}\n\nstatic int ftrace_module_notify_exit(struct notifier_block *self,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tif (val == module_state_going)\n\t\tftrace_release_mod(mod);\n\n\treturn 0;\n}\n#else\nstatic int ftrace_module_notify_exit(struct notifier_block *self,\n\t\t\t\t     unsigned long val, void *data)\n{\n\treturn 0;\n}\n#endif \n\nstruct notifier_block ftrace_module_exit_nb = {\n\t.notifier_call = ftrace_module_notify_exit,\n\t.priority = int_min,\t\n};\n\nvoid __init ftrace_init(void)\n{\n\textern unsigned long __start_mcount_loc[];\n\textern unsigned long __stop_mcount_loc[];\n\tunsigned long count, flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = ftrace_dyn_arch_init();\n\tlocal_irq_restore(flags);\n\tif (ret)\n\t\tgoto failed;\n\n\tcount = __stop_mcount_loc - __start_mcount_loc;\n\tif (!count) {\n\t\tpr_info(\"": 1050, "\", 0444, d_tracer,\n\t\t\t  null, &tracing_enum_map_fops);\n}\n\n#else \nstatic inline void trace_create_enum_file(struct dentry *d_tracer) { }\nstatic inline void trace_insert_enum_map_file(struct module *mod,\n\t\t\t      struct trace_enum_map **start, int len) { }\n#endif \n\nstatic void trace_insert_enum_map(struct module *mod,\n\t\t\t\t  struct trace_enum_map **start, int len)\n{\n\tstruct trace_enum_map **map;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tmap = start;\n\n\ttrace_event_enum_update(map, len);\n\n\ttrace_insert_enum_map_file(mod, start, len);\n}\n\nstatic ssize_t\ntracing_set_trace_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[max_tracer_size+2];\n\tint r;\n\n\tmutex_lock(&trace_types_lock);\n\tr = sprintf(buf, \"": 1051, "\", 0444, d_tracer,\n\t\t\t  tr, &tracing_pipe_fops);\n\n\ttrace_create_file(\"": 1052, "\", 0444, d_tracer,\n\t\t\t  tr, &tracing_total_entries_fops);\n\n\ttrace_create_file(\"": 1053, "\", 0444, d_tracer,\n\t\t\t&ftrace_update_tot_cnt, &tracing_dyn_info_fops);\n#endif\n\n\tcreate_trace_instances(d_tracer);\n\n\tcreate_trace_options_dir(&global_trace);\n\n\t\n\tif (global_trace.current_trace != &nop_trace)\n\t\tupdate_tracer_options(&global_trace, global_trace.current_trace);\n\n\treturn 0;\n}\n\nstatic int trace_panic_handler(struct notifier_block *this,\n\t\t\t       unsigned long event, void *unused)\n{\n\tif (ftrace_dump_on_oops)\n\t\tftrace_dump(ftrace_dump_on_oops);\n\treturn notify_ok;\n}\n\nstatic struct notifier_block trace_panic_notifier = {\n\t.notifier_call  = trace_panic_handler,\n\t.next           = null,\n\t.priority       = 150   \n};\n\nstatic int trace_die_handler(struct notifier_block *self,\n\t\t\t     unsigned long val,\n\t\t\t     void *data)\n{\n\tswitch (val) {\n\tcase die_oops:\n\t\tif (ftrace_dump_on_oops)\n\t\t\tftrace_dump(ftrace_dump_on_oops);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\nstatic struct notifier_block trace_die_notifier = {\n\t.notifier_call = trace_die_handler,\n\t.priority = 200\n};\n\n\n#define trace_max_print\t\t1000\n\n\n#define kern_trace\t\tkern_emerg\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t\n\tif (s->seq.len >= trace_max_print)\n\t\ts->seq.len = trace_max_print;\n\n\t\n\tif (warn_on_once(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(kern_trace \"": 1054, "\", 0444, d_tracer,\n\t\t\tnull, &tracing_readme_fops);\n\n\ttrace_create_file(\"": 1055, "\", 0444, d_tracer,\n\t\t\tnull, &tracing_saved_cmdlines_fops);\n\n\ttrace_create_file(\"": 1056, "\", 0444, d_tracer,\n\t\t\ttr, &show_traces_fops);\n\n\ttrace_create_file(\"": 1057, "\", 0444, null, &timer_list_fops);\n\tif (!pe)\n\t\treturn -enomem;\n\treturn 0;\n}\n__initcall(init_timer_list_procfs);\n\n\n#include <linux/console.h>\n#include <linux/vt_kern.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"": 1058, "\", 0444, rcudir,\n\t\t\t\t     null, &show_tiny_stats_fops);\n\tif (!retval)\n\t\tgoto free_out;\n\treturn 0;\nfree_out:\n\tdebugfs_remove_recursive(rcudir);\n\treturn 1;\n}\n\nstatic void __exit rcutiny_trace_cleanup(void)\n{\n\tdebugfs_remove_recursive(rcudir);\n}\n\nmodule_init(rcutiny_trace_init);\nmodule_exit(rcutiny_trace_cleanup);\n\nmodule_author(\"": 1059, "\", 0644, d_cpu,\n\t\t\t\ttr, cpu, &snapshot_fops);\n\n\ttrace_create_cpu_file(\"": 1060, "\", 0644, d_cpu,\n\t\t\t\ttr, cpu, &tracing_fops);\n\n\ttrace_create_cpu_file(\"": 1061, "\", 0644, d_tracer,\n\t\t\t  null, &tracing_saved_cmdlines_size_fops);\n\n\ttrace_enum_init();\n\n\ttrace_create_enum_file(d_tracer);\n\n#ifdef config_modules\n\tregister_module_notifier(&trace_module_nb);\n#endif\n\n#ifdef config_dynamic_ftrace\n\ttrace_create_file(\"": 1062, "\", 0644, d_tracer,\n\t\t\t  tr, &rb_simple_fops);\n\n#ifdef config_tracer_max_trace\n\ttrace_create_file(\"": 1063, "\", 0644, d_tracer,\n\t\t\t  tr, &snapshot_fops);\n#endif\n\n\tfor_each_tracing_cpu(cpu)\n\t\ttracing_init_tracefs_percpu(tr, cpu);\n\n}\n\nstatic struct vfsmount *trace_automount(void *ingore)\n{\n\tstruct vfsmount *mnt;\n\tstruct file_system_type *type;\n\n\t\n\ttype = get_fs_type(\"": 1064, "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_cpumask_fops);\n\n\ttrace_create_file(\"": 1065, "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_entries_fops);\n\n\ttrace_create_file(\"": 1066, "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_fops);\n\n\ttrace_create_file(\"": 1067, "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_iter_fops);\n\n\ttrace_create_file(\"": 1068, "\", 0644, d_tracer,\n\t\t\t&global_trace, &tracing_thresh_fops);\n\n\ttrace_create_file(\"": 1069, "\", 0644, d_tracer,\n\t\t\t&tr->max_latency, &tracing_max_lat_fops);\n#endif\n\n\tif (ftrace_create_function_files(tr, d_tracer))\n\t\twarn(1, \"": 1070, "\", 0644, d_tracer,\n\t\t\ttr, &set_tracer_fops);\n\n\ttrace_create_file(\"": 1071, "\", 0644, d_tracer, tr,\n\t\t\t  &trace_clock_fops);\n\n\ttrace_create_file(\"": 1072, "\", 0644, null, &tstats_fops);\n\tif (!pe)\n\t\treturn -enomem;\n\treturn 0;\n}\n__initcall(init_tstats_procfs);\n\n\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n\nstruct rcu_ctrlblk {\n\tstruct rcu_head *rcucblist;\t\n\tstruct rcu_head **donetail;\t\n\tstruct rcu_head **curtail;\t\n\trcu_trace(long qlen);\t\t\n\trcu_trace(unsigned long gp_start); \n\trcu_trace(unsigned long ticks_this_gp); \n\trcu_trace(unsigned long jiffies_stall); \n\trcu_trace(const char *name);\t\n};\n\n\nstatic struct rcu_ctrlblk rcu_sched_ctrlblk = {\n\t.donetail\t= &rcu_sched_ctrlblk.rcucblist,\n\t.curtail\t= &rcu_sched_ctrlblk.rcucblist,\n\trcu_trace(.name = \"": 1073, "\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"": 1074, "\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}\n\n\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & ftrace_ops_fl_enabled)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= ftrace_ops_fl_deleted;\n\tmutex_unlock(&ftrace_lock);\n}\n\nstatic __init int ftrace_init_dyn_tracefs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"": 1075, "\", 1);\n\tpm_states[pm_suspend_freeze] = pm_labels[relative_states ? 0 : 2];\n\treturn 1;\n}\n\n__setup(\"": 1076, "\", 2) == 0) {\n\t\tneg = 1;\n\t\tcmp += 2;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\tfor (i = 0; trace_options[i]; i++) {\n\t\tif (strcmp(cmp, trace_options[i]) == 0) {\n\t\t\tret = set_tracer_flag(tr, 1 << i, !neg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tif (!trace_options[i])\n\t\tret = set_tracer_option(tr, cmp, neg);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_trace_options_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tchar buf[64];\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -einval;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -efault;\n\n\tbuf[cnt] = 0;\n\n\tret = trace_set_options(tr, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic int tracing_trace_options_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tret = single_open(file, tracing_trace_options_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_iter_fops = {\n\t.open\t\t= tracing_trace_options_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n\t.write\t\t= tracing_trace_options_write,\n};\n\nstatic const char readme_msg[] =\n\t\"": 1077, "\", 4)) {\n\t\t*brl_options = \"": 1078, "\", 4)) {\n\t\t*brl_options = *str + 4;\n\t\t*str = strchr(*brl_options, ',');\n\t\tif (!*str)\n\t\t\tpr_err(\"": 1079, "\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"": 1080, "\", __func__);\n\t\n\t\n\ttfm = crypto_alloc_shash(hash_algo_name[hash], 0, 0);\n\tif (is_err(tfm))\n\t\treturn (ptr_err(tfm) == -enoent) ? err_ptr(-enopkg) : err_cast(tfm);\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdigest_size = crypto_shash_digestsize(tfm);\n\n\t\n\tret = -enomem;\n\tpks = kzalloc(digest_size + sizeof(*pks) + desc_size, gfp_kernel);\n\tif (!pks)\n\t\tgoto error_no_pks;\n\n\tpks->pkey_hash_algo\t= hash;\n\tpks->digest\t\t= (u8 *)pks + sizeof(*pks) + desc_size;\n\tpks->digest_size\t= digest_size;\n\n\tdesc = (void *)pks + sizeof(*pks);\n\tdesc->tfm   = tfm;\n\tdesc->flags = crypto_tfm_req_may_sleep;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = crypto_shash_finup(desc, mod, modlen, pks->digest);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tcrypto_free_shash(tfm);\n\tpr_devel(\"": 1081, "\", __get_str(%s)\"": 1082, "\", __log_buf_len);\n\n\tlog_buf_len_update(cpu_extra + __log_buf_len);\n}\n#else \nstatic inline void log_buf_add_cpu(void) {}\n#endif \n\nvoid __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tint free;\n\n\tif (log_buf != __log_buf)\n\t\treturn;\n\n\tif (!early && !new_log_buf_len)\n\t\tlog_buf_add_cpu();\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tnew_log_buf =\n\t\t\tmemblock_virt_alloc(new_log_buf_len, log_align);\n\t} else {\n\t\tnew_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len,\n\t\t\t\t\t\t\t  log_align);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"": 1083, "\", argv[1], argv[2]);\n\n\tep[varlen+vallen+1] = '\\0';\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], argv[1], varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn kdb_envfull;\n}\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"": 1084, "\", at: \"": 1085, "\", atomic_read(&overflow_count));\n\tseq_printf(m, \"": 1086, "\", base);\n\tseq_printf(m, \"": 1087, "\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}\n\n\nstatic void clocksource_select(void)\n{\n\treturn __clocksource_select(false);\n}\n\nstatic void clocksource_select_fallback(void)\n{\n\treturn __clocksource_select(true);\n}\n\n#else \n\nstatic inline void clocksource_select(void) { }\nstatic inline void clocksource_select_fallback(void) { }\n\n#endif\n\n\nstatic int __init clocksource_done_booting(void)\n{\n\tmutex_lock(&clocksource_mutex);\n\tcurr_clocksource = clocksource_default_clock();\n\tfinished_booting = 1;\n\t\n\t__clocksource_watchdog_kthread();\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}\nfs_initcall(clocksource_done_booting);\n\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list)\n\t\t\n\t\tif (tmp->rating >= cs->rating)\n\t\t\tentry = &tmp->list;\n\tlist_add(&cs->list, entry);\n}\n\n\nvoid __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t\n\tif (freq) {\n\t\t\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > uint_max)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       nsec_per_sec / scale, sec * scale);\n\t}\n\t\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t\n\twarn_once(cs->mult + cs->maxadj < cs->mult,\n\t\t\"": 1088, "\", boot_delay_setup);\n\nstatic void boot_delay_msec(int level)\n{\n\tunsigned long long k;\n\tunsigned long timeout;\n\n\tif ((boot_delay == 0 || system_state != system_booting)\n\t\t|| (level >= console_loglevel && !ignore_loglevel)) {\n\t\treturn;\n\t}\n\n\tk = (unsigned long long)loops_per_msec * boot_delay;\n\n\ttimeout = jiffies + msecs_to_jiffies(boot_delay);\n\twhile (k) {\n\t\tk--;\n\t\tcpu_relax();\n\t\t\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\ttouch_nmi_watchdog();\n\t}\n}\n#else\nstatic inline void boot_delay_msec(int level)\n{\n}\n#endif\n\nstatic bool printk_time = is_enabled(config_printk_time);\nmodule_param_named(time, printk_time, bool, s_irugo | s_iwusr);\n\nstatic size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec;\n\n\tif (!printk_time)\n\t\treturn 0;\n\n\trem_nsec = do_div(ts, 1000000000);\n\n\tif (!buf)\n\t\treturn snprintf(null, 0, \"": 1089, "\", boot_override_clock);\n\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/kdev_t.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/kallsyms.h>\n#include \"": 1090, "\", boot_override_clocksource);\n\n\nstatic int __init boot_override_clock(char* str)\n{\n\tif (!strcmp(str, \"": 1091, "\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t\n\t\t\t\tif (!kdb_state(kgdb_trans)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"": 1092, "\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: \n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!kdb_state(kgdb_trans)) {\n\t\t\tkdb_state_set(kgdb_trans);\n\t\t\tkdb_printf(\"": 1093, "\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: \n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"": 1094, "\", buffer);\n\t\t}\n\t\tkdb_printf(\"": 1095, "\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"": 1096, "\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"": 1097, "\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: \n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"": 1098, "\", c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuser->buf[len++] = c;\n\t\t}\n\t\tuser->buf[len++] = '\\n';\n\t}\n\n\tuser->idx = log_next(user->idx);\n\tuser->seq++;\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\tif (len > count) {\n\t\tret = -einval;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(buf, user->buf, len)) {\n\t\tret = -efault;\n\t\tgoto out;\n\t}\n\tret = len;\nout:\n\tmutex_unlock(&user->lock);\n\treturn ret;\n}\n\nstatic loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tloff_t ret = 0;\n\n\tif (!user)\n\t\treturn -ebadf;\n\tif (offset)\n\t\treturn -espipe;\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tswitch (whence) {\n\tcase seek_set:\n\t\t\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tbreak;\n\tcase seek_data:\n\t\t\n\t\tuser->idx = clear_idx;\n\t\tuser->seq = clear_seq;\n\t\tbreak;\n\tcase seek_end:\n\t\t\n\t\tuser->idx = log_next_idx;\n\t\tuser->seq = log_next_seq;\n\t\tbreak;\n\tdefault:\n\t\tret = -einval;\n\t}\n\traw_spin_unlock_irq(&logbuf_lock);\n\treturn ret;\n}\n\nstatic unsigned int devkmsg_poll(struct file *file, poll_table *wait)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tint ret = 0;\n\n\tif (!user)\n\t\treturn pollerr|pollnval;\n\n\tpoll_wait(file, &log_wait, wait);\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tif (user->seq < log_next_seq) {\n\t\t\n\t\tif (user->seq < log_first_seq)\n\t\t\tret = pollin|pollrdnorm|pollerr|pollpri;\n\t\telse\n\t\t\tret = pollin|pollrdnorm;\n\t}\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\treturn ret;\n}\n\nstatic int devkmsg_open(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user;\n\tint err;\n\n\t\n\tif ((file->f_flags & o_accmode) == o_wronly)\n\t\treturn 0;\n\n\terr = check_syslog_permissions(syslog_action_read_all,\n\t\t\t\t       syslog_from_reader);\n\tif (err)\n\t\treturn err;\n\n\tuser = kmalloc(sizeof(struct devkmsg_user), gfp_kernel);\n\tif (!user)\n\t\treturn -enomem;\n\n\tmutex_init(&user->lock);\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tuser->idx = log_first_idx;\n\tuser->seq = log_first_seq;\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\tfile->private_data = user;\n\treturn 0;\n}\n\nstatic int devkmsg_release(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\n\tif (!user)\n\t\treturn 0;\n\n\tmutex_destroy(&user->lock);\n\tkfree(user);\n\treturn 0;\n}\n\nconst struct file_operations kmsg_fops = {\n\t.open = devkmsg_open,\n\t.read = devkmsg_read,\n\t.write_iter = devkmsg_write,\n\t.llseek = devkmsg_llseek,\n\t.poll = devkmsg_poll,\n\t.release = devkmsg_release,\n};\n\n#ifdef config_kexec\n\nvoid log_buf_kexec_setup(void)\n{\n\tvmcoreinfo_symbol(log_buf);\n\tvmcoreinfo_symbol(log_buf_len);\n\tvmcoreinfo_symbol(log_first_idx);\n\tvmcoreinfo_symbol(log_next_idx);\n\t\n\tvmcoreinfo_struct_size(printk_log);\n\tvmcoreinfo_offset(printk_log, ts_nsec);\n\tvmcoreinfo_offset(printk_log, len);\n\tvmcoreinfo_offset(printk_log, text_len);\n\tvmcoreinfo_offset(printk_log, dict_len);\n}\n#endif\n\n\nstatic unsigned long __initdata new_log_buf_len;\n\n\nstatic void __init log_buf_len_update(unsigned size)\n{\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = size;\n}\n\n\nstatic int __init log_buf_len_setup(char *str)\n{\n\tunsigned size = memparse(str, &str);\n\n\tlog_buf_len_update(size);\n\n\treturn 0;\n}\nearly_param(\"": 1099, "\", c);\n\t\telse\n\t\t\tuser->buf[len++] = c;\n\t}\n\tuser->buf[len++] = '\\n';\n\n\tif (msg->dict_len) {\n\t\tbool line = true;\n\n\t\tfor (i = 0; i < msg->dict_len; i++) {\n\t\t\tunsigned char c = log_dict(msg)[i];\n\n\t\t\tif (line) {\n\t\t\t\tuser->buf[len++] = ' ';\n\t\t\t\tline = false;\n\t\t\t}\n\n\t\t\tif (c == '\\0') {\n\t\t\t\tuser->buf[len++] = '\\n';\n\t\t\t\tline = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c < ' ' || c >= 127 || c == '\\\\') {\n\t\t\t\tlen += sprintf(user->buf + len, \"": 1100, "\", chan->base_filename, cpu);\n\n\t\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   s_irusr, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}\n\n\nstatic struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = null;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn chan->buf[0];\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn null;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n \t\tchan->buf[0] = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn null;\n}\n\n\nstatic void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tdel_timer_sync(&buf->timer);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}\n\nstatic void setup_callbacks(struct rchan *chan,\n\t\t\t\t   struct rchan_callbacks *cb)\n{\n\tif (!cb) {\n\t\tchan->cb = &default_channel_callbacks;\n\t\treturn;\n\t}\n\n\tif (!cb->subbuf_start)\n\t\tcb->subbuf_start = subbuf_start_default_callback;\n\tif (!cb->buf_mapped)\n\t\tcb->buf_mapped = buf_mapped_default_callback;\n\tif (!cb->buf_unmapped)\n\t\tcb->buf_unmapped = buf_unmapped_default_callback;\n\tif (!cb->create_buf_file)\n\t\tcb->create_buf_file = create_buf_file_default_callback;\n\tif (!cb->remove_buf_file)\n\t\tcb->remove_buf_file = remove_buf_file_default_callback;\n\tchan->cb = cb;\n}\n\n\nstatic int relay_hotcpu_callback(struct notifier_block *nb,\n\t\t\t\tunsigned long action,\n\t\t\t\tvoid *hcpu)\n{\n\tunsigned int hotcpu = (unsigned long)hcpu;\n\tstruct rchan *chan;\n\n\tswitch(action) {\n\tcase cpu_up_prepare:\n\tcase cpu_up_prepare_frozen:\n\t\tmutex_lock(&relay_channels_mutex);\n\t\tlist_for_each_entry(chan, &relay_channels, list) {\n\t\t\tif (chan->buf[hotcpu])\n\t\t\t\tcontinue;\n\t\t\tchan->buf[hotcpu] = relay_open_buf(chan, hotcpu);\n\t\t\tif(!chan->buf[hotcpu]) {\n\t\t\t\tprintk(kern_err\n\t\t\t\t\t\"": 1101, "\", class->ops);\n\tprintk(\"": 1102, "\", cnt);\n\n\tcnt = ring_buffer_bytes_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"": 1103, "\", cnt);\n\n\tcnt = ring_buffer_commit_overrun_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"": 1104, "\", cnt);\n\n\tcnt = ring_buffer_overrun_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"": 1105, "\", cnt);\n\n\tcnt = ring_buffer_read_events_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"": 1106, "\", cnt);\n\n\tcount = simple_read_from_buffer(ubuf, count, ppos,\n\t\t\t\t\ts->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn count;\n}\n\nstatic const struct file_operations tracing_stats_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_stats_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\n#ifdef config_dynamic_ftrace\n\nint __weak ftrace_arch_read_dyn_info(char *buf, int size)\n{\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_read_dyn_info(struct file *filp, char __user *ubuf,\n\t\t  size_t cnt, loff_t *ppos)\n{\n\tstatic char ftrace_dyn_info_buffer[1024];\n\tstatic define_mutex(dyn_info_mutex);\n\tunsigned long *p = filp->private_data;\n\tchar *buf = ftrace_dyn_info_buffer;\n\tint size = array_size(ftrace_dyn_info_buffer);\n\tint r;\n\n\tmutex_lock(&dyn_info_mutex);\n\tr = sprintf(buf, \"": 1107, "\", cnt);\n\n\tif (trace_clocks[tr->clock_id].in_ns) {\n\t\t\n\t\tt = ns2usecs(ring_buffer_oldest_event_ts(trace_buf->buffer, cpu));\n\t\tusec_rem = do_div(t, usec_per_sec);\n\t\ttrace_seq_printf(s, \"": 1108, "\", console_setup);\n\n\nint add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, null);\n}\n\nbool console_suspend_enabled = true;\nexport_symbol(console_suspend_enabled);\n\nstatic int __init console_suspend_disable(char *str)\n{\n\tconsole_suspend_enabled = false;\n\treturn 1;\n}\n__setup(\"": 1109, "\", console_suspend_disable);\nmodule_param_named(console_suspend, console_suspend_enabled,\n\t\tbool, s_irugo | s_iwusr);\nmodule_parm_desc(console_suspend, \"": 1110, "\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\"": 1111, "\", count);\n\n\treturn 0;\n}\n\nstatic struct ftrace_probe_ops snapshot_probe_ops = {\n\t.func\t\t\t= ftrace_snapshot,\n\t.print\t\t\t= ftrace_snapshot_print,\n};\n\nstatic struct ftrace_probe_ops snapshot_count_probe_ops = {\n\t.func\t\t\t= ftrace_count_snapshot,\n\t.print\t\t\t= ftrace_snapshot_print,\n};\n\nstatic int\nftrace_trace_snapshot_callback(struct ftrace_hash *hash,\n\t\t\t       char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t\n\tif (!enable)\n\t\treturn -einval;\n\n\tops = param ? &snapshot_count_probe_ops :  &snapshot_probe_ops;\n\n\tif (glob[0] == '!') {\n\t\tunregister_ftrace_function_probe_func(glob+1, ops);\n\t\treturn 0;\n\t}\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \"": 1112, "\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"": 1113, "\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; \n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"": 1114, "\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: \n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"": 1115, "\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"": 1116, "\", cpu);\n\t\treturn 0;\n\t}\n\tbase->hres_active = 1;\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++)\n\t\tbase->clock_base[i].resolution = ktime_high_res;\n\n\ttick_setup_sched_timer();\n\t\n\tretrigger_next_event(null);\n\tlocal_irq_restore(flags);\n\treturn 1;\n}\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set();\n}\n\nstatic declare_work(hrtimer_work, clock_was_set_work);\n\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}\n\n#else\n\nstatic inline int hrtimer_hres_active(void) { return 0; }\nstatic inline int hrtimer_is_hres_enabled(void) { return 0; }\nstatic inline int hrtimer_switch_to_hres(void) { return 0; }\nstatic inline void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *base, int skip_equal) { }\nstatic inline int hrtimer_reprogram(struct hrtimer *timer,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\treturn 0;\n}\nstatic inline void hrtimer_init_hres(struct hrtimer_cpu_base *base) { }\nstatic inline void retrigger_next_event(void *arg) { }\n\n#endif \n\n\nvoid clock_was_set(void)\n{\n#ifdef config_high_res_timers\n\t\n\ton_each_cpu(retrigger_next_event, null, 1);\n#endif\n\ttimerfd_clock_was_set();\n}\n\n\nvoid hrtimers_resume(void)\n{\n\twarn_once(!irqs_disabled(),\n\t\t  kern_info \"": 1117, "\", cpu);\n\td_cpu = tracefs_create_dir(cpu_dir, d_percpu);\n\tif (!d_cpu) {\n\t\tpr_warning(\"": 1118, "\", cpu);\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tseq_printf(m, \"": 1119, "\", cpu);\n\n\treturn tr->percpu_dir;\n}\n\nstatic struct dentry *\ntrace_create_cpu_file(const char *name, umode_t mode, struct dentry *parent,\n\t\t      void *data, long cpu, const struct file_operations *fops)\n{\n\tstruct dentry *ret = trace_create_file(name, mode, parent, data, fops);\n\n\tif (ret) \n\t\td_inode(ret)->i_cdev = (void *)(cpu + 1);\n\treturn ret;\n}\n\nstatic void\ntracing_init_tracefs_percpu(struct trace_array *tr, long cpu)\n{\n\tstruct dentry *d_percpu = tracing_dentry_percpu(tr, cpu);\n\tstruct dentry *d_cpu;\n\tchar cpu_dir[30]; \n\n\tif (!d_percpu)\n\t\treturn;\n\n\tsnprintf(cpu_dir, 30, \"": 1120, "\", cpu_dir);\n\t\treturn;\n\t}\n\n\t\n\ttrace_create_cpu_file(\"": 1121, "\", cs->name);\n\t\t\toverride_name[0] = 0;\n\t\t} else\n\t\t\t\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"": 1122, "\", cs->name);\n\t\t\tpr_warn(\"": 1123, "\", curr_clocksource->name);\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn count;\n}\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t\n\tif (!cnt || cnt >= cs_name_len)\n\t\treturn -einval;\n\n\t\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}\n\n\nstatic ssize_t sysfs_override_clocksource(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&clocksource_mutex);\n\n\tret = sysfs_get_uname(buf, override_name, count);\n\tif (ret >= 0)\n\t\tclocksource_select();\n\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret;\n}\n\n\nstatic ssize_t sysfs_unbind_clocksource(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct clocksource *cs;\n\tchar name[cs_name_len];\n\tssize_t ret;\n\n\tret = sysfs_get_uname(buf, name, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -enodev;\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (strcmp(cs->name, name))\n\t\t\tcontinue;\n\t\tret = clocksource_unbind(cs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret ? ret : count;\n}\n\n\nstatic ssize_t\nsysfs_show_available_clocksources(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct clocksource *src;\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(src, &clocksource_list, list) {\n\t\t\n\t\tif (!tick_oneshot_mode_active() ||\n\t\t    (src->flags & clock_source_valid_for_hres))\n\t\t\tcount += snprintf(buf + count,\n\t\t\t\t  max((ssize_t)page_size - count, (ssize_t)0),\n\t\t\t\t  \"": 1124, "\", current);\n\tbug();\n}\nexport_symbol(__invalid_creds);\n\n\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(kern_err \"": 1125, "\", d_tracer);\n\tif (!tr->options) {\n\t\tpr_warning(\"": 1126, "\", d_tracer);\n\n\twarn_once(!tr->percpu_dir,\n\t\t  \"": 1127, "\", d_tracer,\n\t\t\t\t\t\t\t instance_mkdir,\n\t\t\t\t\t\t\t instance_rmdir);\n\tif (warn_on(!trace_instance_dir))\n\t\treturn;\n}\n\nstatic void\ninit_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\tint cpu;\n\n\ttrace_create_file(\"": 1128, "\", data);\n\n\t\t\tseq_printf(m, \"": 1129, "\", depth);\n\tprint_lock_name(target->class);\n\tprintk(\"": 1130, "\", depth, \"": 1131, "\", desc->irq_data.domain->name);\n\t\t}\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int virq_debug_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, virq_debug_show, inode->i_private);\n}\n\nstatic const struct file_operations virq_debug_fops = {\n\t.open = virq_debug_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int __init irq_debugfs_init(void)\n{\n\tif (debugfs_create_file(\"": 1132, "\", dev->mode);\n\tseq_printf(m, \"": 1133, "\", dev->mult);\n\tseq_printf(m, \"": 1134, "\", dev->name);\n\tseq_printf(m, \"": 1135, "\", dev->retries);\n\tseq_printf(m, \"": 1136, "\", dev->shift);\n\tseq_printf(m, \"": 1137, "\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"": 1138, "\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"": 1139, "\", entry->type);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_hex_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned char newline = '\\n';\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (trace_flags & trace_iter_context_info) {\n\t\tseq_put_hex_field(s, entry->pid);\n\t\tseq_put_hex_field(s, iter->cpu);\n\t\tseq_put_hex_field(s, iter->ts);\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\treturn trace_type_partial_line;\n\t}\n\n\tevent = ftrace_find_event(entry->type);\n\tif (event) {\n\t\tenum print_line_t ret = event->funcs->hex(iter, 0, event);\n\t\tif (ret != trace_type_handled)\n\t\t\treturn ret;\n\t}\n\n\tseq_put_field(s, newline);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_bin_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (trace_flags & trace_iter_context_info) {\n\t\tseq_put_field(s, entry->pid);\n\t\tseq_put_field(s, iter->cpu);\n\t\tseq_put_field(s, iter->ts);\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\treturn trace_type_partial_line;\n\t}\n\n\tevent = ftrace_find_event(entry->type);\n\treturn event ? event->funcs->binary(iter, 0, event) :\n\t\ttrace_type_handled;\n}\n\nint trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t\n\tif (iter->cpu_file != ring_buffer_all_cpus) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nenum print_line_t print_trace_line(struct trace_iterator *iter)\n{\n\tenum print_line_t ret;\n\n\tif (iter->lost_events) {\n\t\ttrace_seq_printf(&iter->seq, \"": 1140, "\", entry->type);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_raw_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (trace_flags & trace_iter_context_info)\n\t\ttrace_seq_printf(s, \"": 1141, "\", events);\n\n\tmutex_unlock(&show_mutex);\n\n\treturn 0;\n}\n\n\nstatic void sync_access(void)\n{\n\tunsigned long flags;\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\traw_spinlock_t *lock = &per_cpu(tstats_lookup_lock, cpu);\n\n\t\traw_spin_lock_irqsave(lock, flags);\n\t\t\n\t\traw_spin_unlock_irqrestore(lock, flags);\n\t}\n}\n\nstatic ssize_t tstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tchar ctl[2];\n\n\tif (count != 2 || *offs)\n\t\treturn -einval;\n\n\tif (copy_from_user(ctl, buf, count))\n\t\treturn -efault;\n\n\tmutex_lock(&show_mutex);\n\tswitch (ctl[0]) {\n\tcase '0':\n\t\tif (timer_stats_active) {\n\t\t\ttimer_stats_active = 0;\n\t\t\ttime_stop = ktime_get();\n\t\t\tsync_access();\n\t\t}\n\t\tbreak;\n\tcase '1':\n\t\tif (!timer_stats_active) {\n\t\t\treset_entries();\n\t\t\ttime_start = ktime_get();\n\t\t\tsmp_mb();\n\t\t\ttimer_stats_active = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcount = -einval;\n\t}\n\tmutex_unlock(&show_mutex);\n\n\treturn count;\n}\n\nstatic int tstats_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, tstats_show, null);\n}\n\nstatic const struct file_operations tstats_fops = {\n\t.open\t\t= tstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nvoid __init init_timer_stats(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(&per_cpu(tstats_lookup_lock, cpu));\n}\n\nstatic int __init init_tstats_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create(\"": 1142, "\", field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t trace_print_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"": 1143, "\", field->ip);\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_bprint_funcs = {\n\t.trace\t\t= trace_bprint_print,\n\t.raw\t\t= trace_bprint_raw,\n};\n\nstatic struct trace_event trace_bprint_event = {\n\t.type\t\t= trace_bprint,\n\t.funcs\t\t= &trace_bprint_funcs,\n};\n\n\nstatic enum print_line_t trace_print_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct print_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_printf(s, \"": 1144, "\", field->ip);\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_bputs_funcs = {\n\t.trace\t\t= trace_bputs_print,\n\t.raw\t\t= trace_bputs_raw,\n};\n\nstatic struct trace_event trace_bputs_event = {\n\t.type\t\t= trace_bputs,\n\t.funcs\t\t= &trace_bputs_funcs,\n};\n\n\nstatic enum print_line_t\ntrace_bprint_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \"": 1145, "\", field->ip, field->buf);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic struct trace_event_functions trace_print_funcs = {\n\t.trace\t\t= trace_print_print,\n\t.raw\t\t= trace_print_raw,\n};\n\nstatic struct trace_event trace_print_event = {\n\t.type\t \t= trace_print,\n\t.funcs\t\t= &trace_print_funcs,\n};\n\n\nstatic struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\tnull\n};\n\n__init static int init_events(void)\n{\n\tstruct trace_event *event;\n\tint i, ret;\n\n\tfor (i = 0; events[i]; i++) {\n\t\tevent = events[i];\n\n\t\tret = register_ftrace_event(event);\n\t\tif (!ret) {\n\t\t\tprintk(kern_warning \"": 1146, "\", file, line);\n\tdump_invalid_creds(cred, \"": 1147, "\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"": 1148, "\", func);\n\t}\n}\n#endif \n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \"": 1149, "\", hotcpu);\n\t\t\t\tmutex_unlock(&relay_channels_mutex);\n\t\t\t\treturn notifier_from_errno(-enomem);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\tbreak;\n\tcase cpu_dead:\n\tcase cpu_dead_frozen:\n\t\t\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\n\nstruct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn null;\n\tif (subbuf_size > uint_max / n_subbufs)\n\t\treturn null;\n\n\tchan = kzalloc(sizeof(struct rchan), gfp_kernel);\n\tif (!chan)\n\t\treturn null;\n\n\tchan->version = relayfs_channel_version;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = page_align(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, name_max);\n\t}\n\tsetup_callbacks(chan, cb);\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tchan->buf[i] = relay_open_buf(chan, i);\n\t\tif (!chan->buf[i])\n\t\t\tgoto free_bufs;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif (chan->buf[i])\n\t\t\trelay_close_buf(chan->buf[i]);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn null;\n}\nexport_symbol_gpl(relay_open);\n\nstruct rchan_percpu_buf_dispatcher {\n\tstruct rchan_buf *buf;\n\tstruct dentry *dentry;\n};\n\n\nstatic void __relay_set_buf_dentry(void *info)\n{\n\tstruct rchan_percpu_buf_dispatcher *p = info;\n\n\trelay_set_buf_dentry(p->buf, p->dentry);\n}\n\n\nint relay_late_setup_files(struct rchan *chan,\n\t\t\t   const char *base_filename,\n\t\t\t   struct dentry *parent)\n{\n\tint err = 0;\n\tunsigned int i, curr_cpu;\n\tunsigned long flags;\n\tstruct dentry *dentry;\n\tstruct rchan_percpu_buf_dispatcher disp;\n\n\tif (!chan || !base_filename)\n\t\treturn -einval;\n\n\tstrlcpy(chan->base_filename, base_filename, name_max);\n\n\tmutex_lock(&relay_channels_mutex);\n\t\n\tif (unlikely(chan->has_base_filename)) {\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\treturn -eexist;\n\t}\n\tchan->has_base_filename = 1;\n\tchan->parent = parent;\n\tcurr_cpu = get_cpu();\n\t\n\tfor_each_online_cpu(i) {\n\t\tif (unlikely(!chan->buf[i])) {\n\t\t\twarn_once(1, kern_err \"": 1150, "\", hrtimer_max_clock_bases);\n\tseq_printf(m, \"": 1151, "\", hwirq);\n\n\t\t\tchip = irq_desc_get_chip(desc);\n\t\t\tseq_printf(m, \"": 1152, "\", i ? \"": 1153, "\", i);\n\t\t\tseq_printf(m, \"": 1154, "\", i, funcs[i].func);\n}\n\nstatic struct tracepoint_func *func_add(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0;\n\tstruct tracepoint_func *old, *new;\n\n\tif (warn_on(!tp_func->func))\n\t\treturn err_ptr(-einval);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++)\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t    old[nr_probes].data == tp_func->data)\n\t\t\t\treturn err_ptr(-eexist);\n\t}\n\t\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == null)\n\t\treturn err_ptr(-enomem);\n\tif (old)\n\t\tmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\n\tnew[nr_probes] = *tp_func;\n\tnew[nr_probes + 1].func = null;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn err_ptr(-enoent);\n\n\tdebug_print_probes(*funcs);\n\t\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t\n\tif (nr_probes - nr_del == 0) {\n\t\t\n\t\t*funcs = null;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t\n\t\t\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new == null)\n\t\t\treturn err_ptr(-enomem);\n\t\tfor (i = 0; old[i].func; i++)\n\t\t\tif (old[i].func != tp_func->func\n\t\t\t\t\t|| old[i].data != tp_func->data)\n\t\t\t\tnew[j++] = old[i];\n\t\tnew[nr_probes - nr_del].func = null;\n\t\t*funcs = new;\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}\n\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key))\n\t\ttp->regfunc();\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func);\n\tif (is_err(old)) {\n\t\twarn_on_once(1);\n\t\treturn ptr_err(old);\n\t}\n\n\t\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}\n\n\nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (is_err(old)) {\n\t\twarn_on_once(1);\n\t\treturn ptr_err(old);\n\t}\n\n\tif (!tp_funcs) {\n\t\t\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tif (static_key_enabled(&tp->key))\n\t\t\tstatic_key_slow_dec(&tp->key);\n\t}\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\trelease_probes(old);\n\treturn 0;\n}\n\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_add_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nexport_symbol_gpl(tracepoint_probe_register);\n\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nexport_symbol_gpl(tracepoint_probe_unregister);\n\n#ifdef config_modules\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << taint_oot_module) | (1 << taint_crap) |\n\t\t\t       (1 << taint_unsigned_module));\n}\n\nstatic blocking_notifier_head(tracepoint_notify_list);\n\n\nint register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, module_state_coming, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}\nexport_symbol_gpl(register_tracepoint_module_notifier);\n\n\nint unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, module_state_going, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}\nexport_symbol_gpl(unregister_tracepoint_module_notifier);\n\n\nstatic void tp_module_going_check_quiescent(struct tracepoint * const *begin,\n\t\tstruct tracepoint * const *end)\n{\n\tstruct tracepoint * const *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\twarn_on_once((*iter)->funcs);\n}\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), gfp_kernel);\n\tif (!tp_mod) {\n\t\tret = -enomem;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tmodule_state_coming, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tmodule_state_going, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t\n\t\t\ttp_module_going_check_quiescent(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}\n\nstatic int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase module_state_coming:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase module_state_live:\n\t\tbreak;\n\tcase module_state_going:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase module_state_unformed:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct notifier_block tracepoint_module_nb = {\n\t.notifier_call = tracepoint_module_notify,\n\t.priority = 0,\n};\n\nstatic __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warning(\"": 1155, "\", idx);\n\tprint_name_offset(m, taddr);\n\tseq_printf(m, \"": 1156, "\", ignore_loglevel_setup);\nmodule_param(ignore_loglevel, bool, s_irugo | s_iwusr);\nmodule_parm_desc(ignore_loglevel,\n\t\t \"": 1157, "\", irqclass);\n\tif (!save_trace(&next_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tprintk(\"": 1158, "\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tprintk(\"": 1159, "\", irqclass);\n\tprintk(\"": 1160, "\", irqclass);\n\n\tprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\n\n\tprintk(\"": 1161, "\", iter->trace->name);\n\t\t\tseq_puts(m, \"": 1162, "\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"": 1163, "\", kdb_buffer);\n\t}\n\n\tif (kdb_state(pager)) {\n\t\t\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"": 1164, "\", keep_bootcon_setup);\n\n\nvoid register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = null;\n\tstruct console_cmdline *c;\n\n\tif (console_drivers)\n\t\tfor_each_console(bcon)\n\t\t\tif (warn(bcon == newcon,\n\t\t\t\t\t\"": 1165, "\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"": 1166, "\", line);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t devkmsg_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tstruct printk_log *msg;\n\tu64 ts_usec;\n\tsize_t i;\n\tchar cont = '-';\n\tsize_t len;\n\tssize_t ret;\n\n\tif (!user)\n\t\treturn -ebadf;\n\n\tret = mutex_lock_interruptible(&user->lock);\n\tif (ret)\n\t\treturn ret;\n\traw_spin_lock_irq(&logbuf_lock);\n\twhile (user->seq == log_next_seq) {\n\t\tif (file->f_flags & o_nonblock) {\n\t\t\tret = -eagain;\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tret = wait_event_interruptible(log_wait,\n\t\t\t\t\t       user->seq != log_next_seq);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t}\n\n\tif (user->seq < log_first_seq) {\n\t\t\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tret = -epipe;\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tgoto out;\n\t}\n\n\tmsg = log_from_idx(user->idx);\n\tts_usec = msg->ts_nsec;\n\tdo_div(ts_usec, 1000);\n\n\t\n\tif (msg->flags & log_cont && !(user->prev & log_cont))\n\t\tcont = 'c';\n\telse if ((msg->flags & log_cont) ||\n\t\t ((user->prev & log_cont) && !(msg->flags & log_prefix)))\n\t\tcont = '+';\n\n\tlen = sprintf(user->buf, \"": 1167, "\", log_buf_len);\n\tpr_info(\"": 1168, "\", log_buf_len_setup);\n\n#ifdef config_smp\n#define __log_cpu_max_buf_len (1 << config_log_cpu_max_buf_shift)\n\nstatic void __init log_buf_add_cpu(void)\n{\n\tunsigned int cpu_extra;\n\n\t\n\tif (num_possible_cpus() == 1)\n\t\treturn;\n\n\tcpu_extra = (num_possible_cpus() - 1) * __log_cpu_max_buf_len;\n\n\t\n\tif (cpu_extra <= __log_buf_len / 2)\n\t\treturn;\n\n\tpr_info(\"": 1169, "\", max_lock_depth,\n\t\t\t       top_task->comm, task_pid_nr(top_task));\n\t\t}\n\t\tput_task_struct(task);\n\n\t\treturn -edeadlk;\n\t}\n\n\t\n retry:\n\t\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\t\n\twaiter = task->pi_blocked_on;\n\n\t\n\n\t\n\tif (!waiter)\n\t\tgoto out_unlock_pi;\n\n\t\n\tif (orig_waiter && !rt_mutex_owner(orig_lock))\n\t\tgoto out_unlock_pi;\n\n\t\n\tif (next_lock != waiter->lock)\n\t\tgoto out_unlock_pi;\n\n\t\n\tif (top_waiter) {\n\t\tif (!task_has_pi_waiters(task))\n\t\t\tgoto out_unlock_pi;\n\t\t\n\t\tif (top_waiter != task_top_pi_waiter(task)) {\n\t\t\tif (!detect_deadlock)\n\t\t\t\tgoto out_unlock_pi;\n\t\t\telse\n\t\t\t\trequeue = false;\n\t\t}\n\t}\n\n\t\n\tif (waiter->prio == task->prio) {\n\t\tif (!detect_deadlock)\n\t\t\tgoto out_unlock_pi;\n\t\telse\n\t\t\trequeue = false;\n\t}\n\n\t\n\tlock = waiter->lock;\n\t\n\tif (!raw_spin_trylock(&lock->wait_lock)) {\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\tcpu_relax();\n\t\tgoto retry;\n\t}\n\n\t\n\tif (lock == orig_lock || rt_mutex_owner(lock) == top_task) {\n\t\tdebug_rt_mutex_deadlock(chwalk, orig_waiter, lock);\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\tret = -edeadlk;\n\t\tgoto out_unlock_pi;\n\t}\n\n\t\n\tif (!requeue) {\n\t\t\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\tput_task_struct(task);\n\n\t\t\n\t\tif (!rt_mutex_owner(lock)) {\n\t\t\traw_spin_unlock(&lock->wait_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t\n\t\ttask = rt_mutex_owner(lock);\n\t\tget_task_struct(task);\n\t\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\t\t\n\t\tnext_lock = task_blocked_on_lock(task);\n\t\t\n\t\ttop_waiter = rt_mutex_top_waiter(lock);\n\n\t\t\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\traw_spin_unlock(&lock->wait_lock);\n\n\t\t\n\t\tif (!next_lock)\n\t\t\tgoto out_put_task;\n\t\tgoto again;\n\t}\n\n\t\n\tprerequeue_top_waiter = rt_mutex_top_waiter(lock);\n\n\t\n\trt_mutex_dequeue(lock, waiter);\n\twaiter->prio = task->prio;\n\trt_mutex_enqueue(lock, waiter);\n\n\t\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\tput_task_struct(task);\n\n\t\n\tif (!rt_mutex_owner(lock)) {\n\t\t\n\t\tif (prerequeue_top_waiter != rt_mutex_top_waiter(lock))\n\t\t\twake_up_process(rt_mutex_top_waiter(lock)->task);\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\treturn 0;\n\t}\n\n\t\n\ttask = rt_mutex_owner(lock);\n\tget_task_struct(task);\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\t\n\tif (waiter == rt_mutex_top_waiter(lock)) {\n\t\t\n\t\trt_mutex_dequeue_pi(task, prerequeue_top_waiter);\n\t\trt_mutex_enqueue_pi(task, waiter);\n\t\t__rt_mutex_adjust_prio(task);\n\n\t} else if (prerequeue_top_waiter == waiter) {\n\t\t\n\t\trt_mutex_dequeue_pi(task, waiter);\n\t\twaiter = rt_mutex_top_waiter(lock);\n\t\trt_mutex_enqueue_pi(task, waiter);\n\t\t__rt_mutex_adjust_prio(task);\n\t} else {\n\t\t\n\t}\n\n\t\n\tnext_lock = task_blocked_on_lock(task);\n\t\n\ttop_waiter = rt_mutex_top_waiter(lock);\n\n\t\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\traw_spin_unlock(&lock->wait_lock);\n\n\t\n\tif (!next_lock)\n\t\tgoto out_put_task;\n\n\t\n\tif (!detect_deadlock && waiter != top_waiter)\n\t\tgoto out_put_task;\n\n\tgoto again;\n\n out_unlock_pi:\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n out_put_task:\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\n\nstatic int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,\n\t\t\t\tstruct rt_mutex_waiter *waiter)\n{\n\tunsigned long flags;\n\n\t\n\tmark_rt_mutex_waiters(lock);\n\n\t\n\tif (rt_mutex_owner(lock))\n\t\treturn 0;\n\n\t\n\tif (waiter) {\n\t\t\n\t\tif (waiter != rt_mutex_top_waiter(lock))\n\t\t\treturn 0;\n\n\t\t\n\t\trt_mutex_dequeue(lock, waiter);\n\n\t} else {\n\t\t\n\t\tif (rt_mutex_has_waiters(lock)) {\n\t\t\t\n\t\t\tif (task->prio >= rt_mutex_top_waiter(lock)->prio)\n\t\t\t\treturn 0;\n\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tgoto takeit;\n\t\t}\n\t}\n\n\t\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\ttask->pi_blocked_on = null;\n\t\n\tif (rt_mutex_has_waiters(lock))\n\t\trt_mutex_enqueue_pi(task, rt_mutex_top_waiter(lock));\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\ntakeit:\n\t\n\tdebug_rt_mutex_lock(lock);\n\n\t\n\trt_mutex_set_owner(lock, task);\n\n\trt_mutex_deadlock_account_lock(lock, task);\n\n\treturn 1;\n}\n\n\nstatic int task_blocks_on_rt_mutex(struct rt_mutex *lock,\n\t\t\t\t   struct rt_mutex_waiter *waiter,\n\t\t\t\t   struct task_struct *task,\n\t\t\t\t   enum rtmutex_chainwalk chwalk)\n{\n\tstruct task_struct *owner = rt_mutex_owner(lock);\n\tstruct rt_mutex_waiter *top_waiter = waiter;\n\tstruct rt_mutex *next_lock;\n\tint chain_walk = 0, res;\n\tunsigned long flags;\n\n\t\n\tif (owner == task)\n\t\treturn -edeadlk;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\t__rt_mutex_adjust_prio(task);\n\twaiter->task = task;\n\twaiter->lock = lock;\n\twaiter->prio = task->prio;\n\n\t\n\tif (rt_mutex_has_waiters(lock))\n\t\ttop_waiter = rt_mutex_top_waiter(lock);\n\trt_mutex_enqueue(lock, waiter);\n\n\ttask->pi_blocked_on = waiter;\n\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\tif (!owner)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&owner->pi_lock, flags);\n\tif (waiter == rt_mutex_top_waiter(lock)) {\n\t\trt_mutex_dequeue_pi(owner, top_waiter);\n\t\trt_mutex_enqueue_pi(owner, waiter);\n\n\t\t__rt_mutex_adjust_prio(owner);\n\t\tif (owner->pi_blocked_on)\n\t\t\tchain_walk = 1;\n\t} else if (rt_mutex_cond_detect_deadlock(waiter, chwalk)) {\n\t\tchain_walk = 1;\n\t}\n\n\t\n\tnext_lock = task_blocked_on_lock(owner);\n\n\traw_spin_unlock_irqrestore(&owner->pi_lock, flags);\n\t\n\tif (!chain_walk || !next_lock)\n\t\treturn 0;\n\n\t\n\tget_task_struct(owner);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\tres = rt_mutex_adjust_prio_chain(owner, chwalk, lock,\n\t\t\t\t\t next_lock, waiter, task);\n\n\traw_spin_lock(&lock->wait_lock);\n\n\treturn res;\n}\n\n\nstatic void wakeup_next_waiter(struct rt_mutex *lock)\n{\n\tstruct rt_mutex_waiter *waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\n\twaiter = rt_mutex_top_waiter(lock);\n\n\t\n\trt_mutex_dequeue_pi(current, waiter);\n\n\t\n\tlock->owner = (void *) rt_mutex_has_waiters;\n\n\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\n\t\n\twake_up_process(waiter->task);\n}\n\n\nstatic void remove_waiter(struct rt_mutex *lock,\n\t\t\t  struct rt_mutex_waiter *waiter)\n{\n\tbool is_top_waiter = (waiter == rt_mutex_top_waiter(lock));\n\tstruct task_struct *owner = rt_mutex_owner(lock);\n\tstruct rt_mutex *next_lock;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\trt_mutex_dequeue(lock, waiter);\n\tcurrent->pi_blocked_on = null;\n\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\n\t\n\tif (!owner || !is_top_waiter)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&owner->pi_lock, flags);\n\n\trt_mutex_dequeue_pi(owner, waiter);\n\n\tif (rt_mutex_has_waiters(lock))\n\t\trt_mutex_enqueue_pi(owner, rt_mutex_top_waiter(lock));\n\n\t__rt_mutex_adjust_prio(owner);\n\n\t\n\tnext_lock = task_blocked_on_lock(owner);\n\n\traw_spin_unlock_irqrestore(&owner->pi_lock, flags);\n\n\t\n\tif (!next_lock)\n\t\treturn;\n\n\t\n\tget_task_struct(owner);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\trt_mutex_adjust_prio_chain(owner, rt_mutex_min_chainwalk, lock,\n\t\t\t\t   next_lock, null, current);\n\n\traw_spin_lock(&lock->wait_lock);\n}\n\n\nvoid rt_mutex_adjust_pi(struct task_struct *task)\n{\n\tstruct rt_mutex_waiter *waiter;\n\tstruct rt_mutex *next_lock;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\twaiter = task->pi_blocked_on;\n\tif (!waiter || (waiter->prio == task->prio &&\n\t\t\t!dl_prio(task->prio))) {\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\treturn;\n\t}\n\tnext_lock = waiter->lock;\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\t\n\tget_task_struct(task);\n\n\trt_mutex_adjust_prio_chain(task, rt_mutex_min_chainwalk, null,\n\t\t\t\t   next_lock, null, task);\n}\n\n\nstatic int __sched\n__rt_mutex_slowlock(struct rt_mutex *lock, int state,\n\t\t    struct hrtimer_sleeper *timeout,\n\t\t    struct rt_mutex_waiter *waiter)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\t\n\t\tif (try_to_take_rt_mutex(lock, current, waiter))\n\t\t\tbreak;\n\n\t\t\n\t\tif (unlikely(state == task_interruptible)) {\n\t\t\t\n\t\t\tif (signal_pending(current))\n\t\t\t\tret = -eintr;\n\t\t\tif (timeout && !timeout->task)\n\t\t\t\tret = -etimedout;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\traw_spin_unlock(&lock->wait_lock);\n\n\t\tdebug_rt_mutex_print_deadlock(waiter);\n\n\t\tschedule_rt_mutex(lock);\n\n\t\traw_spin_lock(&lock->wait_lock);\n\t\tset_current_state(state);\n\t}\n\n\t__set_current_state(task_running);\n\treturn ret;\n}\n\nstatic void rt_mutex_handle_deadlock(int res, int detect_deadlock,\n\t\t\t\t     struct rt_mutex_waiter *w)\n{\n\t\n\tif (res != -edeadlock || detect_deadlock)\n\t\treturn;\n\n\t\n\trt_mutex_print_deadlock(w);\n\twhile (1) {\n\t\tset_current_state(task_interruptible);\n\t\tschedule();\n\t}\n}\n\n\nstatic int __sched\nrt_mutex_slowlock(struct rt_mutex *lock, int state,\n\t\t  struct hrtimer_sleeper *timeout,\n\t\t  enum rtmutex_chainwalk chwalk)\n{\n\tstruct rt_mutex_waiter waiter;\n\tint ret = 0;\n\n\tdebug_rt_mutex_init_waiter(&waiter);\n\trb_clear_node(&waiter.pi_tree_entry);\n\trb_clear_node(&waiter.tree_entry);\n\n\traw_spin_lock(&lock->wait_lock);\n\n\t\n\tif (try_to_take_rt_mutex(lock, current, null)) {\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\treturn 0;\n\t}\n\n\tset_current_state(state);\n\n\t\n\tif (unlikely(timeout)) {\n\t\thrtimer_start_expires(&timeout->timer, hrtimer_mode_abs);\n\t\tif (!hrtimer_active(&timeout->timer))\n\t\t\ttimeout->task = null;\n\t}\n\n\tret = task_blocks_on_rt_mutex(lock, &waiter, current, chwalk);\n\n\tif (likely(!ret))\n\t\t\n\t\tret = __rt_mutex_slowlock(lock, state, timeout, &waiter);\n\n\tif (unlikely(ret)) {\n\t\t__set_current_state(task_running);\n\t\tif (rt_mutex_has_waiters(lock))\n\t\t\tremove_waiter(lock, &waiter);\n\t\trt_mutex_handle_deadlock(ret, chwalk, &waiter);\n\t}\n\n\t\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\t\n\tif (unlikely(timeout))\n\t\thrtimer_cancel(&timeout->timer);\n\n\tdebug_rt_mutex_free_waiter(&waiter);\n\n\treturn ret;\n}\n\n\nstatic inline int rt_mutex_slowtrylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\t\n\tif (rt_mutex_owner(lock))\n\t\treturn 0;\n\n\t\n\traw_spin_lock(&lock->wait_lock);\n\n\tret = try_to_take_rt_mutex(lock, current, null);\n\n\t\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\treturn ret;\n}\n\n\nstatic void __sched\nrt_mutex_slowunlock(struct rt_mutex *lock)\n{\n\traw_spin_lock(&lock->wait_lock);\n\n\tdebug_rt_mutex_unlock(lock);\n\n\trt_mutex_deadlock_account_unlock(current);\n\n\t\n\twhile (!rt_mutex_has_waiters(lock)) {\n\t\t\n\t\tif (unlock_rt_mutex_safe(lock) == true)\n\t\t\treturn;\n\t\t\n\t\traw_spin_lock(&lock->wait_lock);\n\t}\n\n\t\n\twakeup_next_waiter(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\t\n\trt_mutex_adjust_prio(current);\n}\n\n\nstatic inline int\nrt_mutex_fastlock(struct rt_mutex *lock, int state,\n\t\t  int (*slowfn)(struct rt_mutex *lock, int state,\n\t\t\t\tstruct hrtimer_sleeper *timeout,\n\t\t\t\tenum rtmutex_chainwalk chwalk))\n{\n\tif (likely(rt_mutex_cmpxchg(lock, null, current))) {\n\t\trt_mutex_deadlock_account_lock(lock, current);\n\t\treturn 0;\n\t} else\n\t\treturn slowfn(lock, state, null, rt_mutex_min_chainwalk);\n}\n\nstatic inline int\nrt_mutex_timed_fastlock(struct rt_mutex *lock, int state,\n\t\t\tstruct hrtimer_sleeper *timeout,\n\t\t\tenum rtmutex_chainwalk chwalk,\n\t\t\tint (*slowfn)(struct rt_mutex *lock, int state,\n\t\t\t\t      struct hrtimer_sleeper *timeout,\n\t\t\t\t      enum rtmutex_chainwalk chwalk))\n{\n\tif (chwalk == rt_mutex_min_chainwalk &&\n\t    likely(rt_mutex_cmpxchg(lock, null, current))) {\n\t\trt_mutex_deadlock_account_lock(lock, current);\n\t\treturn 0;\n\t} else\n\t\treturn slowfn(lock, state, timeout, chwalk);\n}\n\nstatic inline int\nrt_mutex_fasttrylock(struct rt_mutex *lock,\n\t\t     int (*slowfn)(struct rt_mutex *lock))\n{\n\tif (likely(rt_mutex_cmpxchg(lock, null, current))) {\n\t\trt_mutex_deadlock_account_lock(lock, current);\n\t\treturn 1;\n\t}\n\treturn slowfn(lock);\n}\n\nstatic inline void\nrt_mutex_fastunlock(struct rt_mutex *lock,\n\t\t    void (*slowfn)(struct rt_mutex *lock))\n{\n\tif (likely(rt_mutex_cmpxchg(lock, current, null)))\n\t\trt_mutex_deadlock_account_unlock(current);\n\telse\n\t\tslowfn(lock);\n}\n\n\nvoid __sched rt_mutex_lock(struct rt_mutex *lock)\n{\n\tmight_sleep();\n\n\trt_mutex_fastlock(lock, task_uninterruptible, rt_mutex_slowlock);\n}\nexport_symbol_gpl(rt_mutex_lock);\n\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tmight_sleep();\n\n\treturn rt_mutex_fastlock(lock, task_interruptible, rt_mutex_slowlock);\n}\nexport_symbol_gpl(rt_mutex_lock_interruptible);\n\n\nint rt_mutex_timed_futex_lock(struct rt_mutex *lock,\n\t\t\t      struct hrtimer_sleeper *timeout)\n{\n\tmight_sleep();\n\n\treturn rt_mutex_timed_fastlock(lock, task_interruptible, timeout,\n\t\t\t\t       rt_mutex_full_chainwalk,\n\t\t\t\t       rt_mutex_slowlock);\n}\n\n\nint\nrt_mutex_timed_lock(struct rt_mutex *lock, struct hrtimer_sleeper *timeout)\n{\n\tmight_sleep();\n\n\treturn rt_mutex_timed_fastlock(lock, task_interruptible, timeout,\n\t\t\t\t       rt_mutex_min_chainwalk,\n\t\t\t\t       rt_mutex_slowlock);\n}\nexport_symbol_gpl(rt_mutex_timed_lock);\n\n\nint __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\treturn rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n}\nexport_symbol_gpl(rt_mutex_trylock);\n\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}\nexport_symbol_gpl(rt_mutex_unlock);\n\n\nvoid rt_mutex_destroy(struct rt_mutex *lock)\n{\n\twarn_on(rt_mutex_is_locked(lock));\n#ifdef config_debug_rt_mutexes\n\tlock->magic = null;\n#endif\n}\n\nexport_symbol_gpl(rt_mutex_destroy);\n\n\nvoid __rt_mutex_init(struct rt_mutex *lock, const char *name)\n{\n\tlock->owner = null;\n\traw_spin_lock_init(&lock->wait_lock);\n\tlock->waiters = rb_root;\n\tlock->waiters_leftmost = null;\n\n\tdebug_rt_mutex_init(lock, name);\n}\nexport_symbol_gpl(__rt_mutex_init);\n\n\nvoid rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, null);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n\trt_mutex_deadlock_account_lock(lock, proxy_owner);\n}\n\n\nvoid rt_mutex_proxy_unlock(struct rt_mutex *lock,\n\t\t\t   struct task_struct *proxy_owner)\n{\n\tdebug_rt_mutex_proxy_unlock(lock);\n\trt_mutex_set_owner(lock, null);\n\trt_mutex_deadlock_account_unlock(proxy_owner);\n}\n\n\nint rt_mutex_start_proxy_lock(struct rt_mutex *lock,\n\t\t\t      struct rt_mutex_waiter *waiter,\n\t\t\t      struct task_struct *task)\n{\n\tint ret;\n\n\traw_spin_lock(&lock->wait_lock);\n\n\tif (try_to_take_rt_mutex(lock, task, null)) {\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\treturn 1;\n\t}\n\n\t\n\tret = task_blocks_on_rt_mutex(lock, waiter, task,\n\t\t\t\t      rt_mutex_full_chainwalk);\n\n\tif (ret && !rt_mutex_owner(lock)) {\n\t\t\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret))\n\t\tremove_waiter(lock, waiter);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\tdebug_rt_mutex_print_deadlock(waiter);\n\n\treturn ret;\n}\n\n\nstruct task_struct *rt_mutex_next_owner(struct rt_mutex *lock)\n{\n\tif (!rt_mutex_has_waiters(lock))\n\t\treturn null;\n\n\treturn rt_mutex_top_waiter(lock)->task;\n}\n\n\nint rt_mutex_finish_proxy_lock(struct rt_mutex *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter)\n{\n\tint ret;\n\n\traw_spin_lock(&lock->wait_lock);\n\n\tset_current_state(task_interruptible);\n\n\t\n\tret = __rt_mutex_slowlock(lock, task_interruptible, to, waiter);\n\n\tif (unlikely(ret))\n\t\tremove_waiter(lock, waiter);\n\n\t\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\treturn ret;\n}\n\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/syscore_ops.h>\n#include <linux/hrtimer.h>\n#include <linux/sched_clock.h>\n#include <linux/seqlock.h>\n#include <linux/bitops.h>\n\n\nstruct clock_read_data {\n\tu64 epoch_ns;\n\tu64 epoch_cyc;\n\tu64 sched_clock_mask;\n\tu64 (*read_sched_clock)(void);\n\tu32 mult;\n\tu32 shift;\n};\n\n\nstruct clock_data {\n\tseqcount_t\t\tseq;\n\tstruct clock_read_data\tread_data[2];\n\tktime_t\t\t\twrap_kt;\n\tunsigned long\t\trate;\n\n\tu64 (*actual_read_sched_clock)(void);\n};\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\n\ncore_param(irqtime, irqtime, int, 0400);\n\nstatic u64 notrace jiffy_sched_clock_read(void)\n{\n\t\n\treturn (u64)(jiffies - initial_jiffies);\n}\n\nstatic struct clock_data cd ____cacheline_aligned = {\n\t.read_data[0] = { .mult = nsec_per_sec / hz,\n\t\t\t  .read_sched_clock = jiffy_sched_clock_read, },\n\t.actual_read_sched_clock = jiffy_sched_clock_read,\n};\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}\n\nunsigned long long notrace sched_clock(void)\n{\n\tu64 cyc, res;\n\tunsigned long seq;\n\tstruct clock_read_data *rd;\n\n\tdo {\n\t\tseq = raw_read_seqcount(&cd.seq);\n\t\trd = cd.read_data + (seq & 1);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (read_seqcount_retry(&cd.seq, seq));\n\n\treturn res;\n}\n\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t\n\tcd.read_data[1] = *rd;\n\n\t\n\traw_write_seqcount_latch(&cd.seq);\n\n\t\n\tcd.read_data[0] = *rd;\n\n\t\n\traw_write_seqcount_latch(&cd.seq);\n}\n\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}\n\nstatic enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn hrtimer_restart;\n}\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\twarn_on(!irqs_disabled());\n\n\t\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, nsec_per_sec, 3600);\n\n\tnew_mask = clocksource_mask(bits);\n\tcd.rate = rate;\n\n\t\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, null);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'm';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t\n\tres = cyc_to_ns(1ull, new_mult, new_shift);\n\n\tpr_info(\"": 1170, "\", moreprompt);\n\n\t\tkdb_read(buf1, 2); \n\t\tkdb_nextline = 1;\t\n\n\t\t\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'q')) {\n\t\t\t\n\t\t\tkdb_flag_set(cmd_interrupt); \n\t\t\tkdb_state_clear(pager);\n\t\t\t\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"": 1171, "\", name);\n\n\treturn ret;\n}\n\n\nstatic struct dentry *trace_options_init_dentry(struct trace_array *tr)\n{\n\tstruct dentry *d_tracer;\n\n\tif (tr->options)\n\t\treturn tr->options;\n\n\td_tracer = tracing_get_dentry(tr);\n\tif (is_err(d_tracer))\n\t\treturn null;\n\n\ttr->options = tracefs_create_dir(\"": 1172, "\", null };\nconst char *pm_states[pm_suspend_max];\n\nstatic const struct platform_suspend_ops *suspend_ops;\nstatic const struct platform_freeze_ops *freeze_ops;\nstatic declare_wait_queue_head(suspend_freeze_wait_head);\n\nenum freeze_state __read_mostly suspend_freeze_state;\nstatic define_spinlock(suspend_freeze_lock);\n\nvoid freeze_set_ops(const struct platform_freeze_ops *ops)\n{\n\tlock_system_sleep();\n\tfreeze_ops = ops;\n\tunlock_system_sleep();\n}\n\nstatic void freeze_begin(void)\n{\n\tsuspend_freeze_state = freeze_state_none;\n}\n\nstatic void freeze_enter(void)\n{\n\tspin_lock_irq(&suspend_freeze_lock);\n\tif (pm_wakeup_pending())\n\t\tgoto out;\n\n\tsuspend_freeze_state = freeze_state_enter;\n\tspin_unlock_irq(&suspend_freeze_lock);\n\n\tget_online_cpus();\n\tcpuidle_resume();\n\n\t\n\twake_up_all_idle_cpus();\n\tpr_debug(\"": 1173, "\", null);\n\tif (!rcudir)\n\t\tgoto free_out;\n\tretval = debugfs_create_file(\"": 1174, "\", null);\n\tput_filesystem(type);\n\tif (is_err(mnt))\n\t\treturn null;\n\tmntget(mnt);\n\n\treturn mnt;\n}\n\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t\n\tif (tr->dir)\n\t\treturn null;\n\n\tif (warn_on(!debugfs_initialized()))\n\t\treturn err_ptr(-enodev);\n\n\t\n\ttr->dir = debugfs_create_automount(\"": 1175, "\", null,\n\t\t\t\t\t   trace_automount, null);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"": 1176, "\", num_online_cpus());\n#else\n\tseq_puts(m, \"": 1177, "\", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"": 1178, "\", per_cpu_ptr(tr->trace_buffer.data, cpu)->entries >> 10);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_entries_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t cnt, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\tif (!val)\n\t\treturn -einval;\n\n\t\n\tval <<= 10;\n\tret = tracing_resize_ring_buffer(tr, val, tracing_get_cpu(inode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\ntracing_total_entries_read(struct file *filp, char __user *ubuf,\n\t\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r, cpu;\n\tunsigned long size = 0, expanded_size = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\tsize += per_cpu_ptr(tr->trace_buffer.data, cpu)->entries >> 10;\n\t\tif (!ring_buffer_expanded)\n\t\t\texpanded_size += trace_buf_size >> 10;\n\t}\n\tif (ring_buffer_expanded)\n\t\tr = sprintf(buf, \"": 1179, "\", perf_type_breakpoint);\n\n\treturn register_die_notifier(&hw_breakpoint_exceptions_nb);\n\n err_alloc:\n\tfor_each_possible_cpu(err_cpu) {\n\t\tfor (i = 0; i < type_max; i++)\n\t\t\tkfree(get_bp_info(err_cpu, i)->tsk_pinned);\n\t\tif (err_cpu == cpu)\n\t\t\tbreak;\n\t}\n\n\treturn -enomem;\n}\n\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n\nstruct irq_devres {\n\tunsigned int irq;\n\tvoid *dev_id;\n};\n\nstatic void devm_irq_release(struct device *dev, void *res)\n{\n\tstruct irq_devres *this = res;\n\n\tfree_irq(this->irq, this->dev_id);\n}\n\nstatic int devm_irq_match(struct device *dev, void *res, void *data)\n{\n\tstruct irq_devres *this = res, *match = data;\n\n\treturn this->irq == match->irq && this->dev_id == match->dev_id;\n}\n\n\nint devm_request_threaded_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,\n\t\t\t      unsigned long irqflags, const char *devname,\n\t\t\t      void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  gfp_kernel);\n\tif (!dr)\n\t\treturn -enomem;\n\n\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,\n\t\t\t\t  dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nexport_symbol(devm_request_threaded_irq);\n\n\nint devm_request_any_context_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  gfp_kernel);\n\tif (!dr)\n\t\treturn -enomem;\n\n\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nexport_symbol(devm_request_any_context_irq);\n\n\nvoid devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\n\tstruct irq_devres match_data = { irq, dev_id };\n\n\twarn_on(devres_destroy(dev, devm_irq_release, devm_irq_match,\n\t\t\t       &match_data));\n\tfree_irq(irq, dev_id);\n}\nexport_symbol(devm_free_irq);\n\n#include \"": 1180, "\", perf_type_software);\n\tperf_pmu_register(&perf_cpu_clock, null, -1);\n\tperf_pmu_register(&perf_task_clock, null, -1);\n\tperf_tp_register();\n\tperf_cpu_notifier(perf_cpu_notify);\n\tregister_reboot_notifier(&perf_reboot_notifier);\n\n\tret = init_hw_breakpoint();\n\twarn(ret, \"": 1181, "\", perf_type_tracepoint);\n}\n\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg)\n{\n\tchar *filter_str;\n\tint ret;\n\n\tif (event->attr.type != perf_type_tracepoint)\n\t\treturn -einval;\n\n\tfilter_str = strndup_user(arg, page_size);\n\tif (is_err(filter_str))\n\t\treturn ptr_err(filter_str);\n\n\tret = ftrace_profile_set_filter(event, event->attr.config, filter_str);\n\n\tkfree(filter_str);\n\treturn ret;\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n\tftrace_profile_free_filter(event);\n}\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\tstruct bpf_prog *prog;\n\n\tif (event->attr.type != perf_type_tracepoint)\n\t\treturn -einval;\n\n\tif (event->tp_event->prog)\n\t\treturn -eexist;\n\n\tif (!(event->tp_event->flags & trace_event_fl_kprobe))\n\t\t\n\t\treturn -einval;\n\n\tprog = bpf_prog_get(prog_fd);\n\tif (is_err(prog))\n\t\treturn ptr_err(prog);\n\n\tif (prog->type != bpf_prog_type_kprobe) {\n\t\t\n\t\tbpf_prog_put(prog);\n\t\treturn -einval;\n\t}\n\n\tevent->tp_event->prog = prog;\n\n\treturn 0;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n\tstruct bpf_prog *prog;\n\n\tif (!event->tp_event)\n\t\treturn;\n\n\tprog = event->tp_event->prog;\n\tif (prog) {\n\t\tevent->tp_event->prog = null;\n\t\tbpf_prog_put(prog);\n\t}\n}\n\n#else\n\nstatic inline void perf_tp_register(void)\n{\n}\n\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg)\n{\n\treturn -enoent;\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n}\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\treturn -enoent;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n}\n#endif \n\n#ifdef config_have_hw_breakpoint\nvoid perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}\n#endif\n\n\n\nstatic enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = hrtimer_restart;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != perf_event_state_active)\n\t\treturn hrtimer_norestart;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && is_idle_task(current)))\n\t\t\tif (__perf_event_overflow(event, 1, &data, regs))\n\t\t\t\tret = hrtimer_norestart;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}\n\nstatic void perf_swevent_start_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 period;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tperiod = local64_read(&hwc->period_left);\n\tif (period) {\n\t\tif (period < 0)\n\t\t\tperiod = 10000;\n\n\t\tlocal64_set(&hwc->period_left, 0);\n\t} else {\n\t\tperiod = max_t(u64, 10000, hwc->sample_period);\n\t}\n\t__hrtimer_start_range_ns(&hwc->hrtimer,\n\t\t\t\tns_to_ktime(period), 0,\n\t\t\t\thrtimer_mode_rel_pinned, 0);\n}\n\nstatic void perf_swevent_cancel_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (is_sampling_event(event)) {\n\t\tktime_t remaining = hrtimer_get_remaining(&hwc->hrtimer);\n\t\tlocal64_set(&hwc->period_left, ktime_to_ns(remaining));\n\n\t\thrtimer_cancel(&hwc->hrtimer);\n\t}\n}\n\nstatic void perf_swevent_init_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\thrtimer_init(&hwc->hrtimer, clock_monotonic, hrtimer_mode_rel);\n\thwc->hrtimer.function = perf_swevent_hrtimer;\n\n\t\n\tif (event->attr.freq) {\n\t\tlong freq = event->attr.sample_freq;\n\n\t\tevent->attr.sample_period = nsec_per_sec / freq;\n\t\thwc->sample_period = event->attr.sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t\thwc->last_period = hwc->sample_period;\n\t\tevent->attr.freq = 0;\n\t}\n}\n\n\n\nstatic void cpu_clock_event_update(struct perf_event *event)\n{\n\ts64 prev;\n\tu64 now;\n\n\tnow = local_clock();\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tlocal64_add(now - prev, &event->count);\n}\n\nstatic void cpu_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, local_clock());\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void cpu_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & perf_ef_start)\n\t\tcpu_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void cpu_clock_event_del(struct perf_event *event, int flags)\n{\n\tcpu_clock_event_stop(event, flags);\n}\n\nstatic void cpu_clock_event_read(struct perf_event *event)\n{\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != perf_type_software)\n\t\treturn -enoent;\n\n\tif (event->attr.config != perf_count_sw_cpu_clock)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_cpu_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= perf_pmu_cap_no_nmi,\n\n\t.event_init\t= cpu_clock_event_init,\n\t.add\t\t= cpu_clock_event_add,\n\t.del\t\t= cpu_clock_event_del,\n\t.start\t\t= cpu_clock_event_start,\n\t.stop\t\t= cpu_clock_event_stop,\n\t.read\t\t= cpu_clock_event_read,\n};\n\n\n\nstatic void task_clock_event_update(struct perf_event *event, u64 now)\n{\n\tu64 prev;\n\ts64 delta;\n\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tdelta = now - prev;\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void task_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, event->ctx->time);\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void task_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\ttask_clock_event_update(event, event->ctx->time);\n}\n\nstatic int task_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & perf_ef_start)\n\t\ttask_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void task_clock_event_del(struct perf_event *event, int flags)\n{\n\ttask_clock_event_stop(event, perf_ef_update);\n}\n\nstatic void task_clock_event_read(struct perf_event *event)\n{\n\tu64 now = perf_clock();\n\tu64 delta = now - event->ctx->timestamp;\n\tu64 time = event->ctx->time + delta;\n\n\ttask_clock_event_update(event, time);\n}\n\nstatic int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != perf_type_software)\n\t\treturn -enoent;\n\n\tif (event->attr.config != perf_count_sw_task_clock)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_task_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= perf_pmu_cap_no_nmi,\n\n\t.event_init\t= task_clock_event_init,\n\t.add\t\t= task_clock_event_add,\n\t.del\t\t= task_clock_event_del,\n\t.start\t\t= task_clock_event_start,\n\t.stop\t\t= task_clock_event_stop,\n\t.read\t\t= task_clock_event_read,\n};\n\nstatic void perf_pmu_nop_void(struct pmu *pmu)\n{\n}\n\nstatic int perf_pmu_nop_int(struct pmu *pmu)\n{\n\treturn 0;\n}\n\nstatic void perf_pmu_start_txn(struct pmu *pmu)\n{\n\tperf_pmu_disable(pmu);\n}\n\nstatic int perf_pmu_commit_txn(struct pmu *pmu)\n{\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n\nstatic void perf_pmu_cancel_txn(struct pmu *pmu)\n{\n\tperf_pmu_enable(pmu);\n}\n\nstatic int perf_event_idx_default(struct perf_event *event)\n{\n\treturn 0;\n}\n\n\nstatic struct perf_cpu_context __percpu *find_pmu_context(int ctxn)\n{\n\tstruct pmu *pmu;\n\n\tif (ctxn < 0)\n\t\treturn null;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (pmu->task_ctx_nr == ctxn)\n\t\t\treturn pmu->pmu_cpu_context;\n\t}\n\n\treturn null;\n}\n\nstatic void update_pmu_context(struct pmu *pmu, struct pmu *old_pmu)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\n\t\tif (cpuctx->unique_pmu == old_pmu)\n\t\t\tcpuctx->unique_pmu = pmu;\n\t}\n}\n\nstatic void free_pmu_context(struct pmu *pmu)\n{\n\tstruct pmu *i;\n\n\tmutex_lock(&pmus_lock);\n\t\n\tlist_for_each_entry(i, &pmus, entry) {\n\t\tif (i->pmu_cpu_context == pmu->pmu_cpu_context) {\n\t\t\tupdate_pmu_context(i, pmu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfree_percpu(pmu->pmu_cpu_context);\nout:\n\tmutex_unlock(&pmus_lock);\n}\nstatic struct idr pmu_idr;\n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, page_size-1, \"": 1182, "\", period.tv_sec, ms);\n\tif (atomic_read(&overflow_count))\n\t\tseq_printf(m, \"": 1183, "\", pm_states[state]);\n\terror = suspend_prepare(state);\n\tif (error)\n\t\tgoto unlock;\n\n\tif (suspend_test(test_freezer))\n\t\tgoto finish;\n\n\ttrace_suspend_resume(tps(\"": 1184, "\", pm_states[state]);\n\tpm_restrict_gfp_mask();\n\terror = suspend_devices_and_enter(state);\n\tpm_restore_gfp_mask();\n\n finish:\n\tpr_debug(\"": 1185, "\", pmu->hrtimer_interval_ms);\n}\n\nstatic ssize_t\nperf_event_mux_interval_ms_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\tint timer, cpu, ret;\n\n\tret = kstrtoint(buf, 0, &timer);\n\tif (ret)\n\t\treturn ret;\n\n\tif (timer < 1)\n\t\treturn -einval;\n\n\t\n\tif (timer == pmu->hrtimer_interval_ms)\n\t\treturn count;\n\n\tpmu->hrtimer_interval_ms = timer;\n\n\t\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tcpuctx->hrtimer_interval = ns_to_ktime(nsec_per_msec * timer);\n\n\t\tif (hrtimer_active(&cpuctx->hrtimer))\n\t\t\thrtimer_forward_now(&cpuctx->hrtimer, cpuctx->hrtimer_interval);\n\t}\n\n\treturn count;\n}\nstatic device_attr_rw(perf_event_mux_interval_ms);\n\nstatic struct attribute *pmu_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_perf_event_mux_interval_ms.attr,\n\tnull,\n};\nattribute_groups(pmu_dev);\n\nstatic int pmu_bus_running;\nstatic struct bus_type pmu_bus = {\n\t.name\t\t= \"": 1186, "\", pmu->name);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tdev_set_drvdata(pmu->dev, pmu);\n\tpmu->dev->bus = &pmu_bus;\n\tpmu->dev->release = pmu_dev_release;\n\tret = device_add(pmu->dev);\n\tif (ret)\n\t\tgoto free_dev;\n\nout:\n\treturn ret;\n\nfree_dev:\n\tput_device(pmu->dev);\n\tgoto out;\n}\n\nstatic struct lock_class_key cpuctx_mutex;\nstatic struct lock_class_key cpuctx_lock;\n\nint perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -enomem;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, perf_type_max, 0, gfp_kernel);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -enomem;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\n\t\t__perf_cpu_hrtimer_init(cpuctx, cpu);\n\n\t\tcpuctx->unique_pmu = pmu;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_void;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= perf_type_max)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}\nexport_symbol_gpl(perf_pmu_register);\n\nvoid perf_pmu_unregister(struct pmu *pmu)\n{\n\tmutex_lock(&pmus_lock);\n\tlist_del_rcu(&pmu->entry);\n\tmutex_unlock(&pmus_lock);\n\n\t\n\tsynchronize_srcu(&pmus_srcu);\n\tsynchronize_rcu();\n\n\tfree_percpu(pmu->pmu_disable_count);\n\tif (pmu->type >= perf_type_max)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\tfree_pmu_context(pmu);\n}\nexport_symbol_gpl(perf_pmu_unregister);\n\nstatic int perf_try_init_event(struct pmu *pmu, struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = null;\n\tint ret;\n\n\tif (!try_module_get(pmu->module))\n\t\treturn -enodev;\n\n\tif (event->group_leader != event) {\n\t\tctx = perf_event_ctx_lock(event->group_leader);\n\t\tbug_on(!ctx);\n\t}\n\n\tevent->pmu = pmu;\n\tret = pmu->event_init(event);\n\n\tif (ctx)\n\t\tperf_event_ctx_unlock(event->group_leader, ctx);\n\n\tif (ret)\n\t\tmodule_put(pmu->module);\n\n\treturn ret;\n}\n\nstruct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = null;\n\tint idx;\n\tint ret;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (ret)\n\t\t\tpmu = err_ptr(ret);\n\t\tgoto unlock;\n\t}\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\n\t\tif (ret != -enoent) {\n\t\t\tpmu = err_ptr(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = err_ptr(-enoent);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\n\treturn pmu;\n}\n\nstatic void account_event_cpu(struct perf_event *event, int cpu)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (is_cgroup_event(event))\n\t\tatomic_inc(&per_cpu(perf_cgroup_events, cpu));\n}\n\nstatic void account_event(struct perf_event *event)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (event->attach_state & perf_attach_task)\n\t\tstatic_key_slow_inc(&perf_sched_events.key);\n\tif (event->attr.mmap || event->attr.mmap_data)\n\t\tatomic_inc(&nr_mmap_events);\n\tif (event->attr.comm)\n\t\tatomic_inc(&nr_comm_events);\n\tif (event->attr.task)\n\t\tatomic_inc(&nr_task_events);\n\tif (event->attr.freq) {\n\t\tif (atomic_inc_return(&nr_freq_events) == 1)\n\t\t\ttick_nohz_full_kick_all();\n\t}\n\tif (has_branch_stack(event))\n\t\tstatic_key_slow_inc(&perf_sched_events.key);\n\tif (is_cgroup_event(event))\n\t\tstatic_key_slow_inc(&perf_sched_events.key);\n\n\taccount_event_cpu(event, event->cpu);\n}\n\n\nstatic struct perf_event *\nperf_event_alloc(struct perf_event_attr *attr, int cpu,\n\t\t struct task_struct *task,\n\t\t struct perf_event *group_leader,\n\t\t struct perf_event *parent_event,\n\t\t perf_overflow_handler_t overflow_handler,\n\t\t void *context, int cgroup_fd)\n{\n\tstruct pmu *pmu;\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tlong err = -einval;\n\n\tif ((unsigned)cpu >= nr_cpu_ids) {\n\t\tif (!task || cpu != -1)\n\t\t\treturn err_ptr(-einval);\n\t}\n\n\tevent = kzalloc(sizeof(*event), gfp_kernel);\n\tif (!event)\n\t\treturn err_ptr(-enomem);\n\n\t\n\tif (!group_leader)\n\t\tgroup_leader = event;\n\n\tmutex_init(&event->child_mutex);\n\tinit_list_head(&event->child_list);\n\n\tinit_list_head(&event->group_entry);\n\tinit_list_head(&event->event_entry);\n\tinit_list_head(&event->sibling_list);\n\tinit_list_head(&event->rb_entry);\n\tinit_list_head(&event->active_entry);\n\tinit_hlist_node(&event->hlist_entry);\n\n\n\tinit_waitqueue_head(&event->waitq);\n\tinit_irq_work(&event->pending, perf_pending_event);\n\n\tmutex_init(&event->mmap_mutex);\n\n\tatomic_long_set(&event->refcount, 1);\n\tevent->cpu\t\t= cpu;\n\tevent->attr\t\t= *attr;\n\tevent->group_leader\t= group_leader;\n\tevent->pmu\t\t= null;\n\tevent->oncpu\t\t= -1;\n\n\tevent->parent\t\t= parent_event;\n\n\tevent->ns\t\t= get_pid_ns(task_active_pid_ns(current));\n\tevent->id\t\t= atomic64_inc_return(&perf_event_id);\n\n\tevent->state\t\t= perf_event_state_inactive;\n\n\tif (task) {\n\t\tevent->attach_state = perf_attach_task;\n\t\t\n\t\tevent->hw.target = task;\n\t}\n\n\tevent->clock = &local_clock;\n\tif (parent_event)\n\t\tevent->clock = parent_event->clock;\n\n\tif (!overflow_handler && parent_event) {\n\t\toverflow_handler = parent_event->overflow_handler;\n\t\tcontext = parent_event->overflow_handler_context;\n\t}\n\n\tevent->overflow_handler\t= overflow_handler;\n\tevent->overflow_handler_context = context;\n\n\tperf_event__state_init(event);\n\n\tpmu = null;\n\n\thwc = &event->hw;\n\thwc->sample_period = attr->sample_period;\n\tif (attr->freq && attr->sample_freq)\n\t\thwc->sample_period = 1;\n\thwc->last_period = hwc->sample_period;\n\n\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\n\t\n\tif (attr->inherit && (attr->read_format & perf_format_group))\n\t\tgoto err_ns;\n\n\tif (!has_branch_stack(event))\n\t\tevent->attr.branch_sample_type = 0;\n\n\tif (cgroup_fd != -1) {\n\t\terr = perf_cgroup_connect(cgroup_fd, event, attr, group_leader);\n\t\tif (err)\n\t\t\tgoto err_ns;\n\t}\n\n\tpmu = perf_init_event(event);\n\tif (!pmu)\n\t\tgoto err_ns;\n\telse if (is_err(pmu)) {\n\t\terr = ptr_err(pmu);\n\t\tgoto err_ns;\n\t}\n\n\terr = exclusive_event_init(event);\n\tif (err)\n\t\tgoto err_pmu;\n\n\tif (!event->parent) {\n\t\tif (event->attr.sample_type & perf_sample_callchain) {\n\t\t\terr = get_callchain_buffers();\n\t\t\tif (err)\n\t\t\t\tgoto err_per_task;\n\t\t}\n\t}\n\n\treturn event;\n\nerr_per_task:\n\texclusive_event_destroy(event);\n\nerr_pmu:\n\tif (event->destroy)\n\t\tevent->destroy(event);\n\tmodule_put(pmu->module);\nerr_ns:\n\tif (is_cgroup_event(event))\n\t\tperf_detach_cgroup(event);\n\tif (event->ns)\n\t\tput_pid_ns(event->ns);\n\tkfree(event);\n\n\treturn err_ptr(err);\n}\n\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(verify_write, uattr, perf_attr_size_ver0))\n\t\treturn -efault;\n\n\t\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (size > page_size)\t\n\t\tgoto err_size;\n\n\tif (!size)\t\t\n\t\tsize = perf_attr_size_ver0;\n\n\tif (size < perf_attr_size_ver0)\n\t\tgoto err_size;\n\n\t\n\tif (size > sizeof(*attr)) {\n\t\tunsigned char __user *addr;\n\t\tunsigned char __user *end;\n\t\tunsigned char val;\n\n\t\taddr = (void __user *)uattr + sizeof(*attr);\n\t\tend  = (void __user *)uattr + size;\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -efault;\n\n\tif (attr->__reserved_1)\n\t\treturn -einval;\n\n\tif (attr->sample_type & ~(perf_sample_max-1))\n\t\treturn -einval;\n\n\tif (attr->read_format & ~(perf_format_max-1))\n\t\treturn -einval;\n\n\tif (attr->sample_type & perf_sample_branch_stack) {\n\t\tu64 mask = attr->branch_sample_type;\n\n\t\t\n\t\tif (mask & ~(perf_sample_branch_max-1))\n\t\t\treturn -einval;\n\n\t\t\n\t\tif (!(mask & ~perf_sample_branch_plm_all))\n\t\t\treturn -einval;\n\n\t\t\n\t\tif (!(mask & perf_sample_branch_plm_all)) {\n\n\t\t\t\n\t\t\tif (!attr->exclude_kernel)\n\t\t\t\tmask |= perf_sample_branch_kernel;\n\n\t\t\tif (!attr->exclude_user)\n\t\t\t\tmask |= perf_sample_branch_user;\n\n\t\t\tif (!attr->exclude_hv)\n\t\t\t\tmask |= perf_sample_branch_hv;\n\t\t\t\n\t\t\tattr->branch_sample_type = mask;\n\t\t}\n\t\t\n\t\tif ((mask & perf_sample_branch_perm_plm)\n\t\t    && perf_paranoid_kernel() && !capable(cap_sys_admin))\n\t\t\treturn -eacces;\n\t}\n\n\tif (attr->sample_type & perf_sample_regs_user) {\n\t\tret = perf_reg_validate(attr->sample_regs_user);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (attr->sample_type & perf_sample_stack_user) {\n\t\tif (!arch_perf_have_user_stack_dump())\n\t\t\treturn -enosys;\n\n\t\t\n\t\tif (attr->sample_stack_user >= ushrt_max)\n\t\t\tret = -einval;\n\t\telse if (!is_aligned(attr->sample_stack_user, sizeof(u64)))\n\t\t\tret = -einval;\n\t}\n\n\tif (attr->sample_type & perf_sample_regs_intr)\n\t\tret = perf_reg_validate(attr->sample_regs_intr);\nout:\n\treturn ret;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\tret = -e2big;\n\tgoto out;\n}\n\nstatic int\nperf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = null;\n\tint ret = -einval;\n\n\tif (!output_event)\n\t\tgoto set;\n\n\t\n\tif (event == output_event)\n\t\tgoto out;\n\n\t\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\n\t\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\n\n\t\n\tif (output_event->clock != event->clock)\n\t\tgoto out;\n\n\t\n\tif (has_aux(event) && has_aux(output_event) &&\n\t    event->pmu != output_event->pmu)\n\t\tgoto out;\n\nset:\n\tmutex_lock(&event->mmap_mutex);\n\t\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\n\tif (output_event) {\n\t\t\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\n\tring_buffer_attach(event, rb);\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\nout:\n\treturn ret;\n}\n\nstatic void mutex_lock_double(struct mutex *a, struct mutex *b)\n{\n\tif (b < a)\n\t\tswap(a, b);\n\n\tmutex_lock(a);\n\tmutex_lock_nested(b, single_depth_nesting);\n}\n\nstatic int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)\n{\n\tbool nmi_safe = false;\n\n\tswitch (clk_id) {\n\tcase clock_monotonic:\n\t\tevent->clock = &ktime_get_mono_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase clock_monotonic_raw:\n\t\tevent->clock = &ktime_get_raw_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase clock_realtime:\n\t\tevent->clock = &ktime_get_real_ns;\n\t\tbreak;\n\n\tcase clock_boottime:\n\t\tevent->clock = &ktime_get_boot_ns;\n\t\tbreak;\n\n\tcase clock_tai:\n\t\tevent->clock = &ktime_get_tai_ns;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\tif (!nmi_safe && !(event->pmu->capabilities & perf_pmu_cap_no_nmi))\n\t\treturn -einval;\n\n\treturn 0;\n}\n\n\nsyscall_define5(perf_event_open,\n\t\tstruct perf_event_attr __user *, attr_uptr,\n\t\tpid_t, pid, int, cpu, int, group_fd, unsigned long, flags)\n{\n\tstruct perf_event *group_leader = null, *output_event = null;\n\tstruct perf_event *event, *sibling;\n\tstruct perf_event_attr attr;\n\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n\tstruct file *event_file = null;\n\tstruct fd group = {null, 0};\n\tstruct task_struct *task = null;\n\tstruct pmu *pmu;\n\tint event_fd;\n\tint move_group = 0;\n\tint err;\n\tint f_flags = o_rdwr;\n\tint cgroup_fd = -1;\n\n\t\n\tif (flags & ~perf_flag_all)\n\t\treturn -einval;\n\n\terr = perf_copy_attr(attr_uptr, &attr);\n\tif (err)\n\t\treturn err;\n\n\tif (!attr.exclude_kernel) {\n\t\tif (perf_paranoid_kernel() && !capable(cap_sys_admin))\n\t\t\treturn -eacces;\n\t}\n\n\tif (attr.freq) {\n\t\tif (attr.sample_freq > sysctl_perf_event_sample_rate)\n\t\t\treturn -einval;\n\t} else {\n\t\tif (attr.sample_period & (1ull << 63))\n\t\t\treturn -einval;\n\t}\n\n\t\n\tif ((flags & perf_flag_pid_cgroup) && (pid == -1 || cpu == -1))\n\t\treturn -einval;\n\n\tif (flags & perf_flag_fd_cloexec)\n\t\tf_flags |= o_cloexec;\n\n\tevent_fd = get_unused_fd_flags(f_flags);\n\tif (event_fd < 0)\n\t\treturn event_fd;\n\n\tif (group_fd != -1) {\n\t\terr = perf_fget_light(group_fd, &group);\n\t\tif (err)\n\t\t\tgoto err_fd;\n\t\tgroup_leader = group.file->private_data;\n\t\tif (flags & perf_flag_fd_output)\n\t\t\toutput_event = group_leader;\n\t\tif (flags & perf_flag_fd_no_group)\n\t\t\tgroup_leader = null;\n\t}\n\n\tif (pid != -1 && !(flags & perf_flag_pid_cgroup)) {\n\t\ttask = find_lively_task_by_vpid(pid);\n\t\tif (is_err(task)) {\n\t\t\terr = ptr_err(task);\n\t\t\tgoto err_group_fd;\n\t\t}\n\t}\n\n\tif (task && group_leader &&\n\t    group_leader->attr.inherit != attr.inherit) {\n\t\terr = -einval;\n\t\tgoto err_task;\n\t}\n\n\tget_online_cpus();\n\n\tif (flags & perf_flag_pid_cgroup)\n\t\tcgroup_fd = pid;\n\n\tevent = perf_event_alloc(&attr, cpu, task, group_leader, null,\n\t\t\t\t null, null, cgroup_fd);\n\tif (is_err(event)) {\n\t\terr = ptr_err(event);\n\t\tgoto err_cpus;\n\t}\n\n\tif (is_sampling_event(event)) {\n\t\tif (event->pmu->capabilities & perf_pmu_cap_no_interrupt) {\n\t\t\terr = -enotsupp;\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\taccount_event(event);\n\n\t\n\tpmu = event->pmu;\n\n\tif (attr.use_clockid) {\n\t\terr = perf_event_set_clock(event, attr.clockid);\n\t\tif (err)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (group_leader &&\n\t    (is_software_event(event) != is_software_event(group_leader))) {\n\t\tif (is_software_event(event)) {\n\t\t\t\n\t\t\tpmu = group_leader->pmu;\n\t\t} else if (is_software_event(group_leader) &&\n\t\t\t   (group_leader->group_flags & perf_group_software)) {\n\t\t\t\n\t\t\tmove_group = 1;\n\t\t}\n\t}\n\n\t\n\tctx = find_get_context(pmu, task, event);\n\tif (is_err(ctx)) {\n\t\terr = ptr_err(ctx);\n\t\tgoto err_alloc;\n\t}\n\n\tif ((pmu->capabilities & perf_pmu_cap_exclusive) && group_leader) {\n\t\terr = -ebusy;\n\t\tgoto err_context;\n\t}\n\n\tif (task) {\n\t\tput_task_struct(task);\n\t\ttask = null;\n\t}\n\n\t\n\tif (group_leader) {\n\t\terr = -einval;\n\n\t\t\n\t\tif (group_leader->group_leader != group_leader)\n\t\t\tgoto err_context;\n\n\t\t\n\t\tif (group_leader->clock != event->clock)\n\t\t\tgoto err_context;\n\n\t\t\n\t\tif (move_group) {\n\t\t\t\n\t\t\tif (group_leader->ctx->task != ctx->task)\n\t\t\t\tgoto err_context;\n\n\t\t\t\n\t\t\tif (group_leader->cpu != event->cpu)\n\t\t\t\tgoto err_context;\n\t\t} else {\n\t\t\tif (group_leader->ctx != ctx)\n\t\t\t\tgoto err_context;\n\t\t}\n\n\t\t\n\t\tif (attr.exclusive || attr.pinned)\n\t\t\tgoto err_context;\n\t}\n\n\tif (output_event) {\n\t\terr = perf_event_set_output(event, output_event);\n\t\tif (err)\n\t\t\tgoto err_context;\n\t}\n\n\tevent_file = anon_inode_getfile(\"": 1187, "\", pmu->name, ret);\n\t}\n\tpmu_bus_running = 1;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}\ndevice_initcall(perf_event_sysfs_init);\n\n#ifdef config_cgroup_perf\nstatic struct cgroup_subsys_state *\nperf_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct perf_cgroup *jc;\n\n\tjc = kzalloc(sizeof(*jc), gfp_kernel);\n\tif (!jc)\n\t\treturn err_ptr(-enomem);\n\n\tjc->info = alloc_percpu(struct perf_cgroup_info);\n\tif (!jc->info) {\n\t\tkfree(jc);\n\t\treturn err_ptr(-enomem);\n\t}\n\n\treturn &jc->css;\n}\n\nstatic void perf_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct perf_cgroup *jc = container_of(css, struct perf_cgroup, css);\n\n\tfree_percpu(jc->info);\n\tkfree(jc);\n}\n\nstatic int __perf_cgroup_move(void *info)\n{\n\tstruct task_struct *task = info;\n\tperf_cgroup_switch(task, perf_cgroup_swout | perf_cgroup_swin);\n\treturn 0;\n}\n\nstatic void perf_cgroup_attach(struct cgroup_subsys_state *css,\n\t\t\t       struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\n\tcgroup_taskset_for_each(task, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n\nstatic void perf_cgroup_exit(struct cgroup_subsys_state *css,\n\t\t\t     struct cgroup_subsys_state *old_css,\n\t\t\t     struct task_struct *task)\n{\n\t\n\tif (!(task->flags & pf_exiting))\n\t\treturn;\n\n\ttask_function_call(task, __perf_cgroup_move, task);\n}\n\nstruct cgroup_subsys perf_event_cgrp_subsys = {\n\t.css_alloc\t= perf_cgroup_css_alloc,\n\t.css_free\t= perf_cgroup_css_free,\n\t.exit\t\t= perf_cgroup_exit,\n\t.attach\t\t= perf_cgroup_attach,\n};\n#endif \n\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/jhash.h>\n#include <linux/init.h>\n#include <linux/futex.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/signal.h>\n#include <linux/export.h>\n#include <linux/magic.h>\n#include <linux/pid.h>\n#include <linux/nsproxy.h>\n#include <linux/ptrace.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/freezer.h>\n#include <linux/bootmem.h>\n\n#include <asm/futex.h>\n\n#include \"": 1188, "\", pmu->type);\n}\nstatic device_attr_ro(type);\n\nstatic ssize_t\nperf_event_mux_interval_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, page_size-1, \"": 1189, "\", pmu_attr->event_str);\n\n\treturn 0;\n}\n\nstatic int __init perf_event_sysfs_init(void)\n{\n\tstruct pmu *pmu;\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\n\tret = bus_register(&pmu_bus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (!pmu->name || pmu->type < 0)\n\t\t\tcontinue;\n\n\t\tret = pmu_dev_alloc(pmu);\n\t\twarn(ret, \"": 1190, "\", prefix);\n\t\t} else {\n\t\t\tlen += 3;\n\t\t\tif (prefix > 999)\n\t\t\t\tlen += 3;\n\t\t\telse if (prefix > 99)\n\t\t\t\tlen += 2;\n\t\t\telse if (prefix > 9)\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\tlen += print_time(msg->ts_nsec, buf ? buf + len : null);\n\treturn len;\n}\n\nstatic size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,\n\t\t\t     bool syslog, char *buf, size_t size)\n{\n\tconst char *text = log_text(msg);\n\tsize_t text_size = msg->text_len;\n\tbool prefix = true;\n\tbool newline = true;\n\tsize_t len = 0;\n\n\tif ((prev & log_cont) && !(msg->flags & log_prefix))\n\t\tprefix = false;\n\n\tif (msg->flags & log_cont) {\n\t\tif ((prev & log_cont) && !(prev & log_newline))\n\t\t\tprefix = false;\n\n\t\tif (!(msg->flags & log_newline))\n\t\t\tnewline = false;\n\t}\n\n\tdo {\n\t\tconst char *next = memchr(text, '\\n', text_size);\n\t\tsize_t text_len;\n\n\t\tif (next) {\n\t\t\ttext_len = next - text;\n\t\t\tnext++;\n\t\t\ttext_size -= next - text;\n\t\t} else {\n\t\t\ttext_len = text_size;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (print_prefix(msg, syslog, null) +\n\t\t\t    text_len + 1 >= size - len)\n\t\t\t\tbreak;\n\n\t\t\tif (prefix)\n\t\t\t\tlen += print_prefix(msg, syslog, buf + len);\n\t\t\tmemcpy(buf + len, text, text_len);\n\t\t\tlen += text_len;\n\t\t\tif (next || newline)\n\t\t\t\tbuf[len++] = '\\n';\n\t\t} else {\n\t\t\t\n\t\t\tif (prefix)\n\t\t\t\tlen += print_prefix(msg, syslog, null);\n\t\t\tlen += text_len;\n\t\t\tif (next || newline)\n\t\t\t\tlen++;\n\t\t}\n\n\t\tprefix = true;\n\t\ttext = next;\n\t} while (text);\n\n\treturn len;\n}\n\nstatic int syslog_print(char __user *buf, int size)\n{\n\tchar *text;\n\tstruct printk_log *msg;\n\tint len = 0;\n\n\ttext = kmalloc(log_line_max + prefix_max, gfp_kernel);\n\tif (!text)\n\t\treturn -enomem;\n\n\twhile (size > 0) {\n\t\tsize_t n;\n\t\tsize_t skip;\n\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_prev = 0;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (syslog_seq == log_next_seq) {\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = syslog_partial;\n\t\tmsg = log_from_idx(syslog_idx);\n\t\tn = msg_print_text(msg, syslog_prev, true, text,\n\t\t\t\t   log_line_max + prefix_max);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t\n\t\t\tsyslog_idx = log_next(syslog_idx);\n\t\t\tsyslog_seq++;\n\t\t\tsyslog_prev = msg->flags;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t\n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, text + skip, n)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -efault;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t}\n\n\tkfree(text);\n\treturn len;\n}\n\nstatic int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tchar *text;\n\tint len = 0;\n\n\ttext = kmalloc(log_line_max + prefix_max, gfp_kernel);\n\tif (!text)\n\t\treturn -enomem;\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tif (buf) {\n\t\tu64 next_seq;\n\t\tu64 seq;\n\t\tu32 idx;\n\t\tenum log_flags prev;\n\n\t\tif (clear_seq < log_first_seq) {\n\t\t\t\n\t\t\tclear_seq = log_first_seq;\n\t\t\tclear_idx = log_first_idx;\n\t\t}\n\n\t\t\n\t\tseq = clear_seq;\n\t\tidx = clear_idx;\n\t\tprev = 0;\n\t\twhile (seq < log_next_seq) {\n\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\tlen += msg_print_text(msg, prev, true, null, 0);\n\t\t\tprev = msg->flags;\n\t\t\tidx = log_next(idx);\n\t\t\tseq++;\n\t\t}\n\n\t\t\n\t\tseq = clear_seq;\n\t\tidx = clear_idx;\n\t\tprev = 0;\n\t\twhile (len > size && seq < log_next_seq) {\n\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\tlen -= msg_print_text(msg, prev, true, null, 0);\n\t\t\tprev = msg->flags;\n\t\t\tidx = log_next(idx);\n\t\t\tseq++;\n\t\t}\n\n\t\t\n\t\tnext_seq = log_next_seq;\n\n\t\tlen = 0;\n\t\twhile (len >= 0 && seq < next_seq) {\n\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\t\t\tint textlen;\n\n\t\t\ttextlen = msg_print_text(msg, prev, true, text,\n\t\t\t\t\t\t log_line_max + prefix_max);\n\t\t\tif (textlen < 0) {\n\t\t\t\tlen = textlen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx = log_next(idx);\n\t\t\tseq++;\n\t\t\tprev = msg->flags;\n\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\t\tlen = -efault;\n\t\t\telse\n\t\t\t\tlen += textlen;\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\n\t\t\tif (seq < log_first_seq) {\n\t\t\t\t\n\t\t\t\tseq = log_first_seq;\n\t\t\t\tidx = log_first_idx;\n\t\t\t\tprev = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (clear) {\n\t\tclear_seq = log_next_seq;\n\t\tclear_idx = log_next_idx;\n\t}\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\tkfree(text);\n\treturn len;\n}\n\nint do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = loglevel_default;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase syslog_action_close:\t\n\t\tbreak;\n\tcase syslog_action_open:\t\n\t\tbreak;\n\tcase syslog_action_read:\t\n\t\terror = -einval;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(verify_write, buf, len)) {\n\t\t\terror = -efault;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t\n\tcase syslog_action_read_clear:\n\t\tclear = true;\n\t\t\n\t\n\tcase syslog_action_read_all:\n\t\terror = -einval;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(verify_write, buf, len)) {\n\t\t\terror = -efault;\n\t\t\tgoto out;\n\t\t}\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t\n\tcase syslog_action_clear:\n\t\tsyslog_print_all(null, 0, true);\n\t\tbreak;\n\t\n\tcase syslog_action_console_off:\n\t\tif (saved_console_loglevel == loglevel_default)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t\n\tcase syslog_action_console_on:\n\t\tif (saved_console_loglevel != loglevel_default) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = loglevel_default;\n\t\t}\n\t\tbreak;\n\t\n\tcase syslog_action_console_level:\n\t\terror = -einval;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t\n\t\tsaved_console_loglevel = loglevel_default;\n\t\terror = 0;\n\t\tbreak;\n\t\n\tcase syslog_action_size_unread:\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_prev = 0;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (from_file) {\n\t\t\t\n\t\t\terror = log_next_seq - syslog_seq;\n\t\t} else {\n\t\t\tu64 seq = syslog_seq;\n\t\t\tu32 idx = syslog_idx;\n\t\t\tenum log_flags prev = syslog_prev;\n\n\t\t\terror = 0;\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\t\terror += msg_print_text(msg, prev, true, null, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t\tprev = msg->flags;\n\t\t\t}\n\t\t\terror -= syslog_partial;\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tbreak;\n\t\n\tcase syslog_action_size_buffer:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -einval;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}\n\nsyscall_define3(syslog, int, type, char __user *, buf, int, len)\n{\n\treturn do_syslog(type, buf, len, syslog_from_reader);\n}\n\n\nstatic void call_console_drivers(int level, const char *text, size_t len)\n{\n\tstruct console *con;\n\n\ttrace_console(text, len);\n\n\tif (level >= console_loglevel && !ignore_loglevel)\n\t\treturn;\n\tif (!console_drivers)\n\t\treturn;\n\n\tfor_each_console(con) {\n\t\tif (exclusive_console && con != exclusive_console)\n\t\t\tcontinue;\n\t\tif (!(con->flags & con_enabled))\n\t\t\tcontinue;\n\t\tif (!con->write)\n\t\t\tcontinue;\n\t\tif (!cpu_online(smp_processor_id()) &&\n\t\t    !(con->flags & con_anytime))\n\t\t\tcontinue;\n\t\tcon->write(con, text, len);\n\t}\n}\n\n\nstatic void zap_locks(void)\n{\n\tstatic unsigned long oops_timestamp;\n\n\tif (time_after_eq(jiffies, oops_timestamp) &&\n\t    !time_after(jiffies, oops_timestamp + 30 * hz))\n\t\treturn;\n\n\toops_timestamp = jiffies;\n\n\tdebug_locks_off();\n\t\n\traw_spin_lock_init(&logbuf_lock);\n\t\n\tsema_init(&console_sem, 1);\n}\n\n\nstatic int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif (con->flags & con_anytime)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n\nstatic inline int can_use_console(unsigned int cpu)\n{\n\treturn cpu_online(cpu) || have_callable_console();\n}\n\n\nstatic int console_trylock_for_printk(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\n\tif (!console_trylock())\n\t\treturn 0;\n\t\n\tif (!can_use_console(cpu)) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint printk_delay_msec __read_mostly;\n\nstatic inline void printk_delay(void)\n{\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}\n\n\nstatic struct cont {\n\tchar buf[log_line_max];\n\tsize_t len;\t\t\t\n\tsize_t cons;\t\t\t\n\tstruct task_struct *owner;\t\n\tu64 ts_nsec;\t\t\t\n\tu8 level;\t\t\t\n\tu8 facility;\t\t\t\n\tenum log_flags flags;\t\t\n\tbool flushed:1;\t\t\t\n} cont;\n\nstatic void cont_flush(enum log_flags flags)\n{\n\tif (cont.flushed)\n\t\treturn;\n\tif (cont.len == 0)\n\t\treturn;\n\n\tif (cont.cons) {\n\t\t\n\t\tlog_store(cont.facility, cont.level, flags | log_nocons,\n\t\t\t  cont.ts_nsec, null, 0, cont.buf, cont.len);\n\t\tcont.flags = flags;\n\t\tcont.flushed = true;\n\t} else {\n\t\t\n\t\tlog_store(cont.facility, cont.level, flags, 0,\n\t\t\t  null, 0, cont.buf, cont.len);\n\t\tcont.len = 0;\n\t}\n}\n\nstatic bool cont_add(int facility, int level, const char *text, size_t len)\n{\n\tif (cont.len && cont.flushed)\n\t\treturn false;\n\n\tif (cont.len + len > sizeof(cont.buf)) {\n\t\t\n\t\tcont_flush(log_cont);\n\t\treturn false;\n\t}\n\n\tif (!cont.len) {\n\t\tcont.facility = facility;\n\t\tcont.level = level;\n\t\tcont.owner = current;\n\t\tcont.ts_nsec = local_clock();\n\t\tcont.flags = 0;\n\t\tcont.cons = 0;\n\t\tcont.flushed = false;\n\t}\n\n\tmemcpy(cont.buf + cont.len, text, len);\n\tcont.len += len;\n\n\tif (cont.len > (sizeof(cont.buf) * 80) / 100)\n\t\tcont_flush(log_cont);\n\n\treturn true;\n}\n\nstatic size_t cont_print_text(char *text, size_t size)\n{\n\tsize_t textlen = 0;\n\tsize_t len;\n\n\tif (cont.cons == 0 && (console_prev & log_newline)) {\n\t\ttextlen += print_time(cont.ts_nsec, text);\n\t\tsize -= textlen;\n\t}\n\n\tlen = cont.len - cont.cons;\n\tif (len > 0) {\n\t\tif (len+1 > size)\n\t\t\tlen = size-1;\n\t\tmemcpy(text + textlen, cont.buf + cont.cons, len);\n\t\ttextlen += len;\n\t\tcont.cons = cont.len;\n\t}\n\n\tif (cont.flushed) {\n\t\tif (cont.flags & log_newline)\n\t\t\ttext[textlen++] = '\\n';\n\t\t\n\t\tcont.len = 0;\n\t}\n\treturn textlen;\n}\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tstatic int recursion_bug;\n\tstatic char textbuf[log_line_max];\n\tchar *text = textbuf;\n\tsize_t text_len = 0;\n\tenum log_flags lflags = 0;\n\tunsigned long flags;\n\tint this_cpu;\n\tint printed_len = 0;\n\tbool in_sched = false;\n\t\n\tstatic unsigned int logbuf_cpu = uint_max;\n\n\tif (level == loglevel_sched) {\n\t\tlevel = loglevel_default;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\n\t\n\tif (unlikely(logbuf_cpu == this_cpu)) {\n\t\t\n\t\tif (!oops_in_progress && !lockdep_recursing(current)) {\n\t\t\trecursion_bug = 1;\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tzap_locks();\n\t}\n\n\tlockdep_off();\n\traw_spin_lock(&logbuf_lock);\n\tlogbuf_cpu = this_cpu;\n\n\tif (unlikely(recursion_bug)) {\n\t\tstatic const char recursion_msg[] =\n\t\t\t\"": 1191, "\", ptr);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec;\n\n\tif (iter->flags & ftrace_iter_hash)\n\t\treturn t_hash_show(m, iter);\n\n\tif (iter->flags & ftrace_iter_printall) {\n\t\tif (iter->flags & ftrace_iter_notrace)\n\t\t\tseq_puts(m, \"": 1192, "\", r);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\nrb_simple_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buffer) {\n\t\tmutex_lock(&trace_types_lock);\n\t\tif (val) {\n\t\t\ttracer_tracing_on(tr);\n\t\t\tif (tr->current_trace->start)\n\t\t\t\ttr->current_trace->start(tr);\n\t\t} else {\n\t\t\ttracer_tracing_off(tr);\n\t\t\tif (tr->current_trace->stop)\n\t\t\t\ttr->current_trace->stop(tr);\n\t\t}\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\t(*ppos)++;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations rb_simple_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= rb_simple_read,\n\t.write\t\t= rb_simple_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= default_llseek,\n};\n\nstruct dentry *trace_instance_dir;\n\nstatic void\ninit_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer);\n\nstatic int\nallocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = trace_flags & trace_iter_overwrite ? rb_fl_overwrite : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -enomem;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -enomem;\n\t}\n\n\t\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}\n\nstatic int allocate_trace_buffers(struct trace_array *tr, int size)\n{\n\tint ret;\n\n\tret = allocate_trace_buffer(tr, &tr->trace_buffer, size);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef config_tracer_max_trace\n\tret = allocate_trace_buffer(tr, &tr->max_buffer,\n\t\t\t\t    allocate_snapshot ? size : 1);\n\tif (warn_on(ret)) {\n\t\tring_buffer_free(tr->trace_buffer.buffer);\n\t\tfree_percpu(tr->trace_buffer.data);\n\t\treturn -enomem;\n\t}\n\ttr->allocated_snapshot = allocate_snapshot;\n\n\t\n\tallocate_snapshot = false;\n#endif\n\treturn 0;\n}\n\nstatic void free_trace_buffer(struct trace_buffer *buf)\n{\n\tif (buf->buffer) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = null;\n\t\tfree_percpu(buf->data);\n\t\tbuf->data = null;\n\t}\n}\n\nstatic void free_trace_buffers(struct trace_array *tr)\n{\n\tif (!tr)\n\t\treturn;\n\n\tfree_trace_buffer(&tr->trace_buffer);\n\n#ifdef config_tracer_max_trace\n\tfree_trace_buffer(&tr->max_buffer);\n#endif\n}\n\nstatic int instance_mkdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = -eexist;\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = -enomem;\n\ttr = kzalloc(sizeof(*tr), gfp_kernel);\n\tif (!tr)\n\t\tgoto out_unlock;\n\n\ttr->name = kstrdup(name, gfp_kernel);\n\tif (!tr->name)\n\t\tgoto out_free_tr;\n\n\tif (!alloc_cpumask_var(&tr->tracing_cpumask, gfp_kernel))\n\t\tgoto out_free_tr;\n\n\tcpumask_copy(tr->tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&tr->start_lock);\n\n\ttr->max_lock = (arch_spinlock_t)__arch_spin_lock_unlocked;\n\n\ttr->current_trace = &nop_trace;\n\n\tinit_list_head(&tr->systems);\n\tinit_list_head(&tr->events);\n\n\tif (allocate_trace_buffers(tr, trace_buf_size) < 0)\n\t\tgoto out_free_tr;\n\n\ttr->dir = tracefs_create_dir(name, trace_instance_dir);\n\tif (!tr->dir)\n\t\tgoto out_free_tr;\n\n\tret = event_trace_add_tracer(tr->dir, tr);\n\tif (ret) {\n\t\ttracefs_remove_recursive(tr->dir);\n\t\tgoto out_free_tr;\n\t}\n\n\tinit_tracer_tracefs(tr, tr->dir);\n\n\tlist_add(&tr->list, &ftrace_trace_arrays);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n\n out_free_tr:\n\tfree_trace_buffers(tr);\n\tfree_cpumask_var(tr->tracing_cpumask);\n\tkfree(tr->name);\n\tkfree(tr);\n\n out_unlock:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n\n}\n\nstatic int instance_rmdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint found = 0;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = -enodev;\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tgoto out_unlock;\n\n\tret = -ebusy;\n\tif (tr->ref || (tr->current_trace && tr->current_trace->ref))\n\t\tgoto out_unlock;\n\n\tlist_del(&tr->list);\n\n\ttracing_set_nop(tr);\n\tevent_trace_del_tracer(tr);\n\tftrace_destroy_function_files(tr);\n\tdebugfs_remove_recursive(tr->dir);\n\tfree_trace_buffers(tr);\n\n\tkfree(tr->name);\n\tkfree(tr);\n\n\tret = 0;\n\n out_unlock:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic __init void create_trace_instances(struct dentry *d_tracer)\n{\n\ttrace_instance_dir = tracefs_create_instance_dir(\"": 1193, "\", rcu_bh_ctrlblk.qlen);\n\treturn 0;\n}\n\nstatic int show_tiny_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, show_tiny_stats, null);\n}\n\nstatic const struct file_operations show_tiny_stats_fops = {\n\t.owner = this_module,\n\t.open = show_tiny_stats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic struct dentry *rcudir;\n\nstatic int __init rcutiny_trace_init(void)\n{\n\tstruct dentry *retval;\n\n\trcudir = debugfs_create_dir(\"": 1194, "\", rcu_sched_ctrlblk.qlen);\n\tseq_printf(m, \"": 1195, "\", read);\n}\n\nvoid __init sched_clock_postinit(void)\n{\n\t\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, bits_per_long, hz);\n\n\tupdate_sched_clock();\n\n\t\n\thrtimer_init(&sched_clock_timer, clock_monotonic, hrtimer_mode_rel);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, hrtimer_mode_rel);\n}\n\n\nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned long seq = raw_read_seqcount(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}\n\nstatic int sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}\n\nstatic void sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, hrtimer_mode_rel);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}\n\nstatic struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};\n\nstatic int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}\ndevice_initcall(sched_clock_syscore_init);\n#ifndef __trace_events_h\n#define __trace_events_h\n\n#include <linux/trace_seq.h>\n#include \"": 1196, "\", rec->%s\"": 1197, "\", ret);\n\n\t\n\tjump_label_rate_limit(&perf_sched_events, hz);\n\n\t\n\tbuild_bug_on((offsetof(struct perf_event_mmap_page, data_head))\n\t\t     != 1024);\n}\n\nssize_t perf_event_sysfs_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr =\n\t\tcontainer_of(attr, struct perf_pmu_events_attr, attr);\n\n\tif (pmu_attr->event_str)\n\t\treturn sprintf(page, \"": 1198, "\", ret);\n\n\treturn 0;\n}\n\nstatic int noop_count(struct lock_list *entry, void *data)\n{\n\t(*(unsigned long *)data)++;\n\treturn 0;\n}\n\nstatic unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}\nunsigned long lockdep_count_forward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = null;\n\tthis.class = class;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_forward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\nstatic unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}\n\nunsigned long lockdep_count_backward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = null;\n\tthis.class = class;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_backward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\n\nstatic noinline int\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}\n\n#if defined(config_trace_irqflags) && defined(config_prove_locking)\n\n\nstatic inline int usage_match(struct lock_list *entry, void *bit)\n{\n\treturn entry->class->usage_mask & (1 << (enum lock_usage_bit)bit);\n}\n\n\n\n\nstatic int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}\n\n\nstatic int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"": 1199, "\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\nout:\n\treturn ret ? ret : locked;\n}\n\n\nstatic void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t\n\tset_current_state(task_interruptible);\n\tqueue_me(q, hb);\n\n\t\n\tif (timeout) {\n\t\thrtimer_start_expires(&timeout->timer, hrtimer_mode_abs);\n\t\tif (!hrtimer_active(&timeout->timer))\n\t\t\ttimeout->task = null;\n\t}\n\n\t\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(task_running);\n}\n\n\nstatic int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t\nretry:\n\tret = get_futex_key(uaddr, flags & flags_shared, &q->key, verify_read);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & flags_shared))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -ewouldblock;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}\n\nstatic int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = null;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -einval;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & flags_clockrt) ?\n\t\t\t\t      clock_realtime : clock_monotonic,\n\t\t\t\t      hrtimer_mode_abs);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t\n\tret = 0;\n\t\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -etimedout;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -erestartsys;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | flags_has_timeout;\n\n\tret = -erestart_restartblock;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n\n\nstatic long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = null;\n\n\tif (restart->futex.flags & flags_has_timeout) {\n\t\tt.tv64 = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}\n\n\n\nstatic int futex_lock_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = null;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (refill_pi_state_cache())\n\t\treturn -enomem;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clock_realtime,\n\t\t\t\t      hrtimer_mode_abs);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & flags_shared, &q.key, verify_write);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -efault:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -eagain:\n\t\t\t\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\t\n\tqueue_me(&q, hb);\n\n\twarn_on(!q.pi_state);\n\t\n\tif (!trylock) {\n\t\tret = rt_mutex_timed_futex_lock(&q.pi_state->pi_mutex, to);\n\t} else {\n\t\tret = rt_mutex_trylock(&q.pi_state->pi_mutex);\n\t\t\n\t\tret = ret ? 0 : -ewouldblock;\n\t}\n\n\tspin_lock(q.lock_ptr);\n\t\n\tres = fixup_owner(uaddr, &q, !ret);\n\t\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current))\n\t\trt_mutex_unlock(&q.pi_state->pi_mutex);\n\n\t\n\tunqueue_me_pi(&q);\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to)\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\treturn ret != -eintr ? ret : -erestartnointr;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & flags_shared))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}\n\n\nstatic int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = futex_key_init;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *match;\n\tint ret;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -efault;\n\t\n\tif ((uval & futex_tid_mask) != vpid)\n\t\treturn -eperm;\n\n\tret = get_futex_key(uaddr, flags & flags_shared, &key, verify_write);\n\tif (ret)\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\n\t\n\tmatch = futex_top_waiter(hb, &key);\n\tif (match) {\n\t\tret = wake_futex_pi(uaddr, uval, match);\n\t\t\n\t\tif (ret == -efault)\n\t\t\tgoto pi_faulted;\n\t\tgoto out_unlock;\n\t}\n\n\t\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0))\n\t\tgoto pi_faulted;\n\n\t\n\tret = (curval == uval) ? 0 : -eagain;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\n\tput_futex_key(&key);\n\treturn ret;\n\npi_faulted:\n\tspin_unlock(&hb->lock);\n\tput_futex_key(&key);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}\n\n\nstatic inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q, union futex_key *key2,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret = 0;\n\n\t\n\tif (!match_futex(&q->key, key2)) {\n\t\twarn_on(q->lock_ptr && (&hb->lock != q->lock_ptr));\n\t\t\n\t\tplist_del(&q->list, &hb->chain);\n\t\thb_waiters_dec(hb);\n\n\t\t\n\t\tret = -ewouldblock;\n\t\tif (timeout && !timeout->task)\n\t\t\tret = -etimedout;\n\t\telse if (signal_pending(current))\n\t\t\tret = -erestartnointr;\n\t}\n\treturn ret;\n}\n\n\nstatic int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = null;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = null;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = futex_key_init;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (uaddr == uaddr2)\n\t\treturn -einval;\n\n\tif (!bitset)\n\t\treturn -einval;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & flags_clockrt) ?\n\t\t\t\t      clock_realtime : clock_monotonic,\n\t\t\t\t      hrtimer_mode_abs);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trb_clear_node(&rt_waiter.pi_tree_entry);\n\trb_clear_node(&rt_waiter.tree_entry);\n\trt_waiter.task = null;\n\n\tret = get_futex_key(uaddr2, flags & flags_shared, &key2, verify_write);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t\n\tif (match_futex(&q.key, &key2)) {\n\t\tqueue_unlock(hb);\n\t\tret = -einval;\n\t\tgoto out_put_keys;\n\t}\n\n\t\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t\n\n\t\n\tif (!q.rt_waiter) {\n\t\t\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t\n\t\twarn_on(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t\n\tif (ret == -efault) {\n\t\tif (pi_mutex && rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -eintr) {\n\t\t\n\t\tret = -ewouldblock;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n\n\n\n\nsyscall_define2(set_robust_list, struct robust_list_head __user *, head,\n\t\tsize_t, len)\n{\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -enosys;\n\t\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -einval;\n\n\tcurrent->robust_list = head;\n\n\treturn 0;\n}\n\n\nsyscall_define3(get_robust_list, int, pid,\n\t\tstruct robust_list_head __user * __user *, head_ptr,\n\t\tsize_t __user *, len_ptr)\n{\n\tstruct robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -enosys;\n\n\trcu_read_lock();\n\n\tret = -esrch;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -eperm;\n\tif (!ptrace_may_access(p, ptrace_mode_read))\n\t\tgoto err_unlock;\n\n\thead = p->robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -efault;\n\treturn put_user(head, head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n\nint handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & futex_tid_mask) == task_pid_vnr(curr)) {\n\t\t\n\t\tmval = (uval & futex_waiters) | futex_owner_died;\n\t\t\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t\n\t\tif (!pi && (uval & futex_waiters))\n\t\t\tfutex_wake(uaddr, 1, 1, futex_bitset_match_any);\n\t}\n\treturn 0;\n}\n\n\nstatic inline int fetch_robust_entry(struct robust_list __user **entry,\n\t\t\t\t     struct robust_list __user * __user *head,\n\t\t\t\t     unsigned int *pi)\n{\n\tunsigned long uentry;\n\n\tif (get_user(uentry, (unsigned long __user *)head))\n\t\treturn -efault;\n\n\t*entry = (void __user *)(uentry & ~1ul);\n\t*pi = uentry & 1;\n\n\treturn 0;\n}\n\n\nvoid exit_robust_list(struct task_struct *curr)\n{\n\tstruct robust_list_head __user *head = curr->robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = robust_list_limit, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tunsigned long futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t\n\tif (fetch_robust_entry(&entry, &head->list.next, &pi))\n\t\treturn;\n\t\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t\n\tif (fetch_robust_entry(&pending, &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = null;\t\n\twhile (entry != &head->list) {\n\t\t\n\t\trc = fetch_robust_entry(&next_entry, &entry->next, &next_pi);\n\t\t\n\t\tif (entry != pending)\n\t\t\tif (handle_futex_death((void __user *)entry + futex_offset,\n\t\t\t\t\t\tcurr, pi))\n\t\t\t\treturn;\n\t\tif (rc)\n\t\t\treturn;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\t\n\t\tif (!--limit)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (pending)\n\t\thandle_futex_death((void __user *)pending + futex_offset,\n\t\t\t\t   curr, pip);\n}\n\nlong do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,\n\t\tu32 __user *uaddr2, u32 val2, u32 val3)\n{\n\tint cmd = op & futex_cmd_mask;\n\tunsigned int flags = 0;\n\n\tif (!(op & futex_private_flag))\n\t\tflags |= flags_shared;\n\n\tif (op & futex_clock_realtime) {\n\t\tflags |= flags_clockrt;\n\t\tif (cmd != futex_wait_bitset && cmd != futex_wait_requeue_pi)\n\t\t\treturn -enosys;\n\t}\n\n\tswitch (cmd) {\n\tcase futex_lock_pi:\n\tcase futex_unlock_pi:\n\tcase futex_trylock_pi:\n\tcase futex_wait_requeue_pi:\n\tcase futex_cmp_requeue_pi:\n\t\tif (!futex_cmpxchg_enabled)\n\t\t\treturn -enosys;\n\t}\n\n\tswitch (cmd) {\n\tcase futex_wait:\n\t\tval3 = futex_bitset_match_any;\n\tcase futex_wait_bitset:\n\t\treturn futex_wait(uaddr, flags, val, timeout, val3);\n\tcase futex_wake:\n\t\tval3 = futex_bitset_match_any;\n\tcase futex_wake_bitset:\n\t\treturn futex_wake(uaddr, flags, val, val3);\n\tcase futex_requeue:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, null, 0);\n\tcase futex_cmp_requeue:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 0);\n\tcase futex_wake_op:\n\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);\n\tcase futex_lock_pi:\n\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);\n\tcase futex_unlock_pi:\n\t\treturn futex_unlock_pi(uaddr, flags);\n\tcase futex_trylock_pi:\n\t\treturn futex_lock_pi(uaddr, flags, null, 1);\n\tcase futex_wait_requeue_pi:\n\t\tval3 = futex_bitset_match_any;\n\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,\n\t\t\t\t\t     uaddr2);\n\tcase futex_cmp_requeue_pi:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 1);\n\t}\n\treturn -enosys;\n}\n\n\nsyscall_define6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct timespec __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = null;\n\tu32 val2 = 0;\n\tint cmd = op & futex_cmd_mask;\n\n\tif (utime && (cmd == futex_wait || cmd == futex_lock_pi ||\n\t\t      cmd == futex_wait_bitset ||\n\t\t      cmd == futex_wait_requeue_pi)) {\n\t\tif (copy_from_user(&ts, utime, sizeof(ts)) != 0)\n\t\t\treturn -efault;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -einval;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == futex_wait)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\t\n\tif (cmd == futex_requeue || cmd == futex_cmp_requeue ||\n\t    cmd == futex_cmp_requeue_pi || cmd == futex_wake_op)\n\t\tval2 = (u32) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}\n\nstatic void __init futex_detect_cmpxchg(void)\n{\n#ifndef config_have_futex_cmpxchg\n\tu32 curval;\n\n\t\n\tif (cmpxchg_futex_value_locked(&curval, null, 0, 0) == -efault)\n\t\tfutex_cmpxchg_enabled = 1;\n#endif\n}\n\nstatic int __init futex_init(void)\n{\n\tunsigned int futex_shift;\n\tunsigned long i;\n\n#if config_base_small\n\tfutex_hashsize = 16;\n#else\n\tfutex_hashsize = roundup_pow_of_two(256 * num_possible_cpus());\n#endif\n\n\tfutex_queues = alloc_large_system_hash(\"": 1200, "\", s->buffer);\n\n\ttrace_seq_init(s);\n}\n\nvoid trace_init_global_iter(struct trace_iterator *iter)\n{\n\titer->tr = &global_trace;\n\titer->trace = iter->tr->current_trace;\n\titer->cpu_file = ring_buffer_all_cpus;\n\titer->trace_buffer = &global_trace.trace_buffer;\n\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t\n\tif (ring_buffer_overruns(iter->trace_buffer->buffer))\n\t\titer->iter_flags |= trace_file_annotate;\n\n\t\n\tif (trace_clocks[iter->tr->clock_id].in_ns)\n\t\titer->iter_flags |= trace_file_time_in_ns;\n}\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.tr->trace_buffer.data, cpu)->disabled);\n\t}\n\n\told_userobj = trace_flags & trace_iter_sym_userobj;\n\n\t\n\ttrace_flags &= ~trace_iter_sym_userobj;\n\n\tswitch (oops_dump_mode) {\n\tcase dump_all:\n\t\titer.cpu_file = ring_buffer_all_cpus;\n\t\tbreak;\n\tcase dump_orig:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase dump_none:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(kern_trace \"": 1201, "\", s_irugo, null,\n\t\t\t\t null, &virq_debug_fops) == null)\n\t\treturn -enomem;\n\n\treturn 0;\n}\n__initcall(irq_debugfs_init);\n#endif \n\n\nint irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (warn_on(intsize < 1))\n\t\treturn -einval;\n\t*out_hwirq = intspec[0];\n\t*out_type = irq_type_none;\n\treturn 0;\n}\nexport_symbol_gpl(irq_domain_xlate_onecell);\n\n\nint irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tif (warn_on(intsize < 2))\n\t\treturn -einval;\n\t*out_hwirq = intspec[0];\n\t*out_type = intspec[1] & irq_type_sense_mask;\n\treturn 0;\n}\nexport_symbol_gpl(irq_domain_xlate_twocell);\n\n\nint irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (warn_on(intsize < 1))\n\t\treturn -einval;\n\t*out_hwirq = intspec[0];\n\t*out_type = (intsize > 1) ? intspec[1] : irq_type_none;\n\treturn 0;\n}\nexport_symbol_gpl(irq_domain_xlate_onetwocell);\n\nconst struct irq_domain_ops irq_domain_simple_ops = {\n\t.xlate = irq_domain_xlate_onetwocell,\n};\nexport_symbol_gpl(irq_domain_simple_ops);\n\nstatic int irq_domain_alloc_descs(int virq, unsigned int cnt,\n\t\t\t\t  irq_hw_number_t hwirq, int node)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = irq_alloc_descs(virq, virq, cnt, node);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = irq_alloc_descs_from(hint, cnt, node);\n\t\tif (virq <= 0 && hint > 1)\n\t\t\tvirq = irq_alloc_descs_from(1, cnt, node);\n\t}\n\n\treturn virq;\n}\n\n#ifdef\tconfig_irq_domain_hierarchy\n\nstruct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct device_node *node,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_add_linear(node, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_add_tree(node, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tif (hwirq < domain->revmap_size) {\n\t\t\tdomain->linear_revmap[hwirq] = virq;\n\t\t} else {\n\t\t\tmutex_lock(&revmap_trees_mutex);\n\t\t\tradix_tree_insert(&domain->revmap_tree, hwirq, data);\n\t\t\tmutex_unlock(&revmap_trees_mutex);\n\t\t}\n\n\t\t\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, irq_norequest);\n}\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, irq_norequest);\n\tirq_set_chip_and_handler(virq, null, null);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tif (hwirq < domain->revmap_size) {\n\t\t\tdomain->linear_revmap[hwirq] = 0;\n\t\t} else {\n\t\t\tmutex_lock(&revmap_trees_mutex);\n\t\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\t\tmutex_unlock(&revmap_trees_mutex);\n\t\t}\n\t}\n}\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), gfp_kernel, child->node);\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->node = child->node;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = null;\n\t\tirq_data->domain = null;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -enomem;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn null;\n}\n\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -enoent;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}\n\n\nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}\n\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = null;\n}\n\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\n\n\nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, null);\n\t\tirq_set_handler(virq + i, null);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic bool irq_domain_is_auto_recursive(struct irq_domain *domain)\n{\n\treturn domain->flags & irq_domain_flag_auto_recursive;\n}\n\nstatic void irq_domain_free_irqs_recursive(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tdomain->ops->free(domain, irq_base, nr_irqs);\n\tif (irq_domain_is_auto_recursive(domain)) {\n\t\tbug_on(!domain->parent);\n\t\tirq_domain_free_irqs_recursive(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs);\n\t}\n}\n\nstatic int irq_domain_alloc_irqs_recursive(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs, void *arg)\n{\n\tint ret = 0;\n\tstruct irq_domain *parent = domain->parent;\n\tbool recursive = irq_domain_is_auto_recursive(domain);\n\n\tbug_on(recursive && !parent);\n\tif (recursive)\n\t\tret = irq_domain_alloc_irqs_recursive(parent, irq_base,\n\t\t\t\t\t\t      nr_irqs, arg);\n\tif (ret >= 0)\n\t\tret = domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n\tif (ret < 0 && recursive)\n\t\tirq_domain_free_irqs_recursive(parent, irq_base, nr_irqs);\n\n\treturn ret;\n}\n\n\nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc)\n{\n\tint i, ret, virq;\n\n\tif (domain == null) {\n\t\tdomain = irq_default_domain;\n\t\tif (warn(!domain, \"": 1202, "\", savedcmd->cmdline_num);\n\tarch_spin_unlock(&trace_cmdline_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic void free_saved_cmdlines_buffer(struct saved_cmdlines_buffer *s)\n{\n\tkfree(s->saved_cmdlines);\n\tkfree(s->map_cmdline_to_pid);\n\tkfree(s);\n}\n\nstatic int tracing_resize_saved_cmdlines(unsigned int val)\n{\n\tstruct saved_cmdlines_buffer *s, *savedcmd_temp;\n\n\ts = kmalloc(sizeof(*s), gfp_kernel);\n\tif (!s)\n\t\treturn -enomem;\n\n\tif (allocate_cmdlines_buffer(val, s) < 0) {\n\t\tkfree(s);\n\t\treturn -enomem;\n\t}\n\n\tarch_spin_lock(&trace_cmdline_lock);\n\tsavedcmd_temp = savedcmd;\n\tsavedcmd = s;\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tfree_saved_cmdlines_buffer(savedcmd_temp);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_saved_cmdlines_size_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\tif (!val || val > pid_max_default)\n\t\treturn -einval;\n\n\tret = tracing_resize_saved_cmdlines((unsigned int)val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations tracing_saved_cmdlines_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_saved_cmdlines_size_read,\n\t.write\t\t= tracing_saved_cmdlines_size_write,\n};\n\n#ifdef config_trace_enum_map_file\nstatic union trace_enum_map_item *\nupdate_enum_map(union trace_enum_map_item *ptr)\n{\n\tif (!ptr->map.enum_string) {\n\t\tif (ptr->tail.next) {\n\t\t\tptr = ptr->tail.next;\n\t\t\t\n\t\t\tptr++;\n\t\t} else\n\t\t\treturn null;\n\t}\n\treturn ptr;\n}\n\nstatic void *enum_map_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tunion trace_enum_map_item *ptr = v;\n\n\t\n\tptr = update_enum_map(ptr);\n\tif (warn_on_once(!ptr))\n\t\treturn null;\n\n\tptr++;\n\n\t(*pos)++;\n\n\tptr = update_enum_map(ptr);\n\n\treturn ptr;\n}\n\nstatic void *enum_map_start(struct seq_file *m, loff_t *pos)\n{\n\tunion trace_enum_map_item *v;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_enum_mutex);\n\n\tv = trace_enum_maps;\n\tif (v)\n\t\tv++;\n\n\twhile (v && l < *pos) {\n\t\tv = enum_map_next(m, v, &l);\n\t}\n\n\treturn v;\n}\n\nstatic void enum_map_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&trace_enum_mutex);\n}\n\nstatic int enum_map_show(struct seq_file *m, void *v)\n{\n\tunion trace_enum_map_item *ptr = v;\n\n\tseq_printf(m, \"": 1203, "\", scancode);\n\t}\n\tkeychar &= 0x0fff;\n\tif (keychar == '\\t')\n\t\tkeychar = ' ';\n\tswitch (ktyp(keychar)) {\n\tcase kt_letter:\n\tcase kt_latin:\n\t\tif (isprint(keychar))\n\t\t\tbreak;\t\t\n\t\t\n\tcase kt_spec:\n\t\tif (keychar == k_enter)\n\t\t\tbreak;\n\t\t\n\tdefault:\n\t\treturn -1;\t\n\t}\n\n\tif (scancode == 0x1c) {\n\t\tkbd_last_ret = 1;\n\t\treturn 13;\n\t}\n\n\treturn keychar & 0xff;\n}\nexport_symbol_gpl(kdb_get_kbd_char);\n\n\nvoid kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t\n\n\twhile (1) {\n\t\twhile ((inb(kbd_status_reg) & kbd_stat_obf) == 0)\n\t\t\tcpu_relax();\n\n\t\t\n\t\tscancode = inb(kbd_data_reg);\n\t\tscanstatus = inb(kbd_status_reg);\n\n\t\t\n\t\tif (scanstatus & kbd_stat_mouse_obf)\n\t\t\tcontinue;\n\n\t\t\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}\n\n\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/syscalls.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n#include <linux/ftrace.h>\n#include <trace/events/power.h>\n#include <linux/compiler.h>\n#include <linux/moduleparam.h>\n\n#include \"": 1204, "\", set_ftrace_filter);\n\n#ifdef config_function_graph_tracer\nstatic char ftrace_graph_buf[ftrace_filter_size] __initdata;\nstatic char ftrace_graph_notrace_buf[ftrace_filter_size] __initdata;\nstatic int ftrace_set_func(unsigned long *array, int *idx, int size, char *buffer);\n\nstatic unsigned long save_global_trampoline;\nstatic unsigned long save_global_flags;\n\nstatic int __init set_graph_function(char *str)\n{\n\tstrlcpy(ftrace_graph_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"": 1205, "\", set_ftrace_notrace);\n\nstatic int __init set_ftrace_filter(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_filter_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"": 1206, "\", set_graph_function);\n\nstatic int __init set_graph_notrace_function(char *str)\n{\n\tstrlcpy(ftrace_graph_notrace_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"": 1207, "\", set_graph_notrace_function);\n\nstatic void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tunsigned long *table = ftrace_graph_funcs;\n\tint *count = &ftrace_graph_count;\n\n\tif (!enable) {\n\t\ttable = ftrace_graph_notrace_funcs;\n\t\tcount = &ftrace_graph_notrace_count;\n\t}\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \"": 1208, "\", setup_hrtimer_hres);\n\n\nstatic inline int hrtimer_is_hres_enabled(void)\n{\n\treturn hrtimer_hres_enabled;\n}\n\n\nstatic inline int hrtimer_hres_active(void)\n{\n\treturn __this_cpu_read(hrtimer_bases.hres_active);\n}\n\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next = __hrtimer_get_next_event(cpu_base);\n\n\tif (skip_equal && expires_next.tv64 == cpu_base->expires_next.tv64)\n\t\treturn;\n\n\tcpu_base->expires_next.tv64 = expires_next.tv64;\n\n\t\n\tif (cpu_base->hang_detected)\n\t\treturn;\n\n\tif (cpu_base->expires_next.tv64 != ktime_max)\n\t\ttick_program_event(cpu_base->expires_next, 1);\n}\n\n\nstatic int hrtimer_reprogram(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\tint res;\n\n\twarn_on_once(hrtimer_get_expires_tv64(timer) < 0);\n\n\t\n\tif (hrtimer_callback_running(timer))\n\t\treturn 0;\n\n\t\n\tif (expires.tv64 < 0)\n\t\treturn -etime;\n\n\tif (expires.tv64 >= cpu_base->expires_next.tv64)\n\t\treturn 0;\n\n\t\n\tif (cpu_base->in_hrtirq)\n\t\treturn 0;\n\n\t\n\tif (cpu_base->hang_detected)\n\t\treturn 0;\n\n\t\n\tres = tick_program_event(expires, 0);\n\tif (!is_err_value(res))\n\t\tcpu_base->expires_next = expires;\n\treturn res;\n}\n\n\nstatic inline void hrtimer_init_hres(struct hrtimer_cpu_base *base)\n{\n\tbase->expires_next.tv64 = ktime_max;\n\tbase->hres_active = 0;\n}\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[hrtimer_base_realtime].offset;\n\tktime_t *offs_boot = &base->clock_base[hrtimer_base_boottime].offset;\n\tktime_t *offs_tai = &base->clock_base[hrtimer_base_tai].offset;\n\n\treturn ktime_get_update_offsets_now(offs_real, offs_boot, offs_tai);\n}\n\n\nstatic void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\thrtimer_force_reprogram(base, 0);\n\traw_spin_unlock(&base->lock);\n}\n\n\nstatic int hrtimer_switch_to_hres(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct hrtimer_cpu_base *base = &per_cpu(hrtimer_bases, cpu);\n\tunsigned long flags;\n\n\tif (base->hres_active)\n\t\treturn 1;\n\n\tlocal_irq_save(flags);\n\n\tif (tick_init_highres()) {\n\t\tlocal_irq_restore(flags);\n\t\tprintk(kern_warning \"": 1209, "\", size >> 10);\n\t\t} else\n\t\t\tr = sprintf(buf, \"": 1210, "\", size);\n\telse\n\t\tr = sprintf(buf, \"": 1211, "\", size, expanded_size);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\ntracing_free_buffer_write(struct file *filp, const char __user *ubuf,\n\t\t\t  size_t cnt, loff_t *ppos)\n{\n\t\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic int\ntracing_free_buffer_release(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\t\n\tif (trace_flags & trace_iter_stop_on_free)\n\t\ttracer_tracing_off(tr);\n\t\n\ttracing_resize_ring_buffer(tr, 0, ring_buffer_all_cpus);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_mark_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *fpos)\n{\n\tunsigned long addr = (unsigned long)ubuf;\n\tstruct trace_array *tr = filp->private_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct print_entry *entry;\n\tunsigned long irq_flags;\n\tstruct page *pages[2];\n\tvoid *map_page[2];\n\tint nr_pages = 1;\n\tssize_t written;\n\tint offset;\n\tint size;\n\tint len;\n\tint ret;\n\tint i;\n\n\tif (tracing_disabled)\n\t\treturn -einval;\n\n\tif (!(trace_flags & trace_iter_markers))\n\t\treturn -einval;\n\n\tif (cnt > trace_buf_size)\n\t\tcnt = trace_buf_size;\n\n\t\n\tbuild_bug_on(trace_buf_size >= page_size);\n\n\t\n\tif ((addr & page_mask) != ((addr + cnt) & page_mask))\n\t\tnr_pages = 2;\n\n\toffset = addr & (page_size - 1);\n\taddr &= page_mask;\n\n\tret = get_user_pages_fast(addr, nr_pages, 0, pages);\n\tif (ret < nr_pages) {\n\t\twhile (--ret >= 0)\n\t\t\tput_page(pages[ret]);\n\t\twritten = -efault;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tmap_page[i] = kmap_atomic(pages[i]);\n\n\tlocal_save_flags(irq_flags);\n\tsize = sizeof(*entry) + cnt + 2; \n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, trace_print, size,\n\t\t\t\t\t  irq_flags, preempt_count());\n\tif (!event) {\n\t\t\n\t\twritten = -ebadf;\n\t\tgoto out_unlock;\n\t}\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = _this_ip_;\n\n\tif (nr_pages == 2) {\n\t\tlen = page_size - offset;\n\t\tmemcpy(&entry->buf, map_page[0] + offset, len);\n\t\tmemcpy(&entry->buf[len], map_page[1], cnt - len);\n\t} else\n\t\tmemcpy(&entry->buf, map_page[0] + offset, cnt);\n\n\tif (entry->buf[cnt - 1] != '\\n') {\n\t\tentry->buf[cnt] = '\\n';\n\t\tentry->buf[cnt + 1] = '\\0';\n\t} else\n\t\tentry->buf[cnt] = '\\0';\n\n\t__buffer_unlock_commit(buffer, event);\n\n\twritten = cnt;\n\n\t*fpos += written;\n\n out_unlock:\n\tfor (i = nr_pages - 1; i >= 0; i--) {\n\t\tkunmap_atomic(map_page[i]);\n\t\tput_page(pages[i]);\n\t}\n out:\n\treturn written;\n}\n\nstatic int tracing_clock_show(struct seq_file *m, void *v)\n{\n\tstruct trace_array *tr = m->private;\n\tint i;\n\n\tfor (i = 0; i < array_size(trace_clocks); i++)\n\t\tseq_printf(m,\n\t\t\t\"": 1212, "\", sleep_states_setup);\n\n\nvoid suspend_set_ops(const struct platform_suspend_ops *ops)\n{\n\tsuspend_state_t i;\n\tint j = 0;\n\n\tlock_system_sleep();\n\n\tsuspend_ops = ops;\n\tfor (i = pm_suspend_mem; i >= pm_suspend_standby; i--)\n\t\tif (valid_state(i)) {\n\t\t\tpm_states[i] = pm_labels[j++];\n\t\t} else if (!relative_states) {\n\t\t\tpm_states[i] = null;\n\t\t\tj++;\n\t\t}\n\n\tpm_states[pm_suspend_freeze] = pm_labels[j];\n\n\tunlock_system_sleep();\n}\nexport_symbol_gpl(suspend_set_ops);\n\n\nint suspend_valid_only_mem(suspend_state_t state)\n{\n\treturn state == pm_suspend_mem;\n}\nexport_symbol_gpl(suspend_valid_only_mem);\n\nstatic bool sleep_state_supported(suspend_state_t state)\n{\n\treturn state == pm_suspend_freeze || (suspend_ops && suspend_ops->enter);\n}\n\nstatic int platform_suspend_prepare(suspend_state_t state)\n{\n\treturn state != pm_suspend_freeze && suspend_ops->prepare ?\n\t\tsuspend_ops->prepare() : 0;\n}\n\nstatic int platform_suspend_prepare_late(suspend_state_t state)\n{\n\treturn state == pm_suspend_freeze && freeze_ops && freeze_ops->prepare ?\n\t\tfreeze_ops->prepare() : 0;\n}\n\nstatic int platform_suspend_prepare_noirq(suspend_state_t state)\n{\n\treturn state != pm_suspend_freeze && suspend_ops->prepare_late ?\n\t\tsuspend_ops->prepare_late() : 0;\n}\n\nstatic void platform_resume_noirq(suspend_state_t state)\n{\n\tif (state != pm_suspend_freeze && suspend_ops->wake)\n\t\tsuspend_ops->wake();\n}\n\nstatic void platform_resume_early(suspend_state_t state)\n{\n\tif (state == pm_suspend_freeze && freeze_ops && freeze_ops->restore)\n\t\tfreeze_ops->restore();\n}\n\nstatic void platform_resume_finish(suspend_state_t state)\n{\n\tif (state != pm_suspend_freeze && suspend_ops->finish)\n\t\tsuspend_ops->finish();\n}\n\nstatic int platform_suspend_begin(suspend_state_t state)\n{\n\tif (state == pm_suspend_freeze && freeze_ops && freeze_ops->begin)\n\t\treturn freeze_ops->begin();\n\telse if (suspend_ops->begin)\n\t\treturn suspend_ops->begin(state);\n\telse\n\t\treturn 0;\n}\n\nstatic void platform_resume_end(suspend_state_t state)\n{\n\tif (state == pm_suspend_freeze && freeze_ops && freeze_ops->end)\n\t\tfreeze_ops->end();\n\telse if (suspend_ops->end)\n\t\tsuspend_ops->end();\n}\n\nstatic void platform_recover(suspend_state_t state)\n{\n\tif (state != pm_suspend_freeze && suspend_ops->recover)\n\t\tsuspend_ops->recover();\n}\n\nstatic bool platform_suspend_again(suspend_state_t state)\n{\n\treturn state != pm_suspend_freeze && suspend_ops->suspend_again ?\n\t\tsuspend_ops->suspend_again() : false;\n}\n\n#ifdef config_pm_debug\nstatic unsigned int pm_test_delay = 5;\nmodule_param(pm_test_delay, uint, 0644);\nmodule_parm_desc(pm_test_delay,\n\t\t \"": 1213, "\", src->name);\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\tcount += snprintf(buf + count,\n\t\t\t  max((ssize_t)page_size - count, (ssize_t)0), \"": 1214, "\", sym);\n\telse\n\t\tseq_printf(m, \"": 1215, "\", symname);\n}\n\nstatic int tstats_show(struct seq_file *m, void *v)\n{\n\tstruct timespec period;\n\tstruct entry *entry;\n\tunsigned long ms;\n\tlong events = 0;\n\tktime_t time;\n\tint i;\n\n\tmutex_lock(&show_mutex);\n\t\n\tif (timer_stats_active)\n\t\ttime_stop = ktime_get();\n\n\ttime = ktime_sub(time_stop, time_start);\n\n\tperiod = ktime_to_timespec(time);\n\tms = period.tv_nsec / 1000000;\n\n\tseq_puts(m, \"": 1216, "\", symname);\n}\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef config_timer_stats\n\tchar tmp[task_comm_len + 1];\n#endif\n\tseq_printf(m, \"": 1217, "\", t, usec_rem);\n\t} else {\n\t\t\n\t\ttrace_seq_printf(s, \"": 1218, "\", t: %p, r: %p\\n\"": 1219, "\", timer->state);\n#ifdef config_timer_stats\n\tseq_printf(m, \"": 1220, "\", timer_stats_active ? \"": 1221, "\", tmp, timer->start_pid);\n#endif\n\tseq_printf(m, \"": 1222, "\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: \n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"": 1223, "\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: \n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"": 1224, "\", tr->current_trace->name);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}\n\nstatic void set_buffer_entries(struct trace_buffer *buf, unsigned long val)\n{\n\tint cpu;\n\n\tfor_each_tracing_cpu(cpu)\n\t\tper_cpu_ptr(buf->data, cpu)->entries = val;\n}\n\n#ifdef config_tracer_max_trace\n\nstatic int resize_buffer_duplicate_size(struct trace_buffer *trace_buf,\n\t\t\t\t\tstruct trace_buffer *size_buf, int cpu_id)\n{\n\tint cpu, ret = 0;\n\n\tif (cpu_id == ring_buffer_all_cpus) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu)->entries, cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tper_cpu_ptr(trace_buf->data, cpu)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu)->entries;\n\t\t}\n\t} else {\n\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu_id)->entries, cpu_id);\n\t\tif (ret == 0)\n\t\t\tper_cpu_ptr(trace_buf->data, cpu_id)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu_id)->entries;\n\t}\n\n\treturn ret;\n}\n#endif \n\nstatic int __tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t\tunsigned long size, int cpu)\n{\n\tint ret;\n\n\t\n\tring_buffer_expanded = true;\n\n\t\n\tif (!tr->trace_buffer.buffer)\n\t\treturn 0;\n\n\tret = ring_buffer_resize(tr->trace_buffer.buffer, size, cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n#ifdef config_tracer_max_trace\n\tif (!(tr->flags & trace_array_fl_global) ||\n\t    !tr->current_trace->use_max_tr)\n\t\tgoto out;\n\n\tret = ring_buffer_resize(tr->max_buffer.buffer, size, cpu);\n\tif (ret < 0) {\n\t\tint r = resize_buffer_duplicate_size(&tr->trace_buffer,\n\t\t\t\t\t\t     &tr->trace_buffer, cpu);\n\t\tif (r < 0) {\n\t\t\t\n\t\t\twarn_on(1);\n\t\t\ttracing_disabled = 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (cpu == ring_buffer_all_cpus)\n\t\tset_buffer_entries(&tr->max_buffer, size);\n\telse\n\t\tper_cpu_ptr(tr->max_buffer.data, cpu)->entries = size;\n\n out:\n#endif \n\n\tif (cpu == ring_buffer_all_cpus)\n\t\tset_buffer_entries(&tr->trace_buffer, size);\n\telse\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->entries = size;\n\n\treturn ret;\n}\n\nstatic ssize_t tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t\t  unsigned long size, int cpu_id)\n{\n\tint ret = size;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu_id != ring_buffer_all_cpus) {\n\t\t\n\t\tif (!cpumask_test_cpu(cpu_id, tracing_buffer_mask)) {\n\t\t\tret = -einval;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __tracing_resize_ring_buffer(tr, size, cpu_id);\n\tif (ret < 0)\n\t\tret = -enomem;\n\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\n\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tring_buffer_all_cpus);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstruct trace_option_dentry;\n\nstatic struct trace_option_dentry *\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nstatic void\ndestroy_trace_option_files(struct trace_option_dentry *topts);\n\n\nstatic void tracing_set_nop(struct trace_array *tr)\n{\n\tif (tr->current_trace == &nop_trace)\n\t\treturn;\n\t\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\ttr->current_trace = &nop_trace;\n}\n\nstatic void update_tracer_options(struct trace_array *tr, struct tracer *t)\n{\n\tstatic struct trace_option_dentry *topts;\n\n\t\n\tif (!tr->dir)\n\t\treturn;\n\n\t\n\tif (!(tr->flags & trace_array_fl_global))\n\t\treturn;\n\n\tdestroy_trace_option_files(topts);\n\ttopts = create_trace_option_files(tr, t);\n}\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf)\n{\n\tstruct tracer *t;\n#ifdef config_tracer_max_trace\n\tbool had_max_tr;\n#endif\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!ring_buffer_expanded) {\n\t\tret = __tracing_resize_ring_buffer(tr, trace_buf_size,\n\t\t\t\t\t\tring_buffer_all_cpus);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(t->name, buf) == 0)\n\t\t\tbreak;\n\t}\n\tif (!t) {\n\t\tret = -einval;\n\t\tgoto out;\n\t}\n\tif (t == tr->current_trace)\n\t\tgoto out;\n\n\t\n\tif (!trace_ok_for_array(t, tr)) {\n\t\tret = -einval;\n\t\tgoto out;\n\t}\n\n\t\n\tif (tr->current_trace->ref) {\n\t\tret = -ebusy;\n\t\tgoto out;\n\t}\n\n\ttrace_branch_disable();\n\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\t\n\ttr->current_trace = &nop_trace;\n\n#ifdef config_tracer_max_trace\n\thad_max_tr = tr->allocated_snapshot;\n\n\tif (had_max_tr && !t->use_max_tr) {\n\t\t\n\t\tsynchronize_sched();\n\t\tfree_snapshot(tr);\n\t}\n#endif\n\tupdate_tracer_options(tr, t);\n\n#ifdef config_tracer_max_trace\n\tif (t->use_max_tr && !had_max_tr) {\n\t\tret = alloc_snapshot(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (t->init) {\n\t\tret = tracer_init(t, tr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\ttr->current_trace = t;\n\ttr->current_trace->enabled++;\n\ttrace_branch_enable(tr);\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_set_trace_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[max_tracer_size+1];\n\tint i;\n\tsize_t ret;\n\tint err;\n\n\tret = cnt;\n\n\tif (cnt > max_tracer_size)\n\t\tcnt = max_tracer_size;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -efault;\n\n\tbuf[cnt] = 0;\n\n\t\n\tfor (i = cnt - 1; i > 0 && isspace(buf[i]); i--)\n\t\tbuf[i] = 0;\n\n\terr = tracing_set_tracer(tr, buf);\n\tif (err)\n\t\treturn err;\n\n\t*ppos += ret;\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_nsecs_read(unsigned long *ptr, char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"": 1225, "\", trace_clocks[i].name,\n\t\t\ti == tr->clock_id ? \"": 1226, "\", trace_options[i]);\n\t\telse\n\t\t\tseq_printf(m, \"": 1227, "\", trace_options[i]);\n\t}\n\n\tfor (i = 0; trace_opts[i].name; i++) {\n\t\tif (tracer_flags & trace_opts[i].bit)\n\t\t\tseq_printf(m, \"": 1228, "\", trace_opts[i].name);\n\t\telse\n\t\t\tseq_printf(m, \"": 1229, "\", trace_opts[i].name);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic int __set_tracer_option(struct trace_array *tr,\n\t\t\t       struct tracer_flags *tracer_flags,\n\t\t\t       struct tracer_opt *opts, int neg)\n{\n\tstruct tracer *trace = tr->current_trace;\n\tint ret;\n\n\tret = trace->set_flag(tr, tracer_flags->val, opts->bit, !neg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (neg)\n\t\ttracer_flags->val &= ~opts->bit;\n\telse\n\t\ttracer_flags->val |= opts->bit;\n\treturn 0;\n}\n\n\nstatic int set_tracer_option(struct trace_array *tr, char *cmp, int neg)\n{\n\tstruct tracer *trace = tr->current_trace;\n\tstruct tracer_flags *tracer_flags = trace->flags;\n\tstruct tracer_opt *opts = null;\n\tint i;\n\n\tfor (i = 0; tracer_flags->opts[i].name; i++) {\n\t\topts = &tracer_flags->opts[i];\n\n\t\tif (strcmp(cmp, opts->name) == 0)\n\t\t\treturn __set_tracer_option(tr, trace->flags, opts, neg);\n\t}\n\n\treturn -einval;\n}\n\n\nint trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & trace_iter_overwrite) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\t\n\tif (!!(trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -einval;\n\n\tif (enabled)\n\t\ttrace_flags |= mask;\n\telse\n\t\ttrace_flags &= ~mask;\n\n\tif (mask == trace_iter_record_cmd)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == trace_iter_overwrite) {\n\t\tring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);\n#ifdef config_tracer_max_trace\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == trace_iter_printk)\n\t\ttrace_printk_start_stop_comm(enabled);\n\n\treturn 0;\n}\n\nstatic int trace_set_options(struct trace_array *tr, char *option)\n{\n\tchar *cmp;\n\tint neg = 0;\n\tint ret = -enodev;\n\tint i;\n\n\tcmp = strstrip(option);\n\n\tif (strncmp(cmp, \"": 1230, "\", tsk);\n\telse\n\t\tprintk(kern_err \"": 1231, "\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"": 1232, "\", usage_str[bit]);\n\t\t\tlen += printk(\"": 1233, "\", virq);\n\t\tret = -enomem;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_recursive(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}\n\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (warn(!data || !data->domain || !data->domain->ops->free,\n\t\t \"": 1234, "\",\"": 1235, "\",clone_children\"": 1236, "\",depth,\"": 1237, "\",high\"": 1238, "\",low\"": 1239, "\",name=%s\"": 1240, "\",noprefix\"": 1241, "\",release_agent=%s\"": 1242, "\",xattr\"": 1243, "\"-\"": 1244, "\"-%-8s\"": 1245, "\"--\"": 1246, "\"---    ----            ---             ---\\n\"": 1247, "\"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\"": 1248, "\"--- %s: nreaders=%d nfakewriters=%d \"": 1249, "\"-----------------------------\"": 1250, "\"------------------------------------------------------\"": 1251, "\"---------------------------------------------------------\"": 1252, "\"----------------------------------------------------\\n\"": 1253, "\"------------------------------------------------\\n\"": 1254, "\"---------------------------------------------\\n\"": 1255, "\"--------------------------------------------\\n\"": 1256, "\"-------------------------------------\\n\"": 1257, "\"----------------------------------\\n\"": 1258, "\"---------------------------------\\n\"": 1259, "\"-------------------------------\\n\"": 1260, "\"------------------------------\\n\"": 1261, "\"-----------------------------\\n\"": 1262, "\"----------\\n\"": 1263, "\"---[ end kernel panic - not syncing: %s\\n\"": 1264, "\"--=\"": 1265, "\"--> %lx (%d)\"": 1266, "\"-:testprobe\"": 1267, "\"-:testprobe2\"": 1268, "\"-=\"": 1269, "\"-> existing mapping on virq %d\\n\"": 1270, "\"-> using domain @%p\\n\"": 1271, "\"->action(): %p\\n\"": 1272, "\"->action->handler(): %p, \"": 1273, "\"->handle_irq():  %p, \"": 1274, "\"->irq_data.chip(): %p, \"": 1275, "\"->rcu_read_unlock_special: %#x (b: %d, nq: %d)\\n\"": 1276, "\"-on-r\"": 1277, "\"-on-w\"": 1278, "\"-q\"": 1279, "\"-r\"": 1280, "\"-w\"": 1281, "\".\"": 1282, "\".-_\"": 1283, "\".. ->owner: %p\\n\"": 1284, "\".. bad ring buffer \"": 1285, "\".. corrupted trace buffer .. \"": 1286, "\".. filter did not filter .. \"": 1287, "\".. filter failed count=%ld ..\"": 1288, "\".. held by:  \"": 1289, "\".. invalid entry %d \"": 1290, "\".. no entries found ..\"": 1291, "\"..\"": 1292, "\"../../mm/internal.h\"": 1293, "\"../debug_core.h\"": 1294, "\"../fs/xfs/xfs_sysctl.h\"": 1295, "\"../locking/rtmutex_common.h\"": 1296, "\"../smpboot.h\"": 1297, "\"../time/tick-internal.h\"": 1298, "\"../workqueue_internal.h\"": 1299, "\".ctors\"": 1300, "\".d\"": 1301, "\".data..percpu\"": 1302, "\".debug\"": 1303, "\".e\"": 1304, "\".exit\"": 1305, "\".g\"": 1306, "\".gnu.linkonce.this_module\"": 1307, "\".i\"": 1308, "\".init\"": 1309, "\".init_array\"": 1310, "\".modinfo\"": 1311, "\".n\"": 1312, "\".owner_cpu: %d\\n\"": 1313, "\".r\"": 1314, "\".rodata\"": 1315, "\".system_keyring\"": 1316, "\".t\"": 1317, "\".tmp_\"": 1318, "\".w\"": 1319, "\"/\"": 1320, "\"/%d\"": 1321, "\"/0x%lx\"": 1322, "\"/=\"": 1323, "\"/autogroup\"": 1324, "\"/autogroup-%ld nice %d\\n\"": 1325, "\"/sbin/modprobe\"": 1326, "\"0\"": 1327, "\"0-0\\tlinux           \\t[kernel]\\n\"": 1328, "\"0\\n\"": 1329, "\"0x%llx\"": 1330, "\"0x%lx\"": 1331, "\"0x%lx\\n\"": 1332, "\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\"": 1333, "\"0x%p-0x%p\\t%ps\\n\"": 1334, "\"0x%pk\\n\"": 1335, "\"0x%x\"": 1336, "\"1\"": 1337, "\"2.6.%u%s\"": 1338, "\": \"": 1339, "\": \\t\"": 1340, "\":\"": 1341, "\":%p\"": 1342, "\":%s/%s\"": 1343, "\":count=%ld\"": 1344, "\":count=%ld\\n\"": 1345, "\":unlimited\"": 1346, "\":unlimited\\n\"": 1347, "\";\n\t\t*str += 4;\n\t} else if (!memcmp(str, \"": 1348, "\";\n\t\t}\n\t}\n\treturn null;\n}\n\n\nstatic char *kdballocenv(size_t bytes)\n{\n#define\tkdb_envbufsize\t512\n\tstatic char envbuffer[kdb_envbufsize];\n\tstatic int envbufsize;\n\tchar *ep = null;\n\n\tif ((kdb_envbufsize - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}\n\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn kdb_notenv;\n\tif (strlen(ep) == 0)\n\t\treturn kdb_noenvvalue;\n\n\t*value = simple_strtoul(ep, null, 0);\n\n\treturn 0;\n}\n\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}\n\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn kdb_badint;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn kdb_badint;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}\n\n\nint kdb_set(int argc, const char **argv)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\t\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn kdb_argcount;\n\n\t\n\tif (strcmp(argv[1], \"": 1349, "\";\n\telse\n\t\tbuf = \"": 1350, "\";\n\tstruct console *c = console_drivers;\n\tstatic define_spinlock(kdb_printf_lock);\n\tunsigned long uninitialized_var(flags);\n\n\tpreempt_disable();\n\tsaved_trap_printk = kdb_trap_printk;\n\tkdb_trap_printk = 0;\n\n\t\n\tif (!kdb_state(printf_lock)) {\n\t\tkdb_state_set(printf_lock);\n\t\tspin_lock_irqsave(&kdb_printf_lock, flags);\n\t\tgot_printf_lock = 1;\n\t\tatomic_inc(&kdb_event);\n\t} else {\n\t\t__acquire(kdb_printf_lock);\n\t}\n\n\tdiag = kdbgetintenv(\"": 1351, "\";\n\n\t\t\n\t\tkdb_nextline = 1;\t\n\n\t\t\n\t\tmoreprompt = kdbgetenv(\"": 1352, "\";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"": 1353, "\";\n\n\t\trecursion_bug = 0;\n\t\t\n\t\tprinted_len += log_store(0, 2, log_prefix|log_newline, 0,\n\t\t\t\t\t null, 0, recursion_msg,\n\t\t\t\t\t strlen(recursion_msg));\n\t}\n\n\t\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= log_newline;\n\t}\n\n\t\n\tif (facility == 0) {\n\t\tint kern_level = printk_get_level(text);\n\n\t\tif (kern_level) {\n\t\t\tconst char *end_of_header = printk_skip_level(text);\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == loglevel_default)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t\n\t\t\tcase 'd':\t\n\t\t\t\tlflags |= log_prefix;\n\t\t\t}\n\t\t\t\n\t\t\ttext_len -= end_of_header - text;\n\t\t\ttext = (char *)end_of_header;\n\t\t}\n\t}\n\n\tif (level == loglevel_default)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= log_prefix|log_newline;\n\n\tif (!(lflags & log_newline)) {\n\t\t\n\t\tif (cont.len && (lflags & log_prefix || cont.owner != current))\n\t\t\tcont_flush(log_newline);\n\n\t\t\n\t\tif (cont_add(facility, level, text, text_len))\n\t\t\tprinted_len += text_len;\n\t\telse\n\t\t\tprinted_len += log_store(facility, level,\n\t\t\t\t\t\t lflags | log_cont, 0,\n\t\t\t\t\t\t dict, dictlen, text, text_len);\n\t} else {\n\t\tbool stored = false;\n\n\t\t\n\t\tif (cont.len) {\n\t\t\tif (cont.owner == current && !(lflags & log_prefix))\n\t\t\t\tstored = cont_add(facility, level, text,\n\t\t\t\t\t\t  text_len);\n\t\t\tcont_flush(log_newline);\n\t\t}\n\n\t\tif (stored)\n\t\t\tprinted_len += text_len;\n\t\telse\n\t\t\tprinted_len += log_store(facility, level, lflags, 0,\n\t\t\t\t\t\t dict, dictlen, text, text_len);\n\t}\n\n\tlogbuf_cpu = uint_max;\n\traw_spin_unlock(&logbuf_lock);\n\tlockdep_on();\n\tlocal_irq_restore(flags);\n\n\t\n\tif (!in_sched) {\n\t\tlockdep_off();\n\t\t\n\t\tpreempt_disable();\n\n\t\t\n\t\tif (console_trylock_for_printk())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t\tlockdep_on();\n\t}\n\n\treturn printed_len;\n}\nexport_symbol(vprintk_emit);\n\nasmlinkage int vprintk(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, loglevel_default, null, 0, fmt, args);\n}\nexport_symbol(vprintk);\n\nasmlinkage int printk_emit(int facility, int level,\n\t\t\t   const char *dict, size_t dictlen,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, dict, dictlen, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}\nexport_symbol(printk_emit);\n\nint vprintk_default(const char *fmt, va_list args)\n{\n\tint r;\n\n#ifdef config_kgdb_kdb\n\tif (unlikely(kdb_trap_printk)) {\n\t\tr = vkdb_printf(kdb_msgsrc_printk, fmt, args);\n\t\treturn r;\n\t}\n#endif\n\tr = vprintk_emit(0, loglevel_default, null, 0, fmt, args);\n\n\treturn r;\n}\nexport_symbol_gpl(vprintk_default);\n\n\ndefine_per_cpu(printk_func_t, printk_func) = vprintk_default;\n\n\nasmlinkage __visible int printk(const char *fmt, ...)\n{\n\tprintk_func_t vprintk_func;\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\n\t\n\tvprintk_func = this_cpu_read(printk_func);\n\tr = vprintk_func(fmt, args);\n\n\tva_end(args);\n\n\treturn r;\n}\nexport_symbol(printk);\n\n#else \n\n#define log_line_max\t\t0\n#define prefix_max\t\t0\n\nstatic u64 syslog_seq;\nstatic u32 syslog_idx;\nstatic u64 console_seq;\nstatic u32 console_idx;\nstatic enum log_flags syslog_prev;\nstatic u64 log_first_seq;\nstatic u32 log_first_idx;\nstatic u64 log_next_seq;\nstatic enum log_flags console_prev;\nstatic struct cont {\n\tsize_t len;\n\tsize_t cons;\n\tu8 level;\n\tbool flushed:1;\n} cont;\nstatic struct printk_log *log_from_idx(u32 idx) { return null; }\nstatic u32 log_next(u32 idx) { return 0; }\nstatic void call_console_drivers(int level, const char *text, size_t len) {}\nstatic size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }\nstatic size_t cont_print_text(char *text, size_t size) { return 0; }\n\n\ndefine_per_cpu(printk_func_t, printk_func);\n\n#endif \n\n#ifdef config_early_printk\nstruct console *early_console;\n\nasmlinkage __visible void early_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tint n;\n\n\tif (!early_console)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tn = vscnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\n\tearly_console->write(early_console, buf, n);\n}\n#endif\n\nstatic int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t\n\tfor (i = 0, c = console_cmdline;\n\t     i < max_cmdlineconsoles && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tselected_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == max_cmdlineconsoles)\n\t\treturn -e2big;\n\tif (!brl_options)\n\t\tselected_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}\n\nstatic int __init console_setup(char *str)\n{\n\tchar buf[sizeof(console_cmdline[0].name) + 4]; \n\tchar *s, *options, *brl_options = null;\n\tint idx;\n\n\tif (_braille_console_setup(&str, &brl_options))\n\t\treturn 1;\n\n\t\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tstrcpy(buf, \"": 1354, "\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"": 1355, "\";\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n}\n\nstatic ssize_t\ntrace_options_core_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t\t loff_t *ppos)\n{\n\tstruct trace_array *tr = &global_trace;\n\tlong index = (long)filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -einval;\n\n\tmutex_lock(&trace_types_lock);\n\tret = set_tracer_flag(tr, 1 << index, val);\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations trace_options_core_fops = {\n\t.open = tracing_open_generic,\n\t.read = trace_options_core_read,\n\t.write = trace_options_core_write,\n\t.llseek = generic_file_llseek,\n};\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warning(\"": 1356, "\";\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n}\n\nstatic ssize_t\ntrace_options_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t\t loff_t *ppos)\n{\n\tstruct trace_option_dentry *topt = filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -einval;\n\n\tif (!!(topt->flags->val & topt->opt->bit) != val) {\n\t\tmutex_lock(&trace_types_lock);\n\t\tret = __set_tracer_option(topt->tr, topt->flags,\n\t\t\t\t\t  topt->opt, !val);\n\t\tmutex_unlock(&trace_types_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\n\nstatic const struct file_operations trace_options_fops = {\n\t.open = tracing_open_generic,\n\t.read = trace_options_read,\n\t.write = trace_options_write,\n\t.llseek\t= generic_file_llseek,\n};\n\nstatic ssize_t\ntrace_options_core_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t\tloff_t *ppos)\n{\n\tlong index = (long)filp->private_data;\n\tchar *buf;\n\n\tif (trace_flags & (1 << index))\n\t\tbuf = \"": 1357, "\";\n\nstatic u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,\n\t\t\tu16 *dict_len, u32 *pad_len)\n{\n\t\n\tu32 max_text_len = log_buf_len / max_log_take_part;\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\t\n\t*trunc_msg_len = strlen(trunc_msg);\n\t\n\t*dict_len = 0;\n\t\n\treturn msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);\n}\n\n\nstatic int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}\n\nint dmesg_restrict = is_enabled(config_security_dmesg_restrict);\n\nstatic int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t\n\treturn type != syslog_action_read_all &&\n\t       type != syslog_action_size_buffer;\n}\n\nint check_syslog_permissions(int type, bool from_file)\n{\n\t\n\tif (from_file && type != syslog_action_open)\n\t\treturn 0;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(cap_syslog))\n\t\t\treturn 0;\n\t\t\n\t\tif (capable(cap_sys_admin)) {\n\t\t\tpr_warn_once(\"": 1358, "\";\n}\n\nstatic inline u64 perf_clock(void)\n{\n\treturn local_clock();\n}\n\nstatic inline u64 perf_event_clock(struct perf_event *event)\n{\n\treturn event->clock();\n}\n\nstatic inline struct perf_cpu_context *\n__get_cpu_context(struct perf_event_context *ctx)\n{\n\treturn this_cpu_ptr(ctx->pmu->pmu_cpu_context);\n}\n\nstatic void perf_ctx_lock(struct perf_cpu_context *cpuctx,\n\t\t\t  struct perf_event_context *ctx)\n{\n\traw_spin_lock(&cpuctx->ctx.lock);\n\tif (ctx)\n\t\traw_spin_lock(&ctx->lock);\n}\n\nstatic void perf_ctx_unlock(struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tif (ctx)\n\t\traw_spin_unlock(&ctx->lock);\n\traw_spin_unlock(&cpuctx->ctx.lock);\n}\n\n#ifdef config_cgroup_perf\n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\n\t\n\tif (!event->cgrp)\n\t\treturn true;\n\n\t\n\tif (!cpuctx->cgrp)\n\t\treturn false;\n\n\t\n\treturn cgroup_is_descendant(cpuctx->cgrp->css.cgroup,\n\t\t\t\t    event->cgrp->css.cgroup);\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{\n\tcss_put(&event->cgrp->css);\n\tevent->cgrp = null;\n}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn event->cgrp != null;\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\tstruct perf_cgroup_info *t;\n\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\treturn t->time;\n}\n\nstatic inline void __update_cgrp_time(struct perf_cgroup *cgrp)\n{\n\tstruct perf_cgroup_info *info;\n\tu64 now;\n\n\tnow = perf_clock();\n\n\tinfo = this_cpu_ptr(cgrp->info);\n\n\tinfo->time += now - info->timestamp;\n\tinfo->timestamp = now;\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_cgroup *cgrp_out = cpuctx->cgrp;\n\tif (cgrp_out)\n\t\t__update_cgrp_time(cgrp_out);\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n\tstruct perf_cgroup *cgrp;\n\n\t\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(current);\n\t\n\tif (cgrp == event->cgrp)\n\t\t__update_cgrp_time(event->cgrp);\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct perf_cgroup_info *info;\n\n\t\n\tif (!task || !ctx->nr_cgroups)\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(task);\n\tinfo = this_cpu_ptr(cgrp->info);\n\tinfo->timestamp = ctx->timestamp;\n}\n\n#define perf_cgroup_swout\t0x1 \n#define perf_cgroup_swin\t0x2 \n\n\nvoid perf_cgroup_switch(struct task_struct *task, int mode)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\t\n\tlocal_irq_save(flags);\n\n\t\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tcontinue; \n\n\t\t\n\t\tif (cpuctx->ctx.nr_cgroups > 0) {\n\t\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\t\t\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\t\t\tif (mode & perf_cgroup_swout) {\n\t\t\t\tcpu_ctx_sched_out(cpuctx, event_all);\n\t\t\t\t\n\t\t\t\tcpuctx->cgrp = null;\n\t\t\t}\n\n\t\t\tif (mode & perf_cgroup_swin) {\n\t\t\t\twarn_on_once(cpuctx->cgrp);\n\t\t\t\t\n\t\t\t\tcpuctx->cgrp = perf_cgroup_from_task(task);\n\t\t\t\tcpu_ctx_sched_in(cpuctx, event_all, task);\n\t\t\t}\n\t\t\tperf_pmu_enable(cpuctx->ctx.pmu);\n\t\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tlocal_irq_restore(flags);\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = null;\n\n\t\n\tcgrp1 = perf_cgroup_from_task(task);\n\n\t\n\tif (next)\n\t\tcgrp2 = perf_cgroup_from_task(next);\n\n\t\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, perf_cgroup_swout);\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = null;\n\n\t\n\tcgrp1 = perf_cgroup_from_task(task);\n\n\t\n\tcgrp2 = perf_cgroup_from_task(prev);\n\n\t\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, perf_cgroup_swin);\n}\n\nstatic inline int perf_cgroup_connect(int fd, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct cgroup_subsys_state *css;\n\tstruct fd f = fdget(fd);\n\tint ret = 0;\n\n\tif (!f.file)\n\t\treturn -ebadf;\n\n\tcss = css_tryget_online_from_dir(f.file->f_path.dentry,\n\t\t\t\t\t &perf_event_cgrp_subsys);\n\tif (is_err(css)) {\n\t\tret = ptr_err(css);\n\t\tgoto out;\n\t}\n\n\tcgrp = container_of(css, struct perf_cgroup, css);\n\tevent->cgrp = cgrp;\n\n\t\n\tif (group_leader && group_leader->cgrp != cgrp) {\n\t\tperf_detach_cgroup(event);\n\t\tret = -einval;\n\t}\nout:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n\tstruct perf_cgroup_info *t;\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\tevent->shadow_ctx_time = now - t->timestamp;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n\t\n\tif (is_cgroup_event(event) && !perf_cgroup_match(event))\n\t\tevent->cgrp_defer_enabled = 1;\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tif (!event->cgrp_defer_enabled)\n\t\treturn;\n\n\tevent->cgrp_defer_enabled = 0;\n\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= perf_event_state_inactive) {\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t\t\tsub->cgrp_defer_enabled = 0;\n\t\t}\n\t}\n}\n#else \n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\treturn true;\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline u64 perf_cgroup_event_cgrp_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n}\n\nstatic inline int perf_cgroup_connect(pid_t pid, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\treturn -einval;\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n}\n\nvoid\nperf_cgroup_switch(struct task_struct *task, struct task_struct *next)\n{\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n}\n#endif\n\n\n#define perf_cpu_hrtimer (1000 / hz)\n\nstatic enum hrtimer_restart perf_cpu_hrtimer_handler(struct hrtimer *hr)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tenum hrtimer_restart ret = hrtimer_norestart;\n\tint rotations = 0;\n\n\twarn_on(!irqs_disabled());\n\n\tcpuctx = container_of(hr, struct perf_cpu_context, hrtimer);\n\n\trotations = perf_rotate_context(cpuctx);\n\n\t\n\tif (rotations) {\n\t\thrtimer_forward_now(hr, cpuctx->hrtimer_interval);\n\t\tret = hrtimer_restart;\n\t}\n\n\treturn ret;\n}\n\n\nvoid perf_cpu_hrtimer_cancel(int cpu)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\tif (warn_on(cpu != smp_processor_id()))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\t\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\t\tcontinue;\n\n\t\thrtimer_cancel(&cpuctx->hrtimer);\n\t}\n\n\trcu_read_unlock();\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void __perf_cpu_hrtimer_init(struct perf_cpu_context *cpuctx, int cpu)\n{\n\tstruct hrtimer *hr = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tint timer;\n\n\t\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn;\n\n\t\n\ttimer = pmu->hrtimer_interval_ms;\n\tif (timer < 1)\n\t\ttimer = pmu->hrtimer_interval_ms = perf_cpu_hrtimer;\n\n\tcpuctx->hrtimer_interval = ns_to_ktime(nsec_per_msec * timer);\n\n\thrtimer_init(hr, clock_monotonic, hrtimer_mode_rel_pinned);\n\thr->function = perf_cpu_hrtimer_handler;\n}\n\nstatic void perf_cpu_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *hr = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\n\t\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn;\n\n\tif (hrtimer_active(hr))\n\t\treturn;\n\n\tif (!hrtimer_callback_running(hr))\n\t\t__hrtimer_start_range_ns(hr, cpuctx->hrtimer_interval,\n\t\t\t\t\t 0, hrtimer_mode_rel_pinned, 0);\n}\n\nvoid perf_pmu_disable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!(*count)++)\n\t\tpmu->pmu_disable(pmu);\n}\n\nvoid perf_pmu_enable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!--(*count))\n\t\tpmu->pmu_enable(pmu);\n}\n\nstatic define_per_cpu(struct list_head, active_ctx_list);\n\n\nstatic void perf_event_ctx_activate(struct perf_event_context *ctx)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\n\twarn_on(!irqs_disabled());\n\n\twarn_on(!list_empty(&ctx->active_ctx_list));\n\n\tlist_add(&ctx->active_ctx_list, head);\n}\n\nstatic void perf_event_ctx_deactivate(struct perf_event_context *ctx)\n{\n\twarn_on(!irqs_disabled());\n\n\twarn_on(list_empty(&ctx->active_ctx_list));\n\n\tlist_del_init(&ctx->active_ctx_list);\n}\n\nstatic void get_ctx(struct perf_event_context *ctx)\n{\n\twarn_on(!atomic_inc_not_zero(&ctx->refcount));\n}\n\nstatic void free_ctx(struct rcu_head *head)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = container_of(head, struct perf_event_context, rcu_head);\n\tkfree(ctx->task_ctx_data);\n\tkfree(ctx);\n}\n\nstatic void put_ctx(struct perf_event_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tif (ctx->parent_ctx)\n\t\t\tput_ctx(ctx->parent_ctx);\n\t\tif (ctx->task)\n\t\t\tput_task_struct(ctx->task);\n\t\tcall_rcu(&ctx->rcu_head, free_ctx);\n\t}\n}\n\n\nstatic struct perf_event_context *\nperf_event_ctx_lock_nested(struct perf_event *event, int nesting)\n{\n\tstruct perf_event_context *ctx;\n\nagain:\n\trcu_read_lock();\n\tctx = access_once(event->ctx);\n\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_nested(&ctx->mutex, nesting);\n\tif (event->ctx != ctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\n\treturn ctx;\n}\n\nstatic inline struct perf_event_context *\nperf_event_ctx_lock(struct perf_event *event)\n{\n\treturn perf_event_ctx_lock_nested(event, 0);\n}\n\nstatic void perf_event_ctx_unlock(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx)\n{\n\tmutex_unlock(&ctx->mutex);\n\tput_ctx(ctx);\n}\n\n\nstatic __must_check struct perf_event_context *\nunclone_ctx(struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *parent_ctx = ctx->parent_ctx;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (parent_ctx)\n\t\tctx->parent_ctx = null;\n\tctx->generation++;\n\n\treturn parent_ctx;\n}\n\nstatic u32 perf_event_pid(struct perf_event *event, struct task_struct *p)\n{\n\t\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_tgid_nr_ns(p, event->ns);\n}\n\nstatic u32 perf_event_tid(struct perf_event *event, struct task_struct *p)\n{\n\t\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_pid_nr_ns(p, event->ns);\n}\n\n\nstatic u64 primary_event_id(struct perf_event *event)\n{\n\tu64 id = event->id;\n\n\tif (event->parent)\n\t\tid = event->parent->id;\n\n\treturn id;\n}\n\n\nstatic struct perf_event_context *\nperf_lock_task_context(struct task_struct *task, int ctxn, unsigned long *flags)\n{\n\tstruct perf_event_context *ctx;\n\nretry:\n\t\n\tpreempt_disable();\n\trcu_read_lock();\n\tctx = rcu_dereference(task->perf_event_ctxp[ctxn]);\n\tif (ctx) {\n\t\t\n\t\traw_spin_lock_irqsave(&ctx->lock, *flags);\n\t\tif (ctx != rcu_dereference(task->perf_event_ctxp[ctxn])) {\n\t\t\traw_spin_unlock_irqrestore(&ctx->lock, *flags);\n\t\t\trcu_read_unlock();\n\t\t\tpreempt_enable();\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\t\traw_spin_unlock_irqrestore(&ctx->lock, *flags);\n\t\t\tctx = null;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tpreempt_enable();\n\treturn ctx;\n}\n\n\nstatic struct perf_event_context *\nperf_pin_task_context(struct task_struct *task, int ctxn)\n{\n\tstruct perf_event_context *ctx;\n\tunsigned long flags;\n\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\t++ctx->pin_count;\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\treturn ctx;\n}\n\nstatic void perf_unpin_context(struct perf_event_context *ctx)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t--ctx->pin_count;\n\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n}\n\n\nstatic void update_context_time(struct perf_event_context *ctx)\n{\n\tu64 now = perf_clock();\n\n\tctx->time += now - ctx->timestamp;\n\tctx->timestamp = now;\n}\n\nstatic u64 perf_event_time(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tif (is_cgroup_event(event))\n\t\treturn perf_cgroup_event_time(event);\n\n\treturn ctx ? ctx->time : 0;\n}\n\n\nstatic void update_event_times(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tu64 run_end;\n\n\tif (event->state < perf_event_state_inactive ||\n\t    event->group_leader->state < perf_event_state_inactive)\n\t\treturn;\n\t\n\tif (is_cgroup_event(event))\n\t\trun_end = perf_cgroup_event_time(event);\n\telse if (ctx->is_active)\n\t\trun_end = ctx->time;\n\telse\n\t\trun_end = event->tstamp_stopped;\n\n\tevent->total_time_enabled = run_end - event->tstamp_enabled;\n\n\tif (event->state == perf_event_state_inactive)\n\t\trun_end = event->tstamp_stopped;\n\telse\n\t\trun_end = perf_event_time(event);\n\n\tevent->total_time_running = run_end - event->tstamp_running;\n\n}\n\n\nstatic void update_group_times(struct perf_event *leader)\n{\n\tstruct perf_event *event;\n\n\tupdate_event_times(leader);\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry)\n\t\tupdate_event_times(event);\n}\n\nstatic struct list_head *\nctx_group_list(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tif (event->attr.pinned)\n\t\treturn &ctx->pinned_groups;\n\telse\n\t\treturn &ctx->flexible_groups;\n}\n\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\twarn_on_once(event->attach_state & perf_attach_context);\n\tevent->attach_state |= perf_attach_context;\n\n\t\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tif (is_software_event(event))\n\t\t\tevent->group_flags |= perf_group_software;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tctx->nr_cgroups++;\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}\n\n\nstatic inline void perf_event__state_init(struct perf_event *event)\n{\n\tevent->state = event->attr.disabled ? perf_event_state_off :\n\t\t\t\t\t      perf_event_state_inactive;\n}\n\n\nstatic void perf_event__read_size(struct perf_event *event)\n{\n\tint entry = sizeof(u64); \n\tint size = 0;\n\tint nr = 1;\n\n\tif (event->attr.read_format & perf_format_total_time_enabled)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & perf_format_total_time_running)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & perf_format_id)\n\t\tentry += sizeof(u64);\n\n\tif (event->attr.read_format & perf_format_group) {\n\t\tnr += event->group_leader->nr_siblings;\n\t\tsize += sizeof(u64);\n\t}\n\n\tsize += entry * nr;\n\tevent->read_size = size;\n}\n\nstatic void perf_event__header_size(struct perf_event *event)\n{\n\tstruct perf_sample_data *data;\n\tu64 sample_type = event->attr.sample_type;\n\tu16 size = 0;\n\n\tperf_event__read_size(event);\n\n\tif (sample_type & perf_sample_ip)\n\t\tsize += sizeof(data->ip);\n\n\tif (sample_type & perf_sample_addr)\n\t\tsize += sizeof(data->addr);\n\n\tif (sample_type & perf_sample_period)\n\t\tsize += sizeof(data->period);\n\n\tif (sample_type & perf_sample_weight)\n\t\tsize += sizeof(data->weight);\n\n\tif (sample_type & perf_sample_read)\n\t\tsize += event->read_size;\n\n\tif (sample_type & perf_sample_data_src)\n\t\tsize += sizeof(data->data_src.val);\n\n\tif (sample_type & perf_sample_transaction)\n\t\tsize += sizeof(data->txn);\n\n\tevent->header_size = size;\n}\n\nstatic void perf_event__id_header_size(struct perf_event *event)\n{\n\tstruct perf_sample_data *data;\n\tu64 sample_type = event->attr.sample_type;\n\tu16 size = 0;\n\n\tif (sample_type & perf_sample_tid)\n\t\tsize += sizeof(data->tid_entry);\n\n\tif (sample_type & perf_sample_time)\n\t\tsize += sizeof(data->time);\n\n\tif (sample_type & perf_sample_identifier)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & perf_sample_id)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & perf_sample_stream_id)\n\t\tsize += sizeof(data->stream_id);\n\n\tif (sample_type & perf_sample_cpu)\n\t\tsize += sizeof(data->cpu_entry);\n\n\tevent->id_header_size = size;\n}\n\nstatic void perf_group_attach(struct perf_event *event)\n{\n\tstruct perf_event *group_leader = event->group_leader, *pos;\n\n\t\n\tif (event->attach_state & perf_attach_group)\n\t\treturn;\n\n\tevent->attach_state |= perf_attach_group;\n\n\tif (group_leader == event)\n\t\treturn;\n\n\twarn_on_once(group_leader->ctx != event->ctx);\n\n\tif (group_leader->group_flags & perf_group_software &&\n\t\t\t!is_software_event(event))\n\t\tgroup_leader->group_flags &= ~perf_group_software;\n\n\tlist_add_tail(&event->group_entry, &group_leader->sibling_list);\n\tgroup_leader->nr_siblings++;\n\n\tperf_event__header_size(group_leader);\n\n\tlist_for_each_entry(pos, &group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(pos);\n}\n\n\nstatic void\nlist_del_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\twarn_on_once(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t\n\tif (!(event->attach_state & perf_attach_context))\n\t\treturn;\n\n\tevent->attach_state &= ~perf_attach_context;\n\n\tif (is_cgroup_event(event)) {\n\t\tctx->nr_cgroups--;\n\t\tcpuctx = __get_cpu_context(ctx);\n\t\t\n\t\tif (!ctx->nr_cgroups)\n\t\t\tcpuctx->cgrp = null;\n\t}\n\n\tctx->nr_events--;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat--;\n\n\tlist_del_rcu(&event->event_entry);\n\n\tif (event->group_leader == event)\n\t\tlist_del_init(&event->group_entry);\n\n\tupdate_group_times(event);\n\n\t\n\tif (event->state > perf_event_state_off)\n\t\tevent->state = perf_event_state_off;\n\n\tctx->generation++;\n}\n\nstatic void perf_group_detach(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *tmp;\n\tstruct list_head *list = null;\n\n\t\n\tif (!(event->attach_state & perf_attach_group))\n\t\treturn;\n\n\tevent->attach_state &= ~perf_attach_group;\n\n\t\n\tif (event->group_leader != event) {\n\t\tlist_del_init(&event->group_entry);\n\t\tevent->group_leader->nr_siblings--;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&event->group_entry))\n\t\tlist = &event->group_entry;\n\n\t\n\tlist_for_each_entry_safe(sibling, tmp, &event->sibling_list, group_entry) {\n\t\tif (list)\n\t\t\tlist_move_tail(&sibling->group_entry, list);\n\t\tsibling->group_leader = sibling;\n\n\t\t\n\t\tsibling->group_flags = event->group_flags;\n\n\t\twarn_on_once(sibling->ctx != event->ctx);\n\t}\n\nout:\n\tperf_event__header_size(event->group_leader);\n\n\tlist_for_each_entry(tmp, &event->group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(tmp);\n}\n\n\nstatic bool is_orphaned_event(struct perf_event *event)\n{\n\treturn event && !is_kernel_event(event) && !event->owner;\n}\n\n\nstatic bool is_orphaned_child(struct perf_event *event)\n{\n\treturn is_orphaned_event(event->parent);\n}\n\nstatic void orphans_remove_work(struct work_struct *work);\n\nstatic void schedule_orphans_remove(struct perf_event_context *ctx)\n{\n\tif (!ctx->task || ctx->orphans_remove_sched || !perf_wq)\n\t\treturn;\n\n\tif (queue_delayed_work(perf_wq, &ctx->orphans_remove, 1)) {\n\t\tget_ctx(ctx);\n\t\tctx->orphans_remove_sched = true;\n\t}\n}\n\nstatic int __init perf_workqueue_init(void)\n{\n\tperf_wq = create_singlethread_workqueue(\"": 1359, "\"<\"": 1360, "\"<%016llx-%016llx>\\n\"": 1361, "\"<-- %lx (%d) (start: %llx  end: %llx) over: %d\"": 1362, "\"<-signal> <pid>\"": 1363, "\"<<=\"": 1364, "\"<=\"": 1365, "\"<==%s() = %d\\n\"": 1366, "\"<==%s() = 0 [%x]\\n\"": 1367, "\"<==========\"": 1368, "\"<bad>\"": 1369, "\"<bpnum>\"": 1370, "\"<cpunum>\"": 1371, "\"<idle>\"": 1372, "\"<key>\"": 1373, "\"<no_memory>\"": 1374, "\"<none>\"": 1375, "\"<paddr> <bytes>\"": 1376, "\"<pid>\"": 1377, "\"<pidnum>\"": 1378, "\"<reg> <contents>\"": 1379, "\"<released>\\n\"": 1380, "\"<stack trace>\\n\"": 1381, "\"<sym> [<bytes>] [<cpu>]\"": 1382, "\"<too_long>\"": 1383, "\"<vaddr> <bytes>\"": 1384, "\"<vaddr> <contents>\"": 1385, "\"<vaddr>\"": 1386, "\"=\"": 1387, "\"=0\"": 1388, "\"==\"": 1389, "\"================================================\\n\"": 1390, "\"=============================================\\n\"": 1391, "\"=============================================\\n\\n\"": 1392, "\"=====================================\\n\"": 1393, "\"==================================\\n\"": 1394, "\"=================================\\n\"": 1395, "\"===============================\\n\"": 1396, "\"==========>\"": 1397, "\"====[ backtrace testing ]===========\\n\"": 1398, "\"====[ end of backtrace testing ]====\\n\"": 1399, "\"==>\"": 1400, "\"==>%s(,%zu)\\n\"": 1401, "\"==>%s(,%zu,,%zu)\\n\"": 1402, "\"=off\"": 1403, "\">\"": 1404, "\">=\"": 1405, "\">>=\"": 1406, "\"?\"": 1407, "\"?+|:';\\\",.<>/?abcdefghijklmnopqrstuvwxyz1234567890\"": 1408, "\"??\"": 1409, "\"??? writer stall state %d g%lu c%lu f%#x\\n\"": 1410, "\"???\"": 1411, "\"[ bug: %s/%d still has locks held! ]\\n\"": 1412, "\"[ bug: bad contention detected! ]\\n\"": 1413, "\"[ bug: bad unlock balance detected! ]\\n\"": 1414, "\"[ bug: circular locking deadlock detected! ]\\n\"": 1415, "\"[ bug: lock held when returning to user space! ]\\n\"": 1416, "\"[ bug: nested lock was not taken ]\\n\"": 1417, "\"[ info: inconsistent lock state ]\\n\"": 1418, "\"[ info: possible recursive locking detected ]\\n\"": 1419, "\"[ info: suspicious rcu usage. ]\\n\"": 1420, "\"[ turning off deadlock detection.\"": 1421, "\"[\"": 1422, "\"[%-5.5s%5u] \"": 1423, "\"[%016llx] %lld (+%lld): \"": 1424, "\"[%08llx] %ld.%03ldms (+%ld.%03ldms): \"": 1425, "\"[%d]\"": 1426, "\"[%d]\\n\"": 1427, "\"[%p] \"": 1428, "\"[%s] %llu\\n\"": 1429, "\"[%s] %s:%s:%d\\n\"": 1430, "\"[%s]\"": 1431, "\"[%s]\\n\"": 1432, "\"[%s]kdb> %s\\n\"": 1433, "\"[+0x%lx]\"": 1434, "\"[<%p>] %pf\"": 1435, "\"[<%p>]\"": 1436, "\"[<flags>|a]\"": 1437, "\"[<vaddr>]\"": 1438, "\"[datar [length]|dataw [length]]   set hw brk\"": 1439, "\"[defcmd]\"": 1440, "\"[disabled]\"": 1441, "\"[disabled]\\n\"": 1442, "\"[d|r|s|t|c|z|e|u|i|m|a]\"": 1443, "\"[eff]\"": 1444, "\"[ftrace]\"": 1445, "\"[gone]\"": 1446, "\"[heap]\"": 1447, "\"[lines]\"": 1448, "\"[optimized]\"": 1449, "\"[permanent],\"": 1450, "\"[real]\"": 1451, "\"[stack]\"": 1452, "\"[unknown/kretprobe'd]\"": 1453, "\"\\\"\"": 1454, "\"\\\", %s\"": 1455, "\"\\\"0x%lx\\\", rec->ret\"": 1456, "\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"": 1457, "\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\"": 1458, "\"\\\\\\\"%s\\\\\\\"\"": 1459, "\"\\n                                    \"": 1460, "\"\\n    is disabled\"": 1461, "\"\\n    is enabled\"": 1462, "\"\\n *** deadlock ***\\n\\n\"": 1463, "\"\\n ------------------------------------------\\n\\n\"": 1464, "\"\\n new dependency: \"": 1465, "\"\\n\"": 1466, "\"\\n%s/%d's [blocked] stackdump:\\n\\n\"": 1467, "\"\\n%s/%d's [current] stackdump:\\n\\n\"": 1468, "\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n\"": 1469, "\"\\n1) %s/%d is trying to acquire this lock:\\n\"": 1470, "\"\\n2) %s/%d is blocked on this lock:\\n\"": 1471, "\"\\n============================================\\n\"": 1472, "\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\"": 1473, "\"\\nacquire class [%p] %s\"": 1474, "\"\\nbut task is already holding lock:\\n\"": 1475, "\"\\nbut this task is not holding:\\n\"": 1476, "\"\\ncfs_rq[%d]:%s\\n\"": 1477, "\"\\ncfs_rq[%d]:\\n\"": 1478, "\"\\ndl_rq[%d]:\\n\"": 1479, "\"\\nentering kdb (0x%p, pid %d) \"": 1480, "\"\\nentering kdb (current=0x%p, pid %d) \"": 1481, "\"\\nhash chain already cached, key: \"": 1482, "\"\\nmarked lock as {%s}:\\n\"": 1483, "\"\\nnew class %p: %s\"": 1484, "\"\\nnew hash chain, key: %016lx tail class: [%p] %s\\n\"": 1485, "\"\\nother info that might help us debug this:\\n\"": 1486, "\"\\nother info that might help us debug this:\\n\\n\"": 1487, "\"\\nparse_error: %s\\n\"": 1488, "\"\\npred visited %s\\n\"": 1489, "\"\\nprint fmt: %s\\n\"": 1490, "\"\\nrt_rq[%d]:%s\\n\"": 1491, "\"\\nrt_rq[%d]:\\n\"": 1492, "\"\\nrunnable tasks:\\n\"": 1493, "\"\\nshowing all locks held in the system:\\n\"": 1494, "\"\\nstack backtrace:\\n\"": 1495, "\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\"": 1496, "\"\\t\"": 1497, "\"\\t%d: (%lu %s) idle=%03x/%llx/%d softirq=%u/%u fqs=%ld %s\\n\"": 1498, "\"\\t%s\\n\"": 1499, "\"\\t0x%lx %s\\n\"": 1500, "\"\\t=> (\"": 1501, "\"\\tadditional per-cpu info printed with stalls.\\n\"": 1502, "\"\\taddr at %016lx, hardtype=%d installed=%d\\n\"": 1503, "\"\\tboot-time adjustment of leaf fanout to %d.\\n\"": 1504, "\"\\tbuild-time adjustment of leaf fanout to %d.\\n\"": 1505, "\"\\tconfig_rcu_fanout set to non-default value of %d\\n\"": 1506, "\"\\tfield: char data;\\t\"": 1507, "\"\\tfield: int overwrite;\\t\"": 1508, "\"\\tfield: local_t commit;\\t\"": 1509, "\"\\tfield: u64 timestamp;\\t\"": 1510, "\"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\"": 1511, "\"\\tfield:%s %s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\"": 1512, "\"\\tfour-level hierarchy is enabled.\\n\"": 1513, "\"\\thierarchical rcu autobalancing is disabled.\\n\"": 1514, "\"\\tnote: kernel parameter 'rcu_nocbs=' contains nonexistent cpus.\\n\"": 1515, "\"\\toffload rcu callbacks from all cpus\\n\"": 1516, "\"\\toffload rcu callbacks from cpu 0\\n\"": 1517, "\"\\toffload rcu callbacks from cpus: %*pbl.\\n\"": 1518, "\"\\tpoll for callbacks from no-cbs cpus.\\n\"": 1519, "\"\\trcu debugfs-based tracing is enabled.\\n\"": 1520, "\"\\trcu dyntick-idle grace-period acceleration is enabled.\\n\"": 1521, "\"\\trcu kthread priority: %d.\\n\"": 1522, "\"\\trcu lockdep checking is enabled.\\n\"": 1523, "\"\\trcu restricting cpus from nr_cpus=%d to nr_cpu_ids=%d.\\n\"": 1524, "\"\\trcu torture testing starts during boot.\\n\"": 1525, "\"\\ttasks blocked on level-%d rcu_node (cpus %d-%d):\"": 1526, "\"\\ttramp: %ps\"": 1527, "\"\\ttramp: error!\"": 1528, "\"]\"": 1529, "\"]\\n\"": 1530, "\"^=\"": 1531, "\"__call_rcu(): leaked duplicate callback\\n\"": 1532, "\"__data_loc char[]\"": 1533, "\"__data_loc\"": 1534, "\"__devel__sane_behavior\"": 1535, "\"__ex_table\"": 1536, "\"__gnu_lto\"": 1537, "\"__jump_table\"": 1538, "\"__kcrctab\"": 1539, "\"__kcrctab_gpl\"": 1540, "\"__kcrctab_gpl_future\"": 1541, "\"__kcrctab_unused\"": 1542, "\"__kcrctab_unused_gpl\"": 1543, "\"__ksymtab\"": 1544, "\"__ksymtab_gpl\"": 1545, "\"__ksymtab_gpl_future\"": 1546, "\"__ksymtab_unused\"": 1547, "\"__ksymtab_unused_gpl\"": 1548, "\"__mcount_loc\"": 1549, "\"__obsparm\"": 1550, "\"__param\"": 1551, "\"__probe_func\"": 1552, "\"__probe_ip\"": 1553, "\"__probe_ret_ip\"": 1554, "\"__put_cred(%p{%d,%d})\"": 1555, "\"__timekeeping_inject_sleeptime: invalid \"": 1556, "\"__trace_printk_fmt\"": 1557, "\"__tracepoints_ptrs\"": 1558, "\"__verbose\"": 1559, "\"__versions\"": 1560, "\"_filter=\"": 1561, "\"_ftrace_enum_map\"": 1562, "\"_ftrace_events\"": 1563, "\"a %d, b %d, c %d, d %d, e %d, f %d, g %d, h %d\"": 1564, "\"a == 1 && b == 1 && c == 1 && d == 1 && \"": 1565, "\"a == 1 || b == 1 || c == 1 || d == 1 || \"": 1566, "\"a\"": 1567, "\"aarp-expiry-time\"": 1568, "\"aarp-resolve-time\"": 1569, "\"aarp-retransmit-limit\"": 1570, "\"aarp-tick-time\"": 1571, "\"abcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()?+\\\\\"": 1572, "\"abi\"": 1573, "\"abort_creds(%p{%d,%d})\"": 1574, "\"aborting hibernation\\n\"": 1575, "\"aborting resume\\n\"": 1576, "\"abs_timeout_sec=%ld abs_timeout_nsec=%ld\"": 1577, "\"absolute symbol: 0x%08lx\\n\"": 1578, "\"accept_ra\"": 1579, "\"accept_ra_defrtr\"": 1580, "\"accept_ra_from_local\"": 1581, "\"accept_ra_pinfo\"": 1582, "\"accept_ra_rt_info_max_plen\"": 1583, "\"accept_ra_rtr_pref\"": 1584, "\"accept_redirects\"": 1585, "\"accept_source_route\"": 1586, "\"accreadycb\"": 1587, "\"acct\"": 1588, "\"accwaitcb\"": 1589, "\"ack\"": 1590, "\"ack_timeout\"": 1591, "\"acknowledge_hold_back_timeout\"": 1592, "\"acknowledgement_hold_back_timeout\"": 1593, "\"acpi_video_flags\"": 1594, "\"acq-bounces\"": 1595, "\"acquisitions\"": 1596, "\"active\"": 1597, "\"add_rule\"": 1598, "\"added domain %s\\n\"": 1599, "\"adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\"": 1600, "\"addip_enable\"": 1601, "\"adjusting %s more than 11%% (%ld vs %ld)\\n\"": 1602, "\"admin_reserve_kbytes\"": 1603, "\"affinity_hint\"": 1604, "\"age_buffer_centisecs\"": 1605, "\"aggrprobe@%p\\n\"": 1606, "\"ahead\"": 1607, "\"aio-max-nr\"": 1608, "\"aio-nr\"": 1609, "\"alarmtimer\"": 1610, "\"all branches stats\\n\"": 1611, "\"all leafs should have field defined\"": 1612, "\"all lock classes:\\n\"": 1613, "\"all qses seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\"": 1614, "\"all\"": 1615, "\"alloc_snapshot\"": 1616, "\"allocated_dquots\"": 1617, "\"allocating new usage for %s.\\n\"": 1618, "\"allow rcu readers from irq handlers\"": 1619, "\"allow\"": 1620, "\"already unlocked\"": 1621, "\"alu\"": 1622, "\"alu64\"": 1623, "\"and/or required key missing - tainting \"": 1624, "\"annotated branches stats\\n\"": 1625, "\"another field.\\n\"": 1626, "\"another i/o driver is already registered with kgdb\\n\"": 1627, "\"app_solicit\"": 1628, "\"appletalk\"": 1629, "\"applying patch '%s' to loading module '%s'\\n\"": 1630, "\"arch=%x syscall=%d\"": 1631, "\"architecture specific data\"": 1632, "\"arg%d\"": 1633, "\"arg_const_stack_size cannot be first argument\\n\"": 1634, "\"argc=%d\"": 1635, "\"argument is too long.: %s\\n\"": 1636, "\"argument[%d] name '%s' conflicts with \"": 1637, "\"arjan van de ven <arjan@linux.intel.com>\"": 1638, "\"arp_accept\"": 1639, "\"arp_announce\"": 1640, "\"arp_filter\"": 1641, "\"arp_ignore\"": 1642, "\"arp_notify\"": 1643, "\"association_max_retrans\"": 1644, "\"asymmetric\"": 1645, "\"async_continuing @ %i after %lli usec\\n\"": 1646, "\"async_waiting @ %i\\n\"": 1647, "\"at the time of bpf_ld_abs|ind r6 != pointer to skb\\n\"": 1648, "\"attempt to kill tasklet from interrupt\\n\"": 1649, "\"attempting to continue\\n\"": 1650, "\"audit rule for lsm \\'%s\\' is invalid\\n\"": 1651, "\"audit(%lu.%03lu:%u): \"": 1652, "\"audit.h\"": 1653, "\"audit: %s\\n\"": 1654, "\"audit_backlog=%d > audit_backlog_limit=%d\\n\"": 1655, "\"audit_backlog_limit\"": 1656, "\"audit_backlog_wait_time\"": 1657, "\"audit_enabled\"": 1658, "\"audit_failure\"": 1659, "\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\"": 1660, "\"audit_possible is deprecated\\n\"": 1661, "\"audit_prune_tree\"": 1662, "\"audit_rate_limit\"": 1663, "\"audit_send_list\"": 1664, "\"audit_send_reply\"": 1665, "\"auid=%u ses=%u op=\"": 1666, "\"auid=%u ses=%u\"": 1667, "\"auid=%u uid=%u gid=%u ses=%u\"": 1668, "\"auto_group.h\"": 1669, "\"autoconf\"": 1670, "\"autogroup_create: %s failure.\\n\"": 1671, "\"autosleep\"": 1672, "\"available_events\"": 1673, "\"ax25\"": 1674, "\"ax25_default_mode\"": 1675, "\"b\"": 1676, "\"b.\"": 1677, "\"back-edge from insn %d to %d\\n\"": 1678, "\"backlog limit exceeded\"": 1679, "\"backmerge\"": 1680, "\"backoff_type\"": 1681, "\"backtrace all processes matching state flag\"": 1682, "\"backtrace current process on each cpu\"": 1683, "\"backtrace process given its struct task address\"": 1684, "\"bad frame pointer: expected %lx, received %lx\\n\"": 1685, "\"bad magic\"": 1686, "\"bad rc=0x%x from %pf()\\n\"": 1687, "\"bad trampoline accounting at: %p (%ps) (%lx)\\n\"": 1688, "\"bad trampoline accounting at: %p (%ps)\\n\"": 1689, "\"bad vermagic\"": 1690, "\"bad: scheduling from the idle thread!\\n\"": 1691, "\"barrier: %ld/%ld:%ld \"": 1692, "\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\"": 1693, "\"base_reachable_time\"": 1694, "\"base_reachable_time_ms\"": 1695, "\"bc\"": 1696, "\"bcc: %d nbd: %lu\\n\"": 1697, "\"bcdef\"": 1698, "\"bcdefgh\"": 1699, "\"bd\"": 1700, "\"bdfh\"": 1701, "\"be\"": 1702, "\"begin\"": 1703, "\"bindv6only\"": 1704, "\"binfmt_misc\"": 1705, "\"bl\"": 1706, "\"blk\"": 1707, "\"block\"": 1708, "\"block_dump\"": 1709, "\"block_iopoll\"": 1710, "\"blocked_load_avg\"": 1711, "\"boot_id\"": 1712, "\"bootloader_type\"": 1713, "\"bootloader_version\"": 1714, "\"bootp_relay\"": 1715, "\"bounce\"": 1716, "\"bp #%d at \"": 1717, "\"bp\"": 1718, "\"bpf program is too complex\\n\"": 1719, "\"bpf program is too large. proccessed %d insn\\n\"": 1720, "\"bpf verifier is misconfigured\\n\"": 1721, "\"bpf-map\"": 1722, "\"bpf_alu uses reserved fields\\n\"": 1723, "\"bpf_call uses reserved fields\\n\"": 1724, "\"bpf_end uses reserved fields\\n\"": 1725, "\"bpf_exit uses reserved fields\\n\"": 1726, "\"bpf_ja uses reserved fields\\n\"": 1727, "\"bpf_jmp uses reserved fields\\n\"": 1728, "\"bpf_ld_abs uses reserved fields\\n\"": 1729, "\"bpf_ld_abs|ind instructions not allowed for this program type\\n\"": 1730, "\"bpf_ld_imm64 uses reserved fields\\n\"": 1731, "\"bpf_ldx uses reserved fields\\n\"": 1732, "\"bpf_mov uses reserved fields\\n\"": 1733, "\"bpf_neg uses reserved fields\\n\"": 1734, "\"bpf_st uses reserved fields\\n\"": 1735, "\"bpf_stx uses reserved fields\\n\"": 1736, "\"bpf_xadd uses reserved fields\\n\"": 1737, "\"bph\"": 1738, "\"braille.h\"": 1739, "\"branch events\\n\"": 1740, "\"branch\"": 1741, "\"branch_all\"": 1742, "\"branch_annotated\"": 1743, "\"breakpoint %d at \"": 1744, "\"breakpoint\"": 1745, "\"broadcast\"": 1746, "\"bset\"": 1747, "\"bt\"": 1748, "\"bta\"": 1749, "\"btaprompt\"": 1750, "\"btc\"": 1751, "\"btc: cpu status: \"": 1752, "\"btp\"": 1753, "\"btt 0x%p\\n\"": 1754, "\"btt\"": 1755, "\"buffer had: %.*s\\n\"": 1756, "\"buffer only contains %d lines, \"": 1757, "\"buffer only contains %d lines, last %d \"": 1758, "\"buffer only contains %d lines, nothing \"": 1759, "\"bug\"": 1760, "\"bug: arch topology borken\\n\"": 1761, "\"bug: bad rss-counter state \"": 1762, "\"bug: function graph tracer hang!\\n\"": 1763, "\"bug: key %p not in .data!\\n\"": 1764, "\"bug: looking up invalid subclass: %u\\n\"": 1765, "\"bug: max_lock_depth too low!\"": 1766, "\"bug: max_lockdep_chains too low!\"": 1767, "\"bug: max_lockdep_entries too low!\"": 1768, "\"bug: max_lockdep_keys too low!\"": 1769, "\"bug: max_stack_trace_entries too low!\"": 1770, "\"bug: non-zero nr_pmds on freeing mm: %ld\\n\"": 1771, "\"bug: non-zero nr_ptes on freeing mm: %ld\\n\"": 1772, "\"bug: read-lock lockup on cpu#%d, \"": 1773, "\"bug: rwlock %s on cpu#%d, %s/%d, %p\\n\"": 1774, "\"bug: sleeping function called from invalid context at %s:%d\\n\"": 1775, "\"bug: soft lockup - cpu#%d stuck for %us! [%s:%d]\\n\"": 1776, "\"bug: spinlock %s on cpu#%d, %s/%d\\n\"": 1777, "\"bug: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"": 1778, "\"bug: write-lock lockup on cpu#%d, \"": 1779, "\"bug_%02x\\n\"": 1780, "\"bug_ld_%02x\\n\"": 1781, "\"bug_ldx_%02x\\n\"": 1782, "\"bug_st_%02x\\n\"": 1783, "\"bus\"": 1784, "\"busy\"": 1785, "\"busy_factor\"": 1786, "\"busy_idx\"": 1787, "\"but no thread function available.\"": 1788, "\"but there are no locks held!\\n\"": 1789, "\"but there are no more locks to release!\\n\"": 1790, "\"but this lock took another, %s-unsafe lock in the past:\\n\"": 1791, "\"but this lock was taken by another, %s-safe lock in the past:\\n\"": 1792, "\"c\"": 1793, "\"c=%ld g=%ld s=%d jfq=%ld j=%x \"": 1794, "\"cache_hits\"": 1795, "\"cache_nice_tries\"": 1796, "\"cad_pid\"": 1797, "\"call\"": 1798, "\"call_request_timeout\"": 1799, "\"calling  %lli_%pf @ %i\\n\"": 1800, "\"can not test ... force \"": 1801, "\"can't allocate system trusted keyring\\n\"": 1802, "\"can't do kill command now.\\n\"": 1803, "\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\"": 1804, "\"cannot call gpl only function from proprietary program\\n\"": 1805, "\"cannot convert secid to context\"": 1806, "\"cannot create audit fsnotify group\"": 1807, "\"cannot halt\"": 1808, "\"cannot initialize netlink socket in namespace\"": 1809, "\"cannot start thread audit_prune_tree\"": 1810, "\"cap_fi\"": 1811, "\"cap_fp\"": 1812, "\"cap_last_cap\"": 1813, "\"cap_pe\"": 1814, "\"cap_pi\"": 1815, "\"cap_pp\"": 1816, "\"cascade\"": 1817, "\"cat \"": 1818, "\"catastrophic error detected\\n\"": 1819, "\"cb\"": 1820, "\"cbflood: %ld\\n\"": 1821, "\"ccversion  %s\\n\"": 1822, "\"ce: %s increased min_delta_ns to %llu nsec\\n\"": 1823, "\"ce: reprogramming failure. giving up\\n\"": 1824, "\"ceg\"": 1825, "\"cfs_period_us\"": 1826, "\"cfs_quota_us\"": 1827, "\"cgroup\"": 1828, "\"cgroup.clone_children\"": 1829, "\"cgroup.controllers\"": 1830, "\"cgroup.populated\"": 1831, "\"cgroup.procs\"": 1832, "\"cgroup.sane_behavior\"": 1833, "\"cgroup.subtree_control\"": 1834, "\"cgroup: failed to update controllers for the default hierarchy (%d), further operations may crash or hang\\n\"": 1835, "\"cgroup: update_dfl_csses failed to make progress, aborting in inconsistent state\\n\"": 1836, "\"cgroup: using legacy files on the default hierarchy\\n\"": 1837, "\"cgroup__devel__legacy_files_on_dfl\"": 1838, "\"cgroup_css_links\"": 1839, "\"cgroup_disable=\"": 1840, "\"cgroup_mutex or rcu read lock required\"": 1841, "\"cgroup_subsys_name %s too long\\n\"": 1842, "\"char\"": 1843, "\"check\"": 1844, "\"cipso_cache_bucket_size\"": 1845, "\"cipso_cache_enable\"": 1846, "\"cipso_rbm_optfmt\"": 1847, "\"cipso_rbm_strictvalid\"": 1848, "\"class name\"": 1849, "\"cleanup\"": 1850, "\"cleanupmore\"": 1851, "\"clear breakpoint\"": 1852, "\"clear_request_timeout\"": 1853, "\"clock-delta\"": 1854, "\"clockevent\"": 1855, "\"clockevents\"": 1856, "\"clockevents: \"": 1857, "\"clone_children\"": 1858, "\"cm\"": 1859, "\"cmode\"": 1860, "\"code at %08lx: \"": 1861, "\"coming\"": 1862, "\"command ignored\\n%s\\n\"": 1863, "\"command only available during kdb_init()\\n\"": 1864, "\"command\"": 1865, "\"commit_creds(%p{%d,%d})\"": 1866, "\"common symbol: %s\\n\"": 1867, "\"common_\"": 1868, "\"common_flags\"": 1869, "\"common_pid\"": 1870, "\"common_preempt_count\"": 1871, "\"common_tgid\"": 1872, "\"common_type\"": 1873, "\"compact_memory\"": 1874, "\"compact_unevictable_allowed\"": 1875, "\"compat-log\"": 1876, "\"complete\"": 1877, "\"completed=%ld  gpnum=%ld  age=%ld  max=%ld\\n\"": 1878, "\"component: %s, time: %u\\n\"": 1879, "\"con-bounces\"": 1880, "\"concurrent rmmod and shutdown illegal!\\n\"": 1881, "\"conf\"": 1882, "\"config.gz\"": 1883, "\"config_data.h\"": 1884, "\"connect_mode\"": 1885, "\"console_cmdline.h\"": 1886, "\"console_lock\"": 1887, "\"contentions\"": 1888, "\"continue execution\"": 1889, "\"cookie_preserve_enable\"": 1890, "\"core dump path required.\\n\"": 1891, "\"core section allocation order:\\n\"": 1892, "\"core\"": 1893, "\"core_pattern\"": 1894, "\"core_pipe_limit\"": 1895, "\"core_uses_pid\"": 1896, "\"could not add '%s' (incompatible \"": 1897, "\"could not add '%s' (out of memory)\\n\"": 1898, "\"could not allocate control_code_buffer\\n\"": 1899, "\"could not allocate memory for swsusp_header\\n\"": 1900, "\"could not allocate new defcmd_set entry for %s\\n\"": 1901, "\"could not allocate new kdb_command \"": 1902, "\"could not allocate swap buffer\\n\"": 1903, "\"could not create file\\n\"": 1904, "\"could not create tracefs \"": 1905, "\"could not create tracefs '%s' directory\\n\"": 1906, "\"could not create tracefs '%s/filter' entry\\n\"": 1907, "\"could not create tracefs 'available_events' entry\\n\"": 1908, "\"could not create tracefs 'events' directory\\n\"": 1909, "\"could not create tracefs 'set_event' entry\\n\"": 1910, "\"could not insert probe at %s+%lu: %d\\n\"": 1911, "\"could not register function stat for cpu %d\\n\"": 1912, "\"could not remove '%s' (not found)\\n\"": 1913, "\"could not save data for '%s' \"": 1914, "\"could not switch to one-shot mode:\"": 1915, "\"couldn't find or set field in one of a subsystem's events\"": 1916, "\"count %u\\n\"": 1917, "\"cpu %d:\\n\"": 1918, "\"cpu %ld is not online\\n\"": 1919, "\"cpu recursion\"": 1920, "\"cpu\"": 1921, "\"cpu#%d, %u.%03u mhz\\n\"": 1922, "\"cpu#%d\\n\"": 1923, "\"cpu%d %u 0 %u %u %u %u %llu %llu %lu\"": 1924, "\"cpu%d attaching null sched-domain.\\n\"": 1925, "\"cpu%d attaching sched-domain:\\n\"": 1926, "\"cpu%d is up\\n\"": 1927, "\"cpu%d\"": 1928, "\"cpu%d\\n\"": 1929, "\"cpu\\n\"": 1930, "\"cpu_dma_latency\"": 1931, "\"cpu_exclusive\"": 1932, "\"cpu_hotplug.lock\"": 1933, "\"cpu_off\"": 1934, "\"cpu_on\"": 1935, "\"cpu_stop: %s(%p) leaked preempt count\\n\"": 1936, "\"cpuacct.h\"": 1937, "\"cpudeadline.h\"": 1938, "\"cpudump\"": 1939, "\"cpuend\"": 1940, "\"cpuofl\"": 1941, "\"cpuonl\"": 1942, "\"cpupri.h\"": 1943, "\"cpuqs\"": 1944, "\"cpus\"": 1945, "\"cpuset\"": 1946, "\"cpuset,noprefix,\"": 1947, "\"cpuset: failed to transfer tasks out of empty cpuset \"": 1948, "\"cpustart\"": 1949, "\"crash kernel\"": 1950, "\"crash_kexec_post_notifiers\"": 1951, "\"crashkernel: '-' expected\\n\"": 1952, "\"crashkernel: invalid size\\n\"": 1953, "\"crashkernel: memory value expected\\n\"": 1954, "\"crashkernel: unrecognized char\\n\"": 1955, "\"create\"": 1956, "\"create_direct obtained virq %d\\n\"": 1957, "\"create_direct virq allocation failed\\n\"": 1958, "\"creating rcu_torture_boost task\"": 1959, "\"cred: ->*gid = { %d,%d,%d,%d }\\n\"": 1960, "\"cred: ->*uid = { %d,%d,%d,%d }\\n\"": 1961, "\"cred: ->magic=%x, put_addr=%p\\n\"": 1962, "\"cred: ->security is %p\\n\"": 1963, "\"cred: ->usage=%d, subscr=%d\\n\"": 1964, "\"cred: put_cred_rcu() sees %p with usage %d\\n\"": 1965, "\"cred: put_cred_rcu() sees %p with\"": 1966, "\"cred_jar\"": 1967, "\"critical breakpoint error, kernel memory destroyed at: %lx\\n\"": 1968, "\"css_set %p\\n\"": 1969, "\"ctrl-alt-del\"": 1970, "\"ctx\"": 1971, "\"curr->pid\"": 1972, "\"current pid: %d comm: %s / idle pid: %d comm: %s\"": 1973, "\"current_css_set\"": 1974, "\"current_css_set_cg_links\"": 1975, "\"current_css_set_refcount\"": 1976, "\"cxt.lwsa: out of memory\"": 1977, "\"d\"": 1978, "\"dad_transmits\"": 1979, "\"dama_slave_timeout\"": 1980, "\"data access\"": 1981, "\"data write\"": 1982, "\"datar\"": 1983, "\"dataw\"": 1984, "\"date       %04d-%02d-%02d %02d:%02d:%02d \"": 1985, "\"ddcmp\"": 1986, "\"debug\"": 1987, "\"debug(g)\"": 1988, "\"debug.h\"": 1989, "\"debug_active\"": 1990, "\"debug_core.h\"": 1991, "\"debug_stoppable\"": 1992, "\"decnet\"": 1993, "\"decnet_mem\"": 1994, "\"decnet_rmem\"": 1995, "\"decnet_wmem\"": 1996, "\"default domain set to @0x%p\\n\"": 1997, "\"default\"": 1998, "\"default_device\"": 1999, "\"default_path_quality\"": 2000, "\"defcmd\"": 2001, "\"deferredwake\"": 2002, "\"define a set of commands, down to endefcmd\"": 2003, "\"delay_first_probe_time\"": 2004, "\"delete command needs an event name.\\n\"": 2005, "\"delete\"": 2006, "\"dentry-state\"": 2007, "\"deny\"": 2008, "\"depth: %i  max: %lu!\\n\"": 2009, "\"description\"": 2010, "\"dev\"": 2011, "\"dev_weight\"": 2012, "\"devices\"": 2013, "\"devname\"": 2014, "\"dfh\"": 2015, "\"di_count\"": 2016, "\"dir-notify-enable\"": 2017, "\"dirty_background_bytes\"": 2018, "\"dirty_background_ratio\"": 2019, "\"dirty_bytes\"": 2020, "\"dirty_expire_centisecs\"": 2021, "\"dirty_ratio\"": 2022, "\"dirty_writeback_centisecs\"": 2023, "\"dirtytime_expire_seconds\"": 2024, "\"disable breakpoint\"": 2025, "\"disable irq lockup detection when true\"": 2026, "\"disable nmi entry to kdb\"": 2027, "\"disable_event\"": 2028, "\"disable_nmi\"": 2029, "\"disable_policy\"": 2030, "\"disable_xfrm\"": 2031, "\"disabled (cpu%i): hardware events not enabled\\n\"": 2032, "\"disabled (cpu%i): not supported (no lapic?)\\n\"": 2033, "\"disabled (cpu%i): unable to create perf event: %ld\\n\"": 2034, "\"disabled\"": 2035, "\"disabled\\n\"": 2036, "\"disabling %s control group\"": 2037, "\"disabling ftrace selftests due to running tracer '%s'\\n\"": 2038, "\"disabling irq #%d\\n\"": 2039, "\"disabling lock debugging due to kernel taint\\n\"": 2040, "\"disabling non-boot cpus ...\\n\"": 2041, "\"disabling patch '%s'\\n\"": 2042, "\"discard\"": 2043, "\"discarding saved data for %s \"": 2044, "\"discovery\"": 2045, "\"discovery_slots\"": 2046, "\"discovery_timeout\"": 2047, "\"display active task list\"": 2048, "\"display breakpoints\"": 2049, "\"display exception frame\"": 2050, "\"display help message\"": 2051, "\"display help on | grep\"": 2052, "\"display memory contents, also mdwcn, e.g. md8c1\"": 2053, "\"display memory symbolically\"": 2054, "\"display per_cpu variables\"": 2055, "\"display physical memory\"": 2056, "\"display raw memory\"": 2057, "\"display registers\"": 2058, "\"display stack for process <pid>\"": 2059, "\"display syslog buffer\"": 2060, "\"div by zero\\n\"": 2061, "\"dl_nr_running\"": 2062, "\"dmesg\"": 2063, "\"dmesg_restrict\"": 2064, "\"dn_count\"": 2065, "\"do not call blocking ops when !task_running; \"": 2066, "\"does not load-balance\\n\"": 2067, "\"doing %s, parsing args: '%s'\\n\"": 2068, "\"doing %s: %s='%s'\\n\"": 2069, "\"domain%d %*pb\"": 2070, "\"domain%d\"": 2071, "\"domainname %s\\n\"": 2072, "\"domainname\"": 2073, "\"done.\"": 2074, "\"done.\\n\"": 2075, "\"dr_count\"": 2076, "\"driverloader\"": 2077, "\"drop_caches\"": 2078, "\"dropped\"": 2079, "\"drops\"": 2080, "\"drv_data\"": 2081, "\"dst_gc_interval\"": 2082, "\"dti\"": 2083, "\"due to %s @ \"": 2084, "\"due to cpu switch\\n\"": 2085, "\"due to debug @ \"": 2086, "\"due to kdb_enter()\\n\"": 2087, "\"due to keyboard entry\\n\"": 2088, "\"due to nonmaskable interrupt @ \"": 2089, "\"due to oops @ \"": 2090, "\"due to recursion @ \"": 2091, "\"due to system nonmaskable interrupt\\n\"": 2092, "\"dummy\"": 2093, "\"dump\"": 2094, "\"dumping ftrace buffer:\\n\"": 2095, "\"dumping kprobe:\\n\"": 2096, "\"dup ret instances\"": 2097, "\"dup xol area\"": 2098, "\"duplicate kdb command registered: \"": 2099, "\"duration of each boost test, seconds.\"": 2100, "\"duration of fqs bursts (us), 0 to disable\"": 2101, "\"dynamic debug error adding module: %s\\n\"": 2102, "\"e == 1 && f == 1 && g == 1 && h == 1\"": 2103, "\"e == 1 || f == 1 || g == 1 || h == 1\"": 2104, "\"e\"": 2105, "\"e.\"": 2106, "\"e01\"": 2107, "\"earlyexit\"": 2108, "\"echo the kernel .config file used to build the kernel\"": 2109, "\"echo usecs [iters] > \"": 2110, "\"edge\"": 2111, "\"ef\"": 2112, "\"effective_cpus\"": 2113, "\"effective_mems\"": 2114, "\"efgh\"": 2115, "\"elfcorehdr\"": 2116, "\"empty!\\n\"": 2117, "\"emulated 'pipe'.\\n\"": 2118, "\"enable breakpoint\"": 2119, "\"enable debug-object double call_rcu() testing\"": 2120, "\"enable verbose debugging printk()s\"": 2121, "\"enable\"": 2122, "\"enable_event\"": 2123, "\"enable_irq before setup/request_irq: irq %u\\n\"": 2124, "\"enabled event during self test!\\n\"": 2125, "\"enabled on all cpus, permanently consumes one hw-pmu counter.\\n\"": 2126, "\"enabled\"": 2127, "\"enabled\\n\"": 2128, "\"enabling non-boot cpus ...\\n\"": 2129, "\"enabling patch '%s'\\n\"": 2130, "\"end boost kthread@notreached\"": 2131, "\"end boost kthread@rcu_wait\"": 2132, "\"end boost kthread@rcu_yield\"": 2133, "\"end context switch\"": 2134, "\"end of test: failure\"": 2135, "\"end of test: rcu_hotplug\"": 2136, "\"end of test: success\"": 2137, "\"end rcu core\"": 2138, "\"end scheduler-tick\"": 2139, "\"end\"": 2140, "\"endefcmd\"": 2141, "\"endefcmd\\n\"": 2142, "\"endian\"": 2143, "\"endwait\"": 2144, "\"enter <q> to end, <cr> to continue:\"": 2145, "\"enter kgdb mode\"": 2146, "\"entering kgdb\\n\"": 2147, "\"entropy_avail\"": 2148, "\"env\"": 2149, "\"epoll\"": 2150, "\"error converting sid to string\"": 2151, "\"error disabling all events\\n\"": 2152, "\"error disabling system %s\\n\"": 2153, "\"error enabling all events\\n\"": 2154, "\"error enabling system %s\\n\"": 2155, "\"error in audit_log_task_context\"": 2156, "\"error on deleting a probe.\\n\"": 2157, "\"error on entry: not idle task\"": 2158, "\"error on exit: not idle task\"": 2159, "\"error on getting 2nd new probe.\\n\"": 2160, "\"error on getting 2nd test probe.\\n\"": 2161, "\"error on getting new probe.\\n\"": 2162, "\"error on getting probe file.\\n\"": 2163, "\"error on getting test probe.\\n\"": 2164, "\"error on probing function entry.\\n\"": 2165, "\"error on probing function return.\\n\"": 2166, "\"error taking cpu%d down: %d\\n\"": 2167, "\"error taking cpu%d up: %d\\n\"": 2168, "\"error updating lsm filters\"": 2169, "\"error updating watch, removing\"": 2170, "\"error updating watch, skipping\"": 2171, "\"error: !sd_load_balance domain\"": 2172, "\"error: %s\\n\\n\"": 2173, "\"error: domain->groups does not contain\"": 2174, "\"error: domain->span does not contain \"": 2175, "\"error: empty group\\n\"": 2176, "\"error: group is null\\n\"": 2177, "\"error: groups don't span domain->span\\n\"": 2178, "\"error: hwirq 0x%x is too large for %s\\n\"": 2179, "\"error: no free irqs available below %i maximum\\n\"": 2180, "\"error: no kgdb i/o module available\\n\"": 2181, "\"error: parent span is not a superset \"": 2182, "\"error: repeated cpus\\n\"": 2183, "\"error: there should be no unused kprobe here.\\n\"": 2184, "\"error: virq%i is already associated\"": 2185, "\"error: virq%i is not allocated\"": 2186, "\"error_burst\"": 2187, "\"error_cost\"": 2188, "\"error_level\"": 2189, "\"es\"": 2190, "\"ethernet\"": 2191, "\"event %s/%s doesn't exist.\\n\"": 2192, "\"event name is not specified\\n\"": 2193, "\"event trace: could not activate\"": 2194, "\"event trace: could not enable event \"": 2195, "\"events\"": 2196, "\"events_freezable\"": 2197, "\"events_freezable_power_efficient\"": 2198, "\"events_highpri\"": 2199, "\"events_long\"": 2200, "\"events_power_efficient\"": 2201, "\"events_unbound\"": 2202, "\"exception-trace\"": 2203, "\"exec_clock\"": 2204, "\"execdomains\"": 2205, "\"execute the probed insn, sending sigill.\"": 2206, "\"executing a continue without signal passing\\n\"": 2207, "\"exit\"": 2208, "\"exit_creds(%u,%p,%p,{%d,%d})\"": 2209, "\"exiting task \\\"%s\\\" (%d) is an active irq thread (irq %d)\\n\"": 2210, "\"expanded resource %s due to conflict with %s\\n\"": 2211, "\"expected:   %.*s\\n\"": 2212, "\"extended_window_size\"": 2213, "\"extfrag_threshold\"": 2214, "\"f\"": 2215, "\"fail to deliver signal %d to process %d.\\n\"": 2216, "\"failed to alloc mask\"": 2217, "\"failed to allocate argument[%d] name.\\n\"": 2218, "\"failed to allocate filename.\\n\"": 2219, "\"failed to allocate memory for command '%s'.\\n\"": 2220, "\"failed to allocate ring buffer on cpu %ld\\n\"": 2221, "\"failed to allocate trace_uprobe.(%d)\\n\"": 2222, "\"failed to apply patch '%s' to module '%s' (%d)\\n\"": 2223, "\"failed to broadcast timer tick. some cpus may be unresponsive.\\n\"": 2224, "\"failed to create files (%d) while rebinding 0x%x to default root\\n\"": 2225, "\"failed to create ftrace wakeup test thread \"": 2226, "\"failed to create system directory %s\\n\"": 2227, "\"failed to create watchdog threads, disabled\\n\"": 2228, "\"failed to enable trace event: %s\\n\"": 2229, "\"failed to find symbol %s\\n\"": 2230, "\"failed to get filter for '%s', err %d\\n\"": 2231, "\"failed to init %s tracer, init returned %d\\n\"": 2232, "\"failed to kmalloc\\n\"": 2233, "\"failed to match filter '%s', expected %d\\n\"": 2234, "\"failed to parse address or file.\\n\"": 2235, "\"failed to re-register probe %s on\"": 2236, "\"failed to register ftrace handler for function '%s' (%d)\\n\"": 2237, "\"failed to register kprobe event: %s\\n\"": 2238, "\"failed to register probe event(%d)\\n\"": 2239, "\"failed to register trace events module notifier\\n\"": 2240, "\"failed to register uprobe event: %s\\n\"": 2241, "\"failed to request resources for %s (irq %d) on irqchip %s\\n\"": 2242, "\"failed to set ftrace filter for function '%s' (%d)\\n\"": 2243, "\"failed to set type for irq%d\\n\"": 2244, "\"failed to start irqsoff tracer\\n\"": 2245, "\"failed to start wakeup tracer\\n\"": 2246, "\"failed to swap buffers due to commit in progress\\n\"": 2247, "\"failed!\\n\"": 2248, "\"failed, unwanted pred visited for filter %s\\n\"": 2249, "\"failed\\n\"": 2250, "\"fast_poll_increase\"": 2251, "\"fd %d is not pointing to valid bpf_map\\n\"": 2252, "\"fd0=%d fd1=%d\"": 2253, "\"fd=%d flags=0x%x\"": 2254, "\"features.h\"": 2255, "\"fi\"": 2256, "\"field not found\"": 2257, "\"fifo prio for consumer\"": 2258, "\"fifo prio for producer\"": 2259, "\"file-max\"": 2260, "\"file-nr\"": 2261, "\"files_cache\"": 2262, "\"filestream_centisecs\"": 2263, "\"filter\"": 2264, "\"final section addresses:\\n\"": 2265, "\"find_task_by_pid_ns() needs rcu_read_lock()\"": 2266, "\"finished\\n\"": 2267, "\"finit_module: fd=%d, uargs=%p, flags=%i\\n\"": 2268, "\"first=%llu [cold cached]\"": 2269, "\"fixing request to [0x%llx-0x%llx]\\n\"": 2270, "\"flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\"": 2271, "\"flags\"": 2272, "\"flush\"": 2273, "\"follow 0/-e convention\\n\"": 2274, "\"followersleep\"": 2275, "\"force_igmp_version\"": 2276, "\"force_mld_version\"": 2277, "\"forcing reboot\\n\"": 2278, "\"forkexec_idx\"": 2279, "\"format\"": 2280, "\"format:\\n\"": 2281, "\"forwarding\"": 2282, "\"fp\"": 2283, "\"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"": 2284, "\"fqsend\"": 2285, "\"fqsstart\"": 2286, "\"fqswait\"": 2287, "\"fqswaitsig\"": 2288, "\"frame pointer is read only\\n\"": 2289, "\"free_dquots\"": 2290, "\"freezer\"": 2291, "\"freezing remaining freezable tasks ... \"": 2292, "\"freezing user space processes ... \"": 2293, "\"freezing\"": 2294, "\"frontmerge\"": 2295, "\"frozen\"": 2296, "\"fs\"": 2297, "\"fs_cache\"": 2298, "\"ftrace failed to modify \"": 2299, "\"ftrace faulted on modifying \"": 2300, "\"ftrace faulted on unknown error \"": 2301, "\"ftrace faulted on writing \"": 2302, "\"ftrace ops had %ps for function\\n\"": 2303, "\"ftrace record flags: %lx\\n\"": 2304, "\"ftrace\"": 2305, "\"ftrace-test\"": 2306, "\"ftrace: failed to allocate memory for functions\\n\"": 2307, "\"ftrace=\"": 2308, "\"ftrace_dump_on_oops\"": 2309, "\"ftrace_enabled\"": 2310, "\"ftrace_graph: couldn't activate tracepoint\"": 2311, "\"fua\"": 2312, "\"function graph tracer: not enough memory\\n\"": 2313, "\"function\"": 2314, "\"function%d\"": 2315, "\"function_graph\"": 2316, "\"function_profile_enabled\"": 2317, "\"fver=%x\"": 2318, "\"g\"": 2319, "\"gc_elasticity\"": 2320, "\"gc_interval\"": 2321, "\"gc_min_interval\"": 2322, "\"gc_min_interval_ms\"": 2323, "\"gc_stale_time\"": 2324, "\"gc_thresh\"": 2325, "\"gc_thresh1\"": 2326, "\"gc_thresh2\"": 2327, "\"gc_thresh3\"": 2328, "\"gc_timeout\"": 2329, "\"gcno\"": 2330, "\"gcov\"": 2331, "\"gcov.h\"": 2332, "\"gcov: \"": 2333, "\"gcov_persist=\"": 2334, "\"get\"": 2335, "\"getrq\"": 2336, "\"gh\"": 2337, "\"go must execute on the entry cpu, \"": 2338, "\"go\"": 2339, "\"going\"": 2340, "\"gpc=%ld gps=%ld nn=%ld ndw%ld\\n\"": 2341, "\"gpl\"": 2342, "\"gps behind\"": 2343, "\"grep \"": 2344, "\"grephelp\"": 2345, "\"group name is not specified\\n\"": 2346, "\"h\"": 2347, "\"handling %s with %p\\n\"": 2348, "\"hardirqs last  enabled at (%u): \"": 2349, "\"hardirqs last disabled at (%u): \"": 2350, "\"hb_ctl_path\"": 2351, "\"hb_interval\"": 2352, "\"header_event\"": 2353, "\"header_page\"": 2354, "\"help\"": 2355, "\"hi\"": 2356, "\"hibernation debug: waiting for 5 seconds.\\n\"": 2357, "\"hierarchical rcu implementation.\\n\"": 2358, "\"highmem_is_dirtyable\"": 2359, "\"hit    time            avg             s^2\\n\"": 2360, "\"hm#1, depth: %u [%u], %016lx != %016lx\\n\"": 2361, "\"hm#2, depth: %u [%u], %016lx != %016lx\\n\"": 2362, "\"hm, tasklist_lock locked, retrying... \"": 2363, "\"hmm, kdb_reboot did not reboot, spinning here\\n\"": 2364, "\"holders\"": 2365, "\"holdoff between bursts (jiffies)\"": 2366, "\"holdoff between floods (jiffies)\"": 2367, "\"holdoff time within fqs bursts (us)\"": 2368, "\"holdtime-avg\"": 2369, "\"holdtime-max\"": 2370, "\"holdtime-min\"": 2371, "\"holdtime-total\"": 2372, "\"home=/\"": 2373, "\"hop_limit\"": 2374, "\"hostname\"": 2375, "\"hotplug\"": 2376, "\"hrtimer\"": 2377, "\"hugepages_treat_as_movable\"": 2378, "\"hugetlb_shm_group\"": 2379, "\"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n\"": 2380, "\"hung_task: blocked tasks\"": 2381, "\"hung_task_check_count\"": 2382, "\"hung_task_panic\"": 2383, "\"hung_task_panic=\"": 2384, "\"hung_task_timeout_secs\"": 2385, "\"hung_task_warnings\"": 2386, "\"i\"": 2387, "\"i/o\"": 2388, "\"icmp\"": 2389, "\"icmp_echo_ignore_all\"": 2390, "\"icmp_echo_ignore_broadcasts\"": 2391, "\"icmp_errors_use_inbound_ifaddr\"": 2392, "\"icmp_ignore_bogus_error_responses\"": 2393, "\"icmp_ratelimit\"": 2394, "\"icmp_ratemask\"": 2395, "\"id\"": 2396, "\"id: %d\\n\"": 2397, "\"idle: \"": 2398, "\"idle_idx\"": 2399, "\"idle_timeout\"": 2400, "\"ieee_emulation_warnings\"": 2401, "\"if it really is, submit a report to the linux kernel \"": 2402, "\"if you just came from a suspend/resume,\\n\"": 2403, "\"if\"": 2404, "\"igmp_max_memberships\"": 2405, "\"igmp_max_msf\"": 2406, "\"ignore-unaligned-usertrap\"": 2407, "\"ikcfg_ed\"": 2408, "\"ikcfg_st\"": 2409, "\"illegal idle entry in rcu read-side critical section.\"": 2410, "\"illegal idle entry in rcu-bh read-side critical section.\"": 2411, "\"illegal idle entry in rcu-sched read-side critical section.\"": 2412, "\"illegal integer value\"": 2413, "\"illegal operation for field type\"": 2414, "\"illegal synchronize_rcu() in rcu read-side critical section\"": 2415, "\"illegal synchronize_sched() in rcu read-side critical section\"": 2416, "\"illegal synchronize_srcu() in same-type srcu (or rcu) read-side critical section\"": 2417, "\"illegal use of '!'\"": 2418, "\"image_crc32\"": 2419, "\"imbalance_pct\"": 2420, "\"imm\"": 2421, "\"in %s\\n\"": 2422, "\"in-\"": 2423, "\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\"": 2424, "\"inc1\"": 2425, "\"inc2\"": 2426, "\"inclusion.\\n\"": 2427, "\"incomplete 'defcmd' set, forcing endefcmd\\n\"": 2428, "\"inconsistent {%s} -> {%s} usage.\\n\"": 2429, "\"incorrect value in post_handler\\n\"": 2430, "\"inet_peer_gc_maxtime\"": 2431, "\"inet_peer_gc_mintime\"": 2432, "\"inet_peer_maxttl\"": 2433, "\"inet_peer_minttl\"": 2434, "\"inet_peer_threshold\"": 2435, "\"info: %s detected stalls on cpus/tasks:\"": 2436, "\"info: %s self-detected stall on cpu\"": 2437, "\"info: lockdep is turned off.\\n\"": 2438, "\"info: rcu_tasks detected stalls on tasks:\\n\"": 2439, "\"info: stall ended before state dump start\\n\"": 2440, "\"info: task %s:%d blocked for more than %ld seconds.\\n\"": 2441, "\"info: timekeeping: cycle offset (%lld) is larger than the the '%s' clock's 50%% safety margin (%lld)\\n\"": 2442, "\"info: trying to register non-static key.\\n\"": 2443, "\"inherit_noatime\"": 2444, "\"inherit_nodefrag\"": 2445, "\"inherit_nodump\"": 2446, "\"inherit_nosymlinks\"": 2447, "\"inherit_sync\"": 2448, "\"inheritable\"": 2449, "\"init failed\\n\"": 2450, "\"init section allocation order:\\n\"": 2451, "\"init_module: umod=%p, len=%lu, uargs=%p\\n\"": 2452, "\"initcall %lli_%pf returned 0 after %lld usecs\\n\"": 2453, "\"initial use\"": 2454, "\"initialise system trusted keyring\\n\"": 2455, "\"initialized\"": 2456, "\"initializing cgroup subsys %s\\n\"": 2457, "\"initializing netlink subsys (%s)\\n\"": 2458, "\"inode-nr\"": 2459, "\"inode-state\"": 2460, "\"inotify\"": 2461, "\"insert\"": 2462, "\"insn state internal bug\\n\"": 2463, "\"inst\"": 2464, "\"instruction boundary.\\n\"": 2465, "\"instruction(i)\"": 2466, "\"instruction(register)\"": 2467, "\"internal.h\"": 2468, "\"internals.h\"": 2469, "\"interval between boost tests, seconds.\"": 2470, "\"intree\"": 2471, "\"inv\"": 2472, "\"invalid 'pipe', see grephelp\\n\"": 2473, "\"invalid access to map value, value_size=%d off=%d size=%d\\n\"": 2474, "\"invalid argument[%d] name: %s\\n\"": 2475, "\"invalid bpf_alu opcode %x\\n\"": 2476, "\"invalid bpf_context access off=%d size=%d\\n\"": 2477, "\"invalid bpf_jmp opcode %x\\n\"": 2478, "\"invalid bpf_ld mode\\n\"": 2479, "\"invalid bpf_ld_imm insn\\n\"": 2480, "\"invalid bpf_ld_imm64 insn\\n\"": 2481, "\"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p name:id=%d:%s\\n\"": 2482, "\"invalid func %d\\n\"": 2483, "\"invalid gcov_persist parameter '%s'\\n\"": 2484, "\"invalid indirect read from stack off %d+%d size %d\\n\"": 2485, "\"invalid insn idx %d insn_cnt %d\\n\"": 2486, "\"invalid map_ptr to access map->key\\n\"": 2487, "\"invalid map_ptr to access map->value\\n\"": 2488, "\"invalid notifier called!\"": 2489, "\"invalid operator\"": 2490, "\"invalid quoted string, see grephelp\\n\"": 2491, "\"invalid signal parameter.<-signal>\\n\"": 2492, "\"invalid size of register spill\\n\"": 2493, "\"io_delay_type\"": 2494, "\"iomem\"": 2495, "\"iomem=\"": 2496, "\"ioports\"": 2497, "\"ip\"": 2498, "\"ip6_queue_maxlen\"": 2499, "\"ip6frag_high_thresh\"": 2500, "\"ip6frag_low_thresh\"": 2501, "\"ip6frag_secret_interval\"": 2502, "\"ip6frag_time\"": 2503, "\"ip_conntrack_buckets\"": 2504, "\"ip_conntrack_checksum\"": 2505, "\"ip_conntrack_count\"": 2506, "\"ip_conntrack_log_invalid\"": 2507, "\"ip_conntrack_max\"": 2508, "\"ip_conntrack_tcp_be_liberal\"": 2509, "\"ip_conntrack_tcp_loose\"": 2510, "\"ip_conntrack_tcp_max_retrans\"": 2511, "\"ip_default_mode\"": 2512, "\"ip_default_ttl\"": 2513, "\"ip_dynaddr\"": 2514, "\"ip_forward\"": 2515, "\"ip_local_port_range\"": 2516, "\"ip_no_pmtu_disc\"": 2517, "\"ip_nonlocal_bind\"": 2518, "\"ip_queue_maxlen\"": 2519, "\"ipfrag_high_thresh\"": 2520, "\"ipfrag_low_thresh\"": 2521, "\"ipfrag_secret_interval\"": 2522, "\"ipfrag_time\"": 2523, "\"ipgre\"": 2524, "\"ipi callback %ps sent to offline cpu\\n\"": 2525, "\"ipi on offline cpu %d\\n\"": 2526, "\"ipmi\"": 2527, "\"ipv4\"": 2528, "\"ipv6\"": 2529, "\"ipx\"": 2530, "\"ipx_pprop_broadcasting\"": 2531, "\"irda\"": 2532, "\"irix_sgid_inherit\"": 2533, "\"irix_symlink_mode\"": 2534, "\"irq %d device %s returned irq_wake_thread \"": 2535, "\"irq %d for msi\\n\"": 2536, "\"irq %d uses trigger mode %u; requested %u\\n\"": 2537, "\"irq %d, desc: %p, depth: %d, count: %d, unhandled: %d\\n\"": 2538, "\"irq %u handler %pf enabled interrupts\\n\"": 2539, "\"irq [%d-%d] for msi\\n\"": 2540, "\"irq lockup detection disabled\\n\"": 2541, "\"irq poll in progress on cpu %d for irq %d\\n\"": 2542, "\"irq\"": 2543, "\"irq/%d-%s\"": 2544, "\"irq/default_smp_affinity\"": 2545, "\"irq/prof_cpu_mask\"": 2546, "\"irq: \"": 2547, "\"irq_create_mapping(0x%p, 0x%lx)\\n\"": 2548, "\"irqfixup\"": 2549, "\"irqpoll\"": 2550, "\"irqsoff\"": 2551, "\"is unknown, you have been warned.\\n\"": 2552, "\"isa\"": 2553, "\"isolcpus=\"": 2554, "\"issue\"": 2555, "\"item=%d\"": 2556, "\"j\"": 2557, "\"j=%04x bt=%04x\\n\"": 2558, "\"jiffies: %lu\\n\"": 2559, "\"jmp\"": 2560, "\"jump out of range from insn %d to %d\\n\"": 2561, "\"k\"": 2562, "\"kallsyms\"": 2563, "\"kauditd\"": 2564, "\"kdb command %s failed, kdb diag %d\\n\"": 2565, "\"kdb current process is %s(pid=%d)\\n\"": 2566, "\"kdb risks deadlock\\n\"": 2567, "\"kdb.\"": 2568, "\"kdb: bad result from kdba_db_trap: %d\\n\"": 2569, "\"kdb: error return from kdba_bp_trap: %d\\n\"": 2570, "\"kdb: unexpected reason code: %d\\n\"": 2571, "\"kdb_continue_catastrophic=%d, \"": 2572, "\"kdb_exec_defcmd: could not find commands for %s\\n\"": 2573, "\"kdb_getarea: bad address 0x%lx\\n\"": 2574, "\"kdb_local 1\"": 2575, "\"kdb_local 4\"": 2576, "\"kdb_local 6\"": 2577, "\"kdb_local 8\"": 2578, "\"kdb_parse: command buffer \"": 2579, "\"kdb_parse: too many arguments, \"": 2580, "\"kdb_private.h\"": 2581, "\"kdb_putarea: bad address 0x%lx\\n\"": 2582, "\"kdbgetsymval: returns 0\\n\"": 2583, "\"kdbgetsymval: returns 1, \"": 2584, "\"kdbgetsymval: symname=%s, symtab=%p\\n\"": 2585, "\"kdbnearsym: addr=0x%lx, symtab=%p\\n\"": 2586, "\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"": 2587, "\"kernel panic - not syncing: %s\\n\"": 2588, "\"kernel release\"": 2589, "\"kernel signature verification failed.\\n\"": 2590, "\"kernel signature verification successful.\\n\"": 2591, "\"kernel subsystem misconfigured verifier\\n\"": 2592, "\"kernel version\"": 2593, "\"kernel\"": 2594, "\"kernel, try again later\\n\"": 2595, "\"kernel.perf_event_max_sample_rate to %d\\n\"": 2596, "\"kernel\\n\"": 2597, "\"kexec: \"": 2598, "\"kexec: memory allocation for saving cpu register states failed\\n\"": 2599, "\"kexec_load_disabled\"": 2600, "\"keys\"": 2601, "\"kgdb only knows signal 9 (pass)\"": 2602, "\"kgdb or $3#33 for kdb\\n\"": 2603, "\"kgdb\"": 2604, "\"kgdbcon\"": 2605, "\"kgdbwait\"": 2606, "\"khelper\"": 2607, "\"khungtaskd\"": 2608, "\"kill\"": 2609, "\"kmalloc()\"": 2610, "\"kmemcheck\"": 2611, "\"kprobe smoke test: \"": 2612, "\"kprobe_events\"": 2613, "\"kprobe_profile\"": 2614, "\"kprobe_target\"": 2615, "\"kprobes-optimization\"": 2616, "\"kptr_restrict\"": 2617, "\"kretprobe_trampoline\"": 2618, "\"ksoftirqd/%u\"": 2619, "\"kstack_depth_to_print\"": 2620, "\"kthreadd\"": 2621, "\"kworker/%s\"": 2622, "\"kworker/dying\"": 2623, "\"lap_keepalive_time\"": 2624, "\"laptop_mode\"": 2625, "\"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\"": 2626, "\"last_accelerate: %04lx/%04lx, nonlazy_posted: %ld, %c%c\"": 2627, "\"last_unhandled %u ms\\n\"": 2628, "\"lastcb\"": 2629, "\"latency top version : v0.1\\n\"": 2630, "\"latency_stats\"": 2631, "\"latencytop\"": 2632, "\"ld\"": 2633, "\"ldx\"": 2634, "\"lease-break-time\"": 2635, "\"leases-enable\"": 2636, "\"legacy_va_layout\"": 2637, "\"level\"": 2638, "\"license\"": 2639, "\"linear\"": 2640, "\"lines printed\\n\"": 2641, "\"link_fail_timeout\"": 2642, "\"link_fails_count\"": 2643, "\"list loaded kernel modules\"": 2644, "\"live\"": 2645, "\"livepatch\"": 2646, "\"llc\"": 2647, "\"llc2\"": 2648, "\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\"": 2649, "\"load\"": 2650, "\"loaded x.509 cert '%s'\\n\"": 2651, "\"loading compiled-in x.509 certificates\\n\"": 2652, "\"loading segment %d: buf=0x%p bufsz=0x%zx mem=0x%lx memsz=0x%zx\\n\"": 2653, "\"loading\"": 2654, "\"lock-torture types:\"": 2655, "\"lock-torture: invalid torture type: \\\"%s\\\"\\n\"": 2656, "\"lock_busted\"": 2657, "\"lock_stat version 0.4\\n\"": 2658, "\"lock_stat\"": 2659, "\"lock_torture_reader task started\"": 2660, "\"lock_torture_reader\"": 2661, "\"lock_torture_stats task started\"": 2662, "\"lock_torture_stats\"": 2663, "\"lock_torture_stats_print: out of memory, need: %d\"": 2664, "\"lock_torture_writer task started\"": 2665, "\"lock_torture_writer\"": 2666, "\"lockdep\"": 2667, "\"lockdep:%s bad path found in chain graph\\n\"": 2668, "\"lockdep_chains\"": 2669, "\"lockdep_internals.h\"": 2670, "\"lockdep_states.h\"": 2671, "\"lockdep_stats\"": 2672, "\"lockname\"": 2673, "\"lockup suspected\"": 2674, "\"log_martians\"": 2675, "\"logaritmic\"": 2676, "\"logging_level\"": 2677, "\"loginuid_immutable\"": 2678, "\"look up: \\\"%s\\\"\\n\"": 2679, "\"lookups\"": 2680, "\"loopback\"": 2681, "\"lowmem_reserve_ratio\"": 2682, "\"lsmod\"": 2683, "\"lve\"": 2684, "\"m\"": 2685, "\"mac_hid\"": 2686, "\"machine    %s\\n\"": 2687, "\"machine\"": 2688, "\"machine_suspend\"": 2689, "\"magic sysrq key\"": 2690, "\"mailing list together with submitting your code for \"": 2691, "\"map %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\"": 2692, "\"map what?\\n\"": 2693, "\"map_ptr\"": 2694, "\"map_value\"": 2695, "\"map_value_or_null\"": 2696, "\"mark %u.%06lu %s\"": 2697, "\"mark 0.000000 lost %lu events.\\n\"": 2698, "\"max\"": 2699, "\"max_addresses\"": 2700, "\"max_baud_rate\"": 2701, "\"max_burst\"": 2702, "\"max_desync_factor\"": 2703, "\"max_dgram_qlen\"": 2704, "\"max_graph_depth\"": 2705, "\"max_init_retransmits\"": 2706, "\"max_interval\"": 2707, "\"max_lock_depth\"": 2708, "\"max_map_count\"": 2709, "\"max_newidle_lb_cost\"": 2710, "\"max_noreply_time\"": 2711, "\"max_queued_events\"": 2712, "\"max_resvport\"": 2713, "\"max_size\"": 2714, "\"max_tx_data_size\"": 2715, "\"max_tx_window\"": 2716, "\"max_user_instances\"": 2717, "\"max_user_watches\"": 2718, "\"max_vruntime\"": 2719, "\"maximum\"": 2720, "\"maximum_packet_length\"": 2721, "\"maximum_retry_count\"": 2722, "\"maximum_virtual_circuits\"": 2723, "\"mc_forwarding\"": 2724, "\"mcast_solicit\"": 2725, "\"md\"": 2726, "\"mdp\"": 2727, "\"mdr\"": 2728, "\"mds\"": 2729, "\"meaningless filter expression\"": 2730, "\"medium_id\"": 2731, "\"mem_exclusive\"": 2732, "\"mem_hardwall\"": 2733, "\"membase\"": 2734, "\"memory error \"": 2735, "\"memory size\"": 2736, "\"memory value expected after '@'\\n\"": 2737, "\"memory\"": 2738, "\"memory_bandwidth\"": 2739, "\"memory_failure_early_kill\"": 2740, "\"memory_failure_recovery\"": 2741, "\"memory_migrate\"": 2742, "\"memory_pressure\"": 2743, "\"memory_pressure_enabled\"": 2744, "\"memory_spread_page\"": 2745, "\"memory_spread_slab\"": 2746, "\"mems\"": 2747, "\"mems_allowed:\\t%*pb\\n\"": 2748, "\"mems_allowed_list:\\t%*pbl\\n\"": 2749, "\"message\"": 2750, "\"message_burst\"": 2751, "\"message_cost\"": 2752, "\"meta\"": 2753, "\"metacharacters:\\n\"": 2754, "\"migration/%u\"": 2755, "\"min_adv_mss\"": 2756, "\"min_free_kbytes\"": 2757, "\"min_interval\"": 2758, "\"min_pmtu\"": 2759, "\"min_resvport\"": 2760, "\"min_slab_ratio\"": 2761, "\"min_tx_turn_time\"": 2762, "\"min_unmapped_ratio\"": 2763, "\"min_vruntime\"": 2764, "\"minimum\"": 2765, "\"misrouted irq fixup and polling support \"": 2766, "\"misrouted irq fixup support enabled.\\n\"": 2767, "\"missing audit_compare define.  report as a bug\\n\"": 2768, "\"missing field name and/or value\"": 2769, "\"mld_max_msf\"": 2770, "\"mm\"": 2771, "\"mm:%p idx:%d val:%ld\\n\"": 2772, "\"mm_struct\"": 2773, "\"mmap_min_addr\"": 2774, "\"mmiotrace has lost events.\\n\"": 2775, "\"mmiotrace\"": 2776, "\"modify memory contents\"": 2777, "\"modify registers\"": 2778, "\"modprobe\"": 2779, "\"module len %lu truncated\\n\"": 2780, "\"module\"": 2781, "\"module-internal.h\"": 2782, "\"modules linked in:\"": 2783, "\"modules\"": 2784, "\"modules_disabled\"": 2785, "\"more than 1 task in runqueue\\n\"": 2786, "\"mouse_button2_keycode\"": 2787, "\"mouse_button3_keycode\"": 2788, "\"mouse_button_emulation\"": 2789, "\"mq_curmsgs=%ld \"": 2790, "\"mq_msgsize=%ld mq_curmsgs=%ld\"": 2791, "\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"": 2792, "\"mqdes=%d msg_len=%zd msg_prio=%u \"": 2793, "\"mqdes=%d sigev_signo=%d\"": 2794, "\"msg\"": 2795, "\"msgmax\"": 2796, "\"msgmnb\"": 2797, "\"msgmni\"": 2798, "\"mtu\"": 2799, "\"mtu_expires\"": 2800, "\"mutex\"": 2801, "\"mutex-debug.h\"": 2802, "\"mutex.h\"": 2803, "\"mutex_lock\"": 2804, "\"n.\"": 2805, "\"n_barrier_cbs=%d \"": 2806, "\"name \\\"usage\\\" \\\"help\\\"\"": 2807, "\"name\"": 2808, "\"name: %s\\n\"": 2809, "\"name: %s\\naddress: %p\\noffset: %x\\n\"": 2810, "\"name=\"": 2811, "\"nargs=%d\"": 2812, "\"ndiswrapper\"": 2813, "\"need to add type to trace.h\\n\"": 2814, "\"neg\"": 2815, "\"neigh\"": 2816, "\"net\"": 2817, "\"net_rx\"": 2818, "\"net_tx\"": 2819, "\"netdev_budget\"": 2820, "\"netdev_max_backlog\"": 2821, "\"netfilter\"": 2822, "\"netrom\"": 2823, "\"network_latency\"": 2824, "\"network_throughput\"": 2825, "\"network_ttl_initialiser\"": 2826, "\"new mount options do not match the existing superblock, will be ignored\\n\"": 2827, "\"new_pe\"": 2828, "\"new_pi\"": 2829, "\"new_pp\"": 2830, "\"newidle_idx\"": 2831, "\"newreq\"": 2832, "\"nf_conntrack_buckets\"": 2833, "\"nf_conntrack_checksum\"": 2834, "\"nf_conntrack_count\"": 2835, "\"nf_conntrack_frag6_high_thresh\"": 2836, "\"nf_conntrack_frag6_low_thresh\"": 2837, "\"nf_conntrack_log_invalid\"": 2838, "\"nf_conntrack_max\"": 2839, "\"nf_conntrack_tcp_be_liberal\"": 2840, "\"nf_conntrack_tcp_loose\"": 2841, "\"nf_conntrack_tcp_max_retrans\"": 2842, "\"nfqs=%lu/nfqsng=%lu(%lu) fqlh=%lu oqlen=%ld/%ld\\n\"": 2843, "\"ng: some tests are failed. please check them.\\n\"": 2844, "\"ngroups_max\"": 2845, "\"nice prio for consumer\"": 2846, "\"nice prio for producer\"": 2847, "\"nm\"": 2848, "\"nmi watchdog: \"": 2849, "\"nmi_watchdog\"": 2850, "\"no error\"": 2851, "\"no locks held by %s/%d.\\n\"": 2852, "\"no memory to create event subsystem %s\\n\"": 2853, "\"no module found in object\\n\"": 2854, "\"no pid\\n\"": 2855, "\"no process for cpu %ld\\n\"": 2856, "\"no process with pid == %ld found\\n\"": 2857, "\"no set_type function for irq %d (%s)\\n\"": 2858, "\"no task with pid=%d\\n\"": 2859, "\"no torture_shutdown_hook(), skipping.\"": 2860, "\"no versions for exported symbols\"": 2861, "\"no\"": 2862, "\"no_activity_timeout\"": 2863, "\"no_fc_max_cwnd\"": 2864, "\"no_file_caps\"": 2865, "\"no_hz full will not work with unstable sched clock\"": 2866, "\"no_numa\"": 2867, "\"noautogroup\"": 2868, "\"node\"": 2869, "\"node_address\"": 2870, "\"node_name\"": 2871, "\"nodelayacct\"": 2872, "\"nodename   %s\\n\"": 2873, "\"noirqdebug\"": 2874, "\"nokgdbroundup\"": 2875, "\"non-boot cpus are not disabled\\n\"": 2876, "\"none\"": 2877, "\"none\\n\"": 2878, "\"noprefix\"": 2879, "\"normal\"": 2880, "\"nosect\"": 2881, "\"nosmp\"": 2882, "\"not tainted\"": 2883, "\"notes\"": 2884, "\"nothing printed\\n\"": 2885, "\"notify_on_release\"": 2886, "\"nr\"": 2887, "\"nr_hugepages\"": 2888, "\"nr_hugepages_mempolicy\"": 2889, "\"nr_involuntary_switches\"": 2890, "\"nr_irqs:%d nr_irqs:%d %d\\n\"": 2891, "\"nr_irqs:%d\\n\"": 2892, "\"nr_open\"": 2893, "\"nr_overcommit_hugepages\"": 2894, "\"nr_pdflush_threads\"": 2895, "\"nr_periods %d\\n\"": 2896, "\"nr_running\"": 2897, "\"nr_spread_over\"": 2898, "\"nr_throttled %d\\n\"": 2899, "\"nr_trim_pages\"": 2900, "\"nr_voluntary_switches\"": 2901, "\"ns_last_pid\"": 2902, "\"ntp_internal.h\"": 2903, "\"null\"": 2904, "\"numa\"": 2905, "\"numa_balancing\"": 2906, "\"numa_balancing_scan_delay_ms\"": 2907, "\"numa_balancing_scan_period_max_ms\"": 2908, "\"numa_balancing_scan_period_min_ms\"": 2909, "\"numa_balancing_scan_size_mb\"": 2910, "\"numa_faults_memory, %d, %d, %d, %d, %ld\\n\"": 2911, "\"numa_migrations, %ld\\n\"": 2912, "\"numa_zonelist_order\"": 2913, "\"number of jiffies between shuffles, 0=disable\"": 2914, "\"number of jiffies to run/halt test, 0=disable\"": 2915, "\"number of rcu fake writer threads\"": 2916, "\"number of rcu reader threads\"": 2917, "\"number of read-locking stress-test threads\"": 2918, "\"number of seconds between shuffles\"": 2919, "\"number of seconds between stats printk()s\"": 2920, "\"number of seconds to run/halt test\"": 2921, "\"number of write-locking stress-test threads\"": 2922, "\"o: %4d, e:%8d, s: 0x%08lx, p: %4d, n: %4d, b: %p, m:\"": 2923, "\"obsolescence_count_initialiser\"": 2924, "\"ocfs2\"": 2925, "\"of domain->span\\n\"": 2926, "\"off\\n\"": 2927, "\"offlinenocb\"": 2928, "\"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\"": 2929, "\"offset:0;\\tsize:%u;\\tsigned:%u;\\n\"": 2930, "\"ofl\"": 2931, "\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"": 2932, "\"ok\"": 2933, "\"ok\\n\"": 2934, "\"old_pe\"": 2935, "\"old_pi\"": 2936, "\"old_pp\"": 2937, "\"on processor %d \"": 2938, "\"on the run queue locks. \"": 2939, "\"onlinenocb\"": 2940, "\"onlinenq\"": 2941, "\"onlineq\"": 2942, "\"only 'ip' field is supported for function trace\"": 2943, "\"only run producer\"": 2944, "\"only_unset_loginuid\"": 2945, "\"onoff_interval=%d onoff_holdoff=%d\\n\"": 2946, "\"oom_dump_tasks\"": 2947, "\"oom_kill_allocating_task\"": 2948, "\"oops\"": 2949, "\"oops: %s\\n\"": 2950, "\"op=\"": 2951, "\"op=%p %ps\\n\"": 2952, "\"op=%s\"": 2953, "\"op_none\"": 2954, "\"operand too long\"": 2955, "\"opid=%d oauid=%d ouid=%d oses=%d\"": 2956, "\"option changes via remount are deprecated (pid=%d comm=%s)\\n\"": 2957, "\"option or name mismatch, new: 0x%x \\\"%s\\\", old: 0x%x \\\"%s\\\"\\n\"": 2958, "\"optmem_max\"": 2959, "\"ordering guarantee broken for workqueue %s\\n\"": 2960, "\"orig_cpu\"": 2961, "\"osrelease\"": 2962, "\"ostype\"": 2963, "\"ouid=%u ogid=%u mode=%#ho\"": 2964, "\"out of memory for argv string\"": 2965, "\"out of memory in audit_alloc\"": 2966, "\"out of memory in audit_log_start\"": 2967, "\"out of memory\"": 2968, "\"out of memory, audit has lost a tree reference\\n\"": 2969, "\"out of memory\\n\"": 2970, "\"overcommit_kbytes\"": 2971, "\"overcommit_memory\"": 2972, "\"overcommit_ratio\"": 2973, "\"overflow, command ignored\\n%s\\n\"": 2974, "\"overflowgid\"": 2975, "\"overflowuid\"": 2976, "\"override_creds(%p{%d,%d})\"": 2977, "\"override_creds() = %p{%d,%d}\"": 2978, "\"p\"": 2979, "\"p0\"": 2980, "\"p:testprobe kprobe_trace_selftest_target \"": 2981, "\"page-cluster\"": 2982, "\"panic\"": 2983, "\"panic: %s\\n\"": 2984, "\"panic_mask\"": 2985, "\"panic_on_io_nmi\"": 2986, "\"panic_on_oom\"": 2987, "\"panic_on_oops\"": 2988, "\"panic_on_stackoverflow\"": 2989, "\"panic_on_unrecovered_nmi\"": 2990, "\"panic_on_warn set ...\\n\"": 2991, "\"panic_on_warn\"": 2992, "\"parameters\"": 2993, "\"parent\"": 2994, "\"parent_freezing\"": 2995, "\"parse error at argument[%d]. (%d)\\n\"": 2996, "\"passed\\n\"": 2997, "\"path=/sbin:/bin:/usr/sbin:/usr/bin\"": 2998, "\"path=/sbin:/usr/sbin:/bin:/usr/bin\"": 2999, "\"path_max_retrans\"": 3000, "\"paul e. mckenney <paulmck@us.ibm.com> and josh triplett <josh@joshtriplett.org>\"": 3001, "\"paul e. mckenney <paulmck@us.ibm.com>\"": 3002, "\"paul e. mckenney\"": 3003, "\"pc\"": 3004, "\"pci io\"": 3005, "\"pci mem\"": 3006, "\"pcidev %02x%02x %04x%04x %x\"": 3007, "\"per_cpu\"": 3008, "\"percpu irq %d still enabled on cpu%d!\\n\"": 3009, "\"percpu_pagelist_fraction\"": 3010, "\"perf buffer not large enough\"": 3011, "\"perf events running\\n\"": 3012, "\"perf interrupt took too long (%lld > %lld), lowering \"": 3013, "\"perf_cpu_time_max_percent\"": 3014, "\"perf_event_max_sample_rate\"": 3015, "\"perf_event_mlock_kb\"": 3016, "\"perf_event_paranoid\"": 3017, "\"performance\\n\"": 3018, "\"pid\"": 3019, "\"pid=%d uid=%u\"": 3020, "\"pid=%d\"": 3021, "\"pid_%d\"": 3022, "\"pid_max\"": 3023, "\"pid_max: default: %u minimum: %u\\n\"": 3024, "\"pipe-max-size\"": 3025, "\"platform\"": 3026, "\"please attach the output of /proc/lock_stat to the bug report\\n\"": 3027, "\"please check additional_cpus= boot parameter\\n\"": 3028, "\"please evaluate if this is the right api to use and \"": 3029, "\"please report this trace. ]\\n\\n\"": 3030, "\"please switch to the trace global clock:\\n\"": 3031, "\"please use \\\"cpu %d\\\" and then execute go\\n\"": 3032, "\"plug\"": 3033, "\"pm\"": 3034, "\"pm: %s %u kbytes in %u.%02u seconds (%u.%02u mb/s)\\n\"": 3035, "\"pm: %s took %d.%03d seconds\\n\"": 3036, "\"pm: basic memory bitmaps created\\n\"": 3037, "\"pm: basic memory bitmaps freed\\n\"": 3038, "\"pm: can't read %s time, err %d\\n\"": 3039, "\"pm: can't set %s wakealarm, err %d\\n\"": 3040, "\"pm: can't test '%s' suspend state\\n\"": 3041, "\"pm: cannot find swap device, try \"": 3042, "\"pm: cannot find swsusp signature!\\n\"": 3043, "\"pm: cannot get swap writer\\n\"": 3044, "\"pm: cannot start crc32 thread\\n\"": 3045, "\"pm: checking hibernation image partition %s\\n\"": 3046, "\"pm: compressing and saving image data (%u pages)...\\n\"": 3047, "\"pm: creating hibernation image:\\n\"": 3048, "\"pm: error %d creating hibernation image\\n\"": 3049, "\"pm: error %d resuming\\n\"": 3050, "\"pm: failed to allocate lzo data\\n\"": 3051, "\"pm: failed to allocate lzo page\\n\"": 3052, "\"pm: failed to load hibernation image, recovering.\\n\"": 3053, "\"pm: hibernation image created (%d pages copied)\\n\"": 3054, "\"pm: hibernation image not present or could not be loaded.\\n\"": 3055, "\"pm: hibernation image partition %d:%d present\\n\"": 3056, "\"pm: hibernation not available.\\n\"": 3057, "\"pm: image device not initialised\\n\"": 3058, "\"pm: image loading done.\\n\"": 3059, "\"pm: image loading progress: %3d%%\\n\"": 3060, "\"pm: image mismatch: %s\\n\"": 3061, "\"pm: image not found (code %d)\\n\"": 3062, "\"pm: image restored successfully.\\n\"": 3063, "\"pm: image saving done.\\n\"": 3064, "\"pm: image signature found, resuming\\n\"": 3065, "\"pm: image successfully loaded\\n\"": 3066, "\"pm: invalid image crc32!\\n\"": 3067, "\"pm: invalid lzo compressed length\\n\"": 3068, "\"pm: invalid lzo uncompressed length\\n\"": 3069, "\"pm: loading hibernation image.\\n\"": 3070, "\"pm: loading image data pages (%u pages)...\\n\"": 3071, "\"pm: looking for hibernation image.\\n\"": 3072, "\"pm: memory allocation failed\\n\"": 3073, "\"pm: need to copy %u pages\\n\"": 3074, "\"pm: no wakealarm-capable rtc driver is ready\\n\"": 3075, "\"pm: normal pages needed: %u + %u, available pages: %u\\n\"": 3076, "\"pm: not enough free memory\\n\"": 3077, "\"pm: not enough free swap\\n\"": 3078, "\"pm: please power down manually\\n\"": 3079, "\"pm: preparing processes for restore.\\n\"": 3080, "\"pm: registered nosave memory: [mem %#010llx-%#010llx]\\n\"": 3081, "\"pm: s\"": 3082, "\"pm: saving image data pages (%u pages)...\\n\"": 3083, "\"pm: some devices failed to power down, \"": 3084, "\"pm: some system devices failed to power down, \"": 3085, "\"pm: suspend test failed, error %d\\n\"": 3086, "\"pm: swap header not found!\\n\"": 3087, "\"pm: swap will be unusable! \"": 3088, "\"pm: syncing filesystems ... \"": 3089, "\"pm: test rtc wakeup from '%s' suspend\\n\"": 3090, "\"pm: using %u thread(s) for compression.\\n\"": 3091, "\"pm: writing image.\\n\"": 3092, "\"pm_qos\"": 3093, "\"pm_qos_add_request() called for already added request\\n\"": 3094, "\"pm_qos_remove_request() called for unknown object\\n\"": 3095, "\"pm_qos_update_request() called for unknown object\\n\"": 3096, "\"poll\"": 3097, "\"pool %d:\"": 3098, "\"poolsize\"": 3099, "\"portbase\"": 3100, "\"portshift\"": 3101, "\"posix clock id %d lacks clock_get()\\n\"": 3102, "\"posix clock id %d lacks clock_getres()\\n\"": 3103, "\"posix clock register failed for clock_id %d\\n\"": 3104, "\"posix timers running\\n\"": 3105, "\"posix_timers_cache\"": 3106, "\"possible reason: unannotated irqs-off.\\n\"": 3107, "\"possible reason: unannotated irqs-on.\\n\"": 3108, "\"potentially unexpected fatal signal %d.\\n\"": 3109, "\"power down\\n\"": 3110, "\"power off\"": 3111, "\"power.h\"": 3112, "\"poweroff(o)\"": 3113, "\"poweroff_cmd\"": 3114, "\"poweroff_powercycle\"": 3115, "\"powersave-nap\"": 3116, "\"ppp\"": 3117, "\"preempt_rcu\"": 3118, "\"preemptible hierarchical rcu implementation.\\n\"": 3119, "\"preemption disabled at:\"": 3120, "\"preemptirqsoff\"": 3121, "\"preemptoff\"": 3122, "\"prepare_kernel_cred() alloc %p\"": 3123, "\"press stop-a (l1-a) to return to the boot prom\\n\"": 3124, "\"prestartedroot\"": 3125, "\"prestartleaf\"": 3126, "\"primary handler called for nested irq %d\\n\"": 3127, "\"print-fatal-signals\"": 3128, "\"print-fatal-signals=\"": 3129, "\"printed\\n\"": 3130, "\"printk limit exceeded\"": 3131, "\"printk\"": 3132, "\"printk_delay\"": 3133, "\"printk_ratelimit\"": 3134, "\"printk_ratelimit_burst\"": 3135, "\"priority\"": 3136, "\"probe definition must be started with 'p', 'r' or '-'.\\n\"": 3137, "\"probe definition must be started with 'p', 'r' or\"": 3138, "\"probing address(0x%p) is not an \"": 3139, "\"problem loading in-kernel x.509 certificate (%ld)\\n\"": 3140, "\"problem parsing in-kernel x.509 certificate list\\n\"": 3141, "\"process %d (%s) no longer affine to cpu%d\\n\"": 3142, "\"process accounting paused\\n\"": 3143, "\"process accounting resumed\\n\"": 3144, "\"process is not running, sending a signal from \"": 3145, "\"process table (0x%p)\\n\"": 3146, "\"process%s\"": 3147, "\"processors\"": 3148, "\"proctitle=\"": 3149, "\"profile buffer not large enough\"": 3150, "\"profile\"": 3151, "\"promote_secondaries\"": 3152, "\"prompt\"": 3153, "\"protected_hardlinks\"": 3154, "\"protected_symlinks\"": 3155, "\"protocol\"": 3156, "\"prove_locking\"": 3157, "\"proxy_arp\"": 3158, "\"proxy_ndp\"": 3159, "\"proxy_qlen\"": 3160, "\"prsctp_enable\"": 3161, "\"ps\"": 3162, "\"pty\"": 3163, "\"put_cred_rcu(%p)\"": 3164, "\"q\"": 3165, "\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\"": 3166, "\"qc\"": 3167, "\"qrcmd,\"": 3168, "\"qsp=%ld rpq=%ld cbr=%ld cng=%ld \"": 3169, "\"queue\"": 3170, "\"quota\"": 3171, "\"quote it:\\n\"": 3172, "\"r %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\"": 3173, "\"r\"": 3174, "\"r%d !read_ok\\n\"": 3175, "\"r%d is invalid\\n\"": 3176, "\"r%d type=%s expected=%s\\n\"": 3177, "\"r:testprobe2 kprobe_trace_selftest_target \"": 3178, "\"raid\"": 3179, "\"random\"": 3180, "\"randomize_va_space\"": 3181, "\"randy dunlap\"": 3182, "\"rate limit exceeded\"": 3183, "\"ratelimit\"": 3184, "\"rbhammer\"": 3185, "\"rbtester/%d\"": 3186, "\"rcu test callback executed %d\\n\"": 3187, "\"rcu used illegally from extended quiescent state!\\n\"": 3188, "\"rcu used illegally from idle cpu!\\n\"": 3189, "\"rcu used illegally from offline cpu!\\n\"": 3190, "\"rcu\"": 3191, "\"rcu-torture types:\"": 3192, "\"rcu-torture: ->fqs null and non-zero fqs_duration, fqs disabled.\\n\"": 3193, "\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\"": 3194, "\"rcu.h\"": 3195, "\"rcu: adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%d\\n\"": 3196, "\"rcu: never-onlined no-cbs cpu %d has cb %p\\n\"": 3197, "\"rcu_bh\"": 3198, "\"rcu_busted\"": 3199, "\"rcu_callback\"": 3200, "\"rcu_cleanup_dead_cpu: callbacks on offline cpu %d: qlen=%lu, nxtlist=%p\\n\"": 3201, "\"rcu_head\"": 3202, "\"rcu_init_one: rcu_num_lvls overflow\"": 3203, "\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\"": 3204, "\"rcu_nocb_poll\"": 3205, "\"rcu_nocbs=\"": 3206, "\"rcu_node_0\"": 3207, "\"rcu_node_1\"": 3208, "\"rcu_node_2\"": 3209, "\"rcu_node_3\"": 3210, "\"rcu_node_fqs_0\"": 3211, "\"rcu_node_fqs_1\"": 3212, "\"rcu_node_fqs_2\"": 3213, "\"rcu_node_fqs_3\"": 3214, "\"rcu_pending\"": 3215, "\"rcu_preempt\"": 3216, "\"rcu_read_lock\"": 3217, "\"rcu_read_lock_bh\"": 3218, "\"rcu_read_lock_sched\"": 3219, "\"rcu_read_unlock() from irq or softirq with blocking in critical section!!!\\n\"": 3220, "\"rcu_sched\"": 3221, "\"rcu_spawn_gp_kthread(): limited prio to %d from %d\\n\"": 3222, "\"rcu_tasks_kthread\"": 3223, "\"rcu_torture_barrier task starting\"": 3224, "\"rcu_torture_barrier\"": 3225, "\"rcu_torture_barrier_cbs\"": 3226, "\"rcu_torture_boost boosting failed\"": 3227, "\"rcu_torture_boost started\"": 3228, "\"rcu_torture_boost task create failed\"": 3229, "\"rcu_torture_boost\"": 3230, "\"rcu_torture_cbflood disabled: bad args or oom\"": 3231, "\"rcu_torture_cbflood task started\"": 3232, "\"rcu_torture_cbflood\"": 3233, "\"rcu_torture_fakewriter\"": 3234, "\"rcu_torture_fqs task started\"": 3235, "\"rcu_torture_fqs\"": 3236, "\"rcu_torture_reader task started\"": 3237, "\"rcu_torture_reader\"": 3238, "\"rcu_torture_stall begin holdoff\"": 3239, "\"rcu_torture_stall end holdoff\"": 3240, "\"rcu_torture_stall end.\\n\"": 3241, "\"rcu_torture_stall start.\\n\"": 3242, "\"rcu_torture_stall task started\"": 3243, "\"rcu_torture_stall\"": 3244, "\"rcu_torture_stats task started\"": 3245, "\"rcu_torture_stats\"": 3246, "\"rcu_torture_writer task started\"": 3247, "\"rcu_torture_writer\"": 3248, "\"rcu_torture_writer: gp_cond without primitives.\\n\"": 3249, "\"rcu_torture_writer: gp_exp without primitives.\\n\"": 3250, "\"rcu_torture_writer: gp_normal without primitives.\\n\"": 3251, "\"rcu_torture_writer: gp_sync without primitives.\\n\"": 3252, "\"rcu_torture_writer: no update-side primitives.\\n\"": 3253, "\"rcub/%d\"": 3254, "\"rcubarrier\"": 3255, "\"rcuboost\"": 3256, "\"rcuc/%u\"": 3257, "\"rcudata\"": 3258, "\"rcuexp\"": 3259, "\"rcugp\"": 3260, "\"rcuhier\"": 3261, "\"rcuo%c/%d\"": 3262, "\"rcupdate\"": 3263, "\"rcupdate.\"": 3264, "\"rcutorture test sequence: %lu %s\\n\"": 3265, "\"rcutorture update version number: %lu\\n\"": 3266, "\"rcutorture\"": 3267, "\"rcutorture: !config_debug_objects_rcu_head, not testing duplicate call_rcu()\\n\"": 3268, "\"rcutorture: duplicated callback was invoked.\\n\"": 3269, "\"rcutorture: warn: duplicate call_rcu() test complete.\\n\"": 3270, "\"rcutorture: warn: duplicate call_rcu() test starting.\\n\"": 3271, "\"rcutree\"": 3272, "\"rcutree.\"": 3273, "\"rcvbuf_policy\"": 3274, "\"rd\"": 3275, "\"re-enter error: breakpoint removed %lx\\n\"": 3276, "\"re-enter exception: all breakpoints killed\\n\"": 3277, "\"read\"": 3278, "\"read, diag=%d\\n\"": 3279, "\"read-copy update tracing for hierarchical implementation\"": 3280, "\"read_wakeup_threshold\"": 3281, "\"reader pipe: \"": 3282, "\"reader_tasks: out of memory\"": 3283, "\"reads \"": 3284, "\"reads\"": 3285, "\"real-root-dev\"": 3286, "\"reboot the machine immediately\"": 3287, "\"reboot\"": 3288, "\"reboot-cmd\"": 3289, "\"reboot: \"": 3290, "\"rebooting in %d seconds..\"": 3291, "\"recursion\"": 3292, "\"recursive entry to debugger\"": 3293, "\"redirect_load\"": 3294, "\"redirect_number\"": 3295, "\"redirect_silence\"": 3296, "\"regen_max_retry\"": 3297, "\"registered i/o driver %s\\n\"": 3298, "\"registered taskstats version %d\\n\"": 3299, "\"regs->ip = 0x%lx\\n\"": 3300, "\"reissue the kill command if you want to risk \"": 3301, "\"rej\"": 3302, "\"relax_domain_level=\"": 3303, "\"relaxed\"": 3304, "\"releasable\"": 3305, "\"release    %s\\n\"": 3306, "\"release child resource %pr\\n\"": 3307, "\"release_agent\"": 3308, "\"release_agent=\"": 3309, "\"release_agent=/sbin/cpuset_release_agent\"": 3310, "\"relocation failed for symbol '%s' at 0x%016lx (%d)\\n\"": 3311, "\"remap\"": 3312, "\"remount is not allowed\\n\"": 3313, "\"remove_rule\"": 3314, "\"removed domain %s\\n\"": 3315, "\"request for unknown module key '%s' err %ld\\n\"": 3316, "\"requeue\"": 3317, "\"reqwait\"": 3318, "\"reqwaitsig\"": 3319, "\"reserve=\"": 3320, "\"reserved\"": 3321, "\"reset\"": 3322, "\"reset_request_timeout\"": 3323, "\"resource collision: %pr conflicts with %s %pr\\n\"": 3324, "\"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pr\\n\"": 3325, "\"restart_request_timeout\"": 3326, "\"restarting kernel threads ... \"": 3327, "\"restarting system with command '%s'\\n\"": 3328, "\"restarting system\\n\"": 3329, "\"restarting tasks ... \"": 3330, "\"resumewait\"": 3331, "\"retrans_time_ms\"": 3332, "\"retval\"": 3333, "\"revert_creds(%p{%d,%d})\"": 3334, "\"reverting patch '%s' on unloading module '%s'\\n\"": 3335, "\"rif_timeout\"": 3336, "\"ring buffer passed!\\n\"": 3337, "\"ring_buffer_benchmark\"": 3338, "\"rm\"": 3339, "\"rmem_default\"": 3340, "\"rmem_max\"": 3341, "\"root %d group %s\\n\"": 3342, "\"rose\"": 3343, "\"rotorstep\"": 3344, "\"route\"": 3345, "\"router_probe_interval\"": 3346, "\"router_solicitation_delay\"": 3347, "\"router_solicitation_interval\"": 3348, "\"router_solicitations\"": 3349, "\"routing_control\"": 3350, "\"rp_filter\"": 3351, "\"rt-test-%d\"": 3352, "\"rt_period_us\"": 3353, "\"rt_runtime_us\"": 3354, "\"rtbf: %ld rtb: %ld nt: %ld \"": 3355, "\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \"": 3356, "\"rtmbe: %d rtbke: %ld rtbre: %ld \"": 3357, "\"rtmutex-debug.h\"": 3358, "\"rtmutex.h\"": 3359, "\"rtmutex_common.h\"": 3360, "\"rto_alpha_exp_divisor\"": 3361, "\"rto_beta_exp_divisor\"": 3362, "\"rto_initial\"": 3363, "\"rto_max\"": 3364, "\"rto_min\"": 3365, "\"rttest\"": 3366, "\"runnable_load_avg\"": 3367, "\"running rcu self tests\\n\"": 3368, "\"running ring buffer tests...\\n\"": 3369, "\"running tests on all trace events:\\n\"": 3370, "\"running tests on trace event systems:\\n\"": 3371, "\"running tests on trace events:\\n\"": 3372, "\"rw what?\\n\"": 3373, "\"rw_lock\"": 3374, "\"rw_lock_irq\"": 3375, "\"rwsem.h\"": 3376, "\"rwsem_lock\"": 3377, "\"s\"": 3378, "\"s1suspend\"": 3379, "\"s390dbf\"": 3380, "\"s=%lu d=%lu w=%lu tf=%lu wd1=%lu wd2=%lu n=%lu sc=%lu dt=%lu dl=%lu dx=%lu\\n\"": 3381, "\"s>\"": 3382, "\"s>=\"": 3383, "\"s>>=\"": 3384, "\"sack_timeout\"": 3385, "\"saddr=\"": 3386, "\"same insn cannot be used with different pointers\\n\"": 3387, "\"sane_behavior: no other mount options allowed\\n\"": 3388, "\"sane_behavior: this is still under development and its behaviors will change, proceed at your own risk\\n\"": 3389, "\"save_stack_trace_regs() not implemented yet.\\n\"": 3390, "\"save_stack_trace_tsk() not implemented yet.\\n\"": 3391, "\"saved backtrace test skipped.\\n\"": 3392, "\"sched debug version: v0.11, %s %.*s\\n\"": 3393, "\"sched rcu must be held\"": 3394, "\"sched rcu or wq->mutex should be held\"": 3395, "\"sched rcu or wq_pool_mutex should be held\"": 3396, "\"sched trace: couldn't activate tracepoint\"": 3397, "\"sched\"": 3398, "\"sched.h\"": 3399, "\"sched: rt throttling activated\\n\"": 3400, "\"sched_autogroup_enabled\"": 3401, "\"sched_cfs_bandwidth_slice_us\"": 3402, "\"sched_child_runs_first\"": 3403, "\"sched_create_group()\"": 3404, "\"sched_debug\"": 3405, "\"sched_domain\"": 3406, "\"sched_features\"": 3407, "\"sched_latency_ns\"": 3408, "\"sched_load_balance\"": 3409, "\"sched_migration_cost_ns\"": 3410, "\"sched_min_granularity_ns\"": 3411, "\"sched_nr_migrate\"": 3412, "\"sched_relax_domain_level\"": 3413, "\"sched_rr_timeslice_ms\"": 3414, "\"sched_rt_period_us\"": 3415, "\"sched_rt_runtime_us\"": 3416, "\"sched_shares_window_ns\"": 3417, "\"sched_time_avg_ms\"": 3418, "\"sched_tunable_scaling\"": 3419, "\"sched_wakeup_granularity_ns\"": 3420, "\"scons-poweroff\"": 3421, "\"scsi\"": 3422, "\"sctp\"": 3423, "\"search string too long\\n\"": 3424, "\"sections\"": 3425, "\"secure_redirects\"": 3426, "\"self_freezing\"": 3427, "\"sem\"": 3428, "\"send a signal to a process\"": 3429, "\"send_redirects\"": 3430, "\"serial_cpumask\"": 3431, "\"set environment variables\"": 3432, "\"set\"": 3433, "\"set/display breakpoints\"": 3434, "\"set_event\"": 3435, "\"set_ftrace_pid\"": 3436, "\"setting dangerous option %s - tainting kernel\\n\"": 3437, "\"setting gcov_persist to %d\\n\"": 3438, "\"setting trigger mode %lu for irq %u failed (%pf)\\n\"": 3439, "\"settings.h\"": 3440, "\"sg-big-buff\"": 3441, "\"sha256_digest\"": 3442, "\"sha_regions\"": 3443, "\"shadowcpu%d\"": 3444, "\"share_creds(%p{%d,%d})\"": 3445, "\"shared_media\"": 3446, "\"shares\"": 3447, "\"shmall\"": 3448, "\"shmmax\"": 3449, "\"shmmni\"": 3450, "\"show environment variables\"": 3451, "\"showing busy workqueues and worker pools:\\n\"": 3452, "\"shuffle_interval=%d stutter=%d irqreader=%d \"": 3453, "\"shutdown time (j), <= zero to disable.\"": 3454, "\"shutdown time (s), <= zero to disable.\"": 3455, "\"shutdown\"": 3456, "\"shutting down hard lockup detector on all cpus\\n\"": 3457, "\"sigev_thread_id must not share bit with other sigev values!\"": 3458, "\"sighand_cache\"": 3459, "\"signal %d is sent to process %d.\\n\"": 3460, "\"signal_cache\"": 3461, "\"single step\"": 3462, "\"skew_tick\"": 3463, "\"sleep delta value!\\n\"": 3464, "\"sleep\"": 3465, "\"sleeprq\"": 3466, "\"slot_timeout\"": 3467, "\"smp: fork_idle() failed for cpu %u\\n\"": 3468, "\"smp_affinity\"": 3469, "\"smp_affinity_list\"": 3470, "\"smpboot.h\"": 3471, "\"snapshot\"": 3472, "\"sndbuf_policy\"": 3473, "\"soft-power\"": 3474, "\"soft_watchdog\"": 3475, "\"softirqs last  enabled at (%u): \"": 3476, "\"softirqs last disabled at (%u): \"": 3477, "\"softlockup: hung tasks\"": 3478, "\"softlockup_all_cpu_backtrace\"": 3479, "\"softlockup_panic\"": 3480, "\"software breakpoints are unavailable.\\n\"": 3481, "\"somaxconn\"": 3482, "\"sorting __ex_table...\\n\"": 3483, "\"span %*pbl level %s\\n\"": 3484, "\"speed_limit_max\"": 3485, "\"speed_limit_min\"": 3486, "\"spin\"": 3487, "\"spin_lock\"": 3488, "\"spin_lock_irq\"": 3489, "\"spin_retry\"": 3490, "\"split\"": 3491, "\"spread\"": 3492, "\"spread0\"": 3493, "\"spurious\"": 3494, "\"sr\"": 3495, "\"srcu\"": 3496, "\"srwoy\"": 3497, "\"ss trap\"": 3498, "\"ss\"": 3499, "\"st\"": 3500, "\"stack traceback for pid %d\\n\"": 3501, "\"stack traceback\"": 3502, "\"stack\"": 3503, "\"stack-protector: kernel stack is corrupted in: %p\\n\"": 3504, "\"stack_max_size\"": 3505, "\"stack_trace\"": 3506, "\"stack_trace_filter\"": 3507, "\"stack_tracer_enabled\"": 3508, "\"stacktrace\"": 3509, "\"staging\"": 3510, "\"stall duration (s), zero to disable.\"": 3511, "\"stall_cpu=%d stall_cpu_holdoff=%d \"": 3512, "\"standard_window_size\"": 3513, "\"start boost kthread@init\"": 3514, "\"start boost kthread@rcu_wait\"": 3515, "\"start boost kthread@rcu_yield\"": 3516, "\"start context switch\"": 3517, "\"start locktorture at module init\"": 3518, "\"start rcu core\"": 3519, "\"start rcutorture at boot\"": 3520, "\"start scheduler-tick\"": 3521, "\"start\"": 3522, "\"startedleaf\"": 3523, "\"startedleafroot\"": 3524, "\"startedroot\"": 3525, "\"starting new kernel\\n\"": 3526, "\"starting tracer '%s'\\n\"": 3527, "\"startleaf\"": 3528, "\"startwait\"": 3529, "\"stat\"": 3530, "\"stat_interval\"": 3531, "\"stat_interval=%d verbose=%d test_no_idle_hz=%d \"": 3532, "\"state\"": 3533, "\"state=%lx set at [<%p>] %ps\\n\"": 3534, "\"station\"": 3535, "\"stats.h\"": 3536, "\"stats_clear\"": 3537, "\"steven rostedt\"": 3538, "\"stop-a\"": 3539, "\"stopping %s\"": 3540, "\"stopping torture_shuffle task\"": 3541, "\"stopping torture_shutdown task\"": 3542, "\"stopping torture_stutter task\"": 3543, "\"strict\"": 3544, "\"string\"": 3545, "\"string_size\"": 3546, "\"stx\"": 3547, "\"suid_dumpable\"": 3548, "\"suid_dumpable=2. pipe handler or fully qualified \"": 3549, "\"sum\"": 3550, "\"summarize the system\"": 3551, "\"summary\"": 3552, "\"sunrpc\"": 3553, "\"suspend\"": 3554, "\"swap-space\"": 3555, "\"swapon -a.\\n\"": 3556, "\"swapper tasks\\n\"": 3557, "\"swappiness\"": 3558, "\"swapspace2\"": 3559, "\"switch to another task\"": 3560, "\"switch to new cpu\"": 3561, "\"symbol %s is being used by a non-gpl module, \"": 3562, "\"symbol %s is in a bss section. cannot %s\\n\"": 3563, "\"symbol %s is marked as unused, however this module is \"": 3564, "\"symbol %s size mismatch: expected %lu actual %u\\n\"": 3565, "\"symbol '%s' not found at specified address 0x%016lx, kernel mismatch?\\n\"": 3566, "\"symbol '%s' not found in symbol table\\n\"": 3567, "\"symbol: %s has bad section index %d.\\n\"": 3568, "\"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\"": 3569, "\"symtab->sym_start=0x%lx\\n\"": 3570, "\"sync\"": 3571, "\"synchronize_rcu_tasks called too soon\"": 3572, "\"syncing filesystems ... \"": 3573, "\"syncs\"": 3574, "\"sys_ni_syscall\"": 3575, "\"syscall %s metadata not mapped, disabling ftrace event\\n\"": 3576, "\"syscall entry trace point\"": 3577, "\"syscall exit trace point\"": 3578, "\"syscalls\"": 3579, "\"sysctl_sched\\n\"": 3580, "\"sysctl_sched_tunable_scaling\"": 3581, "\"sysctl_writes_strict\"": 3582, "\"sysname    %s\\n\"": 3583, "\"sysrq\"": 3584, "\"system call with \"": 3585, "\"system halted\\n\"": 3586, "\"system ram\"": 3587, "\"system type\"": 3588, "\"system\"": 3589, "\"t.\"": 3590, "\"t1_timeout\"": 3591, "\"t2\"": 3592, "\"t2_timeout\"": 3593, "\"t3\"": 3594, "\"t3_timeout\"": 3595, "\"table\\n\"": 3596, "\"tag\"": 3597, "\"tainted\"": 3598, "\"tainted: \"": 3599, "\"tainting kernel with taint_livepatch\\n\"": 3600, "\"target module is loaded. continue.\\n\"": 3601, "\"task %s (pid=%d) is on cpu %d (state=%ld, flags=%x)\\n\"": 3602, "\"task addr\"": 3603, "\"task dump for cpu %d:\\n\"": 3604, "\"task_struct\"": 3605, "\"taskcount\"": 3606, "\"tasklet\"": 3607, "\"tasks\"": 3608, "\"tcp_abort_on_overflow\"": 3609, "\"tcp_adv_win_scale\"": 3610, "\"tcp_allowed_congestion_control\"": 3611, "\"tcp_app_win\"": 3612, "\"tcp_base_mss\"": 3613, "\"tcp_congestion_control\"": 3614, "\"tcp_dsack\"": 3615, "\"tcp_ecn\"": 3616, "\"tcp_fack\"": 3617, "\"tcp_fin_timeout\"": 3618, "\"tcp_frto\"": 3619, "\"tcp_frto_response\"": 3620, "\"tcp_keepalive_intvl\"": 3621, "\"tcp_keepalive_probes\"": 3622, "\"tcp_keepalive_time\"": 3623, "\"tcp_low_latency\"": 3624, "\"tcp_max_orphans\"": 3625, "\"tcp_max_ssthresh\"": 3626, "\"tcp_max_syn_backlog\"": 3627, "\"tcp_max_tw_buckets\"": 3628, "\"tcp_mem\"": 3629, "\"tcp_moderate_rcvbuf\"": 3630, "\"tcp_mtu_probing\"": 3631, "\"tcp_no_metrics_save\"": 3632, "\"tcp_orphan_retries\"": 3633, "\"tcp_reordering\"": 3634, "\"tcp_retrans_collapse\"": 3635, "\"tcp_retries1\"": 3636, "\"tcp_retries2\"": 3637, "\"tcp_rfc1337\"": 3638, "\"tcp_rmem\"": 3639, "\"tcp_sack\"": 3640, "\"tcp_slot_table_entries\"": 3641, "\"tcp_slow_start_after_idle\"": 3642, "\"tcp_stdurg\"": 3643, "\"tcp_syn_retries\"": 3644, "\"tcp_synack_retries\"": 3645, "\"tcp_syncookies\"": 3646, "\"tcp_timestamps\"": 3647, "\"tcp_tso_win_divisor\"": 3648, "\"tcp_tw_recycle\"": 3649, "\"tcp_tw_reuse\"": 3650, "\"tcp_window_scaling\"": 3651, "\"tcp_wmem\"": 3652, "\"tcp_workaround_signed_windows\"": 3653, "\"temp_prefered_lft\"": 3654, "\"temp_valid_lft\"": 3655, "\"term=linux\"": 3656, "\"test rcu prio boost: 0=no, 1=maybe, 2=yes.\"": 3657, "\"test support for tickless idle cpus\"": 3658, "\"test-events\"": 3659, "\"test_boost=%d/%d test_boost_interval=%d \"": 3660, "\"test_boost_duration=%d shutdown_secs=%d \"": 3661, "\"test_suspend\"": 3662, "\"testing a backtrace from irq context.\\n\"": 3663, "\"testing a backtrace from process context.\\n\"": 3664, "\"testing a saved backtrace.\\n\"": 3665, "\"testing all events: \"": 3666, "\"testing dynamic ftrace ops #%d: \"": 3667, "\"testing dynamic ftrace: \"": 3668, "\"testing event %s: \"": 3669, "\"testing event system %s: \"": 3670, "\"testing ftrace filter: \"": 3671, "\"testing ftrace recursion safe: \"": 3672, "\"testing ftrace recursion: \"": 3673, "\"testing ftrace regs%s: \"": 3674, "\"testing kprobe tracing: \"": 3675, "\"testing tracer %s: \"": 3676, "\"testprobe\"": 3677, "\"testprobe2\"": 3678, "\"tg->cfs_bandwidth.timer_active\"": 3679, "\"tg->runnable_avg\"": 3680, "\"tg_load_avg\"": 3681, "\"tg_load_contrib\"": 3682, "\"tg_runnable_contrib\"": 3683, "\"thaw_processes\"": 3684, "\"thawed\"": 3685, "\"the code is fine but needs lockdep annotation.\\n\"": 3686, "\"the deadlock.\\n\"": 3687, "\"the following trace is a kernel self test and not a bug!\\n\"": 3688, "\"the sigmask lock is held somewhere else in \"": 3689, "\"the signal has _not_ been sent.\\n\"": 3690, "\"this may impact system performance.\\n\"": 3691, "\"this may significantly impact system \"": 3692, "\"this probe might be able to register after\"": 3693, "\"this symbol will go away in the future.\\n\"": 3694, "\"thread overran stack, or stack corrupted\\n\"": 3695, "\"thread\"": 3696, "\"thread:\"": 3697, "\"thread_info\"": 3698, "\"threaded irq requested with handler=null and !oneshot for irq %d\\n\"": 3699, "\"threadextrainfo,\"": 3700, "\"threadirqs\"": 3701, "\"threads-max\"": 3702, "\"throttle_count\"": 3703, "\"throttled\"": 3704, "\"throttled_time %llu\\n\"": 3705, "\"tick device: mode:     %d\\n\"": 3706, "\"tick-internal.h\"": 3707, "\"tick-sched.h\"": 3708, "\"ticks this gp\"": 3709, "\"time after boot before cpu hotplugs (s)\"": 3710, "\"time between cpu hotplugs (s), 0=disable\"": 3711, "\"time to wait before starting stall (s).\"": 3712, "\"time_wait\"": 3713, "\"timeconst.h\"": 3714, "\"timed out waiting for secondary cpus.\\n\"": 3715, "\"timekeeping.h\"": 3716, "\"timekeeping_internal.h\"": 3717, "\"timeout\"": 3718, "\"timer\"": 3719, "\"timer: %pf preempt leak: %08x -> %08x\\n\"": 3720, "\"timer_list\"": 3721, "\"timer_migration\"": 3722, "\"timestamp %lu\\n\"": 3723, "\"tiny_plugin.h\"": 3724, "\"to continue\\n\"": 3725, "\"token-ring\"": 3726, "\"too many operands\"": 3727, "\"too many terms in predicate expression\"": 3728, "\"torture thread %s parking due to system shutdown\\n\"": 3729, "\"torture_init_begin: refusing %s init: %s running\"": 3730, "\"torture_onoff begin holdoff\"": 3731, "\"torture_onoff end holdoff\"": 3732, "\"torture_onoff task started\"": 3733, "\"torture_onoff task: offline %d failed: errno %d\\n\"": 3734, "\"torture_onoff task: offlined %d\\n\"": 3735, "\"torture_onoff task: offlining %d\\n\"": 3736, "\"torture_shuffle task started\"": 3737, "\"torture_shuffle\"": 3738, "\"torture_shutdown task shutting down system\"": 3739, "\"torture_shutdown task started\"": 3740, "\"torture_shutdown task: %lu jiffies remaining\\n\"": 3741, "\"torture_shutdown\"": 3742, "\"torture_stutter task started\"": 3743, "\"torture_stutter\"": 3744, "\"tp_printk\"": 3745, "\"trace\"": 3746, "\"trace.h\"": 3747, "\"trace_benchmark.h\"": 3748, "\"trace_buf_size=\"": 3749, "\"trace_clock=\"": 3750, "\"trace_entries.h\"": 3751, "\"trace_event=\"": 3752, "\"trace_events_filter_test.h\"": 3753, "\"trace_options=\"": 3754, "\"trace_output.h\"": 3755, "\"trace_probe.h\"": 3756, "\"trace_stat\"": 3757, "\"trace_stat.h\"": 3758, "\"trace_system\"": 3759, "\"traceoff\"": 3760, "\"traceoff_on_warning\"": 3761, "\"traceon\"": 3762, "\"tracepoint_printk\"": 3763, "\"tracer %s already registered\\n\"": 3764, "\"tracer has a name longer than %d\\n\"": 3765, "\"tracer must have a name\\n\"": 3766, "\"tracing: failed to allocate common fields\"": 3767, "\"transport_acknowledge_delay\"": 3768, "\"transport_busy_delay\"": 3769, "\"transport_maximum_tries\"": 3770, "\"transport_no_activity_timeout\"": 3771, "\"transport_requested_window_size\"": 3772, "\"transport_timeout\"": 3773, "\"tree.h\"": 3774, "\"trigger\"": 3775, "\"try swapon -a.\\n\"": 3776, "\"trying to free already-free irq %d\\n\"": 3777, "\"trying to free dma%d\\n\"": 3778, "\"trying to free free dma%d\\n\"": 3779, "\"trying to free irq %d from irq context!\\n\"": 3780, "\"trying to free nonexistent resource \"": 3781, "\"trylock failure on up\"": 3782, "\"tsb-ratio\"": 3783, "\"turning off the locking correctness validator.\\n\"": 3784, "\"type go a second time if you really want \"": 3785, "\"type of lock to torture (spin_lock, spin_lock_irq, mutex_lock, ...)\"": 3786, "\"type of rcu to torture (rcu, rcu_bh, ...)\"": 3787, "\"type: %d\\n\"": 3788, "\"type=%d %s\\n\"": 3789, "\"type=%s, value=%d, requests: active=%d / total=%d\\n\"": 3790, "\"tz_minuteswest %d\\n\"": 3791, "\"u\"": 3792, "\"u16\"": 3793, "\"u32\"": 3794, "\"u64\"": 3795, "\"u8\"": 3796, "\"ucast_solicit\"": 3797, "\"udelay() test (lpj=%ld kt=%ld.%09ld)\\n\"": 3798, "\"udelay_test\"": 3799, "\"udp_slot_table_entries\"": 3800, "\"uid_cache\"": 3801, "\"unable to set relax_domain_level\\n\"": 3802, "\"unaligned-dump-stack\"": 3803, "\"unaligned-trap\"": 3804, "\"unbalanced enable for irq %d\\n\"": 3805, "\"unbalanced irq %d wake disable\\n\"": 3806, "\"unbalanced parens\"": 3807, "\"unexpected event refcount: %ld; ptr=%p\\n\"": 3808, "\"unhandled %u\\n\"": 3809, "\"unix\"": 3810, "\"unknown %u.%06lu %d 0x%llx %02lx,%02lx,\"": 3811, "\"unknown action %x\\n\"": 3812, "\"unknown argument '%s'\\n\"": 3813, "\"unknown func %d\\n\"": 3814, "\"unknown insn class %d\\n\"": 3815, "\"unknown opcode %02x\\n\"": 3816, "\"unknown return type %d of func %d\\n\"": 3817, "\"unknown\"": 3818, "\"unknown_nmi_panic\"": 3819, "\"unloading\"": 3820, "\"unmap %u.%06lu %d 0x%lx %d\\n\"": 3821, "\"unplug_io\"": 3822, "\"unplug_timer\"": 3823, "\"unrecognized bpf_ld_imm64 insn\\n\"": 3824, "\"unregistered i/o driver %s, debugger disabled\\n\"": 3825, "\"unres_qlen\"": 3826, "\"unresolvable ambiguity (%lu matches) on symbol '%s' in object '%s'\\n\"": 3827, "\"unsafe core_pattern used with \"": 3828, "\"unscheduled system shutdown detected\"": 3829, "\"unspecified\"": 3830, "\"unstable sched clock\\n\"": 3831, "\"unsupported arg_type %d\\n\"": 3832, "\"unsupported type: %s\\n\"": 3833, "\"updated_rules\"": 3834, "\"uprobe: %s:%d failed to %s\\n\"": 3835, "\"uprobe: omit uretprobe due to\"": 3836, "\"uprobe: unable to handle uretprobe pid/tgid=%d/%d\\n\"": 3837, "\"uprobe: unable to set uretprobe pid/tgid=%d/%d\\n\"": 3838, "\"uprobe_events\"": 3839, "\"uprobe_profile\"": 3840, "\"uprobes\"": 3841, "\"uptime     \"": 3842, "\"usage of  cmd args | grep pattern:\\n\"": 3843, "\"usage\"": 3844, "\"usage:\\n\"": 3845, "\"usage_percpu\"": 3846, "\"use conditional/async gp wait primitives\"": 3847, "\"use expedited gp wait primitives\"": 3848, "\"use normal (non-expedited) gp wait primitives\"": 3849, "\"use synchronous gp wait primitives\"": 3850, "\"use_tempaddr\"": 3851, "\"user\"": 3852, "\"user_reserve_kbytes\"": 3853, "\"usermodehelper\"": 3854, "\"userprocess_debug\"": 3855, "\"using it.\\n\"": 3856, "\"ut\"": 3857, "\"utilization_load_avg\"": 3858, "\"uts\"": 3859, "\"uuid\"": 3860, "\"valid_cookie_life\"": 3861, "\"vdso_enabled\"": 3862, "\"vermagic\"": 3863, "\"version    %s\\n\"": 3864, "\"version %d\\n\"": 3865, "\"version 20070824\\n\"": 3866, "\"version magic: 0x%x\\n\"": 3867, "\"version\"": 3868, "\"version)\\n\"": 3869, "\"vfs_cache_pressure\"": 3870, "\"virq%i doesn't exist; cannot disassociate\\n\"": 3871, "\"vm\"": 3872, "\"vmlinux\"": 3873, "\"w %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\"": 3874, "\"wait time between fqs bursts (s)\"": 3875, "\"waiting %dsec before reading resume device...\\n\"": 3876, "\"waiting for connection from remote gdb...\\n\"": 3877, "\"waitqueue\"": 3878, "\"waittime-avg\"": 3879, "\"waittime-max\"": 3880, "\"waittime-min\"": 3881, "\"waittime-total\"": 3882, "\"wake_idx\"": 3883, "\"wakeempty\"": 3884, "\"wakeemptyisdeferred\"": 3885, "\"wakenot\"": 3886, "\"wakenotpoll\"": 3887, "\"wakeovf\"": 3888, "\"wakeovfisdeferred\"": 3889, "\"wakeup trace: couldn't activate tracepoint\"": 3890, "\"wakeup\"": 3891, "\"wakeup_dl\"": 3892, "\"wakeup_rt\"": 3893, "\"warn_noreply_time\"": 3894, "\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\"": 3895, "\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\"": 3896, "\"warning: boot clock returned invalid value!\\n\"": 3897, "\"warning: could not register \"": 3898, "\"warning: could not register block events\\n\"": 3899, "\"warning: could not register graph trace events\\n\"": 3900, "\"warning: could not register the block tracer\\n\"": 3901, "\"warning: found a stray unused \"": 3902, "\"warning: overflow in clocksource '%s' observed, time update capped.\\n\"": 3903, "\"warning: persistent clock returned invalid value!\\n\"": 3904, "\"warning: process `%s' used the deprecated sysctl \"": 3905, "\"warning: timekeeping: cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\"": 3906, "\"warning: underflow in clocksource '%s' observed, time update ignored.\\n\"": 3907, "\"warnings\"": 3908, "\"watchdog detected hard lockup on cpu %d\"": 3909, "\"watchdog\"": 3910, "\"watchdog/%u\"": 3911, "\"watchdog_thresh\"": 3912, "\"which will not be allowed in the future\\n\"": 3913, "\"window_size\"": 3914, "\"wmem_default\"": 3915, "\"wmem_max\"": 3916, "\"wokeempty\"": 3917, "\"wokenonempty\"": 3918, "\"wokequeue\"": 3919, "\"work_struct\"": 3920, "\"workqueue %s: flags=0x%x\\n\"": 3921, "\"workqueue\"": 3922, "\"workqueue: allocation failed while updating numa affinity of \\\"%s\\\"\\n\"": 3923, "\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\"": 3924, "\"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\"": 3925, "\"workqueue_internal.h\"": 3926, "\"write\"": 3927, "\"write_wakeup_threshold\"": 3928, "\"writer_tasks: out of memory\"": 3929, "\"writes\"": 3930, "\"wrong cpu\"": 3931, "\"wrong owner\"": 3932, "\"wrong sd_flags in topology description\\n\"": 3933, "\"wrote\"": 3934, "\"x\"": 3935, "\"x25\"": 3936, "\"x25_forward\"": 3937, "\"xattr\"": 3938, "\"xfrm_aevent_etime\"": 3939, "\"xfrm_aevent_rseqth\"": 3940, "\"xfs\"": 3941, "\"xfsbufd_centisecs\"": 3942, "\"xfssyncd_centisecs\"": 3943, "\"yes\"": 3944, "\"you already have a breakpoint at \"": 3945, "\"you may retry by moving them to a different hierarchy and unbinding\\n\"": 3946, "\"your compiler is too old; turning off.\\n\"": 3947, "\"zone_reclaim_mode\"": 3948, "\"{%s} state was registered at:\\n\"": 3949, "\"|=\"": 3950, "\"|\\n\"": 3951, "\"||\"": 3952, "\"||||\"": 3953, "\"} \"": 3954, "\"} \\n\"": 3955, "\"}\\n\"": 3956, "\"~\"": 3957, "# define": 3958, "# endif": 3959, "# ifdef": 3960, "#define": 3961, "#endif": 3962, "#ifdef": 3963, "#ifndef": 3964, "#include": 3965, "%": 3966, "&": 3967, "&&": 3968, "' '": 3969, "'!'": 3970, "'\"'": 3971, "'#'": 3972, "'$'": 3973, "'%'": 3974, "'('": 3975, "')'": 3976, "'*'": 3977, "'+'": 3978, "','": 3979, "'-'": 3980, "'.'": 3981, "'/'": 3982, "'0'": 3983, "'1'": 3984, "'2'": 3985, "'3'": 3986, "'4'": 3987, "'5'": 3988, "'9'": 3989, "':'": 3990, "';'": 3991, "'='": 3992, "'>'": 3993, "'?'": 3994, "'@'": 3995, "'['": 3996, "'\\''": 3997, "'\\0'": 3998, "'\\\\'": 3999, "'\\n'": 4000, "'\\t'": 4001, "'^'": 4002, "'_'": 4003, "'a'": 4004, "'b'": 4005, "'c'": 4006, "'d'": 4007, "'e'": 4008, "'f'": 4009, "'g'": 4010, "'h'": 4011, "'i'": 4012, "'k'": 4013, "'l'": 4014, "'m'": 4015, "'n'": 4016, "'o'": 4017, "'p'": 4018, "'q'": 4019, "'r'": 4020, "'s'": 4021, "'t'": 4022, "'u'": 4023, "'v'": 4024, "'w'": 4025, "'x'": 4026, "'y'": 4027, "'z'": 4028, "'|'": 4029, "(": 4030, ")": 4031, "*": 4032, "+": 4033, "++": 4034, ",": 4035, "-": 4036, "--": 4037, "->": 4038, ".": 4039, "/": 4040, "0": 4041, "000000": 4042, "0200": 4043, "0222": 4044, "0400": 4045, "0444": 4046, "0555": 4047, "0600": 4048, "0644": 4049, "0666": 4050, "1": 4051, "1.5": 4052, "10": 4053, "100": 4054, "1000": 4055, "10000": 4056, "100000": 4057, "1000000": 4058, "100000000": 4059, "1001": 4060, "1002": 4061, "1003": 4062, "1005": 4063, "10153587": 4064, "1023": 4065, "1024": 4066, "1048576": 4067, "10698": 4068, "1099582": 4069, "11": 4070, "110": 4071, "1100000": 4072, "112": 4073, "11470": 4074, "117": 4075, "1178": 4076, "118348": 4077, "11916": 4078, "119304647": 4079, "12": 4080, "120": 4081, "12226": 4082, "1234": 4083, "12345": 4084, "123456": 4085, "125": 4086, "127": 4087, "1277": 4088, "128": 4089, "12820798": 4090, "12966": 4091, "13": 4092, "13690": 4093, "137": 4094, "1376151": 4095, "14": 4096, "1431655765": 4097, "14398": 4098, "147320": 4099, "148102320": 4100, "14949": 4101, "15": 4102, "15091": 4103, "15769": 4104, "15790321": 4105, "1586": 4106, "16": 4107, "16433": 4108, "17": 4109, "17082": 4110, "1717300": 4111, "172": 4112, "17718": 4113, "18": 4114, "18340": 4115, "184698": 4116, "186737708": 4117, "18705": 4118, "18949": 4119, "1900": 4120, "19545": 4121, "1982": 4122, "1991": 4123, "19976592": 4124, "2": 4125, "20": 4126, "200": 4127, "2000": 4128, "20000": 4129, "20128": 4130, "20698": 4131, "2088": 4132, "2089": 4133, "21": 4134, "21256": 4135, "215": 4136, "2157191": 4137, "21802": 4138, "22": 4139, "22336": 4140, "22859": 4141, "229616": 4142, "23": 4143, "231": 4144, "23254": 4145, "23371": 4146, "238609294": 4147, "24": 4148, "24970740": 4149, "25": 4150, "250": 4151, "2501": 4152, "253": 4153, "255": 4154, "256": 4155, "2560": 4156, "27": 4157, "2708050": 4158, "272": 4159, "28": 4160, "286331153": 4161, "287308": 4162, "29": 4163, "29154": 4164, "2941": 4165, "3": 4166, "30": 4167, "300": 4168, "31": 4169, "3121": 4170, "31350126": 4171, "32": 4172, "32767": 4173, "32768": 4174, "335": 4175, "3363326": 4176, "345": 4177, "36": 4178, "3600": 4179, "360437": 4180, "36291": 4181, "365": 4182, "367": 4183, "38": 4184, "3880": 4185, "39": 4186, "39045157": 4187, "3906": 4188, "4": 4189, "40": 4190, "400": 4191, "4080": 4192, "4096": 4193, "4194304": 4194, "423": 4195, "43": 4196, "449829": 4197, "45": 4198, "46273": 4199, "47742": 4200, "4798": 4201, "48": 4202, "48388": 4203, "4904": 4204, "49367440": 4205, "5": 4206, "50": 4207, "500": 4208, "5000": 4209, "500000": 4210, "512": 4211, "5237765": 4212, "526": 4213, "56": 4214, "563644": 4215, "56483": 4216, "5678": 4217, "5679": 4218, "5697": 4219, "59856": 4220, "6": 4221, "60": 4222, "600": 4223, "60000": 4224, "6100": 4225, "61356676": 4226, "63": 4227, "64": 4228, "65": 4229, "655": 4230, "65535": 4231, "6557202": 4232, "6576": 4233, "68": 4234, "7": 4235, "70": 4236, "704093": 4237, "71755": 4238, "719499": 4239, "72": 4240, "7437": 4241, "75": 4242, "7500": 4243, "76": 4244, "76040": 4245, "7620": 4246, "76695844": 4247, "8": 4248, "80": 4249, "8165337": 4250, "8192": 4251, "8196": 4252, "820": 4253, "8279": 4254, "87": 4255, "875809": 4256, "88761": 4257, "9": 4258, "9103": 4259, "92818": 4260, "933": 4261, "950000": 4262, "95443717": 4263, "9548": 4264, "96": 4265, "98": 4266, "99": 4267, "9909": 4268, "99900": 4269, ":": 4270, ";": 4271, "<\n\t\t\t\t(rq->": 4272, "<\n\t\t\t(sgs->": 4273, "<\n\t    busiest->": 4274, "<  900000/user_hz ||\n\t\t     txc->": 4275, "<  offset ||\n\t\t    uprobe->": 4276, "< &(rsp)->": 4277, "< &per_cpu(cpu_worker_pools, cpu)[nr_std_worker_pools]; \\\n\t     (pool)++)\n\n\n#define for_each_pool(pool, pi)\t\t\t\t\t\t\\\n\tidr_for_each_entry(&worker_pool_idr, pool, pi)\t\t\t\\\n\t\tif (({ assert_rcu_or_pool_mutex(); false; })) { }\t\\\n\t\telse\n\n\n#define for_each_pool_worker(worker, pool)\t\t\t\t\\\n\tlist_for_each_entry((worker), &(pool)->": 4278, "< &pid_ns->": 4279, "< '0' || argv[0][1] >": 4280, "< ((u64)wl_gc_time_sec * nsec_per_sec))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_remove(&wl->": 4281, "< (1ull << dl_scale))\n\t\treturn false;\n\n\t\n\tif (attr->": 4282, "< (arr->": 4283, "< (bufmax - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t\n\t\t\t\tdbg_io_ops->": 4284, "< (bw + bo)) ? -einval : 0;\n}\n\n\nint traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, bool is_return, bool is_kprobe,\n\t\tconst struct fetch_type *ftbl)\n{\n\tconst char *t;\n\tint ret;\n\n\tif (strlen(arg) >": 4285, "< (commit - read)) ||\n\t    cpu_buffer->": 4286, "< (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p >": 4287, "< (depth + 1) * trace_graph_indent; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t\n\ttrace_seq_puts(s, \"\n\tif (s->": 4288, "< (group_faults(p, src_nid) * 3 / 4);\n}\n\nstatic unsigned long weighted_cpuload(const int cpu);\nstatic unsigned long source_load(int cpu, int type);\nstatic unsigned long target_load(int cpu, int type);\nstatic unsigned long capacity_of(int cpu);\nstatic long effective_load(struct task_group *tg, int cpu, long wl, long wg);\n\n\nstruct numa_stats {\n\tunsigned long nr_running;\n\tunsigned long load;\n\n\t\n\tunsigned long compute_capacity;\n\n\t\n\tunsigned long task_capacity;\n\tint has_free_capacity;\n};\n\n\nstatic void update_numa_stats(struct numa_stats *ns, int nid)\n{\n\tint smt, cpu, cpus = 0;\n\tunsigned long capacity;\n\n\tmemset(ns, 0, sizeof(*ns));\n\tfor_each_cpu(cpu, cpumask_of_node(nid)) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\n\t\tns->": 4289, "< (mask >": 4290, "< (pos & 0xff); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}\n\n\nunsigned long kallsyms_lookup_name(const char *name)\n{\n\tchar namebuf[ksym_name_len];\n\tunsigned long i;\n\tunsigned int off;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, array_size(namebuf));\n\n\t\tif (strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_addresses[i];\n\t}\n\treturn module_kallsyms_lookup_name(name);\n}\nexport_symbol_gpl(kallsyms_lookup_name);\n\nint kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,\n\t\t\t\t      unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[ksym_name_len];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, array_size(namebuf));\n\t\tret = fn(data, namebuf, null, kallsyms_addresses[i]);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn module_kallsyms_on_each_symbol(fn, data);\n}\nexport_symbol_gpl(kallsyms_on_each_symbol);\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t\n\tbug_on(!kallsyms_addresses);\n\n\t\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low >": 4291, "< (ret & seccomp_ret_action))\n\t\t\tret = cur_ret;\n\t}\n\treturn ret;\n}\n#endif \n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->": 4292, "< (rsp)->": 4293, "< (s64)d->": 4294, "< (s64)sysctl_sched_migration_cost;\n}\n\n#ifdef config_numa_balancing\n\nstatic bool migrate_improves_locality(struct task_struct *p, struct lb_env *env)\n{\n\tstruct numa_group *numa_group = rcu_dereference(p->": 4295, "< (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if acct_version == 1 || acct_version == 2\n\t{\n\t\t\n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->": 4296, "< (unsigned long)__irqentry_text_start ||\n\t\taddr >": 4297, "< (unsigned long)__irqentry_text_start) ||\n\t    (addr >": 4298, "< (unsigned long)__kprobes_text_end;\n}\n\nstatic bool within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >": 4299, "< (unsigned long)__lock_text_end;\n}\nexport_symbol(in_lock_functions);\n\nlockdep_state(hardirq)\nlockdep_state(softirq)\nlockdep_state(reclaim_fs)\n#ifndef _linux_cpudl_h\n#define _linux_cpudl_h\n\n#include <linux/sched.h>": 4300, "< (unsigned long)__sched_text_end);\n}\n\n#ifdef config_cgroup_sched\n\nstruct task_group root_task_group;\nlist_head(task_groups);\n#endif\n\ndeclare_per_cpu(cpumask_var_t, load_balance_mask);\n\nvoid __init sched_init(void)\n{\n\tint i, j;\n\tunsigned long alloc_size = 0, ptr;\n\n#ifdef config_fair_group_sched\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n#ifdef config_rt_group_sched\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n\tif (alloc_size) {\n\t\tptr = (unsigned long)kzalloc(alloc_size, gfp_nowait);\n\n#ifdef config_fair_group_sched\n\t\troot_task_group.se = (struct sched_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.cfs_rq = (struct cfs_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif \n#ifdef config_rt_group_sched\n\t\troot_task_group.rt_se = (struct sched_rt_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.rt_rq = (struct rt_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif \n\t}\n#ifdef config_cpumask_offstack\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(load_balance_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), gfp_kernel, cpu_to_node(i));\n\t}\n#endif \n\n\tinit_rt_bandwidth(&def_rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n\tinit_dl_bandwidth(&def_dl_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n\n#ifdef config_smp\n\tinit_defrootdomain();\n#endif\n\n#ifdef config_rt_group_sched\n\tinit_rt_bandwidth(&root_task_group.rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n#endif \n\n#ifdef config_cgroup_sched\n\tlist_add(&root_task_group.list, &task_groups);\n\tinit_list_head(&root_task_group.children);\n\tinit_list_head(&root_task_group.siblings);\n\tautogroup_init(&init_task);\n\n#endif \n\n\tfor_each_possible_cpu(i) {\n\t\tstruct rq *rq;\n\n\t\trq = cpu_rq(i);\n\t\traw_spin_lock_init(&rq->": 4301, "< (unsigned long)_edata)\n\t\treturn 1;\n\treturn 0;\n}\n\nint __kernel_text_address(unsigned long addr)\n{\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\tif (is_module_text_address(addr))\n\t\treturn 1;\n\tif (is_ftrace_trampoline(addr))\n\t\treturn 1;\n\t\n\tif (init_kernel_text(addr))\n\t\treturn 1;\n\treturn 0;\n}\n\nint kernel_text_address(unsigned long addr)\n{\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\tif (is_module_text_address(addr))\n\t\treturn 1;\n\treturn is_ftrace_trampoline(addr);\n}\n\n\nint func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}\n\n\n#define rt_mutex_deadlock_check(l)\t\t\t(0)\n#define rt_mutex_deadlock_account_lock(m, t)\t\tdo { } while (0)\n#define rt_mutex_deadlock_account_unlock(l)\t\tdo { } while (0)\n#define debug_rt_mutex_init_waiter(w)\t\t\tdo { } while (0)\n#define debug_rt_mutex_free_waiter(w)\t\t\tdo { } while (0)\n#define debug_rt_mutex_lock(l)\t\t\t\tdo { } while (0)\n#define debug_rt_mutex_proxy_lock(l,p)\t\t\tdo { } while (0)\n#define debug_rt_mutex_proxy_unlock(l)\t\t\tdo { } while (0)\n#define debug_rt_mutex_unlock(l)\t\t\tdo { } while (0)\n#define debug_rt_mutex_init(m, n)\t\t\tdo { } while (0)\n#define debug_rt_mutex_deadlock(d, a ,l)\t\tdo { } while (0)\n#define debug_rt_mutex_print_deadlock(w)\t\tdo { } while (0)\n#define debug_rt_mutex_reset_waiter(w)\t\t\tdo { } while (0)\n\nstatic inline void rt_mutex_print_deadlock(struct rt_mutex_waiter *w)\n{\n\twarn(1, \"rtmutex deadlock detected\\n\");\n}\n\nstatic inline bool debug_rt_mutex_detect_deadlock(struct rt_mutex_waiter *w,\n\t\t\t\t\t\t  enum rtmutex_chainwalk walk)\n{\n\treturn walk == rt_mutex_full_chainwalk;\n}\n#include \"audit.h\"\n#include <linux/fsnotify_backend.h>": 4302, "< (unsigned long)_einittext)\n\t\treturn 1;\n\treturn 0;\n}\n\nint core_kernel_text(unsigned long addr)\n{\n\tif (addr >": 4303, "< (unsigned long)_etext)\n\t\treturn 1;\n\n\tif (system_state == system_booting &&\n\t    init_kernel_text(addr))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nint core_kernel_data(unsigned long addr)\n{\n\tif (addr >": 4304, "< (unsigned long)end;\t\t\\\n\t     event++)\n\n#ifdef config_modules\n\nstatic void trace_module_add_events(struct module *mod)\n{\n\tstruct ftrace_event_call **call, **start, **end;\n\n\tif (!mod->": 4305, "< (unsigned)(b - base);\n}\n\n\nstatic void set_last_pid(struct pid_namespace *pid_ns, int base, int pid)\n{\n\tint prev;\n\tint last_write = base;\n\tdo {\n\t\tprev = last_write;\n\t\tlast_write = cmpxchg(&pid_ns->": 4306, "< *lenp && len < maxlen - 1) {\n\t\t\tif (get_user(c, p++))\n\t\t\t\treturn -efault;\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tdata[len++] = c;\n\t\t}\n\t\tdata[len] = 0;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len >": 4307, "< *lenp) {\n\t\t\tif (put_user('\\n', buffer + len))\n\t\t\t\treturn -efault;\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n\nstatic void warn_sysctl_write(struct ctl_table *table)\n{\n\tpr_warn_once(\"%s wrote to %s when file position was not 0!\\n\"\n\t\t\"this will not be supported in the future. to silence this\\n\"\n\t\t\"warning, set kernel.sysctl_writes_strict = -1\\n\",\n\t\tcurrent->": 4308, "< *min) || (max && val >": 4309, "< *pos && p)\n\t\tp = f_next(m, p, &l);\n\n\treturn p;\n}\n\nstatic void f_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}\n\nstatic const struct seq_operations trace_format_seq_ops = {\n\t.start\t\t= f_start,\n\t.next\t\t= f_next,\n\t.stop\t\t= f_stop,\n\t.show\t\t= f_show,\n};\n\nstatic int trace_format_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &trace_format_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->": 4310, "< *pos; i++) {\n\t\tif (gcov_iter_next(seq->": 4311, "< *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}\n\nstatic void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}\n\nstatic int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = m->": 4312, "< *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))\n\t\treturn -einval;\n\n\tif (tr && (len < *size))\n\t\t*tr = *p;\n\n\t*buf += len;\n\t*size -= len;\n\n\treturn 0;\n}\n\n\nstatic int proc_put_long(void __user **buf, size_t *size, unsigned long val,\n\t\t\t  bool neg)\n{\n\tint len;\n\tchar tmp[tmpbuflen], *p = tmp;\n\n\tsprintf(p, \"%s%lu\", neg ? \"-\" : \"\", val);\n\tlen = strlen(tmp);\n\tif (len >": 4313, "< -1 || val >": 4314, "< -1)\n\t\treturn -ebusy;\n\n\tcalltime = trace_clock_local();\n\n\tindex = ++current->": 4315, "< -1) {\n\t\tcurrent->": 4316, "< -max_bpf_stack || off + access_size >": 4317, "< -max_bpf_stack) {\n\t\t\tverbose(\"invalid stack off=%d size=%d\\n\", off, size);\n\t\t\treturn -eacces;\n\t\t}\n\t\tif (t == bpf_write)\n\t\t\terr = check_stack_write(state, off, size, value_regno);\n\t\telse\n\t\t\terr = check_stack_read(state, off, size, value_regno);\n\t} else {\n\t\tverbose(\"r%d invalid mem access '%s'\\n\",\n\t\t\tregno, reg_type_str[state->": 4318, "< -max_tickadj) {\n\t\ttime_adjust += max_tickadj;\n\t\ttick_length -= max_tickadj_scaled;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * nsec_per_usec / ntp_interval_freq)\n\t\t\t\t\t\t\t << ntp_scale_shift;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}\n\n#ifdef config_generic_cmos_update\nint __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}\n#endif\n\n#if defined(config_generic_cmos_update) || defined(config_rtc_systohc)\nstatic void sync_cmos_clock(struct work_struct *work);\n\nstatic declare_delayed_work(sync_cmos_work, sync_cmos_clock);\n\nstatic void sync_cmos_clock(struct work_struct *work)\n{\n\tstruct timespec64 now;\n\tstruct timespec next;\n\tint fail = 1;\n\n\t\n\tif (!ntp_synced()) {\n\t\t\n\t\treturn;\n\t}\n\n\tgetnstimeofday64(&now);\n\tif (abs(now.tv_nsec - (nsec_per_sec / 2)) <= tick_nsec * 5) {\n\t\tstruct timespec64 adjust = now;\n\n\t\tfail = -enodev;\n\t\tif (persistent_clock_is_local)\n\t\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n#ifdef config_generic_cmos_update\n\t\tfail = update_persistent_clock64(adjust);\n#endif\n\n#ifdef config_rtc_systohc\n\t\tif (fail == -enodev)\n\t\t\tfail = rtc_set_ntp_time(adjust);\n#endif\n\t}\n\n\tnext.tv_nsec = (nsec_per_sec / 2) - now.tv_nsec - (tick_nsec / 2);\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += nsec_per_sec;\n\n\tif (!fail || fail == -enodev)\n\t\tnext.tv_sec = 659;\n\telse\n\t\tnext.tv_sec = 0;\n\n\tif (next.tv_nsec >": 4319, "< -maxfreq * freq_norm.sec)) {\n\t\ttime_status |= sta_ppsjitter;\n\t\t\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(kern_err \"hardpps: ppsjitter: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t\n\n\t\n\tif (freq_norm.sec >": 4320, "< -pps_maxwander) {\n\t\tprintk_deferred(kern_warning\n\t\t\t\t\"hardpps: ppswander: change=%ld\\n\", delta);\n\t\ttime_status |= sta_ppswander;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t\n\t\tpps_inc_freq_interval();\n\t}\n\n\t\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(ntp_scale_shift - shift_usec),\n\t\t\t\tnsec_per_usec) - pps_stabil) >": 4321, "< 0  ? \"h\" : \"\");\n\telse\n\t\tsnprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->": 4322, "< 0 &&\n\t\t   t->": 4323, "< 0 && !can_nice(current, nice))\n\t\treturn -eperm;\n\n\t\n\tif (!capable(cap_sys_admin) && time_before(jiffies, next))\n\t\treturn -eagain;\n\n\tnext = hz / 10 + jiffies;\n\tag = autogroup_task_get(p);\n\n\tdown_write(&ag->": 4324, "< 0 && groupimp < 0)\n\t\t\t\tcontinue;\n\n\t\t\tenv.dist = dist;\n\t\t\tenv.dst_nid = nid;\n\t\t\tupdate_numa_stats(&env.dst_stats, env.dst_nid);\n\t\t\ttask_numa_find_cpu(&env, taskimp, groupimp);\n\t\t}\n\t}\n\n\t\n\tif (p->": 4325, "< 0 && ret != -enosys)\n\t\t\tpr_warn(\"could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}\n\nstatic int\n__register_event(struct ftrace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->": 4326, "< 0 && rrln >": 4327, "< 0 ? 0 : timeout;\n}\nexport_symbol(schedule_timeout);\n\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(task_interruptible);\n\treturn schedule_timeout(timeout);\n}\nexport_symbol(schedule_timeout_interruptible);\n\nsigned long __sched schedule_timeout_killable(signed long timeout)\n{\n\t__set_current_state(task_killable);\n\treturn schedule_timeout(timeout);\n}\nexport_symbol(schedule_timeout_killable);\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(task_uninterruptible);\n\treturn schedule_timeout(timeout);\n}\nexport_symbol(schedule_timeout_uninterruptible);\n\n#ifdef config_hotplug_cpu\nstatic void migrate_timer_list(struct tvec_base *new_base, struct list_head *head)\n{\n\tstruct timer_list *timer;\n\n\twhile (!list_empty(head)) {\n\t\ttimer = list_first_entry(head, struct timer_list, entry);\n\t\t\n\t\tdetach_timer(timer, false);\n\t\ttimer_set_base(timer, new_base);\n\t\tinternal_add_timer(new_base, timer);\n\t}\n}\n\nstatic void migrate_timers(int cpu)\n{\n\tstruct tvec_base *old_base;\n\tstruct tvec_base *new_base;\n\tint i;\n\n\tbug_on(cpu_online(cpu));\n\told_base = per_cpu(tvec_bases, cpu);\n\tnew_base = get_cpu_var(tvec_bases);\n\t\n\tspin_lock_irq(&new_base->": 4328, "< 0 ? err : 0;\n}\n\n\nstatic void audit_receive_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t\n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->": 4329, "< 0 ? ret : 0;\n}\n\nstatic int\nftrace_trace_onoff_callback(struct ftrace_hash *hash,\n\t\t\t    char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\t\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_probe_ops : &traceon_probe_ops;\n\telse\n\t\tops = param ? &traceoff_count_probe_ops : &traceoff_probe_ops;\n\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}\n\nstatic int\nftrace_stacktrace_callback(struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tops = param ? &stacktrace_count_probe_ops : &stacktrace_probe_ops;\n\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}\n\nstatic int\nftrace_dump_callback(struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tops = &dump_probe_ops;\n\n\t\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}\n\nstatic int\nftrace_cpudump_callback(struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tops = &cpudump_probe_ops;\n\n\t\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}\n\nstatic struct ftrace_func_command ftrace_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.func\t\t\t= ftrace_trace_onoff_callback,\n};\n\nstatic struct ftrace_func_command ftrace_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.func\t\t\t= ftrace_trace_onoff_callback,\n};\n\nstatic struct ftrace_func_command ftrace_stacktrace_cmd = {\n\t.name\t\t\t= \"stacktrace\",\n\t.func\t\t\t= ftrace_stacktrace_callback,\n};\n\nstatic struct ftrace_func_command ftrace_dump_cmd = {\n\t.name\t\t\t= \"dump\",\n\t.func\t\t\t= ftrace_dump_callback,\n};\n\nstatic struct ftrace_func_command ftrace_cpudump_cmd = {\n\t.name\t\t\t= \"cpudump\",\n\t.func\t\t\t= ftrace_cpudump_callback,\n};\n\nstatic int __init init_func_cmd_traceon(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&ftrace_traceoff_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ftrace_command(&ftrace_traceon_cmd);\n\tif (ret)\n\t\tgoto out_free_traceoff;\n\n\tret = register_ftrace_command(&ftrace_stacktrace_cmd);\n\tif (ret)\n\t\tgoto out_free_traceon;\n\n\tret = register_ftrace_command(&ftrace_dump_cmd);\n\tif (ret)\n\t\tgoto out_free_stacktrace;\n\n\tret = register_ftrace_command(&ftrace_cpudump_cmd);\n\tif (ret)\n\t\tgoto out_free_dump;\n\n\treturn 0;\n\n out_free_dump:\n\tunregister_ftrace_command(&ftrace_dump_cmd);\n out_free_stacktrace:\n\tunregister_ftrace_command(&ftrace_stacktrace_cmd);\n out_free_traceon:\n\tunregister_ftrace_command(&ftrace_traceon_cmd);\n out_free_traceoff:\n\tunregister_ftrace_command(&ftrace_traceoff_cmd);\n\n\treturn ret;\n}\n#else\nstatic inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}\n#endif \n\nstatic __init int init_function_trace(void)\n{\n\tinit_func_cmd_traceon();\n\treturn register_tracer(&function_trace);\n}\ncore_initcall(init_function_trace);\n\n\n#include <linux/kernel.h>": 4330, "< 0 ? ret : count;\n}\nkernel_attr_rw(kexec_crash_size);\n\nstatic ssize_t vmcoreinfo_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lx %x\\n\",\n\t\t       paddr_vmcoreinfo_note(),\n\t\t       (unsigned int)sizeof(vmcoreinfo_note));\n}\nkernel_attr_ro(vmcoreinfo);\n\n#endif \n\n\nstatic ssize_t fscaps_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", file_caps_enabled);\n}\nkernel_attr_ro(fscaps);\n\nint rcu_expedited;\nstatic ssize_t rcu_expedited_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", rcu_expedited);\n}\nstatic ssize_t rcu_expedited_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tif (kstrtoint(buf, 0, &rcu_expedited))\n\t\treturn -einval;\n\n\treturn count;\n}\nkernel_attr_rw(rcu_expedited);\n\n\nextern const void __start_notes __weak;\nextern const void __stop_notes __weak;\n#define\tnotes_size (&__stop_notes - &__start_notes)\n\nstatic ssize_t notes_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tmemcpy(buf, &__start_notes + off, count);\n\treturn count;\n}\n\nstatic struct bin_attribute notes_attr = {\n\t.attr = {\n\t\t.name = \"notes\",\n\t\t.mode = s_irugo,\n\t},\n\t.read = &notes_read,\n};\n\nstruct kobject *kernel_kobj;\nexport_symbol_gpl(kernel_kobj);\n\nstatic struct attribute * kernel_attrs[] = {\n\t&fscaps_attr.attr,\n\t&uevent_seqnum_attr.attr,\n#ifdef config_uevent_helper\n\t&uevent_helper_attr.attr,\n#endif\n#ifdef config_profiling\n\t&profiling_attr.attr,\n#endif\n#ifdef config_kexec\n\t&kexec_loaded_attr.attr,\n\t&kexec_crash_loaded_attr.attr,\n\t&kexec_crash_size_attr.attr,\n\t&vmcoreinfo_attr.attr,\n#endif\n\t&rcu_expedited_attr.attr,\n\tnull\n};\n\nstatic struct attribute_group kernel_attr_group = {\n\t.attrs = kernel_attrs,\n};\n\nstatic int __init ksysfs_init(void)\n{\n\tint error;\n\n\tkernel_kobj = kobject_create_and_add(\"kernel\", null);\n\tif (!kernel_kobj) {\n\t\terror = -enomem;\n\t\tgoto exit;\n\t}\n\terror = sysfs_create_group(kernel_kobj, &kernel_attr_group);\n\tif (error)\n\t\tgoto kset_exit;\n\n\tif (notes_size >": 4331, "< 0 ? x : y;\n}\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) >": 4332, "< 0 ||\n\t\t    !cpu_online(cpu_file))\n\t\t\treturn kdb_badint;\n\t} else {\n\t\tcpu_file = ring_buffer_all_cpus;\n\t}\n\n\tkdb_trap_printk++;\n\tftrace_dump_buf(skip_lines, cpu_file);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}\n\nstatic __init int kdb_ftrace_register(void)\n{\n\tkdb_register_flags(\"ftdump\", kdb_ftdump, \"[skip_#lines] [cpu]\",\n\t\t\t    \"dump ftrace log\", 0, kdb_enable_always_safe);\n\treturn 0;\n}\n\nlate_initcall(kdb_ftrace_register);\n\n\n#include <linux/types.h>": 4333, "< 0 || !tick_nohz_full_cpu(cpu)],\n\t\t t->": 4334, "< 0 || (delta >": 4335, "< 0 || bp->": 4336, "< 0 || data->": 4337, "< 0 || func_id >": 4338, "< 0 || id >": 4339, "< 0 || len >": 4340, "< 0 || num >": 4341, "< 0 || off + size >": 4342, "< 0 || off >": 4343, "< 0 || size >": 4344, "< 0 || syscall_nr >": 4345, "< 0 || w >": 4346, "< 0)\n\t\t\t\t\terror = -enodev;\n\t\t\t} else {\n\t\t\t\tdata->": 4347, "< 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t\n\tdiag = kdbgetintenv(\"logging\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"logging\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, null, 0, null))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >": 4348, "< 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tcgroup_clear_dir(cgrp, subsys_mask);\n\treturn ret;\n}\n\n\nstatic void css_free_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->": 4349, "< 0)\n\t\t\t\tgoto err_free;\n\t\t} else if (opcode == bpf_ja) {\n\t\t\tif (bpf_src(insns[t].code) != bpf_k) {\n\t\t\t\tret = -einval;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t\n\t\t\tret = push_insn(t, t + insns[t].off + 1,\n\t\t\t\t\tfallthrough, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\t\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->": 4350, "< 0)\n\t\t\t\tgoto err_free;\n\n\t\t\tret = push_insn(t, t + insns[t].off + 1, branch, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t}\n\t} else {\n\t\t\n\t\tret = push_insn(t, t + 1, fallthrough, env);\n\t\tif (ret == 1)\n\t\t\tgoto peek_stack;\n\t\telse if (ret < 0)\n\t\t\tgoto err_free;\n\t}\n\nmark_explored:\n\tinsn_state[t] = explored;\n\tif (cur_stack-- <= 0) {\n\t\tverbose(\"pop stack internal bug\\n\");\n\t\tret = -efault;\n\t\tgoto err_free;\n\t}\n\tgoto peek_stack;\n\ncheck_state:\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != explored) {\n\t\t\tverbose(\"unreachable insn %d\\n\", i);\n\t\t\tret = -einval;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; \n\nerr_free:\n\tkfree(insn_state);\n\tkfree(insn_stack);\n\treturn ret;\n}\n\n\nstatic bool states_equal(struct verifier_state *old, struct verifier_state *cur)\n{\n\tint i;\n\n\tfor (i = 0; i < max_bpf_reg; i++) {\n\t\tif (memcmp(&old->": 4351, "< 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (euid != (uid_t) -1)\n\t\tnew->": 4352, "< 0)\n\t\t\t\tgoto error;\n\t\t}\n\t} else if (!uid_eq(kuid, old->": 4353, "< 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tftrace_warn_on(new_hash->": 4354, "< 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = ret;\n\t\t}\n\t} else if (sscanf(buf, \"%llu\", &value) != 1)\n\t\tgoto out;\n\n\tret = -enxio;\n\n\tp = dev_to_part(dev);\n\tbdev = bdget(part_devt(p));\n\tif (bdev == null)\n\t\tgoto out;\n\n\tq = blk_trace_get_queue(bdev);\n\tif (q == null)\n\t\tgoto out_bdput;\n\n\tmutex_lock(&bdev->": 4355, "< 0)\n\t\t\t\tgoto out_reset;\n\t\t\tif (ret)\n\t\t\t\tgoto out_again;\n\t\t} else {\n\t\t\t\n\t\t\tif (unlikely((cpu_buffer->": 4356, "< 0)\n\t\t\t\tpr_info(\"cannot allocate irq_descs @ irq%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}\nexport_symbol_gpl(irq_domain_add_simple);\n\n\nstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(of_node, first_hwirq + size,\n\t\t\t\t  first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}\nexport_symbol_gpl(irq_domain_add_legacy);\n\n\nstruct irq_domain *irq_find_host(struct device_node *node)\n{\n\tstruct irq_domain *h, *found = null;\n\tint rc;\n\n\t\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->": 4357, "< 0)\n\t\t\t\trestore_unbound_workers_cpumask(pool, cpu);\n\n\t\t\tmutex_unlock(&pool->": 4358, "< 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tcase audit_get_feature:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase audit_set_feature:\n\t\terr = audit_set_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase audit_user:\n\tcase audit_first_user_msg ... audit_last_user_msg:\n\tcase audit_first_user_msg2 ... audit_last_user_msg2:\n\t\tif (!audit_enabled && msg_type != audit_user_avc)\n\t\t\treturn 0;\n\n\t\terr = audit_filter_user(msg_type);\n\t\tif (err == 1) { \n\t\t\terr = 0;\n\t\t\tif (msg_type == audit_user_tty) {\n\t\t\t\terr = tty_audit_push_current();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&audit_cmd_mutex);\n\t\t\taudit_log_common_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != audit_user_tty)\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t audit_message_text_max,\n\t\t\t\t\t\t (char *)data);\n\t\t\telse {\n\t\t\t\tint size;\n\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tsize = nlmsg_len(nlh);\n\t\t\t\tif (size >": 4359, "< 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_backlog_limit) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_backlog_wait_time) {\n\t\t\tif (sizeof(s) >": 4360, "< 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_failure) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_pid) {\n\t\t\tint new_pid = s.pid;\n\n\t\t\tif ((!new_pid) && (task_tgid_vnr(current) != audit_pid))\n\t\t\t\treturn -eacces;\n\t\t\tif (audit_enabled != audit_off)\n\t\t\t\taudit_log_config_change(\"audit_pid\", new_pid, audit_pid, 1);\n\t\t\taudit_pid = new_pid;\n\t\t\taudit_nlk_portid = netlink_cb(skb).portid;\n\t\t\taudit_sock = skb->": 4361, "< 0)\n\t\t\t\tset_user_nice(p, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\trq = task_rq_lock(p, &flags);\n\t\tnormalize_task(rq, p);\n\t\ttask_rq_unlock(rq, p, &flags);\n\t}\n\tread_unlock(&tasklist_lock);\n}\n\n#endif \n\n#if defined(config_ia64) || defined(config_kgdb_kdb)\n\n\n\nstruct task_struct *curr_task(int cpu)\n{\n\treturn cpu_curr(cpu);\n}\n\n#endif \n\n#ifdef config_ia64\n\nvoid set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}\n\n#endif\n\n#ifdef config_cgroup_sched\n\nstatic define_spinlock(task_group_lock);\n\nstatic void free_sched_group(struct task_group *tg)\n{\n\tfree_fair_sched_group(tg);\n\tfree_rt_sched_group(tg);\n\tautogroup_free(tg);\n\tkfree(tg);\n}\n\n\nstruct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kzalloc(sizeof(*tg), gfp_kernel);\n\tif (!tg)\n\t\treturn err_ptr(-enomem);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tfree_sched_group(tg);\n\treturn err_ptr(-enomem);\n}\n\nvoid sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->": 4362, "< 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n\nunsigned int __weak arch_mod_section_prepend(struct module *mod,\n\t\t\t\t\t     unsigned int section)\n{\n\t\n\treturn 0;\n}\n\n\nstatic long get_offset(struct module *mod, unsigned int *size,\n\t\t       elf_shdr *sechdr, unsigned int section)\n{\n\tlong ret;\n\n\t*size += arch_mod_section_prepend(mod, section);\n\tret = align(*size, sechdr->": 4363, "< 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta >": 4364, "< 0)\n\t\t\tgoto done;\n\n\t\tif (!nodes_subset(trialcs->": 4365, "< 0)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(old_tk);\n\t}\n\n\t\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tpr_warning(\"failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tlist_add_tail(&tk->": 4366, "< 0)\n\t\t\tgoto error;\n\t}\n\tif (ruid != (uid_t) -1 ||\n\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->": 4367, "< 0)\n\t\t\tgoto error_put;\n\t}\n\n#ifdef config_keys\n\t\n\tif (new->": 4368, "< 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->": 4369, "< 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->": 4370, "< 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->": 4371, "< 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}\n\nstatic const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\n{\n\tconst struct bin_table *table = &bin_root_table[0];\n\tint ctl_name;\n\n\t\n\tmemcpy(path, \"sys/\", 4);\n\tpath += 4;\n\nrepeat:\n\tif (!nlen)\n\t\treturn err_ptr(-enotdir);\n\tctl_name = *name;\n\tname++;\n\tnlen--;\n\tfor ( ; table->": 4372, "< 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\t\n\t\tresult = -eio;\n\t\tnodep = strchr(buf, '.');\n\t\tif (!nodep)\n\t\t\tgoto out;\n\t\t++nodep;\n\n\t\tarea = simple_strtoul(buf, null, 10);\n\t\tnode = simple_strtoul(nodep, null, 10);\n\n\t\tresult = -eio;\n\t\tif ((area >": 4373, "< 0)\n\t\t\tgoto out;\n\n\t\tcopied = result;\n\t\tlastp = oldval + copied - 1;\n\n\t\tresult = -efault;\n\t\tif (get_user(ch, lastp))\n\t\t\tgoto out;\n\n\t\t\n\t\tif (ch == '\\n') {\n\t\t\tresult = -efault;\n\t\t\tif (put_user('\\0', lastp))\n\t\t\t\tgoto out;\n\t\t\tcopied -= 1;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tloff_t pos = 0;\n\n\t\tresult = vfs_write(file, newval, newlen, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}\n\nstatic ssize_t bin_intvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -enomem;\n\tbuffer = kmalloc(bufsz, gfp_kernel);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tresult = kernel_read(file, 0, buffer, bufsz - 1);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -efault;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tstr = buffer;\n\t\tend = str + bufsz;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -efault;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, 0);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}\n\nstatic ssize_t bin_ulongvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -enomem;\n\tbuffer = kmalloc(bufsz, gfp_kernel);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned long __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tresult = kernel_read(file, 0, buffer, bufsz - 1);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -efault;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned long __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tstr = buffer;\n\t\tend = str + bufsz;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -efault;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, 0);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}\n\nstatic ssize_t bin_uuid(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\t\n\tif (oldval && oldlen) {\n\t\tchar buf[40], *str = buf;\n\t\tunsigned char uuid[16];\n\t\tint i;\n\n\t\tresult = kernel_read(file, 0, buf, sizeof(buf) - 1);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\t\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tresult = -eio;\n\t\t\tif (!isxdigit(str[0]) || !isxdigit(str[1]))\n\t\t\t\tgoto out;\n\n\t\t\tuuid[i] = (hex_to_bin(str[0]) << 4) |\n\t\t\t\t\thex_to_bin(str[1]);\n\t\t\tstr += 2;\n\t\t\tif (*str == '-')\n\t\t\t\tstr++;\n\t\t}\n\n\t\tif (oldlen >": 4374, "< 0)\n\t\t\tjps[i]->": 4375, "< 0)\n\t\t\tn = n->": 4376, "< 0)\n\t\t\tnode = &(*node)->": 4377, "< 0)\n\t\t\tp = &parent->": 4378, "< 0)\n\t\t\tp->": 4379, "< 0)\n\t\t\tposix_cpu_timer_schedule(timr);\n\t\telse\n\t\t\tschedule_next_timer(timr);\n\n\t\tinfo->": 4380, "< 0)\n\t\t\tpr_warn(\"could not create directory for event %s\\n\",\n\t\t\t\tftrace_event_name(call));\n\t}\n}\n\nstruct ftrace_event_file *\nfind_event_file(struct trace_array *tr, const char *system,  const char *event)\n{\n\tstruct ftrace_event_file *file;\n\tstruct ftrace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->": 4381, "< 0)\n\t\t\tpr_warn(\"could not create directory for event %s\\n\",\n\t\t\t\tftrace_event_name(file->": 4382, "< 0)\n\t\t\tpr_warn(\"could not create early event %s\\n\",\n\t\t\t\tftrace_event_name(call));\n\t}\n}\n\n\nstatic void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct ftrace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->": 4383, "< 0)\n\t\t\treturn -efault;\n\t\tset_task_comm(me, comm);\n\t\tproc_comm_connector(me);\n\t\tbreak;\n\tcase pr_get_name:\n\t\tget_task_comm(comm, me);\n\t\tif (copy_to_user((char __user *)arg2, comm, sizeof(comm)))\n\t\t\treturn -efault;\n\t\tbreak;\n\tcase pr_get_endian:\n\t\terror = get_endian(me, arg2);\n\t\tbreak;\n\tcase pr_set_endian:\n\t\terror = set_endian(me, arg2);\n\t\tbreak;\n\tcase pr_get_seccomp:\n\t\terror = prctl_get_seccomp();\n\t\tbreak;\n\tcase pr_set_seccomp:\n\t\terror = prctl_set_seccomp(arg2, (char __user *)arg3);\n\t\tbreak;\n\tcase pr_get_tsc:\n\t\terror = get_tsc_ctl(arg2);\n\t\tbreak;\n\tcase pr_set_tsc:\n\t\terror = set_tsc_ctl(arg2);\n\t\tbreak;\n\tcase pr_task_perf_events_disable:\n\t\terror = perf_event_task_disable();\n\t\tbreak;\n\tcase pr_task_perf_events_enable:\n\t\terror = perf_event_task_enable();\n\t\tbreak;\n\tcase pr_get_timerslack:\n\t\terror = current->": 4384, "< 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(env);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (log_level) {\n\t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(insn);\n\t\t}\n\n\t\tif (class == bpf_alu || class == bpf_alu64) {\n\t\t\terr = check_alu_op(regs, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == bpf_ldx) {\n\t\t\tenum bpf_reg_type src_reg_type;\n\n\t\t\t\n\n\t\t\t\n\t\t\terr = check_reg_arg(regs, insn->": 4385, "< 0)\n\t\t\treturn ret;\n\t\toff += ret;\n\t}\n\tbuffer[off] = '\\0';\n\treturn off;\n}\n\nstatic void param_array_free(void *arg)\n{\n\tunsigned int i;\n\tconst struct kparam_array *arr = arg;\n\n\tif (arr->": 4386, "< 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn traceprobe_probes_write(file, buffer, count, ppos,\n\t\t\tcreate_trace_kprobe);\n}\n\nstatic const struct file_operations kprobe_events_ops = {\n\t.owner          = this_module,\n\t.open           = probes_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= probes_write,\n};\n\n\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_kprobe *tk = v;\n\n\tseq_printf(m, \"  %-44s %15lu %15lu\\n\",\n\t\t   ftrace_event_name(&tk->": 4387, "< 0)\n\t\t\treturn ret;\n\n\t\ttr->": 4388, "< 0)\n\t\t\treturn retval;\n\n\t\tif (!cpumask_subset(trialcs->": 4389, "< 0)\n\t\t\trps[i]->": 4390, "< 0)\n\t\t\tsig->": 4391, "< 0)\n\t\t\tstate = pm_suspend_freeze;\n\t}\n\tif (state == pm_suspend_freeze) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t\n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}\n\nstatic int __init has_wakealarm(struct device *dev, const void *data)\n{\n\tstruct rtc_device *candidate = to_rtc_device(dev);\n\n\tif (!candidate->": 4392, "< 0)\n\t\t\ttk->": 4393, "< 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tbug_on(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->": 4394, "< 0)\n\t\t\n\t\tgoto free_map;\n\n\treturn err;\n\nfree_map:\n\tmap->": 4395, "< 0)\n\t\t*jitter = -*jitter;\n\n\t\n\treturn pps_tf[0];\n}\n\n\nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}\n\n\nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -pps_intcount) {\n\t\tpps_intcnt = -pps_intcount;\n\t\tif (pps_shift >": 4396, "< 0)\n\t\tbug();\n\tnh->": 4397, "< 0)\n\t\tbug();\n\tsched_init_granularity();\n\tfree_cpumask_var(non_isolated_cpus);\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n}\n#else\nvoid __init sched_init_smp(void)\n{\n\tsched_init_granularity();\n}\n#endif \n\nconst_debug unsigned int sysctl_timer_migration = 1;\n\nint in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >": 4398, "< 0)\n\t\td = -d;\n\n\tif (d >": 4399, "< 0)\n\t\tgoto bad_fork_free;\n\n\t\n\tretval = -eagain;\n\tif (nr_threads >": 4400, "< 0)\n\t\tgoto bug_cleanup;\n\n\t\n\tfree_copy(info);\n\n\t\n\ttrace_module_load(mod);\n\n\treturn do_init_module(mod);\n\n bug_cleanup:\n\t\n\tmutex_lock(&module_mutex);\n\tmodule_bug_cleanup(mod);\n\tmutex_unlock(&module_mutex);\n\n\t\n\tunset_module_init_ro_nx(mod);\n\tunset_module_core_ro_nx(mod);\n\n ddebug_cleanup:\n\tdynamic_debug_remove(info->": 4401, "< 0)\n\t\tgoto done;\n\n\tspin_lock_irq(&callback_lock);\n\tcs->": 4402, "< 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, taskstats_cmd_new, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -einval;\n\ttgid = nla_get_u32(info->": 4403, "< 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->": 4404, "< 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, cgroupstats_type_cgroup_stats,\n\t\t\t\tsizeof(struct cgroupstats));\n\tif (na == null) {\n\t\tnlmsg_free(rep_skb);\n\t\trc = -emsgsize;\n\t\tgoto err;\n\t}\n\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, f.file->": 4405, "< 0)\n\t\tgoto err_free_percpu_ref;\n\tcss->": 4406, "< 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\tsetup_timer(&pd->": 4407, "< 0)\n\t\tgoto err_free_wq;\n\n\t\n\tif (flags & wq_mem_reclaim) {\n\t\tstruct worker *rescuer;\n\n\t\trescuer = alloc_worker(numa_no_node);\n\t\tif (!rescuer)\n\t\t\tgoto err_destroy;\n\n\t\trescuer->": 4408, "< 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn null;\n}\nexport_symbol(prepare_creds);\n\n\nstruct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef config_keys\n\t\n\tkey_put(new->": 4409, "< 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn null;\n}\nexport_symbol(prepare_kernel_cred);\n\n\nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}\nexport_symbol(set_security_override);\n\n\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}\nexport_symbol(set_security_override_from_ctx);\n\n\nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tnew->": 4410, "< 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n\n\nsyscall_define3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid, ksuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\tksuid = make_kuid(ns, suid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -einval;\n\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -einval;\n\n\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))\n\t\treturn -einval;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\n\told = current_cred();\n\n\tretval = -eperm;\n\tif (!ns_capable(old->": 4411, "< 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n\nsyscall_define1(setuid, uid_t, uid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kuid;\n\n\tkuid = make_kuid(ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn -einval;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\told = current_cred();\n\n\tretval = -eperm;\n\tif (ns_capable(old->": 4412, "< 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nsyscall_define3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tuid_t ruid, euid, suid;\n\n\truid = from_kuid_munged(cred->": 4413, "< 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn null;\n}\n\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, gfp_kernel);\n\tif (!new)\n\t\treturn null;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->": 4414, "< 0)\n\t\tgoto error_free_pks;\n\n\tret = verify_signature(key, pks);\n\tpr_devel(\"verify_signature() = %d\\n\", ret);\n\nerror_free_pks:\n\tmpi_free(pks->": 4415, "< 0)\n\t\tgoto errout;\n\n\tif (event->": 4416, "< 0)\n\t\tgoto fail;\n\n\t\n\tif (!create_worker(pool))\n\t\tgoto fail;\n\n\t\n\thash_add(unbound_pool_hash, &pool->": 4417, "< 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->": 4418, "< 0)\n\t\tgoto fail;\n\n\tworker = alloc_worker(pool->": 4419, "< 0)\n\t\tgoto fail_free_reader;\n\n\tcpu_buffer->": 4420, "< 0)\n\t\tgoto free_modinfo;\n\n\terr = apply_relocations(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\terr = post_relocation(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\tflush_module_icache(mod);\n\n\t\n\tmod->": 4421, "< 0)\n\t\tgoto free_prog;\n\n\t\n\terr = bpf_check(&prog, attr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\t\n\tfixup_bpf_calls(prog);\n\n\t\n\tbpf_prog_select_runtime(prog);\n\n\terr = anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog, o_rdwr | o_cloexec);\n\tif (err < 0)\n\t\t\n\t\tgoto free_used_maps;\n\n\treturn err;\n\nfree_used_maps:\n\tfree_used_maps(prog->": 4422, "< 0)\n\t\tgoto out;\n\trc = add_del_listener(info->": 4423, "< 0)\n\t\tgoto out;\n\troot_cgrp->": 4424, "< 0)\n\t\tgoto out;\n\n\t\n\tmodule_bug_finalize(info->": 4425, "< 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->": 4426, "< 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->": 4427, "< 0)\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->": 4428, "< 0)\n\t\tgoto out;\n\n\ttype->": 4429, "< 0)\n\t\tgoto out;\n\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = kimage_alloc_page(image, gfp_highuser, maddr);\n\t\tif (!page) {\n\t\t\tresult  = -enomem;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = kimage_add_page(image, page_to_pfn(page)\n\t\t\t\t\t\t\t\t<< page_shift);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tptr = kmap(page);\n\t\t\n\t\tclear_page(ptr);\n\t\tptr += maddr & ~page_mask;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tpage_size - (maddr & ~page_mask));\n\t\tuchunk = min(ubytes, mchunk);\n\n\t\t\n\t\tif (image->": 4430, "< 0)\n\t\tgoto out_disable;\n\t\n\tret = 0;\n out:\n\treturn ret;\n\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\tmodule_put(event_enable_file->": 4431, "< 0)\n\t\tgoto out_free;\n\tret = 0;\n out:\n\treturn ret;\n\n out_free:\n\tif (cmd_ops->": 4432, "< 0)\n\t\tgoto out_free;\n\n out_reg:\n\t\n\tret = try_module_get(event_enable_file->": 4433, "< 0)\n\t\tgoto out_free;\n\n out_reg:\n\tret = cmd_ops->": 4434, "< 0)\n\t\tgoto out_free_sha_regions;\n\n\tdigest = kzalloc(sha256_digest_size, gfp_kernel);\n\tif (!digest) {\n\t\tret = -enomem;\n\t\tgoto out_free_sha_regions;\n\t}\n\n\tfor (j = i = 0; i < image->": 4435, "< 0)\n\t\tgoto out_put;\n\tret = cmd_ops->": 4436, "< 0)\n\t\tgoto out_put;\n\tret = register_ftrace_function_probe(glob, ops, data);\n\t\n\tif (!ret) {\n\t\tret = -enoent;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n\n out_disable:\n\t__ftrace_event_enable_disable(file, 0, 1);\n out_put:\n\tmodule_put(file->": 4437, "< 0)\n\t\tgoto out_put_task_struct;\n\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != ptrace_detach)\n\t\tptrace_unfreeze_traced(child);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}\n\nint generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = access_process_vm(tsk, addr, &tmp, sizeof(tmp), 0);\n\tif (copied != sizeof(tmp))\n\t\treturn -eio;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}\n\nint generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = access_process_vm(tsk, addr, &data, sizeof(data), 1);\n\treturn (copied == sizeof(data)) ? 0 : -eio;\n}\n\n#if defined config_compat\n\nint compat_ptrace_request(struct task_struct *child, compat_long_t request,\n\t\t\t  compat_ulong_t addr, compat_ulong_t data)\n{\n\tcompat_ulong_t __user *datap = compat_ptr(data);\n\tcompat_ulong_t word;\n\tsiginfo_t siginfo;\n\tint ret;\n\n\tswitch (request) {\n\tcase ptrace_peektext:\n\tcase ptrace_peekdata:\n\t\tret = access_process_vm(child, addr, &word, sizeof(word), 0);\n\t\tif (ret != sizeof(word))\n\t\t\tret = -eio;\n\t\telse\n\t\t\tret = put_user(word, datap);\n\t\tbreak;\n\n\tcase ptrace_poketext:\n\tcase ptrace_pokedata:\n\t\tret = access_process_vm(child, addr, &data, sizeof(data), 1);\n\t\tret = (ret != sizeof(data) ? -eio : 0);\n\t\tbreak;\n\n\tcase ptrace_geteventmsg:\n\t\tret = put_user((compat_ulong_t) child->": 4438, "< 0)\n\t\tgoto skip_full_check;\n\n\tenv->": 4439, "< 0)\n\t\tgoto skip_full_check;\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, null) >": 4440, "< 0)\n\t\tgoto use_default;\n\n\t\n\tif (current_clr_polling_and_test()) {\n\t\tdev->": 4441, "< 0)\n\t\tindex += ftrace_notrace_depth;\n\n\tif (unlikely(index < 0 || index >": 4442, "< 0)\n\t\tmin_vruntime = vruntime;\n\n\treturn min_vruntime;\n}\n\nstatic inline int entity_before(struct sched_entity *a,\n\t\t\t\tstruct sched_entity *b)\n{\n\treturn (s64)(a->": 4443, "< 0)\n\t\tnow = trace_clock_struct.prev_time + 1;\n\n\ttrace_clock_struct.prev_time = now;\n\n\tarch_spin_unlock(&trace_clock_struct.lock);\n\n out:\n\tlocal_irq_restore(flags);\n\n\treturn now;\n}\n\nstatic atomic64_t trace_counter;\n\n\nu64 notrace trace_clock_counter(void)\n{\n\treturn atomic64_add_return(1, &trace_counter);\n}\n\n#include <linux/kernel.h>": 4444, "< 0)\n\t\tquota = runtime_inf;\n\telse\n\t\tquota = (u64)cfs_quota_us * nsec_per_usec;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}\n\nlong tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->": 4445, "< 0)\n\t\trcu_unexpedite_gp();\n\twarn_on_once(can_expedite && rcu_gp_is_expedited());\n\trcu_torture_writer_state = rtws_stopping;\n\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\treturn 0;\n}\n\n\nstatic int\nrcu_torture_fakewriter(void *arg)\n{\n\tdefine_torture_random(rand);\n\n\tverbose_torout_string(\"rcu_torture_fakewriter task started\");\n\tset_user_nice(current, max_nice);\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1 + torture_random(&rand)%10);\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\tif (cur_ops->": 4446, "< 0)\n\t\treturn (id & clockfd_mask) == clockfd ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\n\tif (id >": 4447, "< 0)\n\t\treturn -1;  \n\n\treturn 0;\n}\n#endif \n\nlong prctl_get_seccomp(void)\n{\n\treturn current->": 4448, "< 0)\n\t\treturn -efault;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->": 4449, "< 0)\n\t\treturn -efault;\n\tname[module_name_len-1] = '\\0';\n\n\tif (mutex_lock_interruptible(&module_mutex) != 0)\n\t\treturn -eintr;\n\n\tmod = find_module(name);\n\tif (!mod) {\n\t\tret = -enoent;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&mod->": 4450, "< 0)\n\t\treturn -einval;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->": 4451, "< 0)\n\t\treturn -einval;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -efault;\n\n\trcu_read_lock();\n\tretval = -esrch;\n\tp = find_process_by_pid(pid);\n\tif (p != null)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n\nstatic int sched_copy_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(verify_write, uattr, sched_attr_size_ver0))\n\t\treturn -efault;\n\n\t\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->": 4452, "< 0)\n\t\treturn -einval;\n\trcu_read_lock();\n\n\t\n\twrite_lock_irq(&tasklist_lock);\n\n\terr = -esrch;\n\tp = find_task_by_vpid(pid);\n\tif (!p)\n\t\tgoto out;\n\n\terr = -einval;\n\tif (!thread_group_leader(p))\n\t\tgoto out;\n\n\tif (same_thread_group(p->": 4453, "< 0)\n\t\treturn -einval;\n\n\tcgrp = cgroup_kn_lock_live(of->": 4454, "< 0)\n\t\treturn -einval;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\ttask_uninterruptible);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}\nexport_symbol_gpl(usermodehelper_read_lock_wait);\n\nvoid usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}\nexport_symbol_gpl(usermodehelper_read_unlock);\n\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}\n\n\nint __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -einval;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\trunning_helpers_timeout);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(umh_enabled);\n\treturn -eagain;\n}\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}\n\n\nstruct subprocess_info *call_usermodehelper_setup(char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tinit_work(&sub_info->": 4455, "< 0)\n\t\treturn -einval;\n\n\ti = cred->": 4456, "< 0)\n\t\treturn -einval;\n\n\tif (arg.flags & ptrace_peeksiginfo_shared)\n\t\tpending = &child->": 4457, "< 0)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -esrch;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tif (task_has_rt_policy(p))\n\t\tlp.sched_priority = p->": 4458, "< 0)\n\t\treturn -einval;\n\n\tret = cap_get_target_pid(pid, &pe, &pi, &pp);\n\tif (!ret) {\n\t\tstruct __user_cap_data_struct kdata[_kernel_capability_u32s];\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < tocopy; i++) {\n\t\t\tkdata[i].effective = pe.cap[i];\n\t\t\tkdata[i].permitted = pp.cap[i];\n\t\t\tkdata[i].inheritable = pi.cap[i];\n\t\t}\n\n\t\t\n\t\tif (copy_to_user(dataptr, kdata, tocopy\n\t\t\t\t * sizeof(struct __user_cap_data_struct))) {\n\t\t\treturn -efault;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nsyscall_define2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[_kernel_capability_u32s];\n\tunsigned i, tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->": 4459, "< 0)\n\t\treturn -einval;\n\n\treturn do_sched_setscheduler(pid, policy, param);\n}\n\n\nsyscall_define2(sched_setparam, pid_t, pid, struct sched_param __user *, param)\n{\n\treturn do_sched_setscheduler(pid, setparam_policy, param);\n}\n\n\nsyscall_define3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -einval;\n\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tretval = -esrch;\n\tp = find_process_by_pid(pid);\n\tif (p != null)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n\nsyscall_define1(sched_getscheduler, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -einval;\n\n\tretval = -esrch;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (p) {\n\t\tretval = security_task_getscheduler(p);\n\t\tif (!retval)\n\t\t\tretval = p->": 4460, "< 0)\n\t\treturn -einval;\n\n\tretval = -esrch;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &flags);\n\ttime_slice = 0;\n\tif (p->": 4461, "< 0)\n\t\treturn -enodev;\n\n\t\n\tdir = kzalloc(sizeof(*dir), gfp_kernel);\n\tif (!dir) {\n\t\ttrace_array_put(tr);\n\t\treturn -enomem;\n\t}\n\n\tdir->": 4462, "< 0)\n\t\treturn -enodev;\n\n\tif ((file->": 4463, "< 0)\n\t\treturn -enomem;\n\tret = register_ftrace_event(&call->": 4464, "< 0)\n\t\treturn -enomem;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}\n\nstruct trace_event_functions enter_syscall_print_funcs = {\n\t.trace\t\t= print_syscall_enter,\n};\n\nstruct trace_event_functions exit_syscall_print_funcs = {\n\t.trace\t\t= print_syscall_exit,\n};\n\nstruct ftrace_event_class __refdata event_class_syscall_enter = {\n\t.system\t\t= \"syscalls\",\n\t.reg\t\t= syscall_enter_register,\n\t.define_fields\t= syscall_enter_define_fields,\n\t.get_fields\t= syscall_get_enter_fields,\n\t.raw_init\t= init_syscall_trace,\n};\n\nstruct ftrace_event_class __refdata event_class_syscall_exit = {\n\t.system\t\t= \"syscalls\",\n\t.reg\t\t= syscall_exit_register,\n\t.define_fields\t= syscall_exit_define_fields,\n\t.fields\t\t= list_head_init(event_class_syscall_exit.fields),\n\t.raw_init\t= init_syscall_trace,\n};\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}\n\nvoid __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\n\tsyscalls_metadata = kcalloc(nr_syscalls, sizeof(*syscalls_metadata),\n\t\t\t\t    gfp_kernel);\n\tif (!syscalls_metadata) {\n\t\twarn_on(1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->": 4465, "< 0)\n\t\treturn -enomem;\n\n\tret = register_ftrace_event(&call->": 4466, "< 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->": 4467, "< 0)\n\t\treturn 0;\n\ttracing_thresh = threshold * 1000;\n\treturn 1;\n}\n__setup(\"tracing_thresh=\", set_tracing_thresh);\n\nunsigned long nsecs_to_usecs(unsigned long nsecs)\n{\n\treturn nsecs / 1000;\n}\n\n\nstatic const char *trace_options[] = {\n\t\"print-parent\",\n\t\"sym-offset\",\n\t\"sym-addr\",\n\t\"verbose\",\n\t\"raw\",\n\t\"hex\",\n\t\"bin\",\n\t\"block\",\n\t\"stacktrace\",\n\t\"trace_printk\",\n\t\"ftrace_preempt\",\n\t\"branch\",\n\t\"annotate\",\n\t\"userstacktrace\",\n\t\"sym-userobj\",\n\t\"printk-msg-only\",\n\t\"context-info\",\n\t\"latency-format\",\n\t\"sleep-time\",\n\t\"graph-time\",\n\t\"record-cmd\",\n\t\"overwrite\",\n\t\"disable_on_free\",\n\t\"irq-info\",\n\t\"markers\",\n\t\"function-trace\",\n\tnull\n};\n\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\tarch_trace_clocks\n};\n\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->": 4468, "< 0)\n\t\treturn 0;\n\n\tfor (i = irq; cnt >": 4469, "< 0)\n\t\treturn 0;\n\n\tif (unlikely(delta.tv64 >": 4470, "< 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (kdb_flag(cmd_interrupt))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}\n#endif \n\n\nstatic atomic_t kdb_nmi_disabled;\n\nstatic int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}\n\nstatic int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -einval;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops kdb_param_ops_enable_nmi = {\n\t.set = kdb_param_enable_nmi,\n};\nmodule_param_cb(enable_nmi, &kdb_param_ops_enable_nmi, null, 0600);\n\n\nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < nr_cpus; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'f';\t\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'd';\t\n\t\t} else {\n\t\t\tstate = ' ';\t\n\t\t\tif (kdb_task_state_char(kdb_tsk(i)) == 'i')\n\t\t\t\tstate = 'i';\t\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t\n\tif (prev_state != 'f') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}\n\nstatic int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn kdb_argcount;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t\n\tif ((cpunum >": 4471, "< 0)\n\t\treturn __copy_to_user(to, from, sizeof(siginfo_t))\n\t\t\t? -efault : 0;\n\t\n\terr = __put_user(from->": 4472, "< 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}\n#endif\n#endif\n\n\nint sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long flags;\n\tint cpu = get_cpu();\n\n\t__sched_fork(clone_flags, p);\n\t\n\tp->": 4473, "< 0)\n\t\treturn err;\n\n\t\n\tfor (i = 0; i < _kernel_capability_u32s; i++)\n\t\tnew_cap.cap[i] = cap_array[i];\n\n\t\n\tspin_lock(&umh_sysctl_lock);\n\tif (write) {\n\t\tif (table->": 4474, "< 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic list_head(event_subsystems);\n\nstatic int subsystem_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_subsystem *system = null;\n\tstruct ftrace_subsystem_dir *dir = null; \n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -enodev;\n\n\t\n\tmutex_lock(&trace_types_lock);\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tlist_for_each_entry(dir, &tr->": 4475, "< 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint (*func)(struct trace_seq *s) = filp->": 4476, "< 0)\n\t\treturn err;\n\n\tcpu_notify(cpu_dying | param->": 4477, "< 0)\n\t\treturn err;\n\n\tif (!alloc_cpumask_var(&cpus_attach, gfp_kernel))\n\t\tbug();\n\n\treturn 0;\n}\n\n\nstatic void remove_tasks_in_empty_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *parent;\n\n\t\n\tparent = parent_cs(cs);\n\twhile (cpumask_empty(parent->": 4478, "< 0)\n\t\treturn err;\n\n\tif (write) {\n\t\t\n\t\tint i;\n\t\tfor (i = 0; i < bits_per_long && tmptaint >": 4479, "< 0)\n\t\treturn err_ptr(err);\n\n\t\n\tinfo->": 4480, "< 0)\n\t\treturn id;\n\n\troot->": 4481, "< 0)\n\t\treturn null;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[*rctxp]);\n\traw_data = this_cpu_ptr(perf_trace_buf[*rctxp]);\n\n\t\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\n\tentry = (struct trace_entry *)raw_data;\n\tlocal_save_flags(flags);\n\ttracing_generic_entry_update(entry, flags, pc);\n\tentry->": 4482, "< 0)\n\t\treturn null;\n\n\treturn syscalls_metadata[nr];\n}\n\nstatic enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->": 4483, "< 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, irqclass);\n}\n\n\nstatic int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = null;\n\troot.class = hlock_class(this);\n\tret = find_usage_backwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, irqclass);\n}\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->": 4484, "< 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\tthat.parent = null;\n\tthat.class = hlock_class(next);\n\tret = find_usage_forwards(&that, bit_forwards, &target_entry1);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_bad_irq_dependency(curr, &this, &that,\n\t\t\ttarget_entry, target_entry1,\n\t\t\tprev, next,\n\t\t\tbit_backwards, bit_forwards, irqclass);\n}\n\nstatic const char *state_names[] = {\n#define lockdep_state(__state) \\\n\t__stringify(__state),\n#include \"lockdep_states.h\"\n#undef lockdep_state\n};\n\nstatic const char *state_rnames[] = {\n#define lockdep_state(__state) \\\n\t__stringify(__state)\"-read\",\n#include \"lockdep_states.h\"\n#undef lockdep_state\n};\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >": 4485, "< 0)\n\t\treturn rc;\n\n\trc = -einval;\n\tpid = nla_get_u32(info->": 4486, "< 0)\n\t\treturn res;\n\n\troot_swap = res;\n\tres = blkdev_get(hib_resume_bdev, fmode_write, null);\n\tif (res)\n\t\treturn res;\n\n\tres = set_blocksize(hib_resume_bdev, page_size);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, fmode_write);\n\n\treturn res;\n}\n\n\n\nstatic int write_page(void *buf, sector_t offset, struct bio **bio_chain)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -enospc;\n\n\tif (bio_chain) {\n\t\tsrc = (void *)__get_free_page(__gfp_wait | __gfp_nowarn |\n\t\t                              __gfp_noretry);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_on_bio_chain(bio_chain); \n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(__gfp_wait |\n\t\t\t                              __gfp_nowarn |\n\t\t\t                              __gfp_noretry);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\twarn_on_once(1);\n\t\t\t\tbio_chain = null;\t\n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_bio_write_page(offset, src, bio_chain);\n}\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->": 4487, "< 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, uprobe_swbp_insn_size);\n\tput_page(page);\n out:\n\t\n\treturn is_trap_insn(&opcode);\n}\n\nstatic struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->": 4488, "< 0)\n\t\treturn ret;\n\tm = file->": 4489, "< 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = ops->": 4490, "< 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}\n\nstatic void ftrace_update_pid_func(void)\n{\n\t\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tupdate_ftrace_function();\n}\n\n#ifdef config_function_profiler\nstruct ftrace_profile {\n\tstruct hlist_node\t\tnode;\n\tunsigned long\t\t\tip;\n\tunsigned long\t\t\tcounter;\n#ifdef config_function_graph_tracer\n\tunsigned long long\t\ttime;\n\tunsigned long long\t\ttime_squared;\n#endif\n};\n\nstruct ftrace_profile_page {\n\tstruct ftrace_profile_page\t*next;\n\tunsigned long\t\t\tindex;\n\tstruct ftrace_profile\t\trecords[];\n};\n\nstruct ftrace_profile_stat {\n\tatomic_t\t\t\tdisabled;\n\tstruct hlist_head\t\t*hash;\n\tstruct ftrace_profile_page\t*pages;\n\tstruct ftrace_profile_page\t*start;\n\tstruct tracer_stat\t\tstat;\n};\n\n#define profile_records_size\t\t\t\t\t\t\\\n\t(page_size - offsetof(struct ftrace_profile_page, records))\n\n#define profiles_per_page\t\t\t\t\t\\\n\t(profile_records_size / sizeof(struct ftrace_profile))\n\nstatic int ftrace_profile_enabled __read_mostly;\n\n\nstatic define_mutex(ftrace_profile_lock);\n\nstatic define_per_cpu(struct ftrace_profile_stat, ftrace_profile_stats);\n\n#define ftrace_profile_hash_bits 10\n#define ftrace_profile_hash_size (1 << ftrace_profile_hash_bits)\n\nstatic void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & page_mask);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >": 4491, "< 0)\n\t\treturn ret;\n\n\tif (trace_parser_get_init(&parser, event_buf_size + 1))\n\t\treturn -enomem;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >": 4492, "< 0)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -einval;\n\n\t\n\tif (system)\n\t\tname = system->": 4493, "< 0)\n\t\treturn ret;\n\n\tret = -enodev;\n\tmutex_lock(&clockevents_mutex);\n\traw_spin_lock_irq(&clockevents_lock);\n\tlist_for_each_entry(ce, &clockevent_devices, list) {\n\t\tif (!strcmp(ce->": 4494, "< 0)\n\t\treturn ret;\n\n\tret = ftrace_pid_add(val);\n\n\treturn ret ? ret : cnt;\n}\n\nstatic int\nftrace_pid_release(struct inode *inode, struct file *file)\n{\n\tif (file->": 4495, "< 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tret = -enodev;\n\t\tmutex_lock(&event_mutex);\n\t\tfile = event_file_data(filp);\n\t\tif (likely(file))\n\t\t\tret = ftrace_event_enable_disable(file, val);\n\t\tmutex_unlock(&event_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\t*ppos += cnt;\n\n\treturn ret ? ret : cnt;\n}\n\nstatic ssize_t\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tconst char set_to_char[4] = { '?', '0', '1', 'x' };\n\tstruct ftrace_subsystem_dir *dir = filp->": 4496, "< 0)\n\t\treturn retry_task;\n\n\tif (new_tasks >": 4497, "< 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\n\n\nvoid perf_event_wakeup(struct perf_event *event)\n{\n\tring_buffer_wakeup(event);\n\n\tif (event->": 4498, "< 0)\n\t\treturn retval;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->": 4499, "< 0)\n\t\treturn size;\n\n\tif (off % size != 0) {\n\t\tverbose(\"misaligned access off %d size %d\\n\", off, size);\n\t\treturn -eacces;\n\t}\n\n\tif (state->": 4500, "< 0)\n\t\treturn timer_retry;\n\treturn 0;\n}\n\nstatic inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tstruct k_clock *kc = clockid_to_kclock(timer->": 4501, "< 0)\n\t\treturn timer_retry;\n\n\t\n\ttimr->": 4502, "< 0)\n\t\treturn timer_retry;\n\n\treturn 0;\n}\n\n\nstatic int alarm_timer_set(struct k_itimer *timr, int flags,\n\t\t\t\tstruct itimerspec *new_setting,\n\t\t\t\tstruct itimerspec *old_setting)\n{\n\tktime_t exp;\n\n\tif (!rtcdev)\n\t\treturn -enotsupp;\n\n\tif (flags & ~timer_abstime)\n\t\treturn -einval;\n\n\tif (old_setting)\n\t\talarm_timer_get(timr, old_setting);\n\n\t\n\tif (alarm_try_to_cancel(&timr->": 4503, "< 0)\n\t\treturn timer_retry;\n\n\ttimr->": 4504, "< 0)\n\t\treturn;\n\trq->": 4505, "< 0)\n\t\treturn;\n\n\t\n\tif (op->": 4506, "< 0)\n\t\treturn;\n\n\t\n\tpreempt_disable_notrace();\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (ftrace_warn_on(!op->": 4507, "< 0)\n\t\treturn;\n\n\t\n\n\tif (cfs_rq->": 4508, "< 0)\n\t\treturn;\n\n\tif (delta >": 4509, "< 0)\n\t\treturn;\n\n\top->": 4510, "< 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, taskstats_type_pid,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, taskstats_type_tgid,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->": 4511, "< 0)\n\t\trt_runtime = runtime_inf;\n\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}\n\nstatic long sched_group_rt_runtime(struct task_group *tg)\n{\n\tu64 rt_runtime_us;\n\n\tif (tg->": 4512, "< 0)\n\t\tseq_printf(m, \"<%p>": 4513, "< 0)\n\t\tseq_printf(m, \"<%pk>": 4514, "< 0)\n\t\tseq_printf(m, \"broadcast device\\n\");\n\telse\n\t\tseq_printf(m, \"per cpu device: %d\\n\", cpu);\n\n\tseq_printf(m, \"clock event device: \");\n\tif (!dev) {\n\t\tseq_printf(m, \"<null>": 4515, "< 0)\n\t\tseq_puts(m, \"  x \");\n\telse\n\t\tseq_printf(m, \"%3ld \", percent);\n\tseq_printf(m, \"%-30.30s %-20.20s %d\\n\", p->": 4516, "< 0)\n\t\tstutter = 0;\n\tif (stutter) {\n\t\tfirsterr = torture_stutter_init(stutter * hz);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (fqs_duration < 0)\n\t\tfqs_duration = 0;\n\tif (fqs_duration) {\n\t\t\n\t\tfirsterr = torture_create_kthread(rcu_torture_fqs, null,\n\t\t\t\t\t\t  fqs_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (test_boost_interval < 1)\n\t\ttest_boost_interval = 1;\n\tif (test_boost_duration < 2)\n\t\ttest_boost_duration = 2;\n\tif ((test_boost == 1 && cur_ops->": 4517, "< 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}\n\nstatic struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t\n\tsystem = kmalloc(sizeof(*system), gfp_kernel);\n\tif (!system)\n\t\treturn null;\n\n\tsystem->": 4518, "< 0) \n\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();\n\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;\n\t\t}\n\n\t\tlock_is_read_held = 0;\n\t\tcxt.lrsa = kmalloc(sizeof(*cxt.lrsa) * cxt.nrealreaders_stress, gfp_kernel);\n\t\tif (cxt.lrsa == null) {\n\t\t\tverbose_torout_string(\"cxt.lrsa: out of memory\");\n\t\t\tfirsterr = -enomem;\n\t\t\tkfree(cxt.lwsa);\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {\n\t\t\tcxt.lrsa[i].n_lock_fail = 0;\n\t\t\tcxt.lrsa[i].n_lock_acquired = 0;\n\t\t}\n\t}\n\tlock_torture_print_module_parms(cxt.cur_ops, \"start of test\");\n\n\t\n\tif (onoff_interval >": 4519, "< 0) ? 'u' :\n\t\t(p->": 4520, "< 0) {\t\n\t\t((u8 *)get_rloc_data(dest))[0] = '\\0';\n\t\t*(u32 *)dest = make_data_rloc(0, get_rloc_offs(rloc));\n\t} else {\n\t\t*(u32 *)dest = make_data_rloc(ret, get_rloc_offs(rloc));\n\t}\n}\n\nstatic void fetch_func_name(memory, string_size)(struct pt_regs *regs,\n\t\t\t\t\t\t void *addr, void *dest)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, max_string_size);\n\n\tif (len == 0 || len >": 4521, "< 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == bpf_ld) {\n\t\t\tu8 mode = bpf_mode(insn->": 4522, "< 0) {\n\t\t\t\t\tmin_offline = delta;\n\t\t\t\t\tmax_offline = delta;\n\t\t\t\t}\n\t\t\t\tif (min_offline >": 4523, "< 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\nftrace_profile_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\t\t\n\tint r;\n\n\tr = sprintf(buf, \"%u\\n\", ftrace_profile_enabled);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic const struct file_operations ftrace_profile_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= ftrace_profile_read,\n\t.write\t\t= ftrace_profile_write,\n\t.llseek\t\t= default_llseek,\n};\n\n\nstatic struct tracer_stat function_stats __initdata = {\n\t.name\t\t= \"functions\",\n\t.stat_start\t= function_stat_start,\n\t.stat_next\t= function_stat_next,\n\t.stat_cmp\t= function_stat_cmp,\n\t.stat_headers\t= function_stat_headers,\n\t.stat_show\t= function_stat_show\n};\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct dentry *entry;\n\tchar *name;\n\tint ret;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\t\t\n\t\tname = kmalloc(32, gfp_kernel);\n\t\tif (!name) {\n\t\t\t\n\t\t\twarn(1,\n\t\t\t     \"could not allocate stat file for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\treturn;\n\t\t}\n\t\tstat->": 4524, "< 0) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp = doms[nslot];\n\n\t\tif (nslot == ndoms) {\n\t\t\tstatic int warnings = 10;\n\t\t\tif (warnings) {\n\t\t\t\tpr_warn(\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\",\n\t\t\t\t\tnslot, ndoms, csn, i, apn);\n\t\t\t\twarnings--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_clear(dp);\n\t\tif (dattr)\n\t\t\t*(dattr + nslot) = sd_attr_init;\n\t\tfor (j = i; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\n\t\t\tif (apn == b->": 4525, "< 0) {\n\t\t\t\n\t\t\twarn_on_once(1);\n\t\t\ttr->": 4526, "< 0) {\n\t\t\t*len_sent = 0;\n\t\t\taudit_log_end(*ab);\n\t\t\t*ab = audit_log_start(context, gfp_kernel, audit_execve);\n\t\t\tif (!*ab)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t\n\t\tif ((i == 0) && (too_long))\n\t\t\taudit_log_format(*ab, \" a%d_len=%zu\", arg_num,\n\t\t\t\t\t has_cntl ? 2*len : len);\n\n\t\t\n\t\tif (len >": 4527, "< 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char proc_wspace_sep[] = { ' ', '\\t', '\\n' };\n\nstatic int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void __user *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tunsigned long page = 0;\n\tsize_t left;\n\tchar *kbuf;\n\t\n\tif (!tbl_data || !table->": 4528, "< 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_clock_t(lval);\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t    int *valp,\n\t\t\t\t\t    int write, void *data)\n{\n\tif (write) {\n\t\tunsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);\n\n\t\tif (jif >": 4529, "< 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_msecs(lval);\n\t}\n\treturn 0;\n}\n\n\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_jiffies_conv,null);\n}\n\n\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_userhz_jiffies_conv,null);\n}\n\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_ms_jiffies_conv, null);\n}\n\nstatic int proc_do_cad_pid(struct ctl_table *table, int write,\n\t\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid *new_pid;\n\tpid_t tmp;\n\tint r;\n\n\ttmp = pid_vnr(cad_pid);\n\n\tr = __do_proc_dointvec(&tmp, table, write, buffer,\n\t\t\t       lenp, ppos, null, null);\n\tif (r || !write)\n\t\treturn r;\n\n\tnew_pid = find_get_pid(tmp);\n\tif (!new_pid)\n\t\treturn -esrch;\n\n\tput_pid(xchg(&cad_pid, new_pid));\n\treturn 0;\n}\n\n\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tbool first = 1;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->": 4530, "< 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = lval / hz;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t\tint *valp,\n\t\t\t\t\t\tint write, void *data)\n{\n\tif (write) {\n\t\tif (user_hz < hz && *lvalp >": 4531, "< 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"ok\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}\n\n\nstatic int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t\n\tif (strcmp(remcom_in_buffer, \"r0\") == 0) {\n\t\tprintk(kern_crit \"executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"ok\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t\n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[buf_thread_id_size];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"threadinfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->": 4532, "< 0) {\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t\n\tftrace_hash_rec_disable_modify(ops, enable);\n\n\trcu_assign_pointer(*dst, new_hash);\n\n\tftrace_hash_rec_enable_modify(ops, enable);\n\n\treturn 0;\n}\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t\n\treturn (ftrace_hash_empty(hash->": 4533, "< 0) {\n\t\t\tif (i >": 4534, "< 0) {\n\t\t\tif (ops->": 4535, "< 0) {\n\t\t\tif (rq->": 4536, "< 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >": 4537, "< 0) {\n\t\t\tpr_warn(\"could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\ttrace_create_file(\"filter\", 0644, file->": 4538, "< 0) {\n\t\t\tprintk(kern_err \"schedule_timeout: wrong timeout \"\n\t\t\t\t\"value %lx\\n\", timeout);\n\t\t\tdump_stack();\n\t\t\tcurrent->": 4539, "< 0) {\n\t\t\tret = -efault;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef config_kexec\n\tcase linux_reboot_cmd_kexec:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef config_hibernation\n\tcase linux_reboot_cmd_sw_suspend:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -einval;\n\t\tbreak;\n\t}\n\tmutex_unlock(&reboot_mutex);\n\treturn ret;\n}\n\nstatic void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(null);\n}\n\n\nvoid ctrl_alt_del(void)\n{\n\tstatic declare_work(cad_work, deferred_cad);\n\n\tif (c_a_d)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(sigint, 1);\n}\n\nchar poweroff_cmd[poweroff_cmd_path_len] = \"/sbin/poweroff\";\nstatic const char reboot_cmd[] = \"/sbin/reboot\";\n\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"home=/\",\n\t\t\"path=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tnull\n\t};\n\tint ret;\n\targv = argv_split(gfp_kernel, cmd, null);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, umh_wait_exec);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -enomem;\n\t}\n\n\treturn ret;\n}\n\nstatic int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(null);\n\t}\n\n\treturn ret;\n}\n\nstatic int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\n\nstatic bool poweroff_force;\n\nstatic void poweroff_work_func(struct work_struct *work)\n{\n\t__orderly_poweroff(poweroff_force);\n}\n\nstatic declare_work(poweroff_work, poweroff_work_func);\n\n\nvoid orderly_poweroff(bool force)\n{\n\tif (force) \n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}\nexport_symbol_gpl(orderly_poweroff);\n\nstatic void reboot_work_func(struct work_struct *work)\n{\n\t__orderly_reboot();\n}\n\nstatic declare_work(reboot_work, reboot_work_func);\n\n\nvoid orderly_reboot(void)\n{\n\tschedule_work(&reboot_work);\n}\nexport_symbol_gpl(orderly_reboot);\n\nstatic int __init reboot_setup(char *str)\n{\n\tfor (;;) {\n\t\t\n\t\treboot_default = 0;\n\n\t\tswitch (*str) {\n\t\tcase 'w':\n\t\t\treboot_mode = reboot_warm;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\treboot_mode = reboot_cold;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\treboot_mode = reboot_hard;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t{\n\t\t\tint rc;\n\n\t\t\tif (isdigit(*(str+1))) {\n\t\t\t\trc = kstrtoint(str+1, 0, &reboot_cpu);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} else if (str[1] == 'm' && str[2] == 'p' &&\n\t\t\t\t   isdigit(*(str+3))) {\n\t\t\t\trc = kstrtoint(str+3, 0, &reboot_cpu);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\treboot_mode = reboot_soft;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'g':\n\t\t\treboot_mode = reboot_gpio;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'a':\n\t\tcase 'k':\n\t\tcase 't':\n\t\tcase 'e':\n\t\tcase 'p':\n\t\t\treboot_type = *str;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\treboot_force = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tstr = strchr(str, ',');\n\t\tif (str)\n\t\t\tstr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n__setup(\"reboot=\", reboot_setup);\n\n\n#ifndef __kernel_rtmutex_common_h\n#define __kernel_rtmutex_common_h\n\n#include <linux/rtmutex.h>": 4540, "< 0) {\n\t\t\tret = -enospc;\n\t\t\tif (ops->": 4541, "< 0) {\n\t\t\tspin_unlock_irq(&tsk->": 4542, "< 0) {\n\t\t\tvfree(info->": 4543, "< 0) {\n\t\t\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->": 4544, "< 0) {\n\t\t\n\t\traw_spin_unlock(&cfs_b->": 4545, "< 0) {\n\t\t\n\t\tstruct completion *done = xchg(&create->": 4546, "< 0) {\n\t\t\n\t\tvec = base->": 4547, "< 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += nsec_per_sec;\n\t\t--sec;\n\t}\n\tts->": 4548, "< 0) {\n\t\taudit_free_parent(parent);\n\t\treturn err_ptr(ret);\n\t}\n\n\treturn parent;\n}\n\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), gfp_kernel);\n\tif (unlikely(!watch))\n\t\treturn err_ptr(-enomem);\n\n\tinit_list_head(&watch->": 4549, "< 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->": 4550, "< 0) {\n\t\tbug_on(err != -econnrefused); \n\t\tif (audit_pid) {\n\t\t\tpr_err(\"*no* daemon at audit_pid=%d\\n\", audit_pid);\n\t\t\taudit_log_lost(\"auditd disappeared\");\n\t\t\taudit_pid = 0;\n\t\t\taudit_sock = null;\n\t\t}\n\t\t\n\t\taudit_hold_skb(skb);\n\t} else\n\t\t\n\t\tconsume_skb(skb);\n}\n\n\nstatic void kauditd_send_multicast_skb(struct sk_buff *skb, gfp_t gfp_mask)\n{\n\tstruct sk_buff\t\t*copy;\n\tstruct audit_net\t*aunet = net_generic(&init_net, audit_net_id);\n\tstruct sock\t\t*sock = aunet->": 4551, "< 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = it_id_set;\n\tnew_timer->": 4552, "< 0) {\n\t\tgoto fail_free_freeinit;\n\t}\n\tif (ret >": 4553, "< 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\telse\n\t\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->": 4554, "< 0) {\n\t\tkfree(cset);\n\t\treturn null;\n\t}\n\n\tatomic_set(&cset->": 4555, "< 0) {\n\t\tkfree(savedcmd);\n\t\tsavedcmd = null;\n\t\treturn -enomem;\n\t}\n\n\treturn 0;\n}\n\nint is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}\n\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t\n\t\t\twarn_on_once(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef config_tracer_max_trace\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}\n\nstatic void tracing_start_tr(struct trace_array *tr)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\t\n\tif (tr->": 4556, "< 0) {\n\t\tkfree(stat->": 4557, "< 0) {\n\t\tkobject_put(cgroup_kobj);\n\t\treturn err;\n\t}\n\n\tproc_create(\"cgroups\", 0, null, &proc_cgroupstats_operations);\n\treturn 0;\n}\n\nstatic int __init cgroup_wq_init(void)\n{\n\t\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tbug_on(!cgroup_destroy_wq);\n\n\t\n\tcgroup_pidlist_destroy_wq = alloc_workqueue(\"cgroup_pidlist_destroy\",\n\t\t\t\t\t\t    0, 1);\n\tbug_on(!cgroup_pidlist_destroy_wq);\n\n\treturn 0;\n}\ncore_initcall(cgroup_wq_init);\n\n\nint proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf, *path;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -enomem;\n\tbuf = kmalloc(path_max, gfp_kernel);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tdown_read(&css_set_rwsem);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_root_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->": 4558, "< 0) {\n\t\tlist_del_rcu(&data->": 4559, "< 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfdput(f);\n\treturn rc;\n}\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, gfp_kernel))\n\t\treturn -enomem;\n\trc = parse(info->": 4560, "< 0) {\n\t\tnsec = -nsec;\n\t\tdo_div(nsec, 1000000);\n\t\treturn -nsec;\n\t}\n\tdo_div(nsec, 1000000);\n\n\treturn nsec;\n}\n\nstatic unsigned long nsec_low(unsigned long long nsec)\n{\n\tif ((long long)nsec < 0)\n\t\tnsec = -nsec;\n\n\treturn do_div(nsec, 1000000);\n}\n\n#define split_ns(x) nsec_high(x), nsec_low(x)\n\n#ifdef config_fair_group_sched\nstatic void print_cfs_group_stats(struct seq_file *m, int cpu, struct task_group *tg)\n{\n\tstruct sched_entity *se = tg->": 4561, "< 0) {\n\t\tpr_err(\"register_kprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = target(rand1);\n\tunregister_kprobe(&kp);\n\n\tif (preh_val == 0) {\n\t\tpr_err(\"kprobe pre_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tif (posth_val == 0) {\n\t\tpr_err(\"kprobe post_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline u32 kprobe_target2(u32 value)\n{\n\treturn (value / div_factor) + 1;\n}\n\nstatic int kp_pre_handler2(struct kprobe *p, struct pt_regs *regs)\n{\n\tpreh_val = (rand1 / div_factor) + 1;\n\treturn 0;\n}\n\nstatic void kp_post_handler2(struct kprobe *p, struct pt_regs *regs,\n\t\tunsigned long flags)\n{\n\tif (preh_val != (rand1 / div_factor) + 1) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in post_handler2\\n\");\n\t}\n\tposth_val = preh_val + div_factor;\n}\n\nstatic struct kprobe kp2 = {\n\t.symbol_name = \"kprobe_target2\",\n\t.pre_handler = kp_pre_handler2,\n\t.post_handler = kp_post_handler2\n};\n\nstatic int test_kprobes(void)\n{\n\tint ret;\n\tstruct kprobe *kps[2] = {&kp, &kp2};\n\n\t\n\tkp.addr = null;\n\tkp.flags = 0;\n\tret = register_kprobes(kps, 2);\n\tif (ret < 0) {\n\t\tpr_err(\"register_kprobes returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpreh_val = 0;\n\tposth_val = 0;\n\tret = target(rand1);\n\n\tif (preh_val == 0) {\n\t\tpr_err(\"kprobe pre_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tif (posth_val == 0) {\n\t\tpr_err(\"kprobe post_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tpreh_val = 0;\n\tposth_val = 0;\n\tret = target2(rand1);\n\n\tif (preh_val == 0) {\n\t\tpr_err(\"kprobe pre_handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tif (posth_val == 0) {\n\t\tpr_err(\"kprobe post_handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tunregister_kprobes(kps, 2);\n\treturn 0;\n\n}\n\nstatic u32 j_kprobe_target(u32 value)\n{\n\tif (value != rand1) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in jprobe handler\\n\");\n\t}\n\n\tjph_val = rand1;\n\tjprobe_return();\n\treturn 0;\n}\n\nstatic struct jprobe jp = {\n\t.entry\t\t= j_kprobe_target,\n\t.kp.symbol_name = \"kprobe_target\"\n};\n\nstatic int test_jprobe(void)\n{\n\tint ret;\n\n\tret = register_jprobe(&jp);\n\tif (ret < 0) {\n\t\tpr_err(\"register_jprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = target(rand1);\n\tunregister_jprobe(&jp);\n\tif (jph_val == 0) {\n\t\tpr_err(\"jprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\treturn 0;\n}\n\nstatic struct jprobe jp2 = {\n\t.entry          = j_kprobe_target,\n\t.kp.symbol_name = \"kprobe_target2\"\n};\n\nstatic int test_jprobes(void)\n{\n\tint ret;\n\tstruct jprobe *jps[2] = {&jp, &jp2};\n\n\t\n\tjp.kp.addr = null;\n\tjp.kp.flags = 0;\n\tret = register_jprobes(jps, 2);\n\tif (ret < 0) {\n\t\tpr_err(\"register_jprobes returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tjph_val = 0;\n\tret = target(rand1);\n\tif (jph_val == 0) {\n\t\tpr_err(\"jprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tjph_val = 0;\n\tret = target2(rand1);\n\tif (jph_val == 0) {\n\t\tpr_err(\"jprobe handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\tunregister_jprobes(jps, 2);\n\n\treturn 0;\n}\n#ifdef config_kretprobes\nstatic u32 krph_val;\n\nstatic int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tkrph_val = (rand1 / div_factor);\n\treturn 0;\n}\n\nstatic int return_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tif (ret != (rand1 / div_factor)) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in kretprobe handler\\n\");\n\t}\n\tif (krph_val == 0) {\n\t\thandler_errors++;\n\t\tpr_err(\"call to kretprobe entry handler failed\\n\");\n\t}\n\n\tkrph_val = rand1;\n\treturn 0;\n}\n\nstatic struct kretprobe rp = {\n\t.handler\t= return_handler,\n\t.entry_handler  = entry_handler,\n\t.kp.symbol_name = \"kprobe_target\"\n};\n\nstatic int test_kretprobe(void)\n{\n\tint ret;\n\n\tret = register_kretprobe(&rp);\n\tif (ret < 0) {\n\t\tpr_err(\"register_kretprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = target(rand1);\n\tunregister_kretprobe(&rp);\n\tif (krph_val != rand1) {\n\t\tpr_err(\"kretprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\treturn 0;\n}\n\nstatic int return_handler2(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tif (ret != (rand1 / div_factor) + 1) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in kretprobe handler2\\n\");\n\t}\n\tif (krph_val == 0) {\n\t\thandler_errors++;\n\t\tpr_err(\"call to kretprobe entry handler failed\\n\");\n\t}\n\n\tkrph_val = rand1;\n\treturn 0;\n}\n\nstatic struct kretprobe rp2 = {\n\t.handler\t= return_handler2,\n\t.entry_handler  = entry_handler,\n\t.kp.symbol_name = \"kprobe_target2\"\n};\n\nstatic int test_kretprobes(void)\n{\n\tint ret;\n\tstruct kretprobe *rps[2] = {&rp, &rp2};\n\n\t\n\trp.kp.addr = null;\n\trp.kp.flags = 0;\n\tret = register_kretprobes(rps, 2);\n\tif (ret < 0) {\n\t\tpr_err(\"register_kretprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tkrph_val = 0;\n\tret = target(rand1);\n\tif (krph_val != rand1) {\n\t\tpr_err(\"kretprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tkrph_val = 0;\n\tret = target2(rand1);\n\tif (krph_val != rand1) {\n\t\tpr_err(\"kretprobe handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\tunregister_kretprobes(rps, 2);\n\treturn 0;\n}\n#endif \n\nint init_test_probes(void)\n{\n\tint ret;\n\n\ttarget = kprobe_target;\n\ttarget2 = kprobe_target2;\n\n\tdo {\n\t\trand1 = prandom_u32();\n\t} while (rand1 <= div_factor);\n\n\tpr_info(\"started\\n\");\n\tnum_tests++;\n\tret = test_kprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kprobes();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_jprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_jprobes();\n\tif (ret < 0)\n\t\terrors++;\n\n#ifdef config_kretprobes\n\tnum_tests++;\n\tret = test_kretprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kretprobes();\n\tif (ret < 0)\n\t\terrors++;\n#endif \n\n\tif (errors)\n\t\tpr_err(\"bug: %d out of %d tests failed\\n\", errors, num_tests);\n\telse if (handler_errors)\n\t\tpr_err(\"bug: %d error(s) running handlers\\n\", handler_errors);\n\telse\n\t\tpr_info(\"passed successfully\\n\");\n\n\treturn 0;\n}\n\n\n#include <linux/string.h>": 4562, "< 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t\n\tnode->": 4563, "< 0) {\n\t\tpr_warning(\"nohz: incorrect nohz_full cpumask\\n\");\n\t\tfree_bootmem_cpumask_var(tick_nohz_full_mask);\n\t\treturn 1;\n\t}\n\ttick_nohz_full_running = true;\n\n\treturn 1;\n}\n__setup(\"nohz_full=\", tick_nohz_full_setup);\n\nstatic int tick_nohz_cpu_down_callback(struct notifier_block *nfb,\n\t\t\t\t\t\t unsigned long action,\n\t\t\t\t\t\t void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_down_prepare:\n\t\t\n\t\tif (tick_nohz_full_running && tick_do_timer_cpu == cpu)\n\t\t\treturn notify_bad;\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\nstatic int tick_nohz_init_all(void)\n{\n\tint err = -1;\n\n#ifdef config_no_hz_full_all\n\tif (!alloc_cpumask_var(&tick_nohz_full_mask, gfp_kernel)) {\n\t\twarn(1, \"no_hz: can't allocate full dynticks cpumask\\n\");\n\t\treturn err;\n\t}\n\terr = 0;\n\tcpumask_setall(tick_nohz_full_mask);\n\ttick_nohz_full_running = true;\n#endif\n\treturn err;\n}\n\nvoid __init tick_nohz_init(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running) {\n\t\tif (tick_nohz_init_all() < 0)\n\t\t\treturn;\n\t}\n\n\tif (!alloc_cpumask_var(&housekeeping_mask, gfp_kernel)) {\n\t\twarn(1, \"no_hz: can't allocate not-full dynticks cpumask\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\t\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warning(\"no_hz: can't run full dynticks because arch doesn't \"\n\t\t\t   \"support irq work self-ipis\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\tcpumask_copy(housekeeping_mask, cpu_possible_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tcpu = smp_processor_id();\n\n\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\tpr_warning(\"no_hz: clearing %d from nohz_full range for timekeeping\\n\", cpu);\n\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t}\n\n\tcpumask_andnot(housekeeping_mask,\n\t\t       cpu_possible_mask, tick_nohz_full_mask);\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tcpu_notifier(tick_nohz_cpu_down_callback, 0);\n\tpr_info(\"no_hz: full dynticks cpus: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}\n#endif\n\n\n#ifdef config_no_hz_common\n\nstatic int tick_nohz_enabled __read_mostly  = 1;\nint tick_nohz_active  __read_mostly;\n\nstatic int __init setup_tick_nohz(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\ttick_nohz_enabled = 0;\n\telse if (!strcmp(str, \"on\"))\n\t\ttick_nohz_enabled = 1;\n\telse\n\t\treturn 0;\n\treturn 1;\n}\n\n__setup(\"nohz=\", setup_tick_nohz);\n\nint tick_nohz_tick_stopped(void)\n{\n\treturn __this_cpu_read(tick_cpu_sched.tick_stopped);\n}\n\n\nstatic void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog();\n}\n\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->": 4564, "< 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->": 4565, "< 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->": 4566, "< 0) {\n\t\tput_system(dir);\n\t\treturn -enodev;\n\t}\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tput_system(dir);\n\t}\n\n\treturn ret;\n}\n\nstatic int system_tr_open(struct inode *inode, struct file *filp)\n{\n\tstruct ftrace_subsystem_dir *dir;\n\tstruct trace_array *tr = inode->": 4567, "< 0) {\n\t\treset_on_fork = p->": 4568, "< 0) {\n\t\tret = -enomem;\n\t\tgoto out_cancel_ref;\n\t}\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->": 4569, "< 0) {\n\t\tsa->": 4570, "< 0) {\n\t\tsub_info->": 4571, "< 0) {\n\t\ttrace_array_put(tr);\n\t\tkfree(dir);\n\t\treturn ret;\n\t}\n\n\tfilp->": 4572, "< 0) {\n\t\ttrsp->": 4573, "< 0) {\n\t\tverbose_torout_string(\"rcu_torture_boost rt prio failed!\");\n\t\tn_rcu_torture_boost_rterror++;\n\t}\n\n\tinit_rcu_head_on_stack(&rbi.rcu);\n\t\n\tdo {\n\t\t\n\t\toldstarttime = boost_starttime;\n\t\twhile (ulong_cmp_lt(jiffies, oldstarttime)) {\n\t\t\tschedule_timeout_interruptible(oldstarttime - jiffies);\n\t\t\tstutter_wait(\"rcu_torture_boost\");\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t\n\t\tendtime = oldstarttime + test_boost_duration * hz;\n\t\tcall_rcu_time = jiffies;\n\t\twhile (ulong_cmp_lt(jiffies, endtime)) {\n\t\t\t\n\t\t\tif (!rbi.inflight) {\n\t\t\t\tsmp_mb(); \n\t\t\t\trbi.inflight = 1;\n\t\t\t\tcall_rcu(&rbi.rcu, rcu_torture_boost_cb);\n\t\t\t\tif (jiffies - call_rcu_time >": 4574, "< 0) ||\n\t    (max_depth && trace->": 4575, "< 0) || (cpu >": 4576, "< 0) || (info.si_signo == 0))\n\t\treturn ret;\n\n\tif (uru) {\n\t\t\n\t\tif (compat_use_64bit_time)\n\t\t\tret = copy_to_user(uru, &ru, sizeof(ru));\n\t\telse\n\t\t\tret = put_compat_rusage(&ru, uru);\n\t\tif (ret)\n\t\t\treturn -efault;\n\t}\n\n\tbug_on(info.si_code & __si_mask);\n\tinfo.si_code |= __si_chld;\n\treturn copy_siginfo_to_user32(uinfo, &info);\n}\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len >": 4577, "< 0))\n\t\tdelta = 0;\n\n\told_clock = scd->": 4578, "< 0))\n\t\tdelta = 0;\n\n\ttotal = sched_avg_period() + delta;\n\n\tused = div_u64(avg, total);\n\n\tif (likely(used < sched_capacity_scale))\n\t\treturn sched_capacity_scale - used;\n\n\treturn 1;\n}\n\nstatic void update_cpu_capacity(struct sched_domain *sd, int cpu)\n{\n\tunsigned long capacity = sched_capacity_scale;\n\tstruct sched_group *sdg = sd->": 4579, "< 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(&dwork->": 4580, "< 0))\n\t\treturn print_bfs_bug(ret);\n\n\tif (!check_prev_add_irq(curr, prev, next))\n\t\treturn 0;\n\n\t\n\tif (next->": 4581, "< 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (warn_on(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (warn_on(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (warn_on(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\n\treturn 0;\n}\n\n#include <linux/sched.h>": 4582, "< 0))\n\t\treturn ret;\n\tret = register_ftrace_command(&event_disable_cmd);\n\tif (warn_on(ret < 0))\n\t\tunregister_ftrace_command(&event_enable_cmd);\n\treturn ret;\n}\n#else\nstatic inline int register_event_cmds(void) { return 0; }\n#endif \n\n\nstatic __init void\n__trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct ftrace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->": 4583, "< 0))\n\t\treturn;\n\n\tif (cfs_rq->": 4584, "< 0)) \n\t\tatomic_inc(&cpu_hotplug.refcount);\n\n\tif (refcount <= 0 && waitqueue_active(&cpu_hotplug.wq))\n\t\twake_up(&cpu_hotplug.wq);\n\n\tcpuhp_lock_release();\n\n}\nexport_symbol_gpl(put_online_cpus);\n\n\nvoid cpu_hotplug_begin(void)\n{\n\tdefine_wait(wait);\n\n\tcpu_hotplug.active_writer = current;\n\tcpuhp_lock_acquire();\n\n\tfor (;;) {\n\t\tmutex_lock(&cpu_hotplug.lock);\n\t\tprepare_to_wait(&cpu_hotplug.wq, &wait, task_uninterruptible);\n\t\tif (likely(!atomic_read(&cpu_hotplug.refcount)))\n\t\t\t\tbreak;\n\t\tmutex_unlock(&cpu_hotplug.lock);\n\t\tschedule();\n\t}\n\tfinish_wait(&cpu_hotplug.wq, &wait);\n}\n\nvoid cpu_hotplug_done(void)\n{\n\tcpu_hotplug.active_writer = null;\n\tmutex_unlock(&cpu_hotplug.lock);\n\tcpuhp_lock_release();\n}\n\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled = 1;\n\tcpu_maps_update_done();\n}\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled = 0;\n\tcpu_maps_update_done();\n}\n\n#endif\t\n\n\nint __ref register_cpu_notifier(struct notifier_block *nb)\n{\n\tint ret;\n\tcpu_maps_update_begin();\n\tret = raw_notifier_chain_register(&cpu_chain, nb);\n\tcpu_maps_update_done();\n\treturn ret;\n}\n\nint __ref __register_cpu_notifier(struct notifier_block *nb)\n{\n\treturn raw_notifier_chain_register(&cpu_chain, nb);\n}\n\nstatic int __cpu_notify(unsigned long val, void *v, int nr_to_call,\n\t\t\tint *nr_calls)\n{\n\tint ret;\n\n\tret = __raw_notifier_call_chain(&cpu_chain, val, v, nr_to_call,\n\t\t\t\t\tnr_calls);\n\n\treturn notifier_to_errno(ret);\n}\n\nstatic int cpu_notify(unsigned long val, void *v)\n{\n\treturn __cpu_notify(val, v, -1, null);\n}\n\n#ifdef config_hotplug_cpu\n\nstatic void cpu_notify_nofail(unsigned long val, void *v)\n{\n\tbug_on(cpu_notify(val, v));\n}\nexport_symbol(register_cpu_notifier);\nexport_symbol(__register_cpu_notifier);\n\nvoid __ref unregister_cpu_notifier(struct notifier_block *nb)\n{\n\tcpu_maps_update_begin();\n\traw_notifier_chain_unregister(&cpu_chain, nb);\n\tcpu_maps_update_done();\n}\nexport_symbol(unregister_cpu_notifier);\n\nvoid __ref __unregister_cpu_notifier(struct notifier_block *nb)\n{\n\traw_notifier_chain_unregister(&cpu_chain, nb);\n}\nexport_symbol(__unregister_cpu_notifier);\n\n\nvoid clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t\n\twarn_on(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(t->": 4585, "< 0)) {\n\t\tpr_info(\"failed to enable function tracer for event tests\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"running tests again, along with the function tracer\\n\");\n\tevent_trace_self_tests();\n\tunregister_ftrace_function(&trace_ops);\n}\n#else\nstatic __init void event_trace_self_test_with_function(void)\n{\n}\n#endif\n\nstatic __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}\n\nlate_initcall(event_trace_self_tests_init);\n\n#endif\n\n\n\n\n#include <linux/mm.h>": 4586, "< 0)) {\n\t\tptr = &scd->": 4587, "< 0)) {\n\t\ts64 neg = -(s64)tk->": 4588, "< 0)) {\n\t\tstrcpy(comm, \"<xxx>": 4589, "< 0)) {\n\t\tts.tv_sec--;\n\t\trem += nsec_per_sec;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}\nexport_symbol(ns_to_timespec);\n\n\nstruct timeval ns_to_timeval(const s64 nsec)\n{\n\tstruct timespec ts = ns_to_timespec(nsec);\n\tstruct timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t) ts.tv_nsec / 1000;\n\n\treturn tv;\n}\nexport_symbol(ns_to_timeval);\n\n#if bits_per_long == 32\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >": 4590, "< 0)) {\n\t\tts.tv_sec--;\n\t\trem += nsec_per_sec;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}\nexport_symbol(ns_to_timespec64);\n#endif\n\nunsigned long msecs_to_jiffies(const unsigned int m)\n{\n\t\n\tif ((int)m < 0)\n\t\treturn max_jiffy_offset;\n\n#if hz <= msec_per_sec && !(msec_per_sec % hz)\n\t\n\treturn (m + (msec_per_sec / hz) - 1) / (msec_per_sec / hz);\n#elif hz >": 4591, "< 0)) {\n\t\twarn_on_once(1);\n\t\treturn -etime;\n\t}\n\n\tdev->": 4592, "< 0)) ||\n\t    warn_on(!list_empty(&pool->": 4593, "< 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef config_debug_preempt\n\t\n\tdebug_locks_warn_on((preempt_count() & preempt_mask) >": 4594, "< 0));\n\n\t\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\tflush_work(work);\n\tclear_work_data(work);\n\n\t\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, task_normal, 1, work);\n\n\treturn ret;\n}\n\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}\nexport_symbol_gpl(cancel_work_sync);\n\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->": 4595, "< 0);\t\n\t\ttrace_module_put(module, _ret_ip_);\n\t\tpreempt_enable();\n\t}\n}\nexport_symbol(module_put);\n\n#else \nstatic inline void print_unload_info(struct seq_file *m, struct module *mod)\n{\n\t\n\tseq_puts(m, \" - -\");\n}\n\nstatic inline void module_unload_free(struct module *mod)\n{\n}\n\nint ref_module(struct module *a, struct module *b)\n{\n\treturn strong_try_module_get(b);\n}\nexport_symbol_gpl(ref_module);\n\nstatic inline int module_unload_init(struct module *mod)\n{\n\treturn 0;\n}\n#endif \n\nstatic size_t module_flags_taint(struct module *mod, char *buf)\n{\n\tsize_t l = 0;\n\n\tif (mod->": 4596, "< 0);\n\t\t\tif (pwq->": 4597, "< 0);\n\t\t\treturn;  \n\t\t}\n\t}\n\n\t\n\tj = jiffies;\n\taccess_once(rdtp->": 4598, "< 0);\n\t\tif (rdtp->": 4599, "< 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t\n\t\tif (ss->": 4600, "< 0);\n\tif (oldval & dyntick_task_nest_mask) {\n\t\trdtp->": 4601, "< 0);\n\tif (onoff_holdoff >": 4602, "< 0);\n\tif (rdtp->": 4603, "< 0);\n\tif (ret)\n\t\t\n\t\tret = atomic_add_unless(&mod->": 4604, "< 0);\n\t}\n\n\t\n\tinit_css_set.subsys[ss->": 4605, "< 0);\n\t}\n}\n\n#ifdef config_generic_idle_poll_setup\nstatic int __init cpu_idle_poll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 1;\n\treturn 1;\n}\n__setup(\"nohlt\", cpu_idle_poll_setup);\n\nstatic int __init cpu_idle_nopoll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 0;\n\treturn 1;\n}\n__setup(\"hlt\", cpu_idle_nopoll_setup);\n#endif\n\nstatic inline int cpu_idle_poll(void)\n{\n\trcu_idle_enter();\n\ttrace_cpu_idle_rcuidle(0, smp_processor_id());\n\tlocal_irq_enable();\n\twhile (!tif_need_resched() &&\n\t\t(cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\ttrace_cpu_idle_rcuidle(pwr_event_exit, smp_processor_id());\n\trcu_idle_exit();\n\treturn 1;\n}\n\n\nvoid __weak arch_cpu_idle_prepare(void) { }\nvoid __weak arch_cpu_idle_enter(void) { }\nvoid __weak arch_cpu_idle_exit(void) { }\nvoid __weak arch_cpu_idle_dead(void) { }\nvoid __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\tlocal_irq_enable();\n}\n\n\nstatic void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\tbool reflect;\n\n\t\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t\n\tstop_critical_timings();\n\n\t\n\trcu_idle_enter();\n\n\tif (cpuidle_not_available(drv, dev))\n\t\tgoto use_default;\n\n\t\n\tif (idle_should_freeze()) {\n\t\tentered_state = cpuidle_enter_freeze(drv, dev);\n\t\tif (entered_state >": 4606, "< 0);\n\n\t\n\tftrace_hash_ipmodify_disable(ops);\n\tftrace_hash_rec_disable(ops, 1);\n\n\tops->": 4607, "< 0);\n\n\t\n\tif (!(atomic_read(&rdtp->": 4608, "< 0);\n\n\treturn ret;\n}\n#else\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }\n#endif \n\n#ifdef config_stacktrace\n\n#define stack_skip 3\n\nstatic void\nstacktrace_trigger(struct event_trigger_data *data)\n{\n\ttrace_dump_stack(stack_skip);\n}\n\nstatic void\nstacktrace_count_trigger(struct event_trigger_data *data)\n{\n\tif (!data->": 4609, "< 0);\n\n\treturn ret;\n}\n#else\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }\n#endif \n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}\n\n\n#define enable_event_str\t\"enable_event\"\n#define disable_event_str\t\"disable_event\"\n\nstruct enable_trigger_data {\n\tstruct ftrace_event_file\t*file;\n\tbool\t\t\t\tenable;\n};\n\nstatic void\nevent_enable_trigger(struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->": 4610, "< 0);\n\n\treturn ret;\n}\nexport_symbol_gpl(tracing_alloc_snapshot);\n\n\nvoid tracing_snapshot_alloc(void)\n{\n\tint ret;\n\n\tret = tracing_alloc_snapshot();\n\tif (ret < 0)\n\t\treturn;\n\n\ttracing_snapshot();\n}\nexport_symbol_gpl(tracing_snapshot_alloc);\n#else\nvoid tracing_snapshot(void)\n{\n\twarn_once(1, \"snapshot feature not enabled, but internal snapshot used\");\n}\nexport_symbol_gpl(tracing_snapshot);\nint tracing_alloc_snapshot(void)\n{\n\twarn_once(1, \"snapshot feature not enabled, but snapshot allocation used\");\n\treturn -enodev;\n}\nexport_symbol_gpl(tracing_alloc_snapshot);\nvoid tracing_snapshot_alloc(void)\n{\n\t\n\ttracing_snapshot();\n}\nexport_symbol_gpl(tracing_snapshot_alloc);\n#endif \n\nstatic void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->": 4611, "< 0);\n\n\tspin_lock_irq(&pool->": 4612, "< 0);\n}\n\n\nstatic int workqueue_cpu_up_callback(struct notifier_block *nfb,\n\t\t\t\t\t       unsigned long action,\n\t\t\t\t\t       void *hcpu)\n{\n\tint cpu = (unsigned long)hcpu;\n\tstruct worker_pool *pool;\n\tstruct workqueue_struct *wq;\n\tint pi;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_up_prepare:\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tif (pool->": 4613, "< 0);\n}\nexport_symbol(down_trylock);\n\n\nint down_timeout(struct semaphore *sem, long timeout)\n{\n\tunsigned long flags;\n\tint result = 0;\n\n\traw_spin_lock_irqsave(&sem->": 4614, "< 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->": 4615, "< 0, \"failed to arm kprobe-ftrace at %p (%d)\\n\", p->": 4616, "< 0, \"failed to disarm kprobe-ftrace at %p (%d)\\n\", p->": 4617, "< 0, \"failed to init kprobe-ftrace (%d)\\n\", ret);\n\t}\n}\n\n\nstatic void disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret;\n\n\tkprobe_ftrace_enabled--;\n\tif (kprobe_ftrace_enabled == 0) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\twarn(ret < 0, \"failed to init kprobe-ftrace (%d)\\n\", ret);\n\t}\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->": 4618, "< 0;\n}\n\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_time_before(a->": 4619, "< 0;\n}\n\nstatic void update_min_vruntime(struct cfs_rq *cfs_rq)\n{\n\tu64 vruntime = cfs_rq->": 4620, "< 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < max_iores_level; depth++, p = p->": 4621, "< 1 << (tvr_bits + 2 * tvn_bits)) {\n\t\tint i = (expires >": 4622, "< 1 << (tvr_bits + 3 * tvn_bits)) {\n\t\tint i = (expires >": 4623, "< 1 << (tvr_bits + tvn_bits)) {\n\t\tint i = (expires >": 4624, "< 1 || (act && sig_kernel_only(sig)))\n\t\treturn -einval;\n\n\tk = &p->": 4625, "< 1 || max_active >": 4626, "< 1)\n\t\t\tse = second;\n\t}\n\n\t\n\tif (cfs_rq->": 4627, "< 1)\n\t\tdelta = 1;\n\tnow += delta;\n\tif (time_before(now, expires))\n\t\treturn now;\n\treturn expires;\n}\n\n\nunsigned long get_next_timer_interrupt(unsigned long now)\n{\n\tstruct tvec_base *base = __this_cpu_read(tvec_bases);\n\tunsigned long expires = now + next_timer_max_delta;\n\n\t\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\tspin_lock(&base->": 4628, "< 1)\n\t\treturn -einval;\n\tdata = kmalloc(len, gfp_kernel);\n\tif (!data)\n\t\treturn -enomem;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}\n\n#if defined(config_64bit) && !defined(config_have_efficient_unaligned_access)\n#define taskstats_needs_padding 1\n#endif\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == taskstats_type_pid)\n\t\t\t? taskstats_type_aggr_pid\n\t\t\t: taskstats_type_aggr_tgid;\n\n\t\n#ifdef taskstats_needs_padding\n\tif (nla_put(skb, taskstats_type_null, 0, null) < 0)\n\t\tgoto err;\n#endif\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve(skb, taskstats_type_stats, sizeof(struct taskstats));\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn null;\n}\n\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct fd f;\n\n\tna = info->": 4629, "< 1)\n\t\treturn -einval;\n\telse if (ret < 2)\n\t\titers = default_iterations;\n\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_usecs = usecs;\n\tudelay_test_iterations = iters;\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations udelay_test_debugfs_ops = {\n\t.owner = this_module,\n\t.open = udelay_test_open,\n\t.read = seq_read,\n\t.write = udelay_test_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int __init udelay_test_init(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_debugfs_file = debugfs_create_file(debugfs_filename,\n\t\t\ts_irusr, null, null, &udelay_test_debugfs_ops);\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn 0;\n}\n\nmodule_init(udelay_test_init);\n\nstatic void __exit udelay_test_exit(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_remove(udelay_test_debugfs_file);\n\tmutex_unlock(&udelay_test_lock);\n}\n\nmodule_exit(udelay_test_exit);\n\nmodule_author(\"david riley <davidriley@chromium.org>": 4630, "< 1)\n\t\treturn -einval;\n\n\tmemcpy(cmdbuf, buf, count);\n\tcmdbuf[count] = 0;\n\n\tif (sscanf(cmdbuf, \"%d:%d\", &op, &dat) != 2)\n\t\treturn -einval;\n\n\tswitch (op) {\n\tcase rttest_schedot:\n\t\tschedpar.sched_priority = 0;\n\t\tret = sched_setscheduler(threads[tid], sched_normal, &schedpar);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_user_nice(current, 0);\n\t\tbreak;\n\n\tcase rttest_schedrt:\n\t\tschedpar.sched_priority = dat;\n\t\tret = sched_setscheduler(threads[tid], sched_fifo, &schedpar);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase rttest_signal:\n\t\tsend_sig(sighup, threads[tid], 0);\n\t\tbreak;\n\n\tdefault:\n\t\tif (td->": 4631, "< 1)\n\t\tse = cfs_rq->": 4632, "< 1) {\n\t\t\t\tj = 1;\n\t\t\t\tjiffies_till_next_fqs = 1;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\trcu_gp_cleanup(rsp);\n\t}\n}\n\n\nstatic bool\nrcu_start_gp_advanced(struct rcu_state *rsp, struct rcu_node *rnp,\n\t\t      struct rcu_data *rdp)\n{\n\tif (!rsp->": 4633, "< 1) {\n\t\ts->": 4634, "< 1)) {\n\t\terr = -einval;\n\t\tgoto exit;\n\t}\n\n\tif (count >": 4635, "< 1);\n\tput_cred(new);\n}\nexport_symbol(abort_creds);\n\n\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->": 4636, "< 1);\n\n\tget_cred(new); \n\n\t\n\tif (!uid_eq(old->": 4637, "< 1);\n}\n\nstatic const struct fsnotify_ops audit_tree_ops = {\n\t.handle_event = audit_tree_handle_event,\n\t.freeing_mark = audit_tree_freeing_mark,\n};\n\nstatic int __init audit_tree_init(void)\n{\n\tint i;\n\n\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops);\n\tif (is_err(audit_tree_group))\n\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");\n\n\tfor (i = 0; i < hash_size; i++)\n\t\tinit_list_head(&chunk_hash_heads[i]);\n\n\treturn 0;\n}\n__initcall(audit_tree_init);\n\n#include <linux/bpf.h>": 4638, "< 10 &&\n\t\t    (local_softirq_pending() & softirq_stop_idle_mask)) {\n\t\t\tpr_warn(\"nohz: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t\n\t\tif (tick_do_timer_cpu == tick_do_timer_none)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void __tick_nohz_idle_enter(struct tick_sched *ts)\n{\n\tktime_t now, expires;\n\tint cpu = smp_processor_id();\n\n\tnow = tick_nohz_start_idle(ts);\n\n\tif (can_stop_idle_tick(cpu, ts)) {\n\t\tint was_stopped = ts->": 4639, "< 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"cpu%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\tirq_lock_sparse();\n\tdesc = irq_to_desc(i);\n\tif (!desc)\n\t\tgoto outsparse;\n\n\traw_spin_lock_irqsave(&desc->": 4640, "< 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, benchmark_event_strlen,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}\n\nstatic int benchmark_event_kthread(void *arg)\n{\n\t\n\tmsleep(100);\n\n\twhile (!kthread_should_stop()) {\n\n\t\ttrace_do_benchmark();\n\n\t\t\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\n\nvoid trace_benchmark_reg(void)\n{\n\tbm_event_thread = kthread_run(benchmark_event_kthread,\n\t\t\t\t      null, \"event_benchmark\");\n\twarn_on(!bm_event_thread);\n}\n\n\nvoid trace_benchmark_unreg(void)\n{\n\tif (!bm_event_thread)\n\t\treturn;\n\n\tkthread_stop(bm_event_thread);\n\n\tstrcpy(bm_str, \"start\");\n\tbm_total = 0;\n\tbm_totalsq = 0;\n\tbm_last = 0;\n\tbm_max = 0;\n\tbm_min = 0;\n\tbm_cnt = 0;\n\t\n\tbm_first = 0;\n\tbm_std = 0;\n\tbm_avg = 0;\n\tbm_stddev = 0;\n}\n\n#include <linux/proc_fs.h>": 4641, "< 10) {\n\t\t\tudelay(trycount * num_online_cpus());\n\t\t} else {\n\t\t\tput_online_cpus();\n\t\t\twait_rcu_gp(call_rcu);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ulong_cmp_lt(snap, access_once(sync_rcu_preempt_exp_count))) {\n\t\tput_online_cpus();\n\t\tgoto unlock_mb_ret; \n\t}\n\n\t\n\tsynchronize_sched_expedited();\n\n\t\n\trcu_for_each_leaf_node(rsp, rnp)\n\t\tsync_rcu_preempt_exp_init1(rsp, rnp);\n\trcu_for_each_leaf_node(rsp, rnp)\n\t\tsync_rcu_preempt_exp_init2(rsp, rnp);\n\n\tput_online_cpus();\n\n\t\n\trnp = rcu_get_root(rsp);\n\twait_event(sync_rcu_preempt_exp_wq,\n\t\t   sync_rcu_preempt_exp_done(rnp));\n\n\t\n\tsmp_mb(); \n\taccess_once(sync_rcu_preempt_exp_count) =\n\t\t\t\t\tsync_rcu_preempt_exp_count + 1;\nunlock_mb_ret:\n\tmutex_unlock(&sync_rcu_preempt_exp_mutex);\nmb_ret:\n\tsmp_mb(); \n}\nexport_symbol_gpl(synchronize_rcu_expedited);\n\n\nvoid rcu_barrier(void)\n{\n\t_rcu_barrier(&rcu_preempt_state);\n}\nexport_symbol_gpl(rcu_barrier);\n\n\nstatic void __init __rcu_init_preempt(void)\n{\n\trcu_init_one(&rcu_preempt_state, &rcu_preempt_data);\n}\n\n\nvoid exit_rcu(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (likely(list_empty(&current->": 4642, "< 10) {\n\t\t\tudelay(trycount * num_online_cpus());\n\t\t} else {\n\t\t\twait_rcu_gp(call_rcu_sched);\n\t\t\tatomic_long_inc(&rsp->": 4643, "< 100000))\n\t\treturn;\n\n\tdesc->": 4644, "< 10; spincnt++) {\n\t\ttrace_rcu_utilization(tps(\"start cpu kthread@rcu_wait\"));\n\t\tlocal_bh_disable();\n\t\t*statusp = rcu_kthread_running;\n\t\tthis_cpu_inc(rcu_cpu_kthread_loops);\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_kthread_do_work();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(tps(\"end cpu kthread@rcu_wait\"));\n\t\t\t*statusp = rcu_kthread_waiting;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = rcu_kthread_yielding;\n\ttrace_rcu_utilization(tps(\"start cpu kthread@rcu_yield\"));\n\tschedule_timeout_interruptible(2);\n\ttrace_rcu_utilization(tps(\"end cpu kthread@rcu_yield\"));\n\t*statusp = rcu_kthread_waiting;\n}\n\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n\tstruct task_struct *t = rnp->": 4645, "< 128 || log_size >": 4646, "< 16 && !(desc->": 4647, "< 16 && !env->": 4648, "< 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->": 4649, "< 2 && rq->": 4650, "< 2 ? 2 : trycount;\n\tif (!try_check_zero(sp, idx^1, trycount))\n\t\treturn; \n\n\t\n\trcu_batch_move(&sp->": 4651, "< 2 ||\n\t     curr->": 4652, "< 2 ||\n\t     rq->": 4653, "< 2)\n\t\tnr_pages = 2;\n\n\t\n#ifdef config_hotplug_cpu\n\tcpu_notifier_register_begin();\n\tcpumask_copy(buffer->": 4654, "< 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t\n\taction = desc->": 4655, "< 2)\n\t\treturn kdb_argcount;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, null);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg >": 4656, "< 2) {\n\t\tpr_info(\"probe point is not specified.\\n\");\n\t\treturn -einval;\n\t}\n\tif (isdigit(argv[1][0])) {\n\t\tif (is_return) {\n\t\t\tpr_info(\"return probe point must be a symbol.\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t\t\n\t\tret = kstrtoul(&argv[1][0], 0, (unsigned long *)&addr);\n\t\tif (ret) {\n\t\t\tpr_info(\"failed to parse address.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t\n\t\tsymbol = argv[1];\n\t\t\n\t\tret = traceprobe_split_symbol_offset(symbol, &offset);\n\t\tif (ret) {\n\t\t\tpr_info(\"failed to parse symbol.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (offset && is_return) {\n\t\t\tpr_info(\"return probe must be used without offset.\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t}\n\targc -= 2; argv += 2;\n\n\t\n\tif (!event) {\n\t\t\n\t\tif (symbol)\n\t\t\tsnprintf(buf, max_event_name_len, \"%c_%s_%ld\",\n\t\t\t\t is_return ? 'r' : 'p', symbol, offset);\n\t\telse\n\t\t\tsnprintf(buf, max_event_name_len, \"%c_0x%p\",\n\t\t\t\t is_return ? 'r' : 'p', addr);\n\t\tevent = buf;\n\t}\n\ttk = alloc_trace_kprobe(group, event, addr, symbol, offset, argc,\n\t\t\t       is_return);\n\tif (is_err(tk)) {\n\t\tpr_info(\"failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)ptr_err(tk));\n\t\treturn ptr_err(tk);\n\t}\n\n\t\n\tret = 0;\n\tfor (i = 0; i < argc && i < max_trace_args; i++) {\n\t\tstruct probe_arg *parg = &tk->": 4657, "< 2) {\n\t\tpr_info(\"probe point is not specified.\\n\");\n\t\treturn -einval;\n\t}\n\tif (isdigit(argv[1][0])) {\n\t\tpr_info(\"probe point must be have a filename.\\n\");\n\t\treturn -einval;\n\t}\n\targ = strchr(argv[1], ':');\n\tif (!arg) {\n\t\tret = -einval;\n\t\tgoto fail_address_parse;\n\t}\n\n\t*arg++ = '\\0';\n\tfilename = argv[1];\n\tret = kern_path(filename, lookup_follow, &path);\n\tif (ret)\n\t\tgoto fail_address_parse;\n\n\tinode = igrab(d_inode(path.dentry));\n\tpath_put(&path);\n\n\tif (!inode || !s_isreg(inode->": 4658, "< 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tbug_on(atomic_read(&new->": 4659, "< 256 ? hash_small : 0,\n\t\t\t\t\t       &futex_shift, null,\n\t\t\t\t\t       futex_hashsize, futex_hashsize);\n\tfutex_hashsize = 1ul << futex_shift;\n\n\tfutex_detect_cmpxchg();\n\n\tfor (i = 0; i < futex_hashsize; i++) {\n\t\tatomic_set(&futex_queues[i].waiters, 0);\n\t\tplist_head_init(&futex_queues[i].chain);\n\t\tspin_lock_init(&futex_queues[i].lock);\n\t}\n\n\treturn 0;\n}\n__initcall(futex_init);\n\n\n\n\n#include <linux/compiler.h>": 4660, "< 256)\n\t\t\treturn expires;\n\n\t\texpires_limit = expires + delta / 256;\n\t}\n\tmask = expires ^ expires_limit;\n\tif (mask == 0)\n\t\treturn expires;\n\n\tbit = find_last_bit(&mask, bits_per_long);\n\n\tmask = (1ul << bit) - 1;\n\n\texpires_limit = expires_limit & ~(mask);\n\n\treturn expires_limit;\n}\n\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\texpires = apply_slack(timer, expires);\n\n\t\n\tif (timer_pending(timer) && timer->": 4661, "< 2; i++) {\n\t\t\tunsigned long nr_faults = -1;\n\t\t\tint cpu_current, home_node;\n\n\t\t\tif (p->": 4662, "< 3) {\n\t\taccess_once(rcu_cpu_stall_timeout) = 3;\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check >": 4663, "< 31; n++)\n\t\t\tif (audit_tree_match(p->": 4664, "< 32)\n\t\t\t\t\tmask |= 1 << i;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->": 4665, "< 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tcmd_buflen);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tcmd_buflen);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % kdb_cmd_history_count;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % kdb_cmd_history_count;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == kdb_notfound) {\n\t\t\tkdb_printf(\"unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == kdb_cmd_go\n\t\t || diag == kdb_cmd_cpu\n\t\t || diag == kdb_cmd_ss\n\t\t || diag == kdb_cmd_kgdb)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tkdb_debug_state(\"kdb_local 9\", diag);\n\treturn diag;\n}\n\n\n\nvoid kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}\n\n\nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t\n\twhile (1) {\n\t\t\n\t\tkdb_debug_state(\"kdb_main_loop 1\", reason);\n\t\twhile (kdb_state(hold_cpu)) {\n\t\t\t\n\t\t\tif (!kdb_state(kdb))\n\t\t\t\tkdb_state_set(kdb);\n\t\t}\n\n\t\tkdb_state_clear(suppress);\n\t\tkdb_debug_state(\"kdb_main_loop 2\", reason);\n\t\tif (kdb_state(leaving))\n\t\t\tbreak;\t\n\t\t\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tkdb_debug_state(\"kdb_main_loop 3\", result);\n\n\t\tif (result == kdb_cmd_cpu)\n\t\t\tbreak;\n\n\t\tif (result == kdb_cmd_ss) {\n\t\t\tkdb_state_set(doing_ss);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == kdb_cmd_kgdb) {\n\t\t\tif (!kdb_state(doing_kgdb))\n\t\t\t\tkdb_printf(\"entering please attach debugger \"\n\t\t\t\t\t   \"or use $d#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != kdb_cmd_go)\n\t\t\tkdb_printf(\"\\nunexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tkdb_debug_state(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (kdb_state(doing_ss))\n\t\tkdb_state_clear(ssbpt);\n\n\t\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}\n\n\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}\n\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__big_endian\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}\n\nstatic int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = kdb_word_size, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\n\tkdbgetintenv(\"mdcount\", &mdcount);\n\tkdbgetintenv(\"radix\", &radix);\n\tkdbgetintenv(\"bytesperword\", &bytesperword);\n\n\t\n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc != 2)\n\t\t\treturn kdb_argcount;\n\t\tvalid = 1;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn kdb_notfound;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn kdb_argcount;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, null);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc >": 4666, "< 32; bin++) {\n\t\tif (sleep_time_bin[bin] == 0)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"%10u - %-10u %4u\\n\",\n\t\t\tbin ? 1 << (bin - 1) : 0, 1 << bin,\n\t\t\t\tsleep_time_bin[bin]);\n\t}\n\treturn 0;\n}\n\nstatic int tk_debug_sleep_time_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, tk_debug_show_sleep_time, null);\n}\n\nstatic const struct file_operations tk_debug_sleep_time_fops = {\n\t.open\t\t= tk_debug_sleep_time_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init tk_debug_sleep_time_init(void)\n{\n\tstruct dentry *d;\n\n\td = debugfs_create_file(\"sleep_time\", 0444, null, null,\n\t\t&tk_debug_sleep_time_fops);\n\tif (!d) {\n\t\tpr_err(\"failed to create sleep_time debug file\\n\");\n\t\treturn -enomem;\n\t}\n\n\treturn 0;\n}\nlate_initcall(tk_debug_sleep_time_init);\n\nvoid tk_debug_account_sleep_time(struct timespec64 *t)\n{\n\tsleep_time_bin[fls(t->": 4667, "< 34\n#define jiffies_shift\t6\n#elif hz < 67\n#define jiffies_shift\t7\n#else\n#define jiffies_shift\t8\n#endif\n\nstatic cycle_t jiffies_read(struct clocksource *cs)\n{\n\treturn (cycle_t) jiffies;\n}\n\nstatic struct clocksource clocksource_jiffies = {\n\t.name\t\t= \"jiffies\",\n\t.rating\t\t= 1, \n\t.read\t\t= jiffies_read,\n\t.mask\t\t= 0xffffffff, \n\t.mult\t\t= nsec_per_jiffy << jiffies_shift, \n\t.shift\t\t= jiffies_shift,\n\t.max_cycles\t= 10,\n};\n\n__cacheline_aligned_in_smp define_seqlock(jiffies_lock);\n\n#if (bits_per_long < 64)\nu64 get_jiffies_64(void)\n{\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tret = jiffies_64;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\treturn ret;\n}\nexport_symbol(get_jiffies_64);\n#endif\n\nexport_symbol(jiffies);\n\nstatic int __init init_jiffies_clocksource(void)\n{\n\treturn __clocksource_register(&clocksource_jiffies);\n}\n\ncore_initcall(init_jiffies_clocksource);\n\nstruct clocksource * __init __weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}\n\nstruct clocksource refined_jiffies;\n\nint register_refined_jiffies(long cycles_per_second)\n{\n\tu64 nsec_per_tick, shift_hz;\n\tlong cycles_per_tick;\n\n\n\n\trefined_jiffies = clocksource_jiffies;\n\trefined_jiffies.name = \"refined-jiffies\";\n\trefined_jiffies.rating++;\n\n\t\n\tcycles_per_tick = (cycles_per_second + hz/2)/hz;\n\t\n\tshift_hz = (u64)cycles_per_second << 8;\n\tshift_hz += cycles_per_tick/2;\n\tdo_div(shift_hz, cycles_per_tick);\n\t\n\tnsec_per_tick = (u64)nsec_per_sec << 8;\n\tnsec_per_tick += (u32)shift_hz/2;\n\tdo_div(nsec_per_tick, (u32)shift_hz);\n\n\trefined_jiffies.mult = ((u32)nsec_per_tick) << jiffies_shift;\n\n\t__clocksource_register(&refined_jiffies);\n\treturn 0;\n}\n\n\n#define pr_fmt(fmt) \"genirq: \" fmt\n\n#include <linux/irq.h>": 4668, "< 3; i++) {\n\t\tdo {\n\t\t\tif (rb_is_head_page(cpu_buffer, page, page->": 4669, "< 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->": 4670, "< 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, gfp_atomic);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->": 4671, "< 4; array++) {\n\t\tstruct tvec *varp = varray[array];\n\n\t\tindex = slot = timer_jiffies & tvn_mask;\n\t\tdo {\n\t\t\tlist_for_each_entry(nte, varp->": 4672, "< 5) {\n\t\t\tprintk(kern_err\n\t\t\t       \"request_module: runaway loop modprobe %s\\n\",\n\t\t\t       module_name);\n\t\t\tkmod_loop_msg++;\n\t\t}\n\t\tatomic_dec(&kmod_concurrent);\n\t\treturn -enomem;\n\t}\n\n\ttrace_module_request(module_name, wait, _ret_ip_);\n\n\tret = call_modprobe(module_name, wait ? umh_wait_proc : umh_wait_exec);\n\n\tatomic_dec(&kmod_concurrent);\n\treturn ret;\n}\nexport_symbol(__request_module);\n#endif \n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->": 4673, "< 5000)\n\t\tdev->": 4674, "< 64\n\tif (seconds >": 4675, "< 64\n\treturn rlim64 >": 4676, "< 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8ul - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str);\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t\n\tfor (i = len; i < 7; i++)\n\t\ttrace_seq_putc(s, ' ');\n}\n\nstatic void\nprint_graph_duration(unsigned long long duration, struct trace_seq *s,\n\t\t     u32 flags)\n{\n\tif (!(flags & trace_graph_print_duration) ||\n\t    !(trace_flags & trace_iter_context_info))\n\t\treturn;\n\n\t\n\tswitch (flags & trace_graph_print_fill_mask) {\n\tcase flags_fill_full:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase flags_fill_start:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase flags_fill_end:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t\n\tif (flags & trace_graph_print_overhead)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}\n\n\nstatic enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->": 4677, "< 7; i++) {\n\t\tpci_resource_to_user(dev, i, &dev->": 4678, "< 8 * usec_per_msec)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tdo_gettimeofday(&end);\n\telapsed_msecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);\n\tdo_div(elapsed_msecs64, nsec_per_msec);\n\telapsed_msecs = elapsed_msecs64;\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (!wakeup) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -ebusy : 0;\n}\n\n\nint freeze_processes(void)\n{\n\tint error;\n\n\terror = __usermodehelper_disable(umh_freezing);\n\tif (error)\n\t\treturn error;\n\n\t\n\tcurrent->": 4679, "< __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n\n\tif (kdb_debug(mask))\n\t\tkdb_printf(\"kdbflags=0x%x\\n\", kdb_flags);\n\n\treturn 0;\n}\n\n#ifdef config_printk\n\nstatic int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dumper dumper = { .active = 1 };\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc >": 4680, "< __stop___modver; p++) {\n\t\tconst struct module_version_attribute *vattr = *p;\n\n\t\tmk = locate_module_kobject(vattr->": 4681, "< __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->": 4682, "< _kernel_capability_u32s; i++)  {\n\t\tif (table->": 4683, "< _nsig; ++i)\n\t\tt->": 4684, "< _nsig_words; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_nsig_bpw + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _nsig_bpw + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t\n\t\tbreak;\n\t}\n\n\treturn sig;\n}\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic define_ratelimit_state(ratelimit_state, 5 * hz, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tprintk(kern_info \"%s/%d: reached rlimit_sigpending, dropped signal %d\\n\",\n\t\t\t\tcurrent->": 4685, "< a->": 4686, "< active ; i++)\n\t\tvfree(info->": 4687, "< active ; i++) {\n\t\tstruct gcov_ctr_info *ctr = &info->": 4688, "< active->": 4689, "< active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->": 4690, "< active; ct_idx++, ci_ptr++)\n\t\t\tvfree(ci_ptr->": 4691, "< addr)\n\t\t\tcontinue;\n\t\tif (p->": 4692, "< addr)\n\t\t\tcontinue;\n\t\tif (pfn_down(p->": 4693, "< alarm_numtype; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->": 4694, "< alarm_numtype; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\tpdev = platform_device_register_simple(\"alarmtimer\", -1, null, 0);\n\tif (is_err(pdev)) {\n\t\terror = ptr_err(pdev);\n\t\tgoto out_drv;\n\t}\n\tws = wakeup_source_register(\"alarmtimer\");\n\treturn 0;\n\nout_drv:\n\tplatform_driver_unregister(&alarmtimer_driver);\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}\ndevice_initcall(alarmtimer_init);\n\n#include <linux/completion.h>": 4695, "< align)\n\t\t\t\tbuf_align = align;\n\t\t\tbuf_sz = align(buf_sz, align);\n\t\t\tbuf_sz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\t\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = align(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\n\t\n\tbss_pad = 0;\n\tif (buf_sz & (bss_align - 1))\n\t\tbss_pad = bss_align - (buf_sz & (bss_align - 1));\n\n\tmemsz = buf_sz + bss_pad + bss_sz;\n\n\t\n\tpurgatory_buf = vzalloc(buf_sz);\n\tif (!purgatory_buf) {\n\t\tret = -enomem;\n\t\tgoto out;\n\t}\n\n\tif (buf_align < bss_align)\n\t\tbuf_align = bss_align;\n\n\t\n\tret = kexec_add_buffer(image, purgatory_buf, buf_sz, memsz,\n\t\t\t\tbuf_align, min, max, top_down,\n\t\t\t\t&pi->": 4696, "< alloc) {\n\t\t\n\t\talloc -= pages;\n\t\tpages += pages_highmem;\n\t\tpages_highmem = preallocate_image_highmem(alloc);\n\t\tif (pages_highmem < alloc)\n\t\t\tgoto err_out;\n\t\tpages += pages_highmem;\n\t\t\n\t\talloc = (count - pages) - size;\n\t\tpages += preallocate_image_highmem(alloc);\n\t} else {\n\t\t\n\t\talloc = max_size - size;\n\t\tsize = preallocate_highmem_fraction(alloc, highmem, count);\n\t\tpages_highmem += size;\n\t\talloc -= size;\n\t\tsize = preallocate_image_memory(alloc, avail_normal);\n\t\tpages_highmem += preallocate_image_highmem(alloc - size);\n\t\tpages += pages_highmem + size;\n\t}\n\n\t\n\tpages -= free_unnecessary_pages();\n\n out:\n\tstop = ktime_get();\n\tprintk(kern_cont \"done (allocated %lu pages)\\n\", pages);\n\tswsusp_show_speed(start, stop, pages, \"allocated\");\n\n\treturn 0;\n\n err_out:\n\tprintk(kern_cont \"\\n\");\n\tswsusp_free();\n\treturn -enomem;\n}\n\n#ifdef config_highmem\n\n\nstatic unsigned int count_pages_for_highmem(unsigned int nr_highmem)\n{\n\tunsigned int free_highmem = count_free_highmem_pages() + alloc_highmem;\n\n\tif (free_highmem >": 4697, "< arg.nr; ) {\n\t\tsiginfo_t info;\n\t\ts32 off = arg.off + i;\n\n\t\tspin_lock_irq(&child->": 4698, "< argc && i < max_trace_args; i++) {\n\t\tstruct probe_arg *parg = &tu->": 4699, "< array_size(arr); i++) {\n\t\tfor (s = arr[i].sym; s < arr[i].sym + arr[i].num; s++) {\n\t\t\tif (find_symbol(s->": 4700, "< array_size(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >": 4701, "< array_size(kdb_name_table); ++i) {\n\t\tif (kdb_name_table[i]) {\n\t\t\tdebug_kfree(kdb_name_table[i]);\n\t\t\tkdb_name_table[i] = null;\n\t\t}\n\t}\n}\n\nstatic char ks_namebuf[ksym_name_len+1], ks_namebuf_prev[ksym_name_len+1];\n\n\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrcpy(ks_namebuf, name);\n\t\t\t\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len >": 4702, "< array_size(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == array_size(mask_maps)) {\n\t\t\tmask = -einval;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}\n\nstatic ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < array_size(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}\n\nstatic struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->": 4703, "< array_size(masks); ++m) {\n\t\tfor (i = 0; i < info->": 4704, "< array_size(offsets); i++) {\n\t\tu64 val = *(u64 *)((char *)prctl_map + offsets[i]);\n\n\t\tif ((unsigned long)val >": 4705, "< array_size(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid traceprobe_update_arg(struct probe_arg *arg)\n{\n\tif (check_fetch_funcs(bitfield, arg->": 4706, "< array_size(stats.bounces); i++)\n\t\t\tstats.bounces[i] += pcs->": 4707, "< array_size(stats.contending_point); i++)\n\t\t\tstats.contending_point[i] += pcs->": 4708, "< array_size(stats.contention_point); i++)\n\t\t\tstats.contention_point[i] += pcs->": 4709, "< array_size(tnts); i++) {\n\t\t\tconst struct tnt *t = &tnts[i];\n\t\t\t*s++ = test_bit(t->": 4710, "< array_size(torture_ops); i++)\n\t\t\tpr_alert(\" %s\", torture_ops[i]->": 4711, "< array_size(torture_ops); i++) {\n\t\tcur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cur_ops->": 4712, "< arrsize; j++) {\n\t\tif (fn(&arr[j], owner, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nbool each_symbol_section(bool (*fn)(const struct symsearch *arr,\n\t\t\t\t    struct module *owner,\n\t\t\t\t    void *data),\n\t\t\t void *data)\n{\n\tstruct module *mod;\n\tstatic const struct symsearch arr[] = {\n\t\t{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,\n\t\t  not_gpl_only, false },\n\t\t{ __start___ksymtab_gpl, __stop___ksymtab_gpl,\n\t\t  __start___kcrctab_gpl,\n\t\t  gpl_only, false },\n\t\t{ __start___ksymtab_gpl_future, __stop___ksymtab_gpl_future,\n\t\t  __start___kcrctab_gpl_future,\n\t\t  will_be_gpl_only, false },\n#ifdef config_unused_symbols\n\t\t{ __start___ksymtab_unused, __stop___ksymtab_unused,\n\t\t  __start___kcrctab_unused,\n\t\t  not_gpl_only, true },\n\t\t{ __start___ksymtab_unused_gpl, __stop___ksymtab_unused_gpl,\n\t\t  __start___kcrctab_unused_gpl,\n\t\t  gpl_only, true },\n#endif\n\t};\n\n\tif (each_symbol_in_section(arr, array_size(arr), null, fn, data))\n\t\treturn true;\n\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct symsearch arr[] = {\n\t\t\t{ mod->": 4713, "< attr->": 4714, "< audit_backlog_limit))\n\t\tskb_queue_tail(&audit_skb_hold_queue, skb);\n\telse\n\t\tkfree_skb(skb);\n}\n\n\nstatic void audit_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->": 4715, "< audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}\n\n\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch(f->": 4716, "< audit_bitmask_size; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->": 4717, "< audit_bitmask_size; i++)\n\t\tentry->": 4718, "< audit_bitmask_size; i++)\n\t\tif (a->": 4719, "< audit_bitmask_size; i++)\n\t\tnew->": 4720, "< audit_bitmask_size; i++) data->": 4721, "< audit_bitmask_size; j++)\n\t\t\t\tentry->": 4722, "< audit_inode_buckets; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->": 4723, "< audit_inode_buckets; i++)\n\t\tinit_list_head(&audit_inode_hash[i]);\n\n\treturn 0;\n}\n__initcall(audit_init);\n\n\nstatic int __init audit_enable(char *str)\n{\n\taudit_default = !!simple_strtol(str, null, 0);\n\tif (!audit_default)\n\t\taudit_initialized = audit_disabled;\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}\n__setup(\"audit=\", audit_enable);\n\n\nstatic int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}\n__setup(\"audit_backlog_limit=\", audit_backlog_limit_set);\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tunsigned long flags;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (ab->": 4724, "< audit_names) {\n\t\taname = &context->": 4725, "< audit_nr_filters; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}\n\n#include <linux/sched.h>": 4726, "< audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed >": 4727, "< audit_syscall_classes; i++) {\n\t\tint bit = audit_bitmask_size * 32 - i - 1;\n\t\t__u32 *p = &entry->": 4728, "< aux->": 4729, "< axs->": 4730, "< az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tsort(range, nr_range, sizeof(struct range), cmp_range, null);\n\n\treturn nr_range;\n}\n\nvoid sort_range(struct range *range, int nr_range)\n{\n\t\n\tsort(range, nr_range, sizeof(struct range), cmp_range, null);\n}\n\n#include <linux/spinlock.h>": 4731, "< az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >": 4732, "< b->": 4733, "< bc->": 4734, "< best->": 4735, "< bits) {\n\t\t\tpfn = bm->": 4736, "< bits_per_page)\n\t\t\treturn mk_pid(pid_ns, map, offset);\n\t}\n\treturn -1;\n}\n\nvoid put_pid(struct pid *pid)\n{\n\tstruct pid_namespace *ns;\n\n\tif (!pid)\n\t\treturn;\n\n\tns = pid->": 4737, "< bits_to_longs(bitmap_size); i++) {\n\t\tm = 0;\n\n\t\tfor (j = 0; j < sizeof(m)/sizeof(um); j++) {\n\t\t\t\n\t\t\tif (nr_compat_longs-- >": 4738, "< bm_min)\n\t\tbm_min = delta;\n\n\t\n\tif (bm_cnt >": 4739, "< bpf_reg_size; i++)\n\t\t\tstate->": 4740, "< bpf_reg_size; i++) {\n\t\t\tif (slot_type[i] != stack_spill) {\n\t\t\t\tverbose(\"corrupted spill memory\\n\");\n\t\t\t\treturn -eacces;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >": 4741, "< buf_len; i++)\n\t\ttrace_seq_printf(p, \"%s%2.2x\", i == 0 ? \"\" : \" \", buf[i]);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nexport_symbol(ftrace_print_hex_seq);\n\nconst char *\nftrace_print_array_seq(struct trace_seq *p, const void *buf, int count,\n\t\t       size_t el_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *prefix = \"\";\n\tvoid *ptr = (void *)buf;\n\tsize_t buf_len = count * el_size;\n\n\ttrace_seq_putc(p, '{');\n\n\twhile (ptr < buf + buf_len) {\n\t\tswitch (el_size) {\n\t\tcase 1:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u16 *)ptr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u32 *)ptr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttrace_seq_printf(p, \"%s0x%llx\", prefix,\n\t\t\t\t\t *(u64 *)ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_seq_printf(p, \"bad size:%zu 0x%x\", el_size,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tel_size = 1;\n\t\t}\n\t\tprefix = \",\";\n\t\tptr += el_size;\n\t}\n\n\ttrace_seq_putc(p, '}');\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nexport_symbol(ftrace_print_array_seq);\n\nint ftrace_raw_output_prep(struct trace_iterator *iter,\n\t\t\t   struct trace_event *trace_event)\n{\n\tstruct ftrace_event_call *event;\n\tstruct trace_seq *s = &iter->": 4742, "< buf_page_size * 2)\n\t\tsize = buf_page_size * 2;\n\n\tnr_pages = div_round_up(size, buf_page_size);\n\n\t\n\tif (atomic_read(&buffer->": 4743, "< buf_page_size)\n\t\tmemset(&bpage->": 4744, "< buflen)\n\t\t\tpath = buf;\n\t}\n\n\tup_read(&css_set_rwsem);\n\tmutex_unlock(&cgroup_mutex);\n\treturn path;\n}\nexport_symbol_gpl(task_cgroup_path);\n\n\nstruct cgroup_taskset {\n\t\n\tstruct list_head\tsrc_csets;\n\tstruct list_head\tdst_csets;\n\n\t\n\tstruct list_head\t*csets;\n\tstruct css_set\t\t*cur_cset;\n\tstruct task_struct\t*cur_task;\n};\n\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset)\n{\n\ttset->": 4745, "< busiest->": 4746, "< c->": 4747, "< call->": 4748, "< caller_saved_regs; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->": 4749, "< calltime)\n\t\t\tcalltime -= current->": 4750, "< capacity_of(env->": 4751, "< cbflood_n_burst; i++) {\n\t\t\tfor (j = 0; j < cbflood_n_per_burst; j++) {\n\t\t\t\tcur_ops->": 4752, "< cfs_rq->": 4753, "< cgroup_subsys_count; (ssid)++)\t\\\n\t\tif (!((css) = cgroup_e_css(cgrp, cgroup_subsys[(ssid)]))) \\\n\t\t\t;\t\t\t\t\t\t\\\n\t\telse\n\n\n#define for_each_subsys(ss, ssid)\t\t\t\t\t\\\n\tfor ((ssid) = 0; (ssid) < cgroup_subsys_count &&\t\t\\\n\t     (((ss) = cgroup_subsys[ssid]) || true); (ssid)++)\n\n\n#define for_each_root(root)\t\t\t\t\t\t\\\n\tlist_for_each_entry((root), &cgroup_roots, root_list)\n\n\n#define cgroup_for_each_live_child(child, cgrp)\t\t\t\t\\\n\tlist_for_each_entry((child), &(cgrp)->": 4754, "< cgroup_subsys_count; (ssid)++)\t\\\n\t\tif (!((css) = rcu_dereference_check(\t\t\t\\\n\t\t\t\t(cgrp)->": 4755, "< chain->": 4756, "< chainhash_size; i++)\n\t\tinit_list_head(chainhash_table + i);\n\traw_local_irq_restore(flags);\n}\n\nstatic void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t\n\tlist_del_rcu(&class->": 4757, "< chunk->": 4758, "< ci_ptr->": 4759, "< classhash_size; i++)\n\t\tinit_list_head(classhash_table + i);\n\n\tfor (i = 0; i < chainhash_size; i++)\n\t\tinit_list_head(chainhash_table + i);\n\n\tlockdep_initialized = 1;\n}\n\nvoid __init lockdep_info(void)\n{\n\tprintk(\"lock dependency validator: copyright (c) 2006 red hat, inc., ingo molnar\\n\");\n\n\tprintk(\"... max_lockdep_subclasses:  %lu\\n\", max_lockdep_subclasses);\n\tprintk(\"... max_lock_depth:          %lu\\n\", max_lock_depth);\n\tprintk(\"... max_lockdep_keys:        %lu\\n\", max_lockdep_keys);\n\tprintk(\"... classhash_size:          %lu\\n\", classhash_size);\n\tprintk(\"... max_lockdep_entries:     %lu\\n\", max_lockdep_entries);\n\tprintk(\"... max_lockdep_chains:      %lu\\n\", max_lockdep_chains);\n\tprintk(\"... chainhash_size:          %lu\\n\", chainhash_size);\n\n\tprintk(\" memory used by lock dependency info: %lu kb\\n\",\n\t\t(sizeof(struct lock_class) * max_lockdep_keys +\n\t\tsizeof(struct list_head) * classhash_size +\n\t\tsizeof(struct lock_list) * max_lockdep_entries +\n\t\tsizeof(struct lock_chain) * max_lockdep_chains +\n\t\tsizeof(struct list_head) * chainhash_size\n#ifdef config_prove_locking\n\t\t+ sizeof(struct circular_queue)\n#endif\n\t\t) / 1024\n\t\t);\n\n\tprintk(\" per task-struct memory footprint: %lu bytes\\n\",\n\t\tsizeof(struct held_lock) * max_lock_depth);\n\n#ifdef config_debug_lockdep\n\tif (lockdep_init_error) {\n\t\tprintk(\"warning: lockdep init error! lock-%s was acquired\"\n\t\t\t\"before lockdep_init\\n\", lock_init_error);\n\t\tprintk(\"call stack leading to lockdep invocation was:\\n\");\n\t\tprint_stack_trace(&lockdep_init_trace, 0);\n\t}\n#endif\n}\n\nstatic void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tprintk(\"\\n\");\n\tprintk(\"=========================\\n\");\n\tprintk(\"[ bug: held lock freed! ]\\n\");\n\tprint_kernel_ident();\n\tprintk(\"-------------------------\\n\");\n\tprintk(\"%s/%d is freeing memory %p-%p, with a lock still held there!\\n\",\n\t\tcurr->": 4760, "< cnt; i++)\n\t\tfree_desc(from + i);\n\n\tmutex_lock(&sparse_irq_lock);\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}\nexport_symbol_gpl(irq_free_descs);\n\n\nint __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -einval;\n\n\tif (irq >": 4761, "< cnt; i++) {\n\t\tdesc = alloc_desc(start + i, node, owner);\n\t\tif (!desc)\n\t\t\tgoto err;\n\t\tmutex_lock(&sparse_irq_lock);\n\t\tirq_insert_desc(start + i, desc);\n\t\tmutex_unlock(&sparse_irq_lock);\n\t}\n\treturn start;\n\nerr:\n\tfor (i--; i >": 4762, "< cnt; i++) {\n\t\tstruct irq_desc *desc = irq_to_desc(start + i);\n\n\t\tdesc->": 4763, "< commit && !kill_test; i += inc) {\n\n\t\t\tif (i >": 4764, "< context->": 4765, "< count) {\n\t\t\tpr_warning(\"line length is too long: \"\n\t\t\t\t   \"should be less than %d.\", write_bufsize);\n\t\t\tret = -einval;\n\t\t\tgoto out;\n\t\t}\n\t\tdone += size;\n\t\t\n\t\ttmp = strchr(kbuf, '#');\n\n\t\tif (tmp)\n\t\t\t*tmp = '\\0';\n\n\t\tret = traceprobe_command(kbuf, createfn);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}\n\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   bool is_return)\n{\n\tint i;\n\tint pos = 0;\n\n\tconst char *fmt, *arg;\n\n\tif (!is_return) {\n\t\tfmt = \"(%lx)\";\n\t\targ = \"rec->": 4766, "< count) {\n\t\tsize = count - done;\n\n\t\tif (size >": 4767, "< count; i++) {\n\t\tdesc[i].kstat_irqs = alloc_percpu(unsigned int);\n\t\talloc_masks(&desc[i], gfp_kernel, node);\n\t\traw_spin_lock_init(&desc[i].lock);\n\t\tlockdep_set_class(&desc[i].lock, &irq_desc_lock_class);\n\t\tdesc_set_defaults(i, &desc[i], node, null);\n\t}\n\treturn arch_early_irq_init();\n}\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < nr_irqs) ? irq_desc + irq : null;\n}\nexport_symbol(irq_to_desc);\n\nstatic void free_desc(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&desc->": 4768, "< count; i++) {\n\t\tinit_list_head(&chunk->": 4769, "< count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}\nexport_symbol_gpl(irq_domain_associate_many);\n\n\nunsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tunsigned int virq;\n\n\tif (domain == null)\n\t\tdomain = irq_default_domain;\n\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(domain->": 4770, "< count; i++) {\n\t\tlink = kzalloc(sizeof(*link), gfp_kernel);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -enomem;\n\t\t}\n\t\tlist_add(&link->": 4771, "< cp->": 4772, "< cpu)) {\n\t\tkick = true;\n\t\tgoto unlock;\n\t}\n\nunlock:\n\trcu_read_unlock();\n\treturn kick;\n}\n#else\nstatic void nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle) { }\n#endif\n\n\nstatic void run_rebalance_domains(struct softirq_action *h)\n{\n\tstruct rq *this_rq = this_rq();\n\tenum cpu_idle_type idle = this_rq->": 4773, "< cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->": 4774, "< cpu_load_idx_max; i++, scale += scale) {\n\t\tunsigned long old_load, new_load;\n\n\t\t\n\n\t\told_load = this_rq->": 4775, "< cpu_load_idx_max; j++)\n\t\t\trq->": 4776, "< cpu_max_idle_types;\n\t\t\t\t\titype++) {\n\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",\n\t\t\t\t    sd->": 4777, "< cpu_rq(target)->": 4778, "< cpumask_size())\n\t\tcpumask_clear(new_mask);\n\telse if (len >": 4779, "< cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}\n\nstatic inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}\n\n\n\n\nstatic noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n->": 4780, "< crashk_res.start) ||\n\t\t\t    (mend >": 4781, "< crashk_res.start) || (entry >": 4782, "< csn; i++)\n\t\tcsa[i]->": 4783, "< csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->": 4784, "< csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->": 4785, "< csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->": 4786, "< csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->": 4787, "< cur->": 4788, "< cur_dl_b->": 4789, "< curr->": 4790, "< curr_cost + sd->": 4791, "< cxt.nrealwriters_stress ||\n\t\t    j < cxt.nrealreaders_stress; i++, j++) {\n\t\tif (i >": 4792, "< cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = null;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = null;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  \n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"end of test: failure\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"end of test: lock_hotplug\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"end of test: success\");\n\ttorture_cleanup_end();\n}\n\nstatic int __init lock_torture_init(void)\n{\n\tint i, j;\n\tint firsterr = 0;\n\tstatic struct lock_torture_ops *torture_ops[] = {\n\t\t&lock_busted_ops,\n\t\t&spin_lock_ops, &spin_lock_irq_ops,\n\t\t&rw_lock_ops, &rw_lock_irq_ops,\n\t\t&mutex_lock_ops,\n\t\t&rwsem_lock_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose, &torture_runnable))\n\t\treturn -ebusy;\n\n\t\n\tfor (i = 0; i < array_size(torture_ops); i++) {\n\t\tcxt.cur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cxt.cur_ops->": 4793, "< cxt.nrealwriters_stress; i++) {\n\t\tcxt.lwsa[i].n_lock_fail = 0;\n\t\tcxt.lwsa[i].n_lock_acquired = 0;\n\t}\n\n\tif (cxt.cur_ops->": 4794, "< d->": 4795, "< dah_first) {\n\t\th->": 4796, "< dah_overhead)\n\t\tgoto out;\n\tif (rem >": 4797, "< data->": 4798, "< data[thr].unc_len; off += page_size) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, page_size);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tprintk(kern_info\n\t\t\t\t\t       \"pm: image loading progress: \"\n\t\t\t\t\t       \"%3d%%\\n\",\n\t\t\t\t\t       nr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->": 4799, "< data_cnt; i++) {\n\t\tstruct event_filter *filter = null;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(&event_ftrace_test_filter, d->": 4800, "< dbg_max_reg_num; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}\n\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < dbg_max_reg_num; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}\n#endif \n\n\nstatic int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) >": 4801, "< dbg_max_reg_num; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"error: register set currently not implemented\\n\");\n    return 0;\n#endif\n}\n\n#if defined(config_magic_sysrq)\n\nstatic int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(kdb_enable_all, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn kdb_argcount;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}\n#endif\t\n\n\nstatic int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn kdb_argcount;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, null);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}\n\n#if defined(config_modules)\n\nstatic int kdb_lsmod(int argc, const char **argv)\n{\n\tstruct module *mod;\n\n\tif (argc != 0)\n\t\treturn kdb_argcount;\n\n\tkdb_printf(\"module                  size  modstruct     used by\\n\");\n\tlist_for_each_entry(mod, kdb_modules, list) {\n\t\tif (mod->": 4802, "< dbg_max_reg_num; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize >": 4803, "< debug_alloc_pool ||\n\t    (char *)p >": 4804, "< defcmd_set_count; ++i, ++s) {\n\t\tif (strcmp(s->": 4805, "< delta)\n\t\t\t\t\tmax_offline = delta;\n\t\t\t}\n\t\t} else if (cpu_is_hotpluggable(cpu)) {\n\t\t\tif (verbose)\n\t\t\t\tpr_alert(\"%s\" torture_flag\n\t\t\t\t\t \"torture_onoff task: onlining %d\\n\",\n\t\t\t\t\t torture_type, cpu);\n\t\t\tstarttime = jiffies;\n\t\t\tn_online_attempts++;\n\t\t\tret = cpu_up(cpu);\n\t\t\tif (ret) {\n\t\t\t\tif (verbose)\n\t\t\t\t\tpr_alert(\"%s\" torture_flag\n\t\t\t\t\t\t \"torture_onoff task: online %d failed: errno %d\\n\",\n\t\t\t\t\t\t torture_type, cpu, ret);\n\t\t\t} else {\n\t\t\t\tif (verbose)\n\t\t\t\t\tpr_alert(\"%s\" torture_flag\n\t\t\t\t\t\t \"torture_onoff task: onlined %d\\n\",\n\t\t\t\t\t\t torture_type, cpu);\n\t\t\t\tn_online_successes++;\n\t\t\t\tdelta = jiffies - starttime;\n\t\t\t\tsum_online += delta;\n\t\t\t\tif (min_online < 0) {\n\t\t\t\t\tmin_online = delta;\n\t\t\t\t\tmax_online = delta;\n\t\t\t\t}\n\t\t\t\tif (min_online >": 4806, "< delta)\n\t\t\t\t\tmax_online = delta;\n\t\t\t}\n\t\t}\n\t\tschedule_timeout_interruptible(onoff_interval);\n\t}\n\ttorture_kthread_stopping(\"torture_onoff\");\n\treturn 0;\n}\n\n#endif \n\n\nint torture_onoff_init(long ooholdoff, long oointerval)\n{\n\tint ret = 0;\n\n#ifdef config_hotplug_cpu\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\tret = torture_create_kthread(torture_onoff, null, onoff_task);\n#endif \n\treturn ret;\n}\nexport_symbol_gpl(torture_onoff_init);\n\n\nstatic void torture_onoff_cleanup(void)\n{\n#ifdef config_hotplug_cpu\n\tif (onoff_task == null)\n\t\treturn;\n\tverbose_torout_string(\"stopping torture_onoff task\");\n\tkthread_stop(onoff_task);\n\tonoff_task = null;\n#endif \n}\nexport_symbol_gpl(torture_onoff_cleanup);\n\n\nvoid torture_onoff_stats(void)\n{\n#ifdef config_hotplug_cpu\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (hz=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, hz);\n#endif \n}\nexport_symbol_gpl(torture_onoff_stats);\n\n\nbool torture_onoff_failures(void)\n{\n#ifdef config_hotplug_cpu\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else \n\treturn false;\n#endif \n}\nexport_symbol_gpl(torture_onoff_failures);\n\n#define torture_random_mult\t39916801  \n#define torture_random_add\t479001701 \n#define torture_random_refresh\t10000\n\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->": 4807, "< delta_jiffies) {\n\t\t\tnext_jiffies = last_jiffies + rcu_delta_jiffies;\n\t\t\tdelta_jiffies = rcu_delta_jiffies;\n\t\t}\n\t}\n\n\t\n\tif (!ts->": 4808, "< depth; i++) {\n\t\thlock = curr->": 4809, "< depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(curr->": 4810, "< desc->": 4811, "< dev->": 4812, "< dist) {\n\t\t\t\t\tfaults += group_faults(p, b);\n\t\t\t\t\tnode_set(b, this_group);\n\t\t\t\t\tnode_clear(b, nodes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif (faults >": 4813, "< dl_b->": 4814, "< dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == audit_name_full ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}\n\nstatic int audit_filter_user_rules(struct audit_krule *rule, int type,\n\t\t\t\t   enum audit_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->": 4815, "< domain->": 4816, "< dst->": 4817, "< dst_load * src_capacity;\n\telse\n\t\t\n\t\treturn dst_load * src_capacity < src_load * dst_capacity;\n}\n\n\nstatic void task_numa_compare(struct task_numa_env *env,\n\t\t\t      long taskimp, long groupimp)\n{\n\tstruct rq *src_rq = cpu_rq(env->": 4818, "< e->": 4819, "< ehdr->": 4820, "< elen)\n\t\treturn null;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->": 4821, "< end) {\n\t\t\t\tnext_res = alloc_resource(gfp_atomic);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->": 4822, "< end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size >": 4823, "< end) {\n\t\t\tint mid = (index + end) / 2;\n\t\t\tif (cgroup_pid_fry(cgrp, l->": 4824, "< end) {\n\t\t\tp = &res->": 4825, "< end) {\n\t\t\n\t\tif (end - p < 4)\n\t\t\tgoto dodgy_cert;\n\t\tif (p[0] != 0x30 &&\n\t\t    p[1] != 0x82)\n\t\t\tgoto dodgy_cert;\n\t\tplen = (p[2] << 8) | p[3];\n\t\tplen += 4;\n\t\tif (plen >": 4826, "< end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start >": 4827, "< end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\t\n\tif (res->": 4828, "< end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}\n#endif\n\n\nstatic int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->": 4829, "< end; addr += page_size)\n\t\tfree_reserved_page(pfn_to_page(addr >": 4830, "< end; addr++) {\n\t\t\terr = get_user(val, addr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (val)\n\t\t\t\treturn -e2big;\n\t\t}\n\t\tsize = sizeof(attr);\n\t}\n\n\t\n\tif (copy_from_user(&attr, uattr, size) != 0)\n\t\treturn -efault;\n\n\tswitch (cmd) {\n\tcase bpf_map_create:\n\t\terr = map_create(&attr);\n\t\tbreak;\n\tcase bpf_map_lookup_elem:\n\t\terr = map_lookup_elem(&attr);\n\t\tbreak;\n\tcase bpf_map_update_elem:\n\t\terr = map_update_elem(&attr);\n\t\tbreak;\n\tcase bpf_map_delete_elem:\n\t\terr = map_delete_elem(&attr);\n\t\tbreak;\n\tcase bpf_map_get_next_key:\n\t\terr = map_get_next_key(&attr);\n\t\tbreak;\n\tcase bpf_prog_load:\n\t\terr = bpf_prog_load(&attr);\n\t\tbreak;\n\tdefault:\n\t\terr = -einval;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n\n#include <linux/export.h>": 4831, "< end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -efault;\n\n\t\n\tattr->": 4832, "< end; i++)\n\t\tkfree(ret_stack_list[i]);\n\treturn ret;\n}\n\nstatic void\nftrace_graph_probe_sched_switch(void *ignore,\n\t\t\tstruct task_struct *prev, struct task_struct *next)\n{\n\tunsigned long long timestamp;\n\tint index;\n\n\t\n\tif (trace_flags & trace_iter_sleep_time)\n\t\treturn;\n\n\ttimestamp = trace_clock_local();\n\n\tprev->": 4833, "< end; iter++) {\n\t\tentry = arch_deref_entry_point((void *)*iter);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset)) {\n\t\t\tpr_err(\"failed to find blacklist at %p\\n\",\n\t\t\t\t(void *)entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\tent = kmalloc(sizeof(*ent), gfp_kernel);\n\t\tif (!ent)\n\t\t\treturn -enomem;\n\t\tent->": 4834, "< end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\t*iter = tb_fmt->": 4835, "< end; map++, offset = 0) {\n\t\tif (unlikely(!map->": 4836, "< end; p++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" =>": 4837, "< ent->": 4838, "< entry->": 4839, "< env->": 4840, "< erule->": 4841, "< event->": 4842, "< ext->": 4843, "< extents; idx++) {\n\t\tfirst = map->": 4844, "< fcount; i++) {\n\t\tswitch (new->": 4845, "< fetch_mtd_end; i++)\n\t\tif (type->": 4846, "< filter->": 4847, "< first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}\n\n\nint __init parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\t\"crashkernel=\", null);\n}\n\nint __init parse_crashkernel_high(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[suffix_high]);\n}\n\nint __init parse_crashkernel_low(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[suffix_low]);\n}\n\nstatic void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, vmcoreinfo_note_name, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}\n\nvoid crash_save_vmcoreinfo(void)\n{\n\tvmcoreinfo_append_str(\"crashtime=%ld\\n\", get_seconds());\n\tupdate_vmcoreinfo_note();\n}\n\nvoid vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, vmcoreinfo_max_size - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n}\n\n\nvoid __weak arch_crash_save_vmcoreinfo(void)\n{}\n\nunsigned long __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa((unsigned long)(char *)&vmcoreinfo_note);\n}\n\nstatic int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_osrelease(init_uts_ns.name.release);\n\tvmcoreinfo_pagesize(page_size);\n\n\tvmcoreinfo_symbol(init_uts_ns);\n\tvmcoreinfo_symbol(node_online_map);\n#ifdef config_mmu\n\tvmcoreinfo_symbol(swapper_pg_dir);\n#endif\n\tvmcoreinfo_symbol(_stext);\n\tvmcoreinfo_symbol(vmap_area_list);\n\n#ifndef config_need_multiple_nodes\n\tvmcoreinfo_symbol(mem_map);\n\tvmcoreinfo_symbol(contig_page_data);\n#endif\n#ifdef config_sparsemem\n\tvmcoreinfo_symbol(mem_section);\n\tvmcoreinfo_length(mem_section, nr_section_roots);\n\tvmcoreinfo_struct_size(mem_section);\n\tvmcoreinfo_offset(mem_section, section_mem_map);\n#endif\n\tvmcoreinfo_struct_size(page);\n\tvmcoreinfo_struct_size(pglist_data);\n\tvmcoreinfo_struct_size(zone);\n\tvmcoreinfo_struct_size(free_area);\n\tvmcoreinfo_struct_size(list_head);\n\tvmcoreinfo_size(nodemask_t);\n\tvmcoreinfo_offset(page, flags);\n\tvmcoreinfo_offset(page, _count);\n\tvmcoreinfo_offset(page, mapping);\n\tvmcoreinfo_offset(page, lru);\n\tvmcoreinfo_offset(page, _mapcount);\n\tvmcoreinfo_offset(page, private);\n\tvmcoreinfo_offset(pglist_data, node_zones);\n\tvmcoreinfo_offset(pglist_data, nr_zones);\n#ifdef config_flat_node_mem_map\n\tvmcoreinfo_offset(pglist_data, node_mem_map);\n#endif\n\tvmcoreinfo_offset(pglist_data, node_start_pfn);\n\tvmcoreinfo_offset(pglist_data, node_spanned_pages);\n\tvmcoreinfo_offset(pglist_data, node_id);\n\tvmcoreinfo_offset(zone, free_area);\n\tvmcoreinfo_offset(zone, vm_stat);\n\tvmcoreinfo_offset(zone, spanned_pages);\n\tvmcoreinfo_offset(free_area, free_list);\n\tvmcoreinfo_offset(list_head, next);\n\tvmcoreinfo_offset(list_head, prev);\n\tvmcoreinfo_offset(vmap_area, va_start);\n\tvmcoreinfo_offset(vmap_area, list);\n\tvmcoreinfo_length(zone.free_area, max_order);\n\tlog_buf_kexec_setup();\n\tvmcoreinfo_length(free_area.free_list, migrate_types);\n\tvmcoreinfo_number(nr_free_pages);\n\tvmcoreinfo_number(pg_lru);\n\tvmcoreinfo_number(pg_private);\n\tvmcoreinfo_number(pg_swapcache);\n\tvmcoreinfo_number(pg_slab);\n#ifdef config_memory_failure\n\tvmcoreinfo_number(pg_hwpoison);\n#endif\n\tvmcoreinfo_number(pg_head_mask);\n\tvmcoreinfo_number(page_buddy_mapcount_value);\n#ifdef config_hugetlbfs\n\tvmcoreinfo_symbol(free_huge_page);\n#endif\n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}\n\nsubsys_initcall(crash_save_vmcoreinfo_init);\n\n#ifdef config_kexec_file\nstatic int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->": 4848, "< flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->": 4849, "< fmt_size; i++) {\n\t\tif ((!isprint(fmt[i]) && !isspace(fmt[i])) || !isascii(fmt[i]))\n\t\t\treturn -einval;\n\n\t\tif (fmt[i] != '%')\n\t\t\tcontinue;\n\n\t\tif (fmt_cnt >": 4850, "< freezer_delta.tv64))\n\t\tfreezer_delta = delta;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}\n\n\n\nvoid alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->": 4851, "< ftrace_retfunc_depth)\n\t\t\tcpu_data->": 4852, "< ftrace_retfunc_depth) {\n\t\t\tif (cpu_data->": 4853, "< ftrace_retstack_alloc_size; i++) {\n\t\tret_stack_list[i] = kmalloc(ftrace_retfunc_depth\n\t\t\t\t\t* sizeof(struct ftrace_ret_stack),\n\t\t\t\t\tgfp_kernel);\n\t\tif (!ret_stack_list[i]) {\n\t\t\tstart = 0;\n\t\t\tend = i;\n\t\t\tret = -enomem;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tread_lock_irqsave(&tasklist_lock, flags);\n\tdo_each_thread(g, t) {\n\t\tif (start == end) {\n\t\t\tret = -eagain;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (t->": 4854, "< ftrace_stack_entries; i++) {\n\t\tunsigned long ip = entry->": 4855, "< gc->": 4856, "< gcov_counters; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      gcov_tag_for_counter(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->": 4857, "< gcov_counters; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->": 4858, "< gcov_counters; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->": 4859, "< gcov_counters; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}\n\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->": 4860, "< gcov_counters; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}\n\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active; i++) {\n\t\tmemset(info->": 4861, "< gcov_counters; i++) {\n\t\tif (counter_active(iter->": 4862, "< gdbstub_use_prev_in_buf)\n\t\t\treturn remcom_in_buffer[gdbstub_prev_in_buf_pos++];\n\t\telse\n\t\t\tgdbstub_use_prev_in_buf = 0;\n\t}\n\n\t\n\twhile (ret < 0)\n\t\tfor (i = 0; kdb_poll_funcs[i] != null; i++) {\n\t\t\tret = kdb_poll_funcs[i]();\n\t\t\tif (ret >": 4863, "< get_func(iter)->": 4864, "< group_faults(p, src_nid);\n\t}\n\n\t\n\tif (src_nid == p->": 4865, "< group_first_cpu(sg)) {\n\t\tif (!sds->": 4866, "< group_info->": 4867, "< header_size) {\n\t\t\n\t\tstack_size = ushrt_max - header_size - sizeof(u64);\n\t\tstack_size = round_up(stack_size, sizeof(u64));\n\t}\n\n\treturn stack_size;\n}\n\nstatic void\nperf_output_sample_ustack(struct perf_output_handle *handle, u64 dump_size,\n\t\t\t  struct pt_regs *regs)\n{\n\t\n\tif (!regs) {\n\t\tu64 size = 0;\n\t\tperf_output_put(handle, size);\n\t} else {\n\t\tunsigned long sp;\n\t\tunsigned int rem;\n\t\tu64 dyn_size;\n\n\t\t\n\n\t\t\n\t\tperf_output_put(handle, dump_size);\n\n\t\t\n\t\tsp = perf_user_stack_pointer(regs);\n\t\trem = __output_copy_user(handle, (void *) sp, dump_size);\n\t\tdyn_size = dump_size - rem;\n\n\t\tperf_output_skip(handle, rem);\n\n\t\t\n\t\tperf_output_put(handle, dyn_size);\n\t}\n}\n\nstatic void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->": 4868, "< highbp;\n\t    i++, bp++) {\n\t\tif (bp->": 4869, "< htab->": 4870, "< hz/4 && !force_up) \n\t\tj = j - rem;\n\telse \n\t\tj = j - rem + hz;\n\n\t\n\tj -= cpu * 3;\n\n\t\n\treturn time_is_after_jiffies(j) ? j : original;\n}\n\n\nunsigned long __round_jiffies(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, false);\n}\nexport_symbol_gpl(__round_jiffies);\n\n\nunsigned long __round_jiffies_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t\n\treturn round_jiffies_common(j + j0, cpu, false) - j0;\n}\nexport_symbol_gpl(__round_jiffies_relative);\n\n\nunsigned long round_jiffies(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), false);\n}\nexport_symbol_gpl(round_jiffies);\n\n\nunsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}\nexport_symbol_gpl(round_jiffies_relative);\n\n\nunsigned long __round_jiffies_up(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, true);\n}\nexport_symbol_gpl(__round_jiffies_up);\n\n\nunsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t\n\treturn round_jiffies_common(j + j0, cpu, true) - j0;\n}\nexport_symbol_gpl(__round_jiffies_up_relative);\n\n\nunsigned long round_jiffies_up(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), true);\n}\nexport_symbol_gpl(round_jiffies_up);\n\n\nunsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}\nexport_symbol_gpl(round_jiffies_up_relative);\n\n\nvoid set_timer_slack(struct timer_list *timer, int slack_hz)\n{\n\ttimer->": 4871, "< i; j++)\n\t\trdp->": 4872, "< i; j++) {\n\t\t\tunsigned long pstart, pend;\n\t\t\tpstart = image->": 4873, "< image->": 4874, "< imbalance*min_load)\n\t\treturn null;\n\treturn idlest;\n}\n\n\nstatic int\nfind_idlest_cpu(struct sched_group *group, struct task_struct *p, int this_cpu)\n{\n\tunsigned long load, min_load = ulong_max;\n\tunsigned int min_exit_latency = uint_max;\n\tu64 latest_idle_timestamp = 0;\n\tint least_loaded_cpu = this_cpu;\n\tint shallowest_idle_cpu = -1;\n\tint i;\n\n\t\n\tfor_each_cpu_and(i, sched_group_cpus(group), tsk_cpus_allowed(p)) {\n\t\tif (idle_cpu(i)) {\n\t\t\tstruct rq *rq = cpu_rq(i);\n\t\t\tstruct cpuidle_state *idle = idle_get_state(rq);\n\t\t\tif (idle && idle->": 4875, "< index)\n\t\t\t\t\tbreak;\n\t\t\t\treturn expires;\n\t\t\t}\n\t\t\tslot = (slot + 1) & tvn_mask;\n\t\t} while (slot != index);\n\n\t\tif (index)\n\t\t\ttimer_jiffies += tvn_size - index;\n\t\ttimer_jiffies >": 4876, "< index)\n\t\t\t\tgoto cascade;\n\t\t\treturn expires;\n\t\t}\n\t\tslot = (slot + 1) & tvr_mask;\n\t} while (slot != index);\n\ncascade:\n\t\n\tif (index)\n\t\ttimer_jiffies += tvr_size - index;\n\ttimer_jiffies >": 4877, "< info->": 4878, "< initcnt; i++) {\n\t\tdesc = alloc_desc(i, node, null);\n\t\tset_bit(i, allocated_irqs);\n\t\tirq_insert_desc(i, desc);\n\t}\n\treturn arch_early_irq_init();\n}\n\n#else \n\nstruct irq_desc irq_desc[nr_irqs] __cacheline_aligned_in_smp = {\n\t[0 ... nr_irqs-1] = {\n\t\t.handle_irq\t= handle_bad_irq,\n\t\t.depth\t\t= 1,\n\t\t.lock\t\t= __raw_spin_lock_unlocked(irq_desc->": 4879, "< insn_cnt; i++, insn++)\n\t\tif (insn->": 4880, "< insn_cnt; i++, insn++) {\n\t\tif (bpf_class(insn->": 4881, "< insn_cnt; i++, insn++) {\n\t\tif (insn->": 4882, "< iter->": 4883, "< iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}\n\n\nvoid __weak __init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\t\n}\n\nstatic void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop, int enable)\n{\n\tfor (; (entry < stop) &&\n\t      (entry->": 4884, "< iter_stop; iter++) {\n\t\tarch_jump_label_transform_static(iter, jump_label_disable);\n\t}\n}\n\nstatic int jump_label_add_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->": 4885, "< iter_stop; iter++) {\n\t\tif (iter->": 4886, "< iter_stop; iter++) {\n\t\tif (within_module_init(iter->": 4887, "< iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\titerk = (struct static_key *)(unsigned long)iter->": 4888, "< iters; ++i) {\n\t\tstruct timespec ts1, ts2;\n\t\tint time_passed;\n\n\t\tktime_get_ts(&ts1);\n\t\tudelay(usecs);\n\t\tktime_get_ts(&ts2);\n\t\ttime_passed = timespec_to_ns(&ts2) - timespec_to_ns(&ts1);\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed >": 4889, "< jeb->": 4890, "< k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j >": 4891, "< kbuf->": 4892, "< kcmp_types; i++)\n\t\tcookies[i][1] |= (~(~0ul >": 4893, "< kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->": 4894, "< kdb_max_commands;\t\t\t\t\t\\\n\t     num++, num == kdb_base_cmd_max ? cmd = kdb_commands : cmd++)\n\ntypedef struct _kdbmsg {\n\tint\tkm_diag;\t\n\tchar\t*km_msg;\t\n} kdbmsg_t;\n\n#define kdbmsg(msgnum, text) \\\n\t{ kdb_##msgnum, text }\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tkdbmsg(notfound, \"command not found\"),\n\tkdbmsg(argcount, \"improper argument count, see usage.\"),\n\tkdbmsg(badwidth, \"illegal value for bytesperword use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tkdbmsg(badradix, \"illegal value for radix use 8, 10 or 16\"),\n\tkdbmsg(notenv, \"cannot find environment variable\"),\n\tkdbmsg(noenvvalue, \"environment variable should have value\"),\n\tkdbmsg(notimp, \"command not implemented\"),\n\tkdbmsg(envfull, \"environment full\"),\n\tkdbmsg(envbuffull, \"environment buffer full\"),\n\tkdbmsg(toomanybpt, \"too many breakpoints defined\"),\n#ifdef config_cpu_xscale\n\tkdbmsg(toomanydbregs, \"more breakpoints than ibcr registers defined\"),\n#else\n\tkdbmsg(toomanydbregs, \"more breakpoints than db registers defined\"),\n#endif\n\tkdbmsg(dupbpt, \"duplicate breakpoint address\"),\n\tkdbmsg(bptnotfound, \"breakpoint not found\"),\n\tkdbmsg(badmode, \"invalid idmode\"),\n\tkdbmsg(badint, \"illegal numeric value\"),\n\tkdbmsg(invaddrfmt, \"invalid symbolic address format\"),\n\tkdbmsg(badreg, \"invalid register name\"),\n\tkdbmsg(badcpunum, \"invalid cpu number\"),\n\tkdbmsg(badlength, \"invalid length field\"),\n\tkdbmsg(nobp, \"no breakpoint exists\"),\n\tkdbmsg(badaddr, \"invalid address\"),\n\tkdbmsg(noperm, \"permission denied\"),\n};\n#undef kdbmsg\n\nstatic const int __nkdb_err = array_size(kdbmsgs);\n\n\n\n\nstatic char *__env[] = {\n#if defined(config_smp)\n \"prompt=[%d]kdb>": 4895, "< kdb_maxbpt) {\n\t\t\tbp = &kdb_breakpoints[addr];\n\t\t\tlowbp = highbp = addr;\n\t\t\thighbp++;\n\t\t} else {\n\t\t\tfor (i = 0, bp = kdb_breakpoints; i < kdb_maxbpt;\n\t\t\t    i++, bp++) {\n\t\t\t\tif (bp->": 4896, "< kdb_maxbpt;\n\t\t     bpno++, bp++) {\n\t\t\tif (bp->": 4897, "< kdb_maxbpt;\n\t     i++, bp_check++) {\n\t\tif (!bp_check->": 4898, "< kdb_maxbpt; bpno++, bp++) {\n\t\tif (bp->": 4899, "< kdb_maxbpt; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (kdb_debug(bp)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->": 4900, "< kdb_maxbpt; i++, bp++)\n\t\tbp->": 4901, "< kdb_maxbpt; i++, bp++) {\n\t\t\tif (bp->": 4902, "< kdb_maxbpt; i++, bp++) {\n\t\tif ((bp->": 4903, "< key_id_len; i++) {\n\t\t*q++ = hex_asc[*key_id >": 4904, "< kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state != bp_set)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"bp install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = bp_active;\n\t}\n\treturn ret;\n}\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif ((kgdb_break[i].state == bp_set) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -eexist;\n\t}\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state == bp_removed &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\t\tif (kgdb_break[i].state == bp_undefined) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -e2big;\n\n\tkgdb_break[breakno].state = bp_set;\n\tkgdb_break[breakno].type = bp_breakpoint;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state != bp_active)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"bp remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = bp_set;\n\t}\n\treturn ret;\n}\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif ((kgdb_break[i].state == bp_set) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = bp_removed;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -enoent;\n}\n\nint kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif ((kgdb_break[i].state == bp_removed) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state != bp_active)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = bp_undefined;\n\t}\n\n\t\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}\n\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef config_kgdb_kdb\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for kdb\\n\");\n#else\n\t\tpr_crit(\"waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->": 4905, "< kj.tv64)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->": 4906, "< kprobe_table_size) ? pos : null;\n}\n\nstatic void *kprobe_seq_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >": 4907, "< kprobe_table_size; hash++) {\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thead = &kretprobe_inst_table[hash];\n\t\thlist_for_each_entry_safe(ri, next, head, hlist) {\n\t\t\tif (ri->": 4908, "< kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tarm_kprobe(p);\n\t}\n\n\tprintk(kern_info \"kprobes globally enabled\\n\");\n\nalready_enabled:\n\tmutex_unlock(&kprobe_mutex);\n\treturn;\n}\n\nstatic void disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tkprobes_all_disarmed = true;\n\tprintk(kern_info \"kprobes globally disabled\\n\");\n\n\tfor (i = 0; i < kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p))\n\t\t\t\tdisarm_kprobe(p, false);\n\t\t}\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\n\t\n\twait_for_kprobe_optimizer();\n}\n\n\nstatic ssize_t read_enabled_file_bool(struct file *file,\n\t       char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (!kprobes_all_disarmed)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t write_enabled_file_bool(struct file *file,\n\t       const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -efault;\n\n\tbuf[buf_size] = '\\0';\n\tswitch (buf[0]) {\n\tcase 'y':\n\tcase 'y':\n\tcase '1':\n\t\tarm_all_kprobes();\n\t\tbreak;\n\tcase 'n':\n\tcase 'n':\n\tcase '0':\n\t\tdisarm_all_kprobes();\n\t\tbreak;\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_kp = {\n\t.read =         read_enabled_file_bool,\n\t.write =        write_enabled_file_bool,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic int __init debugfs_kprobe_init(void)\n{\n\tstruct dentry *dir, *file;\n\tunsigned int value = 1;\n\n\tdir = debugfs_create_dir(\"kprobes\", null);\n\tif (!dir)\n\t\treturn -enomem;\n\n\tfile = debugfs_create_file(\"list\", 0444, dir, null,\n\t\t\t\t&debugfs_kprobes_operations);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"enabled\", 0600, dir,\n\t\t\t\t\t&value, &fops_kp);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"blacklist\", 0444, dir, null,\n\t\t\t\t&debugfs_kprobe_blacklist_ops);\n\tif (!file)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdebugfs_remove(dir);\n\treturn -enomem;\n}\n\nlate_initcall(debugfs_kprobe_init);\n#endif \n\nmodule_init(init_kprobes);\n\n\nexport_symbol_gpl(jprobe_return);\n\n\n\n#include <linux/list.h>": 4909, "< kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\toptimize_kprobe(p);\n\t}\n\tprintk(kern_info \"kprobes globally optimized\\n\");\nout:\n\tmutex_unlock(&kprobe_mutex);\n}\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\n\t\n\twait_for_kprobe_optimizer();\n\tprintk(kern_info \"kprobes globally unoptimized\\n\");\n}\n\nstatic define_mutex(kprobe_sysctl_mutex);\nint sysctl_kprobes_optimization;\nint proc_kprobes_optimization_handler(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer, size_t *length,\n\t\t\t\t      loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&kprobe_sysctl_mutex);\n\tsysctl_kprobes_optimization = kprobes_allow_optimization ? 1 : 0;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\tif (sysctl_kprobes_optimization)\n\t\toptimize_all_kprobes();\n\telse\n\t\tunoptimize_all_kprobes();\n\tmutex_unlock(&kprobe_sysctl_mutex);\n\n\treturn ret;\n}\n#endif \n\n\nstatic void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\t\n\t_p = get_optimized_kprobe((unsigned long)p->": 4910, "< kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (within_module_init((unsigned long)p->": 4911, "< kprobe_table_size; i++) {\n\t\tinit_hlist_head(&kprobe_table[i]);\n\t\tinit_hlist_head(&kretprobe_inst_table[i]);\n\t\traw_spin_lock_init(&(kretprobe_table_locks[i].lock));\n\t}\n\n\terr = populate_kprobe_blacklist(__start_kprobe_blacklist,\n\t\t\t\t\t__stop_kprobe_blacklist);\n\tif (err) {\n\t\tpr_err(\"kprobes: failed to populate blacklist: %d\\n\", err);\n\t\tpr_err(\"please take care of using kprobes.\\n\");\n\t}\n\n\tif (kretprobe_blacklist_size) {\n\t\t\n\t\tfor (i = 0; kretprobe_blacklist[i].name != null; i++) {\n\t\t\tkprobe_lookup_name(kretprobe_blacklist[i].name,\n\t\t\t\t\t   kretprobe_blacklist[i].addr);\n\t\t\tif (!kretprobe_blacklist[i].addr)\n\t\t\t\tprintk(\"kretprobe: lookup failed: %s\\n\",\n\t\t\t\t       kretprobe_blacklist[i].name);\n\t\t}\n\t}\n\n#if defined(config_optprobes)\n#if defined(__arch_want_kprobes_insn_slot)\n\t\n\tkprobe_optinsn_slots.insn_size = max_optinsn_size;\n#endif\n\t\n\tkprobes_allow_optimization = true;\n#endif\n\n\t\n\tkprobes_all_disarmed = false;\n\n\terr = arch_init_kprobes();\n\tif (!err)\n\t\terr = register_die_notifier(&kprobe_exceptions_nb);\n\tif (!err)\n\t\terr = register_module_notifier(&kprobe_module_nb);\n\n\tkprobes_initialized = (err == 0);\n\n\tif (!err)\n\t\tinit_test_probes();\n\treturn err;\n}\n\n#ifdef config_debug_fs\nstatic void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\n\tif (p->": 4912, "< len))\n\t\tgoto out;\n\n\titem = ring_buffer_event_data(event);\n\titem->": 4913, "< len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); \n}\n\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tbug_on(!ab->": 4914, "< len; i++) {\n\t\t\tif (call->": 4915, "< len; i++) {\n\t\tbuf += sprintf(buf, \"%s%02x\", i == 0 ? \"\" : \" \", cmd[i]);\n\t\tif (i == end && end != len - 1) {\n\t\t\tsprintf(buf, \" ..\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid blk_fill_rwbs(char *rwbs, u32 rw, int bytes)\n{\n\tint i = 0;\n\n\tif (rw & req_flush)\n\t\trwbs[i++] = 'f';\n\n\tif (rw & write)\n\t\trwbs[i++] = 'w';\n\telse if (rw & req_discard)\n\t\trwbs[i++] = 'd';\n\telse if (bytes)\n\t\trwbs[i++] = 'r';\n\telse\n\t\trwbs[i++] = 'n';\n\n\tif (rw & req_fua)\n\t\trwbs[i++] = 'f';\n\tif (rw & req_rahead)\n\t\trwbs[i++] = 'a';\n\tif (rw & req_sync)\n\t\trwbs[i++] = 's';\n\tif (rw & req_meta)\n\t\trwbs[i++] = 'm';\n\tif (rw & req_secure)\n\t\trwbs[i++] = 'e';\n\n\trwbs[i] = '\\0';\n}\nexport_symbol_gpl(blk_fill_rwbs);\n\n#endif \n\n\n\n#include <linux/export.h>": 4916, "< len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\t*search = buff + 1;\n\t\t\t\ttype = match_end_only;\n\t\t\t} else {\n\t\t\t\tif (type == match_end_only)\n\t\t\t\t\ttype = match_middle_only;\n\t\t\t\telse\n\t\t\t\t\ttype = match_front_only;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn type;\n}\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->": 4917, "< length; src++) {\n\t\t\n\t\twhile (list[src] == list[src-1]) {\n\t\t\tsrc++;\n\t\t\tif (src == length)\n\t\t\t\tgoto after;\n\t\t}\n\t\t\n\t\tlist[dest] = list[src];\n\t\tdest++;\n\t}\nafter:\n\treturn dest;\n}\n\n\nstatic pid_t pid_fry(pid_t pid)\n{\n\tunsigned a = pid & 0x55555555;\n\tunsigned b = pid & 0xaaaaaaaa;\n\n\treturn (a << 1) | (b >": 4918, "< level; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = sdtl_overlap,\n\t\t\t.numa_level = j,\n\t\t\tsd_init_name(numa)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = level;\n\tsched_max_numa_distance = sched_domains_numa_distance[level - 1];\n\n\tinit_numa_topology_type();\n}\n\nstatic void sched_domains_numa_masks_set(int cpu)\n{\n\tint i, j;\n\tint node = cpu_to_node(cpu);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}\n\nstatic void sched_domains_numa_masks_clear(int cpu)\n{\n\tint i, j;\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}\n\n\nstatic int sched_domains_numa_masks_update(struct notifier_block *nfb,\n\t\t\t\t\t   unsigned long action,\n\t\t\t\t\t   void *hcpu)\n{\n\tint cpu = (long)hcpu;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_online:\n\t\tsched_domains_numa_masks_set(cpu);\n\t\tbreak;\n\n\tcase cpu_dead:\n\t\tsched_domains_numa_masks_clear(cpu);\n\t\tbreak;\n\n\tdefault:\n\t\treturn notify_done;\n\t}\n\n\treturn notify_ok;\n}\n#else\nstatic inline void sched_init_numa(void)\n{\n}\n\nstatic int sched_domains_numa_masks_update(struct notifier_block *nfb,\n\t\t\t\t\t   unsigned long action,\n\t\t\t\t\t   void *hcpu)\n{\n\treturn 0;\n}\n#endif \n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->": 4919, "< levels_needed; i++) {\n\t\tnode = alloc_rtree_node(gfp_mask, safe_needed, ca,\n\t\t\t\t\t&zone->": 4920, "< lhs.tv_sec || res.tv_sec < rhs.tv_sec)\n\t\tres.tv_sec = time_t_max;\n\n\treturn res;\n}\n\n\n#include <linux/proc_fs.h>": 4921, "< limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}\n\nstatic void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid >": 4922, "< load_b)\n\t\tswap(load_a, load_b);\n\n\t\n\timb = load_a * src_capacity * 100 -\n\t\tload_b * dst_capacity * env->": 4923, "< lockstat_points)\n\t\tstats->": 4924, "< lockstat_points; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->": 4925, "< lockstat_points; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time >": 4926, "< log_next_seq) {\n\t\tif (logbuf_has_space(msg_size, false))\n\t\t\treturn 0;\n\t\t\n\t\tlog_first_idx = log_next(log_first_idx);\n\t\tlog_first_seq++;\n\t}\n\n\t\n\tif (logbuf_has_space(msg_size, true))\n\t\treturn 0;\n\n\treturn -enomem;\n}\n\n\nstatic u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (log_align - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}\n\n\n#define max_log_take_part 4\nstatic const char trunc_msg[] = \"<truncated>": 4927, "< long_max)\n\t\taccount_idle_ticks(ticks);\n#endif\n}\n\n\nvoid tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\twarn_on_once(!ts->": 4928, "< loops; i++) {\n\t\t\tif (arch_read_trylock(&lock->": 4929, "< loops; i++) {\n\t\t\tif (arch_write_trylock(&lock->": 4930, "< loops; i++) {\n\t\tif (arch_spin_trylock(&lock->": 4931, "< lt->": 4932, "< lt_backtracedepth; q++) {\n\t\t\t\tunsigned long bt = lr->": 4933, "< lt_backtracedepth; q++) {\n\t\t\tunsigned long record = lat->": 4934, "< lt_backtracedepth; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->": 4935, "< lzo_cmp_pages && asked) {\n\t\t\tret = hib_wait_on_bio_chain(&bio);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(kern_err\n\t\t\t\t       \"pm: lzo decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len >": 4936, "< lzo_header + data[thr].cmp_len;\n\t\t\t     off += page_size) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], page_size);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >": 4937, "< lzo_header + data[thr].cmp_len;\n\t\t\t     off += page_size) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, page_size);\n\n\t\t\t\tret = swap_write_page(handle, page, &bio);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->": 4938, "< map->": 4939, "< max_bpf_reg; i++) {\n\t\tregs[i].type = not_init;\n\t\tregs[i].imm = 0;\n\t\tregs[i].map_ptr = null;\n\t}\n\n\t\n\tregs[bpf_reg_fp].type = frame_ptr;\n\n\t\n\tregs[bpf_reg_1].type = ptr_to_ctx;\n}\n\nstatic void mark_reg_unknown_value(struct reg_state *regs, u32 regno)\n{\n\tbug_on(regno >": 4940, "< max_bpf_reg; i++) {\n\t\tt = env->": 4941, "< max_bpf_stack; i += bpf_reg_size) {\n\t\tif (env->": 4942, "< max_bpf_stack; i++) {\n\t\tif (old->": 4943, "< max_dma_channels ; i++) {\n\t\tif (dma_chan_busy[i].lock) {\n\t\t\tseq_printf(m, \"%2d: %s\\n\", i,\n\t\t\t\t   dma_chan_busy[i].device_id);\n\t\t}\n\t}\n\treturn 0;\n}\n#else\nstatic int proc_dma_show(struct seq_file *m, void *v)\n{\n\tseq_puts(m, \"no dma\\n\");\n\treturn 0;\n}\n#endif \n\nstatic int proc_dma_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, proc_dma_show, null);\n}\n\nstatic const struct file_operations proc_dma_operations = {\n\t.open\t\t= proc_dma_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init proc_dma_init(void)\n{\n\tproc_create(\"dma\", 0, null, &proc_dma_operations);\n\treturn 0;\n}\n\n__initcall(proc_dma_init);\n#endif\n\nexport_symbol(request_dma);\nexport_symbol(free_dma);\nexport_symbol(dma_spin_lock);\n\n\n\n#include <linux/mm.h>": 4944, "< max_faults * 3 / 16)\n\t\t\tnode_clear(nid, numa_group->": 4945, "< max_lockdep_subclasses; j++) {\n\t\t\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(class);\n\t}\n\t\n\tlocked = graph_lock();\n\tfor (i = 0; i < classhash_size; i++) {\n\t\thead = classhash_table + i;\n\t\tif (list_empty(head))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tint match = 0;\n\n\t\t\tfor (j = 0; j < nr_lockdep_caching_classes; j++)\n\t\t\t\tmatch |= class == lock->": 4946, "< max_optimized_length; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn null;\n}\n\n\nstatic list_head(optimizing_list);\nstatic list_head(unoptimizing_list);\nstatic list_head(freeing_list);\n\nstatic void kprobe_optimizer(struct work_struct *work);\nstatic declare_delayed_work(optimizing_work, kprobe_optimizer);\n#define optimize_delay 5\n\n\nstatic void do_optimize_kprobes(void)\n{\n\t\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\t\n\tget_online_cpus();\n\tmutex_lock(&text_mutex);\n\tarch_optimize_kprobes(&optimizing_list);\n\tmutex_unlock(&text_mutex);\n\tput_online_cpus();\n}\n\n\nstatic void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\t\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\t\n\tget_online_cpus();\n\tmutex_lock(&text_mutex);\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t\n\t\tif (kprobe_disabled(&op->": 4947, "< max_pinned_interval) ||\n\t\t\t(sd->": 4948, "< max_rt_prio; i++) {\n\t\tinit_list_head(array->": 4949, "< max_rt_test_mutexes; i++)\n\t\trt_mutex_init(&mutexes[i]);\n\n\tret = subsys_system_register(&rttest_subsys, null);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < max_rt_test_threads; i++) {\n\t\tret = init_test_thread(i);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = device_create_file(&thread_data[i].dev, &dev_attr_status);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = device_create_file(&thread_data[i].dev, &dev_attr_command);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tprintk(\"initializing rt-tester: %s\\n\", ret ? \"failed\" : \"ok\" );\n\n\treturn ret;\n}\n\ndevice_initcall(init_rttest);\n\n\n#include <linux/module.h>": 4950, "< max_rt_test_mutexes; i++) {\n\t\t\tif (td->": 4951, "< max_rt_test_threads; tid++) {\n\t\tif (threads[tid] == current)\n\t\t\tbreak;\n\t}\n\n\tbug_on(tid == max_rt_test_threads);\n\n\ttd = &thread_data[tid];\n\n\top = td->": 4952, "< max_scan_window)\n\t\twindows = max_scan_window / scan_size;\n\tfloor = 1000 / windows;\n\n\tscan = sysctl_numa_balancing_scan_period_min / task_nr_scan_windows(p);\n\treturn max_t(unsigned int, floor, scan);\n}\n\nstatic unsigned int task_scan_max(struct task_struct *p)\n{\n\tunsigned int smin = task_scan_min(p);\n\tunsigned int smax;\n\n\t\n\tsmax = sysctl_numa_balancing_scan_period_max / task_nr_scan_windows(p);\n\treturn max(smin, smax);\n}\n\nstatic void account_numa_enqueue(struct rq *rq, struct task_struct *p)\n{\n\trq->": 4953, "< max_stack_trace.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ulong_max)\n\t\t\tbreak;\n\t\tif (i+1 == max_stack_trace.nr_entries ||\n\t\t\t\tstack_dump_trace[i+1] == ulong_max)\n\t\t\tsize = stack_dump_index[i];\n\t\telse\n\t\t\tsize = stack_dump_index[i] - stack_dump_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %ps\\n\", i, stack_dump_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}\n\nstatic inline void\ncheck_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = access_once(tracer_frame);\n\tint i;\n\n\tthis_size = ((unsigned long)stack) & (thread_size-1);\n\tthis_size = thread_size - this_size;\n\t\n\tthis_size -= frame_size;\n\n\tif (this_size <= max_stack_size)\n\t\treturn;\n\n\t\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&max_stack_lock);\n\n\t\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t\n\tif (this_size <= max_stack_size)\n\t\tgoto out;\n\n\tmax_stack_size = this_size;\n\n\tmax_stack_trace.nr_entries = 0;\n\n\tif (using_ftrace_ops_list_func())\n\t\tmax_stack_trace.skip = 4;\n\telse\n\t\tmax_stack_trace.skip = 3;\n\n\tsave_stack_trace(&max_stack_trace);\n\n\t\n\tstack_dump_trace[0] = ip;\n\tmax_stack_trace.nr_entries++;\n\n\t\n\ti = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(thread_size-1)) + thread_size);\n\n\t\n\twhile (i < max_stack_trace.nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_dump_index[i] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < max_stack_trace.nr_entries; p++) {\n\t\t\tif (*p == stack_dump_trace[i]) {\n\t\t\t\tthis_size = stack_dump_index[i++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t\n\t\t\t\tstart = p + 1;\n\t\t\t\t\n\t\t\t\tif (unlikely(!tracer_frame) && i == 1) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tmax_stack_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tprint_max_stack();\n\t\tbug();\n\t}\n\n out:\n\tarch_spin_unlock(&max_stack_lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic void\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tunsigned long stack;\n\tint cpu;\n\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\t\n\tif (per_cpu(trace_active, cpu)++ != 0)\n\t\tgoto out;\n\n\t\n\tif (fentry)\n\t\tip = parent_ip;\n\telse\n\t\tip += mcount_insn_size;\n\n\tcheck_stack(ip, &stack);\n\n out:\n\tper_cpu(trace_active, cpu)--;\n\t\n\tpreempt_enable_notrace();\n}\n\nstatic struct ftrace_ops trace_ops __read_mostly =\n{\n\t.func = stack_trace_call,\n\t.flags = ftrace_ops_fl_recursion_safe,\n};\n\nstatic ssize_t\nstack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->": 4954, "< max_zone_pfn; pfn++)\n\t\t\tif (page_is_saveable(zone, pfn))\n\t\t\t\tmemory_bm_set_bit(orig_bm, pfn);\n\t}\n\tmemory_bm_position_reset(orig_bm);\n\tmemory_bm_position_reset(copy_bm);\n\tfor(;;) {\n\t\tpfn = memory_bm_next_pfn(orig_bm);\n\t\tif (unlikely(pfn == bm_end_of_map))\n\t\t\tbreak;\n\t\tcopy_data_page(memory_bm_next_pfn(copy_bm), pfn);\n\t}\n}\n\n\nstatic unsigned int nr_copy_pages;\n\nstatic unsigned int nr_meta_pages;\n\nunsigned int alloc_normal, alloc_highmem;\n\nstatic struct memory_bitmap orig_bm;\n\nstatic struct memory_bitmap copy_bm;\n\n\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != bm_end_of_map && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = null;\n\tbuffer = null;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n}\n\n\n\n#define gfp_image\t(gfp_kernel | __gfp_nowarn)\n\n\nstatic unsigned long preallocate_image_pages(unsigned long nr_pages, gfp_t mask)\n{\n\tunsigned long nr_alloc = 0;\n\n\twhile (nr_pages >": 4955, "< max_zone_pfn; pfn++)\n\t\t\tif (pfn_valid(pfn))\n\t\t\t\tswsusp_unset_page_free(pfn_to_page(pfn));\n\t}\n\n\t\n\tmemory_bm_position_reset(bm);\n\tdo {\n\t\tpfn = memory_bm_next_pfn(bm);\n\t\tif (likely(pfn != bm_end_of_map)) {\n\t\t\tif (likely(pfn_valid(pfn)))\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn));\n\t\t\telse\n\t\t\t\treturn -efault;\n\t\t}\n\t} while (pfn != bm_end_of_map);\n\n\tallocated_unsafe_pages = 0;\n\n\treturn 0;\n}\n\nstatic void\nduplicate_memory_bitmap(struct memory_bitmap *dst, struct memory_bitmap *src)\n{\n\tunsigned long pfn;\n\n\tmemory_bm_position_reset(src);\n\tpfn = memory_bm_next_pfn(src);\n\twhile (pfn != bm_end_of_map) {\n\t\tmemory_bm_set_bit(dst, pfn);\n\t\tpfn = memory_bm_next_pfn(src);\n\t}\n}\n\nstatic int check_header(struct swsusp_info *info)\n{\n\tchar *reason;\n\n\treason = check_image_kernel(info);\n\tif (!reason && info->": 4956, "< max_zone_pfn; pfn++)\n\t\t\tif (saveable_highmem_page(zone, pfn))\n\t\t\t\tn++;\n\t}\n\treturn n;\n}\n#else\nstatic inline void *saveable_highmem_page(struct zone *z, unsigned long p)\n{\n\treturn null;\n}\n#endif \n\n\nstatic struct page *saveable_page(struct zone *zone, unsigned long pfn)\n{\n\tstruct page *page;\n\n\tif (!pfn_valid(pfn))\n\t\treturn null;\n\n\tpage = pfn_to_page(pfn);\n\tif (page_zone(page) != zone)\n\t\treturn null;\n\n\tbug_on(pagehighmem(page));\n\n\tif (swsusp_page_is_forbidden(page) || swsusp_page_is_free(page))\n\t\treturn null;\n\n\tif (pagereserved(page)\n\t    && (!kernel_page_present(page) || pfn_is_nosave(pfn)))\n\t\treturn null;\n\n\tif (page_is_guard(page))\n\t\treturn null;\n\n\treturn page;\n}\n\n\n\nstatic unsigned int count_data_pages(void)\n{\n\tstruct zone *zone;\n\tunsigned long pfn, max_zone_pfn;\n\tunsigned int n = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (is_highmem(zone))\n\t\t\tcontinue;\n\n\t\tmark_free_pages(zone);\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->": 4957, "< max_zone_pfn; pfn++)\n\t\t\tif (saveable_page(zone, pfn))\n\t\t\t\tn++;\n\t}\n\treturn n;\n}\n\n\nstatic inline void do_copy_page(long *dst, long *src)\n{\n\tint n;\n\n\tfor (n = page_size / sizeof(long); n; n--)\n\t\t*dst++ = *src++;\n}\n\n\n\nstatic void safe_copy_page(void *dst, struct page *s_page)\n{\n\tif (kernel_page_present(s_page)) {\n\t\tdo_copy_page(dst, page_address(s_page));\n\t} else {\n\t\tkernel_map_pages(s_page, 1, 1);\n\t\tdo_copy_page(dst, page_address(s_page));\n\t\tkernel_map_pages(s_page, 1, 0);\n\t}\n}\n\n\n#ifdef config_highmem\nstatic inline struct page *\npage_is_saveable(struct zone *zone, unsigned long pfn)\n{\n\treturn is_highmem(zone) ?\n\t\tsaveable_highmem_page(zone, pfn) : saveable_page(zone, pfn);\n}\n\nstatic void copy_data_page(unsigned long dst_pfn, unsigned long src_pfn)\n{\n\tstruct page *s_page, *d_page;\n\tvoid *src, *dst;\n\n\ts_page = pfn_to_page(src_pfn);\n\td_page = pfn_to_page(dst_pfn);\n\tif (pagehighmem(s_page)) {\n\t\tsrc = kmap_atomic(s_page);\n\t\tdst = kmap_atomic(d_page);\n\t\tdo_copy_page(dst, src);\n\t\tkunmap_atomic(dst);\n\t\tkunmap_atomic(src);\n\t} else {\n\t\tif (pagehighmem(d_page)) {\n\t\t\t\n\t\t\tsafe_copy_page(buffer, s_page);\n\t\t\tdst = kmap_atomic(d_page);\n\t\t\tcopy_page(dst, buffer);\n\t\t\tkunmap_atomic(dst);\n\t\t} else {\n\t\t\tsafe_copy_page(page_address(d_page), s_page);\n\t\t}\n\t}\n}\n#else\n#define page_is_saveable(zone, pfn)\tsaveable_page(zone, pfn)\n\nstatic inline void copy_data_page(unsigned long dst_pfn, unsigned long src_pfn)\n{\n\tsafe_copy_page(page_address(pfn_to_page(dst_pfn)),\n\t\t\t\tpfn_to_page(src_pfn));\n}\n#endif \n\nstatic void\ncopy_data_pages(struct memory_bitmap *copy_bm, struct memory_bitmap *orig_bm)\n{\n\tstruct zone *zone;\n\tunsigned long pfn;\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned long max_zone_pfn;\n\n\t\tmark_free_pages(zone);\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->": 4958, "< maxlen);\n\n\tdst[-1] = '\\0';\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\tif (ret < 0) {\t\n\t\t((u8 *)get_rloc_data(dest))[0] = '\\0';\n\t\t*(u32 *)dest = make_data_rloc(0, get_rloc_offs(*(u32 *)dest));\n\t} else {\n\t\t*(u32 *)dest = make_data_rloc(src - (u8 *)addr,\n\t\t\t\t\t      get_rloc_offs(*(u32 *)dest));\n\t}\n}\nnokprobe_symbol(fetch_func_name(memory, string));\n\n\nstatic void fetch_func_name(memory, string_size)(struct pt_regs *regs,\n\t\t\t\t\t\t void *addr, void *dest)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(kernel_ds);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < max_string_size);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\tif (ret < 0)\t\n\t\t*(u32 *)dest = 0;\n\telse\n\t\t*(u32 *)dest = len;\n}\nnokprobe_symbol(fetch_func_name(memory, string_size));\n\n#define define_fetch_symbol(type)\t\t\t\t\t\\\nvoid fetch_func_name(symbol, type)(struct pt_regs *regs, void *data, void *dest)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct symbol_cache *sc = data;\t\t\t\t\t\\\n\tif (sc->": 4959, "< maxlr; i++) {\n\t\tint q, same = 1;\n\n\t\t\n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull >": 4960, "< maxlr; i++) {\n\t\tstruct latency_record *lr = &latency_record[i];\n\n\t\tif (lr->": 4961, "< maxreserve) {\n\t\t\tstruct resource *res = reserve + x;\n\t\t\tres->": 4962, "< mcount_insn_size; i++)\n\t\tprintk(kern_cont \"%s%02x\", i ? \":\" : \"\", p[i]);\n}\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec);\n\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->": 4963, "< mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tpages = alloc_pages(gfp_mask, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\t\tpages->": 4964, "< meta->": 4965, "< min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->": 4966, "< min)\n\t\tres->": 4967, "< min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -einval;\n\t}\n\treturn 0;\n}\n\nstatic int param_array_set(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_array *arr = kp->": 4968, "< min.tv64))\n\t\t\tmin = delta;\n\t}\n\tif (min.tv64 == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * nsec_per_sec) {\n\t\t__pm_wakeup_event(ws, 2 * msec_per_sec);\n\t\treturn -ebusy;\n\t}\n\n\t\n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t\n\tret = rtc_timer_start(rtc, &rtctimer, now, ktime_set(0, 0));\n\tif (ret < 0)\n\t\t__pm_wakeup_event(ws, msec_per_sec);\n\treturn ret;\n}\n#else\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tktime_t delta;\n\tunsigned long flags;\n\tstruct alarm_base *base = &alarm_bases[type];\n\n\tdelta = ktime_sub(absexp, base->": 4969, "< min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -einval;\n\n\t\n\tif (period >": 4970, "< min_exit_latency) {\n\t\t\t\t\n\t\t\t\tmin_exit_latency = idle->": 4971, "< min_expire)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;\n\n\t\n\tif (runtime_refresh_within(cfs_b, min_left))\n\t\treturn;\n\n\tstart_bandwidth_timer(&cfs_b->": 4972, "< min_load || (load == min_load && i == this_cpu)) {\n\t\t\t\tmin_load = load;\n\t\t\t\tleast_loaded_cpu = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn shallowest_idle_cpu != -1 ? shallowest_idle_cpu : least_loaded_cpu;\n}\n\n\nstatic int select_idle_sibling(struct task_struct *p, int target)\n{\n\tstruct sched_domain *sd;\n\tstruct sched_group *sg;\n\tint i = task_cpu(p);\n\n\tif (idle_cpu(target))\n\t\treturn target;\n\n\t\n\tif (i != target && cpus_share_cache(i, target) && idle_cpu(i))\n\t\treturn i;\n\n\t\n\tsd = rcu_dereference(per_cpu(sd_llc, target));\n\tfor_each_lower_domain(sd) {\n\t\tsg = sd->": 4973, "< min_load) {\n\t\t\tmin_load = avg_load;\n\t\t\tidlest = group;\n\t\t}\n\t} while (group = group->": 4974, "< min_nice || nice >": 4975, "< min_shares)\n\t\t\twl = min_shares;\n\n\t\t\n\t\twl -= se->": 4976, "< min_shares)\n\t\tshares = min_shares;\n\tif (shares >": 4977, "< minsec)\n\t\treturn 0;\n\n\tif (!(time_status & sta_fll) && (secs <= maxsec))\n\t\treturn 0;\n\n\ttime_status |= sta_mode;\n\n\treturn div64_long(offset64 << (ntp_scale_shift - shift_fll), secs);\n}\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & sta_pll))\n\t\treturn;\n\n\tif (!(time_status & sta_nano))\n\t\toffset *= nsec_per_usec;\n\n\t\n\toffset = min(offset, maxphase);\n\toffset = max(offset, -maxphase);\n\n\t\n\tsecs = get_seconds() - time_reftime;\n\tif (unlikely(time_status & sta_freqhold))\n\t\tsecs = 0;\n\n\ttime_reftime = get_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t\n\tif (unlikely(secs >": 4978, "< minsigstksz)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent->": 4979, "< mk->": 4980, "< mmap_min_addr)\n\t\t\tgoto out;\n\t}\n\n\t\n#define __prctl_check_order(__m1, __op, __m2)\t\t\t\t\\\n\t((unsigned long)prctl_map->": 4981, "< mmap_min_addr)\n\t\treturn -einval;\n\n\terror = -einval;\n\n\tdown_read(&mm->": 4982, "< mod->": 4983, "< module_addr_min || addr >": 4984, "< module_addr_min)\n\t\t\tmodule_addr_min = (unsigned long)ret;\n\t\tif ((unsigned long)ret + size >": 4985, "< msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}\n\n\nstatic void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t\n\t\tif (!spin_counter) {\n\t\t\t\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(msec_per_sec);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}\n\n\nint oops_may_print(void)\n{\n\treturn pause_on_oops_flag == 0;\n}\n\n\nvoid oops_enter(void)\n{\n\ttracing_off();\n\t\n\tdebug_locks_off();\n\tdo_oops_enter_exit();\n}\n\n\nstatic u64 oops_id;\n\nstatic int init_oops_id(void)\n{\n\tif (!oops_id)\n\t\tget_random_bytes(&oops_id, sizeof(oops_id));\n\telse\n\t\toops_id++;\n\n\treturn 0;\n}\nlate_initcall(init_oops_id);\n\nvoid print_oops_end_marker(void)\n{\n\tinit_oops_id();\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", (unsigned long long)oops_id);\n}\n\n\nvoid oops_exit(void)\n{\n\tdo_oops_enter_exit();\n\tprint_oops_end_marker();\n\tkmsg_dump(kmsg_dump_oops);\n}\n\n#ifdef want_warn_on_slowpath\nstruct slowpath_args {\n\tconst char *fmt;\n\tva_list args;\n};\n\nstatic void warn_slowpath_common(const char *file, int line, void *caller,\n\t\t\t\t unsigned taint, struct slowpath_args *args)\n{\n\tdisable_trace_on_warning();\n\n\tpr_warn(\"------------[ cut here ]------------\\n\");\n\tpr_warn(\"warning: cpu: %d pid: %d at %s:%d %ps()\\n\",\n\t\traw_smp_processor_id(), current->": 4986, "< mult_adj)) {\n\t\t\n\t\twarn_on_once(1);\n\t\treturn;\n\t}\n\n\ttk->": 4987, "< n; i++)\n\t\tnode = rb_next(node);\n\n\treturn node;\n}\n\nstatic void *stat_seq_next(struct seq_file *s, void *p, loff_t *pos)\n{\n\tstruct stat_session *session = s->": 4988, "< n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}\n\nstatic void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->": 4989, "< n_barrier_cbs; i++)\n\t\t\twake_up(&barrier_cbs_wq[i]);\n\t\twait_event(barrier_wq,\n\t\t\t   atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop());\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tn_barrier_attempts++;\n\t\tcur_ops->": 4990, "< n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, null, barrier_task);\n}\n\n\nstatic void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != null) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = null;\n\t}\n\tif (barrier_cbs_wq != null) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = null;\n\t}\n}\n\nstatic int rcutorture_cpu_notify(struct notifier_block *self,\n\t\t\t\t unsigned long action, void *hcpu)\n{\n\tlong cpu = (long)hcpu;\n\n\tswitch (action) {\n\tcase cpu_online:\n\tcase cpu_down_failed:\n\t\t(void)rcutorture_booster_init(cpu);\n\t\tbreak;\n\tcase cpu_down_prepare:\n\t\trcutorture_booster_cleanup(cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\nstatic struct notifier_block rcutorture_cpu_nb = {\n\t.notifier_call = rcutorture_cpu_notify,\n};\n\nstatic void\nrcu_torture_cleanup(void)\n{\n\tint i;\n\n\trcutorture_record_test_transition();\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->": 4991, "< n_preds; i++) {\n\t\tpred = &filter->": 4992, "< n_stress; i++) {\n\t\tif (statp[i].n_lock_fail)\n\t\t\tfail = true;\n\t\tsum += statp[i].n_lock_acquired;\n\t\tif (max < statp[i].n_lock_fail)\n\t\t\tmax = statp[i].n_lock_fail;\n\t\tif (min >": 4993, "< nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->": 4994, "< ncbflooders; i++) {\n\t\t\tfirsterr = torture_create_kthread(rcu_torture_cbflood,\n\t\t\t\t\t\t\t  null,\n\t\t\t\t\t\t\t  cbflood_task[i]);\n\t\t\tif (firsterr)\n\t\t\t\tgoto unwind;\n\t\t}\n\t}\n\trcutorture_record_test_transition();\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_torture_cleanup();\n\treturn firsterr;\n}\n\nmodule_init(rcu_torture_init);\nmodule_exit(rcu_torture_cleanup);\n\n\n#define pr_fmt(fmt) \"kgdb: \" fmt\n\n#include <linux/pid_namespace.h>": 4995, "< ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], gfp_kernel)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn doms;\n}\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}\n\n\nstatic int init_sched_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map);\n\terr = build_sched_domains(doms_cur[0], null);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}\n\n\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(null, &def_root_domain, i);\n\trcu_read_unlock();\n}\n\n\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = sd_attr_init;\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}\n\n\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t\n\tunregister_sched_domain_sysctl();\n\n\t\n\tnew_topology = arch_update_cpu_topology();\n\n\tn = doms_new ? ndoms_new : 0;\n\n\t\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (doms_new == null) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);\n\t\twarn_on_once(dattr_new);\n\t}\n\n\t\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : null);\nmatch2:\n\t\t;\n\t}\n\n\t\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\tkfree(dattr_cur);\t\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}\n\nstatic int num_cpus_frozen;\t\n\n\nstatic int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action,\n\t\t\t     void *hcpu)\n{\n\tswitch (action) {\n\tcase cpu_online_frozen:\n\tcase cpu_down_failed_frozen:\n\n\t\t\n\t\tnum_cpus_frozen--;\n\t\tif (likely(num_cpus_frozen)) {\n\t\t\tpartition_sched_domains(1, null, null);\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\n\tcase cpu_online:\n\t\tcpuset_update_active_cpus(true);\n\t\tbreak;\n\tdefault:\n\t\treturn notify_done;\n\t}\n\treturn notify_ok;\n}\n\nstatic int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action,\n\t\t\t       void *hcpu)\n{\n\tunsigned long flags;\n\tlong cpu = (long)hcpu;\n\tstruct dl_bw *dl_b;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_down_prepare:\n\t\t\n\t\tif (!(action & cpu_tasks_frozen)) {\n\t\t\tbool overflow;\n\t\t\tint cpus;\n\n\t\t\trcu_read_lock_sched();\n\t\t\tdl_b = dl_bw_of(cpu);\n\n\t\t\traw_spin_lock_irqsave(&dl_b->": 4996, "< new->": 4997, "< new_map->": 4998, "< new_map.nr_extents; idx++) {\n\t\tu32 lower_first;\n\t\textent = &new_map.extent[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\textent->": 4999, "< next_distance ||\n\t\t\t\t     next_distance == curr_distance))\n\t\t\t\t\tnext_distance = distance;\n\n\t\t\t\t\n\t\t\t\tif (sched_debug() && node_distance(k, i) != distance)\n\t\t\t\t\tsched_numa_warn(\"node-distance not symmetric\");\n\n\t\t\t\tif (sched_debug() && i && !find_numa_distance(distance))\n\t\t\t\t\tsched_numa_warn(\"node-0 not representative\");\n\t\t\t}\n\t\t\tif (next_distance != curr_distance) {\n\t\t\t\tsched_domains_numa_distance[level++] = next_distance;\n\t\t\t\tsched_domains_numa_levels = level;\n\t\t\t\tcurr_distance = next_distance;\n\t\t\t} else break;\n\t\t}\n\n\t\t\n\t\tif (!sched_debug())\n\t\t\tbreak;\n\t}\n\n\tif (!level)\n\t\treturn;\n\n\t\n\n\t\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * level, gfp_kernel);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t\n\tfor (i = 0; i < level; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), gfp_kernel);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), gfp_kernel);\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tif (node_distance(j, k) >": 5000, "< next_event.tv64) {\n\t\t\tnext_event.tv64 = td->": 5001, "< next_timer_max_delta)) {\n\t\t\t\n\t\t\ttime_delta = min_t(u64, time_delta,\n\t\t\t\t\t   tick_period.tv64 * delta_jiffies);\n\t\t}\n\n\t\tif (time_delta < ktime_max)\n\t\t\texpires = ktime_add_ns(last_update, time_delta);\n\t\telse\n\t\t\texpires.tv64 = ktime_max;\n\n\t\t\n\t\tif (ts->": 5002, "< nextval\n\t\t    && *(mod->": 5003, "< nice_0_load) {\n\t\tse->": 5004, "< nlen; i++)\n\t\t\tprintk(\"%d.\", name[i]);\n\t\tprintk(\"\\n\");\n\t}\n\treturn;\n}\n\n#define warn_once_hash_bits 8\n#define warn_once_hash_size (1<<warn_once_hash_bits)\n\nstatic declare_bitmap(warn_once_bitmap, warn_once_hash_size);\n\n#define fnv32_offset 2166136261u\n#define fnv32_prime 0x01000193\n\n\nstatic void warn_on_bintable(const int *name, int nlen)\n{\n\tint i;\n\tu32 hash = fnv32_offset;\n\n\tfor (i = 0; i < nlen; i++)\n\t\thash = (hash ^ name[i]) * fnv32_prime;\n\thash %= warn_once_hash_size;\n\tif (__test_and_set_bit(hash, warn_once_bitmap))\n\t\treturn;\n\tdeprecated_sysctl_warning(name, nlen);\n}\n\nstatic ssize_t do_sysctl(int __user *args_name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tint name[ctl_maxname];\n\tint i;\n\n\t\n\tif (nlen < 0 || nlen >": 5005, "< nlen; i++)\n\t\tif (get_user(name[i], args_name + i))\n\t\t\treturn -efault;\n\n\twarn_on_bintable(name, nlen);\n\n\treturn binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);\n}\n\nsyscall_define1(sysctl, struct __sysctl_args __user *, args)\n{\n\tstruct __sysctl_args tmp;\n\tsize_t oldlen = 0;\n\tssize_t result;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -efault;\n\n\tif (tmp.oldval && !tmp.oldlenp)\n\t\treturn -efault;\n\n\tif (tmp.oldlenp && get_user(oldlen, tmp.oldlenp))\n\t\treturn -efault;\n\n\tresult = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, oldlen,\n\t\t\t   tmp.newval, tmp.newlen);\n\n\tif (result >": 5006, "< node->": 5007, "< notes; ++i)\n\t\tif (sysfs_create_bin_file(notes_attrs->": 5008, "< nr_blocks; i++) {\n\t\tif (add_rtree_block(zone, gfp_mask, safe_needed, ca)) {\n\t\t\tfree_zone_bm_rtree(zone, pg_unsafe_clear);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn zone;\n}\n\n\nstatic void free_zone_bm_rtree(struct mem_zone_bm_rtree *zone,\n\t\t\t       int clear_nosave_free)\n{\n\tstruct rtree_node *node;\n\n\tlist_for_each_entry(node, &zone->": 5009, "< nr_cpu_ids && idle_cpu(ilb))\n\t\treturn ilb;\n\n\treturn nr_cpu_ids;\n}\n\n\nstatic void nohz_balancer_kick(void)\n{\n\tint ilb_cpu;\n\n\tnohz.next_balance++;\n\n\tilb_cpu = find_new_ilb();\n\n\tif (ilb_cpu >": 5010, "< nr_cpu_ids)\n\t\tirq_do_set_affinity(&desc->": 5011, "< nr_cpu_ids)\n\t\tnr_cpu_ids = nr_cpus;\n\n\treturn 0;\n}\n\nearly_param(\"nr_cpus\", nrcpus);\n\nstatic int __init maxcpus(char *str)\n{\n\tget_option(&str, &setup_max_cpus);\n\tif (setup_max_cpus == 0)\n\t\tarch_disable_smp_support();\n\n\treturn 0;\n}\n\nearly_param(\"maxcpus\", maxcpus);\n\n\nint nr_cpu_ids __read_mostly = nr_cpus;\nexport_symbol(nr_cpu_ids);\n\n\nvoid __init setup_nr_cpu_ids(void)\n{\n\tnr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),nr_cpus) + 1;\n}\n\nvoid __weak smp_announce(void)\n{\n\tprintk(kern_info \"brought up %d cpus\\n\", num_online_cpus());\n}\n\n\nvoid __init smp_init(void)\n{\n\tunsigned int cpu;\n\n\tidle_threads_init();\n\n\t\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >": 5012, "< nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\treturn null;\n}\n\nstatic void *sched_debug_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\treturn sched_debug_start(file, offset);\n}\n\nstatic void sched_debug_stop(struct seq_file *file, void *data)\n{\n}\n\nstatic const struct seq_operations sched_debug_sops = {\n\t.start = sched_debug_start,\n\t.next = sched_debug_next,\n\t.stop = sched_debug_stop,\n\t.show = sched_debug_show,\n};\n\nstatic int sched_debug_release(struct inode *inode, struct file *file)\n{\n\tseq_release(inode, file);\n\n\treturn 0;\n}\n\nstatic int sched_debug_open(struct inode *inode, struct file *filp)\n{\n\tint ret = 0;\n\n\tret = seq_open(filp, &sched_debug_sops);\n\n\treturn ret;\n}\n\nstatic const struct file_operations sched_debug_fops = {\n\t.open\t\t= sched_debug_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= sched_debug_release,\n};\n\nstatic int __init init_sched_debug_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create(\"sched_debug\", 0444, null, &sched_debug_fops);\n\tif (!pe)\n\t\treturn -enomem;\n\treturn 0;\n}\n\n__initcall(init_sched_debug_procfs);\n\n#define __p(f) \\\n\tseq_printf(m, \"%-45s:%21ld\\n\", #f, (long long)f)\n#define p(f) \\\n\tseq_printf(m, \"%-45s:%21ld\\n\", #f, (long long)p->": 5013, "< nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\treturn null;\n}\n\nstatic void *schedstat_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\treturn schedstat_start(file, offset);\n}\n\nstatic void schedstat_stop(struct seq_file *file, void *data)\n{\n}\n\nstatic const struct seq_operations schedstat_sops = {\n\t.start = schedstat_start,\n\t.next  = schedstat_next,\n\t.stop  = schedstat_stop,\n\t.show  = show_schedstat,\n};\n\nstatic int schedstat_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &schedstat_sops);\n}\n\nstatic const struct file_operations proc_schedstat_operations = {\n\t.open    = schedstat_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic int __init proc_schedstat_init(void)\n{\n\tproc_create(\"schedstat\", 0, null, &proc_schedstat_operations);\n\treturn 0;\n}\nsubsys_initcall(proc_schedstat_init);\n\n\n#include <linux/export.h>": 5014, "< nr_cpu_ids)\n\t\treturn -einval;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -einval;\n\n\tif (!alloc_cpumask_var(&mask, gfp_kernel))\n\t\treturn -enomem;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tsize_t retlen = min_t(size_t, len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -efault;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\nint get_compat_itimerspec(struct itimerspec *dst,\n\t\t\t  const struct compat_itimerspec __user *src)\n{\n\tif (__compat_get_timespec(&dst->": 5015, "< nr_cpu_ids)\n\t\treturn -einval;\n\tif (len & (sizeof(unsigned long)-1))\n\t\treturn -einval;\n\n\tif (!alloc_cpumask_var(&mask, gfp_kernel))\n\t\treturn -enomem;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tsize_t retlen = min_t(size_t, len, cpumask_size());\n\n\t\tif (copy_to_user(user_mask_ptr, mask, retlen))\n\t\t\tret = -efault;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\n\nsyscall_define0(sched_yield)\n{\n\tstruct rq *rq = this_rq_lock();\n\n\tschedstat_inc(rq, yld_count);\n\tcurrent->": 5016, "< nr_cpu_ids)\n\t\treturn per_cpu_ptr(rsp->": 5017, "< nr_cpu_ids)\n\t\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n#else \n\thousekeeping_affine(current);\n#endif \n}\n\n\nstatic void rcu_dynticks_task_enter(void)\n{\n#if defined(config_tasks_rcu) && defined(config_no_hz_full)\n\taccess_once(current->": 5018, "< nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(lowest_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\treturn -1;\n}\n\n\nstatic struct rq *find_lock_lowest_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *lowest_rq = null;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < rt_max_tries; tries++) {\n\t\tcpu = find_lowest_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->": 5019, "< nr_cpu_ids;\n\t     cpu = cpumask_next_and(cpu, nodemask, mask)) {\n\t\tif (cpu_online(cpu))\n\t\t\tgoto call;\n\t}\n\n\t\n\tcpu = cpumask_any_and(mask, cpu_online_mask);\ncall:\n\tret = smp_call_function_single(cpu, func, info, wait);\n\tput_cpu();\n\treturn ret;\n}\nexport_symbol_gpl(smp_call_function_any);\n\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t\n\twarn_on_once(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t\n\tif (cpu >": 5020, "< nr_irqs; i++)\n\t\t\tinfo->": 5021, "< nr_lock_chains)\n\t\treturn lock_chains + (*pos - 1);\n\n\treturn null;\n}\n\nstatic void *lc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn lc_start(m, pos);\n}\n\nstatic void lc_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int lc_show(struct seq_file *m, void *v)\n{\n\tstruct lock_chain *chain = v;\n\tstruct lock_class *class;\n\tint i;\n\n\tif (v == seq_start_token) {\n\t\tseq_printf(m, \"all lock chains:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"irq_context: %d\\n\", chain->": 5022, "< nr_lockdep_caching_classes)\n\t\tclass = lock->": 5023, "< nr_lockdep_caching_classes)\n\t\tlock->": 5024, "< nr_lockdep_caching_classes; i++)\n\t\tlock->": 5025, "< nr_mm_counters; i++) {\n\t\tlong x = atomic_long_read(&mm->": 5026, "< nr_node_ids; i++) {\n\t\tprintk(kern_warning \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(kern_cont \"%02d \", node_distance(i,j));\n\t\tprintk(kern_cont \"\\n\");\n\t}\n\tprintk(kern_warning \"\\n\");\n}\n\nbool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (n <= 1)\n\t\tsched_numa_topology_type = numa_direct;\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tnuma_glueless_mesh;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = numa_backplane;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void sched_init_numa(void)\n{\n\tint next_distance, curr_distance = node_distance(0, 0);\n\tstruct sched_domain_topology_level *tl;\n\tint level = 0;\n\tint i, j, k;\n\n\tsched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, gfp_kernel);\n\tif (!sched_domains_numa_distance)\n\t\treturn;\n\n\t\n\tnext_distance = curr_distance;\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tint distance = node_distance(i, k);\n\n\t\t\t\tif (distance >": 5027, "< nr_numa_hint_fault_stats * nr_node_ids; i++)\n\t\t\tgrp->": 5028, "< nr_numa_hint_fault_stats * nr_node_ids; i++) {\n\t\tmy_grp->": 5029, "< nr_numa_hint_fault_types; priv++) {\n\t\t\tlong diff, f_diff, f_weight;\n\n\t\t\tmem_idx = task_faults_idx(numa_mem, nid, priv);\n\t\t\tmembuf_idx = task_faults_idx(numa_membuf, nid, priv);\n\t\t\tcpu_idx = task_faults_idx(numa_cpu, nid, priv);\n\t\t\tcpubuf_idx = task_faults_idx(numa_cpubuf, nid, priv);\n\n\t\t\t\n\t\t\tdiff = p->": 5030, "< nr_pages; i++) {\n\t\tcompat_uptr_t p;\n\n\t\tif (get_user(p, pages32 + i) ||\n\t\t\tput_user(compat_ptr(p), pages + i))\n\t\t\treturn -efault;\n\t}\n\treturn sys_move_pages(pid, nr_pages, pages, nodes, status, flags);\n}\n\ncompat_syscall_define4(migrate_pages, compat_pid_t, pid,\n\t\t       compat_ulong_t, maxnode,\n\t\t       const compat_ulong_t __user *, old_nodes,\n\t\t       const compat_ulong_t __user *, new_nodes)\n{\n\tunsigned long __user *old = null;\n\tunsigned long __user *new = null;\n\tnodemask_t tmp_mask;\n\tunsigned long nr_bits;\n\tunsigned long size;\n\n\tnr_bits = min_t(unsigned long, maxnode - 1, max_numnodes);\n\tsize = align(nr_bits, bits_per_long) / 8;\n\tif (old_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), old_nodes, nr_bits))\n\t\t\treturn -efault;\n\t\told = compat_alloc_user_space(new_nodes ? size * 2 : size);\n\t\tif (new_nodes)\n\t\t\tnew = old + size / sizeof(unsigned long);\n\t\tif (copy_to_user(old, nodes_addr(tmp_mask), size))\n\t\t\treturn -efault;\n\t}\n\tif (new_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), new_nodes, nr_bits))\n\t\t\treturn -efault;\n\t\tif (new == null)\n\t\t\tnew = compat_alloc_user_space(size);\n\t\tif (copy_to_user(new, nodes_addr(tmp_mask), size))\n\t\t\treturn -efault;\n\t}\n\treturn sys_migrate_pages(pid, nr_bits + 1, old, new);\n}\n#endif\n\ncompat_syscall_define2(sched_rr_get_interval,\n\t\t       compat_pid_t, pid,\n\t\t       struct compat_timespec __user *, interval)\n{\n\tstruct timespec t;\n\tint ret;\n\tmm_segment_t old_fs = get_fs();\n\n\tset_fs(kernel_ds);\n\tret = sys_sched_rr_get_interval(pid, (struct timespec __user *)&t);\n\tset_fs(old_fs);\n\tif (compat_put_timespec(&t, interval))\n\t\treturn -efault;\n\treturn ret;\n}\n\n\nvoid __user *compat_alloc_user_space(unsigned long len)\n{\n\tvoid __user *ptr;\n\n\t\n\tif (unlikely(len >": 5031, "< nr_pages; i++) {\n\t\trb->": 5032, "< nr_pages; i++) {\n\t\tstruct page *page;\n\t\t\n\t\tbpage = kzalloc_node(align(sizeof(*bpage), cache_line_size()),\n\t\t\t\t    gfp_kernel | __gfp_noretry,\n\t\t\t\t    cpu_to_node(cpu));\n\t\tif (!bpage)\n\t\t\tgoto free_pages;\n\n\t\tlist_add(&bpage->": 5033, "< nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->": 5034, "< nr_pages;) {\n\t\tstruct page *page;\n\t\tint last, order;\n\n\t\torder = min(max_order, ilog2(nr_pages - rb->": 5035, "< nr_profile_hit; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, null, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, nr_profile_hit*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >": 5036, "< nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start >": 5037, "< nr_segments; i++) {\n\t\t\tresult = kimage_load_segment(image, &image->": 5038, "< nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->": 5039, "< nr_segments; i++) {\n\t\tresult = copy_from_user(&in, &segments[i], sizeof(in));\n\t\tif (result)\n\t\t\treturn -efault;\n\n\t\tout.buf   = compat_ptr(in.buf);\n\t\tout.bufsz = in.bufsz;\n\t\tout.mem   = in.mem;\n\t\tout.memsz = in.memsz;\n\n\t\tresult = copy_to_user(&ksegments[i], &out, sizeof(out));\n\t\tif (result)\n\t\t\treturn -efault;\n\t}\n\n\treturn sys_kexec_load(entry, nr_segments, ksegments, flags);\n}\n#endif\n\n#ifdef config_kexec_file\nsyscall_define5(kexec_file_load, int, kernel_fd, int, initrd_fd,\n\t\tunsigned long, cmdline_len, const char __user *, cmdline_ptr,\n\t\tunsigned long, flags)\n{\n\tint ret = 0, i;\n\tstruct kimage **dest_image, *image;\n\n\t\n\tif (!capable(cap_sys_boot) || kexec_load_disabled)\n\t\treturn -eperm;\n\n\t\n\tif (flags != (flags & kexec_file_flags))\n\t\treturn -einval;\n\n\timage = null;\n\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -ebusy;\n\n\tdest_image = &kexec_image;\n\tif (flags & kexec_file_on_crash)\n\t\tdest_image = &kexec_crash_image;\n\n\tif (flags & kexec_file_unload)\n\t\tgoto exchange;\n\n\t\n\tif (flags & kexec_file_on_crash)\n\t\tkimage_free(xchg(&kexec_crash_image, null));\n\n\tret = kimage_file_alloc_init(&image, kernel_fd, initrd_fd, cmdline_ptr,\n\t\t\t\t     cmdline_len, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kexec_calculate_store_digests(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < image->": 5040, "< nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->": 5041, "< nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->": 5042, "< nr_std_worker_pools; i++) {\n\t\tstruct workqueue_attrs *attrs;\n\n\t\tbug_on(!(attrs = alloc_workqueue_attrs(gfp_kernel)));\n\t\tattrs->": 5043, "< nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}\n\n\n\nstatic int enough_swap(unsigned int nr_pages, unsigned int flags)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"pm: free swap pages: %u\\n\", free_swap);\n\n\trequired = pages_for_io + nr_pages;\n\treturn free_swap >": 5044, "< nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}\n\n\n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < page_size)\n\t\treturn error < 0 ? error : -efault;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, null);\n\tif (!error) {\n\t\terror = (*flags_p & sf_nocompress_mode) ?\n\t\t\tload_image(&handle, &snapshot, header->": 5045, "< nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct cmp_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), gfp_kernel);\n\tif (!crc) {\n\t\tprintk(kern_err \"pm: failed to allocate crc\\n\");\n\t\tret = -enomem;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (is_err(data[thr].thr)) {\n\t\t\tdata[thr].thr = null;\n\t\t\tprintk(kern_err\n\t\t\t       \"pm: cannot start compression threads\\n\");\n\t\t\tret = -enomem;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t\n\tinit_waitqueue_head(&crc->": 5046, "< nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct dec_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), gfp_kernel);\n\tif (!crc) {\n\t\tprintk(kern_err \"pm: failed to allocate crc\\n\");\n\t\tret = -enomem;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (is_err(data[thr].thr)) {\n\t\t\tdata[thr].thr = null;\n\t\t\tprintk(kern_err\n\t\t\t       \"pm: cannot start decompression threads\\n\");\n\t\t\tret = -enomem;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t\n\tinit_waitqueue_head(&crc->": 5047, "< nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >": 5048, "< nr_threads; thr++) {\n\t\t\tfor (off = 0; off < lzo_unc_size; off += page_size) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), page_size);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tprintk(kern_info\n\t\t\t\t\t       \"pm: image saving progress: \"\n\t\t\t\t\t       \"%3d%%\\n\",\n\t\t\t\t               nr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->": 5049, "< nr_threads; thr++) {\n\t\tcrc->": 5050, "< nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\trcu_torture_current = null;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\t}\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = null;\n\t}\n\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tfor (i = 0; i < ncbflooders; i++)\n\t\ttorture_stop_kthread(rcu_torture_cbflood, cbflood_task[i]);\n\tif ((test_boost == 1 && cur_ops->": 5051, "< ns->": 5052, "< nsrc; i++) {\n\t\tif (i == 0 ||\n\t\t    is_core_symbol(src+i, info->": 5053, "< num; i++)\n\t\tif (kps[i]->": 5054, "< num; i++)\n\t\tif (params[i].ops->": 5055, "< num; i++) {\n\t\tif (jps[i]->": 5056, "< num; i++) {\n\t\tif (rps[i]->": 5057, "< num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->": 5058, "< num_counter_active(dest); i++) {\n\t\tfor (j = 0; j < dest->": 5059, "< num_params; i++) {\n\t\tif (kparam[i].perm == 0)\n\t\t\tcontinue;\n\t\terr = add_sysfs_param(&mod->": 5060, "< num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level >": 5061, "< num_versions; i++) {\n\t\tif (strcmp(versions[i].name, symname) != 0)\n\t\t\tcontinue;\n\n\t\tif (versions[i].crc == maybe_relocated(*crc, crc_owner))\n\t\t\treturn 1;\n\t\tpr_debug(\"found checksum %lx vs module %lx\\n\",\n\t\t       maybe_relocated(*crc, crc_owner), versions[i].crc);\n\t\tgoto bad_version;\n\t}\n\n\tpr_warn(\"%s: no symbol version for %s\\n\", mod->": 5062, "< numchips; i++) {\n\t\t\n\t\tdgc->": 5063, "< offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5; \n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}\n\nstatic void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}\n\nstatic void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->": 5064, "< old->": 5065, "< op->": 5066, "< p->": 5067, "< page_size / sizeof(long); j++) {\n\t\tif (unlikely(buf[j] == bm_end_of_map))\n\t\t\tbreak;\n\n\t\t\n\t\tpage_key_memorize(buf + j);\n\n\t\tif (memory_bm_pfn_present(bm, buf[j]))\n\t\t\tmemory_bm_set_bit(bm, buf[j]);\n\t\telse\n\t\t\treturn -efault;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct linked_page *safe_pages_list;\n\n#ifdef config_highmem\n\nstruct highmem_pbe {\n\tstruct page *copy_page;\t\n\tstruct page *orig_page;\t\n\tstruct highmem_pbe *next;\n};\n\n\nstatic struct highmem_pbe *highmem_pblist;\n\n\n\nstatic unsigned int count_highmem_image_pages(struct memory_bitmap *bm)\n{\n\tunsigned long pfn;\n\tunsigned int cnt = 0;\n\n\tmemory_bm_position_reset(bm);\n\tpfn = memory_bm_next_pfn(bm);\n\twhile (pfn != bm_end_of_map) {\n\t\tif (pagehighmem(pfn_to_page(pfn)))\n\t\t\tcnt++;\n\n\t\tpfn = memory_bm_next_pfn(bm);\n\t}\n\treturn cnt;\n}\n\n\n\nstatic unsigned int safe_highmem_pages;\n\nstatic struct memory_bitmap *safe_highmem_bm;\n\nstatic int\nprepare_highmem_image(struct memory_bitmap *bm, unsigned int *nr_highmem_p)\n{\n\tunsigned int to_alloc;\n\n\tif (memory_bm_create(bm, gfp_atomic, pg_safe))\n\t\treturn -enomem;\n\n\tif (get_highmem_buffer(pg_safe))\n\t\treturn -enomem;\n\n\tto_alloc = count_free_highmem_pages();\n\tif (to_alloc >": 5068, "< page_size ? len : -einval;\n}\n\nstatic ssize_t store_cpumask(struct padata_instance *pinst,\n\t\t\t     struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tcpumask_var_t new_cpumask;\n\tssize_t ret;\n\tint mask_type;\n\n\tif (!alloc_cpumask_var(&new_cpumask, gfp_kernel))\n\t\treturn -enomem;\n\n\tret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmask_type = !strcmp(attr->": 5069, "< page_size)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->": 5070, "< page_size) {\n\t\tif (error >": 5071, "< page_size) {\n\t\tprintk(kern_err \"pm: adding page to bio failed at %llu\\n\",\n\t\t\t(unsigned long long)sector);\n\t\tbio_put(bio);\n\t\treturn -efault;\n\t}\n\n\tlock_page(page);\n\tbio_get(bio);\n\n\tif (bio_chain == null) {\n\t\tsubmit_bio(bio_rw, bio);\n\t\twait_on_page_locked(page);\n\t\tif (rw == read)\n\t\t\tbio_set_pages_dirty(bio);\n\t\tbio_put(bio);\n\t} else {\n\t\tif (rw == read)\n\t\t\tget_page(page);\t\n\t\tbio->": 5072, "< pages)\n\t\tsize = min_t(unsigned long, pages, max_size);\n\n\t\n\tshrink_all_memory(saveable - size);\n\n\t\n\tpages_highmem = preallocate_image_highmem(highmem / 2);\n\talloc = count - max_size;\n\tif (alloc >": 5073, "< pages; i++) {\n\t\tpg->": 5074, "< panic_timeout * 1000; i += panic_timer_step) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >": 5075, "< parent->": 5076, "< parser->": 5077, "< path_max);\n\n\tcgrp = cgroup_kn_lock_live(of->": 5078, "< pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}\n\nstatic void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent)\n{\n\tchar cmd[task_comm_len];\n\n\ttrace_find_cmdline(ent->": 5079, "< pend))\n\t\t\t\treturn result;\n\t\t}\n\t}\n\n\t\n\tresult = -einval;\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->": 5080, "< percent_b)\n\t\treturn -1;\n\tif (percent_a >": 5081, "< perf_aux_size(rb))\n\t\t\thandle->": 5082, "< perf_data_size(rb) + page_size)\n\t\t\tgoto aux_unlock;\n\n\t\tif (aux_offset != vma->": 5083, "< perf_event_state_inactive)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\toutput(event, data);\n\t}\n}\n\nstatic void\nperf_event_aux(perf_event_aux_output_cb output, void *data,\n\t       struct perf_event_context *task_ctx)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->": 5084, "< perf_nr_contexts; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->": 5085, "< perf_nr_contexts; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = null;\n\t\t}\n\t}\n\n\tif (!--tp_event->": 5086, "< perf_nr_contexts; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = null;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->": 5087, "< perf_nr_task_contexts; (ctxn)++)\n\n\nvoid __perf_event_task_sched_out(struct task_struct *task,\n\t\t\t\t struct task_struct *next)\n{\n\tint ctxn;\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(task, next, false);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_context_sched_out(task, ctxn, next);\n\n\t\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_out(task, next);\n}\n\nstatic void task_ctx_sched_out(struct perf_event_context *ctx)\n{\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\n\tif (!cpuctx->": 5088, "< pg->": 5089, "< pi->": 5090, "< pidmap_entries; i++)\n\t\tatomic_set(&ns->": 5091, "< pidmap_entries; i++)\n\t\tkfree(ns->": 5092, "< pidtype_max; ++type)\n\t\tinit_hlist_head(&pid->": 5093, "< pidtype_max; ++type) {\n\t\tinit_hlist_node(&links[type].node); \n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}\n\nstruct task_struct *fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\ttask = copy_process(clone_vm, 0, 0, null, &init_struct_pid, 0);\n\tif (!is_err(task)) {\n\t\tinit_idle_pids(task->": 5094, "< pm_qos_num_classes; i++) {\n\t\tret = register_pm_qos_misc(pm_qos_array[i], d);\n\t\tif (ret < 0) {\n\t\t\tprintk(kern_err \"pm_qos_param: %s setup failed\\n\",\n\t\t\t       pm_qos_array[i]->": 5095, "< pm_qos_num_classes; pm_qos_class++) {\n\t\tif (minor ==\n\t\t\tpm_qos_array[pm_qos_class]->": 5096, "< pm_suspend_max)\n\t\terror = pm_suspend(state);\n\telse if (state == pm_suspend_max)\n\t\terror = hibernate();\n\telse\n\t\terror = -einval;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}\n\npower_attr(state);\n\n#ifdef config_pm_sleep\n\n\nstatic ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -eintr;\n}\n\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() >": 5097, "< pm_suspend_max)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef config_hibernation\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}\n\nstatic ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == pm_suspend_on\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -einval;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}\n\npower_attr(autosleep);\n#endif \n\n#ifdef config_pm_wakelocks\nstatic ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}\n\nstatic ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}\n\npower_attr(wake_lock);\n\nstatic ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}\n\nstatic ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}\n\npower_attr(wake_unlock);\n\n#endif \n#endif \n\n#ifdef config_pm_trace\nint pm_trace_enabled;\n\nstatic ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}\n\nstatic ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"pm: enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"pm: correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -einval;\n}\n\npower_attr(pm_trace);\n\nstatic ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, page_size);\n}\n\nstatic ssize_t\npm_trace_dev_match_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t n)\n{\n\treturn -einval;\n}\n\npower_attr(pm_trace_dev_match);\n\n#endif \n\n#ifdef config_freezer\nstatic ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}\n\nstatic ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -einval;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}\n\npower_attr(pm_freeze_timeout);\n\n#endif\t\n\nstatic struct attribute * g[] = {\n\t&state_attr.attr,\n#ifdef config_pm_trace\n\t&pm_trace_attr.attr,\n\t&pm_trace_dev_match_attr.attr,\n#endif\n#ifdef config_pm_sleep\n\t&pm_async_attr.attr,\n\t&wakeup_count_attr.attr,\n#ifdef config_pm_autosleep\n\t&autosleep_attr.attr,\n#endif\n#ifdef config_pm_wakelocks\n\t&wake_lock_attr.attr,\n\t&wake_unlock_attr.attr,\n#endif\n#ifdef config_pm_debug\n\t&pm_test_attr.attr,\n#endif\n#ifdef config_pm_sleep_debug\n\t&pm_print_times_attr.attr,\n#endif\n#endif\n#ifdef config_freezer\n\t&pm_freeze_timeout_attr.attr,\n#endif\n\tnull,\n};\n\nstatic struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\nstruct workqueue_struct *pm_wq;\nexport_symbol_gpl(pm_wq);\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", wq_freezable, 0);\n\n\treturn pm_wq ? 0 : -enomem;\n}\n\nstatic int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpower_kobj = kobject_create_and_add(\"power\", null);\n\tif (!power_kobj)\n\t\treturn -enomem;\n\terror = sysfs_create_group(power_kobj, &attr_group);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}\n\ncore_initcall(pm_init);\n\n\n#include <linux/init.h>": 5098, "< pm_suspend_max; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t\n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef config_suspend\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn pm_suspend_max;\n\n#ifdef config_suspend\n\tfor (state = pm_suspend_min; state < pm_suspend_max; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn pm_suspend_on;\n}\n\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() >": 5099, "< pm_suspend_max; test_state++) {\n\t\tconst char *state_label = pm_states[test_state];\n\n\t\tif (state_label && !strcmp(test_state_label, state_label))\n\t\t\tbreak;\n\t}\n\tif (test_state == pm_suspend_max) {\n\t\tprintk(warn_bad_state, test_state_label);\n\t\treturn 0;\n\t}\n\n\t\n\tdev = class_find_device(rtc_class, null, null, has_wakealarm);\n\tif (dev)\n\t\trtc = rtc_class_open(dev_name(dev));\n\tif (!rtc) {\n\t\tprintk(warn_no_rtc);\n\t\treturn 0;\n\t}\n\n\t\n\ttest_wakealarm(rtc, test_state);\n\trtc_class_close(rtc);\n\treturn 0;\n}\nlate_initcall(test_suspend);\n\n\n#include <linux/errno.h>": 5100, "< pos && i + insn->": 5101, "< pos)\n\t\t\tinsn->": 5102, "< pps_intmax) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}\n\n\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t\n\tif (freq_norm.sec >": 5103, "< preempt_mask) &&\n\t\t\t!(preempt_count() & preempt_mask)))\n\t\treturn;\n#endif\n\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(caller_addr0, get_parent_ip(caller_addr1));\n\t__preempt_count_sub(val);\n}\nexport_symbol(preempt_count_sub);\nnokprobe_symbol(preempt_count_sub);\n\n#endif\n\n\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(kern_err \"bug: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->": 5104, "< prev_prio)\n\t\tcpupri_set(&rq->": 5105, "< prev_prio)\n\t\trt_rq->": 5106, "< prev_prio);\n\n\t\t\n\t\tif (prio == prev_prio) {\n\t\t\tstruct rt_prio_array *array = &rt_rq->": 5107, "< prio)\n\t\t\tenqueue_flag = enqueue_head;\n\t\tp->": 5108, "< prio_process)\n\t\tgoto out;\n\n\t\n\terror = -esrch;\n\tif (niceval < min_nice)\n\t\tniceval = min_nice;\n\tif (niceval >": 5109, "< prio_process)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tswitch (which) {\n\tcase prio_process:\n\t\tif (who)\n\t\t\tp = find_task_by_vpid(who);\n\t\telse\n\t\t\tp = current;\n\t\tif (p) {\n\t\t\tniceval = nice_to_rlimit(task_nice(p));\n\t\t\tif (niceval >": 5110, "< prog->": 5111, "< ps->": 5112, "< pwq->": 5113, "< r->": 5114, "< r2->": 5115, "< range[j].end) {\n\t\t\t\n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->": 5116, "< rb->": 5117, "< rb_page_size(reader))\n\t\tgoto out;\n\n\t\n\tif (rb_warn_on(cpu_buffer,\n\t\t       cpu_buffer->": 5118, "< rcu_next_size; i++)\n\t\t\tif (&rdp->": 5119, "< rcu_next_size; i++)\n\t\trdp->": 5120, "< rcu_next_tail; i++)\n\t\tif (rdp->": 5121, "< rcu_next_tail; i++)\n\t\tif (ulong_cmp_lt(c, rdp->": 5122, "< rcu_next_tail; i++) {\n\t\tif (ulong_cmp_lt(rnp->": 5123, "< rcu_next_tail; i++, j++) {\n\t\tif (rdp->": 5124, "< rcu_num_lvls; i++)\n\t\trsp->": 5125, "< rcu_num_nodes; rnp++) {\n\t\tif (rnp->": 5126, "< rcu_stall_rat_delay || !rcu_gp_in_progress(rsp)) {\n\t\traw_spin_unlock_irqrestore(&rnp->": 5127, "< rcu_torture_pipe_len + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, torture_flag);\n\tpr_cont(\"reader batch: \");\n\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, torture_flag);\n\tpr_cont(\"free-block circulation: \");\n\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->": 5128, "< rcu_torture_pipe_len + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = rcu_torture_pipe_len - 1; i >": 5129, "< rdp->": 5130, "< re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->": 5131, "< read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < lzo_cmp_pages ?\n\t\t                                  __gfp_wait | __gfp_high :\n\t\t                                  __gfp_wait | __gfp_nowarn |\n\t\t                                  __gfp_noretry);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < lzo_cmp_pages) {\n\t\t\t\tring_size = i;\n\t\t\t\tprintk(kern_err\n\t\t\t\t       \"pm: failed to allocate lzo pages\\n\");\n\t\t\t\tret = -enomem;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tprintk(kern_info\n\t\t\"pm: using %u thread(s) for decompression.\\n\"\n\t\t\"pm: loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_threads, nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tbio = null;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &bio);\n\t\t\tif (ret) {\n\t\t\t\t\n\t\t\t\tif (handle->": 5132, "< real_tk->": 5133, "< rec->": 5134, "< region->": 5135, "< regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}\n\n\nstatic void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >": 5136, "< repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z >": 5137, "< res.end) &&\n\t\t(!find_next_iomem_res(&res, name, false))) {\n\t\tret = (*func)(res.start, res.end, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tres.start = res.end + 1;\n\t\tres.end = orig_end;\n\t}\n\treturn ret;\n}\n\n\nint walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\t\tint (*func)(u64, u64, void *))\n{\n\tstruct resource res;\n\tu64 orig_end;\n\tint ret = -1;\n\n\tres.start = start;\n\tres.end = end;\n\tres.flags = ioresource_mem | ioresource_busy;\n\torig_end = res.end;\n\twhile ((res.start < res.end) &&\n\t\t(!find_next_iomem_res(&res, \"system ram\", true))) {\n\t\tret = (*func)(res.start, res.end, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tres.start = res.end + 1;\n\t\tres.end = orig_end;\n\t}\n\treturn ret;\n}\n\n#if !defined(config_arch_has_walk_memory)\n\n\nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\tvoid *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tu64 orig_end;\n\tint ret = -1;\n\n\tres.start = (u64) start_pfn << page_shift;\n\tres.end = ((u64)(start_pfn + nr_pages) << page_shift) - 1;\n\tres.flags = ioresource_mem | ioresource_busy;\n\torig_end = res.end;\n\twhile ((res.start < res.end) &&\n\t\t(find_next_iomem_res(&res, \"system ram\", true) >": 5138, "< right);\n\tcase audit_le:\n\t\treturn (left <= right);\n\tcase audit_gt:\n\t\treturn (left >": 5139, "< ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->": 5140, "< root->": 5141, "< rp->": 5142, "< rq->": 5143, "< rq2) {\n\t\t\traw_spin_lock(&rq1->": 5144, "< rsp->": 5145, "< rt_b->": 5146, "< rule->": 5147, "< run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(kern_err \"pm: lzo compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >": 5148, "< runtime) {\n\t\t\t\trt_rq->": 5149, "< rwsem_waiting_bias)) {\n\t\t\t\n\t\t\tif (rwsem_atomic_update(-adjustment, sem) &\n\t\t\t\t\t\trwsem_active_mask)\n\t\t\t\tgoto out;\n\t\t\t\n\t\t\tgoto try_reader_grant;\n\t\t}\n\t}\n\n\t\n\twoken = 0;\n\tdo {\n\t\twoken++;\n\n\t\tif (waiter->": 5150, "< s->": 5151, "< sched_attr_size_ver0 || flags)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -esrch;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tattr.sched_policy = p->": 5152, "< sched_attr_size_ver0)\n\t\tgoto err_size;\n\n\t\n\tif (size >": 5153, "< sched_nr_latency)\n\t\thrtick_start_fair(rq, curr);\n}\n#else \nstatic inline void\nhrtick_start_fair(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline void hrtick_update(struct rq *rq)\n{\n}\n#endif\n\n\nstatic void\nenqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->": 5154, "< sd->": 5155, "< sechdrs[i].sh_size/sizeof(elf_sym); k++) {\n\t\t\tif (elf_st_bind(syms[k].st_info) != stb_global)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == shn_undef ||\n\t\t\t    syms[k].st_shndx >": 5156, "< sect_attrs->": 5157, "< sgs->": 5158, "< shdr->": 5159, "< sigrtmin)\n\t\toverride_rlimit = (is_si_special(info) || info->": 5160, "< sigrtmin) && sigismember(&signals->": 5161, "< size)\n\t\t\tgoto out_unlock;\n\n\t\t\n\t\tsave_timestamp = cpu_buffer->": 5162, "< size) {\n\t\tstruct linked_page *lp;\n\n\t\tlp = get_image_page(ca->": 5163, "< size))\n\t\t\tgoto fail;\n\n\t\t\n\n\t\thead += size;\n\t} while (local_cmpxchg(&rb->": 5164, "< size; i++)\n\t\t\tstate->": 5165, "< size; i++) {\n\t\t\tif (slot_type[i] != stack_misc) {\n\t\t\t\tverbose(\"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -eacces;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >": 5166, "< size; i++) {\n\t\thhd = &hash->": 5167, "< size; i++) {\n\t\thhd = &src->": 5168, "< size; i++) {\n\t\thlist_for_each_entry(entry, &hash->": 5169, "< size; i++) {\n\t\tif (d >": 5170, "< sizeof(*(info->": 5171, "< sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\treturn -efbig;\n\t\t}\n\n\t\tattr->": 5172, "< sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >": 5173, "< sizeof(stat_nam) - 1 ? stat_nam[state] : '?');\n#if bits_per_long == 32\n\tif (state == task_running)\n\t\tprintk(kern_cont \" running  \");\n\telse\n\t\tprintk(kern_cont \" %08lx \", thread_saved_pc(p));\n#else\n\tif (state == task_running)\n\t\tprintk(kern_cont \"  running task    \");\n\telse\n\t\tprintk(kern_cont \" %016lx \", thread_saved_pc(p));\n#endif\n#ifdef config_debug_stack_usage\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->": 5174, "< sizeof(state_to_char) - 1 ? state_to_char[bit] : '?';\n}\n\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (event_hashsize - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->": 5175, "< sizeof(struct audit_rule_data))\n\t\t\treturn -einval;\n\t\tif (audit_enabled == audit_locked) {\n\t\t\taudit_log_common_recv_msg(&ab, audit_config_change);\n\t\t\taudit_log_format(ab, \" audit_enabled=%d res=0\", audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -eperm;\n\t\t}\n\t\terr = audit_rule_change(msg_type, netlink_cb(skb).portid,\n\t\t\t\t\t   seq, data, nlmsg_len(nlh));\n\t\tbreak;\n\tcase audit_list_rules:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase audit_trim:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(&ab, audit_config_change);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase audit_make_equiv: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = nlmsg_len(nlh);\n\t\tchar *old, *new;\n\n\t\terr = -einval;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (is_err(old)) {\n\t\t\terr = ptr_err(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (is_err(new)) {\n\t\t\terr = ptr_err(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(&ab, audit_config_change);\n\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase audit_signal_info:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(sizeof(*sig_data) + len, gfp_kernel);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -enomem;\n\t\t}\n\t\tsig_data->": 5176, "< sizeof(struct sock_filter));\n\tfp_size = fprog->": 5177, "< sizeof(unsigned int) && count >": 5178, "< slots_per_page(c)) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\t\tif (kip->": 5179, "< slots_per_page(c)) {\n\t\t\twarn_on(kip->": 5180, "< slots_per_page(c); i++) {\n\t\t\tif (kip->": 5181, "< src->": 5182, "< src_rq->": 5183, "< srcu_callback_batch; i++) {\n\t\thead = rcu_batch_dequeue(&sp->": 5184, "< start + mod->": 5185, "< start + size));\n}\n\n\nstatic int gcov_module_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t\tvoid *data)\n{\n\tstruct module *mod = data;\n\tstruct gcov_info *info = null;\n\tstruct gcov_info *prev = null;\n\n\tif (event != module_state_going)\n\t\treturn notify_ok;\n\tmutex_lock(&gcov_lock);\n\n\t\n\twhile ((info = gcov_info_next(info))) {\n\t\tif (within(info, mod->": 5186, "< start + size);\n}\n\n#ifdef config_kallsyms\n\nstatic inline int is_arm_mapping_symbol(const char *str)\n{\n\tif (str[0] == '.' && str[1] == 'l')\n\t\treturn true;\n\treturn str[0] == '$' && strchr(\"axtd\", str[1])\n\t       && (str[2] == '\\0' || str[2] == '.');\n}\n\nstatic const char *get_ksymbol(struct module *mod,\n\t\t\t       unsigned long addr,\n\t\t\t       unsigned long *size,\n\t\t\t       unsigned long *offset)\n{\n\tunsigned int i, best = 0;\n\tunsigned long nextval;\n\n\t\n\tif (within_module_init(addr, mod))\n\t\tnextval = (unsigned long)mod->": 5187, "< start + size;\n}\n\n\nvoid lockdep_free_key_range(void *start, unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct list_head *head;\n\tunsigned long flags;\n\tint i;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\n\t\n\tfor (i = 0; i < classhash_size; i++) {\n\t\thead = classhash_table + i;\n\t\tif (list_empty(head))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (within(class->": 5188, "< start || temp_start < kbuf->": 5189, "< start)\n\t\t\tbreak;\t\n\t}\n\tread_unlock(&resource_lock);\n\treturn ret;\n}\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}\n\nstatic resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->": 5190, "< start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}\n\nstatic int __release_resource(struct resource *old)\n{\n\tstruct resource *tmp, **p;\n\n\tp = &old->": 5191, "< start)\n\t\treturn root;\n\tif (start < root->": 5192, "< start) || (tmp->": 5193, "< start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}\n\nstatic void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(null, pos);\n}\n\nstatic void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t\n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}\n\nstatic const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &show_format_seq_ops);\n}\n\nstatic const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic __init int init_trace_printk_function_export(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (is_err(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", 0444, d_tracer,\n\t\t\t\t    null, &ftrace_formats_fops);\n\n\treturn 0;\n}\n\nfs_initcall(init_trace_printk_function_export);\n\nstatic __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}\n\nearly_initcall(init_trace_printk);\n\n#include <linux/rwsem.h>": 5194, "< stat.size) {\n\t\tbytes = kernel_read(f.file, pos, (char *)(*buf) + pos,\n\t\t\t\t    stat.size - pos);\n\t\tif (bytes < 0) {\n\t\t\tvfree(*buf);\n\t\t\tret = bytes;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t\tpos += bytes;\n\t}\n\n\tif (pos != stat.size) {\n\t\tret = -ebadf;\n\t\tvfree(*buf);\n\t\tgoto out;\n\t}\n\n\t*buf_len = pos;\nout:\n\tfdput(f);\n\treturn ret;\n}\n\n\nint __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\n\t\t\t\t\t unsigned long buf_len)\n{\n\treturn -enoexec;\n}\n\nvoid * __weak arch_kexec_kernel_image_load(struct kimage *image)\n{\n\treturn err_ptr(-enoexec);\n}\n\nvoid __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n}\n\nint __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t\tunsigned long buf_len)\n{\n\treturn -ekeyrejected;\n}\n\n\nint __weak\narch_kexec_apply_relocations_add(const elf_ehdr *ehdr, elf_shdr *sechdrs,\n\t\t\t\t unsigned int relsec)\n{\n\tpr_err(\"rela relocation unsupported.\\n\");\n\treturn -enoexec;\n}\n\n\nint __weak\narch_kexec_apply_relocations(const elf_ehdr *ehdr, elf_shdr *sechdrs,\n\t\t\t     unsigned int relsec)\n{\n\tpr_err(\"rel relocation unsupported.\\n\");\n\treturn -enoexec;\n}\n\n\nstatic void kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->": 5195, "< stat.size) {\n\t\tbytes = kernel_read(f.file, pos, (char *)(info->": 5196, "< stop; start++) {\n\t\tif ((*start)->": 5197, "< strlen(buts->": 5198, "< strlen(name); i++) {\n\t\t\t\tchar c = name[i];\n\t\t\t\tif (isalnum(c))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n\t\t\t\t\tcontinue;\n\t\t\t\treturn -einval;\n\t\t\t}\n\t\t\t\n\t\t\tif (opts->": 5199, "< symsec->": 5200, "< sysctl_sched_migration_cost ||\n\t    !this_rq->": 5201, "< sysctl_sched_min_granularity)\n\t\treturn;\n\n\tse = __pick_first_entity(cfs_rq);\n\tdelta = curr->": 5202, "< t)\n\t\t\t\n\t\t\tcval = cputime_one_jiffy;\n\t\telse\n\t\t\tcval = cval - t;\n\t}\n\n\tspin_unlock_irq(&tsk->": 5203, "< t2) | ((t1 >": 5204, "< task_comm_len);\n\n\t\n\tdelta = ktime_get_ns() - tsk->": 5205, "< task_faults(p, src_nid);\n}\n\n#else\nstatic inline bool migrate_improves_locality(struct task_struct *p,\n\t\t\t\t\t     struct lb_env *env)\n{\n\treturn false;\n}\n\nstatic inline bool migrate_degrades_locality(struct task_struct *p,\n\t\t\t\t\t     struct lb_env *env)\n{\n\treturn false;\n}\n#endif\n\n\nstatic\nint can_migrate_task(struct task_struct *p, struct lb_env *env)\n{\n\tint tsk_cache_hot = 0;\n\n\tlockdep_assert_held(&env->": 5206, "< task_nice(p) &&\n\t\t\t    !can_nice(p, attr->": 5207, "< task_nice(p) && !can_nice(p, niceval)) {\n\t\terror = -eacces;\n\t\tgoto out;\n\t}\n\tno_nice = security_task_setnice(p, niceval);\n\tif (no_nice) {\n\t\terror = no_nice;\n\t\tgoto out;\n\t}\n\tif (error == -esrch)\n\t\terror = 0;\n\tset_user_nice(p, niceval);\nout:\n\treturn error;\n}\n\nsyscall_define3(setpriority, int, which, int, who, int, niceval)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tint error = -einval;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which >": 5208, "< this_rq) {\n\t\t\traw_spin_unlock(&this_rq->": 5209, "< this_rq->": 5210, "< tick_period.tv64)\n\t\treturn;\n\n\t\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta.tv64 >": 5211, "< tk->": 5212, "< tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->": 5213, "< tocopy; i++) {\n\t\teffective.cap[i] = kdata[i].effective;\n\t\tpermitted.cap[i] = kdata[i].permitted;\n\t\tinheritable.cap[i] = kdata[i].inheritable;\n\t}\n\twhile (i < _kernel_capability_u32s) {\n\t\teffective.cap[i] = 0;\n\t\tpermitted.cap[i] = 0;\n\t\tinheritable.cap[i] = 0;\n\t\ti++;\n\t}\n\n\teffective.cap[cap_last_u32] &= cap_last_u32_valid_mask;\n\tpermitted.cap[cap_last_u32] &= cap_last_u32_valid_mask;\n\tinheritable.cap[cap_last_u32] &= cap_last_u32_valid_mask;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n\nbool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}\n\n\nbool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}\n\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}\n\n\nbool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}\n\n\nbool ns_capable(struct user_namespace *ns, int cap)\n{\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tbug();\n\t}\n\n\tif (security_capable(current_cred(), ns, cap) == 0) {\n\t\tcurrent->": 5214, "< tp->": 5215, "< trace->": 5216, "< tracing_thresh)\n\t\t\treturn 0;\n\t} else {\n\t\tif (delta <= tr->": 5217, "< tracing_thresh))\n\t\treturn;\n\telse\n\t\ttrace_graph_return(trace);\n}\n\nstatic int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&trace_graph_thresh_return,\n\t\t\t\t\t    &trace_graph_thresh_entry);\n\telse\n\t\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t\t    &trace_graph_entry);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}\n\nstatic void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph();\n}\n\nstatic int graph_trace_update_thresh(struct trace_array *tr)\n{\n\tgraph_trace_reset(tr);\n\treturn graph_trace_init(tr);\n}\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}\n\n#define trace_graph_procinfo_length\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[task_comm_len];\n\t\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < trace_graph_procinfo_length)\n\t\tspaces = trace_graph_procinfo_length - len;\n\n\t\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}\n\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}\n\n\nstatic void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->": 5218, "< tsk->": 5219, "< tu->": 5220, "< tvn_size; i++) {\n\t\tmigrate_timer_list(new_base, old_base->": 5221, "< tvn_size; j++) {\n\t\tinit_list_head(base->": 5222, "< tvr_size) {\n\t\tint i = expires & tvr_mask;\n\t\tvec = base->": 5223, "< tvr_size; i++)\n\t\tmigrate_timer_list(new_base, old_base->": 5224, "< tvr_size; j++)\n\t\tinit_list_head(base->": 5225, "< txc->": 5226, "< u->": 5227, "< uidhash_sz; ++n)\n\t\tinit_hlist_head(uidhash_table + n);\n\n\t\n\tspin_lock_irq(&uidhash_lock);\n\tuid_hash_insert(&root_user, uidhashentry(global_root_uid));\n\tspin_unlock_irq(&uidhash_lock);\n\n\treturn 0;\n}\nsubsys_initcall(uid_cache_init);\n\n\nextern int mod_verify_sig(const void *mod, unsigned long *_modlen);\n\n\n#define pr_fmt(fmt) kbuild_modname \": \" fmt\n\n#include <linux/file.h>": 5228, "< uinsns_per_page) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->": 5229, "< uinsns_per_page));\n\t} while (slot_nr >": 5230, "< uprobes_hash_sz; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tif (percpu_init_rwsem(&dup_mmap_sem))\n\t\treturn -enomem;\n\n\treturn register_die_notifier(&uprobe_exception_nb);\n}\n__initcall(init_uprobes);\n\n\n#include <linux/capability.h>": 5231, "< usec_per_sec))\n\nint do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\t\n\tif (!timeval_valid(&value->": 5232, "< usecs)\n\t\t\t++fail_count;\n\t\twarn_on(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" fail=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int udelay_test_show(struct seq_file *s, void *v)\n{\n\tint usecs;\n\tint iters;\n\tint ret = 0;\n\n\tmutex_lock(&udelay_test_lock);\n\tusecs = udelay_test_usecs;\n\titers = udelay_test_iterations;\n\tmutex_unlock(&udelay_test_lock);\n\n\tif (usecs >": 5233, "< user_hz\n\treturn x * (user_hz / hz);\n# else\n\treturn x / (hz / user_hz);\n# endif\n#else\n\treturn div_u64((u64)x * tick_nsec, nsec_per_sec / user_hz);\n#endif\n}\nexport_symbol(jiffies_to_clock_t);\n\nunsigned long clock_t_to_jiffies(unsigned long x)\n{\n#if (hz % user_hz)==0\n\tif (x >": 5234, "< user_hz\n\tx = div_u64(x * user_hz, hz);\n# elif hz >": 5235, "< val))\n\t\t\treturn -einval;\n\t\t*valp = val;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_dointvec_minmax_conv_param param = {\n\t\t.min = (int *) table->": 5236, "< val);\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase op_le:\t\t\t\t\t\t\t\\\n\t\tmatch = (*addr <= val);\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase op_gt:\t\t\t\t\t\t\t\\\n\t\tmatch = (*addr >": 5237, "< view->": 5238, "< vmacache_size; i++) {\n\t\t\tif (!current->": 5239, "< w)\n\t\t\twl = (w * (long)tg->": 5240, "< wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t\n\t\tput_packet(gdbmsgbuf);\n\t}\n}\n\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t\n\ttmp = buf + count;\n\n\terr = probe_kernel_read(tmp, mem, count);\n\tif (err)\n\t\treturn null;\n\twhile (count >": 5241, "< work_nr_colors; i++) {\n\t\t\tif (warn_on(pwq->": 5242, "< zone->": 5243, "<%u>": 5244, "<, end_code);\n\terror |= __prctl_check_order(start_data, <, end_data);\n\terror |= __prctl_check_order(start_brk, <=, brk);\n\terror |= __prctl_check_order(arg_start, <=, arg_end);\n\terror |= __prctl_check_order(env_start, <=, env_end);\n\tif (error)\n\t\tgoto out;\n#undef __prctl_check_order\n\n\terror = -einval;\n\n\t\n\tif (prctl_map->": 5245, "<- %lx)\";\n\t\targ = \"rec->": 5246, "<...>": 5247, "<<\n\t\t\t\t\t\t(tk->": 5248, "<<  1)\n#define max_shares\t(1ul << 18)\n#endif\n\ntypedef int (*tg_visitor)(struct task_group *, void *);\n\nextern int walk_tg_tree_from(struct task_group *from,\n\t\t\t     tg_visitor down, tg_visitor up, void *data);\n\n\nstatic inline int walk_tg_tree(tg_visitor down, tg_visitor up, void *data)\n{\n\treturn walk_tg_tree_from(&root_task_group, down, up, data);\n}\n\nextern int tg_nop(struct task_group *tg, void *data);\n\nextern void free_fair_sched_group(struct task_group *tg);\nextern int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent);\nextern void unregister_fair_sched_group(struct task_group *tg, int cpu);\nextern void init_tg_cfs_entry(struct task_group *tg, struct cfs_rq *cfs_rq,\n\t\t\tstruct sched_entity *se, int cpu,\n\t\t\tstruct sched_entity *parent);\nextern void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b);\nextern int sched_group_set_shares(struct task_group *tg, unsigned long shares);\n\nextern void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b);\nextern void __start_cfs_bandwidth(struct cfs_bandwidth *cfs_b, bool force);\nextern void unthrottle_cfs_rq(struct cfs_rq *cfs_rq);\n\nextern void free_rt_sched_group(struct task_group *tg);\nextern int alloc_rt_sched_group(struct task_group *tg, struct task_group *parent);\nextern void init_tg_rt_entry(struct task_group *tg, struct rt_rq *rt_rq,\n\t\tstruct sched_rt_entity *rt_se, int cpu,\n\t\tstruct sched_rt_entity *parent);\n\nextern struct task_group *sched_create_group(struct task_group *parent);\nextern void sched_online_group(struct task_group *tg,\n\t\t\t       struct task_group *parent);\nextern void sched_destroy_group(struct task_group *tg);\nextern void sched_offline_group(struct task_group *tg);\n\nextern void sched_move_task(struct task_struct *tsk);\n\n#ifdef config_fair_group_sched\nextern int sched_group_set_shares(struct task_group *tg, unsigned long shares);\n#endif\n\n#else \n\nstruct cfs_bandwidth { };\n\n#endif\t\n\n\nstruct cfs_rq {\n\tstruct load_weight load;\n\tunsigned int nr_running, h_nr_running;\n\n\tu64 exec_clock;\n\tu64 min_vruntime;\n#ifndef config_64bit\n\tu64 min_vruntime_copy;\n#endif\n\n\tstruct rb_root tasks_timeline;\n\tstruct rb_node *rb_leftmost;\n\n\t\n\tstruct sched_entity *curr, *next, *last, *skip;\n\n#ifdef\tconfig_sched_debug\n\tunsigned int nr_spread_over;\n#endif\n\n#ifdef config_smp\n\t\n\tunsigned long runnable_load_avg, blocked_load_avg, utilization_load_avg;\n\tatomic64_t decay_counter;\n\tu64 last_decay;\n\tatomic_long_t removed_load;\n\n#ifdef config_fair_group_sched\n\t\n\tu32 tg_runnable_contrib;\n\tunsigned long tg_load_contrib;\n\n\t\n\tunsigned long h_load;\n\tu64 last_h_load_update;\n\tstruct sched_entity *h_load_next;\n#endif \n#endif \n\n#ifdef config_fair_group_sched\n\tstruct rq *rq;\t\n\n\t\n\tint on_list;\n\tstruct list_head leaf_cfs_rq_list;\n\tstruct task_group *tg;\t\n\n#ifdef config_cfs_bandwidth\n\tint runtime_enabled;\n\tu64 runtime_expires;\n\ts64 runtime_remaining;\n\n\tu64 throttled_clock, throttled_clock_task;\n\tu64 throttled_clock_task_time;\n\tint throttled, throttle_count;\n\tstruct list_head throttled_list;\n#endif \n#endif \n};\n\nstatic inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >": 5249, "<< !!(file->": 5250, "<< (20 - page_shift);\n\trss = get_mm_rss(p->": 5251, "<< (bits_per_long-1))\n\n\ndefine_mutex(module_mutex);\nexport_symbol_gpl(module_mutex);\nstatic list_head(modules);\n#ifdef config_kgdb_kdb\nstruct list_head *kdb_modules = &modules; \n#endif \n\n#ifdef config_module_sig\n#ifdef config_module_sig_force\nstatic bool sig_enforce = true;\n#else\nstatic bool sig_enforce = false;\n\nstatic int param_set_bool_enable_only(const char *val,\n\t\t\t\t      const struct kernel_param *kp)\n{\n\tint err;\n\tbool test;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &test;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t\n\tif (!test && sig_enforce)\n\t\treturn -erofs;\n\n\tif (test)\n\t\tsig_enforce = true;\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_bool_enable_only = {\n\t.flags = kernel_param_ops_fl_noarg,\n\t.set = param_set_bool_enable_only,\n\t.get = param_get_bool,\n};\n#define param_check_bool_enable_only param_check_bool\n\nmodule_param(sig_enforce, bool_enable_only, 0644);\n#endif \n#endif \n\n\nint modules_disabled = 0;\ncore_param(nomodule, modules_disabled, bint, 0);\n\n\nstatic declare_wait_queue_head(module_wq);\n\nstatic blocking_notifier_head(module_notify_list);\n\n\nstatic unsigned long module_addr_min = -1ul, module_addr_max = 0;\n\nint register_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&module_notify_list, nb);\n}\nexport_symbol(register_module_notifier);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}\nexport_symbol(unregister_module_notifier);\n\nstruct load_info {\n\telf_ehdr *hdr;\n\tunsigned long len;\n\telf_shdr *sechdrs;\n\tchar *secstrings, *strtab;\n\tunsigned long symoffs, stroffs;\n\tstruct _ddebug *debug;\n\tunsigned int num_debug;\n\tbool sig_ok;\n\tstruct {\n\t\tunsigned int sym, str, mod, vers, info, pcpu;\n\t} index;\n};\n\n\nstatic inline int strong_try_module_get(struct module *mod)\n{\n\tbug_on(mod && mod->": 5252, "<< (cpu - rdp->": 5253, "<< (expsize - 1));\t\n\t\tvalue >": 5254, "<< (frac_bits - 1);\n\t\tx >": 5255, "<< (fshift - 1);\n\treturn load >": 5256, "<< (i - gc->": 5257, "<< (j * bits_per_compat_long);\n\t\t}\n\t\t*mask++ = m;\n\t}\n\n\treturn 0;\n}\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tint i, j;\n\tunsigned long m;\n\tcompat_ulong_t um;\n\tunsigned long nr_compat_longs;\n\n\t\n\tbitmap_size = align(bitmap_size, bits_per_compat_long);\n\n\tif (!access_ok(verify_write, umask, bitmap_size / 8))\n\t\treturn -efault;\n\n\tnr_compat_longs = bits_to_compat_longs(bitmap_size);\n\n\tfor (i = 0; i < bits_to_longs(bitmap_size); i++) {\n\t\tm = *mask++;\n\n\t\tfor (j = 0; j < sizeof(m)/sizeof(um); j++) {\n\t\t\tum = m;\n\n\t\t\t\n\t\t\tif (nr_compat_longs-- >": 5258, "<< (mantsize2+expsize2-1)) - 1;\n\t} else {\n\t\treturn (value & (maxfract2>": 5259, "<< (mantsize2-1));\n\t}\n}\n#endif\n\n#if acct_version == 3\n\nstatic u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value >": 5260, "<< (page_shift + page_order(rb));\n}\n\nstatic inline unsigned long perf_aux_size(struct ring_buffer *rb)\n{\n\treturn rb->": 5261, "<< (page_shift - 1);\n\nout:\n\tif (!ret)\n\t\trb->": 5262, "<< (page_shift - 10))\n\tkdb_printf(\"\\nmemtotal:       %8lu kb\\nmemfree:        %8lu kb\\n\"\n\t\t   \"buffers:        %8lu kb\\n\",\n\t\t   k(val.totalram), k(val.freeram), k(val.bufferram));\n\treturn 0;\n}\n\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0ul;\n\n\tif (argc < 1 || argc >": 5263, "<< (shift_pll + 1 + time_constant)))\n\t\tsecs = 1 << (shift_pll + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(ntp_scale_shift - 2 * (shift_pll + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, maxfreq_scaled);\n\n\ttime_freq   = max(freq_adj, -maxfreq_scaled);\n\n\ttime_offset = div_s64(offset64 << ntp_scale_shift, ntp_interval_freq);\n}\n\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t\n\ttime_status\t|= sta_unsync;\n\ttime_maxerror\t= ntp_phase_limit;\n\ttime_esterror\t= ntp_phase_limit;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\t\n\tpps_clear();\n}\n\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}\n\n\n\nint second_overflow(unsigned long secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\n\t\n\tswitch (time_state) {\n\tcase time_ok:\n\t\tif (time_status & sta_ins)\n\t\t\ttime_state = time_ins;\n\t\telse if (time_status & sta_del)\n\t\t\ttime_state = time_del;\n\t\tbreak;\n\tcase time_ins:\n\t\tif (!(time_status & sta_ins))\n\t\t\ttime_state = time_ok;\n\t\telse if (secs % 86400 == 0) {\n\t\t\tleap = -1;\n\t\t\ttime_state = time_oop;\n\t\t\tprintk(kern_notice\n\t\t\t\t\"clock: inserting leap second 23:59:60 utc\\n\");\n\t\t}\n\t\tbreak;\n\tcase time_del:\n\t\tif (!(time_status & sta_del))\n\t\t\ttime_state = time_ok;\n\t\telse if ((secs + 1) % 86400 == 0) {\n\t\t\tleap = 1;\n\t\t\ttime_state = time_wait;\n\t\t\tprintk(kern_notice\n\t\t\t\t\"clock: deleting leap second 23:59:59 utc\\n\");\n\t\t}\n\t\tbreak;\n\tcase time_oop:\n\t\ttime_state = time_wait;\n\t\tbreak;\n\n\tcase time_wait:\n\t\tif (!(time_status & (sta_ins | sta_del)))\n\t\t\ttime_state = time_ok;\n\t\tbreak;\n\t}\n\n\n\t\n\ttime_maxerror += maxfreq / nsec_per_usec;\n\tif (time_maxerror >": 5264, "<< (x))\n#define mask_declare_2(x)\tmask_declare_1(x), mask_declare_1(x+1)\n#define mask_declare_4(x)\tmask_declare_2(x), mask_declare_2(x+2)\n#define mask_declare_8(x)\tmask_declare_4(x), mask_declare_4(x+4)\n\nconst unsigned long cpu_bit_bitmap[bits_per_long+1][bits_to_longs(nr_cpus)] = {\n\n\tmask_declare_8(0),\tmask_declare_8(8),\n\tmask_declare_8(16),\tmask_declare_8(24),\n#if bits_per_long >": 5265, "<< 0)\n#define _irq_desc_percpu\t(1 << 1)\n\n#define irq_get_desc_check_global\t(_irq_desc_check)\n#define irq_get_desc_check_percpu\t(_irq_desc_check | _irq_desc_percpu)\n\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\nvoid __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}\n\n\nstatic inline void irqd_set_move_pending(struct irq_data *d)\n{\n\td->": 5266, "<< 0)\n#define tk_mirror\t\t(1 << 1)\n#define tk_clock_was_set\t(1 << 2)\n\n\nstatic struct {\n\tseqcount_t\t\tseq;\n\tstruct timekeeper\ttimekeeper;\n} tk_core ____cacheline_aligned;\n\nstatic define_raw_spinlock(timekeeper_lock);\nstatic struct timekeeper shadow_timekeeper;\n\n\nstruct tk_fast {\n\tseqcount_t\t\tseq;\n\tstruct tk_read_base\tbase[2];\n};\n\nstatic struct tk_fast tk_fast_mono ____cacheline_aligned;\nstatic struct tk_fast tk_fast_raw  ____cacheline_aligned;\n\n\nint __read_mostly timekeeping_suspended;\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->": 5267, "<< 0)\n};\n\nextern struct list_head ftrace_trace_arrays;\n\nextern struct mutex trace_types_lock;\n\nextern int trace_array_get(struct trace_array *tr);\nextern void trace_array_put(struct trace_array *tr);\n\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn null;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\twarn_on(!(tr->": 5268, "<< 0), \n\tcgroup_freezing_self\t= (1 << 1), \n\tcgroup_freezing_parent\t= (1 << 2), \n\tcgroup_frozen\t\t= (1 << 3), \n\n\t\n\tcgroup_freezing\t\t= cgroup_freezing_self | cgroup_freezing_parent,\n};\n\nstruct freezer {\n\tstruct cgroup_subsys_state\tcss;\n\tunsigned int\t\t\tstate;\n};\n\nstatic define_mutex(freezer_mutex);\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : null;\n}\n\nstatic inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->": 5269, "<< 1) + 1;\n}\n\nstatic inline int right_child(int i)\n{\n\treturn (i << 1) + 2;\n}\n\nstatic inline int dl_time_before(u64 a, u64 b)\n{\n\treturn (s64)(a - b) < 0;\n}\n\nstatic void cpudl_exchange(struct cpudl *cp, int a, int b)\n{\n\tint cpu_a = cp->": 5270, "<< 1) >": 5271, "<< 1),\n\ttracer_preempt_off\t= (1 << 2),\n};\n\nstatic int trace_type __read_mostly;\n\nstatic int save_flags;\nstatic bool function_enabled;\n\nstatic void stop_irqsoff_tracer(struct trace_array *tr, int graph);\nstatic int start_irqsoff_tracer(struct trace_array *tr, int graph);\n\n#ifdef config_preempt_tracer\nstatic inline int\npreempt_trace(void)\n{\n\treturn ((trace_type & tracer_preempt_off) && preempt_count());\n}\n#else\n# define preempt_trace() (0)\n#endif\n\n#ifdef config_irqsoff_tracer\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & tracer_irqs_off) &&\n\t\tirqs_disabled());\n}\n#else\n# define irq_trace() (0)\n#endif\n\n#define trace_display_graph\t1\n\nstatic struct tracer_opt trace_opts[] = {\n#ifdef config_function_graph_tracer\n\t\n\t{ tracer_opt(display-graph, trace_display_graph) },\n#endif\n\t{ } \n};\n\nstatic struct tracer_flags tracer_flags = {\n\t.val  = 0,\n\t.opts = trace_opts,\n};\n\n#define is_graph() (tracer_flags.val & trace_display_graph)\n\n\nstatic __cacheline_aligned_in_smp\tunsigned long max_sequence;\n\n#ifdef config_function_tracer\n\nstatic int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t\n\tif (!irqs_disabled_flags(*flags))\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->": 5272, "<< 1);\n\n\t\tp->": 5273, "<< 1);\n}\n\n\nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file = null;\n\n\ttask_lock(task);\n\trcu_read_lock();\n\n\tif (task->": 5274, "<< 10) | node);\n\n\t\tresult = -efault;\n\t\tif (put_user(dnaddr, (__le16 __user *)oldval))\n\t\t\tgoto out;\n\n\t\tcopied = sizeof(dnaddr);\n\t}\n\n\tif (newval && newlen) {\n\t\t__le16 dnaddr;\n\t\tchar buf[15];\n\t\tint len;\n\n\t\tresult = -einval;\n\t\tif (newlen != sizeof(dnaddr))\n\t\t\tgoto out;\n\n\t\tresult = -efault;\n\t\tif (get_user(dnaddr, (__le16 __user *)newval))\n\t\t\tgoto out;\n\n\t\tlen = scnprintf(buf, sizeof(buf), \"%hu.%hu\",\n\t\t\t\tle16_to_cpu(dnaddr) >": 5275, "<< 15)\n#define filter_pred_fold\t(1 << 15)\n\n\n#define max_filter_pred\t\t16384\n\nstruct filter_pred;\nstruct regex;\n\ntypedef int (*filter_pred_fn_t) (struct filter_pred *pred, void *event);\n\ntypedef int (*regex_match_func)(char *str, struct regex *r, int len);\n\nenum regex_type {\n\tmatch_full = 0,\n\tmatch_front_only,\n\tmatch_middle_only,\n\tmatch_end_only,\n};\n\nstruct regex {\n\tchar\t\t\tpattern[max_filter_str_val];\n\tint\t\t\tlen;\n\tint\t\t\tfield_len;\n\tregex_match_func\tmatch;\n};\n\nstruct filter_pred {\n\tfilter_pred_fn_t \tfn;\n\tu64 \t\t\tval;\n\tstruct regex\t\tregex;\n\tunsigned short\t\t*ops;\n\tstruct ftrace_event_field *field;\n\tint \t\t\toffset;\n\tint \t\t\tnot;\n\tint \t\t\top;\n\tunsigned short\t\tindex;\n\tunsigned short\t\tparent;\n\tunsigned short\t\tleft;\n\tunsigned short\t\tright;\n};\n\nextern enum regex_type\nfilter_parse_regex(char *buff, int len, char **search, int *not);\nextern void print_event_filter(struct ftrace_event_file *file,\n\t\t\t       struct trace_seq *s);\nextern int apply_event_filter(struct ftrace_event_file *file,\n\t\t\t      char *filter_string);\nextern int apply_subsystem_event_filter(struct ftrace_subsystem_dir *dir,\n\t\t\t\t\tchar *filter_string);\nextern void print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t\t struct trace_seq *s);\nextern int filter_assign_type(const char *type);\nextern int create_event_filter(struct ftrace_event_call *call,\n\t\t\t       char *filter_str, bool set_str,\n\t\t\t       struct event_filter **filterp);\nextern void free_event_filter(struct event_filter *filter);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct ftrace_event_call *call, char *name);\n\nextern void trace_event_enable_cmd_record(bool enable);\nextern int event_trace_add_tracer(struct dentry *parent, struct trace_array *tr);\nextern int event_trace_del_tracer(struct trace_array *tr);\n\nextern struct ftrace_event_file *find_event_file(struct trace_array *tr,\n\t\t\t\t\t\t const char *system,\n\t\t\t\t\t\t const char *event);\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn access_once(file_inode(filp)->": 5276, "<< 16) | ((u32)(roffs) & 0xffff))\n#define get_rloc_len(dl)\t\t((u32)(dl) >": 5277, "<< 16, period + 1);\n\t\t\tf_weight = (f_weight * p->": 5278, "<< 17))\n\n#if bits_per_long >": 5279, "<< 18) / sizeof(struct sock_filter))\n\n\nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->": 5280, "<< 2); \n\t\tif (hlock->": 5281, "<< 2,\t\n\n\t\n\tworker_die\t\t= 1 << 1,\t\n\tworker_idle\t\t= 1 << 2,\t\n\tworker_prep\t\t= 1 << 3,\t\n\tworker_cpu_intensive\t= 1 << 6,\t\n\tworker_unbound\t\t= 1 << 7,\t\n\tworker_rebound\t\t= 1 << 8,\t\n\n\tworker_not_running\t= worker_prep | worker_cpu_intensive |\n\t\t\t\t  worker_unbound | worker_rebound,\n\n\tnr_std_worker_pools\t= 2,\t\t\n\n\tunbound_pool_hash_order\t= 6,\t\t\n\tbusy_worker_hash_order\t= 6,\t\t\n\n\tmax_idle_workers_ratio\t= 4,\t\t\n\tidle_worker_timeout\t= 300 * hz,\t\n\n\tmayday_initial_timeout  = hz / 100 >": 5282, "<< 20));\n#ifndef config_64bit\n\tcfs_rq->": 5283, "<< 20;\n\t\t\tupdate_entity_load_avg(se, 0);\n\t\t\t\n\t\t\tse->": 5284, "<< 20;\n\n\t\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << 20, period);\n}\n\n#ifdef config_smp\ninline struct dl_bw *dl_bw_of(int i)\n{\n\trcu_lockdep_assert(rcu_read_lock_sched_held(),\n\t\t\t   \"sched rcu must be held\");\n\treturn &cpu_rq(i)->": 5285, "<< 23);\n}\n#endif\n\n\n\nstatic void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->": 5286, "<< 24 | poison_free << 16 | poison_free << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\nexport_symbol(creds_are_invalid);\n\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(kern_err \"cred: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->": 5287, "<< 24 | poison_free << 16 | poison_free << 8)))\n\t\tprintk(kern_err \"cred: ->": 5288, "<< 31)\n\nstatic inline int system_refcount(struct event_subsystem *system)\n{\n\treturn system->": 5289, "<< 31);\n\tchunk->": 5290, "<< 32 );\n\tcase 1: set->": 5291, "<< 32 );\n\tcase 2: set->": 5292, "<< 32 );\n\tcase 3: set->": 5293, "<< 32 );\n\t}\n}\nexport_symbol_gpl(sigset_from_compat);\n\nvoid\nsigset_to_compat(compat_sigset_t *compat, const sigset_t *set)\n{\n\tswitch (_nsig_words) {\n\tcase 4: compat->": 5294, "<< 32;\n\t\tinsn++;\n\t\tcont;\n\talu64_arsh_x:\n\t\t(*(s64 *) &dst) >": 5295, "<< 32;\n\n\treturn (struct bpf_map *) (unsigned long) imm64;\n}\n\n\nstatic int check_ld_imm(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->": 5296, "<< 4;\n\t}\n\n\treturn probe_kernel_write(mem, tmp_raw, count);\n}\n\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}\n\n\nstatic int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- >": 5297, "<< 59),\n\t\t\t\t  kern_warning \"delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t\t\t  (unsigned long long)delta,\n\t\t\t\t  (unsigned long long)ts,\n\t\t\t\t  (unsigned long long)cpu_buffer->": 5298, "<< 63) ||\n\t    attr->": 5299, "<< 63))\n\t\treturn false;\n\n\t\n\tif ((attr->": 5300, "<< 8),\n\t\t\t\t cld_stopped);\n\t} else {\n\t\twarn_on_once(!signr);\n\t\tptrace_stop(signr, cld_stopped, 0, null);\n\t\tcurrent->": 5301, "<< \\\n\t  (ilog2(blk_tc_ ## __name) + blk_tc_shift - __req_ ## __name))\n\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int rw, u32 what, int error, int pdu_len, void *pdu_data)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = null;\n\tstruct ring_buffer *buffer = null;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\n\tif (unlikely(bt->": 5302, "<< __sched_feat_##name) * enabled |\n\nconst_debug unsigned int sysctl_sched_features =\n#include \"features.h\"\n\t0;\n\n#undef sched_feat\n\n#ifdef config_sched_debug\n#define sched_feat(name, enabled)\t\\\n\t#name ,\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\n#undef sched_feat\n\nstatic int sched_feat_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < __sched_feat_nr; i++) {\n\t\tif (!(sysctl_sched_features & (1ul << i)))\n\t\t\tseq_puts(m, \"no_\");\n\t\tseq_printf(m, \"%s \", sched_feat_names[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\n#ifdef have_jump_label\n\n#define jump_label_key__true  static_key_init_true\n#define jump_label_key__false static_key_init_false\n\n#define sched_feat(name, enabled)\t\\\n\tjump_label_key__##enabled ,\n\nstruct static_key sched_feat_keys[__sched_feat_nr] = {\n#include \"features.h\"\n};\n\n#undef sched_feat\n\nstatic void sched_feat_disable(int i)\n{\n\tif (static_key_enabled(&sched_feat_keys[i]))\n\t\tstatic_key_slow_dec(&sched_feat_keys[i]);\n}\n\nstatic void sched_feat_enable(int i)\n{\n\tif (!static_key_enabled(&sched_feat_keys[i]))\n\t\tstatic_key_slow_inc(&sched_feat_keys[i]);\n}\n#else\nstatic void sched_feat_disable(int i) { };\nstatic void sched_feat_enable(int i) { };\n#endif \n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"no_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\tfor (i = 0; i < __sched_feat_nr; i++) {\n\t\tif (strcmp(cmp, sched_feat_names[i]) == 0) {\n\t\t\tif (neg) {\n\t\t\t\tsysctl_sched_features &= ~(1ul << i);\n\t\t\t\tsched_feat_disable(i);\n\t\t\t} else {\n\t\t\t\tsysctl_sched_features |= (1ul << i);\n\t\t\t\tsched_feat_enable(i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic ssize_t\nsched_feat_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tchar *cmp;\n\tint i;\n\tstruct inode *inode;\n\n\tif (cnt >": 5303, "<< __sched_feat_##x))\n#endif \n\n#ifdef config_numa_balancing\n#define sched_feat_numa(x) sched_feat(x)\n#ifdef config_sched_debug\n#define numabalancing_enabled sched_feat_numa(numa)\n#else\nextern bool numabalancing_enabled;\n#endif \n#else\n#define sched_feat_numa(x) (0)\n#define numabalancing_enabled (0)\n#endif \n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * nsec_per_usec;\n}\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn runtime_inf;\n\n\treturn (u64)sysctl_sched_rt_runtime * nsec_per_usec;\n}\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->": 5304, "<< bad_bit)))\n\t\treturn print_usage_bug(curr, this, bad_bit, new_bit);\n\treturn 1;\n}\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\n#if defined(config_trace_irqflags) && defined(config_prove_locking)\n\n\nstatic int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = null;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tprintk(\"\\n\");\n\tprintk(\"=========================================================\\n\");\n\tprintk(\"[ info: possible irq lock inversion dependency detected ]\\n\");\n\tprint_kernel_ident();\n\tprintk(\"---------------------------------------------------------\\n\");\n\tprintk(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->": 5305, "<< bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->": 5306, "<< bit)))\n\t\treturn 1;\n\n\tval |= (1 << bit);\n\t__this_cpu_write(current_context, val);\n\n\treturn 0;\n}\n\nstatic __always_inline void trace_recursive_unlock(void)\n{\n\t__this_cpu_and(current_context, __this_cpu_read(current_context) - 1);\n}\n\n#else\n\n#define trace_recursive_lock()\t\t(0)\n#define trace_recursive_unlock()\tdo { } while (0)\n\n#endif\n\n\nstruct ring_buffer_event *\nring_buffer_lock_reserve(struct ring_buffer *buffer, unsigned long length)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint cpu;\n\n\tif (ring_buffer_flags != rb_buffers_on)\n\t\treturn null;\n\n\t\n\tpreempt_disable_notrace();\n\n\tif (atomic_read(&buffer->": 5307, "<< bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->": 5308, "<< bit;\n}\n\nstatic char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\n{\n\tchar c = '.';\n\n\tif (class->": 5309, "<< blk_tc_shift) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->": 5310, "<< blk_tc_shift) - 1);\n\tlong_act   = !!(trace_flags & trace_iter_verbose);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\n\tif (t->": 5311, "<< bm_block_shift) - 1)\n\n\nstruct rtree_node {\n\tstruct list_head list;\n\tunsigned long *data;\n};\n\n\nstruct mem_zone_bm_rtree {\n\tstruct list_head list;\t\t\n\tstruct list_head nodes;\t\t\n\tstruct list_head leaves;\t\n\tunsigned long start_pfn;\t\n\tunsigned long end_pfn;\t\t\n\tstruct rtree_node *rtree;\t\n\tint levels;\t\t\t\n\tunsigned int blocks;\t\t\n};\n\n\n\nstruct bm_position {\n\tstruct mem_zone_bm_rtree *zone;\n\tstruct rtree_node *node;\n\tunsigned long node_pfn;\n\tint node_bit;\n};\n\nstruct memory_bitmap {\n\tstruct list_head zones;\n\tstruct linked_page *p_list;\t\n\tstruct bm_position cur;\t\n};\n\n\n\n#define bm_entries_per_level\t(page_size / sizeof(unsigned long))\n#if bits_per_long == 32\n#define bm_rtree_level_shift\t(page_shift - 2)\n#else\n#define bm_rtree_level_shift\t(page_shift - 3)\n#endif\n#define bm_rtree_level_mask\t((1ul << bm_rtree_level_shift) - 1)\n\n\nstatic struct rtree_node *alloc_rtree_node(gfp_t gfp_mask, int safe_needed,\n\t\t\t\t\t   struct chain_allocator *ca,\n\t\t\t\t\t   struct list_head *list)\n{\n\tstruct rtree_node *node;\n\n\tnode = chain_alloc(ca, sizeof(struct rtree_node));\n\tif (!node)\n\t\treturn null;\n\n\tnode->": 5312, "<< cc->": 5313, "<< classhash_bits)\n#define __classhashfn(key)\thash_long((unsigned long)key, classhash_bits)\n#define classhashentry(key)\t(classhash_table + __classhashfn((key)))\n\nstatic struct list_head classhash_table[classhash_size];\n\n\n#define chainhash_bits\t\t(max_lockdep_chains_bits-1)\n#define chainhash_size\t\t(1ul << chainhash_bits)\n#define __chainhashfn(chain)\thash_long(chain, chainhash_bits)\n#define chainhashentry(chain)\t(chainhash_table + __chainhashfn((chain)))\n\nstatic struct list_head chainhash_table[chainhash_size];\n\n\n#define iterate_chain_key(key1, key2) \\\n\t(((key1) << max_lockdep_keys_bits) ^ \\\n\t((key1) >": 5314, "<< config_log_buf_shift)\nstatic char __log_buf[__log_buf_len] __aligned(log_align);\nstatic char *log_buf = __log_buf;\nstatic u32 log_buf_len = __log_buf_len;\n\n\nchar *log_buf_addr_get(void)\n{\n\treturn log_buf;\n}\n\n\nu32 log_buf_len_get(void)\n{\n\treturn log_buf_len;\n}\n\n\nstatic char *log_text(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log);\n}\n\n\nstatic char *log_dict(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log) + msg->": 5315, "<< cpu))\n\t\t\t\t\tdump_cpu_task(rnp->": 5316, "<< cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(rsp,\n\t\t\t\t\t\t\t     rnp->": 5317, "<< cpuset_cgrp_id);\n#endif\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\twhile ((token = strsep(&o, \",\")) != null) {\n\t\tnr_opts++;\n\n\t\tif (!*token)\n\t\t\treturn -einval;\n\t\tif (!strcmp(token, \"none\")) {\n\t\t\t\n\t\t\topts->": 5318, "<< cs_online) | (1 << cs_cpu_exclusive) |\n\t\t  (1 << cs_mem_exclusive)),\n};\n\n\n#define cpuset_for_each_child(child_cs, pos_css, parent_cs)\t\t\\\n\tcss_for_each_child((pos_css), &(parent_cs)->": 5319, "<< css->": 5320, "<< debug_shift;\n}\n\nu64 ring_buffer_time_stamp(struct ring_buffer *buffer, int cpu)\n{\n\tu64 time;\n\n\tpreempt_disable_notrace();\n\ttime = rb_time_stamp(buffer);\n\tpreempt_enable_no_resched_notrace();\n\n\treturn time;\n}\nexport_symbol_gpl(ring_buffer_time_stamp);\n\nvoid ring_buffer_normalize_time_stamp(struct ring_buffer *buffer,\n\t\t\t\t      int cpu, u64 *ts)\n{\n\t\n\t*ts >": 5321, "<< evt->": 5322, "<< ffz(thread_mask);\n\n\t} else if (new->": 5323, "<< flag);\n}\n\n\nvoid __module_put_and_exit(struct module *mod, long code)\n{\n\tmodule_put(mod);\n\tdo_exit(code);\n}\nexport_symbol(__module_put_and_exit);\n\n\nstatic unsigned int find_sec(const struct load_info *info, const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < info->": 5324, "<< frac_bits;\n\n\tif (n) for (;;) {\n\t\tif (n & 1) {\n\t\t\tresult *= x;\n\t\t\tresult += 1ul << (frac_bits - 1);\n\t\t\tresult >": 5325, "<< ftrace_hash_bits)\n#define ftrace_hash_default_bits 10\n#define ftrace_hash_max_bits 12\n\n#define fl_global_control_mask (ftrace_ops_fl_control)\n\n#ifdef config_dynamic_ftrace\n#define init_ops_hash(opsname)\t\\\n\t.func_hash\t\t= &opsname.local_hash,\t\t\t\\\n\t.local_hash.regex_lock\t= __mutex_initializer(opsname.local_hash.regex_lock),\n#define assign_ops_hash(opsname, val) \\\n\t.func_hash\t\t= val, \\\n\t.local_hash.regex_lock\t= __mutex_initializer(opsname.local_hash.regex_lock),\n#else\n#define init_ops_hash(opsname)\n#define assign_ops_hash(opsname, val)\n#endif\n\nstatic struct ftrace_ops ftrace_list_end __read_mostly = {\n\t.func\t\t= ftrace_stub,\n\t.flags\t\t= ftrace_ops_fl_recursion_safe | ftrace_ops_fl_stub,\n\tinit_ops_hash(ftrace_list_end)\n};\n\n\nint ftrace_enabled __read_mostly;\nstatic int last_ftrace_enabled;\n\n\nstruct ftrace_ops *function_trace_op __read_mostly = &ftrace_list_end;\n\nstatic struct ftrace_ops *set_function_trace_op;\n\n\nlist_head(ftrace_pids);\nstruct ftrace_pid {\n\tstruct list_head list;\n\tstruct pid *pid;\n};\n\n\nstatic int ftrace_disabled __read_mostly;\n\nstatic define_mutex(ftrace_lock);\n\nstatic struct ftrace_ops *ftrace_control_list __read_mostly = &ftrace_list_end;\nstatic struct ftrace_ops *ftrace_ops_list __read_mostly = &ftrace_list_end;\nftrace_func_t ftrace_trace_function __read_mostly = ftrace_stub;\nftrace_func_t ftrace_pid_function __read_mostly = ftrace_stub;\nstatic struct ftrace_ops global_ops;\nstatic struct ftrace_ops control_ops;\n\nstatic void ftrace_ops_recurs_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct ftrace_ops *op, struct pt_regs *regs);\n\n#if arch_supports_ftrace_ops\nstatic void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t struct ftrace_ops *op, struct pt_regs *regs);\n#else\n\nstatic void ftrace_ops_no_ops(unsigned long ip, unsigned long parent_ip);\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n#endif\n\n\n#define do_for_each_ftrace_op(op, list)\t\t\t\\\n\top = rcu_dereference_raw_notrace(list);\t\t\t\\\n\tdo\n\n\n#define while_for_each_ftrace_op(op)\t\t\t\t\\\n\twhile (likely(op = rcu_dereference_raw_notrace((op)->": 5326, "<< hash->": 5327, "<< i)) {\n\t\t\t\n\t\t\ttemplate[i] = cgroup_e_css(cgrp, ss);\n\t\t} else {\n\t\t\t\n\t\t\ttemplate[i] = old_cset->": 5328, "<< i)) ||\n\t\t    ss->": 5329, "<< i)))\n\t\t\tcontinue;\n\t\tlist_for_each_entry(cfts, &ss->": 5330, "<< i)))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(cfts, &ss->": 5331, "<< i);\n\t\t\tone_ss = true;\n\n\t\t\tbreak;\n\t\t}\n\t\tif (i == cgroup_subsys_count)\n\t\t\treturn -enoent;\n\t}\n\n\tif (opts->": 5332, "<< i);\n\n\t\n\tif (!opts->": 5333, "<< i;\n\n\t\t\tdesc->": 5334, "<< idx;\n\n\tirq_set_chip_and_handler(virq, chip, ct->": 5335, "<< iocsize_shift;\n\t\t}\n\t\tbreak;\n\t}\n\treturn perf_ioctl(file, cmd, arg);\n}\n#else\n# define perf_compat_ioctl null\n#endif\n\nint perf_event_task_enable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->": 5336, "<< kdb_debug_flag_shift))\n#define kdb_debug_state(text, value) if (kdb_debug(state)) \\\n\t\tkdb_print_state(text, value)\n\n#if bits_per_long == 32\n\n#define kdb_platform_env\t\"bytesperword=4\"\n\n#define kdb_machreg_fmt\t\t\"0x%lx\"\n#define kdb_machreg_fmt0\t\"0x%08lx\"\n#define kdb_bfd_vma_fmt\t\t\"0x%lx\"\n#define kdb_bfd_vma_fmt0\t\"0x%08lx\"\n#define kdb_elfw_addr_fmt\t\"0x%x\"\n#define kdb_elfw_addr_fmt0\t\"0x%08x\"\n#define kdb_f_count_fmt\t\t\"%d\"\n\n#elif bits_per_long == 64\n\n#define kdb_platform_env\t\"bytesperword=8\"\n\n#define kdb_machreg_fmt\t\t\"0x%lx\"\n#define kdb_machreg_fmt0\t\"0x%016lx\"\n#define kdb_bfd_vma_fmt\t\t\"0x%lx\"\n#define kdb_bfd_vma_fmt0\t\"0x%016lx\"\n#define kdb_elfw_addr_fmt\t\"0x%x\"\n#define kdb_elfw_addr_fmt0\t\"0x%016x\"\n#define kdb_f_count_fmt\t\t\"%ld\"\n\n#endif\n\n\n#define kdb_maxbpt\t16\n\n\ntypedef struct __ksymtab {\n\t\tunsigned long value;\t\n\t\tconst char *mod_name;\t\n\t\tunsigned long mod_start;\n\t\tunsigned long mod_end;\n\t\tconst char *sec_name;\t\n\t\tunsigned long sec_start;\n\t\tunsigned long sec_end;\n\t\tconst char *sym_name;\t\n\t\tunsigned long sym_start;\n\t\tunsigned long sym_end;\n\t\t} kdb_symtab_t;\nextern int kallsyms_symbol_next(char *prefix_name, int flag);\nextern int kallsyms_symbol_complete(char *prefix_name, int max_len);\n\n\nextern int kdb_getarea_size(void *, unsigned long, size_t);\nextern int kdb_putarea_size(unsigned long, void *, size_t);\n\n\n#define kdb_getarea(x, addr) kdb_getarea_size(&(x), addr, sizeof((x)))\n#define kdb_putarea(addr, x) kdb_putarea_size(addr, &(x), sizeof((x)))\n\nextern int kdb_getphysword(unsigned long *word,\n\t\t\tunsigned long addr, size_t size);\nextern int kdb_getword(unsigned long *, unsigned long, size_t);\nextern int kdb_putword(unsigned long, unsigned long, size_t);\n\nextern int kdbgetularg(const char *, unsigned long *);\nextern int kdbgetu64arg(const char *, u64 *);\nextern char *kdbgetenv(const char *);\nextern int kdbgetaddrarg(int, const char **, int*, unsigned long *,\n\t\t\t long *, char **);\nextern int kdbgetsymval(const char *, kdb_symtab_t *);\nextern int kdbnearsym(unsigned long, kdb_symtab_t *);\nextern void kdbnearsym_cleanup(void);\nextern char *kdb_strdup(const char *str, gfp_t type);\nextern void kdb_symbol_print(unsigned long, const kdb_symtab_t *, unsigned int);\n\n\nextern void kdb_print_state(const char *, int);\n\nextern int kdb_state;\n#define kdb_state_kdb\t\t0x00000001\t\n#define kdb_state_leaving\t0x00000002\t\n#define kdb_state_cmd\t\t0x00000004\t\n#define kdb_state_kdb_control\t0x00000008\t\n#define kdb_state_hold_cpu\t0x00000010\t\n#define kdb_state_doing_ss\t0x00000020\t\n#define kdb_state_ssbpt\t\t0x00000080\t\n#define kdb_state_reentry\t0x00000100\t\n#define kdb_state_suppress\t0x00000200\t\n#define kdb_state_pager\t\t0x00000400\t\n#define kdb_state_go_switch\t0x00000800\t\n#define kdb_state_printf_lock\t0x00001000\t\n#define kdb_state_wait_ipi\t0x00002000\t\n#define kdb_state_recurse\t0x00004000\t\n#define kdb_state_ip_adjusted\t0x00008000\t\n#define kdb_state_go1\t\t0x00010000\t\n#define kdb_state_keyboard\t0x00020000\t\n#define kdb_state_kexec\t\t0x00040000\t\n#define kdb_state_doing_kgdb\t0x00080000\t\n#define kdb_state_kgdb_trans\t0x00200000\t\n#define kdb_state_arch\t\t0xff000000\t\n\n#define kdb_state(flag) (kdb_state & kdb_state_##flag)\n#define kdb_state_set(flag) ((void)(kdb_state |= kdb_state_##flag))\n#define kdb_state_clear(flag) ((void)(kdb_state &= ~kdb_state_##flag))\n\nextern int kdb_nextline; \n\ntypedef struct _kdb_bp {\n\tunsigned long\tbp_addr;\t\n\tunsigned int\tbp_free:1;\t\n\tunsigned int\tbp_enabled:1;\t\n\tunsigned int\tbp_type:4;\t\n\tunsigned int\tbp_installed:1;\t\n\tunsigned int\tbp_delay:1;\t\n\tunsigned int\tbp_delayed:1;\t\n\tunsigned int\tbph_length;\t\n} kdb_bp_t;\n\n#ifdef config_kgdb_kdb\nextern kdb_bp_t kdb_breakpoints[];\n\n\ntypedef struct _kdbtab {\n\tchar    *cmd_name;\t\t\n\tkdb_func_t cmd_func;\t\t\n\tchar    *cmd_usage;\t\t\n\tchar    *cmd_help;\t\t\n\tshort    cmd_minlen;\t\t\n\tkdb_cmdflags_t cmd_flags;\t\n} kdbtab_t;\n\nextern int kdb_bt(int, const char **);\t\n\n\nextern void kdb_initbptab(void);\nextern void kdb_bp_install(struct pt_regs *);\nextern void kdb_bp_remove(void);\n\ntypedef enum {\n\tkdb_db_bpt,\t\n\tkdb_db_ss,\t\n\tkdb_db_ssbpt,\t\n\tkdb_db_nobpt\t\n} kdb_dbtrap_t;\n\nextern int kdb_main_loop(kdb_reason_t, kdb_reason_t,\n\t\t\t int, kdb_dbtrap_t, struct pt_regs *);\n\n\nextern int kdb_grepping_flag;\n#define kdb_grepping_flag_search 0x8000\nextern char kdb_grep_string[];\n#define kdb_grep_strlen 256\nextern int kdb_grep_leading;\nextern int kdb_grep_trailing;\nextern char *kdb_cmds[];\nextern unsigned long kdb_task_state_string(const char *);\nextern char kdb_task_state_char (const struct task_struct *);\nextern unsigned long kdb_task_state(const struct task_struct *p,\n\t\t\t\t    unsigned long mask);\nextern void kdb_ps_suppressed(void);\nextern void kdb_ps1(const struct task_struct *p);\nextern void kdb_print_nameval(const char *name, unsigned long val);\nextern void kdb_send_sig_info(struct task_struct *p, struct siginfo *info);\nextern void kdb_meminfo_proc_show(void);\nextern char *kdb_getstr(char *, size_t, const char *);\nextern void kdb_gdb_state_pass(char *buf);\n\n\n#define kdb_sp_spaceb\t0x0001\t\t\n#define kdb_sp_spacea\t0x0002\t\t\n#define kdb_sp_paren\t0x0004\t\t\n#define kdb_sp_value\t0x0008\t\t\n#define kdb_sp_symsize\t0x0010\t\t\n#define kdb_sp_newline\t0x0020\t\t\n#define kdb_sp_default (kdb_sp_value|kdb_sp_paren)\n\n#define kdb_tsk(cpu) kgdb_info[cpu].task\n#define kdb_tskregs(cpu) kgdb_info[cpu].debuggerinfo\n\nextern struct task_struct *kdb_curr_task(int);\n\n#define kdb_task_has_cpu(p) (task_curr(p))\n\n\n#define\tkdb_do_each_thread(g, p) do_each_thread(g, p)\n#define\tkdb_while_each_thread(g, p) while_each_thread(g, p)\n\n#define gfp_kdb (in_interrupt() ? gfp_atomic : gfp_kernel)\n\nextern void *debug_kmalloc(size_t size, gfp_t flags);\nextern void debug_kfree(void *);\nextern void debug_kusage(void);\n\nextern void kdb_set_current_task(struct task_struct *);\nextern struct task_struct *kdb_current_task;\n\n#ifdef config_kdb_keyboard\nextern void kdb_kbd_cleanup_state(void);\n#else \n#define kdb_kbd_cleanup_state()\n#endif \n\n#ifdef config_modules\nextern struct list_head *kdb_modules;\n#endif \n\nextern char kdb_prompt_str[];\n\n#define\tkdb_word_size\t((int)sizeof(unsigned long))\n\n#endif \n#endif\t\n\n#include <linux/interrupt.h>": 5337, "<< kprobe_hash_bits)\n\n\n\n#ifndef kprobe_lookup_name\n#define kprobe_lookup_name(name, addr) \\\n\taddr = ((kprobe_opcode_t *)(kallsyms_lookup_name(name)))\n#endif\n\nstatic int kprobes_initialized;\nstatic struct hlist_head kprobe_table[kprobe_table_size];\nstatic struct hlist_head kretprobe_inst_table[kprobe_table_size];\n\n\nstatic bool kprobes_all_disarmed;\n\n\nstatic define_mutex(kprobe_mutex);\nstatic define_per_cpu(struct kprobe *, kprobe_instance) = null;\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[kprobe_table_size];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}\n\n\nstatic list_head(kprobe_blacklist);\n\n#ifdef __arch_want_kprobes_insn_slot\n\nstruct kprobe_insn_page {\n\tstruct list_head list;\n\tkprobe_opcode_t *insns;\t\t\n\tstruct kprobe_insn_cache *cache;\n\tint nused;\n\tint ngarbage;\n\tchar slot_used[];\n};\n\n#define kprobe_insn_page_size(slots)\t\t\t\\\n\t(offsetof(struct kprobe_insn_page, slot_used) +\t\\\n\t (sizeof(char) * (slots)))\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn page_size/(c->": 5338, "<< lock_##__state),\n\nenum {\n#define lockdep_state(__state)\t\t\t\t\t\t\\\n\t__lockf(used_in_##__state)\t\t\t\t\t\\\n\t__lockf(used_in_##__state##_read)\t\t\t\t\\\n\t__lockf(enabled_##__state)\t\t\t\t\t\\\n\t__lockf(enabled_##__state##_read)\n#include \"lockdep_states.h\"\n#undef lockdep_state\n\t__lockf(used)\n};\n\n#define lockf_enabled_irq (lockf_enabled_hardirq | lockf_enabled_softirq)\n#define lockf_used_in_irq (lockf_used_in_hardirq | lockf_used_in_softirq)\n\n#define lockf_enabled_irq_read \\\n\t\t(lockf_enabled_hardirq_read | lockf_enabled_softirq_read)\n#define lockf_used_in_irq_read \\\n\t\t(lockf_used_in_hardirq_read | lockf_used_in_softirq_read)\n\n\n#define max_lockdep_entries\t32768ul\n\n#define max_lockdep_chains_bits\t16\n#define max_lockdep_chains\t(1ul << max_lockdep_chains_bits)\n\n#define max_lockdep_chain_hlocks (max_lockdep_chains*5)\n\n\n#define max_stack_trace_entries\t524288ul\n\nextern struct list_head all_lock_classes;\nextern struct lock_chain lock_chains[];\n\n#define lock_usage_chars (1+lock_usage_states/2)\n\nextern void get_usage_chars(struct lock_class *class,\n\t\t\t    char usage[lock_usage_chars]);\n\nextern const char * __get_key_name(struct lockdep_subclass_key *key, char *str);\n\nstruct lock_class *lock_chain_get_class(struct lock_chain *chain, int i);\n\nextern unsigned long nr_lock_classes;\nextern unsigned long nr_list_entries;\nextern unsigned long nr_lock_chains;\nextern int nr_chain_hlocks;\nextern unsigned long nr_stack_trace_entries;\n\nextern unsigned int nr_hardirq_chains;\nextern unsigned int nr_softirq_chains;\nextern unsigned int nr_process_chains;\nextern unsigned int max_lockdep_depth;\nextern unsigned int max_recursion_depth;\n\nextern unsigned int max_bfs_queue_depth;\n\n#ifdef config_prove_locking\nextern unsigned long lockdep_count_forward_deps(struct lock_class *);\nextern unsigned long lockdep_count_backward_deps(struct lock_class *);\n#else\nstatic inline unsigned long\nlockdep_count_forward_deps(struct lock_class *class)\n{\n\treturn 0;\n}\nstatic inline unsigned long\nlockdep_count_backward_deps(struct lock_class *class)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef config_debug_lockdep\n\n#include <asm/local.h>": 5339, "<< mantsize) - 1)\t\n\nstatic comp_t encode_comp_t(unsigned long value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value >": 5340, "<< max_entries_bits)\n\nstatic unsigned long nr_entries;\nstatic struct entry entries[max_entries];\n\nstatic atomic_t overflow_count;\n\n\n#define tstat_hash_bits\t\t(max_entries_bits - 1)\n#define tstat_hash_size\t\t(1ul << tstat_hash_bits)\n#define tstat_hash_mask\t\t(tstat_hash_size - 1)\n\n#define __tstat_hashfn(entry)\t\t\t\t\t\t\\\n\t(((unsigned long)(entry)->": 5341, "<< mmf_dump_filter_shift) &\n\t\tmmf_dump_filter_mask;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>": 5342, "<< new_bit, ret = 1;\n\n\t\n\tif (likely(hlock_class(this)->": 5343, "<< nice_0_shift,\n\t\t\t  sa->": 5344, "<< nmi_watchdog_enabled_bit)\n#define soft_watchdog_enabled     (1 << soft_watchdog_enabled_bit)\n\n#ifdef config_hardlockup_detector\nstatic unsigned long __read_mostly watchdog_enabled = soft_watchdog_enabled|nmi_watchdog_enabled;\n#else\nstatic unsigned long __read_mostly watchdog_enabled = soft_watchdog_enabled;\n#endif\nint __read_mostly nmi_watchdog_enabled;\nint __read_mostly soft_watchdog_enabled;\nint __read_mostly watchdog_user_enabled;\nint __read_mostly watchdog_thresh = 10;\n\n#ifdef config_smp\nint __read_mostly sysctl_softlockup_all_cpu_backtrace;\n#else\n#define sysctl_softlockup_all_cpu_backtrace 0\n#endif\n\nstatic int __read_mostly watchdog_running;\nstatic u64 __read_mostly sample_period;\n\nstatic define_per_cpu(unsigned long, watchdog_touch_ts);\nstatic define_per_cpu(struct task_struct *, softlockup_watchdog);\nstatic define_per_cpu(struct hrtimer, watchdog_hrtimer);\nstatic define_per_cpu(bool, softlockup_touch_sync);\nstatic define_per_cpu(bool, soft_watchdog_warn);\nstatic define_per_cpu(unsigned long, hrtimer_interrupts);\nstatic define_per_cpu(unsigned long, soft_lockup_hrtimer_cnt);\nstatic define_per_cpu(struct task_struct *, softlockup_task_ptr_saved);\n#ifdef config_hardlockup_detector\nstatic define_per_cpu(bool, hard_watchdog_warn);\nstatic define_per_cpu(bool, watchdog_nmi_touch);\nstatic define_per_cpu(unsigned long, hrtimer_interrupts_saved);\nstatic define_per_cpu(struct perf_event *, watchdog_ev);\n#endif\nstatic unsigned long soft_lockup_nmi_warn;\n\n\n\n#ifdef config_hardlockup_detector\nstatic int hardlockup_panic =\n\t\t\tconfig_bootparam_hardlockup_panic_value;\n\nvoid hardlockup_detector_disable(void)\n{\n\twatchdog_enabled &= ~nmi_watchdog_enabled;\n}\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\twatchdog_enabled &= ~nmi_watchdog_enabled;\n\telse if (!strncmp(str, \"1\", 1))\n\t\twatchdog_enabled |= nmi_watchdog_enabled;\n\treturn 1;\n}\n__setup(\"nmi_watchdog=\", hardlockup_panic_setup);\n#endif\n\nunsigned int __read_mostly softlockup_panic =\n\t\t\tconfig_bootparam_softlockup_panic_value;\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, null, 0);\n\n\treturn 1;\n}\n__setup(\"softlockup_panic=\", softlockup_panic_setup);\n\nstatic int __init nowatchdog_setup(char *str)\n{\n\twatchdog_enabled = 0;\n\treturn 1;\n}\n__setup(\"nowatchdog\", nowatchdog_setup);\n\nstatic int __init nosoftlockup_setup(char *str)\n{\n\twatchdog_enabled &= ~soft_watchdog_enabled;\n\treturn 1;\n}\n__setup(\"nosoftlockup\", nosoftlockup_setup);\n\n#ifdef config_smp\nstatic int __init softlockup_all_cpu_backtrace_setup(char *str)\n{\n\tsysctl_softlockup_all_cpu_backtrace =\n\t\t!!simple_strtol(str, null, 0);\n\treturn 1;\n}\n__setup(\"softlockup_all_cpu_backtrace=\", softlockup_all_cpu_backtrace_setup);\n#endif\n\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}\n\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >": 5345, "<< nr);\n}\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}\n\n\nstruct tasklet_head {\n\tstruct tasklet_struct *head;\n\tstruct tasklet_struct **tail;\n};\n\nstatic define_per_cpu(struct tasklet_head, tasklet_vec);\nstatic define_per_cpu(struct tasklet_head, tasklet_hi_vec);\n\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tt->": 5346, "<< ntp_scale_shift) / ntp_interval_freq)\n\n\n\n\nstatic int\t\t\ttime_state = time_ok;\n\n\nstatic int\t\t\ttime_status = sta_unsync;\n\n\nstatic s64\t\t\ttime_offset;\n\n\nstatic long\t\t\ttime_constant = 2;\n\n\nstatic long\t\t\ttime_maxerror = ntp_phase_limit;\n\n\nstatic long\t\t\ttime_esterror = ntp_phase_limit;\n\n\nstatic s64\t\t\ttime_freq;\n\n\nstatic long\t\t\ttime_reftime;\n\nstatic long\t\t\ttime_adjust;\n\n\nstatic s64\t\t\tntp_tick_adj;\n\n#ifdef config_ntp_pps\n\n\n#define pps_valid\t10\t\n#define pps_popcorn\t4\t\n#define pps_intmin\t2\t\n#define pps_intmax\t8\t\n#define pps_intcount\t4\t\n#define pps_maxwander\t100000\t\n\nstatic int pps_valid;\t\t\nstatic long pps_tf[3];\t\t\nstatic long pps_jitter;\t\t\nstatic struct timespec pps_fbase; \nstatic int pps_shift;\t\t\nstatic int pps_intcnt;\t\t\nstatic s64 pps_freq;\t\t\nstatic long pps_stabil;\t\t\n\n\nstatic long pps_calcnt;\t\t\nstatic long pps_jitcnt;\t\t\nstatic long pps_stbcnt;\t\t\nstatic long pps_errcnt;\t\t\n\n\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & sta_ppstime && time_status & sta_ppssignal)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, shift_pll + time_constant);\n}\n\nstatic inline void pps_reset_freq_interval(void)\n{\n\t\n\tpps_shift = pps_intmin;\n\tpps_intcnt = 0;\n}\n\n\nstatic inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}\n\n\nstatic inline void pps_dec_valid(void)\n{\n\tif (pps_valid >": 5347, "<< ntp_scale_shift;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, hz) >": 5348, "<< order) / entry_size >": 5349, "<< order) / entry_size;\n\tpg->": 5350, "<< order) << page_shift;\n\thole_start = (image->": 5351, "<< order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tsetpagereserved(pages + i);\n\t}\n\n\treturn pages;\n}\n\nstatic void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\tfor (i = 0; i < count; i++)\n\t\tclearpagereserved(page + i);\n\t__free_pages(page, order);\n}\n\nstatic void kimage_free_page_list(struct list_head *list)\n{\n\tstruct list_head *pos, *next;\n\n\tlist_for_each_safe(pos, next, list) {\n\t\tstruct page *page;\n\n\t\tpage = list_entry(pos, struct page, lru);\n\t\tlist_del(&page->": 5352, "<< order;\n\tinit_list_head(&extra_pages);\n\n\t\n\tdo {\n\t\tunsigned long pfn, epfn, addr, eaddr;\n\n\t\tpages = kimage_alloc_pages(kexec_control_memory_gfp, order);\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfn   = page_to_pfn(pages);\n\t\tepfn  = pfn + count;\n\t\taddr  = pfn << page_shift;\n\t\teaddr = epfn << page_shift;\n\t\tif ((epfn >": 5353, "<< page_order(rb);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (len && written == size);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\nstatic inline unsigned long\nmemcpy_common(void *dst, const void *src, unsigned long n)\n{\n\tmemcpy(dst, src, n);\n\treturn 0;\n}\n\ndefine_output_copy(__output_copy, memcpy_common)\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}\n\ndefine_output_copy(__output_skip, memcpy_skip)\n\n#ifndef arch_perf_out_copy_user\n#define arch_perf_out_copy_user arch_perf_out_copy_user\n\nstatic inline unsigned long\narch_perf_out_copy_user(void *dst, const void *src, unsigned long n)\n{\n\tunsigned long ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\treturn ret;\n}\n#endif\n\ndefine_output_copy(__output_copy_user, arch_perf_out_copy_user)\n\n\nextern struct perf_callchain_entry *\nperf_callchain(struct perf_event *event, struct pt_regs *regs);\nextern int get_callchain_buffers(void);\nextern void put_callchain_buffers(void);\n\nstatic inline int get_recursion_context(int *recursion)\n{\n\tint rctx;\n\n\tif (in_nmi())\n\t\trctx = 3;\n\telse if (in_irq())\n\t\trctx = 2;\n\telse if (in_softirq())\n\t\trctx = 1;\n\telse\n\t\trctx = 0;\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}\n\nstatic inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}\n\n#ifdef config_have_perf_user_stack_dump\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn true;\n}\n\n#define perf_user_stack_pointer(regs) user_stack_pointer(regs)\n#else\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn false;\n}\n\n#define perf_user_stack_pointer(regs) 0\n#endif \n\n#endif \n#include <linux/stat.h>": 5354, "<< page_order(rb);\n}\n\nstatic struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\t\n\tif (pgoff >": 5355, "<< page_private(page));\n\t\t     last >": 5356, "<< page_shift)\n\t\t\t\t- 1);\n\n\t\tfor (pfn = region->": 5357, "<< page_shift)\n\t\t\tgoto aux_unlock;\n\n\t\t\n\t\tif (rb_has_aux(rb) && rb->": 5358, "<< page_shift) + (vaddr - vma->": 5359, "<< page_shift) - 1;\n\thandle->": 5360, "<< page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = perf_record_lost;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->": 5361, "<< page_shift), hpage_size);\n\t\t\tend = min(end, vma->": 5362, "<< page_shift);\n\tzero_buf_sz = page_size;\n\n\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (is_err(tfm)) {\n\t\tret = ptr_err(tfm);\n\t\tgoto out;\n\t}\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdesc = kzalloc(desc_size, gfp_kernel);\n\tif (!desc) {\n\t\tret = -enomem;\n\t\tgoto out_free_tfm;\n\t}\n\n\tsha_region_sz = kexec_segment_max * sizeof(struct kexec_sha_region);\n\tsha_regions = vzalloc(sha_region_sz);\n\tif (!sha_regions)\n\t\tgoto out_free_desc;\n\n\tdesc->": 5363, "<< page_shift);\n}\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->": 5364, "<< page_shift,\n\t\t\t ((unsigned long long) region->": 5365, "<< page_shift,\n\t\t((unsigned long long) end_pfn << page_shift) - 1);\n}\n\n\nstatic struct memory_bitmap *forbidden_pages_map;\n\n\nstatic struct memory_bitmap *free_pages_map;\n\n\n\nvoid swsusp_set_page_free(struct page *page)\n{\n\tif (free_pages_map)\n\t\tmemory_bm_set_bit(free_pages_map, page_to_pfn(page));\n}\n\nstatic int swsusp_page_is_free(struct page *page)\n{\n\treturn free_pages_map ?\n\t\tmemory_bm_test_bit(free_pages_map, page_to_pfn(page)) : 0;\n}\n\nvoid swsusp_unset_page_free(struct page *page)\n{\n\tif (free_pages_map)\n\t\tmemory_bm_clear_bit(free_pages_map, page_to_pfn(page));\n}\n\nstatic void swsusp_set_page_forbidden(struct page *page)\n{\n\tif (forbidden_pages_map)\n\t\tmemory_bm_set_bit(forbidden_pages_map, page_to_pfn(page));\n}\n\nint swsusp_page_is_forbidden(struct page *page)\n{\n\treturn forbidden_pages_map ?\n\t\tmemory_bm_test_bit(forbidden_pages_map, page_to_pfn(page)) : 0;\n}\n\nstatic void swsusp_unset_page_forbidden(struct page *page)\n{\n\tif (forbidden_pages_map)\n\t\tmemory_bm_clear_bit(forbidden_pages_map, page_to_pfn(page));\n}\n\n\n\nstatic void mark_nosave_pages(struct memory_bitmap *bm)\n{\n\tstruct nosave_region *region;\n\n\tif (list_empty(&nosave_regions))\n\t\treturn;\n\n\tlist_for_each_entry(region, &nosave_regions, list) {\n\t\tunsigned long pfn;\n\n\t\tpr_debug(\"pm: marking nosave pages: [mem %#010llx-%#010llx]\\n\",\n\t\t\t (unsigned long long) region->": 5366, "<< page_shift, end_pfn - begin_pfn);\n\t}\n}\n\nstatic void unset_module_core_ro_nx(struct module *mod)\n{\n\tset_page_attributes(mod->": 5367, "<< page_shift, end_pfn - begin_pfn);\n}\n\nstatic void set_section_ro_nx(void *base,\n\t\t\tunsigned long text_size,\n\t\t\tunsigned long ro_size,\n\t\t\tunsigned long total_size)\n{\n\t\n\tunsigned long begin_pfn;\n\tunsigned long end_pfn;\n\n\t\n\tif (ro_size >": 5368, "<< page_shift;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->": 5369, "<< page_shift;\n\t\tif (uprobe->": 5370, "<< page_shift;\n\n\t\t\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + page_size))\n\t\t\tbreak;\n\n\t\t\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & page_mask;\n\t\t\told_page = pfn_to_page(old_addr >": 5371, "<< page_shift;\n}\n\n#define define_output_copy(func_name, memcpy_func)\t\t\t\\\nstatic inline unsigned long\t\t\t\t\t\t\\\nfunc_name(struct perf_output_handle *handle,\t\t\t\t\\\n\t  const void *buf, unsigned long len)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long size, written;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tsize    = min(handle->": 5372, "<< pidhash_shift;\n\n\tfor (i = 0; i < pidhash_size; i++)\n\t\tinit_hlist_head(&pid_hash[i]);\n}\n\nvoid __init pidmap_init(void)\n{\n\t\n\tbuild_bug_on(pid_max_limit >": 5373, "<< pps_popcorn)) {\n\t\tprintk_deferred(kern_warning\n\t\t\t\t\"hardpps: ppsjitter: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << pps_popcorn));\n\t\ttime_status |= sta_ppsjitter;\n\t\tpps_jitcnt++;\n\t} else if (time_status & sta_ppstime) {\n\t\t\n\t\ttime_offset = div_s64(((s64)correction) << ntp_scale_shift,\n\t\t\t\tntp_interval_freq);\n\t\t\n\t\ttime_adjust = 0;\n\t}\n\t\n\tpps_jitter += (jitter - pps_jitter) >": 5374, "<< pps_shift)) {\n\t\tpps_calcnt++;\n\t\t\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}\n#endif\t\n\nstatic int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtol(str, 0, (long *)&ntp_tick_adj);\n\n\tif (rc)\n\t\treturn rc;\n\tntp_tick_adj <<= ntp_scale_shift;\n\n\treturn 1;\n}\n\n__setup(\"ntp_tick_adj=\", ntp_tick_adj_setup);\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n}\n\n#include <linux/spinlock.h>": 5375, "<< pps_shift)) {\n\t\ttime_status |= sta_ppserror;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(kern_err\n\t\t\t\"hardpps: ppserror: interval too long - %ld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << ntp_scale_shift,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, ntp_scale_shift);\n\tpps_freq = ftemp;\n\tif (delta >": 5376, "<< prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >": 5377, "<< profile_grpshift)\n#define nr_profile_hit\t\t(page_size/sizeof(struct profile_hit))\n#define nr_profile_grp\t\t(nr_profile_hit/profile_grpsz)\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\n\nint prof_on __read_mostly;\nexport_symbol_gpl(prof_on);\n\nstatic cpumask_var_t prof_cpu_mask;\n#ifdef config_smp\nstatic define_per_cpu(struct profile_hit *[2], cpu_profile_hits);\nstatic define_per_cpu(int, cpu_profile_flip);\nstatic define_mutex(profile_flip_mutex);\n#endif \n\nint profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef config_schedstats\n\t\tprof_on = sleep_profiling;\n\t\tif (str[strlen(sleepstr)] == ',')\n\t\t\tstr += strlen(sleepstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel sleep profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n#else\n\t\tpr_warn(\"kernel sleep profiling requires config_schedstats\\n\");\n#endif \n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = sched_profiling;\n\t\tif (str[strlen(schedstr)] == ',')\n\t\t\tstr += strlen(schedstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel schedule profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = kvm_profiling;\n\t\tif (str[strlen(kvmstr)] == ',')\n\t\t\tstr += strlen(kvmstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel kvm profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = par;\n\t\tprof_on = cpu_profiling;\n\t\tpr_info(\"kernel profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t}\n\treturn 1;\n}\n__setup(\"profile=\", profile_setup);\n\n\nint __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t\n\tprof_len = (_etext - _stext) >": 5378, "<< profile_grpshift;\n\tsecondary = (~(pc << 1) & (nr_profile_grp - 1)) << profile_grpshift;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t\n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < profile_grpsz; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (nr_profile_hit - 1);\n\t} while (i != primary);\n\n\t\n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < nr_profile_hit; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}\n\nstatic int profile_cpu_callback(struct notifier_block *info,\n\t\t\t\t\tunsigned long action, void *__cpu)\n{\n\tint node, cpu = (unsigned long)__cpu;\n\tstruct page *page;\n\n\tswitch (action) {\n\tcase cpu_up_prepare:\n\tcase cpu_up_prepare_frozen:\n\t\tnode = cpu_to_mem(cpu);\n\t\tper_cpu(cpu_profile_flip, cpu) = 0;\n\t\tif (!per_cpu(cpu_profile_hits, cpu)[1]) {\n\t\t\tpage = alloc_pages_exact_node(node,\n\t\t\t\t\tgfp_kernel | __gfp_zero,\n\t\t\t\t\t0);\n\t\t\tif (!page)\n\t\t\t\treturn notifier_from_errno(-enomem);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[1] = page_address(page);\n\t\t}\n\t\tif (!per_cpu(cpu_profile_hits, cpu)[0]) {\n\t\t\tpage = alloc_pages_exact_node(node,\n\t\t\t\t\tgfp_kernel | __gfp_zero,\n\t\t\t\t\t0);\n\t\t\tif (!page)\n\t\t\t\tgoto out_free;\n\t\t\tper_cpu(cpu_profile_hits, cpu)[0] = page_address(page);\n\t\t}\n\t\tbreak;\nout_free:\n\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[1]);\n\t\tper_cpu(cpu_profile_hits, cpu)[1] = null;\n\t\t__free_page(page);\n\t\treturn notifier_from_errno(-enomem);\n\tcase cpu_online:\n\tcase cpu_online_frozen:\n\t\tif (prof_cpu_mask != null)\n\t\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\t\tbreak;\n\tcase cpu_up_canceled:\n\tcase cpu_up_canceled_frozen:\n\tcase cpu_dead:\n\tcase cpu_dead_frozen:\n\t\tif (prof_cpu_mask != null)\n\t\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\t\tif (per_cpu(cpu_profile_hits, cpu)[0]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[0]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[0] = null;\n\t\t\t__free_page(page);\n\t\t}\n\t\tif (per_cpu(cpu_profile_hits, cpu)[1]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[1]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[1] = null;\n\t\t\t__free_page(page);\n\t\t}\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n#else \n#define profile_flip_buffers()\t\tdo { } while (0)\n#define profile_discard_flip_buffers()\tdo { } while (0)\n#define profile_cpu_callback\t\tnull\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >": 5379, "<< pt_opt_flag_shift);\n\tflags |= (data << pt_opt_flag_shift);\n\tchild->": 5380, "<< pt_opt_flag_shift);\n\t} else {\n\t\tflags = pt_ptraced;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -eperm;\n\tif (unlikely(task->": 5381, "<< rb_buffers_on_bit,\n\trb_buffers_disabled\t= 1 << rb_buffers_disabled_bit,\n};\n\nstatic unsigned long ring_buffer_flags __read_mostly = rb_buffers_on;\n\n\n#define rb_buffer_off\t\t(1 << 20)\n\n#define buf_page_hdr_size offsetof(struct buffer_data_page, data)\n\n\nvoid tracing_off_permanent(void)\n{\n\tset_bit(rb_buffers_disabled_bit, &ring_buffer_flags);\n}\n\n#define rb_evnt_hdr_size (offsetof(struct ring_buffer_event, array))\n#define rb_alignment\t\t4u\n#define rb_max_small_data\t(rb_alignment * ringbuf_type_data_type_len_max)\n#define rb_evnt_min_size\t8u\t\n\n#ifndef config_have_64bit_aligned_access\n# define rb_force_8byte_alignment\t0\n# define rb_arch_alignment\t\trb_alignment\n#else\n# define rb_force_8byte_alignment\t1\n# define rb_arch_alignment\t\t8u\n#endif\n\n#define rb_align_data\t\t__aligned(rb_arch_alignment)\n\n\n#define ringbuf_type_data 0 ... ringbuf_type_data_type_len_max\n\nenum {\n\trb_len_time_extend = 8,\n\trb_len_time_stamp = 16,\n};\n\n#define skip_time_extend(event) \\\n\t((struct ring_buffer_event *)((char *)event + rb_len_time_extend))\n\nstatic inline int rb_null_event(struct ring_buffer_event *event)\n{\n\treturn event->": 5382, "<< rnp->": 5383, "<< sched_load_resolution)\n# define scale_load_down(w)\t((w) >": 5384, "<< sched_load_shift)\n\n#define nice_0_load\t\tsched_load_scale\n#define nice_0_shift\t\tsched_load_shift\n\n\n#define dl_scale (10)\n\n\n\n\n#define runtime_inf\t((u64)~0ull)\n\nstatic inline int fair_policy(int policy)\n{\n\treturn policy == sched_normal || policy == sched_batch;\n}\n\nstatic inline int rt_policy(int policy)\n{\n\treturn policy == sched_fifo || policy == sched_rr;\n}\n\nstatic inline int dl_policy(int policy)\n{\n\treturn policy == sched_deadline;\n}\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->": 5385, "<< shift | bit;\n\n\treturn &zone->": 5386, "<< shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t\n\traw_nsecs = (u64)tk->": 5387, "<< shift;\n\tloads[1] = (avenrun[1] + offset) << shift;\n\tloads[2] = (avenrun[2] + offset) << shift;\n}\n\nlong calc_load_fold_active(struct rq *this_rq)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->": 5388, "<< shift;\n\traw_nsecs += tk->": 5389, "<< shift;\n\ttk->": 5390, "<< shift;\n\tu64 raw_nsecs;\n\n\t\n\tif (offset < interval)\n\t\treturn offset;\n\n\t\n\toffset -= interval;\n\ttk->": 5391, "<< size_bits;\n\thash->": 5392, "<< src->": 5393, "<< ss->": 5394, "<< ssid))\n\t\t\t\tnew_ss_mask |= ss->": 5395, "<< ssid))\n\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\", ss->": 5396, "<< ssid))\n\t\t\tcgroup_clear_dir(&ss->": 5397, "<< ssid))\n\t\t\tseq_printf(seq, \",%s\", ss->": 5398, "<< ssid)) {\n\t\t\t\t\tret = -ebusy;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t\n\tif (enable && cgroup_parent(cgrp) && !list_empty(&cgrp->": 5399, "<< ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (!(cgrp_dfl_root.subsys_mask & (1 << ssid)) ||\n\t\t\t    (cgroup_parent(cgrp) &&\n\t\t\t     !(cgroup_parent(cgrp)->": 5400, "<< ssid)) {\n\t\t\tif (cgrp->": 5401, "<< ssid)) {\n\t\t\tif (printed)\n\t\t\t\tseq_putc(seq, ' ');\n\t\t\tseq_printf(seq, \"%s\", ss->": 5402, "<< ssid)) {\n\t\t\tret = create_css(cgrp, ss,\n\t\t\t\t\t parent->": 5403, "<< ssid)))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (css_next_child(null, cgroup_css(&ss->": 5404, "<< ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tdefine_wait(wait);\n\n\t\t\tif (!cgroup_css(child, ss))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get(child);\n\t\t\tprepare_to_wait(&child->": 5405, "<< ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tif (css_enable & (1 << ssid))\n\t\t\t\tret = create_css(child, ss,\n\t\t\t\t\tcgrp->": 5406, "<< ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(child, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tif (css_enable & (1 << ssid))\n\t\t\t\tkill_css(css);\n\t\t\telse\n\t\t\t\tcgroup_clear_dir(child, 1 << ssid);\n\t\t}\n\t}\n\tgoto out_unlock;\n}\n\nstatic int cgroup_populated_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"%d\\n\", (bool)seq_css(seq)->": 5407, "<< ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->": 5408, "<< ssid)))) {\n\t\t\t\tret = -enoent;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->": 5409, "<< ssid));\n\t\t\telse\n\t\t\t\tret = cgroup_populate_dir(child, 1 << ssid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_undo_css;\n\t\t}\n\t}\n\n\t\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\tgoto err_undo_css;\n\n\t\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(disable & (1 << ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(child, ss);\n\n\t\t\tif (css_disable & (1 << ssid)) {\n\t\t\t\tkill_css(css);\n\t\t\t} else {\n\t\t\t\tcgroup_clear_dir(child, 1 << ssid);\n\t\t\t\tif (ss->": 5410, "<< ssid));\n\t\t\tif (ret)\n\t\t\t\tgoto out_destroy;\n\t\t}\n\t}\n\n\t\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgrp->": 5411, "<< ssid);\n\t\tcgroup_refresh_child_subsys_mask(&src_root->": 5412, "<< ssid);\n\t\tsrc_root->": 5413, "<< ssid);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_root *src_root;\n\t\tstruct cgroup_subsys_state *css;\n\t\tstruct css_set *cset;\n\n\t\tif (!(ss_mask & (1 << ssid)))\n\t\t\tcontinue;\n\n\t\tsrc_root = ss->": 5414, "<< ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -einval;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (ssid == cgroup_subsys_count)\n\t\t\treturn -einval;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->": 5415, "<< ssid;\n\t\t\tcgroup_refresh_child_subsys_mask(&dst_root->": 5416, "<< ssid;\n\t\tif (dst_root != &cgrp_dfl_root) {\n\t\t\tdst_root->": 5417, "<< taint_crap))\n\t\tbuf[l++] = 'c';\n\tif (mod->": 5418, "<< taint_forced_module))\n\t\tbuf[l++] = 'f';\n\tif (mod->": 5419, "<< taint_oot_module))\n\t\tbuf[l++] = 'o';\n\tif (mod->": 5420, "<< taint_proprietary_module))\n\t\tbuf[l++] = 'p';\n\tif (mod->": 5421, "<< taint_proprietary_module)), true);\n\tif (!sym)\n\t\tgoto unlock;\n\n\tif (!check_version(info->": 5422, "<< taint_unsigned_module))\n\t\tbuf[l++] = 'e';\n\t\n\treturn l;\n}\n\nstatic ssize_t show_initstate(struct module_attribute *mattr,\n\t\t\t      struct module_kobject *mk, char *buffer)\n{\n\tconst char *state = \"unknown\";\n\n\tswitch (mk->": 5423, "<< tk->": 5424, "<< trace_graph_print_fill_shift)\n\nextern enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags);\nextern void print_graph_headers_flags(struct seq_file *s, u32 flags);\nextern void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s);\nextern void graph_trace_open(struct trace_iterator *iter);\nextern void graph_trace_close(struct trace_iterator *iter);\nextern int __trace_graph_entry(struct trace_array *tr,\n\t\t\t       struct ftrace_graph_ent *trace,\n\t\t\t       unsigned long flags, int pc);\nextern void __trace_graph_return(struct trace_array *tr,\n\t\t\t\t struct ftrace_graph_ret *trace,\n\t\t\t\t unsigned long flags, int pc);\n\n\n#ifdef config_dynamic_ftrace\n\n#define ftrace_graph_max_funcs\t\t32\nextern int ftrace_graph_count;\nextern unsigned long ftrace_graph_funcs[ftrace_graph_max_funcs];\nextern int ftrace_graph_notrace_count;\nextern unsigned long ftrace_graph_notrace_funcs[ftrace_graph_max_funcs];\n\nstatic inline int ftrace_graph_addr(unsigned long addr)\n{\n\tint i;\n\n\tif (!ftrace_graph_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < ftrace_graph_count; i++) {\n\t\tif (addr == ftrace_graph_funcs[i]) {\n\t\t\t\n\t\t\tif (in_irq())\n\t\t\t\ttrace_recursion_set(trace_irq_bit);\n\t\t\telse\n\t\t\t\ttrace_recursion_clear(trace_irq_bit);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\tint i;\n\n\tif (!ftrace_graph_notrace_count)\n\t\treturn 0;\n\n\tfor (i = 0; i < ftrace_graph_notrace_count; i++) {\n\t\tif (addr == ftrace_graph_notrace_funcs[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int ftrace_graph_addr(unsigned long addr)\n{\n\treturn 1;\n}\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}\n#endif \n#else \nstatic inline enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\treturn trace_type_unhandled;\n}\n#endif \n\nextern struct list_head ftrace_pids;\n\n#ifdef config_function_tracer\nextern bool ftrace_filter_param __initdata;\nstatic inline int ftrace_trace_task(struct task_struct *task)\n{\n\tif (list_empty(&ftrace_pids))\n\t\treturn 1;\n\n\treturn test_tsk_trace_trace(task);\n}\nextern int ftrace_is_dead(void);\nint ftrace_create_function_files(struct trace_array *tr,\n\t\t\t\t struct dentry *parent);\nvoid ftrace_destroy_function_files(struct trace_array *tr);\nvoid ftrace_init_global_array_ops(struct trace_array *tr);\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func);\nvoid ftrace_reset_array_ops(struct trace_array *tr);\nint using_ftrace_ops_list_func(void);\n#else\nstatic inline int ftrace_trace_task(struct task_struct *task)\n{\n\treturn 1;\n}\nstatic inline int ftrace_is_dead(void) { return 0; }\nstatic inline int\nftrace_create_function_files(struct trace_array *tr,\n\t\t\t     struct dentry *parent)\n{\n\treturn 0;\n}\nstatic inline void ftrace_destroy_function_files(struct trace_array *tr) { }\nstatic inline __init void\nftrace_init_global_array_ops(struct trace_array *tr) { }\nstatic inline void ftrace_reset_array_ops(struct trace_array *tr) { }\n\n#define ftrace_init_array_ops(tr, func) do { } while (0)\n#endif \n\n#if defined(config_function_tracer) && defined(config_dynamic_ftrace)\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent);\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops);\n#else\n\n#define ftrace_create_filter_files(ops, parent) do { } while (0)\n#define ftrace_destroy_filter_files(ops) do { } while (0)\n#endif \n\nint ftrace_event_is_function(struct ftrace_event_call *call);\n\n\nstruct trace_parser {\n\tbool\t\tcont;\n\tchar\t\t*buffer;\n\tunsigned\tidx;\n\tunsigned\tsize;\n};\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->": 5425, "<< trace_graph_print_fill_shift,\n\tflags_fill_start = 2 << trace_graph_print_fill_shift,\n\tflags_fill_end   = 3 << trace_graph_print_fill_shift,\n};\n\nstatic void\nprint_graph_duration(unsigned long long duration, struct trace_seq *s,\n\t\t     u32 flags);\n\n\nint\nftrace_push_return_trace(unsigned long ret, unsigned long func, int *depth,\n\t\t\t unsigned long frame_pointer)\n{\n\tunsigned long long calltime;\n\tint index;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\treturn -ebusy;\n\n\tif (!current->": 5426, "<< ts_shift) - 1)\n#define ts_delta_test\t(~ts_mask)\n\n\n#define rb_missed_events\t(1 << 31)\n\n#define rb_missed_stored\t(1 << 30)\n\nstruct buffer_data_page {\n\tu64\t\t time_stamp;\t\n\tlocal_t\t\t commit;\t\n\tunsigned char\t data[] rb_align_data;\t\n};\n\n\nstruct buffer_page {\n\tstruct list_head list;\t\t\n\tlocal_t\t\t write;\t\t\n\tunsigned\t read;\t\t\n\tlocal_t\t\t entries;\t\n\tunsigned long\t real_end;\t\n\tstruct buffer_data_page *page;\t\n};\n\n\n#define rb_write_mask\t\t0xfffff\n#define rb_write_intcnt\t\t(1 << 20)\n\nstatic void rb_init_page(struct buffer_data_page *bpage)\n{\n\tlocal_set(&bpage->": 5427, "<< tvn_bits)\n#define tvr_size (1 << tvr_bits)\n#define tvn_mask (tvn_size - 1)\n#define tvr_mask (tvr_size - 1)\n#define max_tval ((unsigned long)((1ull << (tvr_bits + 4*tvn_bits)) - 1))\n\nstruct tvec {\n\tstruct list_head vec[tvn_size];\n};\n\nstruct tvec_root {\n\tstruct list_head vec[tvr_size];\n};\n\nstruct tvec_base {\n\tspinlock_t lock;\n\tstruct timer_list *running_timer;\n\tunsigned long timer_jiffies;\n\tunsigned long next_timer;\n\tunsigned long active_timers;\n\tunsigned long all_timers;\n\tint cpu;\n\tstruct tvec_root tv1;\n\tstruct tvec tv2;\n\tstruct tvec tv3;\n\tstruct tvec tv4;\n\tstruct tvec tv5;\n} ____cacheline_aligned;\n\n\nstruct tvec_base boot_tvec_bases;\nexport_symbol(boot_tvec_bases);\n\nstatic define_per_cpu(struct tvec_base *, tvec_bases) = &boot_tvec_bases;\n\n\nstatic inline unsigned int tbase_get_deferrable(struct tvec_base *base)\n{\n\treturn ((unsigned int)(unsigned long)base & timer_deferrable);\n}\n\nstatic inline unsigned int tbase_get_irqsafe(struct tvec_base *base)\n{\n\treturn ((unsigned int)(unsigned long)base & timer_irqsafe);\n}\n\nstatic inline struct tvec_base *tbase_get_base(struct tvec_base *base)\n{\n\treturn ((struct tvec_base *)((unsigned long)base & ~timer_flag_mask));\n}\n\nstatic inline void\ntimer_set_base(struct timer_list *timer, struct tvec_base *new_base)\n{\n\tunsigned long flags = (unsigned long)timer->": 5428, "<< type) & info->": 5429, "<< uidhash_bits)\n#define uidhash_mask\t\t(uidhash_sz - 1)\n#define __uidhashfn(uid)\t(((uid >": 5430, "<< work_offq_pool_shift,\n\t\t      work_struct_pending);\n}\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << work_offq_pool_shift, 0);\n}\n\nstatic void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t\n\tset_work_data(work, work_struct_no_pool, 0);\n}\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->": 5431, "<< work_struct_color_bits) - 1);\n}\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % work_nr_colors;\n}\n\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\twarn_on_once(!work_pending(work));\n\tatomic_long_set(&work->": 5432, "<< work_struct_color_shift;\n}\n\nstatic int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >": 5433, "<< work_struct_flag_bits);\n\n\nstruct wq_flusher {\n\tstruct list_head\tlist;\t\t\n\tint\t\t\tflush_color;\t\n\tstruct completion\tdone;\t\t\n};\n\nstruct wq_device;\n\n\nstruct workqueue_struct {\n\tstruct list_head\tpwqs;\t\t\n\tstruct list_head\tlist;\t\t\n\n\tstruct mutex\t\tmutex;\t\t\n\tint\t\t\twork_color;\t\n\tint\t\t\tflush_color;\t\n\tatomic_t\t\tnr_pwqs_to_flush; \n\tstruct wq_flusher\t*first_flusher;\t\n\tstruct list_head\tflusher_queue;\t\n\tstruct list_head\tflusher_overflow; \n\n\tstruct list_head\tmaydays;\t\n\tstruct worker\t\t*rescuer;\t\n\n\tint\t\t\tnr_drainers;\t\n\tint\t\t\tsaved_max_active; \n\n\tstruct workqueue_attrs\t*unbound_attrs;\t\n\tstruct pool_workqueue\t*dfl_pwq;\t\n\n#ifdef config_sysfs\n\tstruct wq_device\t*wq_dev;\t\n#endif\n#ifdef config_lockdep\n\tstruct lockdep_map\tlockdep_map;\n#endif\n\tchar\t\t\tname[wq_name_len]; \n\n\t\n\tstruct rcu_head\t\trcu;\n\n\t\n\tunsigned int\t\tflags ____cacheline_aligned; \n\tstruct pool_workqueue __percpu *cpu_pwqs; \n\tstruct pool_workqueue __rcu *numa_pwq_tbl[]; \n};\n\nstatic struct kmem_cache *pwq_cache;\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\n\t\t\t\t\t\n\nstatic bool wq_disable_numa;\nmodule_param_named(disable_numa, wq_disable_numa, bool, 0444);\n\n\n#ifdef config_wq_power_efficient_default\nstatic bool wq_power_efficient = true;\n#else\nstatic bool wq_power_efficient;\n#endif\n\nmodule_param_named(power_efficient, wq_power_efficient, bool, 0444);\n\nstatic bool wq_numa_enabled;\t\t\n\n\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\n\nstatic define_mutex(wq_pool_mutex);\t\nstatic define_spinlock(wq_mayday_lock);\t\n\nstatic list_head(workqueues);\t\t\nstatic bool workqueue_freezing;\t\t\n\n\nstatic define_per_cpu_shared_aligned(struct worker_pool [nr_std_worker_pools],\n\t\t\t\t     cpu_worker_pools);\n\nstatic define_idr(worker_pool_idr);\t\n\n\nstatic define_hashtable(unbound_pool_hash, unbound_pool_hash_order);\n\n\nstatic struct workqueue_attrs *unbound_std_wq_attrs[nr_std_worker_pools];\n\n\nstatic struct workqueue_attrs *ordered_wq_attrs[nr_std_worker_pools];\n\nstruct workqueue_struct *system_wq __read_mostly;\nexport_symbol(system_wq);\nstruct workqueue_struct *system_highpri_wq __read_mostly;\nexport_symbol_gpl(system_highpri_wq);\nstruct workqueue_struct *system_long_wq __read_mostly;\nexport_symbol_gpl(system_long_wq);\nstruct workqueue_struct *system_unbound_wq __read_mostly;\nexport_symbol_gpl(system_unbound_wq);\nstruct workqueue_struct *system_freezable_wq __read_mostly;\nexport_symbol_gpl(system_freezable_wq);\nstruct workqueue_struct *system_power_efficient_wq __read_mostly;\nexport_symbol_gpl(system_power_efficient_wq);\nstruct workqueue_struct *system_freezable_power_efficient_wq __read_mostly;\nexport_symbol_gpl(system_freezable_power_efficient_wq);\n\nstatic int worker_thread(void *__worker);\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\n#define create_trace_points\n#include <trace/events/workqueue.h>": 5434, "<<(bit)))\n\n#define trace_context_bits\t4\n\n#define trace_ftrace_start\ttrace_ftrace_bit\n#define trace_ftrace_max\t((1 << (trace_ftrace_start + trace_context_bits)) - 1)\n\n#define trace_list_start\ttrace_internal_bit\n#define trace_list_max\t\t((1 << (trace_list_start + trace_context_bits)) - 1)\n\n#define trace_context_mask\ttrace_list_max\n\nstatic __always_inline int trace_get_context_bit(void)\n{\n\tint bit;\n\n\tif (in_interrupt()) {\n\t\tif (in_nmi())\n\t\t\tbit = 0;\n\n\t\telse if (in_irq())\n\t\t\tbit = 1;\n\t\telse\n\t\t\tbit = 2;\n\t} else\n\t\tbit = 3;\n\n\treturn bit;\n}\n\nstatic __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->": 5435, "<<(bit)); } while (0)\n#define trace_recursion_clear(bit)\tdo { (current)->": 5436, "<<(bit)); } while (0)\n#define trace_recursion_test(bit)\t((current)->": 5437, "<<)\n\talu(rsh, >": 5438, "<<1;\n\tif (new_len >": 5439, "<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->": 5440, "<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->": 5441, "<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}\n\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}\n\n\nvoid audit_kill_trees(struct list_head *list)\n{\n\tmutex_lock(&audit_cmd_mutex);\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->": 5442, "<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->": 5443, "<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}\n\nint audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    rule->": 5444, "<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}\n\nstatic void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->": 5445, "<<31);\n\tp->": 5446, "<<31;\n\t\t\tif (iterate_mounts(compare_root, inode, root_mnt))\n\t\t\t\tnode->": 5447, "<<= 1) {\n\t\t\tif ((rnp->": 5448, "<<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >": 5449, "<<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t\n\n\tinfo->": 5450, "<<= 1;\n\t\trtime >": 5451, "<<= 1;\n\n\t\n\n\tfor (i = rcu_num_lvls - 1; i >": 5452, "<<= 1; \n\n\tswitch_count = &prev->": 5453, "<<= 20 - page_shift; \n\tif (!pages)\n\t\treturn;\n\n\tdown_read(&mm->": 5454, "<<= adj_scale;\n\tinterval <<= adj_scale;\n\toffset <<= adj_scale;\n\n\t\n\tif ((mult_adj >": 5455, "<<= bitcount;\n\tinfo->": 5456, "<<= bitcount;\n\nout:\n\treturn 0;\n}\n\nsyscall_define1(sysinfo, struct sysinfo __user *, info)\n{\n\tstruct sysinfo val;\n\n\tdo_sysinfo(&val);\n\n\tif (copy_to_user(info, &val, sizeof(struct sysinfo)))\n\t\treturn -efault;\n\n\treturn 0;\n}\n\n#ifdef config_compat\nstruct compat_sysinfo {\n\ts32 uptime;\n\tu32 loads[3];\n\tu32 totalram;\n\tu32 freeram;\n\tu32 sharedram;\n\tu32 bufferram;\n\tu32 totalswap;\n\tu32 freeswap;\n\tu16 procs;\n\tu16 pad;\n\tu32 totalhigh;\n\tu32 freehigh;\n\tu32 mem_unit;\n\tchar _f[20-2*sizeof(u32)-sizeof(int)];\n};\n\ncompat_syscall_define1(sysinfo, struct compat_sysinfo __user *, info)\n{\n\tstruct sysinfo s;\n\n\tdo_sysinfo(&s);\n\n\t\n\tif (upper_32_bits(s.totalram) || upper_32_bits(s.totalswap)) {\n\t\tint bitcount = 0;\n\n\t\twhile (s.mem_unit < page_size) {\n\t\t\ts.mem_unit <<= 1;\n\t\t\tbitcount++;\n\t\t}\n\n\t\ts.totalram >": 5457, "<<= bprm->": 5458, "<<= clock->": 5459, "<<= mantsize;\t\t\n\texp += value;\t\t\t\n\treturn exp;\n}\n\n#if acct_version == 1 || acct_version == 2\n\n\n#define mantsize2       20                      \n#define expsize2        5                       \n#define maxfract2       ((1ul << mantsize2) - 1) \n#define maxexp2         ((1 << expsize2) - 1)    \n\nstatic comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value >": 5460, "<<= page_shift;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -enospc;\n\t\t}\n\t\tbreak;\n\n\tcase snapshot_free_swap_pages:\n\t\tif (data->": 5461, "<<= page_shift;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase snapshot_alloc_swap_page:\n\t\tif (data->": 5462, "<<= page_shift;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase snapshot_avail_swap_size:\n\t\tsize = count_swap_pages(data->": 5463, "<<= page_shift;\n\treturn init_header_complete(info);\n}\n\n\n\nstatic inline void\npack_pfns(unsigned long *buf, struct memory_bitmap *bm)\n{\n\tint j;\n\n\tfor (j = 0; j < page_size / sizeof(long); j++) {\n\t\tbuf[j] = memory_bm_next_pfn(bm);\n\t\tif (unlikely(buf[j] == bm_end_of_map))\n\t\t\tbreak;\n\t\t\n\t\tpage_key_read(buf + j);\n\t}\n}\n\n\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->": 5464, "<<= shift_change;\n\t}\n\ttk->": 5465, "<<= ts_shift;\n\t\t\tdelta += event->": 5466, "<<= ts_shift;\n\t\tdelta += event->": 5467, "<<= work_offq_pool_shift;\n\tset_work_data(work, pool_id | work_offq_canceling, work_struct_pending);\n}\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->": 5468, "<<shift)\n\t\t\tshift--;\n\t}\n\n\t\n\ttimekeeping_adjust(tk, offset);\n\n\t\n\told_vsyscall_fixup(tk);\n\n\t\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\ttimekeeping_update(real_tk, clock_set);\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t\n\t\tclock_was_set_delayed();\n}\n\n\nvoid getboottime64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tktime_t t = ktime_sub(tk->": 5469, "<=\n\t\t\t\tenv->": 5470, "<=\n\t\t\ttask_rlimit(t, rlimit_sigpending)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == null)) {\n\t\tatomic_dec(&user->": 5471, "<=\n\t\t     extent->": 5472, "<= (*pos - iter->": 5473, "<= (1ull << evt->": 5474, "<= (busiest->": 5475, "<= (irq_handled | irq_wake_thread)))\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic void\n__report_bad_irq(unsigned int irq, struct irq_desc *desc,\n\t\t irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(kern_err \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(kern_err \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(kern_err \"handlers:\\n\");\n\n\t\n\traw_spin_lock_irqsave(&desc->": 5476, "<= (unsigned long)_einittext)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int is_kernel_text(unsigned long addr)\n{\n\tif ((addr >": 5477, "<= (unsigned long)_end)\n\t\treturn 1;\n\treturn in_gate_area_no_mm(addr);\n}\n\nstatic int is_ksym_addr(unsigned long addr)\n{\n\tif (all_var)\n\t\treturn is_kernel(addr);\n\n\treturn is_kernel_text(addr) || is_kernel_inittext(addr);\n}\n\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t\n\toff += len + 1;\n\n\t\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t\n\treturn off;\n}\n\n\nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}\n\n\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t\n\tname = &kallsyms_names[kallsyms_markers[pos >": 5478, "<= (unsigned long)_etext) ||\n\t    arch_is_kernel_text(addr))\n\t\treturn 1;\n\treturn in_gate_area_no_mm(addr);\n}\n\nstatic inline int is_kernel(unsigned long addr)\n{\n\tif (addr >": 5479, "<= (unsigned long)end &&\n\t\tentry->": 5480, "<= *pos; ) {\n\t\tfile = s_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_event_file *file = v;\n\tstruct ftrace_event_call *call = file->": 5481, "<= *pos; ) {\n\t\tfile = t_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}\n\nstatic void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ftrace_event_file *file = v;\n\tstruct trace_array *tr = m->": 5482, "<= *pos; ) {\n\t\tp = t_next(m, p, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tif (!p)\n\t\treturn t_hash_start(m, pos);\n\n\treturn iter;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ftrace_lock);\n}\n\nvoid * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn null;\n}\n\nstatic void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->": 5483, "<= -erestartsys) &&\n\t    (return_code >": 5484, "<= 0 ?\n\t\t\trr_timeslice : msecs_to_jiffies(sched_rr_timeslice);\n\t}\n\tmutex_unlock(&mutex);\n\treturn ret;\n}\n\n#ifdef config_cgroup_sched\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : null;\n}\n\nstatic struct cgroup_subsys_state *\ncpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct task_group *parent = css_tg(parent_css);\n\tstruct task_group *tg;\n\n\tif (!parent) {\n\t\t\n\t\treturn &root_task_group.css;\n\t}\n\n\ttg = sched_create_group(parent);\n\tif (is_err(tg))\n\t\treturn err_ptr(-enomem);\n\n\treturn &tg->": 5485, "<= 0 || (*prog)->": 5486, "<= 0 || nargs >": 5487, "<= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, false);\n\t\t\t\n\t\t\tif (unlikely(error == -esrch))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nstatic int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info = {};\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = si_tkill;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}\n\n\nsyscall_define3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -einval;\n\n\treturn do_tkill(tgid, pid, sig);\n}\n\n\nsyscall_define2(tkill, pid_t, pid, int, sig)\n{\n\t\n\tif (pid <= 0)\n\t\treturn -einval;\n\n\treturn do_tkill(0, pid, sig);\n}\n\nstatic int do_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t *info)\n{\n\t\n\tif ((info->": 5488, "<= 0 || tgid <= 0)\n\t\treturn -einval;\n\n\t\n\tif ((info->": 5489, "<= 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tinit_list_head(&cpu_buffer->": 5490, "<= 0)\n\t\t\t\tgoto out;\n\n\t\t\tcond_resched();\n\t\t} while (end != vma->": 5491, "<= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, gfp_kernel, context->": 5492, "<= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &bio);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->": 5493, "<= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &bio);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tprintk(kern_info \"pm: image saving progress: %3d%%\\n\",\n\t\t\t       nr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_on_bio_chain(&bio);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tprintk(kern_info \"pm: image saving done.\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"wrote\");\n\treturn ret;\n}\n\n\nstruct crc_data {\n\tstruct task_struct *thr;                  \n\tatomic_t ready;                           \n\tatomic_t stop;                            \n\tunsigned run_threads;                     \n\twait_queue_head_t go;                     \n\twait_queue_head_t done;                   \n\tu32 *crc32;                               \n\tsize_t *unc_len[lzo_threads];             \n\tunsigned char *unc[lzo_threads];          \n};\n\n\nstatic int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->": 5494, "<= 0)\n\t\t\tbreak;\n\t\tsleep_jf = div_round_up(sleep_jf * 11, 10);\n\t}\nupdate_state:\n\toldstate = atomic_read(&per_cpu(cpu_hotplug_state, cpu));\n\tif (oldstate == cpu_dead) {\n\t\t\n\t\tsmp_mb(); \n\t\tatomic_set(&per_cpu(cpu_hotplug_state, cpu), cpu_post_dead);\n\t} else {\n\t\t\n\t\tif (atomic_cmpxchg(&per_cpu(cpu_hotplug_state, cpu),\n\t\t\t\t   oldstate, cpu_broken) != oldstate)\n\t\t\tgoto update_state;\n\t\tret = false;\n\t}\n\treturn ret;\n}\n\n\nbool cpu_report_death(void)\n{\n\tint oldstate;\n\tint newstate;\n\tint cpu = smp_processor_id();\n\n\tdo {\n\t\toldstate = atomic_read(&per_cpu(cpu_hotplug_state, cpu));\n\t\tif (oldstate != cpu_broken)\n\t\t\tnewstate = cpu_dead;\n\t\telse\n\t\t\tnewstate = cpu_dead_frozen;\n\t} while (atomic_cmpxchg(&per_cpu(cpu_hotplug_state, cpu),\n\t\t\t\toldstate, newstate) != oldstate);\n\treturn newstate == cpu_dead;\n}\n\n#endif \n\n\n#include <linux/module.h>": 5495, "<= 0)\n\t\t\tbreak;\n\n\t\tcontinue;\nnext:\n\t\tlist_move_tail(&p->": 5496, "<= 0)\n\t\t\tcurrent->": 5497, "<= 0)\n\t\t\tgoto out;\n\t}\n\n\n\t\n\tret = -erestart_restartblock;\nout:\n\treturn ret;\n}\n\n\nstatic int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t     struct timespec *tsreq, struct timespec __user *rmtp)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tstruct restart_block *restart;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -enotsupp;\n\n\tif (flags & ~timer_abstime)\n\t\treturn -einval;\n\n\tif (!capable(cap_wake_alarm))\n\t\treturn -eperm;\n\n\talarm_init(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec_to_ktime(*tsreq);\n\t\n\tif (flags != timer_abstime) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\n\tif (alarmtimer_do_nsleep(&alarm, exp))\n\t\tgoto out;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(exp, type);\n\n\t\n\tif (flags == timer_abstime) {\n\t\tret = -erestartnohand;\n\t\tgoto out;\n\t}\n\n\tif (rmtp) {\n\t\tret = update_rmtp(exp, type, rmtp);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\trestart = &current->": 5498, "<= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = page_size - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->": 5499, "<= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = page_size - pg_offp;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->": 5500, "<= 0)\n\t\t\tnrealreaders = 1;\n\t}\n\trcu_torture_print_module_parms(cur_ops, \"start of test\");\n\n\t\n\n\tinit_list_head(&rcu_torture_freelist);\n\tfor (i = 0; i < array_size(rcu_tortures); i++) {\n\t\trcu_tortures[i].rtort_mbtest = 0;\n\t\tlist_add_tail(&rcu_tortures[i].rtort_free,\n\t\t\t      &rcu_torture_freelist);\n\t}\n\n\t\n\n\trcu_torture_current = null;\n\trcu_torture_current_version = 0;\n\tatomic_set(&n_rcu_torture_alloc, 0);\n\tatomic_set(&n_rcu_torture_alloc_fail, 0);\n\tatomic_set(&n_rcu_torture_free, 0);\n\tatomic_set(&n_rcu_torture_mberror, 0);\n\tatomic_set(&n_rcu_torture_error, 0);\n\tn_rcu_torture_barrier_error = 0;\n\tn_rcu_torture_boost_ktrerror = 0;\n\tn_rcu_torture_boost_rterror = 0;\n\tn_rcu_torture_boost_failure = 0;\n\tn_rcu_torture_boosts = 0;\n\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++)\n\t\tatomic_set(&rcu_torture_wcount[i], 0);\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++) {\n\t\t\tper_cpu(rcu_torture_count, cpu)[i] = 0;\n\t\t\tper_cpu(rcu_torture_batch, cpu)[i] = 0;\n\t\t}\n\t}\n\n\t\n\n\tfirsterr = torture_create_kthread(rcu_torture_writer, null,\n\t\t\t\t\t  writer_task);\n\tif (firsterr)\n\t\tgoto unwind;\n\tfakewriter_tasks = kzalloc(nfakewriters * sizeof(fakewriter_tasks[0]),\n\t\t\t\t   gfp_kernel);\n\tif (fakewriter_tasks == null) {\n\t\tverbose_torout_errstring(\"out of memory\");\n\t\tfirsterr = -enomem;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nfakewriters; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t\t  null, fakewriter_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\treader_tasks = kzalloc(nrealreaders * sizeof(reader_tasks[0]),\n\t\t\t       gfp_kernel);\n\tif (reader_tasks == null) {\n\t\tverbose_torout_errstring(\"out of memory\");\n\t\tfirsterr = -enomem;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_reader, null,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval >": 5501, "<= 0)\n\t\t\trem.tv64 = nsec_per_usec;\n\t} else\n\t\trem.tv64 = 0;\n\n\treturn ktime_to_timeval(rem);\n}\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerval *const value)\n{\n\tcputime_t cval, cinterval;\n\tstruct cpu_itimer *it = &tsk->": 5502, "<= 0)\n\t\t\treturn false;\n\t\tudelay(srcu_retry_check_delay);\n\t}\n}\n\n\nstatic void srcu_flip(struct srcu_struct *sp)\n{\n\tsp->": 5503, "<= 0)\n\t\treturn -1;\n\n\tgran = wakeup_gran(curr, se);\n\tif (vdiff >": 5504, "<= 0)\n\t\treturn -einval;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kprobe(kps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i >": 5505, "<= 0)\n\t\treturn -einval;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kretprobe(rps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i >": 5506, "<= 0)\n\t\treturn -einval;\n\tfor (i = 0; i < num; i++) {\n\t\tunsigned long addr, offset;\n\t\tjp = jps[i];\n\t\taddr = arch_deref_entry_point(jp->": 5507, "<= 0)\n\t\treturn -einval;\n\n\tif ((sysctl_sched_rt_runtime != runtime_inf) &&\n\t\t(sysctl_sched_rt_runtime >": 5508, "<= 0)\n\t\treturn -einval;\n\n\tif (kexec_purgatory_size < sizeof(elf_ehdr))\n\t\treturn -enoexec;\n\n\tpi->": 5509, "<= 0)\n\t\treturn -einval;\n\n\tworkqueue_set_max_active(wq, val);\n\treturn count;\n}\nstatic device_attr_rw(max_active);\n\nstatic struct attribute *wq_sysfs_attrs[] = {\n\t&dev_attr_per_cpu.attr,\n\t&dev_attr_max_active.attr,\n\tnull,\n};\nattribute_groups(wq_sysfs);\n\nstatic ssize_t wq_pool_ids_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tconst char *delim = \"\";\n\tint node, written = 0;\n\n\trcu_read_lock_sched();\n\tfor_each_node(node) {\n\t\twritten += scnprintf(buf + written, page_size - written,\n\t\t\t\t     \"%s%d:%d\", delim, node,\n\t\t\t\t     unbound_pwq_by_node(wq, node)->": 5510, "<= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, null, stall_task);\n}\n\n\nstatic void rcu_torture_barrier_cbf(struct rcu_head *rcu)\n{\n\tatomic_inc(&barrier_cbs_invoked);\n}\n\n\nstatic int rcu_torture_barrier_cbs(void *arg)\n{\n\tlong myid = (long)arg;\n\tbool lastphase = 0;\n\tbool newphase;\n\tstruct rcu_head rcu;\n\n\tinit_rcu_head_on_stack(&rcu);\n\tverbose_torout_string(\"rcu_torture_barrier_cbs task started\");\n\tset_user_nice(current, max_nice);\n\tdo {\n\t\twait_event(barrier_cbs_wq[myid],\n\t\t\t   (newphase =\n\t\t\t    access_once(barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop());\n\t\tlastphase = newphase;\n\t\tsmp_mb(); \n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tcur_ops->": 5511, "<= 0)\n\t\treturn 0;\n\trmt = ktime_to_timespec(rem);\n\n\tif (copy_to_user(rmtp, &rmt, sizeof(*rmtp)))\n\t\treturn -efault;\n\n\treturn 1;\n\n}\n\n\nstatic long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->": 5512, "<= 0)\n\t\treturn 0;\n\n\twhile (!list_empty(tasks)) {\n\t\tp = list_first_entry(tasks, struct task_struct, se.group_node);\n\n\t\tenv->": 5513, "<= 0)\n\t\treturn false;\n\n\t\n\torig_src_load = env->": 5514, "<= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -etime;\n\n\tdelta = min(delta, (int64_t) dev->": 5515, "<= 0)\n\t\treturn now + 1;\n\n\ttsdelta = ktime_to_timespec(hr_delta);\n\tdelta = timespec_to_jiffies(&tsdelta);\n\n\t\n\tif (delta >": 5516, "<= 0)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\treturn 1;\n}\n\nstatic int match_held_lock(struct held_lock *hlock, struct lockdep_map *lock)\n{\n\tif (hlock->": 5517, "<= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -enomem;\n\tnew_page = alloc_page_vma(gfp_highuser_movable, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__setpageuptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, uprobe_swbp_insn_size);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tpage_cache_release(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -eagain))\n\t\tgoto retry;\n\treturn ret;\n}\n\n\nint __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(mm, vaddr, uprobe_swbp_insn);\n}\n\n\nint __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(mm, vaddr, *(uprobe_opcode_t *)&auprobe->": 5518, "<= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(&jps[i]->": 5519, "<= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(&rps[i]->": 5520, "<= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->": 5521, "<= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\tstore_stacktrace(tsk, &lat);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->": 5522, "<= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->": 5523, "<= 0)\n\t\tthrottle_cfs_rq(cfs_rq);\n}\n\n\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_bandwidth_used())\n\t\treturn false;\n\n\tif (likely(!cfs_rq->": 5524, "<= 0) {\n\t\t\t\tkill_test();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, bpage);\n\n\tif (ret < 0)\n\t\treturn event_dropped;\n\treturn event_found;\n}\n\nstatic void ring_buffer_consumer(void)\n{\n\t\n\tread_events ^= 1;\n\n\tread = 0;\n\twhile (!reader_finish && !kill_test) {\n\t\tint found;\n\n\t\tdo {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (kill_test)\n\t\t\t\t\tbreak;\n\t\t\t\tif (stat == event_found)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t} while (found && !kill_test);\n\n\t\tset_current_state(task_interruptible);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\treader_finish = 0;\n\tcomplete(&read_done);\n}\n\nstatic void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t\n\ttrace_printk(\"starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, run_time * nsec_per_sec);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer, event);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef config_preempt\n\t\t\n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\n\t} while (ktime_before(end_time, timeout) && !kill_test);\n\ttrace_printk(\"end ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t\n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t\n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\t\n\t\tsmp_wmb();\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (kill_test)\n\t\ttrace_printk(\"error!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo < 0)\n\t\t\ttrace_printk(\"running consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t\telse\n\t\t\ttrace_printk(\"running consumer at sched_fifo %d\\n\",\n\t\t\t\t     consumer_fifo);\n\t}\n\tif (producer_fifo < 0)\n\t\ttrace_printk(\"running producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\telse\n\t\ttrace_printk(\"running producer at sched_fifo %d\\n\",\n\t\t\t     producer_fifo);\n\n\t\n\tif (producer_fifo < 0 && consumer_fifo < 0 &&\n\t    producer_nice == max_nice && consumer_nice == max_nice)\n\t\ttrace_printk(\"warning!!! this test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"entries:  %lld\\n\", entries);\n\ttrace_printk(\"total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"missed:   %ld\\n\", missed);\n\ttrace_printk(\"hit:      %ld\\n\", hit);\n\n\t\n\tdo_div(time, usec_per_msec);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"time is zero??\\n\");\n\n\ttrace_printk(\"entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t\n\t\tavg = nsec_per_msec / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t\n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--; \n\t\t}\n\n\t\t\n\t\tavg = nsec_per_msec / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}\n\nstatic void wait_to_die(void)\n{\n\tset_current_state(task_interruptible);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(task_interruptible);\n\t}\n\t__set_current_state(task_running);\n}\n\nstatic int ring_buffer_consumer_thread(void *arg)\n{\n\twhile (!kthread_should_stop() && !kill_test) {\n\t\tcomplete(&read_start);\n\n\t\tring_buffer_consumer();\n\n\t\tset_current_state(task_interruptible);\n\t\tif (kthread_should_stop() || kill_test)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(task_running);\n\n\tif (kill_test)\n\t\twait_to_die();\n\n\treturn 0;\n}\n\nstatic int ring_buffer_producer_thread(void *arg)\n{\n\tinit_completion(&read_start);\n\n\twhile (!kthread_should_stop() && !kill_test) {\n\t\tring_buffer_reset(buffer);\n\n\t\tif (consumer) {\n\t\t\tsmp_wmb();\n\t\t\twake_up_process(consumer);\n\t\t\twait_for_completion(&read_start);\n\t\t}\n\n\t\tring_buffer_producer();\n\n\t\ttrace_printk(\"sleeping for 10 secs\\n\");\n\t\tset_current_state(task_interruptible);\n\t\tschedule_timeout(hz * sleep_time);\n\t}\n\n\tif (kill_test)\n\t\twait_to_die();\n\n\treturn 0;\n}\n\nstatic int __init ring_buffer_benchmark_init(void)\n{\n\tint ret;\n\n\t\n\tbuffer = ring_buffer_alloc(1000000, rb_fl_overwrite);\n\tif (!buffer)\n\t\treturn -enomem;\n\n\tif (!disable_reader) {\n\t\tconsumer = kthread_create(ring_buffer_consumer_thread,\n\t\t\t\t\t  null, \"rb_consumer\");\n\t\tret = ptr_err(consumer);\n\t\tif (is_err(consumer))\n\t\t\tgoto out_fail;\n\t}\n\n\tproducer = kthread_run(ring_buffer_producer_thread,\n\t\t\t       null, \"rb_producer\");\n\tret = ptr_err(producer);\n\n\tif (is_err(producer))\n\t\tgoto out_kill;\n\n\t\n\tif (!disable_reader) {\n\t\tif (consumer_fifo >": 5525, "<= 0) {\n\t\t\n\t\tif ((timr->": 5526, "<= 0) {\n\t\tkdb_printf(\"process id must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t\n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"the specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->": 5527, "<= 0) {\n\t\tpr_debug(\"->": 5528, "<= 0) {\n\t\tpr_warn(\"%s: gave up waiting for init of module %s.\\n\",\n\t\t\tmod->": 5529, "<= 0) {\n\t\tprintk(kern_err \"kgdb: internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn null;\n\t}\n\n\t\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}\n\n\n\nstatic inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}\n\n\n\n\nstatic void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t\n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 's';\n\thex_byte_pack(&remcom_out_buffer[1], ks->": 5530, "<= 0) {\n\t\tverbose(\"invalid stack type r%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -eacces;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tif (state->": 5531, "<= 0) {\n#ifdef config_preempt\n\t\trp->": 5532, "<= 0) || (event->": 5533, "<= 0))\n\t\t\tgoto timed_out;\n\t\t__set_task_state(task, state);\n\t\traw_spin_unlock_irq(&sem->": 5534, "<= 0))\n\t\treturn;\n\n\tcurr->": 5535, "<= 0))\n\t\treturn;\n\n\tdata->": 5536, "<= 0))\n\t\treturn;\n\n\tschedstat_set(curr->": 5537, "<= 0)) {\n\t\t\n\t\ttimekeeping_apply_adjustment(tk, offset, 1, 0);\n\t\ttk->": 5538, "<= 0)) {\n\t\tse->": 5539, "<= 0);\n\t\t\treturn; \n\t\t} else {\n\t\t\trdtp->": 5540, "<= 0);\n\t\tif (rdtp->": 5541, "<= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}\n\n\n#include <linux/proc_fs.h>": 5542, "<= 0);\n\tpwq->": 5543, "<= 0);\n\twarn_on_once(!(atomic_read(&rdtp->": 5544, "<= 1)\n\t\t\treturn null;\n\t}\n\n\t\n\twhile (!string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn null;\n\t}\n\treturn string;\n}\n\nstatic char *get_modinfo(struct load_info *info, const char *tag)\n{\n\tchar *p;\n\tunsigned int taglen = strlen(tag);\n\telf_shdr *infosec = &info->": 5545, "<= 1)\n\t\tdump_stack();\n#endif\n\n\t\n\tif (!crash_kexec_post_notifiers)\n\t\tcrash_kexec(null);\n\n\t\n\tsmp_send_stop();\n\n\t\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(kmsg_dump_panic);\n\n\t\n\tcrash_kexec(null);\n\n\tbust_spinlocks(0);\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout >": 5546, "<= 1)\n\t\tgoto out;\n\n\t\n\tif ((long)delta_jiffies >": 5547, "<= 1)\n\t\tgoto out_unlock;\n\n\t\n\tbug_on(busiest_rq == target_rq);\n\n\t\n\trcu_read_lock();\n\tfor_each_domain(target_cpu, sd) {\n\t\tif ((sd->": 5548, "<= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: numa affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(gfp_kernel);\n\tbug_on(!wq_update_unbound_numa_attrs_buf);\n\n\t\n\ttbl = kzalloc(nr_node_ids * sizeof(tbl[0]), gfp_kernel);\n\tbug_on(!tbl);\n\n\tfor_each_node(node)\n\t\tbug_on(!zalloc_cpumask_var_node(&tbl[node], gfp_kernel,\n\t\t\t\tnode_online(node) ? node : numa_no_node));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tif (warn_on(node == numa_no_node)) {\n\t\t\tpr_warn(\"workqueue: numa node mapping not available for cpu%d, disabling numa support\\n\", cpu);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}\n\nstatic int __init init_workqueues(void)\n{\n\tint std_nice[nr_std_worker_pools] = { 0, highpri_nice_level };\n\tint i, cpu;\n\n\twarn_on(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n\tpwq_cache = kmem_cache(pool_workqueue, slab_panic);\n\n\tcpu_notifier(workqueue_cpu_up_callback, cpu_pri_workqueue_up);\n\thotcpu_notifier(workqueue_cpu_down_callback, cpu_pri_workqueue_down);\n\n\twq_numa_init();\n\n\t\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct worker_pool *pool;\n\n\t\ti = 0;\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tbug_on(init_worker_pool(pool));\n\t\t\tpool->": 5549, "<= 1)\n\t\tstddev = 0;\n\telse {\n\t\t\n\t\tstddev = rec->": 5550, "<= 1) {\n\t\tif (!task_current(rq, p))\n\t\t\tdequeue_pushable_task(rq, p);\n\t\tbug_on(!rq->": 5551, "<= 1))\n\t\t\treturn kdb_noperm;\n\n\t\tkdb_state_set(cmd);\n\t\tresult = (*tp->": 5552, "<= 1);\n\n\tbug_on(!task_on_rq_queued(p));\n\tbug_on(!rt_task(p));\n\n\treturn p;\n}\n\n\nstatic int push_rt_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *lowest_rq;\n\tint ret = 0;\n\n\tif (!rq->": 5553, "<= 1000))\n\t\t\tpr_warn(\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\",\n\t\t\t\twq->": 5554, "<= 1;\n\tpreempt_enable();\n\treturn ret;\n}\n\n\nvoid synchronize_sched(void)\n{\n\trcu_lockdep_assert(!lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"illegal synchronize_sched() in rcu-sched read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_sched_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu_sched);\n}\nexport_symbol_gpl(synchronize_sched);\n\n\nvoid synchronize_rcu_bh(void)\n{\n\trcu_lockdep_assert(!lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"illegal synchronize_rcu_bh() in rcu-bh read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_bh_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu_bh);\n}\nexport_symbol_gpl(synchronize_rcu_bh);\n\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t\n\tsmp_mb();  \n\n\t\n\treturn smp_load_acquire(&rcu_state_p->": 5555, "<= 1;\n}\n\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}\n\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = mutex_is_locked(&pool->": 5556, "<= 1;\n}\n\n\nstatic int dyntick_save_progress_counter(struct rcu_data *rdp,\n\t\t\t\t\t bool *isidle, unsigned long *maxj)\n{\n\trdp->": 5557, "<= 256) \n\t\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase pm_post_hibernation:\n\tcase pm_post_suspend:\n\t\tif (nr_cpu_ids <= 256) \n\t\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\n\nstatic int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct rcu_state *rsp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t\n\tif (is_enabled(config_rcu_boost) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio >": 5558, "<= addr\n\t\t    && mod->": 5559, "<= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t\n\twhile (low && kallsyms_addresses[low-1] == kallsyms_addresses[low])\n\t\t--low;\n\n\tsymbol_start = kallsyms_addresses[low];\n\n\t\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_addresses[i] >": 5560, "<= alloc_normal)\n\t\treturn 0;\n\n\talloc = avail_normal - alloc_normal;\n\tif (nr_pages < alloc)\n\t\talloc = nr_pages;\n\n\treturn preallocate_image_pages(alloc, gfp_image);\n}\n\n#ifdef config_highmem\nstatic unsigned long preallocate_image_highmem(unsigned long nr_pages)\n{\n\treturn preallocate_image_pages(nr_pages, gfp_image | __gfp_highmem);\n}\n\n\nstatic unsigned long __fraction(u64 x, u64 multiplier, u64 base)\n{\n\tx *= multiplier;\n\tdo_div(x, base);\n\treturn (unsigned long)x;\n}\n\nstatic unsigned long preallocate_highmem_fraction(unsigned long nr_pages,\n\t\t\t\t\t\tunsigned long highmem,\n\t\t\t\t\t\tunsigned long total)\n{\n\tunsigned long alloc = __fraction(nr_pages, highmem, total);\n\n\treturn preallocate_image_pages(alloc, gfp_image | __gfp_highmem);\n}\n#else \nstatic inline unsigned long preallocate_image_highmem(unsigned long nr_pages)\n{\n\treturn 0;\n}\n\nstatic inline unsigned long preallocate_highmem_fraction(unsigned long nr_pages,\n\t\t\t\t\t\tunsigned long highmem,\n\t\t\t\t\t\tunsigned long total)\n{\n\treturn 0;\n}\n#endif \n\n\nstatic unsigned long free_unnecessary_pages(void)\n{\n\tunsigned long save, to_free_normal, to_free_highmem, free;\n\n\tsave = count_data_pages();\n\tif (alloc_normal >": 5561, "<= allowed_ns)\n\t\treturn;\n\n\tif (max_samples_per_tick <= 1)\n\t\treturn;\n\n\tmax_samples_per_tick = div_round_up(max_samples_per_tick, 2);\n\tsysctl_perf_event_sample_rate = max_samples_per_tick * hz;\n\tperf_sample_period_ns = nsec_per_sec / sysctl_perf_event_sample_rate;\n\n\tupdate_perf_cpu_limits();\n\n\tif (!irq_work_queue(&perf_duration_work)) {\n\t\tearly_printk(\"perf interrupt took too long (%lld >": 5562, "<= audit_backlog_limit)\n\t\t\t\twake_up(&audit_backlog_wait);\n\t\t\tif (audit_pid)\n\t\t\t\tkauditd_send_skb(skb);\n\t\t\telse\n\t\t\t\taudit_printk_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\twait_event_freezable(kauditd_wait, skb_queue_len(&audit_skb_queue));\n\t}\n\treturn 0;\n}\n\nint audit_send_list(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct net *net = dest->": 5563, "<= audit_last_feature; i++) {\n\t\tu32 feature = audit_feature_to_mask(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t\n\t\tif (!(feature & uaf->": 5564, "<= bp_vaddr) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->": 5565, "<= buf_page_hdr_size)\n\t\tgoto out;\n\n\tlen -= buf_page_hdr_size;\n\n\tif (!data_page)\n\t\tgoto out;\n\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&cpu_buffer->": 5566, "<= busiest->": 5567, "<= config_no_hz_full_sysidle_small)\n\t\treturn 0;\n\treturn div_round_up(nr_cpu_ids * hz, rcu_fanout_leaf * 1000);\n}\n\n\nstatic void rcu_sysidle(unsigned long j)\n{\n\t\n\tswitch (access_once(full_sysidle_state)) {\n\tcase rcu_sysidle_not:\n\n\t\t\n\t\taccess_once(full_sysidle_state) = rcu_sysidle_short;\n\t\tbreak;\n\n\tcase rcu_sysidle_short:\n\n\t\t\n\t\tif (ulong_cmp_ge(jiffies, j + rcu_sysidle_delay()))\n\t\t\t(void)cmpxchg(&full_sysidle_state,\n\t\t\t\t      rcu_sysidle_short, rcu_sysidle_long);\n\t\tbreak;\n\n\tcase rcu_sysidle_long:\n\n\t\t\n\t\tif (ulong_cmp_ge(jiffies, j + rcu_sysidle_delay()))\n\t\t\t(void)cmpxchg(&full_sysidle_state,\n\t\t\t\t      rcu_sysidle_long, rcu_sysidle_full);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\nstatic void rcu_sysidle_cancel(void)\n{\n\tsmp_mb();\n\tif (full_sysidle_state >": 5568, "<= config_no_hz_full_sysidle_small)\n\t\treturn;  \n\tif (isidle)\n\t\trcu_sysidle(maxj);    \n\telse\n\t\trcu_sysidle_cancel(); \n}\n\n\nstatic void rcu_sysidle_report_gp(struct rcu_state *rsp, int isidle,\n\t\t\t\t  unsigned long maxj)\n{\n\t\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\n\trcu_sysidle_report(rsp, isidle, maxj, true);\n}\n\n\nstruct rcu_sysidle_head {\n\tstruct rcu_head rh;\n\tint inuse;\n};\n\nstatic void rcu_sysidle_cb(struct rcu_head *rhp)\n{\n\tstruct rcu_sysidle_head *rshp;\n\n\t\n\tsmp_mb();  \n\n\trshp = container_of(rhp, struct rcu_sysidle_head, rh);\n\taccess_once(rshp->": 5569, "<= config_no_hz_full_sysidle_small) {\n\t\tint oldrss = rss - 1;\n\n\t\t\n\t\twhile (rss < rcu_sysidle_full && oldrss < rss) {\n\t\t\tint cpu;\n\t\t\tbool isidle = true;\n\t\t\tunsigned long maxj = jiffies - ulong_max / 4;\n\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\trdp = per_cpu_ptr(rcu_state_p->": 5570, "<= crashk_res.end) {\n\t\tunsigned long i;\n\n\t\tif (hole_end >": 5571, "<= ctx->": 5572, "<= end))\n\t\tgoto out;\n\n\ttmp = parent->": 5573, "<= env->": 5574, "<= ext->": 5575, "<= extent->": 5576, "<= fp_old->": 5577, "<= handle->": 5578, "<= hibernation_max; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase hibernation_shutdown:\n\t\tcase hibernation_reboot:\n#ifdef config_suspend\n\t\tcase hibernation_suspend:\n#endif\n\t\t\tbreak;\n\t\tcase hibernation_platform:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}\n\nstatic ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint error = 0;\n\tint i;\n\tint len;\n\tchar *p;\n\tint mode = hibernation_invalid;\n\n\tif (!hibernation_available())\n\t\treturn -eperm;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\tfor (i = hibernation_first; i <= hibernation_max; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != hibernation_invalid) {\n\t\tswitch (mode) {\n\t\tcase hibernation_shutdown:\n\t\tcase hibernation_reboot:\n#ifdef config_suspend\n\t\tcase hibernation_suspend:\n#endif\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase hibernation_platform:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -einval;\n\t\t}\n\t} else\n\t\terror = -einval;\n\n\tif (!error)\n\t\tpr_debug(\"pm: hibernation mode set to '%s'\\n\",\n\t\t\t hibernation_modes[mode]);\n\tunlock_system_sleep();\n\treturn error ? error : n;\n}\n\npower_attr(disk);\n\nstatic ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf,\"%d:%d\\n\", major(swsusp_resume_device),\n\t\t       minor(swsusp_resume_device));\n}\n\nstatic ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tdev_t res;\n\tint len = n;\n\tchar *name;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, gfp_kernel);\n\tif (!name)\n\t\treturn -enomem;\n\n\tres = name_to_dev_t(name);\n\tkfree(name);\n\tif (!res)\n\t\treturn -einval;\n\n\tlock_system_sleep();\n\tswsusp_resume_device = res;\n\tunlock_system_sleep();\n\tprintk(kern_info \"pm: starting manual resume from disk\\n\");\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}\n\npower_attr(resume);\n\nstatic ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}\n\nstatic ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -einval;\n}\n\npower_attr(image_size);\n\nstatic ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}\n\nstatic ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -einval;\n}\n\npower_attr(reserved_size);\n\nstatic struct attribute * g[] = {\n\t&disk_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tnull,\n};\n\n\nstatic struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\n\nstatic int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}\n\ncore_initcall(pm_disk_init);\n\n\nstatic int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy( resume_file, str, 255 );\n\treturn 1;\n}\n\nstatic int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}\n\nstatic int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8))\n\t\tnoresume = 1;\n\telse if (!strncmp(str, \"nocompress\", 10))\n\t\tnocompress = 1;\n\telse if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t}\n\treturn 1;\n}\n\nstatic int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}\n\nstatic int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}\n\nstatic int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}\n\nstatic int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}\n\nstatic int __init kaslr_nohibernate_setup(char *str)\n{\n\treturn nohibernate_setup(str);\n}\n\n__setup(\"noresume\", noresume_setup);\n__setup(\"resume_offset=\", resume_offset_setup);\n__setup(\"resume=\", resume_setup);\n__setup(\"hibernate=\", hibernate_setup);\n__setup(\"resumewait\", resumewait_setup);\n__setup(\"resumedelay=\", resumedelay_setup);\n__setup(\"nohibernate\", nohibernate_setup);\n__setup(\"kaslr\", kaslr_nohibernate_setup);\n\n#include <linux/mutex.h>": 5579, "<= interval)))\n\t\treturn;\n\n\t\n\tnegative = (tick_error < 0);\n\n\t\n\ttick_error = abs(tick_error);\n\tfor (adj = 0; tick_error >": 5580, "<= is_cpu_exclusive(q) &&\n\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);\n}\n\n\nstatic struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), gfp_kernel);\n\tif (!trial)\n\t\treturn null;\n\n\tif (!alloc_cpumask_var(&trial->": 5581, "<= jiffies_to_usecs(1) * 1000) {\n\t\t\n\t} else if (gran == 1000000000) {\n\t\tt.tv_nsec = 0;\n\t} else {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t}\n\treturn t;\n}\nexport_symbol(timespec_trunc);\n\n\ntime64_t mktime64(const unsigned int year0, const unsigned int mon0,\n\t\tconst unsigned int day, const unsigned int hour,\n\t\tconst unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\n\t\n\tif (0 >": 5582, "<= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase kdb_not_initialized:\n\t\t\tkdb_inittab();\t\t\n\t\t\tkdb_initbptab();\t\n\t\t\tbreak;\n\t\tcase kdb_init_early:\n\t\t\tkdb_cmd_init();\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}\n\n\n#define pr_fmt(fmt) kbuild_modname \": \" fmt\n\n#include <linux/kernel.h>": 5583, "<= last &&\n\t\t    (id2 >": 5584, "<= last)\n\t\t\tbreak;\n\t}\n\t\n\tif (idx < extents)\n\t\tid = (id - first) + map->": 5585, "<= last))\n\t\t\tbreak;\n\t}\n\t\n\tif (idx < extents)\n\t\tid = (id - first) + map->": 5586, "<= load_avg_period))\n\t\treturn runnable_avg_yn_sum[n];\n\telse if (unlikely(n >": 5587, "<= long_max &&\n\t    (ctx->": 5588, "<= lower_last) &&\n\t\t    (prev_lower_last >": 5589, "<= max_lockdep_chain_hlocks)) {\n\t\tchain->": 5590, "<= max_nice)\n\t\tret = apply_workqueue_attrs(wq, attrs);\n\telse\n\t\tret = -einval;\n\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}\n\nstatic ssize_t wq_cpumask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->": 5591, "<= max_rcu_lvls; i++)\n\t\tif (n <= rcu_capacity[i]) {\n\t\t\tfor (j = 0; j <= i; j++)\n\t\t\t\tnum_rcu_lvl[j] =\n\t\t\t\t\tdiv_round_up(n, rcu_capacity[i - j]);\n\t\t\trcu_num_lvls = i;\n\t\t\tfor (j = i + 1; j <= max_rcu_lvls; j++)\n\t\t\t\tnum_rcu_lvl[j] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\n\trcu_num_nodes = 0;\n\tfor (i = 0; i <= max_rcu_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n\trcu_num_nodes -= n;\n}\n\nvoid __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one(&rcu_bh_state, &rcu_bh_data);\n\trcu_init_one(&rcu_sched_state, &rcu_sched_data);\n\t__rcu_init_preempt();\n\topen_softirq(rcu_softirq, rcu_process_callbacks);\n\n\t\n\tcpu_notifier(rcu_cpu_notify, 0);\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu)\n\t\trcu_cpu_notify(null, cpu_up_prepare, (void *)(long)cpu);\n}\n\n#include \"tree_plugin.h\"\n\n#include <linux/module.h>": 5592, "<= max_rcu_lvls; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * config_rcu_fanout;\n\n\t\n\tif (rcu_fanout_leaf < config_rcu_fanout_leaf ||\n\t    rcu_fanout_leaf >": 5593, "<= max_scan; ++i) {\n\t\tif (unlikely(!map->": 5594, "<= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}\n\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tfor (i = 0; i < curr->": 5595, "<= mend)) {\n\t\t\t\t\n\t\t\t\thole_start = (mend + (size - 1)) & ~(size - 1);\n\t\t\t\thole_end   = hole_start + size - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (i == image->": 5596, "<= mm->": 5597, "<= msec_per_sec && !(msec_per_sec % hz)\n\treturn (msec_per_sec / hz) * j;\n#elif hz >": 5598, "<= now.tv64) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t\n\t\t\ttick_program_event(dev->": 5599, "<= now.tv64) {\n\t\t\tcpumask_set_cpu(cpu, tmpmask);\n\t\t\t\n\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);\n\t\t} else if (td->": 5600, "<= nr; i++)\n\t\tperf_mmap_unmark_page(base + (i * page_size));\n\n\tvfree(base);\n\tkfree(rb);\n}\n\nvoid rb_free(struct ring_buffer *rb)\n{\n\tschedule_work(&rb->": 5601, "<= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->": 5602, "<= nr_meta_pages + nr_copy_pages);\n}\n\n#ifdef config_highmem\n\nstatic inline void\nswap_two_pages_data(struct page *p1, struct page *p2, void *buf)\n{\n\tvoid *kaddr1, *kaddr2;\n\n\tkaddr1 = kmap_atomic(p1);\n\tkaddr2 = kmap_atomic(p2);\n\tcopy_page(buf, kaddr1);\n\tcopy_page(kaddr1, kaddr2);\n\tcopy_page(kaddr2, buf);\n\tkunmap_atomic(kaddr2);\n\tkunmap_atomic(kaddr1);\n}\n\n\n\nint restore_highmem(void)\n{\n\tstruct highmem_pbe *pbe = highmem_pblist;\n\tvoid *buf;\n\n\tif (!pbe)\n\t\treturn 0;\n\n\tbuf = get_image_page(gfp_atomic, pg_safe);\n\tif (!buf)\n\t\treturn -enomem;\n\n\twhile (pbe) {\n\t\tswap_two_pages_data(pbe->": 5603, "<= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (pagehighmem(page)) {\n\t\t\t\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->": 5604, "<= ns->": 5605, "<= p->": 5606, "<= perf_event_state_off)\n\t\t\tcontinue;\n\t\t\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, can_add_hw)) {\n\t\t\tif (group_sched_in(event, cpuctx, ctx))\n\t\t\t\tcan_add_hw = 0;\n\t\t}\n\t}\n}\n\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task)\n{\n\tu64 now;\n\tint is_active = ctx->": 5607, "<= perf_event_state_off)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, 1))\n\t\t\tgroup_sched_in(event, cpuctx, ctx);\n\n\t\t\n\t\tif (event->": 5608, "<= perf_event_state_off)\n\t\treturn 0;\n\n\tevent->": 5609, "<= pfn_down(addr) &&\n\t\t    pfn_down(p->": 5610, "<= pi->": 5611, "<= pid)\n\t\t\t\tindex = mid + 1;\n\t\t\telse\n\t\t\t\tend = mid;\n\t\t}\n\t}\n\t\n\tif (index >": 5612, "<= pid->": 5613, "<= prctl_map->": 5614, "<= prev_eff_load;\n\n\tschedstat_inc(p, se.statistics.nr_wakeups_affine_attempts);\n\n\tif (!balanced)\n\t\treturn 0;\n\n\tschedstat_inc(sd, ttwu_move_affine);\n\tschedstat_inc(p, se.statistics.nr_wakeups_affine);\n\n\treturn 1;\n}\n\n\nstatic struct sched_group *\nfind_idlest_group(struct sched_domain *sd, struct task_struct *p,\n\t\t  int this_cpu, int sd_flag)\n{\n\tstruct sched_group *idlest = null, *group = sd->": 5615, "<= pse_depth) {\n\t\t\t\tput_prev_entity(cfs_rq_of(pse), pse);\n\t\t\t\tpse = parent_entity(pse);\n\t\t\t}\n\t\t\tif (se_depth >": 5616, "<= qlowmark)\n\t\trdp->": 5617, "<= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start >": 5618, "<= rcu_fanout_1\n#  define rcu_num_lvls\t      1\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      (nr_cpus)\n#  define num_rcu_lvl_2\t      0\n#  define num_rcu_lvl_3\t      0\n#  define num_rcu_lvl_4\t      0\n#elif nr_cpus <= rcu_fanout_2\n#  define rcu_num_lvls\t      2\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      div_round_up(nr_cpus, rcu_fanout_1)\n#  define num_rcu_lvl_2\t      (nr_cpus)\n#  define num_rcu_lvl_3\t      0\n#  define num_rcu_lvl_4\t      0\n#elif nr_cpus <= rcu_fanout_3\n#  define rcu_num_lvls\t      3\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      div_round_up(nr_cpus, rcu_fanout_2)\n#  define num_rcu_lvl_2\t      div_round_up(nr_cpus, rcu_fanout_1)\n#  define num_rcu_lvl_3\t      (nr_cpus)\n#  define num_rcu_lvl_4\t      0\n#elif nr_cpus <= rcu_fanout_4\n#  define rcu_num_lvls\t      4\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      div_round_up(nr_cpus, rcu_fanout_3)\n#  define num_rcu_lvl_2\t      div_round_up(nr_cpus, rcu_fanout_2)\n#  define num_rcu_lvl_3\t      div_round_up(nr_cpus, rcu_fanout_1)\n#  define num_rcu_lvl_4\t      (nr_cpus)\n#else\n# error \"config_rcu_fanout insufficient for nr_cpus\"\n#endif \n\n#define rcu_sum (num_rcu_lvl_0 + num_rcu_lvl_1 + num_rcu_lvl_2 + num_rcu_lvl_3 + num_rcu_lvl_4)\n#define num_rcu_nodes (rcu_sum - nr_cpus)\n\nextern int rcu_num_lvls;\nextern int rcu_num_nodes;\n\n\nstruct rcu_dynticks {\n\tlong long dynticks_nesting; \n\t\t\t\t    \n\tint dynticks_nmi_nesting;   \n\tatomic_t dynticks;\t    \n#ifdef config_no_hz_full_sysidle\n\tlong long dynticks_idle_nesting;\n\t\t\t\t    \n\tatomic_t dynticks_idle;\t    \n\t\t\t\t    \n\tunsigned long dynticks_idle_jiffies;\n\t\t\t\t    \n#endif \n#ifdef config_rcu_fast_no_hz\n\tbool all_lazy;\t\t    \n\tunsigned long nonlazy_posted;\n\t\t\t\t    \n\tunsigned long nonlazy_posted_snap;\n\t\t\t\t    \n\tunsigned long last_accelerate;\n\t\t\t\t    \n\tunsigned long last_advance_all;\n\t\t\t\t    \n\tint tick_nohz_enabled_snap; \n#endif \n};\n\n\n#define rcu_kthread_stopped  0\n#define rcu_kthread_running  1\n#define rcu_kthread_waiting  2\n#define rcu_kthread_offcpu   3\n#define rcu_kthread_yielding 4\n#define rcu_kthread_max      4\n\n\nstruct rcu_node {\n\traw_spinlock_t lock;\t\n\t\t\t\t\n\tunsigned long gpnum;\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long completed; \n\t\t\t\t\n\t\t\t\t\n\tunsigned long qsmask;\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long expmask;\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long qsmaskinit;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long qsmaskinitnext;\n\t\t\t\t\n\tunsigned long grpmask;\t\n\t\t\t\t\n\tint\tgrplo;\t\t\n\tint\tgrphi;\t\t\n\tu8\tgrpnum;\t\t\n\tu8\tlevel;\t\t\n\tbool\twait_blkd_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct rcu_node *parent;\n\tstruct list_head blkd_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct list_head *gp_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct list_head *exp_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n#ifdef config_rcu_boost\n\tstruct list_head *boost_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct rt_mutex boost_mtx;\n\t\t\t\t\n\t\t\t\t\n\tunsigned long boost_time;\n\t\t\t\t\n\tstruct task_struct *boost_kthread_task;\n\t\t\t\t\n\t\t\t\t\n\tunsigned int boost_kthread_status;\n\t\t\t\t\n\tunsigned long n_tasks_boosted;\n\t\t\t\t\n\tunsigned long n_exp_boosts;\n\t\t\t\t\n\tunsigned long n_normal_boosts;\n\t\t\t\t\n\tunsigned long n_balk_blkd_tasks;\n\t\t\t\t\n\tunsigned long n_balk_exp_gp_tasks;\n\t\t\t\t\n\tunsigned long n_balk_boost_tasks;\n\t\t\t\t\n\tunsigned long n_balk_notblocked;\n\t\t\t\t\n\tunsigned long n_balk_notyet;\n\t\t\t\t\n\tunsigned long n_balk_nos;\n\t\t\t\t\n\t\t\t\t\n#endif \n#ifdef config_rcu_nocb_cpu\n\twait_queue_head_t nocb_gp_wq[2];\n\t\t\t\t\n#endif \n\tint need_future_gp[2];\n\t\t\t\t\n\traw_spinlock_t fqslock ____cacheline_internodealigned_in_smp;\n} ____cacheline_internodealigned_in_smp;\n\n\n#define rcu_for_each_node_breadth_first(rsp, rnp) \\\n\tfor ((rnp) = &(rsp)->": 5619, "<= rcu_next_tail; i++) {\n\t\trdp->": 5620, "<= real_ns) ? 0 : cpu_ns - real_ns;\n}\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerval *const value,\n\t\t\t   struct itimerval *const ovalue)\n{\n\tcputime_t cval, nval, cinterval, ninterval;\n\ts64 ns_ninterval, ns_nval;\n\tu32 error, incr_error;\n\tstruct cpu_itimer *it = &tsk->": 5621, "<= res->": 5622, "<= ringbuf_type_data_type_len_max)\n\t\tcpu_buffer->": 5623, "<= rnp->": 5624, "<= s->": 5625, "<= sds->": 5626, "<= send_sig_forced;\n}\n\nstatic inline bool si_fromuser(const struct siginfo *info)\n{\n\treturn info == send_sig_noinfo ||\n\t\t(!is_si_special(info) && si_fromuser(info));\n}\n\n\nstatic int kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\tif (uid_eq(cred->": 5627, "<= sgs->": 5628, "<= size ? 0 : saveable - size;\n}\n\n\nint hibernate_preallocate_memory(void)\n{\n\tstruct zone *zone;\n\tunsigned long saveable, size, max_size, count, highmem, pages = 0;\n\tunsigned long alloc, save_highmem, pages_highmem, avail_normal;\n\tktime_t start, stop;\n\tint error;\n\n\tprintk(kern_info \"pm: preallocating image memory... \");\n\tstart = ktime_get();\n\n\terror = memory_bm_create(&orig_bm, gfp_image, pg_any);\n\tif (error)\n\t\tgoto err_out;\n\n\terror = memory_bm_create(&copy_bm, gfp_image, pg_any);\n\tif (error)\n\t\tgoto err_out;\n\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\n\t\n\tsave_highmem = count_highmem_pages();\n\tsaveable = count_data_pages();\n\n\t\n\tcount = saveable;\n\tsaveable += save_highmem;\n\thighmem = save_highmem;\n\tsize = 0;\n\tfor_each_populated_zone(zone) {\n\t\tsize += snapshot_additional_pages(zone);\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone_page_state(zone, nr_free_pages);\n\t\telse\n\t\t\tcount += zone_page_state(zone, nr_free_pages);\n\t}\n\tavail_normal = count;\n\tcount += highmem;\n\tcount -= totalreserve_pages;\n\n\t\n\tsize += page_key_additional_pages(saveable);\n\n\t\n\tmax_size = (count - (size + pages_for_io)) / 2\n\t\t\t- 2 * div_round_up(reserved_size, page_size);\n\t\n\tsize = div_round_up(image_size, page_size);\n\tif (size >": 5629, "<= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->": 5630, "<= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t\n\tdefault:\n\t\tdiag = kdb_badwidth;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}\n\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t\n\tdefault:\n\t\tdiag = kdb_badwidth;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}\n\n\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\t\n\tdefault:\n\t\tdiag = kdb_badwidth;\n\t\tkdb_printf(\"kdb_putword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}\n\n\n\n\n#define unrunnable\t(1ul << (8*sizeof(unsigned long) - 1))\n#define running\t\t(1ul << (8*sizeof(unsigned long) - 2))\n#define idle\t\t(1ul << (8*sizeof(unsigned long) - 3))\n#define daemon\t\t(1ul << (8*sizeof(unsigned long) - 4))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"ps\");\n\t\tif (!s)\n\t\t\ts = \"drstczeu\";\t\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'd':\n\t\t\tres |= task_uninterruptible;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tres |= running;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tres |= task_interruptible;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tres |= task_stopped;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tres |= task_traced;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tres |= exit_zombie << 16;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tres |= exit_dead << 16;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tres |= unrunnable;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tres |= idle;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tres |= daemon;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tres = ~0ul;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}\n\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'e';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->": 5631, "<= sizeof(ms))\n\t\treturn -ebadmsg;\n\n\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));\n\tmodlen -= sizeof(ms);\n\n\tsig_len = be32_to_cpu(ms.sig_len);\n\tif (sig_len >": 5632, "<= skb_tail_pointer(skb))\n\t\treturn ptr;\n\n\treturn null;\n}\n\nstruct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = gfp_kernel | __gfp_highmem | __gfp_zero |\n\t\t\t  gfp_extra_flags;\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *fp;\n\n\tsize = round_up(size, page_size);\n\tfp = __vmalloc(size, gfp_flags, page_kernel);\n\tif (fp == null)\n\t\treturn null;\n\n\taux = kzalloc(sizeof(*aux), gfp_kernel | gfp_extra_flags);\n\tif (aux == null) {\n\t\tvfree(fp);\n\t\treturn null;\n\t}\n\n\tfp->": 5633, "<= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->": 5634, "<= start && end <= p->": 5635, "<= start && res->": 5636, "<= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -einval;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"memory value expected\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >": 5637, "<= suspend) {\n\t\t\tacct->": 5638, "<= task->": 5639, "<= task_rlimit(p, rlimit_nice) ||\n\t\tcapable(cap_sys_nice));\n}\n\n#ifdef __arch_want_sys_nice\n\n\nsyscall_define1(nice, int, increment)\n{\n\tlong nice, retval;\n\n\t\n\tincrement = clamp(increment, -nice_width, nice_width);\n\tnice = task_nice(current) + increment;\n\n\tnice = clamp_val(nice, min_nice, max_nice);\n\tif (increment < 0 && !can_nice(current, nice))\n\t\treturn -eperm;\n\n\tretval = security_task_setnice(current, nice);\n\tif (retval)\n\t\treturn retval;\n\n\tset_user_nice(current, nice);\n\treturn 0;\n}\n\n#endif\n\n\nint task_prio(const struct task_struct *p)\n{\n\treturn p->": 5640, "<= test_max; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}\n\nstatic ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tconst char * const *s;\n\tint level;\n\tchar *p;\n\tint len;\n\tint error = -einval;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\n\tlevel = test_first;\n\tfor (s = &pm_tests[level]; level <= test_max; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep();\n\n\treturn error ? error : n;\n}\n\npower_attr(pm_test);\n#endif \n\n#ifdef config_debug_fs\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase suspend_freeze:\n\t\treturn \"freeze\";\n\tcase suspend_prepare:\n\t\treturn \"prepare\";\n\tcase suspend_suspend:\n\t\treturn \"suspend\";\n\tcase suspend_suspend_noirq:\n\t\treturn \"suspend_noirq\";\n\tcase suspend_resume_noirq:\n\t\treturn \"resume_noirq\";\n\tcase suspend_resume:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + rec_failed_num - 1;\n\tlast_dev %= rec_failed_num;\n\tlast_errno = suspend_stats.last_failed_errno + rec_failed_num - 1;\n\tlast_errno %= rec_failed_num;\n\tlast_step = suspend_stats.last_failed_step + rec_failed_num - 1;\n\tlast_step %= rec_failed_num;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < rec_failed_num; i++) {\n\t\tindex = last_dev + rec_failed_num - i;\n\t\tindex %= rec_failed_num;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < rec_failed_num; i++) {\n\t\tindex = last_errno + rec_failed_num - i;\n\t\tindex %= rec_failed_num;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < rec_failed_num; i++) {\n\t\tindex = last_step + rec_failed_num - i;\n\t\tindex %= rec_failed_num;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}\n\nstatic int suspend_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, suspend_stats_show, null);\n}\n\nstatic const struct file_operations suspend_stats_operations = {\n\t.open           = suspend_stats_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\n\nstatic int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", s_ifreg | s_irugo,\n\t\t\tnull, null, &suspend_stats_operations);\n\treturn 0;\n}\n\nlate_initcall(pm_debugfs_init);\n#endif \n\n#endif \n\n#ifdef config_pm_sleep_debug\n\nbool pm_print_times_enabled;\n\nstatic ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}\n\nstatic ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -einval;\n\n\tif (val >": 5641, "<= tick_period.tv64)\n\t\treturn;\n\n\ttick_nohz_restart(ts, now);\n#endif\n}\n\nstatic inline void tick_nohz_irq_enter(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tif (!ts->": 5642, "<= tmp->": 5643, "<= tp->": 5644, "<= upper_last) &&\n\t\t    (prev_upper_last >": 5645, "<= usec_per_sec && !(usec_per_sec % hz)\n\treturn (u + (usec_per_sec / hz) - 1) / (usec_per_sec / hz);\n#elif hz >": 5646, "<= usec_per_sec && !(usec_per_sec % hz)\n\treturn (usec_per_sec / hz) * j;\n#elif hz >": 5647, "<= vma->": 5648, "<= wl_gc_count_max)\n\t\treturn;\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->": 5649, "<==%s() = ok\\n\", __func__);\n\treturn pks;\n\nerror:\n\tkfree(pks);\nerror_no_pks:\n\tcrypto_free_shash(tfm);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn err_ptr(ret);\n}\n\n\nstatic int mod_extract_mpi_array(struct public_key_signature *pks,\n\t\t\t\t const void *data, size_t len)\n{\n\tsize_t nbytes;\n\tmpi mpi;\n\n\tif (len < 3)\n\t\treturn -ebadmsg;\n\tnbytes = ((const u8 *)data)[0] << 8 | ((const u8 *)data)[1];\n\tdata += 2;\n\tlen -= 2;\n\tif (len != nbytes)\n\t\treturn -ebadmsg;\n\n\tmpi = mpi_read_raw_data(data, nbytes);\n\tif (!mpi)\n\t\treturn -enomem;\n\tpks->": 5650, "<asm-generic/mutex-null.h>": 5651, "<asm-generic/sections.h>": 5652, "<asm/bitsperlong.h>": 5653, "<asm/byteorder.h>": 5654, "<asm/cacheflush.h>": 5655, "<asm/div64.h>": 5656, "<asm/dma.h>": 5657, "<asm/errno.h>": 5658, "<asm/io.h>": 5659, "<asm/irq_regs.h>": 5660, "<asm/local.h>": 5661, "<asm/mcs_spinlock.h>": 5662, "<asm/mmu_context.h>": 5663, "<asm/mutex.h>": 5664, "<asm/nmi.h>": 5665, "<asm/page.h>": 5666, "<asm/param.h>": 5667, "<asm/paravirt.h>": 5668, "<asm/pgalloc.h>": 5669, "<asm/pgtable.h>": 5670, "<asm/processor.h>": 5671, "<asm/ptrace.h>": 5672, "<asm/qrwlock.h>": 5673, "<asm/sections.h>": 5674, "<asm/setup.h>": 5675, "<asm/siginfo.h>": 5676, "<asm/stacktrace.h>": 5677, "<asm/switch_to.h>": 5678, "<asm/syscall.h>": 5679, "<asm/timex.h>": 5680, "<asm/tlb.h>": 5681, "<asm/tlbflush.h>": 5682, "<asm/types.h>": 5683, "<asm/uaccess.h>": 5684, "<asm/unaligned.h>": 5685, "<asm/unistd.h>": 5686, "<audit_nr_filters; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(portid, seq, audit_list_rules,\n\t\t\t\t\t       0, 1, data,\n\t\t\t\t\t       sizeof(*data) + data->": 5687, "<crypto/hash.h>": 5688, "<crypto/sha.h>": 5689, "<event>": 5690, "<filter>": 5691, "<function>": 5692, "<generated/utsrelease.h>": 5693, "<interrupt>": 5694, "<keys/asymmetric-type.h>": 5695, "<keys/system_keyring.h>": 5696, "<keys/user-type.h>": 5697, "<linux/acct.h>": 5698, "<linux/acpi.h>": 5699, "<linux/aio.h>": 5700, "<linux/alarmtimer.h>": 5701, "<linux/anon_inodes.h>": 5702, "<linux/async.h>": 5703, "<linux/atomic.h>": 5704, "<linux/audit.h>": 5705, "<linux/backing-dev.h>": 5706, "<linux/binfmts.h>": 5707, "<linux/bio.h>": 5708, "<linux/bitmap.h>": 5709, "<linux/bitops.h>": 5710, "<linux/blkdev.h>": 5711, "<linux/blktrace_api.h>": 5712, "<linux/bootmem.h>": 5713, "<linux/bpf.h>": 5714, "<linux/bsearch.h>": 5715, "<linux/bug.h>": 5716, "<linux/cache.h>": 5717, "<linux/capability.h>": 5718, "<linux/cgroup.h>": 5719, "<linux/cgroup_subsys.h>": 5720, "<linux/cgroupstats.h>": 5721, "<linux/circ_buf.h>": 5722, "<linux/clockchips.h>": 5723, "<linux/clocksource.h>": 5724, "<linux/cn_proc.h>": 5725, "<linux/compaction.h>": 5726, "<linux/compat.h>": 5727, "<linux/compiler.h>": 5728, "<linux/completion.h>": 5729, "<linux/console.h>": 5730, "<linux/context_tracking.h>": 5731, "<linux/coredump.h>": 5732, "<linux/cpu.h>": 5733, "<linux/cpu_pm.h>": 5734, "<linux/cpuidle.h>": 5735, "<linux/cpumask.h>": 5736, "<linux/cpuset.h>": 5737, "<linux/crash_dump.h>": 5738, "<linux/crc32.h>": 5739, "<linux/cred.h>": 5740, "<linux/ctype.h>": 5741, "<linux/dcache.h>": 5742, "<linux/dcookies.h>": 5743, "<linux/debug_locks.h>": 5744, "<linux/debugfs.h>": 5745, "<linux/delay.h>": 5746, "<linux/delayacct.h>": 5747, "<linux/device.h>": 5748, "<linux/dnotify.h>": 5749, "<linux/elf.h>": 5750, "<linux/elfcore.h>": 5751, "<linux/err.h>": 5752, "<linux/errno.h>": 5753, "<linux/export.h>": 5754, "<linux/fcntl.h>": 5755, "<linux/fdtable.h>": 5756, "<linux/file.h>": 5757, "<linux/filter.h>": 5758, "<linux/freezer.h>": 5759, "<linux/fs.h>": 5760, "<linux/fs_pin.h>": 5761, "<linux/fs_struct.h>": 5762, "<linux/fsnotify_backend.h>": 5763, "<linux/ftrace.h>": 5764, "<linux/ftrace_event.h>": 5765, "<linux/futex.h>": 5766, "<linux/genhd.h>": 5767, "<linux/getcpu.h>": 5768, "<linux/gfp.h>": 5769, "<linux/hardirq.h>": 5770, "<linux/hash.h>": 5771, "<linux/hashtable.h>": 5772, "<linux/highmem.h>": 5773, "<linux/highuid.h>": 5774, "<linux/hrtimer.h>": 5775, "<linux/hugetlb.h>": 5776, "<linux/hw_breakpoint.h>": 5777, "<linux/idr.h>": 5778, "<linux/init.h>": 5779, "<linux/init_task.h>": 5780, "<linux/initrd.h>": 5781, "<linux/inotify.h>": 5782, "<linux/interrupt.h>": 5783, "<linux/io.h>": 5784, "<linux/iocontext.h>": 5785, "<linux/ioport.h>": 5786, "<linux/ipc_namespace.h>": 5787, "<linux/irq.h>": 5788, "<linux/irq_work.h>": 5789, "<linux/irqdesc.h>": 5790, "<linux/irqdomain.h>": 5791, "<linux/irqflags.h>": 5792, "<linux/jhash.h>": 5793, "<linux/jiffies.h>": 5794, "<linux/jump_label.h>": 5795, "<linux/jump_label_ratelimit.h>": 5796, "<linux/kallsyms.h>": 5797, "<linux/kbuild.h>": 5798, "<linux/kcmp.h>": 5799, "<linux/kdb.h>": 5800, "<linux/kdebug.h>": 5801, "<linux/kernel.h>": 5802, "<linux/kernel_stat.h>": 5803, "<linux/kexec.h>": 5804, "<linux/key-type.h>": 5805, "<linux/key.h>": 5806, "<linux/keyctl.h>": 5807, "<linux/kgdb.h>": 5808, "<linux/khugepaged.h>": 5809, "<linux/kmemcheck.h>": 5810, "<linux/kmemleak.h>": 5811, "<linux/kmod.h>": 5812, "<linux/kmsg_dump.h>": 5813, "<linux/kobject.h>": 5814, "<linux/kprobes.h>": 5815, "<linux/kref.h>": 5816, "<linux/ksm.h>": 5817, "<linux/kthread.h>": 5818, "<linux/ktime.h>": 5819, "<linux/kvm_para.h>": 5820, "<linux/latencytop.h>": 5821, "<linux/lglock.h>": 5822, "<linux/license.h>": 5823, "<linux/limits.h>": 5824, "<linux/linkage.h>": 5825, "<linux/list.h>": 5826, "<linux/livepatch.h>": 5827, "<linux/lockdep.h>": 5828, "<linux/log2.h>": 5829, "<linux/lzo.h>": 5830, "<linux/magic.h>": 5831, "<linux/math64.h>": 5832, "<linux/memblock.h>": 5833, "<linux/memcontrol.h>": 5834, "<linux/memory.h>": 5835, "<linux/mempolicy.h>": 5836, "<linux/migrate.h>": 5837, "<linux/miscdevice.h>": 5838, "<linux/mm.h>": 5839, "<linux/mm_types.h>": 5840, "<linux/mman.h>": 5841, "<linux/mmiotrace.h>": 5842, "<linux/mmu_notifier.h>": 5843, "<linux/mmzone.h>": 5844, "<linux/mnt_namespace.h>": 5845, "<linux/module.h>": 5846, "<linux/moduleloader.h>": 5847, "<linux/moduleparam.h>": 5848, "<linux/mount.h>": 5849, "<linux/mqueue.h>": 5850, "<linux/msi.h>": 5851, "<linux/mutex.h>": 5852, "<linux/namei.h>": 5853, "<linux/net.h>": 5854, "<linux/netdevice.h>": 5855, "<linux/netlink.h>": 5856, "<linux/nfs_fs.h>": 5857, "<linux/nmi.h>": 5858, "<linux/nodemask.h>": 5859, "<linux/notifier.h>": 5860, "<linux/nsproxy.h>": 5861, "<linux/numa.h>": 5862, "<linux/of.h>": 5863, "<linux/of_address.h>": 5864, "<linux/of_irq.h>": 5865, "<linux/oom.h>": 5866, "<linux/osq_lock.h>": 5867, "<linux/padata.h>": 5868, "<linux/page-flags.h>": 5869, "<linux/pagemap.h>": 5870, "<linux/pci.h>": 5871, "<linux/percpu-rwsem.h>": 5872, "<linux/percpu.h>": 5873, "<linux/perf_event.h>": 5874, "<linux/personality.h>": 5875, "<linux/pfn.h>": 5876, "<linux/pid.h>": 5877, "<linux/pid_namespace.h>": 5878, "<linux/pipe_fs_i.h>": 5879, "<linux/platform_device.h>": 5880, "<linux/pm-trace.h>": 5881, "<linux/pm.h>": 5882, "<linux/pm_qos.h>": 5883, "<linux/pm_wakeup.h>": 5884, "<linux/poison.h>": 5885, "<linux/poll.h>": 5886, "<linux/posix-clock.h>": 5887, "<linux/posix-timers.h>": 5888, "<linux/prctl.h>": 5889, "<linux/preempt.h>": 5890, "<linux/prefetch.h>": 5891, "<linux/printk.h>": 5892, "<linux/proc_fs.h>": 5893, "<linux/proc_ns.h>": 5894, "<linux/profile.h>": 5895, "<linux/projid.h>": 5896, "<linux/ptrace.h>": 5897, "<linux/pvclock_gtod.h>": 5898, "<linux/radix-tree.h>": 5899, "<linux/random.h>": 5900, "<linux/range.h>": 5901, "<linux/ratelimit.h>": 5902, "<linux/rbtree.h>": 5903, "<linux/rculist.h>": 5904, "<linux/rcupdate.h>": 5905, "<linux/reboot.h>": 5906, "<linux/regset.h>": 5907, "<linux/resource.h>": 5908, "<linux/resource_ext.h>": 5909, "<linux/ring_buffer.h>": 5910, "<linux/rmap.h>": 5911, "<linux/rtc.h>": 5912, "<linux/rtmutex.h>": 5913, "<linux/rwlock.h>": 5914, "<linux/rwsem.h>": 5915, "<linux/sched.h>": 5916, "<linux/sched/deadline.h>": 5917, "<linux/sched/rt.h>": 5918, "<linux/sched/sysctl.h>": 5919, "<linux/seccomp.h>": 5920, "<linux/securebits.h>": 5921, "<linux/security.h>": 5922, "<linux/sem.h>": 5923, "<linux/semaphore.h>": 5924, "<linux/seq_file.h>": 5925, "<linux/seqlock.h>": 5926, "<linux/serial_core.h>": 5927, "<linux/shmem_fs.h>": 5928, "<linux/signal.h>": 5929, "<linux/signalfd.h>": 5930, "<linux/skbuff.h>": 5931, "<linux/slab.h>": 5932, "<linux/smp.h>": 5933, "<linux/smpboot.h>": 5934, "<linux/socket.h>": 5935, "<linux/sort.h>": 5936, "<linux/spinlock.h>": 5937, "<linux/spinlock_types.h>": 5938, "<linux/splice.h>": 5939, "<linux/srcu.h>": 5940, "<linux/stackprotector.h>": 5941, "<linux/stacktrace.h>": 5942, "<linux/stat.h>": 5943, "<linux/static_key.h>": 5944, "<linux/stddef.h>": 5945, "<linux/stop_machine.h>": 5946, "<linux/string.h>": 5947, "<linux/stringify.h>": 5948, "<linux/sunrpc/debug.h>": 5949, "<linux/suspend.h>": 5950, "<linux/suspend_ioctls.h>": 5951, "<linux/swap.h>": 5952, "<linux/swapops.h>": 5953, "<linux/syscalls.h>": 5954, "<linux/syscore_ops.h>": 5955, "<linux/sysctl.h>": 5956, "<linux/sysfs.h>": 5957, "<linux/syslog.h>": 5958, "<linux/sysrq.h>": 5959, "<linux/task_io_accounting_ops.h>": 5960, "<linux/task_work.h>": 5961, "<linux/taskstats.h>": 5962, "<linux/taskstats_kern.h>": 5963, "<linux/thread_info.h>": 5964, "<linux/threads.h>": 5965, "<linux/tick.h>": 5966, "<linux/time.h>": 5967, "<linux/timecounter.h>": 5968, "<linux/timekeeper_internal.h>": 5969, "<linux/timer.h>": 5970, "<linux/timerqueue.h>": 5971, "<linux/times.h>": 5972, "<linux/timex.h>": 5973, "<linux/topology.h>": 5974, "<linux/torture.h>": 5975, "<linux/trace_clock.h>": 5976, "<linux/trace_seq.h>": 5977, "<linux/tracefs.h>": 5978, "<linux/tracehook.h>": 5979, "<linux/tracepoint.h>": 5980, "<linux/tsacct_kern.h>": 5981, "<linux/tty.h>": 5982, "<linux/tty_driver.h>": 5983, "<linux/types.h>": 5984, "<linux/uaccess.h>": 5985, "<linux/uidgid.h>": 5986, "<linux/uio.h>": 5987, "<linux/unistd.h>": 5988, "<linux/uprobes.h>": 5989, "<linux/usb.h>": 5990, "<linux/user-return-notifier.h>": 5991, "<linux/user_namespace.h>": 5992, "<linux/uts.h>": 5993, "<linux/utsname.h>": 5994, "<linux/vermagic.h>": 5995, "<linux/version.h>": 5996, "<linux/vfs.h>": 5997, "<linux/vmacache.h>": 5998, "<linux/vmalloc.h>": 5999, "<linux/vmstat.h>": 6000, "<linux/wait.h>": 6001, "<linux/workqueue.h>": 6002, "<linux/writeback.h>": 6003, "<linux/ww_mutex.h>": 6004, "<module-name>": 6005, "<net/genetlink.h>": 6006, "<net/net_namespace.h>": 6007, "<net/netlink.h>": 6008, "<net/netns/generic.h>": 6009, "<net/sock.h>": 6010, "<scsi/sg.h>": 6011, "<stdarg.h>": 6012, "<system>": 6013, "<trace/define_trace.h>": 6014, "<trace/events/block.h>": 6015, "<trace/events/context_tracking.h>": 6016, "<trace/events/irq.h>": 6017, "<trace/events/lock.h>": 6018, "<trace/events/module.h>": 6019, "<trace/events/power.h>": 6020, "<trace/events/printk.h>": 6021, "<trace/events/rcu.h>": 6022, "<trace/events/rpm.h>": 6023, "<trace/events/sched.h>": 6024, "<trace/events/signal.h>": 6025, "<trace/events/syscalls.h>": 6026, "<trace/events/task.h>": 6027, "<trace/events/timer.h>": 6028, "<trace/syscall.h>": 6029, "<trigger>": 6030, "<uapi/linux/limits.h>": 6031, "<uapi/linux/module.h>": 6032, "<uapi/linux/mqueue.h>": 6033, "<user stack trace>": 6034, "=": 6035, "==": 6036, ">": 6037, ">=": 6038, "[": 6039, "\\": 6040, "]": 6041, "^": 6042, "_": 6043, "_____i": 6044, "_____ret": 6045, "____cacheline_aligned": 6046, "____cacheline_aligned_in_smp": 6047, "____cacheline_internodealigned_in_smp": 6048, "____call_usermodehelper": 6049, "____ftrace_": 6050, "____ftrace_check_": 6051, "___might_sleep": 6052, "___n": 6053, "___p": 6054, "___pd": 6055, "___ps": 6056, "___r": 6057, "___ret": 6058, "__account_cfs_rq_runtime": 6059, "__account_scheduler_latency": 6060, "__account_system_time": 6061, "__acct_update_integrals": 6062, "__acquire": 6063, "__acquires": 6064, "__add_event_to_tracers": 6065, "__add_hash_entry": 6066, "__add_wait_queue": 6067, "__add_wait_queue_tail": 6068, "__adjust_resource": 6069, "__aligned": 6070, "__alignof__": 6071, "__alloc_filter": 6072, "__alloc_percpu": 6073, "__alloc_pred_stack": 6074, "__alloc_preds": 6075, "__alloc_reserved_percpu": 6076, "__alloc_workqueue_key": 6077, "__always_inline": 6078, "__always_unused": 6079, "__arch_has_ka_restorer": 6080, "__arch_has_sa_restorer": 6081, "__arch_has_vtime_account": 6082, "__arch_has_vtime_task_switch": 6083, "__arch_irq_exit_irqs_disabled": 6084, "__arch_irq_stat": 6085, "__arch_rw_lock_unlocked": 6086, "__arch_si_trapno": 6087, "__arch_sigsys": 6088, "__arch_spin_lock_unlocked": 6089, "__arch_um__": 6090, "__arch_want_compat_sys_time": 6091, "__arch_want_sys_alarm": 6092, "__arch_want_sys_clone": 6093, "__arch_want_sys_fork": 6094, "__arch_want_sys_gethostname": 6095, "__arch_want_sys_getpgrp": 6096, "__arch_want_sys_old_getrlimit": 6097, "__arch_want_sys_old_uname": 6098, "__arch_want_sys_pause": 6099, "__arch_want_sys_signal": 6100, "__arch_want_sys_sigpending": 6101, "__arch_want_sys_sigprocmask": 6102, "__arch_want_sys_time": 6103, "__arch_want_sys_vfork": 6104, "__arm_kprobe": 6105, "__array": 6106, "__array_desc": 6107, "__assign_fetch_type": 6108, "__async_schedule": 6109, "__atomic_notifier_call_chain": 6110, "__attr": 6111, "__attr_null": 6112, "__attr_ro": 6113, "__attr_rw": 6114, "__attribute__": 6115, "__audit_bprm": 6116, "__audit_fd_pair": 6117, "__audit_file": 6118, "__audit_free": 6119, "__audit_getname": 6120, "__audit_inode": 6121, "__audit_inode_child": 6122, "__audit_ipc_obj": 6123, "__audit_ipc_set_perm": 6124, "__audit_log_bprm_fcaps": 6125, "__audit_log_capset": 6126, "__audit_mmap_fd": 6127, "__audit_mq_getsetattr": 6128, "__audit_mq_notify": 6129, "__audit_mq_open": 6130, "__audit_mq_sendrecv": 6131, "__audit_ptrace": 6132, "__audit_reusename": 6133, "__audit_seccomp": 6134, "__audit_signal_info": 6135, "__audit_sockaddr": 6136, "__audit_socketcall": 6137, "__audit_syscall_entry": 6138, "__audit_syscall_exit": 6139, "__b": 6140, "__bad_type_size": 6141, "__be64": 6142, "__bfs": 6143, "__big_endian": 6144, "__blk_add_trace": 6145, "__blk_ta_backmerge": 6146, "__blk_ta_bounce": 6147, "__blk_ta_complete": 6148, "__blk_ta_frontmerge": 6149, "__blk_ta_getrq": 6150, "__blk_ta_insert": 6151, "__blk_ta_issue": 6152, "__blk_ta_plug": 6153, "__blk_ta_queue": 6154, "__blk_ta_remap": 6155, "__blk_ta_requeue": 6156, "__blk_ta_sleeprq": 6157, "__blk_ta_split": 6158, "__blk_ta_unplug_io": 6159, "__blk_ta_unplug_timer": 6160, "__blocking_notifier_call_chain": 6161, "__bpf_call_base": 6162, "__bpf_func_max_id": 6163, "__bpf_prog_free": 6164, "__bpf_prog_run": 6165, "__buffer_unlock_commit": 6166, "__builtin_return_address": 6167, "__builtin_types_compatible_p": 6168, "__cacheline_aligned": 6169, "__cacheline_aligned_in_smp": 6170, "__calc_delta": 6171, "__call_rcu": 6172, "__call_rcu_core": 6173, "__call_rcu_nocb": 6174, "__call_rcu_nocb_enqueue": 6175, "__call_usermodehelper": 6176, "__cancel_work_timer": 6177, "__cap_empty_set": 6178, "__cfs_bandwidth_used": 6179, "__cfs_schedulable": 6180, "__cftype_not_on_dfl": 6181, "__cftype_only_on_dfl": 6182, "__cgroup_procs_write": 6183, "__change_pid": 6184, "__checkparam_dl": 6185, "__cleanup_sighand": 6186, "__clear_bit": 6187, "__clear_buddies_last": 6188, "__clear_buddies_next": 6189, "__clear_buddies_skip": 6190, "__clear_sched_clock_stable": 6191, "__clockevents_set_state": 6192, "__clockevents_try_unbind": 6193, "__clockevents_unbind": 6194, "__clockevents_update_freq": 6195, "__common_field": 6196, "__compat_get_timespec": 6197, "__compat_get_timeval": 6198, "__compat_put_timespec": 6199, "__compat_put_timeval": 6200, "__compat_save_altstack": 6201, "__compute_runnable_contrib": 6202, "__cond_lock": 6203, "__cond_resched_lock": 6204, "__cond_resched_softirq": 6205, "__context_tracking_task_switch": 6206, "__copy_from_user_inatomic": 6207, "__copy_insn": 6208, "__copy_to_user": 6209, "__count": 6210, "__cpu": 6211, "__cpu_die": 6212, "__cpu_disable": 6213, "__cpu_lockdep_stats": 6214, "__cpu_notify": 6215, "__cpu_up": 6216, "__cpuinit": 6217, "__cpuset_memory_pressure_bump": 6218, "__cpuset_node_allowed": 6219, "__cq_dequeue": 6220, "__cq_empty": 6221, "__cq_enqueue": 6222, "__cq_full": 6223, "__cq_get_elem_count": 6224, "__cq_init": 6225, "__create_xol_area": 6226, "__current_clr_polling": 6227, "__current_kernel_time": 6228, "__current_set_polling": 6229, "__data": 6230, "__debug_atomic_inc": 6231, "__debug_locks_off": 6232, "__default_fetch_type": 6233, "__delay": 6234, "__delayacct_add_tsk": 6235, "__delayacct_blkio_end": 6236, "__delayacct_blkio_start": 6237, "__delayacct_blkio_ticks": 6238, "__delayacct_freepages_end": 6239, "__delayacct_freepages_start": 6240, "__delayacct_tsk_init": 6241, "__dequeue_entity": 6242, "__dequeue_rt_entity": 6243, "__dequeue_signal": 6244, "__devm_release_region": 6245, "__devm_request_region": 6246, "__disable_irq": 6247, "__disable_irq_nosync": 6248, "__disable_kprobe": 6249, "__disable_runtime": 6250, "__disable_trace_on_warning": 6251, "__disarm_kprobe": 6252, "__dl_add": 6253, "__dl_clear": 6254, "__dl_clear_params": 6255, "__dl_overflow": 6256, "__do_adjtimex": 6257, "__do_proc_dointvec": 6258, "__do_proc_doulongvec_minmax": 6259, "__do_softirq": 6260, "__down": 6261, "__down_common": 6262, "__down_interruptible": 6263, "__down_killable": 6264, "__down_read": 6265, "__down_read_trylock": 6266, "__down_timeout": 6267, "__down_trylock_console_sem": 6268, "__down_write": 6269, "__down_write_nested": 6270, "__down_write_trylock": 6271, "__downgrade_write": 6272, "__dynamic_array": 6273, "__enable_irq": 6274, "__enable_runtime": 6275, "__enqueue_entity": 6276, "__enqueue_rt_entity": 6277, "__entry": 6278, "__event_": 6279, "__exit": 6280, "__fatal_signal_pending": 6281, "__ffs": 6282, "__field": 6283, "__field_desc": 6284, "__field_struct": 6285, "__file__": 6286, "__find_event_field": 6287, "__find_resource": 6288, "__find_uprobe": 6289, "__flush_itimer_signals": 6290, "__flush_signals": 6291, "__force": 6292, "__fput_sync": 6293, "__free_domain_allocs": 6294, "__free_event": 6295, "__free_filter": 6296, "__free_ftrace_hash_rcu": 6297, "__free_insn_slot": 6298, "__free_irq": 6299, "__free_page": 6300, "__free_percpu_irq": 6301, "__free_pred_stack": 6302, "__free_preds": 6303, "__free_subsystem_filter": 6304, "__ftrace_bad_type": 6305, "__ftrace_event_enable_disable": 6306, "__ftrace_function_set_filter": 6307, "__ftrace_graph_entry": 6308, "__ftrace_hash_rec_update": 6309, "__ftrace_hash_update_ipmodify": 6310, "__ftrace_modify_code": 6311, "__ftrace_ops_list_func": 6312, "__ftrace_replace_code": 6313, "__ftrace_set_clr_event": 6314, "__ftrace_set_clr_event_nolock": 6315, "__ftrace_vbprintk": 6316, "__ftrace_vprintk": 6317, "__func__": 6318, "__gcov_flush": 6319, "__gcov_init": 6320, "__gcov_merge_add": 6321, "__gcov_merge_delta": 6322, "__gcov_merge_ior": 6323, "__gcov_merge_single": 6324, "__gcov_merge_time_profile": 6325, "__generating_bounds_h": 6326, "__get_cached_msi_msg": 6327, "__get_cpu_context": 6328, "__get_data_size": 6329, "__get_free_page": 6330, "__get_free_pages": 6331, "__get_insn_slot": 6332, "__get_key_name": 6333, "__get_system": 6334, "__get_system_dir": 6335, "__get_user": 6336, "__get_valid_kprobe": 6337, "__getname": 6338, "__getnstimeofday64": 6339, "__getparam_dl": 6340, "__gfp_cold": 6341, "__gfp_fs": 6342, "__gfp_hardwall": 6343, "__gfp_high": 6344, "__gfp_highmem": 6345, "__gfp_nomemalloc": 6346, "__gfp_noretry": 6347, "__gfp_notrack_false_positive": 6348, "__gfp_nowarn": 6349, "__gfp_thisnode": 6350, "__gfp_wait": 6351, "__gfp_zero": 6352, "__gnuc__": 6353, "__gnuc_minor__": 6354, "__group_send_sig_info": 6355, "__handle_domain_irq": 6356, "__hardpps": 6357, "__hibernation_after_last": 6358, "__hotcpu_notifier": 6359, "__hppa__": 6360, "__hrtick_restart": 6361, "__hrtick_start": 6362, "__hrtimer_start_range_ns": 6363, "__hrtimer_tasklet_trampoline": 6364, "__i386__": 6365, "__init": 6366, "__init_kthread_worker": 6367, "__init_rwsem": 6368, "__init_srcu_struct": 6369, "__init_waitqueue_head": 6370, "__init_work": 6371, "__initcall": 6372, "__initconst": 6373, "__initdata": 6374, "__initdata_or_module": 6375, "__insert_resource": 6376, "__insert_uprobe": 6377, "__internal_add_timer": 6378, "__iomem": 6379, "__irq_alloc_descs": 6380, "__irq_domain_add": 6381, "__irq_domain_alloc_irqs": 6382, "__irq_enter": 6383, "__irq_get_desc_lock": 6384, "__irq_put_desc_unlock": 6385, "__irq_set_affinity": 6386, "__irq_set_handler": 6387, "__irq_set_trigger": 6388, "__irq_wake_thread": 6389, "__irqentry_text_end": 6390, "__irqf_timer": 6391, "__irqsoff_tracer_init": 6392, "__is_kfree_rcu_offset": 6393, "__is_ram": 6394, "__jump_label_mod_text_reserved": 6395, "__jump_label_mod_update": 6396, "__jump_label_text_reserved": 6397, "__jump_label_update": 6398, "__kernel__": 6399, "__kernel_param_lock": 6400, "__kernel_param_unlock": 6401, "__kernel_size_t": 6402, "__kernel_time_t": 6403, "__kernel_write": 6404, "__kernfs_create_file": 6405, "__kexec_load_purgatory": 6406, "__kgid_val": 6407, "__kill_pgrp_info": 6408, "__klp_disable_patch": 6409, "__klp_enable_patch": 6410, "__kprobe_trace_func": 6411, "__kprobes_text_start": 6412, "__kprojid_val": 6413, "__kretprobe_trace_func": 6414, "__kthread_bind": 6415, "__kthread_parkme": 6416, "__kthread_unpark": 6417, "__ktime_get_fast_ns": 6418, "__kuid_val": 6419, "__le16": 6420, "__line__": 6421, "__linux_mcs_spinlock_h": 6422, "__linux_rcu_h": 6423, "__list_del": 6424, "__local_bh_disable_ip": 6425, "__local_bh_enable": 6426, "__local_bh_enable_ip": 6427, "__lock_acquire": 6428, "__lock_acquired": 6429, "__lock_contended": 6430, "__lock_is_held": 6431, "__lock_release": 6432, "__lock_set_class": 6433, "__lock_task_sighand": 6434, "__lock_text_end": 6435, "__lock_text_start": 6436, "__lock_timer": 6437, "__lockdep_no_validate__": 6438, "__lockdep_trace_alloc": 6439, "__lockf": 6440, "__lockfunc": 6441, "__log_buf_len": 6442, "__m1": 6443, "__m2": 6444, "__max_nr_zones": 6445, "__maybe_unused": 6446, "__might_sleep": 6447, "__migrate_swap_task": 6448, "__migrate_task": 6449, "__mmdrop": 6450, "__mod_timer": 6451, "__modinit": 6452, "__module_address": 6453, "__module_get": 6454, "__module_text_address": 6455, "__modver_version_show": 6456, "__mutex_fastpath_lock": 6457, "__mutex_fastpath_lock_retval": 6458, "__mutex_fastpath_trylock": 6459, "__mutex_fastpath_unlock": 6460, "__mutex_init": 6461, "__mutex_initializer": 6462, "__mutex_lock_common": 6463, "__mutex_lock_interruptible_slowpath": 6464, "__mutex_lock_killable_slowpath": 6465, "__mutex_lock_slowpath": 6466, "__mutex_slowpath_needs_to_unlock": 6467, "__mutex_trylock_slowpath": 6468, "__mutex_unlock_common_slowpath": 6469, "__mutex_unlock_slowpath": 6470, "__name": 6471, "__need_more_worker": 6472, "__net_exit": 6473, "__net_init": 6474, "__net_initdata": 6475, "__new_uts_len": 6476, "__next": 6477, "__next_timer_interrupt": 6478, "__noreturn": 6479, "__normal_prio": 6480, "__nosavedata": 6481, "__note_gp_changes": 6482, "__nr_pageflags": 6483, "__nr_seccomp_exit": 6484, "__nr_seccomp_exit_32": 6485, "__nr_seccomp_read": 6486, "__nr_seccomp_read_32": 6487, "__nr_seccomp_sigreturn": 6488, "__nr_seccomp_sigreturn_32": 6489, "__nr_seccomp_write": 6490, "__nr_seccomp_write_32": 6491, "__old": 6492, "__old_uts_len": 6493, "__op": 6494, "__output_copy": 6495, "__output_skip": 6496, "__p": 6497, "__packed": 6498, "__padata_add_cpu": 6499, "__padata_free": 6500, "__padata_list_init": 6501, "__padata_remove_cpu": 6502, "__padata_set_cpumasks": 6503, "__padata_start": 6504, "__padata_stop": 6505, "__parse_bitfield_probe_arg": 6506, "__parse_crashkernel": 6507, "__pc": 6508, "__per_cpu_offset": 6509, "__percpu": 6510, "__percpu_init_rwsem": 6511, "__perf_event__output_id_sample": 6512, "__perf_event_count": 6513, "__perf_event_disable": 6514, "__perf_event_enable": 6515, "__perf_event_header__init_id": 6516, "__perf_event_init_context": 6517, "__perf_event_mark_enabled": 6518, "__perf_event_read": 6519, "__perf_event_sync_stat": 6520, "__perf_event_task_sched_in": 6521, "__perf_install_in_context": 6522, "__perf_mmap_to_page": 6523, "__perf_remove_from_context": 6524, "__pick_first_entity": 6525, "__pick_last_entity": 6526, "__pick_next_entity": 6527, "__pm_qos_update_request": 6528, "__pm_relax": 6529, "__pm_stay_awake": 6530, "__pm_wakeup_event": 6531, "__pn": 6532, "__pool": 6533, "__pop_pred_stack": 6534, "__posix_timers_find": 6535, "__prctl_check_order": 6536, "__preempt_count_add": 6537, "__preempt_count_sub": 6538, "__print_graph_headers_flags": 6539, "__print_lock_name": 6540, "__print_symbol": 6541, "__profile_flip_buffers": 6542, "__ptrace_detach": 6543, "__ptrace_link": 6544, "__ptrace_may_access": 6545, "__ptrace_unlink": 6546, "__push_pred_stack": 6547, "__put_chunk": 6548, "__put_cred": 6549, "__put_system": 6550, "__put_system_dir": 6551, "__put_task_struct": 6552, "__put_user": 6553, "__putname": 6554, "__queue_delayed_work": 6555, "__queue_work": 6556, "__r": 6557, "__raise_softirq_irqoff": 6558, "__raw_": 6559, "__raw_notifier_call_chain": 6560, "__raw_read_lock": 6561, "__raw_read_lock_bh": 6562, "__raw_read_lock_irq": 6563, "__raw_read_lock_irqsave": 6564, "__raw_read_trylock": 6565, "__raw_read_unlock": 6566, "__raw_read_unlock_bh": 6567, "__raw_read_unlock_irq": 6568, "__raw_read_unlock_irqrestore": 6569, "__raw_spin_lock": 6570, "__raw_spin_lock_bh": 6571, "__raw_spin_lock_init": 6572, "__raw_spin_lock_irq": 6573, "__raw_spin_lock_irqsave": 6574, "__raw_spin_lock_unlocked": 6575, "__raw_spin_trylock": 6576, "__raw_spin_trylock_bh": 6577, "__raw_spin_unlock": 6578, "__raw_spin_unlock_bh": 6579, "__raw_spin_unlock_irq": 6580, "__raw_spin_unlock_irqrestore": 6581, "__raw_write_lock": 6582, "__raw_write_lock_bh": 6583, "__raw_write_lock_irq": 6584, "__raw_write_lock_irqsave": 6585, "__raw_write_trylock": 6586, "__raw_write_unlock": 6587, "__raw_write_unlock_bh": 6588, "__raw_write_unlock_irq": 6589, "__raw_write_unlock_irqrestore": 6590, "__rb_allocate_pages": 6591, "__rb_data_page_index": 6592, "__rb_free_aux": 6593, "__rb_page_index": 6594, "__rb_reserve_next": 6595, "__rcu": 6596, "__rcu_init_preempt": 6597, "__rcu_is_watching": 6598, "__rcu_pending": 6599, "__rcu_process_callbacks": 6600, "__rcu_read_lock": 6601, "__rcu_read_unlock": 6602, "__rcu_reclaim": 6603, "__read_lock_debug": 6604, "__read_mostly": 6605, "__ref": 6606, "__refdata": 6607, "__refill_cfs_bandwidth_runtime": 6608, "__refrigerator": 6609, "__register_cpu_notifier": 6610, "__register_event": 6611, "__register_ftrace_function": 6612, "__register_nosave_region": 6613, "__register_trace_kprobe": 6614, "__release": 6615, "__release_child_resources": 6616, "__release_region": 6617, "__release_resource": 6618, "__releases": 6619, "__remove_filter": 6620, "__remove_wait_queue": 6621, "__replace_page": 6622, "__report_bad_irq": 6623, "__request_module": 6624, "__request_region": 6625, "__request_resource": 6626, "__res": 6627, "__rescuer": 6628, "__reserve_region_with_split": 6629, "__reserved": 6630, "__reset_stat_session": 6631, "__return_cfs_rq_runtime": 6632, "__ring_buffer_alloc": 6633, "__rq_clock_broken": 6634, "__rt_schedulable": 6635, "__run_timers": 6636, "__rwlock_init": 6637, "__rwsem_do_wake": 6638, "__rwsem_initializer": 6639, "__rwsem_wake_one_writer": 6640, "__same_type": 6641, "__save_altstack": 6642, "__sched": 6643, "__sched_clock_stable": 6644, "__sched_clock_stable_early": 6645, "__sched_feat_": 6646, "__sched_feat_nr": 6647, "__sched_fork": 6648, "__sched_info_switch": 6649, "__sched_period": 6650, "__sched_setscheduler": 6651, "__sched_text_start": 6652, "__schedule": 6653, "__schedule_bug": 6654, "__sd": 6655, "__sdt_alloc": 6656, "__sdt_free": 6657, "__seccomp_phase1_filter": 6658, "__secure_computing": 6659, "__secure_computing_strict": 6660, "__send_signal": 6661, "__seq_open_private": 6662, "__set_bit": 6663, "__set_current_blocked": 6664, "__set_current_state": 6665, "__set_enter_print_fmt": 6666, "__set_print_fmt": 6667, "__set_sched_clock_stable": 6668, "__set_task_blocked": 6669, "__set_task_cpu": 6670, "__set_task_state": 6671, "__setparam_dl": 6672, "__setscheduler": 6673, "__setscheduler_params": 6674, "__setup": 6675, "__setup_irq": 6676, "__si_chld": 6677, "__si_fault": 6678, "__si_kill": 6679, "__si_mask": 6680, "__si_mesgq": 6681, "__si_poll": 6682, "__si_rt": 6683, "__si_special": 6684, "__si_sys": 6685, "__si_timer": 6686, "__sighandler_t": 6687, "__sigqueue_alloc": 6688, "__sigqueue_free": 6689, "__size": 6690, "__skb_dequeue": 6691, "__smpboot_create_thread": 6692, "__sparc__": 6693, "__spin_lock_debug": 6694, "__sprint_symbol": 6695, "__srcu_notifier_call_chain": 6696, "__srcu_read_lock": 6697, "__srcu_read_unlock": 6698, "__stack_chk_fail": 6699, "__start___ex_table": 6700, "__start___jump_table": 6701, "__start___kcrctab": 6702, "__start___kcrctab_gpl": 6703, "__start___kcrctab_gpl_future": 6704, "__start___kcrctab_unused": 6705, "__start___kcrctab_unused_gpl": 6706, "__start___ksymtab": 6707, "__start___ksymtab_gpl": 6708, "__start___ksymtab_gpl_future": 6709, "__start___ksymtab_unused": 6710, "__start___ksymtab_unused_gpl": 6711, "__start___modver": 6712, "__start___param": 6713, "__start___trace_bprintk_fmt": 6714, "__start___tracepoint_str": 6715, "__start_annotated_branch_profile": 6716, "__start_branch_profile": 6717, "__start_cfs_bandwidth": 6718, "__start_ftrace_events": 6719, "__start_kprobe_blacklist": 6720, "__start_syscalls_metadata": 6721, "__state": 6722, "__static_key_slow_dec": 6723, "__stop___ex_table": 6724, "__stop___jump_table": 6725, "__stop___ksymtab": 6726, "__stop___ksymtab_gpl": 6727, "__stop___ksymtab_gpl_future": 6728, "__stop___ksymtab_unused": 6729, "__stop___ksymtab_unused_gpl": 6730, "__stop___modver": 6731, "__stop___trace_bprintk_fmt": 6732, "__stop___tracepoint_str": 6733, "__stop_annotated_branch_profile": 6734, "__stop_branch_profile": 6735, "__stop_cpus": 6736, "__stop_ftrace_events": 6737, "__stop_kprobe_blacklist": 6738, "__stop_machine": 6739, "__stop_syscalls_metadata": 6740, "__stringify": 6741, "__symbol_get": 6742, "__symbol_put": 6743, "__synchronize_entity_decay": 6744, "__synchronize_hardirq": 6745, "__synchronize_srcu": 6746, "__sysrq_enabled": 6747, "__task_cred": 6748, "__task_pid_nr_ns": 6749, "__task_rq_lock": 6750, "__task_rq_unlock": 6751, "__task_stopped": 6752, "__task_traced": 6753, "__tasklet_hi_schedule": 6754, "__tasklet_hi_schedule_first": 6755, "__tasklet_hrtimer_trampoline": 6756, "__tasklet_schedule": 6757, "__test_after_last": 6758, "__thaw_task": 6759, "__this_cpu_add": 6760, "__this_cpu_dec": 6761, "__this_cpu_inc": 6762, "__this_cpu_inc_return": 6763, "__this_cpu_read": 6764, "__this_cpu_write": 6765, "__this_cpu_xchg": 6766, "__tick_nohz_full_check": 6767, "__tick_nohz_idle_enter": 6768, "__tick_nohz_task_switch": 6769, "__timekeeping_inject_sleeptime": 6770, "__timekeeping_set_tai_offset": 6771, "__timer_stats_timer_set_start_info": 6772, "__timespec_to_jiffies": 6773, "__timr": 6774, "__to_kthread": 6775, "__torture_print_stats": 6776, "__total": 6777, "__touch_watchdog": 6778, "__trace_add_event_dirs": 6779, "__trace_add_new_event": 6780, "__trace_array_put": 6781, "__trace_bprintk": 6782, "__trace_bputs": 6783, "__trace_define_field": 6784, "__trace_early_add_event_dirs": 6785, "__trace_early_add_events": 6786, "__trace_early_add_new_event": 6787, "__trace_find_cmdline": 6788, "__trace_first_type": 6789, "__trace_function": 6790, "__trace_graph_entry": 6791, "__trace_graph_function": 6792, "__trace_graph_return": 6793, "__trace_hardirqs_on_caller": 6794, "__trace_last_type": 6795, "__trace_mmiotrace_map": 6796, "__trace_mmiotrace_rw": 6797, "__trace_note_message": 6798, "__trace_printk": 6799, "__trace_puts": 6800, "__trace_remove_event_call": 6801, "__trace_remove_event_dirs": 6802, "__trace_seq_init": 6803, "__trace_stack": 6804, "__trace_stat_h": 6805, "__tracepoint_string": 6806, "__tracer_data": 6807, "__tstat_hashfn": 6808, "__tvec_bases": 6809, "__u16": 6810, "__u32": 6811, "__u64": 6812, "__u8": 6813, "__uidhashfn": 6814, "__unregister_cpu_notifier": 6815, "__unregister_ftrace_event": 6816, "__unregister_ftrace_function": 6817, "__unregister_kprobe_bottom": 6818, "__unregister_kprobe_top": 6819, "__unregister_trace_kprobe": 6820, "__unused": 6821, "__up": 6822, "__up_read": 6823, "__up_write": 6824, "__update_blocked_averages_cpu": 6825, "__update_cfs_rq_tg_load_contrib": 6826, "__update_cpu_load": 6827, "__update_entity_load_avg_contrib": 6828, "__update_entity_runnable_avg": 6829, "__update_entity_utilization_avg_contrib": 6830, "__update_group_entity_contrib": 6831, "__update_inv_weight": 6832, "__update_max_tr": 6833, "__update_task_entity_contrib": 6834, "__update_task_entity_utilization": 6835, "__update_tg_runnable_avg": 6836, "__uprobe_perf_filter": 6837, "__uprobe_perf_func": 6838, "__uprobe_register": 6839, "__uprobe_trace_func": 6840, "__uprobe_unregister": 6841, "__usage": 6842, "__used": 6843, "__user": 6844, "__user_cap_data_struct": 6845, "__usermodehelper_set_disable_depth": 6846, "__va": 6847, "__va_args__": 6848, "__val": 6849, "__validate_process_creds": 6850, "__visible": 6851, "__visit_domain_allocation_hell": 6852, "__vma_link_rb": 6853, "__vmalloc": 6854, "__vtime_account_system": 6855, "__wait_atomic_t_key_initializer": 6856, "__wait_bit_key_initializer": 6857, "__wait_on_atomic_t": 6858, "__wait_on_bit": 6859, "__wait_on_bit_lock": 6860, "__wait_queue_head_initializer": 6861, "__wake_up": 6862, "__wake_up_bit": 6863, "__wake_up_common": 6864, "__wake_up_locked": 6865, "__wake_up_locked_key": 6866, "__wake_up_parent": 6867, "__wake_up_sync": 6868, "__wake_up_sync_key": 6869, "__wakeup_reset": 6870, "__wakeup_tracer_init": 6871, "__wall": 6872, "__weak": 6873, "__worker": 6874, "__wq_draining": 6875, "__wq_ordered": 6876, "__write_lock_debug": 6877, "__ww_mutex_lock": 6878, "__ww_mutex_lock_check_stamp": 6879, "__ww_mutex_lock_interruptible": 6880, "__ww_mutex_lock_interruptible_slowpath": 6881, "__ww_mutex_lock_slowpath": 6882, "_attr": 6883, "_braille_console_setup": 6884, "_braille_register_console": 6885, "_braille_unregister_console": 6886, "_can_lock": 6887, "_cgrp_id": 6888, "_cgrp_subsys": 6889, "_cond_resched": 6890, "_console_cmdline_h": 6891, "_cpu_down": 6892, "_cpu_up": 6893, "_create": 6894, "_cred": 6895, "_data": 6896, "_ddebug": 6897, "_debug_core_h_": 6898, "_default_fetch_type": 6899, "_double_lock_balance": 6900, "_down_write_nest_lock": 6901, "_einittext": 6902, "_end": 6903, "_etext": 6904, "_exists": 6905, "_fls": 6906, "_fmttype": 6907, "_free_event": 6908, "_ioc_nr": 6909, "_ioc_size": 6910, "_ioc_type": 6911, "_irq_default_init_flags": 6912, "_irq_desc_check": 6913, "_irq_desc_percpu": 6914, "_irq_is_polled": 6915, "_irq_level": 6916, "_irq_move_pcntxt": 6917, "_irq_nested_thread": 6918, "_irq_no_balancing": 6919, "_irq_noautoen": 6920, "_irq_noprobe": 6921, "_irq_norequest": 6922, "_irq_nothread": 6923, "_irq_per_cpu": 6924, "_irq_per_cpu_devid": 6925, "_irqf_modify_mask": 6926, "_k": 6927, "_kdb_bp_install": 6928, "_kdb_bp_remove": 6929, "_kdbprivate_h": 6930, "_kernel_capability_u32s": 6931, "_kernel_capability_version": 6932, "_kernel_events_internal_h": 6933, "_kernel_time_timekeeping_h": 6934, "_kobj": 6935, "_last_field": 6936, "_linux_capability_u32s_1": 6937, "_linux_capability_u32s_3": 6938, "_linux_capability_version_1": 6939, "_linux_capability_version_2": 6940, "_linux_capability_version_3": 6941, "_linux_kernel_trace_h": 6942, "_linux_ntp_internal_h": 6943, "_local_bh_enable": 6944, "_lock": 6945, "_lock_bh": 6946, "_lock_irq": 6947, "_lock_irqsave": 6948, "_modlen": 6949, "_mutex_lock_nest_lock": 6950, "_name": 6951, "_nsig": 6952, "_nsig_words": 6953, "_p": 6954, "_param": 6955, "_perf_event_disable": 6956, "_perf_event_enable": 6957, "_perf_event_refresh": 6958, "_perf_event_reset": 6959, "_perf_ioctl": 6960, "_pick_next_task_rt": 6961, "_printk_braille_h": 6962, "_proc_do_string": 6963, "_qr_bias": 6964, "_qw_locked": 6965, "_qw_waiting": 6966, "_qw_wmask": 6967, "_raw_": 6968, "_raw_read_lock": 6969, "_raw_read_lock_bh": 6970, "_raw_read_lock_irq": 6971, "_raw_read_lock_irqsave": 6972, "_raw_read_trylock": 6973, "_raw_read_unlock": 6974, "_raw_read_unlock_bh": 6975, "_raw_read_unlock_irq": 6976, "_raw_read_unlock_irqrestore": 6977, "_raw_spin_lock": 6978, "_raw_spin_lock_bh": 6979, "_raw_spin_lock_bh_nested": 6980, "_raw_spin_lock_irq": 6981, "_raw_spin_lock_irqsave": 6982, "_raw_spin_lock_irqsave_nested": 6983, "_raw_spin_lock_nest_lock": 6984, "_raw_spin_lock_nested": 6985, "_raw_spin_trylock": 6986, "_raw_spin_trylock_bh": 6987, "_raw_spin_unlock": 6988, "_raw_spin_unlock_bh": 6989, "_raw_spin_unlock_irq": 6990, "_raw_spin_unlock_irqrestore": 6991, "_raw_write_lock": 6992, "_raw_write_lock_bh": 6993, "_raw_write_lock_irq": 6994, "_raw_write_lock_irqsave": 6995, "_raw_write_trylock": 6996, "_raw_write_unlock": 6997, "_raw_write_unlock_bh": 6998, "_raw_write_unlock_irq": 6999, "_raw_write_unlock_irqrestore": 7000, "_rcu_barrier": 7001, "_rcu_barrier_trace": 7002, "_read": 7003, "_relax": 7004, "_ret_ip_": 7005, "_sched_setscheduler": 7006, "_sdata": 7007, "_show": 7008, "_show_name": 7009, "_sinittext": 7010, "_size": 7011, "_state": 7012, "_stext": 7013, "_store": 7014, "_store_name": 7015, "_t": 7016, "_this_ip_": 7017, "_tick_sched_h": 7018, "_tif_need_resched": 7019, "_tif_polling_nrflag": 7020, "_timekeeping_internal_h": 7021, "_torture_create_kthread": 7022, "_torture_stop_kthread": 7023, "_trace_benchmark_h": 7024, "_trace_test_h": 7025, "_trylock": 7026, "_varname": 7027, "_verbose": 7028, "_x": 7029, "a": 7030, "a0": 7031, "a1": 7032, "a2": 7033, "a3": 7034, "a4": 7035, "a5": 7036, "a6": 7037, "a_ops": 7038, "a_preds": 7039, "ab": 7040, "abbr": 7041, "abi": 7042, "abort": 7043, "abort_creds": 7044, "abort_exclusive_wait": 7045, "abs": 7046, "abs_msec": 7047, "abs_timeout": 7048, "abs_ts": 7049, "abs_usec": 7050, "absexp": 7051, "abstime": 7052, "ac": 7053, "ac_ahz": 7054, "ac_btime": 7055, "ac_comm": 7056, "ac_etime": 7057, "ac_etime_hi": 7058, "ac_etime_lo": 7059, "ac_exitcode": 7060, "ac_flag": 7061, "ac_gid": 7062, "ac_gid16": 7063, "ac_majflt": 7064, "ac_mem": 7065, "ac_minflt": 7066, "ac_nice": 7067, "ac_pid": 7068, "ac_ppid": 7069, "ac_sched": 7070, "ac_stime": 7071, "ac_stimescaled": 7072, "ac_tty": 7073, "ac_uid": 7074, "ac_uid16": 7075, "ac_utime": 7076, "ac_utimescaled": 7077, "ac_version": 7078, "acc_mode": 7079, "accept": 7080, "accepts": 7081, "access": 7082, "access_lock": 7083, "access_ok": 7084, "access_once": 7085, "access_process_vm": 7086, "access_size": 7087, "account": 7088, "account_cfs_rq_runtime": 7089, "account_entity_dequeue": 7090, "account_entity_enqueue": 7091, "account_global_scheduler_latency": 7092, "account_group_exec_runtime": 7093, "account_group_system_time": 7094, "account_group_user_time": 7095, "account_guest_time": 7096, "account_idle_ticks": 7097, "account_idle_time": 7098, "account_irq_enter_time": 7099, "account_irq_exit_time": 7100, "account_kernel_stack": 7101, "account_numa_dequeue": 7102, "account_numa_enqueue": 7103, "account_process_tick": 7104, "account_scheduler_latency": 7105, "account_steal_ticks": 7106, "account_steal_time": 7107, "account_system_time": 7108, "account_user_time": 7109, "accounting": 7110, "acct": 7111, "acct_account_cputime": 7112, "acct_byteorder": 7113, "acct_clear_integrals": 7114, "acct_collect": 7115, "acct_exit_ns": 7116, "acct_get": 7117, "acct_on": 7118, "acct_on_mutex": 7119, "acct_parm": 7120, "acct_pin_kill": 7121, "acct_process": 7122, "acct_put": 7123, "acct_rss_mem1": 7124, "acct_t": 7125, "acct_timeout": 7126, "acct_timexpd": 7127, "acct_update_integrals": 7128, "acct_version": 7129, "acct_vm_mem1": 7130, "accumulate_nsecs_to_secs": 7131, "accumulate_thread_rusage": 7132, "ack": 7133, "ack_bad": 7134, "ack_bad_irq": 7135, "ack_state": 7136, "acore": 7137, "acpi_pm": 7138, "acpi_realmode_flags": 7139, "acquire": 7140, "acquire_ip": 7141, "acquired": 7142, "acquirelock": 7143, "across": 7144, "act": 7145, "act_log_check": 7146, "act_mask": 7147, "act_waiter": 7148, "action": 7149, "action_msg": 7150, "action_ptr": 7151, "action_ret": 7152, "actions": 7153, "activate": 7154, "activate_task": 7155, "active": 7156, "active_balance": 7157, "active_balance_work": 7158, "active_cpus": 7159, "active_ctx_list": 7160, "active_load_balance_cpu_stop": 7161, "active_mm": 7162, "active_nodes": 7163, "active_oncpu": 7164, "active_reqs": 7165, "active_timers": 7166, "active_uprobe": 7167, "active_writer": 7168, "actual_nr_irqs": 7169, "add": 7170, "add_del_listener": 7171, "add_dev": 7172, "add_event_to_ctx": 7173, "add_ftrace_list_ops": 7174, "add_ftrace_ops": 7175, "add_hash_entry": 7176, "add_if_not_found": 7177, "add_info": 7178, "add_interrupt_randomness": 7179, "add_kallsyms": 7180, "add_links": 7181, "add_lock_to_list": 7182, "add_module_usage": 7183, "add_new_kprobe": 7184, "add_node": 7185, "add_notes_attrs": 7186, "add_nr_running": 7187, "add_offset": 7188, "add_range": 7189, "add_range_with_merge": 7190, "add_rtree_block": 7191, "add_sect_attrs": 7192, "add_sysfs_param": 7193, "add_taint": 7194, "add_taint_module": 7195, "add_timer": 7196, "add_timer_on": 7197, "add_timestamp": 7198, "add_unformed_module": 7199, "add_usage_links": 7200, "add_wait_queue": 7201, "add_wait_queue_exclusive": 7202, "add_watch_to_parent": 7203, "added_mask": 7204, "addend": 7205, "adding": 7206, "addr": 7207, "addr_conflict": 7208, "address": 7209, "address_space": 7210, "adj": 7211, "adj_adjtime": 7212, "adj_esterror": 7213, "adj_frequency": 7214, "adj_maxerror": 7215, "adj_micro": 7216, "adj_nano": 7217, "adj_offset": 7218, "adj_offset_readonly": 7219, "adj_offset_singleshot": 7220, "adj_scale": 7221, "adj_setoffset": 7222, "adj_status": 7223, "adj_tai": 7224, "adj_tick": 7225, "adj_timeconst": 7226, "adjtimex": 7227, "adjust": 7228, "adjust_branches": 7229, "adjust_resource": 7230, "adjust_stack_addr": 7231, "adjustment": 7232, "af": 7233, "affine_sd": 7234, "affinity": 7235, "affinity_hint": 7236, "affinity_notify": 7237, "afork": 7238, "after": 7239, "after_dashes": 7240, "ag": 7241, "again": 7242, "age_stamp": 7243, "agentbuf": 7244, "aggr_break_handler": 7245, "aggr_fault_handler": 7246, "aggr_kprobe_disabled": 7247, "aggr_post_handler": 7248, "aggr_pre_handler": 7249, "ahz": 7250, "aiee": 7251, "ainsn": 7252, "aio_max_nr": 7253, "aio_nr": 7254, "al": 7255, "alarm": 7256, "alarm_base": 7257, "alarm_bases": 7258, "alarm_boottime": 7259, "alarm_cancel": 7260, "alarm_clock": 7261, "alarm_clock_get": 7262, "alarm_clock_getres": 7263, "alarm_expires_remaining": 7264, "alarm_forward": 7265, "alarm_forward_now": 7266, "alarm_handle_timer": 7267, "alarm_init": 7268, "alarm_numtype": 7269, "alarm_realtime": 7270, "alarm_restart": 7271, "alarm_setitimer": 7272, "alarm_start": 7273, "alarm_start_relative": 7274, "alarm_timer_create": 7275, "alarm_timer_del": 7276, "alarm_timer_get": 7277, "alarm_timer_nsleep": 7278, "alarm_timer_nsleep_restart": 7279, "alarm_timer_set": 7280, "alarm_try_to_cancel": 7281, "alarmtimer": 7282, "alarmtimer_dequeue": 7283, "alarmtimer_do_nsleep": 7284, "alarmtimer_driver": 7285, "alarmtimer_enqueue": 7286, "alarmtimer_fired": 7287, "alarmtimer_freezerset": 7288, "alarmtimer_get_rtcdev": 7289, "alarmtimer_init": 7290, "alarmtimer_norestart": 7291, "alarmtimer_nsleep_wakeup": 7292, "alarmtimer_pm_ops": 7293, "alarmtimer_restart": 7294, "alarmtimer_rtc_add_device": 7295, "alarmtimer_rtc_interface": 7296, "alarmtimer_rtc_interface_remove": 7297, "alarmtimer_rtc_interface_setup": 7298, "alarmtimer_rtc_timer_init": 7299, "alarmtimer_state_enqueued": 7300, "alarmtimer_state_inactive": 7301, "alarmtimer_suspend": 7302, "alarmtimer_type": 7303, "alb_count": 7304, "alb_failed": 7305, "alb_pushed": 7306, "algo": 7307, "align": 7308, "alignf": 7309, "alignf_data": 7310, "alignment": 7311, "all": 7312, "all_annotated_branch_stats": 7313, "all_branch_stat_headers": 7314, "all_branch_stat_next": 7315, "all_branch_stat_start": 7316, "all_branch_stats": 7317, "all_buf": 7318, "all_cpu_access_lock": 7319, "all_cpus_idle": 7320, "all_head": 7321, "all_lazy": 7322, "all_lock_classes": 7323, "all_ss": 7324, "all_stat_sessions": 7325, "all_stat_sessions_mutex": 7326, "all_timers": 7327, "all_var": 7328, "alloc": 7329, "alloc_aggr_kprobe": 7330, "alloc_and_copy_ftrace_hash": 7331, "alloc_and_link_pwqs": 7332, "alloc_bootmem_cpumask_var": 7333, "alloc_callchain_buffers": 7334, "alloc_chunk": 7335, "alloc_cpumask_var": 7336, "alloc_desc": 7337, "alloc_descs": 7338, "alloc_entry": 7339, "alloc_fair_sched_group": 7340, "alloc_frozen_cpus": 7341, "alloc_ftrace_hash": 7342, "alloc_highmem": 7343, "alloc_highmem_pages": 7344, "alloc_image_page": 7345, "alloc_insn_page": 7346, "alloc_kmem_pages_node": 7347, "alloc_large_system_hash": 7348, "alloc_list_entry": 7349, "alloc_lock": 7350, "alloc_masks": 7351, "alloc_normal": 7352, "alloc_ordered_workqueue": 7353, "alloc_page": 7354, "alloc_pages_exact": 7355, "alloc_pages_exact_node": 7356, "alloc_pages_node": 7357, "alloc_percpu": 7358, "alloc_percpu_gfp": 7359, "alloc_perf_context": 7360, "alloc_pid": 7361, "alloc_pidmap": 7362, "alloc_posix_timer": 7363, "alloc_resource": 7364, "alloc_retstack_tasklist": 7365, "alloc_rootdomain": 7366, "alloc_rt_sched_group": 7367, "alloc_rtree_node": 7368, "alloc_sched_domains": 7369, "alloc_snapshot": 7370, "alloc_state": 7371, "alloc_swapdev_block": 7372, "alloc_symbol_cache": 7373, "alloc_task_struct_node": 7374, "alloc_thread_info_node": 7375, "alloc_trace_kprobe": 7376, "alloc_trace_uprobe": 7377, "alloc_tree": 7378, "alloc_trial_cpuset": 7379, "alloc_uid": 7380, "alloc_unbound_pwq": 7381, "alloc_uprobe": 7382, "alloc_worker": 7383, "alloc_workqueue": 7384, "alloc_workqueue_attrs": 7385, "allocate": 7386, "allocate_cgrp_cset_links": 7387, "allocate_cmdlines_buffer": 7388, "allocate_ftrace_ops": 7389, "allocate_mm": 7390, "allocate_resource": 7391, "allocate_snapshot": 7392, "allocated": 7393, "allocated_irqs": 7394, "allocated_snapshot": 7395, "allocated_unsafe_pages": 7396, "allocates": 7397, "allocating": 7398, "allocation": 7399, "allow_changes": 7400, "allow_instances": 7401, "allow_nohz": 7402, "allow_signal": 7403, "allowed": 7404, "allowed_error_ns": 7405, "allowed_ns": 7406, "alm": 7407, "already": 7408, "already_enabled": 7409, "already_gone": 7410, "already_uses": 7411, "alter_cred_subscribers": 7412, "alu": 7413, "alu64_": 7414, "alu64_add_k": 7415, "alu64_add_x": 7416, "alu64_and_k": 7417, "alu64_and_x": 7418, "alu64_arsh_k": 7419, "alu64_arsh_x": 7420, "alu64_div_k": 7421, "alu64_div_x": 7422, "alu64_lsh_k": 7423, "alu64_lsh_x": 7424, "alu64_mod_k": 7425, "alu64_mod_x": 7426, "alu64_mov_k": 7427, "alu64_mov_x": 7428, "alu64_mul_k": 7429, "alu64_mul_x": 7430, "alu64_neg": 7431, "alu64_or_k": 7432, "alu64_or_x": 7433, "alu64_rsh_k": 7434, "alu64_rsh_x": 7435, "alu64_sub_k": 7436, "alu64_sub_x": 7437, "alu64_xor_k": 7438, "alu64_xor_x": 7439, "alu_": 7440, "alu_add_k": 7441, "alu_add_x": 7442, "alu_and_k": 7443, "alu_and_x": 7444, "alu_div_k": 7445, "alu_div_x": 7446, "alu_end_to_be": 7447, "alu_end_to_le": 7448, "alu_lsh_k": 7449, "alu_lsh_x": 7450, "alu_mod_k": 7451, "alu_mod_x": 7452, "alu_mov_k": 7453, "alu_mov_x": 7454, "alu_mul_k": 7455, "alu_mul_x": 7456, "alu_neg": 7457, "alu_or_k": 7458, "alu_or_x": 7459, "alu_rsh_k": 7460, "alu_rsh_x": 7461, "alu_sub_k": 7462, "alu_sub_x": 7463, "alu_xor_k": 7464, "alu_xor_x": 7465, "amagic": 7466, "amount": 7467, "amt": 7468, "an": 7469, "aname": 7470, "ancestor": 7471, "and": 7472, "annotated_branch_stat_cmp": 7473, "annotated_branch_stat_headers": 7474, "annotated_branch_stat_next": 7475, "annotated_branch_stat_start": 7476, "annotated_branch_stats": 7477, "anon_inode_getfd": 7478, "anon_vma_chain": 7479, "anon_vma_fork": 7480, "another": 7481, "any": 7482, "any_count": 7483, "ap": 7484, "apn": 7485, "append_elf_note": 7486, "append_filter_err": 7487, "append_filter_string": 7488, "append_operand_char": 7489, "apply_event_filter": 7490, "apply_relocate": 7491, "apply_relocate_add": 7492, "apply_relocations": 7493, "apply_slack": 7494, "apply_subsystem_event_filter": 7495, "apply_workqueue_attrs": 7496, "ar": 7497, "arch": 7498, "arch_": 7499, "arch_arm_kprobe": 7500, "arch_capacity": 7501, "arch_check_ftrace_location": 7502, "arch_check_optimized_kprobe": 7503, "arch_compat_alloc_user_space": 7504, "arch_cpu_idle": 7505, "arch_cpu_idle_dead": 7506, "arch_cpu_idle_enter": 7507, "arch_cpu_idle_exit": 7508, "arch_cpu_idle_prepare": 7509, "arch_deref_entry_point": 7510, "arch_disable_smp_support": 7511, "arch_disarm_kprobe": 7512, "arch_dup_mmap": 7513, "arch_dup_task_struct": 7514, "arch_dynirq_lower_bound": 7515, "arch_early_irq_init": 7516, "arch_enable_nonboot_cpus_begin": 7517, "arch_enable_nonboot_cpus_end": 7518, "arch_f": 7519, "arch_ftrace_trampoline_free": 7520, "arch_ftrace_update_code": 7521, "arch_ftrace_update_trampoline": 7522, "arch_gettimeoffset": 7523, "arch_has_block_step": 7524, "arch_has_single_step": 7525, "arch_has_syscall_match_sym_name": 7526, "arch_hibernation_header_restore": 7527, "arch_hibernation_header_save": 7528, "arch_initcall": 7529, "arch_irq_work_has_interrupt": 7530, "arch_irq_work_raise": 7531, "arch_jump_label_transform": 7532, "arch_jump_label_transform_static": 7533, "arch_kexec_apply_relocations": 7534, "arch_kexec_apply_relocations_add": 7535, "arch_kexec_kernel_image_load": 7536, "arch_kexec_kernel_image_probe": 7537, "arch_kexec_kernel_verify_sig": 7538, "arch_kgdb_breakpoint": 7539, "arch_kgdb_ops": 7540, "arch_kimage_file_post_load_cleanup": 7541, "arch_mcs_spin_lock_contended": 7542, "arch_mcs_spin_unlock_contended": 7543, "arch_min_mmstruct_align": 7544, "arch_min_taskalign": 7545, "arch_needs_cpu": 7546, "arch_perf_update_userpage": 7547, "arch_prepare_kprobe": 7548, "arch_prepare_kprobe_ftrace": 7549, "arch_prepare_kretprobe": 7550, "arch_prepare_optimized_kprobe": 7551, "arch_prepared_optinsn": 7552, "arch_probe_nr_irqs": 7553, "arch_ptrace_attach": 7554, "arch_ptrace_stop": 7555, "arch_ptrace_stop_needed": 7556, "arch_read_lock": 7557, "arch_read_relax": 7558, "arch_read_trylock": 7559, "arch_read_unlock": 7560, "arch_release_task_struct": 7561, "arch_release_thread_info": 7562, "arch_relocates_kcrctab": 7563, "arch_remove_kprobe": 7564, "arch_remove_optimized_kprobe": 7565, "arch_remove_reservations": 7566, "arch_rwlock_t": 7567, "arch_scale_cpu_capacity": 7568, "arch_scale_freq_capacity": 7569, "arch_send_call_function_ipi_mask": 7570, "arch_send_call_function_single_ipi": 7571, "arch_setup_hwirq": 7572, "arch_shf_small": 7573, "arch_show_interrupts": 7574, "arch_specific_insn": 7575, "arch_spin_is_locked": 7576, "arch_spin_lock": 7577, "arch_spin_relax": 7578, "arch_spin_trylock": 7579, "arch_spin_unlock": 7580, "arch_spinlock_t": 7581, "arch_start_context_switch": 7582, "arch_supports_ftrace_ops": 7583, "arch_syscall_match_sym_name": 7584, "arch_task_cache_init": 7585, "arch_teardown_hwirq": 7586, "arch_trace_ignore_compat_syscalls": 7587, "arch_trace_is_compat_syscall": 7588, "arch_unoptimize_kprobe": 7589, "arch_update_cpu_topology": 7590, "arch_uprobe": 7591, "arch_uprobe_abort_xol": 7592, "arch_uprobe_analyze_insn": 7593, "arch_uprobe_copy_ixol": 7594, "arch_uprobe_exception_notify": 7595, "arch_uprobe_ignore": 7596, "arch_uprobe_post_xol": 7597, "arch_uprobe_pre_xol": 7598, "arch_uprobe_skip_sstep": 7599, "arch_uprobe_xol_was_trapped": 7600, "arch_uretprobe_hijack_return_addr": 7601, "arch_vma_name": 7602, "arch_vtime_task_switch": 7603, "arch_within_kprobe_blacklist": 7604, "arch_write_lock": 7605, "arch_write_relax": 7606, "arch_write_trylock": 7607, "arch_write_unlock": 7608, "are": 7609, "area": 7610, "arg": 7611, "arg1": 7612, "arg1_type": 7613, "arg2": 7614, "arg2_type": 7615, "arg3": 7616, "arg3_type": 7617, "arg4": 7618, "arg4_type": 7619, "arg5": 7620, "arg5_type": 7621, "arg_anything": 7622, "arg_const_map_ptr": 7623, "arg_const_stack_size": 7624, "arg_dontcare": 7625, "arg_end": 7626, "arg_num": 7627, "arg_num_len": 7628, "arg_num_len_buf": 7629, "arg_ptr_to_ctx": 7630, "arg_ptr_to_map_key": 7631, "arg_ptr_to_map_value": 7632, "arg_ptr_to_stack": 7633, "arg_start": 7634, "arg_type": 7635, "argc": 7636, "argcount": 7637, "args": 7638, "args2": 7639, "argv": 7640, "argv_free": 7641, "argv_split": 7642, "arm_all_kprobes": 7643, "arm_kprobe": 7644, "arm_kprobe_ftrace": 7645, "arr": 7646, "array": 7647, "array_descriptor": 7648, "array_map_alloc": 7649, "array_map_delete_elem": 7650, "array_map_free": 7651, "array_map_get_next_key": 7652, "array_map_lookup_elem": 7653, "array_map_update_elem": 7654, "array_ops": 7655, "array_size": 7656, "array_type": 7657, "arrsize": 7658, "as": 7659, "asked": 7660, "asm": 7661, "asmlinkage": 7662, "assert_raw_spin_locked": 7663, "assert_rcu_or_pool_mutex": 7664, "assert_rcu_or_wq_mutex": 7665, "assert_spin_locked": 7666, "assign": 7667, "assign_cfs_rq_runtime": 7668, "assign_fetch_func": 7669, "assign_fetch_type": 7670, "assign_fetch_type_end": 7671, "assign_ops_hash": 7672, "assuming": 7673, "asu": 7674, "async_cookie_max": 7675, "async_cookie_t": 7676, "async_dfl_domain": 7677, "async_domain": 7678, "async_done": 7679, "async_entry": 7680, "async_func_t": 7681, "async_global_pending": 7682, "async_lock": 7683, "async_run_entry_fn": 7684, "async_schedule": 7685, "async_schedule_domain": 7686, "async_synchronize_cookie": 7687, "async_synchronize_cookie_domain": 7688, "async_synchronize_full": 7689, "async_synchronize_full_domain": 7690, "async_unregister_domain": 7691, "at": 7692, "at_null": 7693, "at_vector_size": 7694, "atomic64_add": 7695, "atomic64_read": 7696, "atomic64_set": 7697, "atomic64_t": 7698, "atomic_add": 7699, "atomic_add_return": 7700, "atomic_add_unless": 7701, "atomic_cmpxchg": 7702, "atomic_dec": 7703, "atomic_dec_and_lock": 7704, "atomic_dec_and_mutex_lock": 7705, "atomic_dec_and_test": 7706, "atomic_dec_if_positive": 7707, "atomic_dec_return": 7708, "atomic_dec_unless_positive": 7709, "atomic_inc": 7710, "atomic_inc_not_zero": 7711, "atomic_inc_return": 7712, "atomic_inc_unless_negative": 7713, "atomic_init": 7714, "atomic_long_add": 7715, "atomic_long_cmpxchg": 7716, "atomic_long_dec_and_test": 7717, "atomic_long_inc": 7718, "atomic_long_inc_not_zero": 7719, "atomic_long_inc_return": 7720, "atomic_long_read": 7721, "atomic_long_set": 7722, "atomic_long_sub": 7723, "atomic_long_t": 7724, "atomic_long_xchg": 7725, "atomic_notifier_call_chain": 7726, "atomic_notifier_chain_register": 7727, "atomic_notifier_chain_unregister": 7728, "atomic_notifier_head": 7729, "atomic_read": 7730, "atomic_set": 7731, "atomic_sub": 7732, "atomic_sub_return": 7733, "atomic_t": 7734, "atomic_t_waitqueue": 7735, "atomic_write_len": 7736, "atomic_xchg": 7737, "attach": 7738, "attach_in_progress": 7739, "attach_mutex": 7740, "attach_one_task": 7741, "attach_pid": 7742, "attach_state": 7743, "attach_task": 7744, "attach_tasks": 7745, "attempt": 7746, "attempted": 7747, "attr": 7748, "attr2pentry": 7749, "attr_gid": 7750, "attr_uid": 7751, "attribute": 7752, "attribute_group": 7753, "attributes": 7754, "attrs": 7755, "audit_add": 7756, "audit_add_rule": 7757, "audit_add_to_parent": 7758, "audit_add_tree_rule": 7759, "audit_add_watch": 7760, "audit_alloc": 7761, "audit_alloc_context": 7762, "audit_alloc_name": 7763, "audit_always": 7764, "audit_anom_abend": 7765, "audit_anom_link": 7766, "audit_arch": 7767, "audit_arg0": 7768, "audit_arg1": 7769, "audit_arg2": 7770, "audit_arg3": 7771, "audit_aux_data": 7772, "audit_aux_data_bprm_fcaps": 7773, "audit_aux_data_pids": 7774, "audit_aux_ipcperm": 7775, "audit_aux_pids": 7776, "audit_backlog_limit": 7777, "audit_backlog_wait": 7778, "audit_backlog_wait_overflow": 7779, "audit_backlog_wait_time": 7780, "audit_backlog_wait_time_master": 7781, "audit_bad": 7782, "audit_bind": 7783, "audit_bit": 7784, "audit_bit_mask": 7785, "audit_bit_test": 7786, "audit_bitmask": 7787, "audit_bitmask_size": 7788, "audit_bittest": 7789, "audit_bprm_fcaps": 7790, "audit_buffer": 7791, "audit_buffer_alloc": 7792, "audit_buffer_free": 7793, "audit_bufsiz": 7794, "audit_build_context": 7795, "audit_cap_data": 7796, "audit_capset": 7797, "audit_chunk": 7798, "audit_class_chattr": 7799, "audit_class_chattr_32": 7800, "audit_class_read": 7801, "audit_class_read_32": 7802, "audit_class_signal": 7803, "audit_class_signal_32": 7804, "audit_class_write": 7805, "audit_class_write_32": 7806, "audit_classify_arch": 7807, "audit_classify_syscall": 7808, "audit_cmd_mutex": 7809, "audit_comparator": 7810, "audit_compare_auid_to_euid": 7811, "audit_compare_auid_to_fsuid": 7812, "audit_compare_auid_to_obj_uid": 7813, "audit_compare_auid_to_suid": 7814, "audit_compare_dname_path": 7815, "audit_compare_egid_to_fsgid": 7816, "audit_compare_egid_to_obj_gid": 7817, "audit_compare_egid_to_sgid": 7818, "audit_compare_euid_to_fsuid": 7819, "audit_compare_euid_to_obj_uid": 7820, "audit_compare_euid_to_suid": 7821, "audit_compare_fsgid_to_obj_gid": 7822, "audit_compare_fsuid_to_obj_uid": 7823, "audit_compare_gid": 7824, "audit_compare_gid_to_egid": 7825, "audit_compare_gid_to_fsgid": 7826, "audit_compare_gid_to_obj_gid": 7827, "audit_compare_gid_to_sgid": 7828, "audit_compare_rule": 7829, "audit_compare_sgid_to_fsgid": 7830, "audit_compare_sgid_to_obj_gid": 7831, "audit_compare_suid_to_fsuid": 7832, "audit_compare_suid_to_obj_uid": 7833, "audit_compare_uid": 7834, "audit_compare_uid_to_auid": 7835, "audit_compare_uid_to_euid": 7836, "audit_compare_uid_to_fsuid": 7837, "audit_compare_uid_to_obj_uid": 7838, "audit_compare_uid_to_suid": 7839, "audit_config_change": 7840, "audit_context": 7841, "audit_copy_fcaps": 7842, "audit_copy_inode": 7843, "audit_core_dumps": 7844, "audit_cwd": 7845, "audit_data_to_entry": 7846, "audit_default": 7847, "audit_del": 7848, "audit_del_rule": 7849, "audit_devmajor": 7850, "audit_devminor": 7851, "audit_dir": 7852, "audit_disabled": 7853, "audit_do_config_change": 7854, "audit_dummy_context": 7855, "audit_dupe_lsm_field": 7856, "audit_dupe_rule": 7857, "audit_dupe_watch": 7858, "audit_egid": 7859, "audit_enabled": 7860, "audit_entry": 7861, "audit_eoe": 7862, "audit_equal": 7863, "audit_euid": 7864, "audit_ever_enabled": 7865, "audit_execve": 7866, "audit_exit": 7867, "audit_expand": 7868, "audit_fail_panic": 7869, "audit_fail_printk": 7870, "audit_fail_silent": 7871, "audit_failure": 7872, "audit_fd_pair": 7873, "audit_feature_bitmap_all": 7874, "audit_feature_change": 7875, "audit_feature_loginuid_immutable": 7876, "audit_feature_names": 7877, "audit_feature_only_unset_loginuid": 7878, "audit_feature_to_mask": 7879, "audit_feature_version": 7880, "audit_features": 7881, "audit_field": 7882, "audit_field_compare": 7883, "audit_field_valid": 7884, "audit_filetype": 7885, "audit_filter_entry": 7886, "audit_filter_exit": 7887, "audit_filter_inode_name": 7888, "audit_filter_inodes": 7889, "audit_filter_list": 7890, "audit_filter_mutex": 7891, "audit_filter_prepend": 7892, "audit_filter_rules": 7893, "audit_filter_syscall": 7894, "audit_filter_task": 7895, "audit_filter_type": 7896, "audit_filter_user": 7897, "audit_filter_user_rules": 7898, "audit_filterkey": 7899, "audit_find_parent": 7900, "audit_find_rule": 7901, "audit_first_user_msg": 7902, "audit_first_user_msg2": 7903, "audit_free": 7904, "audit_free_aux": 7905, "audit_free_context": 7906, "audit_free_lsm_field": 7907, "audit_free_names": 7908, "audit_free_parent": 7909, "audit_free_rule": 7910, "audit_free_rule_rcu": 7911, "audit_freelist": 7912, "audit_freelist_count": 7913, "audit_freelist_lock": 7914, "audit_fs_watch": 7915, "audit_fsgid": 7916, "audit_fsuid": 7917, "audit_ge": 7918, "audit_get": 7919, "audit_get_feature": 7920, "audit_get_loginuid": 7921, "audit_get_nd": 7922, "audit_get_parent": 7923, "audit_get_sessionid": 7924, "audit_get_stamp": 7925, "audit_get_watch": 7926, "audit_gid": 7927, "audit_gid_comparator": 7928, "audit_greater_than": 7929, "audit_greater_than_or_equal": 7930, "audit_gt": 7931, "audit_hash_ino": 7932, "audit_hold_skb": 7933, "audit_in_mask": 7934, "audit_init": 7935, "audit_init_entry": 7936, "audit_init_parent": 7937, "audit_init_watch": 7938, "audit_initialized": 7939, "audit_inode": 7940, "audit_inode_buckets": 7941, "audit_inode_hash": 7942, "audit_inode_hidden": 7943, "audit_inode_parent": 7944, "audit_ipc": 7945, "audit_ipc_set_perm": 7946, "audit_kernel": 7947, "audit_kill_trees": 7948, "audit_killed_trees": 7949, "audit_krule": 7950, "audit_krule_to_data": 7951, "audit_last_feature": 7952, "audit_last_user_msg": 7953, "audit_last_user_msg2": 7954, "audit_launch_prune": 7955, "audit_le": 7956, "audit_less_than": 7957, "audit_less_than_or_equal": 7958, "audit_list": 7959, "audit_list_rules": 7960, "audit_list_rules_send": 7961, "audit_locked": 7962, "audit_log": 7963, "audit_log_cap": 7964, "audit_log_common_recv_msg": 7965, "audit_log_config_change": 7966, "audit_log_d_path": 7967, "audit_log_d_path_exe": 7968, "audit_log_end": 7969, "audit_log_execve_info": 7970, "audit_log_exit": 7971, "audit_log_fcaps": 7972, "audit_log_feature_change": 7973, "audit_log_format": 7974, "audit_log_key": 7975, "audit_log_link_denied": 7976, "audit_log_lost": 7977, "audit_log_n_hex": 7978, "audit_log_n_string": 7979, "audit_log_n_untrustedstring": 7980, "audit_log_name": 7981, "audit_log_pid_context": 7982, "audit_log_proctitle": 7983, "audit_log_rule_change": 7984, "audit_log_secctx": 7985, "audit_log_session_info": 7986, "audit_log_set_loginuid": 7987, "audit_log_single_execve_arg": 7988, "audit_log_start": 7989, "audit_log_string": 7990, "audit_log_task": 7991, "audit_log_task_context": 7992, "audit_log_task_info": 7993, "audit_log_untrustedstring": 7994, "audit_log_vformat": 7995, "audit_login": 7996, "audit_loginuid": 7997, "audit_loginuid_legacy": 7998, "audit_loginuid_set": 7999, "audit_lost": 8000, "audit_lt": 8001, "audit_make_equiv": 8002, "audit_make_reply": 8003, "audit_make_tree": 8004, "audit_match_class": 8005, "audit_match_class_bits": 8006, "audit_match_filetype": 8007, "audit_match_perm": 8008, "audit_match_signal": 8009, "audit_max_field_compare": 8010, "audit_max_fields": 8011, "audit_max_key_len": 8012, "audit_maxfree": 8013, "audit_mmap": 8014, "audit_mq_getsetattr": 8015, "audit_mq_notify": 8016, "audit_mq_open": 8017, "audit_mq_sendrecv": 8018, "audit_msgtype": 8019, "audit_n_rules": 8020, "audit_name_full": 8021, "audit_names": 8022, "audit_net": 8023, "audit_net_exit": 8024, "audit_net_id": 8025, "audit_net_init": 8026, "audit_net_ops": 8027, "audit_netlink_list": 8028, "audit_netlink_ok": 8029, "audit_never": 8030, "audit_nlgrp_max": 8031, "audit_nlgrp_readlog": 8032, "audit_nlk_portid": 8033, "audit_not_equal": 8034, "audit_nr_filters": 8035, "audit_obj_gid": 8036, "audit_obj_lev_high": 8037, "audit_obj_lev_low": 8038, "audit_obj_pid": 8039, "audit_obj_role": 8040, "audit_obj_type": 8041, "audit_obj_uid": 8042, "audit_obj_user": 8043, "audit_off": 8044, "audit_on": 8045, "audit_ops": 8046, "audit_pack_string": 8047, "audit_panic": 8048, "audit_parent": 8049, "audit_path": 8050, "audit_perm": 8051, "audit_perm_attr": 8052, "audit_perm_exec": 8053, "audit_perm_read": 8054, "audit_perm_write": 8055, "audit_pers": 8056, "audit_pid": 8057, "audit_possible": 8058, "audit_ppid": 8059, "audit_printk_skb": 8060, "audit_proctitle": 8061, "audit_proctitle_free": 8062, "audit_proctitle_rtrim": 8063, "audit_put_chunk": 8064, "audit_put_parent": 8065, "audit_put_tree": 8066, "audit_put_watch": 8067, "audit_rate_check": 8068, "audit_rate_limit": 8069, "audit_receive": 8070, "audit_receive_msg": 8071, "audit_receive_skb": 8072, "audit_record_context": 8073, "audit_register_class": 8074, "audit_remove_parent_watches": 8075, "audit_remove_tree_rule": 8076, "audit_remove_watch": 8077, "audit_remove_watch_rule": 8078, "audit_reply": 8079, "audit_rule_change": 8080, "audit_rule_data": 8081, "audit_rules_list": 8082, "audit_schedule_prune": 8083, "audit_seccomp": 8084, "audit_send_list": 8085, "audit_send_reply": 8086, "audit_send_reply_thread": 8087, "audit_serial": 8088, "audit_set": 8089, "audit_set_auditable": 8090, "audit_set_backlog_limit": 8091, "audit_set_backlog_wait_time": 8092, "audit_set_enabled": 8093, "audit_set_failure": 8094, "audit_set_feature": 8095, "audit_set_loginuid": 8096, "audit_set_loginuid_perm": 8097, "audit_set_portid": 8098, "audit_set_rate_limit": 8099, "audit_sgid": 8100, "audit_sig_info": 8101, "audit_sig_pid": 8102, "audit_sig_sid": 8103, "audit_sig_uid": 8104, "audit_signal_info": 8105, "audit_signals": 8106, "audit_skb_hold_queue": 8107, "audit_skb_queue": 8108, "audit_sock": 8109, "audit_sockaddr": 8110, "audit_socketcall": 8111, "audit_state": 8112, "audit_status": 8113, "audit_status_enabled": 8114, "audit_status_rate_limit": 8115, "audit_string_contains_control": 8116, "audit_subj_clr": 8117, "audit_subj_role": 8118, "audit_subj_sen": 8119, "audit_subj_type": 8120, "audit_subj_user": 8121, "audit_success": 8122, "audit_suid": 8123, "audit_syscall": 8124, "audit_syscall_classes": 8125, "audit_tag_tree": 8126, "audit_take_context": 8127, "audit_to_entry_common": 8128, "audit_to_inode": 8129, "audit_to_op": 8130, "audit_to_watch": 8131, "audit_tree": 8132, "audit_tree_destroy_watch": 8133, "audit_tree_freeing_mark": 8134, "audit_tree_group": 8135, "audit_tree_handle_event": 8136, "audit_tree_log_remove_rule": 8137, "audit_tree_lookup": 8138, "audit_tree_match": 8139, "audit_tree_path": 8140, "audit_tree_refs": 8141, "audit_trim": 8142, "audit_trim_trees": 8143, "audit_tty": 8144, "audit_tty_get": 8145, "audit_tty_log_passwd": 8146, "audit_tty_set": 8147, "audit_tty_status": 8148, "audit_type_child_create": 8149, "audit_type_child_delete": 8150, "audit_type_normal": 8151, "audit_type_parent": 8152, "audit_type_unknown": 8153, "audit_uid": 8154, "audit_uid_comparator": 8155, "audit_uid_unset": 8156, "audit_uninitialized": 8157, "audit_unpack_string": 8158, "audit_update_lsm_rules": 8159, "audit_update_watch": 8160, "audit_user": 8161, "audit_user_avc": 8162, "audit_watch": 8163, "audit_watch_compare": 8164, "audit_watch_free_mark": 8165, "audit_watch_fsnotify_ops": 8166, "audit_watch_group": 8167, "audit_watch_handle_event": 8168, "audit_watch_init": 8169, "audit_watch_log_rule_change": 8170, "audit_watch_path": 8171, "audit_word": 8172, "auditsc_args": 8173, "auditsc_failure": 8174, "auditsc_get_stamp": 8175, "auditsc_invalid": 8176, "auditsc_success": 8177, "auid": 8178, "aunet": 8179, "aup": 8180, "autogroup": 8181, "autogroup_create": 8182, "autogroup_default": 8183, "autogroup_destroy": 8184, "autogroup_free": 8185, "autogroup_init": 8186, "autogroup_kref_get": 8187, "autogroup_kref_put": 8188, "autogroup_move_group": 8189, "autogroup_path": 8190, "autogroup_seq_nr": 8191, "autogroup_task_get": 8192, "autogroup_task_group": 8193, "autoreap": 8194, "autoremove_wake_function": 8195, "autosleep_lock": 8196, "autosleep_show": 8197, "autosleep_state": 8198, "autosleep_wq": 8199, "autosleep_ws": 8200, "aux": 8201, "aux_head": 8202, "aux_mmap_count": 8203, "aux_mmap_locked": 8204, "aux_nest": 8205, "aux_nr_pages": 8206, "aux_offset": 8207, "aux_overwrite": 8208, "aux_pages": 8209, "aux_pgoff": 8210, "aux_pids": 8211, "aux_priv": 8212, "aux_refcount": 8213, "aux_size": 8214, "aux_tail": 8215, "aux_unlock": 8216, "aux_wakeup": 8217, "aux_watermark": 8218, "auxv": 8219, "auxv_size": 8220, "avail": 8221, "avail_normal": 8222, "available": 8223, "available_filter_functions": 8224, "available_tracers": 8225, "avenrun": 8226, "avg": 8227, "avg_atom": 8228, "avg_idle": 8229, "avg_load": 8230, "avg_local_sample_len": 8231, "avg_per_cpu": 8232, "avg_period": 8233, "ax": 8234, "axp": 8235, "axs": 8236, "axsig": 8237, "az": 8238, "b": 8239, "bacct": 8240, "bacct_add_tsk": 8241, "back": 8242, "backlog": 8243, "backlog_limit": 8244, "backlog_wait_time": 8245, "backtrace": 8246, "backtrace_regression_test": 8247, "backtrace_tasklet": 8248, "backtrace_test_irq": 8249, "backtrace_test_irq_callback": 8250, "backtrace_test_normal": 8251, "backtrace_test_saved": 8252, "backtrace_work": 8253, "bad": 8254, "bad_action_ret": 8255, "bad_bit": 8256, "bad_fork_cleanup_audit": 8257, "bad_fork_cleanup_count": 8258, "bad_fork_cleanup_files": 8259, "bad_fork_cleanup_fs": 8260, "bad_fork_cleanup_io": 8261, "bad_fork_cleanup_mm": 8262, "bad_fork_cleanup_namespaces": 8263, "bad_fork_cleanup_perf": 8264, "bad_fork_cleanup_policy": 8265, "bad_fork_cleanup_semundo": 8266, "bad_fork_cleanup_sighand": 8267, "bad_fork_cleanup_signal": 8268, "bad_fork_cleanup_threadgroup_lock": 8269, "bad_fork_free": 8270, "bad_fork_free_pid": 8271, "bad_unshare_cleanup_cred": 8272, "bad_unshare_cleanup_fd": 8273, "bad_unshare_cleanup_fs": 8274, "bad_unshare_out": 8275, "bad_version": 8276, "balance": 8277, "balance_cpu": 8278, "balance_flag_changed": 8279, "balance_interval": 8280, "balance_runtime": 8281, "balanced": 8282, "balancing": 8283, "barr": 8284, "barrier": 8285, "barrier_cbs_count": 8286, "barrier_cbs_invoked": 8287, "barrier_cbs_tasks": 8288, "barrier_cbs_wq": 8289, "barrier_completion": 8290, "barrier_cpu_count": 8291, "barrier_head": 8292, "barrier_mutex": 8293, "barrier_phase": 8294, "barrier_task": 8295, "barrier_wq": 8296, "base": 8297, "base_addr": 8298, "base_clockid": 8299, "base_files": 8300, "baseid": 8301, "basename": 8302, "batch_check0": 8303, "batch_check1": 8304, "batch_count": 8305, "batch_done": 8306, "batch_queue": 8307, "batchsummary": 8308, "bc": 8309, "bc_handler": 8310, "bc_moved": 8311, "bc_set_mode": 8312, "bc_set_next": 8313, "bc_stopped": 8314, "bctimer": 8315, "bd_dev": 8316, "bd_disk": 8317, "bd_mutex": 8318, "bd_part": 8319, "bdev": 8320, "bdev_get_queue": 8321, "bdevname": 8322, "bdevname_size": 8323, "bdget": 8324, "bdput": 8325, "be": 8326, "be32_to_cpu": 8327, "be64_to_cpu": 8328, "became": 8329, "because": 8330, "beenhere": 8331, "beenonline": 8332, "before": 8333, "begin": 8334, "begin_pfn": 8335, "being": 8336, "benchmark": 8337, "benchmark_event": 8338, "benchmark_event_strlen": 8339, "best": 8340, "best_cpu": 8341, "best_imp": 8342, "best_task": 8343, "bestprev": 8344, "between": 8345, "bf": 8346, "bfs": 8347, "bi_bdev": 8348, "bi_end_io": 8349, "bi_io_vec": 8350, "bi_iter": 8351, "bi_private": 8352, "bi_rw": 8353, "bi_sector": 8354, "bi_size": 8355, "big_event_size": 8356, "bin": 8357, "bin_attr": 8358, "bin_attribute": 8359, "bin_bus_isa_table": 8360, "bin_bus_table": 8361, "bin_convert_t": 8362, "bin_dev_table": 8363, "bin_dir": 8364, "bin_dn_node_address": 8365, "bin_fs_ocfs2_nm_table": 8366, "bin_fs_ocfs2_table": 8367, "bin_fs_quota_table": 8368, "bin_fs_table": 8369, "bin_fs_xfs_table": 8370, "bin_inotify_table": 8371, "bin_intvec": 8372, "bin_ipmi_table": 8373, "bin_kern_table": 8374, "bin_mac_hid_files": 8375, "bin_net_atalk_table": 8376, "bin_net_ax25_param_table": 8377, "bin_net_ax25_table": 8378, "bin_net_core_table": 8379, "bin_net_decnet_conf": 8380, "bin_net_decnet_conf_vars": 8381, "bin_net_decnet_table": 8382, "bin_net_ipv4_conf_table": 8383, "bin_net_ipv4_conf_vars_table": 8384, "bin_net_ipv4_netfilter_table": 8385, "bin_net_ipv4_route_table": 8386, "bin_net_ipv4_table": 8387, "bin_net_ipv6_conf_table": 8388, "bin_net_ipv6_conf_var_table": 8389, "bin_net_ipv6_icmp_table": 8390, "bin_net_ipv6_route_table": 8391, "bin_net_ipv6_table": 8392, "bin_net_ipx_table": 8393, "bin_net_irda_table": 8394, "bin_net_llc_llc2_table": 8395, "bin_net_llc_llc2_timeout_table": 8396, "bin_net_llc_station_table": 8397, "bin_net_llc_table": 8398, "bin_net_neigh_table": 8399, "bin_net_neigh_vars_table": 8400, "bin_net_netfilter_table": 8401, "bin_net_netrom_table": 8402, "bin_net_rose_table": 8403, "bin_net_sctp_table": 8404, "bin_net_table": 8405, "bin_net_tr_table": 8406, "bin_net_unix_table": 8407, "bin_net_x25_table": 8408, "bin_pm_table": 8409, "bin_pty_table": 8410, "bin_raid_table": 8411, "bin_random_table": 8412, "bin_root_table": 8413, "bin_s390dbf_table": 8414, "bin_scsi_table": 8415, "bin_string": 8416, "bin_sunrpc_table": 8417, "bin_table": 8418, "bin_ulongvec": 8419, "bin_uuid": 8420, "bin_vm_table": 8421, "binary": 8422, "binary_sysctl": 8423, "bind": 8424, "binfmt": 8425, "binfmt_misc_table": 8426, "bio": 8427, "bio_add_page": 8428, "bio_alloc": 8429, "bio_chain": 8430, "bio_flagged": 8431, "bio_put": 8432, "bio_rw": 8433, "bio_uptodate": 8434, "bit": 8435, "bit_a": 8436, "bit_b": 8437, "bit_backwards": 8438, "bit_forwards": 8439, "bit_nr": 8440, "bit_wait": 8441, "bit_wait_io": 8442, "bit_wait_io_timeout": 8443, "bit_wait_timeout": 8444, "bit_waitqueue": 8445, "bitcount": 8446, "bitfield": 8447, "bitfield_fetch_param": 8448, "bitmap": 8449, "bitmap_clear": 8450, "bitmap_copy": 8451, "bitmap_empty": 8452, "bitmap_find_next_zero_area": 8453, "bitmap_len": 8454, "bitmap_or": 8455, "bitmap_set": 8456, "bitmap_size": 8457, "bitmask_ptr": 8458, "bitmask_size": 8459, "bits": 8460, "bits_per_byte": 8461, "bits_per_compat_long": 8462, "bits_per_long": 8463, "bits_per_page": 8464, "bits_per_page_mask": 8465, "bits_to_compat_longs": 8466, "bits_to_longs": 8467, "bkt": 8468, "bl": 8469, "blimit": 8470, "blk_add_driver_data": 8471, "blk_add_trace_bio": 8472, "blk_add_trace_bio_backmerge": 8473, "blk_add_trace_bio_bounce": 8474, "blk_add_trace_bio_complete": 8475, "blk_add_trace_bio_frontmerge": 8476, "blk_add_trace_bio_queue": 8477, "blk_add_trace_bio_remap": 8478, "blk_add_trace_getrq": 8479, "blk_add_trace_plug": 8480, "blk_add_trace_rq": 8481, "blk_add_trace_rq_abort": 8482, "blk_add_trace_rq_complete": 8483, "blk_add_trace_rq_insert": 8484, "blk_add_trace_rq_issue": 8485, "blk_add_trace_rq_remap": 8486, "blk_add_trace_rq_requeue": 8487, "blk_add_trace_sleeprq": 8488, "blk_add_trace_split": 8489, "blk_add_trace_unplug": 8490, "blk_classic": 8491, "blk_create_buf_file_callback": 8492, "blk_dropped_fops": 8493, "blk_dropped_read": 8494, "blk_dump_cmd": 8495, "blk_flush_plug": 8496, "blk_io_trace": 8497, "blk_io_trace_magic": 8498, "blk_io_trace_remap": 8499, "blk_io_trace_version": 8500, "blk_log_action": 8501, "blk_log_action_classic": 8502, "blk_log_action_t": 8503, "blk_log_dump_pdu": 8504, "blk_log_generic": 8505, "blk_log_msg": 8506, "blk_log_plug": 8507, "blk_log_remap": 8508, "blk_log_split": 8509, "blk_log_unplug": 8510, "blk_log_with_error": 8511, "blk_msg_fops": 8512, "blk_msg_write": 8513, "blk_needs_flush_plug": 8514, "blk_probes_ref": 8515, "blk_register_tracepoints": 8516, "blk_relay_callbacks": 8517, "blk_remove_buf_file_callback": 8518, "blk_rq_bytes": 8519, "blk_rq_pos": 8520, "blk_schedule_flush_plug": 8521, "blk_subbuf_start_callback": 8522, "blk_ta_abort": 8523, "blk_ta_backmerge": 8524, "blk_ta_bounce": 8525, "blk_ta_complete": 8526, "blk_ta_drv_data": 8527, "blk_ta_frontmerge": 8528, "blk_ta_getrq": 8529, "blk_ta_insert": 8530, "blk_ta_issue": 8531, "blk_ta_plug": 8532, "blk_ta_queue": 8533, "blk_ta_remap": 8534, "blk_ta_requeue": 8535, "blk_ta_sleeprq": 8536, "blk_ta_split": 8537, "blk_ta_unplug_io": 8538, "blk_ta_unplug_timer": 8539, "blk_tc_act": 8540, "blk_tc_ahead": 8541, "blk_tc_complete": 8542, "blk_tc_discard": 8543, "blk_tc_drv_data": 8544, "blk_tc_flush": 8545, "blk_tc_fs": 8546, "blk_tc_fua": 8547, "blk_tc_issue": 8548, "blk_tc_meta": 8549, "blk_tc_notify": 8550, "blk_tc_pc": 8551, "blk_tc_queue": 8552, "blk_tc_rahead": 8553, "blk_tc_read": 8554, "blk_tc_requeue": 8555, "blk_tc_shift": 8556, "blk_tc_sync": 8557, "blk_tc_write": 8558, "blk_tn_max_msg": 8559, "blk_tn_message": 8560, "blk_tn_process": 8561, "blk_tn_timestamp": 8562, "blk_tr": 8563, "blk_trace": 8564, "blk_trace_attr_group": 8565, "blk_trace_attrs": 8566, "blk_trace_cleanup": 8567, "blk_trace_device_attr": 8568, "blk_trace_event_print": 8569, "blk_trace_event_print_binary": 8570, "blk_trace_free": 8571, "blk_trace_get_queue": 8572, "blk_trace_init_sysfs": 8573, "blk_trace_ioctl": 8574, "blk_trace_mask2str": 8575, "blk_trace_remove": 8576, "blk_trace_remove_queue": 8577, "blk_trace_remove_sysfs": 8578, "blk_trace_setup": 8579, "blk_trace_setup_lba": 8580, "blk_trace_setup_queue": 8581, "blk_trace_shutdown": 8582, "blk_trace_startstop": 8583, "blk_trace_str2mask": 8584, "blk_trace_synthesize_old_trace": 8585, "blk_tracer": 8586, "blk_tracer_enabled": 8587, "blk_tracer_flags": 8588, "blk_tracer_init": 8589, "blk_tracer_opts": 8590, "blk_tracer_print_header": 8591, "blk_tracer_print_line": 8592, "blk_tracer_reset": 8593, "blk_tracer_set_flag": 8594, "blk_tracer_start": 8595, "blk_tracer_stop": 8596, "blk_tree_mutex": 8597, "blk_tree_root": 8598, "blk_unregister_tracepoints": 8599, "blk_user_trace_setup": 8600, "blkd_tasks": 8601, "blkdev_get_by_dev": 8602, "blkdev_put": 8603, "blkio_count": 8604, "blkio_delay": 8605, "blkio_delay_total": 8606, "blkio_start": 8607, "blktrace_bdev_size": 8608, "blktrace_running": 8609, "blktrace_seq": 8610, "blktrace_setup": 8611, "blktrace_stopped": 8612, "blktracesetup": 8613, "blktracesetup32": 8614, "blktracestart": 8615, "blktracestop": 8616, "blktraceteardown": 8617, "block": 8618, "block_all_signals": 8619, "block_device": 8620, "block_dump": 8621, "block_max": 8622, "block_nr": 8623, "block_start": 8624, "block_unplug": 8625, "blocked": 8626, "blocked_load_avg": 8627, "blocked_on": 8628, "blocking_init_notifier_head": 8629, "blocking_notifier_call_chain": 8630, "blocking_notifier_chain_cond_register": 8631, "blocking_notifier_chain_register": 8632, "blocking_notifier_chain_unregister": 8633, "blocking_notifier_head": 8634, "blocks": 8635, "bm": 8636, "bm1": 8637, "bm2": 8638, "bm_avg": 8639, "bm_bits_per_block": 8640, "bm_block_mask": 8641, "bm_block_shift": 8642, "bm_cnt": 8643, "bm_end_of_map": 8644, "bm_entries_per_level": 8645, "bm_event_thread": 8646, "bm_first": 8647, "bm_last": 8648, "bm_max": 8649, "bm_min": 8650, "bm_rtree_level_mask": 8651, "bm_rtree_level_shift": 8652, "bm_std": 8653, "bm_stddev": 8654, "bm_str": 8655, "bm_total": 8656, "bm_totalsq": 8657, "bmagic": 8658, "bo": 8659, "body": 8660, "bool": 8661, "boolkp": 8662, "boolval": 8663, "boost": 8664, "boost_kthread_status": 8665, "boost_kthread_task": 8666, "boost_mtx": 8667, "boost_mutex": 8668, "boost_starttime": 8669, "boost_tasks": 8670, "boost_time": 8671, "boot": 8672, "boot_acpi": 8673, "boot_alloc_snapshot": 8674, "boot_cpu": 8675, "boot_delay": 8676, "boot_init_stack_canary": 8677, "boot_tvec_bases": 8678, "bootconsole": 8679, "bootloader_type": 8680, "bootloader_version": 8681, "bootmem_resource_free": 8682, "bootmem_resource_lock": 8683, "bootup": 8684, "bootup_event_buf": 8685, "bootup_tracer_buf": 8686, "bounce_acquired": 8687, "bounce_acquired_read": 8688, "bounce_acquired_write": 8689, "bounce_contended": 8690, "bounce_contended_read": 8691, "bounce_contended_write": 8692, "bounces": 8693, "bound_on": 8694, "bp": 8695, "bp_access_watchpoint": 8696, "bp_addr": 8697, "bp_breakpoint": 8698, "bp_check": 8699, "bp_delay": 8700, "bp_delayed": 8701, "bp_enabled": 8702, "bp_free": 8703, "bp_hardware_breakpoint": 8704, "bp_installed": 8705, "bp_type": 8706, "bp_undefined": 8707, "bp_vaddr": 8708, "bp_write_watchpoint": 8709, "bpage": 8710, "bpf": 8711, "bpf_a": 8712, "bpf_abs": 8713, "bpf_access_type": 8714, "bpf_add": 8715, "bpf_alu": 8716, "bpf_alu64": 8717, "bpf_alu_string": 8718, "bpf_and": 8719, "bpf_arg_type": 8720, "bpf_array": 8721, "bpf_arsh": 8722, "bpf_attr": 8723, "bpf_b": 8724, "bpf_binary_header": 8725, "bpf_call": 8726, "bpf_check": 8727, "bpf_check_classic": 8728, "bpf_class": 8729, "bpf_class_string": 8730, "bpf_convert_filter": 8731, "bpf_div": 8732, "bpf_dw": 8733, "bpf_end": 8734, "bpf_exist": 8735, "bpf_exit": 8736, "bpf_fill_ill_insns": 8737, "bpf_func": 8738, "bpf_func_id": 8739, "bpf_func_ktime_get_ns": 8740, "bpf_func_map_delete_elem": 8741, "bpf_func_map_lookup_elem": 8742, "bpf_func_map_update_elem": 8743, "bpf_func_probe_read": 8744, "bpf_func_proto": 8745, "bpf_func_trace_printk": 8746, "bpf_get_prandom_u32": 8747, "bpf_get_prandom_u32_proto": 8748, "bpf_get_smp_processor_id": 8749, "bpf_get_smp_processor_id_proto": 8750, "bpf_h": 8751, "bpf_htab": 8752, "bpf_imm": 8753, "bpf_ind": 8754, "bpf_insn": 8755, "bpf_int_jit_compile": 8756, "bpf_internal_load_pointer_neg_helper": 8757, "bpf_ja": 8758, "bpf_jeq": 8759, "bpf_jge": 8760, "bpf_jgt": 8761, "bpf_jit_binary_alloc": 8762, "bpf_jit_binary_free": 8763, "bpf_jit_fill_hole_t": 8764, "bpf_jit_free": 8765, "bpf_jmp": 8766, "bpf_jmp_string": 8767, "bpf_jne": 8768, "bpf_jset": 8769, "bpf_jsge": 8770, "bpf_jsgt": 8771, "bpf_k": 8772, "bpf_ktime_get_ns": 8773, "bpf_ktime_get_ns_proto": 8774, "bpf_ld": 8775, "bpf_ldst_string": 8776, "bpf_ldx": 8777, "bpf_len": 8778, "bpf_load_pointer": 8779, "bpf_lsh": 8780, "bpf_map": 8781, "bpf_map_create": 8782, "bpf_map_create_last_field": 8783, "bpf_map_delete_elem": 8784, "bpf_map_delete_elem_last_field": 8785, "bpf_map_delete_elem_proto": 8786, "bpf_map_fops": 8787, "bpf_map_free_deferred": 8788, "bpf_map_get": 8789, "bpf_map_get_next_key": 8790, "bpf_map_get_next_key_last_field": 8791, "bpf_map_lookup_elem": 8792, "bpf_map_lookup_elem_last_field": 8793, "bpf_map_lookup_elem_proto": 8794, "bpf_map_ops": 8795, "bpf_map_put": 8796, "bpf_map_release": 8797, "bpf_map_type_array": 8798, "bpf_map_type_hash": 8799, "bpf_map_type_list": 8800, "bpf_map_types": 8801, "bpf_map_update_elem": 8802, "bpf_map_update_elem_last_field": 8803, "bpf_map_update_elem_proto": 8804, "bpf_maxinsns": 8805, "bpf_mem": 8806, "bpf_misc": 8807, "bpf_mod": 8808, "bpf_mode": 8809, "bpf_mov": 8810, "bpf_mul": 8811, "bpf_neg": 8812, "bpf_noexist": 8813, "bpf_op": 8814, "bpf_or": 8815, "bpf_probe_read": 8816, "bpf_probe_read_proto": 8817, "bpf_prog": 8818, "bpf_prog_active": 8819, "bpf_prog_alloc": 8820, "bpf_prog_aux": 8821, "bpf_prog_fops": 8822, "bpf_prog_free": 8823, "bpf_prog_free_deferred": 8824, "bpf_prog_get": 8825, "bpf_prog_load": 8826, "bpf_prog_load_last_field": 8827, "bpf_prog_lock_ro": 8828, "bpf_prog_put": 8829, "bpf_prog_realloc": 8830, "bpf_prog_release": 8831, "bpf_prog_run": 8832, "bpf_prog_select_runtime": 8833, "bpf_prog_size": 8834, "bpf_prog_type": 8835, "bpf_prog_type_kprobe": 8836, "bpf_prog_type_list": 8837, "bpf_prog_type_sched_act": 8838, "bpf_prog_type_sched_cls": 8839, "bpf_prog_type_socket_filter": 8840, "bpf_prog_types": 8841, "bpf_pseudo_map_fd": 8842, "bpf_r0": 8843, "bpf_r1": 8844, "bpf_r10": 8845, "bpf_r2": 8846, "bpf_r3": 8847, "bpf_r4": 8848, "bpf_r5": 8849, "bpf_r6": 8850, "bpf_r7": 8851, "bpf_r8": 8852, "bpf_r9": 8853, "bpf_read": 8854, "bpf_reg_0": 8855, "bpf_reg_1": 8856, "bpf_reg_10": 8857, "bpf_reg_2": 8858, "bpf_reg_3": 8859, "bpf_reg_4": 8860, "bpf_reg_5": 8861, "bpf_reg_6": 8862, "bpf_reg_7": 8863, "bpf_reg_8": 8864, "bpf_reg_9": 8865, "bpf_reg_a": 8866, "bpf_reg_arg1": 8867, "bpf_reg_ctx": 8868, "bpf_reg_fp": 8869, "bpf_reg_size": 8870, "bpf_reg_type": 8871, "bpf_reg_x": 8872, "bpf_register_map_type": 8873, "bpf_register_prog_type": 8874, "bpf_ret": 8875, "bpf_rsh": 8876, "bpf_size": 8877, "bpf_size_to_bytes": 8878, "bpf_src": 8879, "bpf_st": 8880, "bpf_stack_slot_type": 8881, "bpf_stx": 8882, "bpf_sub": 8883, "bpf_tax": 8884, "bpf_to_be": 8885, "bpf_to_le": 8886, "bpf_trace_printk": 8887, "bpf_trace_printk_proto": 8888, "bpf_txa": 8889, "bpf_verifier_lock": 8890, "bpf_verifier_ops": 8891, "bpf_w": 8892, "bpf_write": 8893, "bpf_x": 8894, "bpf_xadd": 8895, "bpf_xor": 8896, "bph_length": 8897, "bpn": 8898, "bpno": 8899, "bprint": 8900, "bprint_entry": 8901, "bprm": 8902, "bpt": 8903, "bpt_addr": 8904, "bpt_type": 8905, "bputs": 8906, "bputs_entry": 8907, "br_stack": 8908, "braille": 8909, "braille_register_console": 8910, "braille_set_options": 8911, "braille_unregister_console": 8912, "branch": 8913, "branch_print_header": 8914, "branch_stat_show": 8915, "branch_trace": 8916, "branch_trace_init": 8917, "branch_trace_reset": 8918, "branch_tracer": 8919, "branch_tracing_enabled": 8920, "branch_tracing_mutex": 8921, "break": 8922, "break_handler": 8923, "break_instr_size": 8924, "break_lock": 8925, "breakpoint": 8926, "brk": 8927, "brl": 8928, "brl_options": 8929, "broadcast": 8930, "broadcast_needs_cpu": 8931, "broadcast_shutdown_local": 8932, "broken_hierarchy": 8933, "brw": 8934, "bs": 8935, "bsd_acct_struct": 8936, "bsearch": 8937, "bsize": 8938, "bss_addr": 8939, "bss_align": 8940, "bss_pad": 8941, "bss_sz": 8942, "bt": 8943, "btaprompt": 8944, "btrace_mutex": 8945, "btrace_seq": 8946, "buckets": 8947, "buf": 8948, "buf_addr": 8949, "buf_align": 8950, "buf_len": 8951, "buf_max": 8952, "buf_max_data_size": 8953, "buf_min": 8954, "buf_nr": 8955, "buf_page_hdr_size": 8956, "buf_page_size": 8957, "buf_size": 8958, "buf_sz": 8959, "buf_thread_id_size": 8960, "buff": 8961, "buffer": 8962, "buffer_a": 8963, "buffer_b": 8964, "buffer_bytes": 8965, "buffer_data_page": 8966, "buffer_disabled": 8967, "buffer_ftrace_now": 8968, "buffer_iter": 8969, "buffer_page": 8970, "buffer_size_kb": 8971, "buffer_total_size_kb": 8972, "bufferram": 8973, "buffers": 8974, "buflen": 8975, "bufmax": 8976, "bufp": 8977, "bufptr": 8978, "bufsz": 8979, "bug": 8980, "bug_cleanup": 8981, "bug_msg": 8982, "bug_on": 8983, "build_bug_on": 8984, "build_group_mask": 8985, "build_lock_ops": 8986, "build_map_info": 8987, "build_overlap_sched_groups": 8988, "build_probe_list": 8989, "build_sched_domain": 8990, "build_sched_domains": 8991, "build_sched_groups": 8992, "burst": 8993, "bus": 8994, "bus_isa_mem_base": 8995, "bus_isa_port_base": 8996, "bus_isa_port_shift": 8997, "bus_mceerr_ao": 8998, "bus_mceerr_ar": 8999, "bus_type": 9000, "busiest": 9001, "busiest_capacity": 9002, "busiest_cpu": 9003, "busiest_load": 9004, "busiest_rq": 9005, "busiest_stat": 9006, "bust_spinlocks": 9007, "busy": 9008, "busy_factor": 9009, "busy_hash": 9010, "busy_idx": 9011, "busy_sd": 9012, "busy_worker_hash_order": 9013, "but": 9014, "buts": 9015, "bv_page": 9016, "bw": 9017, "bx": 9018, "by": 9019, "byte": 9020, "bytes": 9021, "bytes_alloc": 9022, "bytes_alloc_nested": 9023, "bytes_dropped": 9024, "bytes_dropped_nested": 9025, "bytes_to_bits": 9026, "bytes_written": 9027, "bytes_written_nested": 9028, "bytesperword": 9029, "c": 9030, "c0": 9031, "c1": 9032, "c_a_d": 9033, "c_old": 9034, "c_out": 9035, "ca": 9036, "cache": 9037, "cache_flush_is_safe": 9038, "cache_hit": 9039, "cache_hot_buddy": 9040, "cache_line_size": 9041, "cache_nice_tries": 9042, "cache_read": 9043, "cache_reader_page": 9044, "cachep": 9045, "cad_pid": 9046, "calc_cfs_shares": 9047, "calc_delta_fair": 9048, "calc_global_load": 9049, "calc_global_nohz": 9050, "calc_load": 9051, "calc_load_account_active": 9052, "calc_load_active": 9053, "calc_load_enter_idle": 9054, "calc_load_exit_idle": 9055, "calc_load_fold_active": 9056, "calc_load_fold_idle": 9057, "calc_load_idle": 9058, "calc_load_idx": 9059, "calc_load_migrate": 9060, "calc_load_n": 9061, "calc_load_read_idx": 9062, "calc_load_tasks": 9063, "calc_load_update": 9064, "calc_load_write_idx": 9065, "calc_tg_weight": 9066, "calc_timer_values": 9067, "calcnt": 9068, "calculate_imbalance": 9069, "call": 9070, "call_args": 9071, "call_fetch": 9072, "call_filter_check_discard": 9073, "call_function_data": 9074, "call_function_init": 9075, "call_modprobe": 9076, "call_panic": 9077, "call_rcu": 9078, "call_rcu_bh": 9079, "call_rcu_busted": 9080, "call_rcu_func_t": 9081, "call_rcu_sched": 9082, "call_rcu_tasks": 9083, "call_rcu_time": 9084, "call_single_data": 9085, "call_single_queue": 9086, "call_srcu": 9087, "call_timer_fn": 9088, "call_usermodehelper": 9089, "call_usermodehelper_exec": 9090, "call_usermodehelper_freeinfo": 9091, "call_usermodehelper_setup": 9092, "callback_head": 9093, "callback_lock": 9094, "callchain": 9095, "callchain_cpus_entries": 9096, "callchain_mutex": 9097, "callchain_recursion": 9098, "called": 9099, "caller": 9100, "caller_addr": 9101, "caller_addr0": 9102, "caller_addr1": 9103, "caller_addr2": 9104, "caller_addr3": 9105, "caller_saved": 9106, "caller_saved_regs": 9107, "calls": 9108, "calltime": 9109, "can": 9110, "can_add_hw": 9111, "can_attach": 9112, "can_boost": 9113, "can_cont": 9114, "can_expedite": 9115, "can_migrate_task": 9116, "can_nice": 9117, "can_request_irq": 9118, "can_stop_full_tick": 9119, "can_stop_idle_tick": 9120, "cancel_attach": 9121, "cancel_delayed_work": 9122, "cancel_delayed_work_sync": 9123, "cancel_ref": 9124, "cancel_txn": 9125, "cancel_waitq": 9126, "cancel_work_sync": 9127, "cancelled_write_bytes": 9128, "candidate": 9129, "cannot": 9130, "canrequest": 9131, "cap": 9132, "cap_array": 9133, "cap_audit_control": 9134, "cap_audit_read": 9135, "cap_audit_write": 9136, "cap_bit0_is_deprecated": 9137, "cap_block_suspend": 9138, "cap_bset": 9139, "cap_effective": 9140, "cap_empty_set": 9141, "cap_for_each_u32": 9142, "cap_full_set": 9143, "cap_get_target_pid": 9144, "cap_inheritable": 9145, "cap_intersect": 9146, "cap_ipc_lock": 9147, "cap_isclear": 9148, "cap_issubset": 9149, "cap_kill": 9150, "cap_last_cap": 9151, "cap_last_u32": 9152, "cap_permitted": 9153, "cap_pi": 9154, "cap_setgid": 9155, "cap_setid": 9156, "cap_setpcap": 9157, "cap_setuid": 9158, "cap_sys_admin": 9159, "cap_sys_boot": 9160, "cap_sys_module": 9161, "cap_sys_nice": 9162, "cap_sys_pacct": 9163, "cap_sys_ptrace": 9164, "cap_sys_resource": 9165, "cap_sys_time": 9166, "cap_syslog": 9167, "cap_user_data_t": 9168, "cap_user_header_t": 9169, "cap_valid": 9170, "cap_validate_magic": 9171, "cap_wake_alarm": 9172, "capa_move": 9173, "capa_now": 9174, "capabilities": 9175, "capable": 9176, "capable_wrt_inode_uidgid": 9177, "capacity": 9178, "capacity_of": 9179, "capacity_orig_of": 9180, "capget": 9181, "caps": 9182, "capset": 9183, "cascade": 9184, "case": 9185, "cat": 9186, "catastrophic": 9187, "catchup_timer_jiffies": 9188, "cb": 9189, "cb_barrier": 9190, "cb_count": 9191, "cb_cpu": 9192, "cbcpu": 9193, "cbcpumask": 9194, "cbflood_inter_holdoff": 9195, "cbflood_intra_holdoff": 9196, "cbflood_n_burst": 9197, "cbflood_n_per_burst": 9198, "cbflood_task": 9199, "cbs": 9200, "cbs_ready": 9201, "cbuf": 9202, "cbuts": 9203, "cc": 9204, "cc_cyc2ns_backwards": 9205, "cc_using_fentry": 9206, "ccur": 9207, "ccversion": 9208, "cd": 9209, "cdev": 9210, "cdev_add": 9211, "cdev_del": 9212, "cdev_init": 9213, "ce": 9214, "ce_broadcast_hrtimer": 9215, "ce_unbind": 9216, "ced": 9217, "centisecs": 9218, "cev_delta2ns": 9219, "cfd": 9220, "cfd_data": 9221, "cfg": 9222, "cfg_checksum": 9223, "cflags": 9224, "cfs": 9225, "cfs_b": 9226, "cfs_bandwidth": 9227, "cfs_bandwidth_slack_period": 9228, "cfs_bandwidth_usage_dec": 9229, "cfs_bandwidth_usage_inc": 9230, "cfs_bandwidth_used": 9231, "cfs_constraints_mutex": 9232, "cfs_period_us": 9233, "cfs_quota_us": 9234, "cfs_rq": 9235, "cfs_rq_clock_task": 9236, "cfs_rq_of": 9237, "cfs_rq_throttled": 9238, "cfs_schedulable_data": 9239, "cfs_tasks": 9240, "cft": 9241, "cfts": 9242, "cftype": 9243, "cftype_no_prefix": 9244, "cftype_not_on_root": 9245, "cftype_only_on_root": 9246, "cg_list": 9247, "cgroup": 9248, "cgroup_add_cftypes": 9249, "cgroup_add_dfl_cftypes": 9250, "cgroup_add_file": 9251, "cgroup_add_legacy_cftypes": 9252, "cgroup_addrm_files": 9253, "cgroup_apply_cftypes": 9254, "cgroup_assert_mutex_or_rcu_locked": 9255, "cgroup_attach_task": 9256, "cgroup_attach_task_all": 9257, "cgroup_calc_child_subsys_mask": 9258, "cgroup_clear_dir": 9259, "cgroup_clone_children_read": 9260, "cgroup_clone_children_write": 9261, "cgroup_controllers_show": 9262, "cgroup_css": 9263, "cgroup_css_links_read": 9264, "cgroup_destroy_locked": 9265, "cgroup_destroy_root": 9266, "cgroup_destroy_wq": 9267, "cgroup_dfl_base_files": 9268, "cgroup_disable": 9269, "cgroup_e_css": 9270, "cgroup_enable_task_cg_lists": 9271, "cgroup_exit": 9272, "cgroup_exit_cftypes": 9273, "cgroup_exit_root_id": 9274, "cgroup_file_mode": 9275, "cgroup_file_name": 9276, "cgroup_file_name_max": 9277, "cgroup_file_procs": 9278, "cgroup_file_tasks": 9279, "cgroup_file_write": 9280, "cgroup_filetype": 9281, "cgroup_fork": 9282, "cgroup_free_root": 9283, "cgroup_freezer_online": 9284, "cgroup_freezing": 9285, "cgroup_freezing_parent": 9286, "cgroup_freezing_self": 9287, "cgroup_frozen": 9288, "cgroup_fs": 9289, "cgroup_fs_type": 9290, "cgroup_get": 9291, "cgroup_get_e_css": 9292, "cgroup_has_tasks": 9293, "cgroup_hierarchy_idr": 9294, "cgroup_idr": 9295, "cgroup_idr_alloc": 9296, "cgroup_idr_lock": 9297, "cgroup_idr_remove": 9298, "cgroup_idr_replace": 9299, "cgroup_init": 9300, "cgroup_init_cftypes": 9301, "cgroup_init_early": 9302, "cgroup_init_root_id": 9303, "cgroup_init_subsys": 9304, "cgroup_is_dead": 9305, "cgroup_is_descendant": 9306, "cgroup_kf_ops": 9307, "cgroup_kf_single_ops": 9308, "cgroup_kf_syscall_ops": 9309, "cgroup_kill_sb": 9310, "cgroup_kn_lock_live": 9311, "cgroup_kn_set_ugid": 9312, "cgroup_kn_unlock": 9313, "cgroup_kobj": 9314, "cgroup_legacy_base_files": 9315, "cgroup_legacy_files_on_dfl": 9316, "cgroup_migrate": 9317, "cgroup_migrate_add_src": 9318, "cgroup_migrate_finish": 9319, "cgroup_migrate_prepare_dst": 9320, "cgroup_mkdir": 9321, "cgroup_mount": 9322, "cgroup_mutex": 9323, "cgroup_name": 9324, "cgroup_on_dfl": 9325, "cgroup_parent": 9326, "cgroup_path": 9327, "cgroup_pid_fry": 9328, "cgroup_pidlist": 9329, "cgroup_pidlist_destroy_all": 9330, "cgroup_pidlist_destroy_delay": 9331, "cgroup_pidlist_destroy_work_fn": 9332, "cgroup_pidlist_destroy_wq": 9333, "cgroup_pidlist_find": 9334, "cgroup_pidlist_find_create": 9335, "cgroup_pidlist_next": 9336, "cgroup_pidlist_show": 9337, "cgroup_pidlist_start": 9338, "cgroup_pidlist_stop": 9339, "cgroup_populate_dir": 9340, "cgroup_populated_show": 9341, "cgroup_post_fork": 9342, "cgroup_print_ss_mask": 9343, "cgroup_procs_write": 9344, "cgroup_put": 9345, "cgroup_read_notify_on_release": 9346, "cgroup_refresh_child_subsys_mask": 9347, "cgroup_release_agent": 9348, "cgroup_release_agent_show": 9349, "cgroup_release_agent_write": 9350, "cgroup_remount": 9351, "cgroup_rename": 9352, "cgroup_rm_cftypes": 9353, "cgroup_rm_cftypes_locked": 9354, "cgroup_rm_file": 9355, "cgroup_rmdir": 9356, "cgroup_root": 9357, "cgroup_root_controllers_show": 9358, "cgroup_root_count": 9359, "cgroup_root_from_kf": 9360, "cgroup_roots": 9361, "cgroup_sane_behavior_show": 9362, "cgroup_sb_opts": 9363, "cgroup_seqfile_next": 9364, "cgroup_seqfile_show": 9365, "cgroup_seqfile_start": 9366, "cgroup_seqfile_stop": 9367, "cgroup_set_legacy_files_on_dfl": 9368, "cgroup_setup_root": 9369, "cgroup_show_options": 9370, "cgroup_subsys": 9371, "cgroup_subsys_count": 9372, "cgroup_subsys_name": 9373, "cgroup_subsys_state": 9374, "cgroup_subtree_control_show": 9375, "cgroup_subtree_control_write": 9376, "cgroup_super_magic": 9377, "cgroup_task_count": 9378, "cgroup_task_migrate": 9379, "cgroup_tasks_write": 9380, "cgroup_taskset": 9381, "cgroup_taskset_first": 9382, "cgroup_taskset_for_each": 9383, "cgroup_taskset_next": 9384, "cgroup_transfer_tasks": 9385, "cgroup_tryget": 9386, "cgroup_update_dfl_csses": 9387, "cgroup_update_populated": 9388, "cgroup_write_notify_on_release": 9389, "cgroups": 9390, "cgroupstats": 9391, "cgroupstats_build": 9392, "cgroupstats_cmd_attr_fd": 9393, "cgroupstats_cmd_attr_max": 9394, "cgroupstats_cmd_get": 9395, "cgroupstats_cmd_get_policy": 9396, "cgroupstats_cmd_new": 9397, "cgroupstats_open": 9398, "cgroupstats_user_cmd": 9399, "cgrp": 9400, "cgrp1": 9401, "cgrp2": 9402, "cgrp_cpuset_clone_children": 9403, "cgrp_cset_link": 9404, "cgrp_dfl_root": 9405, "cgrp_dfl_root_inhibit_ss_mask": 9406, "cgrp_dfl_root_visible": 9407, "cgrp_link": 9408, "cgrp_links": 9409, "cgrp_notify_on_release": 9410, "cgrp_root_noprefix": 9411, "cgrp_root_sane_behavior": 9412, "cgrp_root_xattr": 9413, "ch": 9414, "chain": 9415, "chain_alloc": 9416, "chain_allocator": 9417, "chain_head": 9418, "chain_hlocks": 9419, "chain_init": 9420, "chain_key": 9421, "chain_lookup_hits": 9422, "chain_lookup_misses": 9423, "chained": 9424, "chainhashentry": 9425, "chan": 9426, "change": 9427, "change_clocksource": 9428, "change_okay": 9429, "change_pid": 9430, "change_prot_numa": 9431, "char": 9432, "charge": 9433, "charp": 9434, "check": 9435, "check_alu_op": 9436, "check_asym_packing": 9437, "check_attr": 9438, "check_call": 9439, "check_cfg": 9440, "check_cfs_rq_runtime": 9441, "check_chain_key": 9442, "check_class_changed": 9443, "check_clocks": 9444, "check_cond_jmp_op": 9445, "check_cpu_capacity": 9446, "check_cpu_stall": 9447, "check_cpu_stall_init": 9448, "check_cpu_stalls": 9449, "check_critical_timing": 9450, "check_ctx_access": 9451, "check_data_rlimit": 9452, "check_deadlock": 9453, "check_enqueue_throttle": 9454, "check_fetch_funcs": 9455, "check_flags": 9456, "check_for_release": 9457, "check_for_tasks": 9458, "check_free_space": 9459, "check_func_arg": 9460, "check_grep": 9461, "check_header": 9462, "check_holdout_task": 9463, "check_hung_task": 9464, "check_hung_uninterruptible_tasks": 9465, "check_image": 9466, "check_image_kernel": 9467, "check_irq_entry": 9468, "check_irq_resend": 9469, "check_irq_return": 9470, "check_irq_usage": 9471, "check_kill_permission": 9472, "check_kprobe_address_safe": 9473, "check_kprobe_rereg": 9474, "check_kthr_stop": 9475, "check_ld_abs": 9476, "check_ld_imm": 9477, "check_map_access": 9478, "check_mem_access": 9479, "check_mm": 9480, "check_modinfo": 9481, "check_modstruct_version": 9482, "check_module_license_and_versions": 9483, "check_noncircular": 9484, "check_pgt_cache": 9485, "check_pred_data": 9486, "check_pred_tree": 9487, "check_pred_tree_cb": 9488, "check_preds": 9489, "check_preempt_curr": 9490, "check_preempt_curr_idle": 9491, "check_preempt_curr_rt": 9492, "check_preempt_equal_prio": 9493, "check_preempt_tick": 9494, "check_preempt_wakeup": 9495, "check_prev_add": 9496, "check_prev_add_irq": 9497, "check_prevs_add": 9498, "check_prlimit_permission": 9499, "check_reg_arg": 9500, "check_resched": 9501, "check_same_owner": 9502, "check_spread": 9503, "check_stack_boundary": 9504, "check_stack_read": 9505, "check_stack_write": 9506, "check_state": 9507, "check_symbol": 9508, "check_unlock": 9509, "check_unshare_flags": 9510, "check_usage": 9511, "check_usage_backwards": 9512, "check_usage_f": 9513, "check_usage_forwards": 9514, "check_version": 9515, "check_xadd": 9516, "checkcore": 9517, "checksum": 9518, "checkwait": 9519, "child": 9520, "child_cs": 9521, "child_list": 9522, "child_mutex": 9523, "child_reaper": 9524, "child_subsys_mask": 9525, "child_tidptr": 9526, "child_total_time_enabled": 9527, "child_total_time_running": 9528, "children": 9529, "chip": 9530, "chip_bus_lock": 9531, "chip_bus_sync_unlock": 9532, "chip_data": 9533, "chip_types": 9534, "choose": 9535, "chown16": 9536, "chunk": 9537, "chunk_entry": 9538, "chunk_hash": 9539, "chunk_hash_heads": 9540, "chunks": 9541, "chwalk": 9542, "chz": 9543, "ci_ptr": 9544, "cinblock": 9545, "cinterval": 9546, "circ_space": 9547, "circular": 9548, "circular_queue": 9549, "ck_cmdline": 9550, "cl": 9551, "claim_allocations": 9552, "clamp": 9553, "clamp_t": 9554, "clamp_val": 9555, "class": 9556, "class_cache": 9557, "class_filter": 9558, "class_idx": 9559, "class_interface": 9560, "class_interface_register": 9561, "class_interface_unregister": 9562, "class_intf": 9563, "classes": 9564, "classhash_bits": 9565, "classhash_size": 9566, "classhashentry": 9567, "classic": 9568, "clc": 9569, "cld_continued": 9570, "cld_dumped": 9571, "cld_exited": 9572, "cld_killed": 9573, "cld_stopped": 9574, "cld_trapped": 9575, "clean_sort_range": 9576, "cleanup": 9577, "cleanup_all_probes": 9578, "cleanup_rp_inst": 9579, "cleanup_srcu_struct": 9580, "clear": 9581, "clear_all_latency_tracing": 9582, "clear_bit": 9583, "clear_buddies": 9584, "clear_child_tid": 9585, "clear_code": 9586, "clear_event_triggers": 9587, "clear_fast_ctr": 9588, "clear_frozen": 9589, "clear_ftrace_function": 9590, "clear_ftrace_pid": 9591, "clear_ftrace_pid_task": 9592, "clear_ftrace_swapper": 9593, "clear_global_latency_tracing": 9594, "clear_idx": 9595, "clear_lock_stats": 9596, "clear_nosave_free": 9597, "clear_operand_string": 9598, "clear_page": 9599, "clear_page_nosave": 9600, "clear_pending": 9601, "clear_preempt_need_resched": 9602, "clear_restore_sigmask": 9603, "clear_sched_clock_stable": 9604, "clear_seq": 9605, "clear_thread_flag": 9606, "clear_tlb_flush_pending": 9607, "clear_trace": 9608, "clear_tsk_need_resched": 9609, "clear_tsk_thread_flag": 9610, "clear_tsk_trace_trace": 9611, "clear_user_return_notifier": 9612, "clearpageprivate": 9613, "clears": 9614, "clk": 9615, "clock": 9616, "clock2alarm": 9617, "clock_adj": 9618, "clock_adjtime": 9619, "clock_base": 9620, "clock_boottime": 9621, "clock_boottime_alarm": 9622, "clock_event_device": 9623, "clock_event_mode": 9624, "clock_event_state": 9625, "clock_evt_feat_c3stop": 9626, "clock_evt_feat_dummy": 9627, "clock_evt_feat_dynirq": 9628, "clock_evt_feat_hrtimer": 9629, "clock_evt_feat_ktime": 9630, "clock_evt_feat_oneshot": 9631, "clock_evt_feat_percpu": 9632, "clock_evt_feat_periodic": 9633, "clock_evt_mode_resume": 9634, "clock_evt_mode_shutdown": 9635, "clock_evt_mode_unused": 9636, "clock_evt_state_detached": 9637, "clock_evt_state_oneshot": 9638, "clock_evt_state_periodic": 9639, "clock_evt_state_shutdown": 9640, "clock_get": 9641, "clock_getres": 9642, "clock_gettime": 9643, "clock_id": 9644, "clock_monotonic": 9645, "clock_monotonic_coarse": 9646, "clock_monotonic_raw": 9647, "clock_nanosleep": 9648, "clock_nanosleep_restart": 9649, "clock_posix_dynamic": 9650, "clock_realtime": 9651, "clock_realtime_alarm": 9652, "clock_realtime_coarse": 9653, "clock_set": 9654, "clock_settime": 9655, "clock_skip_update": 9656, "clock_source_suspend_nonstop": 9657, "clock_source_valid_for_hres": 9658, "clock_t": 9659, "clock_t_to_compat_clock_t": 9660, "clock_t_to_jiffies": 9661, "clock_tai": 9662, "clock_task": 9663, "clock_was_set": 9664, "clockevent_delta2ns": 9665, "clockevent_devices": 9666, "clockevents_calc_mult_shift": 9667, "clockevents_config": 9668, "clockevents_config_and_register": 9669, "clockevents_exchange_device": 9670, "clockevents_handle_noop": 9671, "clockevents_increase_min_delta": 9672, "clockevents_init_sysfs": 9673, "clockevents_lock": 9674, "clockevents_mutex": 9675, "clockevents_notify_released": 9676, "clockevents_program_event": 9677, "clockevents_program_min_delta": 9678, "clockevents_register_device": 9679, "clockevents_released": 9680, "clockevents_replace": 9681, "clockevents_resume": 9682, "clockevents_sanity_check": 9683, "clockevents_set_state": 9684, "clockevents_shutdown": 9685, "clockevents_subsys": 9686, "clockevents_suspend": 9687, "clockevents_tick_resume": 9688, "clockevents_unbind": 9689, "clockevents_unbind_device": 9690, "clockevents_update_freq": 9691, "clockid": 9692, "clockid_t": 9693, "clockid_to_fd": 9694, "clockid_to_kclock": 9695, "clocksource": 9696, "clocksource_cyc2ns": 9697, "clocksource_default_clock": 9698, "clocksource_delta": 9699, "clocksource_resume": 9700, "clocksource_suspend": 9701, "clocksource_touch_watchdog": 9702, "clone": 9703, "clone_child_cleartid": 9704, "clone_child_settid": 9705, "clone_ctx": 9706, "clone_files": 9707, "clone_flags": 9708, "clone_fs": 9709, "clone_io": 9710, "clone_newipc": 9711, "clone_newnet": 9712, "clone_newns": 9713, "clone_newpid": 9714, "clone_newuser": 9715, "clone_newuts": 9716, "clone_parent": 9717, "clone_parent_settid": 9718, "clone_ptrace": 9719, "clone_sighand": 9720, "clone_sysvsem": 9721, "clone_thread": 9722, "clone_untraced": 9723, "clone_uts_ns": 9724, "clone_vfork": 9725, "clone_vm": 9726, "close": 9727, "close_finish": 9728, "close_work": 9729, "clr": 9730, "cm": 9731, "cma": 9732, "cmaj_flt": 9733, "cmaxrss": 9734, "cmd": 9735, "cmd_attr_deregister_cpumask": 9736, "cmd_attr_pid": 9737, "cmd_attr_register_cpumask": 9738, "cmd_attr_tgid": 9739, "cmd_buflen": 9740, "cmd_cur": 9741, "cmd_enable": 9742, "cmd_flags": 9743, "cmd_func": 9744, "cmd_head": 9745, "cmd_help": 9746, "cmd_hist": 9747, "cmd_interrupt": 9748, "cmd_len": 9749, "cmd_minlen": 9750, "cmd_name": 9751, "cmd_ops": 9752, "cmd_tail": 9753, "cmd_type": 9754, "cmd_usage": 9755, "cmdbuf": 9756, "cmdline": 9757, "cmdline_buf": 9758, "cmdline_buf_len": 9759, "cmdline_idx": 9760, "cmdline_len": 9761, "cmdline_num": 9762, "cmdline_ptr": 9763, "cmdptr": 9764, "cmdstr": 9765, "cmin_flt": 9766, "cmp": 9767, "cmp_data": 9768, "cmp_len": 9769, "cmp_name": 9770, "cmp_next_hrtimer_event": 9771, "cmp_stat_t": 9772, "cmppid": 9773, "cmpxchg": 9774, "cmpxchg64": 9775, "cmpxchg_cputime": 9776, "cnivcsw": 9777, "cnt": 9778, "cnts": 9779, "cnvcsw": 9780, "co": 9781, "code": 9782, "collect_garbage_slots": 9783, "collect_mounts": 9784, "collect_one_slot": 9785, "collect_signal": 9786, "collection": 9787, "collision": 9788, "colon": 9789, "color": 9790, "columns": 9791, "comm": 9792, "comm_event": 9793, "comm_size": 9794, "comma": 9795, "command": 9796, "command_line_size": 9797, "commands": 9798, "commit": 9799, "commit_creds": 9800, "commit_overrun": 9801, "commit_page": 9802, "commit_txn": 9803, "commits": 9804, "committing": 9805, "common_end": 9806, "common_head": 9807, "common_nsleep": 9808, "common_timer_create": 9809, "common_timer_del": 9810, "common_timer_get": 9811, "common_timer_set": 9812, "comp": 9813, "compare_css_sets": 9814, "compare_root": 9815, "compat": 9816, "compat_alloc_user_space": 9817, "compat_arch_ptrace": 9818, "compat_blk_trace_setup": 9819, "compat_blk_user_trace_setup": 9820, "compat_clock_nanosleep_restart": 9821, "compat_clock_t": 9822, "compat_convert_timespec": 9823, "compat_exit_robust_list": 9824, "compat_get_bitmap": 9825, "compat_get_timespec": 9826, "compat_get_timeval": 9827, "compat_get_timex": 9828, "compat_get_user_cpu_mask": 9829, "compat_ioctl": 9830, "compat_iovec": 9831, "compat_itimerspec": 9832, "compat_itimerval": 9833, "compat_jiffies_to_clock_t": 9834, "compat_kexec_segment": 9835, "compat_loff_t": 9836, "compat_log": 9837, "compat_long_t": 9838, "compat_nanosleep_restart": 9839, "compat_old_sigaction": 9840, "compat_old_sigset_t": 9841, "compat_oldlenp": 9842, "compat_pid_t": 9843, "compat_ptr": 9844, "compat_put_timespec": 9845, "compat_put_timeval": 9846, "compat_put_timex": 9847, "compat_restore_altstack": 9848, "compat_resume_swap_area": 9849, "compat_rlim_infinity": 9850, "compat_rlim_old_infinity": 9851, "compat_rlimit": 9852, "compat_rmtp": 9853, "compat_robust_list": 9854, "compat_robust_list_head": 9855, "compat_rusage": 9856, "compat_sig_setmask": 9857, "compat_sigaction": 9858, "compat_sigevent": 9859, "compat_siginfo": 9860, "compat_siginfo_t": 9861, "compat_sigset_t": 9862, "compat_sigset_word": 9863, "compat_size_t": 9864, "compat_sock_fprog": 9865, "compat_stack_t": 9866, "compat_sys_epoll_pwait": 9867, "compat_sys_fanotify_mark": 9868, "compat_sys_futex": 9869, "compat_sys_get_mempolicy": 9870, "compat_sys_get_robust_list": 9871, "compat_sys_getsockopt": 9872, "compat_sys_ipc": 9873, "compat_sys_kexec_load": 9874, "compat_sys_keyctl": 9875, "compat_sys_lookup_dcookie": 9876, "compat_sys_mbind": 9877, "compat_sys_migrate_pages": 9878, "compat_sys_move_pages": 9879, "compat_sys_mq_getsetattr": 9880, "compat_sys_mq_notify": 9881, "compat_sys_mq_open": 9882, "compat_sys_mq_timedreceive": 9883, "compat_sys_mq_timedsend": 9884, "compat_sys_msgctl": 9885, "compat_sys_msgrcv": 9886, "compat_sys_msgsnd": 9887, "compat_sys_open_by_handle_at": 9888, "compat_sys_process_vm_readv": 9889, "compat_sys_process_vm_writev": 9890, "compat_sys_recv": 9891, "compat_sys_recvfrom": 9892, "compat_sys_recvmmsg": 9893, "compat_sys_recvmsg": 9894, "compat_sys_s390_ipc": 9895, "compat_sys_semctl": 9896, "compat_sys_semtimedop": 9897, "compat_sys_sendmmsg": 9898, "compat_sys_sendmsg": 9899, "compat_sys_set_mempolicy": 9900, "compat_sys_set_robust_list": 9901, "compat_sys_setsockopt": 9902, "compat_sys_shmat": 9903, "compat_sys_shmctl": 9904, "compat_sys_sigaltstack": 9905, "compat_sys_signalfd": 9906, "compat_sys_signalfd4": 9907, "compat_sys_socketcall": 9908, "compat_sys_sysctl": 9909, "compat_sys_timerfd_gettime": 9910, "compat_sys_timerfd_settime": 9911, "compat_syscall_define1": 9912, "compat_syscall_define2": 9913, "compat_syscall_define3": 9914, "compat_syscall_define4": 9915, "compat_syscall_define5": 9916, "compat_syscall_define6": 9917, "compat_sysctl_args": 9918, "compat_sysinfo": 9919, "compat_time_t": 9920, "compat_timespec": 9921, "compat_timeval": 9922, "compat_timex": 9923, "compat_tms": 9924, "compat_uint_t": 9925, "compat_ulong_t": 9926, "compat_uptr_t": 9927, "compat_use_64bit_time": 9928, "compat_user_stack_pointer": 9929, "compat_uts_machine": 9930, "compatible": 9931, "complete": 9932, "complete_formation": 9933, "complete_signal": 9934, "complete_vfork_done": 9935, "completed": 9936, "completion": 9937, "completion_done": 9938, "completion_initializer_onstack": 9939, "compressed": 9940, "compute_capacity": 9941, "con": 9942, "con_brl": 9943, "con_enabled": 9944, "con_printbuffer": 9945, "cond": 9946, "cond_func": 9947, "cond_resched": 9948, "cond_resched_completed": 9949, "cond_resched_rcu_qs": 9950, "cond_suspend_depth": 9951, "cond_sync": 9952, "cond_synchronize_rcu": 9953, "cond_syscall": 9954, "cond_unmask_eoi_irq": 9955, "cond_unmask_irq": 9956, "config": 9957, "config_64bit": 9958, "config_a11y_braille_console": 9959, "config_acpi_sleep": 9960, "config_aio": 9961, "config_arch_hibernation_header": 9962, "config_arch_task_struct_allocator": 9963, "config_arch_thread_info_allocator": 9964, "config_arch_uses_gettimeoffset": 9965, "config_arm": 9966, "config_audit_tree": 9967, "config_audit_watch": 9968, "config_auditsyscall": 9969, "config_auto_irq_affinity": 9970, "config_base_small": 9971, "config_bcache": 9972, "config_binfmt_elf_fdpic": 9973, "config_binfmt_misc": 9974, "config_binfmt_misc_module": 9975, "config_blk_dev_initrd": 9976, "config_blk_dev_io_trace": 9977, "config_block": 9978, "config_bootparam_hung_task_panic_value": 9979, "config_bpf_jit": 9980, "config_branch_tracer": 9981, "config_bsd_process_acct": 9982, "config_cc_stackprotector": 9983, "config_cfs_bandwidth": 9984, "config_cgroup_cpuacct": 9985, "config_cgroup_debug": 9986, "config_cgroup_sched": 9987, "config_cgroups": 9988, "config_checkpoint_restore": 9989, "config_chr_dev_sg": 9990, "config_clocksource_validate_last_cycle": 9991, "config_clone_backwards": 9992, "config_clone_backwards2": 9993, "config_clone_backwards3": 9994, "config_compaction": 9995, "config_compat": 9996, "config_compat_old_sigaction": 9997, "config_constructors": 9998, "config_context_switch_tracer": 9999, "config_context_tracking": 10000, "config_context_tracking_force": 10001, "config_coredump": 10002, "config_cpu_idle": 10003, "config_cpusets": 10004, "config_debug_atomic_sleep": 10005, "config_debug_bugverbose": 10006, "config_debug_credentials": 10007, "config_debug_fs": 10008, "config_debug_kmemleak": 10009, "config_debug_lock_alloc": 10010, "config_debug_lockdep": 10011, "config_debug_mutexes": 10012, "config_debug_notifiers": 10013, "config_debug_objects_rcu_head": 10014, "config_debug_objects_timers": 10015, "config_debug_objects_work": 10016, "config_debug_preempt": 10017, "config_debug_rodata": 10018, "config_debug_rt_mutexes": 10019, "config_debug_set_module_ronx": 10020, "config_debug_shirq": 10021, "config_debug_shirq_fixme": 10022, "config_debug_spinlock": 10023, "config_debug_stackoverflow": 10024, "config_debug_timekeeping": 10025, "config_debug_ww_mutex_slowpath": 10026, "config_default_hung_task_timeout": 10027, "config_detect_hung_task": 10028, "config_dnotify": 10029, "config_dynamic_debug": 10030, "config_dynamic_ftrace": 10031, "config_dynamic_ftrace_with_regs": 10032, "config_epoll": 10033, "config_event_trace_test_syscalls": 10034, "config_event_tracing": 10035, "config_fair_group_sched": 10036, "config_file_locking": 10037, "config_freezer": 10038, "config_ftrace_mcount_record": 10039, "config_ftrace_selftest": 10040, "config_ftrace_startup_test": 10041, "config_ftrace_syscalls": 10042, "config_function_graph_tracer": 10043, "config_function_tracer": 10044, "config_futex": 10045, "config_generic_clockevents": 10046, "config_generic_clockevents_broadcast": 10047, "config_generic_clockevents_min_adjust": 10048, "config_generic_irq_legacy": 10049, "config_generic_irq_legacy_alloc_hwirq": 10050, "config_generic_irq_show": 10051, "config_generic_irq_show_level": 10052, "config_generic_lockbreak": 10053, "config_generic_msi_irq_domain": 10054, "config_generic_pending_irq": 10055, "config_generic_smp_idle_thread": 10056, "config_generic_time_vsyscall_old": 10057, "config_handle_domain_irq": 10058, "config_hardirqs_sw_resend": 10059, "config_hardlockup_detector": 10060, "config_have_arch_seccomp_filter": 10061, "config_have_arch_tracehook": 10062, "config_have_efficient_unaligned_access": 10063, "config_have_function_graph_fp_test": 10064, "config_have_irq_exit_on_irq_stack": 10065, "config_have_nmi_watchdog": 10066, "config_have_unstable_sched_clock": 10067, "config_hibernation": 10068, "config_high_res_timers": 10069, "config_highmem": 10070, "config_hotplug_cpu": 10071, "config_hugetlb_page": 10072, "config_ia64": 10073, "config_ikconfig_proc": 10074, "config_init_all_possible": 10075, "config_inline_read_lock": 10076, "config_inline_read_lock_bh": 10077, "config_inline_read_lock_irq": 10078, "config_inline_read_lock_irqsave": 10079, "config_inline_read_trylock": 10080, "config_inline_read_unlock": 10081, "config_inline_read_unlock_bh": 10082, "config_inline_read_unlock_irq": 10083, "config_inline_read_unlock_irqrestore": 10084, "config_inline_spin_lock": 10085, "config_inline_spin_lock_bh": 10086, "config_inline_spin_lock_irq": 10087, "config_inline_spin_lock_irqsave": 10088, "config_inline_spin_trylock": 10089, "config_inline_spin_trylock_bh": 10090, "config_inline_spin_unlock_bh": 10091, "config_inline_spin_unlock_irq": 10092, "config_inline_spin_unlock_irqrestore": 10093, "config_inline_write_lock": 10094, "config_inline_write_lock_bh": 10095, "config_inline_write_lock_irq": 10096, "config_inline_write_lock_irqsave": 10097, "config_inline_write_trylock": 10098, "config_inline_write_unlock": 10099, "config_inline_write_unlock_bh": 10100, "config_inline_write_unlock_irq": 10101, "config_inline_write_unlock_irqrestore": 10102, "config_inotify_user": 10103, "config_irq_domain": 10104, "config_irq_domain_hierarchy": 10105, "config_irq_edge_eoi_handler": 10106, "config_irq_forced_threading": 10107, "config_irq_preflow_fasteoi": 10108, "config_irq_time_accounting": 10109, "config_irq_work": 10110, "config_irqsoff_tracer": 10111, "config_kallsyms": 10112, "config_kallsyms_all": 10113, "config_kdb_continue_catastrophic": 10114, "config_kdb_default_enable": 10115, "config_kexec": 10116, "config_kexec_file": 10117, "config_kexec_jump": 10118, "config_kexec_verify_sig": 10119, "config_keys": 10120, "config_kgdb_kdb": 10121, "config_kmemcheck": 10122, "config_kprobe_event": 10123, "config_kprobes_on_ftrace": 10124, "config_kretprobes": 10125, "config_latencytop": 10126, "config_lock_stat": 10127, "config_lockdep": 10128, "config_lockup_detector": 10129, "config_magic_sysrq": 10130, "config_magic_sysrq_default_enable": 10131, "config_mathemu": 10132, "config_memcg": 10133, "config_memory_failure": 10134, "config_memory_hotremove": 10135, "config_mmu": 10136, "config_module_force_load": 10137, "config_module_force_unload": 10138, "config_module_sig": 10139, "config_module_unload": 10140, "config_modules": 10141, "config_modversions": 10142, "config_mpu": 10143, "config_multiuser": 10144, "config_mutex_spin_on_owner": 10145, "config_net": 10146, "config_no_hz_common": 10147, "config_no_hz_full": 10148, "config_no_hz_full_sysidle": 10149, "config_no_hz_full_sysidle_small": 10150, "config_nop_tracer": 10151, "config_nr_cpus": 10152, "config_ntp_pps": 10153, "config_numa": 10154, "config_numa_balancing": 10155, "config_odd_rt_sigaction": 10156, "config_old_sigaction": 10157, "config_old_sigsuspend": 10158, "config_old_sigsuspend3": 10159, "config_optprobes": 10160, "config_panic_on_oops_value": 10161, "config_panic_timeout": 10162, "config_paravirt": 10163, "config_paravirt_time_accounting": 10164, "config_perf_events": 10165, "config_perf_use_vmalloc": 10166, "config_persistent_keyrings": 10167, "config_pid_ns": 10168, "config_pm": 10169, "config_pm_autosleep": 10170, "config_pm_debug": 10171, "config_pm_sleep": 10172, "config_pm_sleep_smp": 10173, "config_pm_std_partition": 10174, "config_pm_test_suspend": 10175, "config_pm_wakelocks": 10176, "config_pm_wakelocks_gc": 10177, "config_pm_wakelocks_limit": 10178, "config_posix_mqueue": 10179, "config_preempt": 10180, "config_preempt_notifiers": 10181, "config_preempt_rcu": 10182, "config_preempt_tracer": 10183, "config_printk": 10184, "config_proc_fs": 10185, "config_proc_pid_cpuset": 10186, "config_proc_sysctl": 10187, "config_profile_all_branches": 10188, "config_profiling": 10189, "config_prove_locking": 10190, "config_prove_rcu": 10191, "config_prove_rcu_repeatedly": 10192, "config_randomize_base": 10193, "config_rcu_boost": 10194, "config_rcu_boost_delay": 10195, "config_rcu_cpu_stall_info": 10196, "config_rcu_cpu_stall_timeout": 10197, "config_rcu_expedite_boot": 10198, "config_rcu_fanout": 10199, "config_rcu_fanout_exact": 10200, "config_rcu_fanout_leaf": 10201, "config_rcu_fast_no_hz": 10202, "config_rcu_kthread_prio": 10203, "config_rcu_nocb_cpu": 10204, "config_rcu_nocb_cpu_all": 10205, "config_rcu_nocb_cpu_none": 10206, "config_rcu_nocb_cpu_zero": 10207, "config_rcu_stall_common": 10208, "config_rcu_torture_test_runnable": 10209, "config_rcu_torture_test_slow_init": 10210, "config_rcu_torture_test_slow_init_delay": 10211, "config_rcu_trace": 10212, "config_rcu_user_qs": 10213, "config_ring_buffer_allow_swap": 10214, "config_ring_buffer_startup_test": 10215, "config_rt_group_sched": 10216, "config_rt_mutex_tester": 10217, "config_rt_mutexes": 10218, "config_rtc_class": 10219, "config_rtc_hctosys_device": 10220, "config_rwsem_spin_on_owner": 10221, "config_s390": 10222, "config_sched_autogroup": 10223, "config_sched_debug": 10224, "config_sched_hrtick": 10225, "config_sched_mc": 10226, "config_sched_smt": 10227, "config_sched_stack_end_check": 10228, "config_sched_tracer": 10229, "config_schedstats": 10230, "config_seccomp": 10231, "config_seccomp_filter": 10232, "config_security": 10233, "config_security_selinux": 10234, "config_sgetmask_syscall": 10235, "config_smp": 10236, "config_sparc": 10237, "config_sparc64": 10238, "config_sparse_irq": 10239, "config_srcu": 10240, "config_stack_growsup": 10241, "config_stack_tracer": 10242, "config_stacktrace": 10243, "config_stop_machine": 10244, "config_strict_devmem": 10245, "config_superh": 10246, "config_suspend": 10247, "config_suspend_freezer": 10248, "config_sysctl": 10249, "config_sysctl_arch_unalign_allow": 10250, "config_sysctl_arch_unalign_no_warn": 10251, "config_sysctl_exception_trace": 10252, "config_sysctl_syscall": 10253, "config_sysfs": 10254, "config_sysvipc": 10255, "config_task_delay_acct": 10256, "config_task_io_accounting": 10257, "config_task_xacct": 10258, "config_tasks_rcu": 10259, "config_tick_oneshot": 10260, "config_timer_stats": 10261, "config_tiny_rcu": 10262, "config_trace_enum_map_file": 10263, "config_trace_irqflags": 10264, "config_tracepoints": 10265, "config_tracer_max_trace": 10266, "config_tracer_snapshot": 10267, "config_tracing": 10268, "config_transparent_hugepage": 10269, "config_tree_rcu": 10270, "config_uevent_helper": 10271, "config_uml": 10272, "config_unicore32": 10273, "config_uninline_spin_unlock": 10274, "config_unused_symbols": 10275, "config_user_ns": 10276, "config_virt_cpu_accounting": 10277, "config_virt_cpu_accounting_gen": 10278, "config_virt_cpu_accounting_native": 10279, "config_vsyscall": 10280, "config_x86": 10281, "config_x86_32": 10282, "config_x86_64": 10283, "config_x86_local_apic": 10284, "configured": 10285, "conflict": 10286, "connects": 10287, "console": 10288, "console_cmdline": 10289, "console_drivers": 10290, "console_idx": 10291, "console_lock_dep_map": 10292, "console_locked": 10293, "console_loglevel": 10294, "console_loglevel_default": 10295, "console_loglevel_min": 10296, "console_loglevel_motormouth": 10297, "console_may_schedule": 10298, "console_prev": 10299, "console_printk": 10300, "console_sem": 10301, "console_seq": 10302, "console_set_on_cmdline": 10303, "console_suspended": 10304, "console_verbose": 10305, "const": 10306, "const_debug": 10307, "const_imm": 10308, "const_ptr_to_map": 10309, "constant": 10310, "constraint": 10311, "constraints": 10312, "consume": 10313, "consume_skb": 10314, "consumer": 10315, "consumer_add": 10316, "consumer_del": 10317, "consumer_fifo": 10318, "consumer_filter": 10319, "consumer_nice": 10320, "consumer_rwsem": 10321, "consumers": 10322, "consuming": 10323, "cont": 10324, "cont_jmp": 10325, "container": 10326, "container_of": 10327, "containing": 10328, "contending_lock": 10329, "contending_point": 10330, "content": 10331, "contention_point": 10332, "contents": 10333, "context": 10334, "context_equiv": 10335, "context_kernel": 10336, "context_switch": 10337, "context_tracking": 10338, "context_tracking_cpu_set": 10339, "context_tracking_enabled": 10340, "context_tracking_enter": 10341, "context_tracking_exit": 10342, "context_tracking_in_user": 10343, "context_tracking_init": 10344, "context_tracking_is_enabled": 10345, "context_tracking_task_switch": 10346, "context_tracking_user_enter": 10347, "context_tracking_user_exit": 10348, "context_user": 10349, "continue": 10350, "continue_balancing": 10351, "contrib": 10352, "contrib_delta": 10353, "contribution": 10354, "contributions": 10355, "control": 10356, "control_code_page": 10357, "control_ops": 10358, "control_ops_alloc": 10359, "control_ops_disable_all": 10360, "control_ops_free": 10361, "control_page": 10362, "control_pages": 10363, "conv": 10364, "convdiv": 10365, "convert": 10366, "convert_ctx_access": 10367, "convert_ctx_accesses": 10368, "convert_kthread_status": 10369, "convert_pseudo_ld_imm64": 10370, "convert_rloc_to_loc": 10371, "convert_to_gcda": 10372, "convmul": 10373, "cookie": 10374, "cookies": 10375, "copied": 10376, "copy": 10377, "copy_bm": 10378, "copy_chunk_size": 10379, "copy_chunked_from_user": 10380, "copy_creds": 10381, "copy_data_pages": 10382, "copy_file_from_fd": 10383, "copy_files": 10384, "copy_from_page": 10385, "copy_from_user": 10386, "copy_fs": 10387, "copy_fs_struct": 10388, "copy_highpage": 10389, "copy_insn": 10390, "copy_io": 10391, "copy_ipcs": 10392, "copy_kprobe": 10393, "copy_last_highmem_page": 10394, "copy_mm": 10395, "copy_mnt_ns": 10396, "copy_module_from_fd": 10397, "copy_module_from_user": 10398, "copy_namespaces": 10399, "copy_net_ns": 10400, "copy_page": 10401, "copy_page_range": 10402, "copy_pid_ns": 10403, "copy_process": 10404, "copy_regset_from_user": 10405, "copy_regset_to_user": 10406, "copy_seccomp": 10407, "copy_semundo": 10408, "copy_sighand": 10409, "copy_siginfo": 10410, "copy_siginfo_from_user32": 10411, "copy_siginfo_to_user": 10412, "copy_siginfo_to_user32": 10413, "copy_signal": 10414, "copy_thread": 10415, "copy_to_page": 10416, "copy_to_user": 10417, "copy_user_segment_list": 10418, "copy_utsname": 10419, "copy_workqueue_attrs": 10420, "copybytes": 10421, "core_initcall": 10422, "core_internal_state__do_not_mess_with_it": 10423, "core_kernel_data": 10424, "core_kernel_text": 10425, "core_note_type": 10426, "core_num_syms": 10427, "core_param": 10428, "core_pattern": 10429, "core_pipe_limit": 10430, "core_ro_size": 10431, "core_size": 10432, "core_state": 10433, "core_strtab": 10434, "core_symtab": 10435, "core_text_size": 10436, "core_uses_pid": 10437, "coredump_filter_setup": 10438, "coredump_params": 10439, "coremem": 10440, "corename_max_size": 10441, "coresize": 10442, "correct": 10443, "correct_hw_break": 10444, "correction": 10445, "corrupted": 10446, "coublock": 10447, "could": 10448, "count": 10449, "count_data_pages": 10450, "count_fls": 10451, "count_free_highmem_pages": 10452, "count_highmem_image_pages": 10453, "count_highmem_pages": 10454, "count_lazy": 10455, "count_leafs": 10456, "count_leafs_cb": 10457, "count_matching_names": 10458, "count_overruns": 10459, "count_pages_for_highmem": 10460, "count_preds": 10461, "counter": 10462, "counter_active": 10463, "counters": 10464, "counts": 10465, "covered": 10466, "cp": 10467, "cp2": 10468, "cpl": 10469, "cpp": 10470, "cprm": 10471, "cprv": 10472, "cpu": 10473, "cpu0": 10474, "cpu0_err": 10475, "cpu1": 10476, "cpu2": 10477, "cpu_a": 10478, "cpu_access_lock": 10479, "cpu_active": 10480, "cpu_active_bits": 10481, "cpu_active_mask": 10482, "cpu_add_remove_lock": 10483, "cpu_all_bits": 10484, "cpu_all_mask": 10485, "cpu_attach_domain": 10486, "cpu_avg_load_per_task": 10487, "cpu_b": 10488, "cpu_base": 10489, "cpu_bit_bitmap": 10490, "cpu_bits_all": 10491, "cpu_broken": 10492, "cpu_buffer": 10493, "cpu_buffer_a": 10494, "cpu_buffer_b": 10495, "cpu_busy": 10496, "cpu_callback": 10497, "cpu_capacity": 10498, "cpu_capacity_orig": 10499, "cpu_cfs_period_read_u64": 10500, "cpu_cfs_period_write_u64": 10501, "cpu_cfs_quota_read_s64": 10502, "cpu_cfs_quota_write_s64": 10503, "cpu_cgroup_attach": 10504, "cpu_cgroup_can_attach": 10505, "cpu_cgroup_css_alloc": 10506, "cpu_cgroup_css_free": 10507, "cpu_cgroup_css_offline": 10508, "cpu_cgroup_css_online": 10509, "cpu_cgroup_exit": 10510, "cpu_cgroup_fork": 10511, "cpu_cgrp_id": 10512, "cpu_cgrp_subsys": 10513, "cpu_chain": 10514, "cpu_check_up_prepare": 10515, "cpu_clk": 10516, "cpu_clock": 10517, "cpu_cluster_pm_enter": 10518, "cpu_cluster_pm_enter_failed": 10519, "cpu_cluster_pm_exit": 10520, "cpu_core_flags": 10521, "cpu_coregroup_mask": 10522, "cpu_count": 10523, "cpu_cpu_mask": 10524, "cpu_ctx_sched_in": 10525, "cpu_ctx_sched_out": 10526, "cpu_curr": 10527, "cpu_current": 10528, "cpu_data": 10529, "cpu_dead": 10530, "cpu_dead_frozen": 10531, "cpu_dead_idle": 10532, "cpu_delay_total": 10533, "cpu_dma_constraints": 10534, "cpu_dma_lat_notifier": 10535, "cpu_dma_pm_qos": 10536, "cpu_dont_care": 10537, "cpu_down": 10538, "cpu_down_failed": 10539, "cpu_down_failed_frozen": 10540, "cpu_down_prepare": 10541, "cpu_down_prepare_frozen": 10542, "cpu_dying": 10543, "cpu_dying_frozen": 10544, "cpu_dying_idle": 10545, "cpu_entries": 10546, "cpu_entry": 10547, "cpu_extra": 10548, "cpu_file": 10549, "cpu_files": 10550, "cpu_function_call": 10551, "cpu_going_down": 10552, "cpu_hardirq_time": 10553, "cpu_has_callbacks_ready_to_invoke": 10554, "cpu_hotplug": 10555, "cpu_hotplug_begin": 10556, "cpu_hotplug_disable": 10557, "cpu_hotplug_disabled": 10558, "cpu_hotplug_done": 10559, "cpu_hotplug_enable": 10560, "cpu_hotplug_pm_callback": 10561, "cpu_hotplug_pm_sync_init": 10562, "cpu_hotplug_state": 10563, "cpu_i": 10564, "cpu_id": 10565, "cpu_idle": 10566, "cpu_idle_force_poll": 10567, "cpu_idle_loop": 10568, "cpu_idle_poll": 10569, "cpu_idle_poll_ctrl": 10570, "cpu_idle_type": 10571, "cpu_idx": 10572, "cpu_index": 10573, "cpu_intensive": 10574, "cpu_is_hotpluggable": 10575, "cpu_is_offline": 10576, "cpu_isolated_map": 10577, "cpu_khz": 10578, "cpu_limit": 10579, "cpu_load": 10580, "cpu_load_idx_max": 10581, "cpu_lock_stats": 10582, "cpu_loop": 10583, "cpu_map": 10584, "cpu_maps_update_begin": 10585, "cpu_maps_update_done": 10586, "cpu_master_loop": 10587, "cpu_needs_another_gp": 10588, "cpu_newly_idle": 10589, "cpu_nfb": 10590, "cpu_node": 10591, "cpu_not_idle": 10592, "cpu_notifier": 10593, "cpu_notifier_register_begin": 10594, "cpu_notifier_register_done": 10595, "cpu_notify": 10596, "cpu_notify_nofail": 10597, "cpu_ns": 10598, "cpu_num": 10599, "cpu_of": 10600, "cpu_off": 10601, "cpu_online": 10602, "cpu_online_bits": 10603, "cpu_online_frozen": 10604, "cpu_online_mask": 10605, "cpu_pid_to_cpupid": 10606, "cpu_pm_enter": 10607, "cpu_pm_enter_failed": 10608, "cpu_pm_event": 10609, "cpu_pm_exit": 10610, "cpu_pm_init": 10611, "cpu_pm_notifier_chain": 10612, "cpu_pm_notifier_lock": 10613, "cpu_pm_notify": 10614, "cpu_pm_register_notifier": 10615, "cpu_pm_resume": 10616, "cpu_pm_suspend": 10617, "cpu_pm_syscore_ops": 10618, "cpu_pm_unregister_notifier": 10619, "cpu_pools": 10620, "cpu_possible": 10621, "cpu_possible_bits": 10622, "cpu_possible_mask": 10623, "cpu_post_dead": 10624, "cpu_present": 10625, "cpu_present_bits": 10626, "cpu_present_mask": 10627, "cpu_pri_cpuset_active": 10628, "cpu_pri_cpuset_inactive": 10629, "cpu_pri_migration": 10630, "cpu_pri_sched_active": 10631, "cpu_pri_sched_inactive": 10632, "cpu_pri_smpboot": 10633, "cpu_profile_flip": 10634, "cpu_profile_hits": 10635, "cpu_profiling": 10636, "cpu_pwqs": 10637, "cpu_relax": 10638, "cpu_relax_lowlatency": 10639, "cpu_report_state": 10640, "cpu_rq": 10641, "cpu_rt_period_read_uint": 10642, "cpu_rt_period_write_uint": 10643, "cpu_rt_runtime_read": 10644, "cpu_rt_runtime_write": 10645, "cpu_run_real_total": 10646, "cpu_run_virtual_total": 10647, "cpu_scaled_run_real_total": 10648, "cpu_sdc": 10649, "cpu_set_state_online": 10650, "cpu_shares_read_u64": 10651, "cpu_shares_write_u64": 10652, "cpu_smt_flags": 10653, "cpu_smt_mask": 10654, "cpu_softirq_time": 10655, "cpu_starting": 10656, "cpu_starting_frozen": 10657, "cpu_startup_entry": 10658, "cpu_stats": 10659, "cpu_stats_show": 10660, "cpu_stop_create": 10661, "cpu_stop_done": 10662, "cpu_stop_fn_t": 10663, "cpu_stop_init": 10664, "cpu_stop_init_done": 10665, "cpu_stop_park": 10666, "cpu_stop_queue_work": 10667, "cpu_stop_should_run": 10668, "cpu_stop_signal_done": 10669, "cpu_stop_threads": 10670, "cpu_stop_unpark": 10671, "cpu_stop_work": 10672, "cpu_stopper": 10673, "cpu_stopper_task": 10674, "cpu_stopper_thread": 10675, "cpu_tasks_frozen": 10676, "cpu_timers": 10677, "cpu_to_be16": 10678, "cpu_to_be32": 10679, "cpu_to_be64": 10680, "cpu_to_le16": 10681, "cpu_to_le32": 10682, "cpu_to_le64": 10683, "cpu_to_mem": 10684, "cpu_to_node": 10685, "cpu_up": 10686, "cpu_up_canceled": 10687, "cpu_up_canceled_frozen": 10688, "cpu_up_prepare": 10689, "cpu_up_prepare_frozen": 10690, "cpu_vfs_cap_data": 10691, "cpu_wait_death": 10692, "cpu_worker_pools": 10693, "cpuacct": 10694, "cpuacct_account_field": 10695, "cpuacct_cgrp_id": 10696, "cpuacct_cgrp_subsys": 10697, "cpuacct_charge": 10698, "cpuacct_cpuusage_read": 10699, "cpuacct_cpuusage_write": 10700, "cpuacct_css_alloc": 10701, "cpuacct_css_free": 10702, "cpuacct_percpu_seq_show": 10703, "cpuacct_stat_desc": 10704, "cpuacct_stat_index": 10705, "cpuacct_stat_nstats": 10706, "cpuacct_stat_system": 10707, "cpuacct_stat_user": 10708, "cpuacct_stats_show": 10709, "cpubuf_idx": 10710, "cpuclock_prof": 10711, "cpuclock_virt": 10712, "cpuctx": 10713, "cpudl": 10714, "cpudl_change_key": 10715, "cpudl_cleanup": 10716, "cpudl_clear_freecpu": 10717, "cpudl_exchange": 10718, "cpudl_find": 10719, "cpudl_heapify": 10720, "cpudl_init": 10721, "cpudl_item": 10722, "cpudl_maximum": 10723, "cpudl_set": 10724, "cpudl_set_freecpu": 10725, "cpudump": 10726, "cpudump_probe_ops": 10727, "cpuhp_lock_acquire": 10728, "cpuhp_lock_acquire_read": 10729, "cpuhp_lock_acquire_tryread": 10730, "cpuhp_lock_release": 10731, "cpuhp_state": 10732, "cpuidle_enter": 10733, "cpuidle_find_deepest_state": 10734, "cpuidle_idle_call": 10735, "cpuidle_reflect": 10736, "cpuidle_select": 10737, "cpuidle_state": 10738, "cpulist_parse": 10739, "cpumask": 10740, "cpumask_and": 10741, "cpumask_andnot": 10742, "cpumask_any": 10743, "cpumask_any_and": 10744, "cpumask_bits": 10745, "cpumask_change_notifier": 10746, "cpumask_clear": 10747, "cpumask_clear_cpu": 10748, "cpumask_copy": 10749, "cpumask_empty": 10750, "cpumask_equal": 10751, "cpumask_first": 10752, "cpumask_first_and": 10753, "cpumask_intersects": 10754, "cpumask_next": 10755, "cpumask_next_and": 10756, "cpumask_of": 10757, "cpumask_of_node": 10758, "cpumask_or": 10759, "cpumask_parse": 10760, "cpumask_parse_user": 10761, "cpumask_parselist_user": 10762, "cpumask_pr_args": 10763, "cpumask_set_cpu": 10764, "cpumask_setall": 10765, "cpumask_size": 10766, "cpumask_subset": 10767, "cpumask_t": 10768, "cpumask_test_and_clear_cpu": 10769, "cpumask_test_and_set_cpu": 10770, "cpumask_test_cpu": 10771, "cpumask_type": 10772, "cpumask_var_t": 10773, "cpumask_weight": 10774, "cpunum": 10775, "cpup": 10776, "cpupid": 10777, "cpupid_match_pid": 10778, "cpupid_pid_unset": 10779, "cpupid_to_cpu": 10780, "cpupid_to_nid": 10781, "cpupri": 10782, "cpupri_cleanup": 10783, "cpupri_find": 10784, "cpupri_init": 10785, "cpupri_invalid": 10786, "cpupri_set": 10787, "cpus": 10788, "cpus_allowed": 10789, "cpus_attach": 10790, "cpus_share_cache": 10791, "cpus_updated": 10792, "cpuset": 10793, "cpuset_attach": 10794, "cpuset_attach_nodemask_to": 10795, "cpuset_attach_old_cs": 10796, "cpuset_attach_wq": 10797, "cpuset_being_rebound": 10798, "cpuset_bind": 10799, "cpuset_can_attach": 10800, "cpuset_cancel_attach": 10801, "cpuset_cgrp_id": 10802, "cpuset_cgrp_subsys": 10803, "cpuset_change_task_nodemask": 10804, "cpuset_clone_children": 10805, "cpuset_common_seq_show": 10806, "cpuset_cpu_active": 10807, "cpuset_cpu_inactive": 10808, "cpuset_cpumask_can_shrink": 10809, "cpuset_cpus_allowed": 10810, "cpuset_cpus_allowed_fallback": 10811, "cpuset_css_alloc": 10812, "cpuset_css_free": 10813, "cpuset_css_offline": 10814, "cpuset_css_online": 10815, "cpuset_dec": 10816, "cpuset_filetype_t": 10817, "cpuset_flagbits_t": 10818, "cpuset_for_each_child": 10819, "cpuset_for_each_descendant_pre": 10820, "cpuset_fs_type": 10821, "cpuset_hotplug_update_tasks": 10822, "cpuset_hotplug_work": 10823, "cpuset_hotplug_workfn": 10824, "cpuset_inc": 10825, "cpuset_init": 10826, "cpuset_init_current_mems_allowed": 10827, "cpuset_init_smp": 10828, "cpuset_mem_spread_node": 10829, "cpuset_mem_spread_rotor": 10830, "cpuset_memory_pressure_enabled": 10831, "cpuset_mems_allowed": 10832, "cpuset_mems_allowed_intersects": 10833, "cpuset_migrate_mm": 10834, "cpuset_mount": 10835, "cpuset_mutex": 10836, "cpuset_nodemask_valid_mems_allowed": 10837, "cpuset_print_task_mems_allowed": 10838, "cpuset_read_s64": 10839, "cpuset_read_u64": 10840, "cpuset_slab_spread_node": 10841, "cpuset_slab_spread_rotor": 10842, "cpuset_spread_node": 10843, "cpuset_task_status_allowed": 10844, "cpuset_track_online_nodes": 10845, "cpuset_track_online_nodes_nb": 10846, "cpuset_update_active_cpus": 10847, "cpuset_update_task_spread_flag": 10848, "cpuset_write_resmask": 10849, "cpuset_write_s64": 10850, "cpuset_write_u64": 10851, "cpusets_enabled_key": 10852, "cpusets_overlap": 10853, "cpustat": 10854, "cpustride": 10855, "cputime": 10856, "cputime64_to_clock_t": 10857, "cputime_adjust": 10858, "cputime_advance": 10859, "cputime_expires": 10860, "cputime_guest": 10861, "cputime_guest_nice": 10862, "cputime_idle": 10863, "cputime_iowait": 10864, "cputime_irq": 10865, "cputime_nice": 10866, "cputime_one_jiffy": 10867, "cputime_scaled": 10868, "cputime_softirq": 10869, "cputime_steal": 10870, "cputime_sub_ns": 10871, "cputime_system": 10872, "cputime_t": 10873, "cputime_to_clock_t": 10874, "cputime_to_jiffies": 10875, "cputime_to_nsecs": 10876, "cputime_to_scaled": 10877, "cputime_to_timespec": 10878, "cputime_to_timeval": 10879, "cputime_to_usecs": 10880, "cputime_user": 10881, "cputimer": 10882, "cputimer_running": 10883, "cpuusage": 10884, "cpuusage_read": 10885, "cpuusage_write": 10886, "cpy_name": 10887, "cq": 10888, "cq_depth": 10889, "cq_mask": 10890, "cr": 10891, "crash_base": 10892, "crash_free_reserved_phys_range": 10893, "crash_get_memory_size": 10894, "crash_kexec": 10895, "crash_kexec_post_notifiers": 10896, "crash_map_reserved_pages": 10897, "crash_notes": 10898, "crash_notes_memory_init": 10899, "crash_save_cpu": 10900, "crash_save_vmcoreinfo": 10901, "crash_setup_regs": 10902, "crash_shrink_memory": 10903, "crash_size": 10904, "crash_unmap_reserved_pages": 10905, "crashk_low_res": 10906, "crashk_res": 10907, "crc": 10908, "crc32": 10909, "crc32_le": 10910, "crc32_threadfn": 10911, "crc_data": 10912, "crc_owner": 10913, "crcs": 10914, "create": 10915, "create_basic_memory_bitmaps": 10916, "create_buf_file": 10917, "create_chunk": 10918, "create_cooldown": 10919, "create_css": 10920, "create_event_filter": 10921, "create_event_toplevel_files": 10922, "create_filter": 10923, "create_filter_finish": 10924, "create_filter_start": 10925, "create_hash_tables": 10926, "create_image": 10927, "create_kthread": 10928, "create_mem_extents": 10929, "create_new_namespaces": 10930, "create_new_subsystem": 10931, "create_nsproxy": 10932, "create_pid_cachep": 10933, "create_pid_namespace": 10934, "create_pred": 10935, "create_proc_profile": 10936, "create_prof_cpu_mask": 10937, "create_reader": 10938, "create_singlethread_workqueue": 10939, "create_system_filter": 10940, "create_trace_kprobe": 10941, "create_trace_points": 10942, "create_trace_uprobe": 10943, "create_user_ns": 10944, "create_uts_ns": 10945, "create_worker": 10946, "create_zone_bm_rtree": 10947, "created_timer_id": 10948, "createfn": 10949, "creation": 10950, "cred": 10951, "cred_alloc_blank": 10952, "cred_cap_issubset": 10953, "cred_guard_mutex": 10954, "cred_init": 10955, "cred_jar": 10956, "cred_magic": 10957, "cred_magic_dead": 10958, "credentials": 10959, "creds": 10960, "creds_are_invalid": 10961, "crf": 10962, "critical_end": 10963, "critical_sequence": 10964, "critical_start": 10965, "crypto_shash": 10966, "crypto_shash_final": 10967, "crypto_shash_init": 10968, "crypto_shash_update": 10969, "cs": 10970, "cs_cpu_exclusive": 10971, "cs_cpus_allowed": 10972, "cs_last": 10973, "cs_mem_exclusive": 10974, "cs_mem_hardwall": 10975, "cs_memory_migrate": 10976, "cs_name_len": 10977, "cs_now": 10978, "cs_online": 10979, "cs_sched_load_balance": 10980, "cs_spread_page": 10981, "cs_spread_slab": 10982, "csa": 10983, "csd": 10984, "csd_data": 10985, "csd_flag_lock": 10986, "csd_flag_synchronous": 10987, "csd_lock": 10988, "csd_lock_wait": 10989, "csd_next": 10990, "csd_stack": 10991, "csd_unlock": 10992, "cset": 10993, "cset_cgroup_from_root": 10994, "cset_head": 10995, "cset_link": 10996, "cset_links": 10997, "cset_pos": 10998, "csets": 10999, "csignal": 11000, "csn": 11001, "css": 11002, "css_advance_task_iter": 11003, "css_alloc": 11004, "css_ca": 11005, "css_cs": 11006, "css_disable": 11007, "css_e_css_changed": 11008, "css_enable": 11009, "css_for_each_child": 11010, "css_for_each_descendant_post": 11011, "css_for_each_descendant_pre": 11012, "css_free": 11013, "css_free_rcu_fn": 11014, "css_free_work_fn": 11015, "css_freezer": 11016, "css_from_id": 11017, "css_get": 11018, "css_has_online_children": 11019, "css_idr": 11020, "css_killed_ref_fn": 11021, "css_killed_work_fn": 11022, "css_leftmost_descendant": 11023, "css_next_child": 11024, "css_next_descendant_post": 11025, "css_next_descendant_pre": 11026, "css_no_ref": 11027, "css_offline": 11028, "css_online": 11029, "css_put": 11030, "css_release": 11031, "css_release_work_fn": 11032, "css_released": 11033, "css_reset": 11034, "css_rightmost_descendant": 11035, "css_serial_nr_next": 11036, "css_set": 11037, "css_set_count": 11038, "css_set_hash": 11039, "css_set_hash_bits": 11040, "css_set_rwsem": 11041, "css_set_table": 11042, "css_task_iter": 11043, "css_task_iter_end": 11044, "css_task_iter_next": 11045, "css_task_iter_start": 11046, "css_tg": 11047, "css_tryget": 11048, "css_tryget_online": 11049, "css_tryget_online_from_dir": 11050, "cstime": 11051, "ct": 11052, "ct_idx": 11053, "ctime": 11054, "ctl_abi": 11055, "ctl_bus": 11056, "ctl_bus_isa": 11057, "ctl_dev": 11058, "ctl_dir": 11059, "ctl_dnadr": 11060, "ctl_fs": 11061, "ctl_int": 11062, "ctl_kern": 11063, "ctl_max_resvport": 11064, "ctl_maxname": 11065, "ctl_min_resvport": 11066, "ctl_name": 11067, "ctl_net": 11068, "ctl_path": 11069, "ctl_pm": 11070, "ctl_s390dbf": 11071, "ctl_slottable_tcp": 11072, "ctl_slottable_udp": 11073, "ctl_str": 11074, "ctl_sunrpc": 11075, "ctl_table": 11076, "ctl_table_header": 11077, "ctl_ulong": 11078, "ctl_uuid": 11079, "ctl_vm": 11080, "ctors": 11081, "ctr": 11082, "ctr_mask": 11083, "ctr_type": 11084, "ctrl_n": 11085, "ctrl_p": 11086, "ctrs": 11087, "cts": 11088, "ctv": 11089, "ctx": 11090, "ctx1": 11091, "ctx2": 11092, "ctx_flexible_sched_in": 11093, "ctx_pinned_sched_in": 11094, "ctx_sched_in": 11095, "ctx_sched_out": 11096, "ctx_state": 11097, "ctx_switch_entry": 11098, "ctx_time": 11099, "ctxn": 11100, "cu": 11101, "cur": 11102, "cur_cset": 11103, "cur_dl_b": 11104, "cur_ld_moved": 11105, "cur_ops": 11106, "cur_ret": 11107, "cur_setting": 11108, "cur_ss_mask": 11109, "cur_stack": 11110, "cur_state": 11111, "cur_swap": 11112, "cur_task": 11113, "cur_uprobe": 11114, "curdev": 11115, "curr": 11116, "curr_chain_key": 11117, "curr_cost": 11118, "curr_cpu": 11119, "curr_distance": 11120, "curr_jiffies": 11121, "curr_load_addr": 11122, "curr_operand": 11123, "curr_ret_stack": 11124, "curr_target": 11125, "curr_value": 11126, "current": 11127, "current_chrooted": 11128, "current_clr_polling_and_test": 11129, "current_context": 11130, "current_cpuset_is_being_rebound": 11131, "current_cred": 11132, "current_css_set_cg_links_read": 11133, "current_css_set_read": 11134, "current_css_set_refcount_read": 11135, "current_device": 11136, "current_egid": 11137, "current_euid": 11138, "current_fs_time": 11139, "current_fsgid": 11140, "current_fsuid": 11141, "current_func": 11142, "current_gid": 11143, "current_is_async": 11144, "current_is_workqueue_rescuer": 11145, "current_kernel_time": 11146, "current_pwq": 11147, "current_state": 11148, "current_thread_info": 11149, "current_time": 11150, "current_trace": 11151, "current_tracer": 11152, "current_uid": 11153, "current_uid_gid": 11154, "current_user": 11155, "current_user_ns": 11156, "current_user_stack_pointer": 11157, "current_work": 11158, "current_wq_worker": 11159, "cursor": 11160, "curstate": 11161, "curtail": 11162, "curtask": 11163, "cutime": 11164, "cv_idx": 11165, "cv_size": 11166, "cval": 11167, "cwait": 11168, "cwt_wait": 11169, "cwt_wakefn": 11170, "cxt": 11171, "cycle": 11172, "cycle_delta": 11173, "cycle_interval": 11174, "cycle_last": 11175, "cycle_now": 11176, "cycle_t": 11177, "cycle_tstamp": 11178, "cyclecounter": 11179, "cyclecounter_cyc2ns": 11180, "cycles": 11181, "cycles_at_suspend": 11182, "d": 11183, "d_backing_inode": 11184, "d_child": 11185, "d_events": 11186, "d_inode": 11187, "d_is_positive": 11188, "d_lock": 11189, "d_name": 11190, "d_parent": 11191, "d_path": 11192, "d_really_is_positive": 11193, "d_sb": 11194, "d_subdirs": 11195, "d_tracer": 11196, "d_tracing": 11197, "dac_mmap_min_addr": 11198, "daemon": 11199, "dah_align": 11200, "dah_first": 11201, "dah_first_call": 11202, "dah_overhead": 11203, "dah_used": 11204, "dah_used_max": 11205, "dap_lock": 11206, "dap_locked": 11207, "dash2underscore": 11208, "dat": 11209, "data": 11210, "data_cnt": 11211, "data_head": 11212, "data_len": 11213, "data_of": 11214, "data_offset": 11215, "data_page": 11216, "data_page_nr": 11217, "data_pages": 11218, "data_rec": 11219, "data_size": 11220, "data_src": 11221, "data_tail": 11222, "data_type": 11223, "datalp": 11224, "dataof_trace_entry": 11225, "datap": 11226, "dataptr": 11227, "datasz": 11228, "datavp": 11229, "dattr": 11230, "dattr_cur": 11231, "day": 11232, "days": 11233, "db_result": 11234, "dbg_activate_sw_breakpoints": 11235, "dbg_deactivate_sw_breakpoints": 11236, "dbg_get_reg": 11237, "dbg_io_get_char": 11238, "dbg_io_ops": 11239, "dbg_is_early": 11240, "dbg_kdb_mode": 11241, "dbg_late_init": 11242, "dbg_master_lock": 11243, "dbg_max_reg_num": 11244, "dbg_module_load_nb": 11245, "dbg_notify_reboot": 11246, "dbg_pass_event": 11247, "dbg_reboot_notifier": 11248, "dbg_reg_def": 11249, "dbg_remove_all_break": 11250, "dbg_remove_sw_break": 11251, "dbg_set_reg": 11252, "dbg_set_sw_break": 11253, "dbg_slave_lock": 11254, "dbg_switch_cpu": 11255, "dbg_switch_cpu_event": 11256, "dbg_touch_watchdogs": 11257, "dci_ptr": 11258, "dcount": 11259, "dcpu_is_slave": 11260, "dcpu_next_master": 11261, "dcpu_sstep": 11262, "dcpu_want_master": 11263, "ddebug_add_module": 11264, "ddebug_cleanup": 11265, "ddebug_dyndbg_module_param_cb": 11266, "ddebug_remove_module": 11267, "ddir_act": 11268, "de": 11269, "deactivate": 11270, "deactivate_mm": 11271, "deactivate_super": 11272, "deactivate_task": 11273, "dead": 11274, "dead_cpu": 11275, "deadcpu": 11276, "deadline": 11277, "deadlock": 11278, "deadlock_inject_countdown": 11279, "deadlock_inject_interval": 11280, "deadlock_lock": 11281, "deadlock_task_pid": 11282, "debug": 11283, "debug_activate": 11284, "debug_align": 11285, "debug_alloc_header": 11286, "debug_alloc_pool": 11287, "debug_alloc_pool_aligned": 11288, "debug_assert_init": 11289, "debug_atomic_dec": 11290, "debug_atomic_inc": 11291, "debug_atomic_read": 11292, "debug_cgrp_subsys": 11293, "debug_check_no_locks_freed": 11294, "debug_check_no_locks_held": 11295, "debug_css_alloc": 11296, "debug_css_free": 11297, "debug_deactivate": 11298, "debug_files": 11299, "debug_hint": 11300, "debug_init": 11301, "debug_kfree": 11302, "debug_kmalloc": 11303, "debug_kusage": 11304, "debug_kusage_one_time": 11305, "debug_lock": 11306, "debug_lockdep_rcu_enabled": 11307, "debug_locks": 11308, "debug_locks_off": 11309, "debug_locks_off_graph_unlock": 11310, "debug_locks_silent": 11311, "debug_locks_warn_on": 11312, "debug_mutex_add_waiter": 11313, "debug_mutex_free_waiter": 11314, "debug_mutex_init": 11315, "debug_mutex_lock_common": 11316, "debug_mutex_unlock": 11317, "debug_mutex_wake_waiter": 11318, "debug_obj_descr": 11319, "debug_obj_state": 11320, "debug_object_activate": 11321, "debug_object_active_state": 11322, "debug_object_assert_init": 11323, "debug_object_deactivate": 11324, "debug_object_free": 11325, "debug_object_init": 11326, "debug_object_init_on_stack": 11327, "debug_rcu_head_queue": 11328, "debug_rcu_head_unqueue": 11329, "debug_rt_mutex_deadlock": 11330, "debug_rt_mutex_detect_deadlock": 11331, "debug_rt_mutex_free_waiter": 11332, "debug_rt_mutex_init": 11333, "debug_rt_mutex_init_waiter": 11334, "debug_rt_mutex_lock": 11335, "debug_rt_mutex_print_deadlock": 11336, "debug_rt_mutex_proxy_lock": 11337, "debug_rt_mutex_proxy_unlock": 11338, "debug_rt_mutex_reset_waiter": 11339, "debug_rt_mutex_unlock": 11340, "debug_shift": 11341, "debug_show_all_locks": 11342, "debug_show_held_locks": 11343, "debug_spin_lock_after": 11344, "debug_spin_lock_before": 11345, "debug_spin_unlock": 11346, "debug_table": 11347, "debug_taskcount_read": 11348, "debug_timer_activate": 11349, "debug_timer_assert_init": 11350, "debug_timer_deactivate": 11351, "debug_timer_free": 11352, "debug_timer_init": 11353, "debug_work_activate": 11354, "debug_work_deactivate": 11355, "debug_write_lock_after": 11356, "debug_write_lock_before": 11357, "debug_write_unlock": 11358, "debugfs": 11359, "debugfs_create_dir": 11360, "debugfs_create_file": 11361, "debugfs_create_symlink": 11362, "debugfs_filename": 11363, "debugfs_kprobe_blacklist_ops": 11364, "debugfs_kprobes_operations": 11365, "debugfs_remove": 11366, "debugfs_remove_recursive": 11367, "debuggerinfo": 11368, "debuggerinfo_struct": 11369, "debugging": 11370, "dec": 11371, "dec_data": 11372, "dec_mm_counter": 11373, "dec_rt_group": 11374, "dec_rt_migration": 11375, "dec_rt_prio": 11376, "dec_rt_prio_smp": 11377, "dec_rt_tasks": 11378, "decay_count": 11379, "decay_counter": 11380, "decay_load": 11381, "decay_load_missed": 11382, "decayed": 11383, "decays": 11384, "declare_basic_fetch_funcs": 11385, "declare_basic_print_type_func": 11386, "declare_bitmap": 11387, "declare_completion": 11388, "declare_completion_onstack": 11389, "declare_fetch_func": 11390, "declare_hashtable": 11391, "declare_per_cpu": 11392, "declare_per_cpu_shared_aligned": 11393, "declare_rwsem": 11394, "declare_tasklet": 11395, "declare_wait_queue_head": 11396, "declare_waitqueue": 11397, "declare_work": 11398, "decode_state": 11399, "decrement": 11400, "decrement_wakelocks_number": 11401, "decremented": 11402, "decrements": 11403, "def_dl_bandwidth": 11404, "def_flags": 11405, "def_root_domain": 11406, "def_rt_bandwidth": 11407, "default": 11408, "default_affinity_open": 11409, "default_affinity_proc_fops": 11410, "default_affinity_show": 11411, "default_affinity_write": 11412, "default_arch_gettimeoffset": 11413, "default_attrs": 11414, "default_bootup_tracer": 11415, "default_cfs_period": 11416, "default_cpu_time_max_percent": 11417, "default_dump_filter": 11418, "default_fetch_type": 11419, "default_fetch_type_str": 11420, "default_fs_overflowuid": 11421, "default_handle": 11422, "default_iterations": 11423, "default_label": 11424, "default_llseek": 11425, "default_max_sample_rate": 11426, "default_overflowgid": 11427, "default_overflowuid": 11428, "default_reboot_mode": 11429, "default_relax_domain_level": 11430, "default_sample_period_ns": 11431, "default_scale_cpu_capacity": 11432, "default_sys_filter_message": 11433, "default_timer_slack_ns": 11434, "default_topology": 11435, "default_value": 11436, "default_wake_function": 11437, "defcmd": 11438, "defcmd_in_progress": 11439, "defcmd_set": 11440, "defcmd_set_count": 11441, "deferred_free": 11442, "define": 11443, "define_basic_fetch_funcs": 11444, "define_basic_print_type_func": 11445, "define_comparison_pred": 11446, "define_equality_pred": 11447, "define_fetch_": 11448, "define_fetch_bitfield": 11449, "define_fetch_deref": 11450, "define_fetch_file_offset": 11451, "define_fetch_memory": 11452, "define_fetch_reg": 11453, "define_fetch_retval": 11454, "define_fetch_stack": 11455, "define_fetch_symbol": 11456, "define_field": 11457, "define_fields": 11458, "define_hashtable": 11459, "define_idr": 11460, "define_irq_work": 11461, "define_mutex": 11462, "define_per_cpu": 11463, "define_per_cpu_shared_aligned": 11464, "define_raw_spinlock": 11465, "define_rcu_tps": 11466, "define_rwlock": 11467, "define_semaphore": 11468, "define_spinlock": 11469, "define_srcu": 11470, "define_static_lglock": 11471, "define_static_srcu": 11472, "define_timer": 11473, "define_torture_random": 11474, "define_wait": 11475, "define_wait_atomic_t": 11476, "define_wait_bit": 11477, "defined": 11478, "degrade_factor": 11479, "degrade_shift": 11480, "degrade_zero_ticks": 11481, "del": 11482, "del_singleshot_timer_sync": 11483, "del_timer": 11484, "del_timer_sync": 11485, "del_usage_links": 11486, "delay": 11487, "delayacct_add_tsk": 11488, "delayacct_blkio_end": 11489, "delayacct_blkio_start": 11490, "delayacct_cache": 11491, "delayacct_end": 11492, "delayacct_init": 11493, "delayacct_is_task_waiting_on_io": 11494, "delayacct_on": 11495, "delayacct_pf_swapin": 11496, "delayacct_setup_disable": 11497, "delayacct_tsk_free": 11498, "delayacct_tsk_init": 11499, "delayed_free_pidns": 11500, "delayed_put_pid": 11501, "delayed_work": 11502, "delayed_work_pending": 11503, "delayed_work_timer_fn": 11504, "delayed_works": 11505, "delays": 11506, "delcount": 11507, "delete_all_elements": 11508, "delete_clock": 11509, "delete_irq_desc": 11510, "delete_module": 11511, "delete_uprobe": 11512, "delim": 11513, "delta": 11514, "delta_cpu": 11515, "delta_delta": 11516, "delta_exec": 11517, "delta_jiffies": 11518, "delta_ns": 11519, "delta_w": 11520, "dentry": 11521, "dentry_stat": 11522, "dep_gen_id": 11523, "dep_map": 11524, "dependencies": 11525, "dependency": 11526, "depends": 11527, "depends_on": 11528, "deprecated": 11529, "deprecated_sysctl_warning": 11530, "depth": 11531, "depth_irq": 11532, "dequeue": 11533, "dequeue_entity": 11534, "dequeue_entity_load_avg": 11535, "dequeue_pushable_task": 11536, "dequeue_rt_entity": 11537, "dequeue_rt_stack": 11538, "dequeue_signal": 11539, "dequeue_sleep": 11540, "dequeue_task": 11541, "dequeue_task_fair": 11542, "dequeue_task_idle": 11543, "dequeue_task_rt": 11544, "dequeue_top_rt_rq": 11545, "deref": 11546, "deref_fetch_param": 11547, "dereference_function_descriptor": 11548, "deregister": 11549, "des_cs": 11550, "desc": 11551, "desc_node": 11552, "desc_set_defaults": 11553, "desc_size": 11554, "desc_smp_init": 11555, "desc_valid": 11556, "description": 11557, "deskew": 11558, "desktop": 11559, "dest": 11560, "dest_cfs_rq": 11561, "dest_cpu": 11562, "dest_image": 11563, "dest_pages": 11564, "destination": 11565, "destroy": 11566, "destroy_cfs_bandwidth": 11567, "destroy_context": 11568, "destroy_delayed_work_on_stack": 11569, "destroy_dwork": 11570, "destroy_header_iter": 11571, "destroy_params": 11572, "destroy_pid_namespace": 11573, "destroy_rcu_head": 11574, "destroy_rcu_head_on_stack": 11575, "destroy_root": 11576, "destroy_rt_bandwidth": 11577, "destroy_sched_domain": 11578, "destroy_sched_domains": 11579, "destroy_session": 11580, "destroy_timer_on_stack": 11581, "destroy_work": 11582, "destroy_work_on_stack": 11583, "destroy_worker": 11584, "destroy_workqueue": 11585, "detach_completion": 11586, "detach_expired_timer": 11587, "detach_group": 11588, "detach_if_pending": 11589, "detach_one_task": 11590, "detach_pid": 11591, "detach_task": 11592, "detach_tasks": 11593, "detach_timer": 11594, "detached": 11595, "detected": 11596, "dev": 11597, "dev_attr_act_mask": 11598, "dev_attr_current_device": 11599, "dev_attr_enable": 11600, "dev_attr_end_lba": 11601, "dev_attr_pid": 11602, "dev_attr_start_lba": 11603, "dev_attr_unbind_device": 11604, "dev_dbg": 11605, "dev_err": 11606, "dev_get_by_index": 11607, "dev_groups": 11608, "dev_id": 11609, "dev_ipmi": 11610, "dev_ipmi_poweroff_powercycle": 11611, "dev_mac_hid": 11612, "dev_mac_hid_mouse_button2_keycode": 11613, "dev_mac_hid_mouse_button3_keycode": 11614, "dev_mac_hid_mouse_button_emulation": 11615, "dev_name": 11616, "dev_pm_ops": 11617, "dev_put": 11618, "dev_raid": 11619, "dev_raid_speed_limit_max": 11620, "dev_raid_speed_limit_min": 11621, "dev_scsi": 11622, "dev_scsi_logging_level": 11623, "dev_set_uevent_suppress": 11624, "dev_t": 11625, "dev_table": 11626, "dev_to_node": 11627, "dev_to_part": 11628, "dev_to_wq": 11629, "devfn": 11630, "device": 11631, "device_attr": 11632, "device_attr_ro": 11633, "device_attribute": 11634, "device_create_file": 11635, "device_from": 11636, "device_id": 11637, "device_initcall": 11638, "device_may_wakeup": 11639, "device_node": 11640, "device_register": 11641, "device_shutdown": 11642, "device_to": 11643, "device_unregister": 11644, "devices": 11645, "devid": 11646, "devm_region_match": 11647, "devm_region_release": 11648, "devm_release_resource": 11649, "devm_request_resource": 11650, "devm_resource_match": 11651, "devm_resource_release": 11652, "devname": 11653, "devres_add": 11654, "devres_alloc": 11655, "devres_destroy": 11656, "devres_free": 11657, "devres_release": 11658, "devtree": 11659, "df": 11660, "dfl_cftypes": 11661, "dfl_cgrp": 11662, "dfl_pwq": 11663, "dgc": 11664, "diag": 11665, "diagnostic": 11666, "dict_len": 11667, "did": 11668, "did_panic": 11669, "die": 11670, "die_args": 11671, "die_chain": 11672, "die_oops": 11673, "die_val": 11674, "diff": 11675, "digest": 11676, "dir": 11677, "dir_notify_enable": 11678, "direct": 11679, "direct_max": 11680, "directory": 11681, "dirty": 11682, "dirty_background_bytes": 11683, "dirty_background_bytes_handler": 11684, "dirty_background_ratio": 11685, "dirty_background_ratio_handler": 11686, "dirty_bytes_handler": 11687, "dirty_bytes_min": 11688, "dirty_expire_interval": 11689, "dirty_paused_when": 11690, "dirty_ratio_handler": 11691, "dirty_writeback_centisecs_handler": 11692, "dirty_writeback_interval": 11693, "dirtytime_expire_interval": 11694, "dirtytime_interval_handler": 11695, "disable": 11696, "disable_branch_profiling": 11697, "disable_branch_tracing": 11698, "disable_event": 11699, "disable_event_str": 11700, "disable_first": 11701, "disable_hardirq": 11702, "disable_hw_break": 11703, "disable_irq": 11704, "disable_irq_nosync": 11705, "disable_kprobe": 11706, "disable_kretprobe": 11707, "disable_mmiotrace": 11708, "disable_nonboot_cpus": 11709, "disable_percpu_irq": 11710, "disable_pid_allocation": 11711, "disable_reader": 11712, "disable_sched_clock_irqtime": 11713, "disable_trace_kprobe": 11714, "disable_trace_on_warning": 11715, "disable_tsc": 11716, "disabled": 11717, "disabled_wait": 11718, "disables": 11719, "disarm_kprobe": 11720, "disarm_kprobe_ftrace": 11721, "disarmed": 11722, "discard": 11723, "discovered": 11724, "disk_devt": 11725, "disk_show": 11726, "displaced": 11727, "display": 11728, "dist": 11729, "distance": 11730, "distribute_cfs_runtime": 11731, "div64_u64": 11732, "div64_u64_rem": 11733, "div64_ul": 11734, "div_factor": 11735, "div_round_closest": 11736, "div_round_up": 11737, "div_s64": 11738, "div_s64_rem": 11739, "div_u64": 11740, "div_u64_rem": 11741, "dividend": 11742, "divisor": 11743, "dj": 11744, "dl": 11745, "dl_b": 11746, "dl_bandwidth": 11747, "dl_bandwidth_enabled": 11748, "dl_boosted": 11749, "dl_bw": 11750, "dl_bw_cpus": 11751, "dl_bw_of": 11752, "dl_deadline": 11753, "dl_entity_preempt": 11754, "dl_new": 11755, "dl_nr_migratory": 11756, "dl_nr_running": 11757, "dl_overflow": 11758, "dl_param_changed": 11759, "dl_period": 11760, "dl_policy": 11761, "dl_prio": 11762, "dl_rq": 11763, "dl_runtime": 11764, "dl_runtime_lock": 11765, "dl_sched_class": 11766, "dl_se": 11767, "dl_task": 11768, "dl_throttled": 11769, "dl_time_before": 11770, "dl_yielded": 11771, "dlen": 11772, "dlo_count": 11773, "dlo_mask": 11774, "dma_chan": 11775, "dma_chan_busy": 11776, "dma_spin_lock": 11777, "dmanr": 11778, "dmesg_restrict": 11779, "dnaddr": 11780, "dname": 11781, "do": 11782, "do_acct_process": 11783, "do_adjtimex": 11784, "do_balance_runtime": 11785, "do_blk_trace_setup": 11786, "do_check": 11787, "do_coredump": 11788, "do_div": 11789, "do_each_pid_task": 11790, "do_each_pid_thread": 11791, "do_each_thread": 11792, "do_execve": 11793, "do_exit": 11794, "do_fault": 11795, "do_for_each_event_file": 11796, "do_for_each_event_file_safe": 11797, "do_for_each_ftrace_op": 11798, "do_for_each_ftrace_rec": 11799, "do_fork": 11800, "do_free_cleaned_kprobes": 11801, "do_free_init": 11802, "do_full_getstr": 11803, "do_futex": 11804, "do_getitimer": 11805, "do_gettimeofday": 11806, "do_group_exit": 11807, "do_init_module": 11808, "do_init_timer": 11809, "do_jobctl_trap": 11810, "do_kernel_restart": 11811, "do_kimage_alloc_init": 11812, "do_migrate_pages": 11813, "do_mod_ctors": 11814, "do_no_restart_syscall": 11815, "do_nocb_deferred_wakeup": 11816, "do_nothing": 11817, "do_notify_parent": 11818, "do_notify_parent_cldstop": 11819, "do_one_initcall": 11820, "do_optimize_kprobes": 11821, "do_poweroff": 11822, "do_print_state": 11823, "do_prlimit": 11824, "do_proc_dointvec": 11825, "do_proc_dointvec_conv": 11826, "do_proc_dointvec_jiffies_conv": 11827, "do_proc_dointvec_minmax_conv": 11828, "do_proc_dointvec_minmax_conv_param": 11829, "do_proc_doulongvec_minmax": 11830, "do_profile_hits": 11831, "do_raw_": 11832, "do_raw_read_lock": 11833, "do_raw_read_trylock": 11834, "do_raw_read_unlock": 11835, "do_raw_spin_lock": 11836, "do_raw_spin_lock_flags": 11837, "do_raw_spin_trylock": 11838, "do_raw_spin_unlock": 11839, "do_raw_write_lock": 11840, "do_raw_write_trylock": 11841, "do_raw_write_unlock": 11842, "do_rt_sigqueueinfo": 11843, "do_rt_tgsigqueueinfo": 11844, "do_sched_cfs_period_timer": 11845, "do_sched_cfs_slack_timer": 11846, "do_sched_rt_period_timer": 11847, "do_sched_setscheduler": 11848, "do_schedule_next_timer": 11849, "do_seccomp": 11850, "do_send_sig_info": 11851, "do_send_specific": 11852, "do_set_cpus_allowed": 11853, "do_setitimer": 11854, "do_settimeofday": 11855, "do_settimeofday64": 11856, "do_sigaction": 11857, "do_sigaltstack": 11858, "do_signal_stop": 11859, "do_sigpending": 11860, "do_sigtimedwait": 11861, "do_softirq": 11862, "do_softirq_own_stack": 11863, "do_switch": 11864, "do_sys_settimeofday": 11865, "do_sys_times": 11866, "do_sysctl": 11867, "do_sysinfo": 11868, "do_sysvsem": 11869, "do_test": 11870, "do_timer": 11871, "do_timer_last": 11872, "do_trace_rcu_torture_read": 11873, "do_trap": 11874, "do_unoptimize_kprobes": 11875, "do_usleep_range": 11876, "dodgy_cert": 11877, "does": 11878, "doesn": 11879, "doing": 11880, "doing_kgdb": 11881, "doing_ss": 11882, "doit": 11883, "dolock": 11884, "domain": 11885, "domain_cost": 11886, "domain_list": 11887, "domain_num": 11888, "domainname": 11889, "domains": 11890, "doms": 11891, "doms_cur": 11892, "done": 11893, "done_acquire": 11894, "done_seqretry_irqrestore": 11895, "donetail": 11896, "dont_count": 11897, "dot": 11898, "double_lock": 11899, "double_lock_balance": 11900, "double_lock_irq": 11901, "double_raw_lock": 11902, "double_rq_lock": 11903, "double_rq_unlock": 11904, "double_tick": 11905, "double_unlock_balance": 11906, "down": 11907, "down_console_sem": 11908, "down_interruptible": 11909, "down_killable": 11910, "down_read": 11911, "down_read_nested": 11912, "down_read_non_owner": 11913, "down_read_trylock": 11914, "down_timeout": 11915, "down_trylock": 11916, "down_trylock_console_sem": 11917, "down_write": 11918, "down_write_nested": 11919, "down_write_trylock": 11920, "downgrade_write": 11921, "dp": 11922, "dpm_complete": 11923, "dpm_prepare": 11924, "dpm_resume": 11925, "dpm_resume_end": 11926, "dpm_resume_start": 11927, "dpm_suspend": 11928, "dpm_suspend_end": 11929, "dpm_suspend_start": 11930, "dprm": 11931, "dput": 11932, "dr": 11933, "drain_local_pages": 11934, "drain_workqueue": 11935, "drained": 11936, "driver": 11937, "drivers_dir": 11938, "drop": 11939, "drop_boost_mutex": 11940, "drop_caches_sysctl_handler": 11941, "drop_collected_mounts": 11942, "drop_precision": 11943, "dropped": 11944, "dropped_count": 11945, "dropped_events": 11946, "dropped_file": 11947, "drv": 11948, "dry_run": 11949, "dsize": 11950, "dst": 11951, "dst_capacity": 11952, "dst_cgrp": 11953, "dst_cpu": 11954, "dst_cset": 11955, "dst_csets": 11956, "dst_grpmask": 11957, "dst_load": 11958, "dst_nid": 11959, "dst_op": 11960, "dst_op_no_mark": 11961, "dst_reg": 11962, "dst_root": 11963, "dst_rq": 11964, "dst_stats": 11965, "dst_task": 11966, "dtabcount": 11967, "dtime": 11968, "dummy": 11969, "dummy_clock_read": 11970, "dummy_cmp": 11971, "dummy_irq_chip": 11972, "dummy_set_flag": 11973, "dummy_tracer_flags": 11974, "dummy_tracer_opt": 11975, "dump": 11976, "dump_all": 11977, "dump_cpu_task": 11978, "dump_kprobe": 11979, "dump_orig": 11980, "dump_probe_ops": 11981, "dump_stack": 11982, "dumpable": 11983, "dumping": 11984, "dup": 11985, "dup_fd": 11986, "dup_mm": 11987, "dup_mmap": 11988, "dup_mmap_sem": 11989, "dup_task_struct": 11990, "dup_utask": 11991, "dup_xol_addr": 11992, "dup_xol_work": 11993, "duplicate_memory_bitmap": 11994, "duration": 11995, "during": 11996, "dw": 11997, "dwork": 11998, "dyn_ftrace": 11999, "dyn_ftrace_test_name": 12000, "dyn_ftrace_test_name2": 12001, "dyn_ftrace_total_info": 12002, "dyn_ops": 12003, "dynamic": 12004, "dynamic_debug_remove": 12005, "dynamic_debug_setup": 12006, "dyntick_save_progress_counter": 12007, "dyntick_task_exit_idle": 12008, "dyntick_task_flag": 12009, "dyntick_task_mask": 12010, "dyntick_task_nest_mask": 12011, "dyntick_task_nest_value": 12012, "dyntick_task_nest_width": 12013, "dynticks": 12014, "dynticks_fqs": 12015, "dynticks_idle": 12016, "dynticks_idle_jiffies": 12017, "dynticks_idle_nesting": 12018, "dynticks_nesting": 12019, "dynticks_nmi_nesting": 12020, "dynticks_snap": 12021, "e": 12022, "e1": 12023, "e2": 12024, "e2big": 12025, "e_cset_node": 12026, "e_csets": 12027, "e_entry": 12028, "e_ident": 12029, "e_shentsize": 12030, "e_shnum": 12031, "e_shoff": 12032, "e_shstrndx": 12033, "e_type": 12034, "eacces": 12035, "each_symbol_in_section": 12036, "each_symbol_section": 12037, "eaddr": 12038, "eaddrnotavail": 12039, "eagain": 12040, "ealready": 12041, "earliest_dl": 12042, "early": 12043, "early_boot_irqs_disabled": 12044, "early_boot_test_call_rcu": 12045, "early_boot_test_call_rcu_bh": 12046, "early_boot_test_call_rcu_sched": 12047, "early_boot_test_counter": 12048, "early_enable_events": 12049, "early_event_add_tracer": 12050, "early_init": 12051, "early_initcall": 12052, "early_irq_init": 12053, "early_param": 12054, "ebadf": 12055, "ebadmsg": 12056, "ebusy": 12057, "echild": 12058, "echo": 12059, "ecode": 12060, "econnrefused": 12061, "edeadlk": 12062, "eexist": 12063, "efault": 12064, "efbig": 12065, "effective": 12066, "effective_cpus": 12067, "effective_flags": 12068, "effective_load": 12069, "effective_mems": 12070, "effective_prio": 12071, "egid": 12072, "egidp": 12073, "ehdr": 12074, "eilseq": 12075, "einprogress": 12076, "eintr": 12077, "einval": 12078, "eio": 12079, "elapsed": 12080, "elapsed_centisecs64": 12081, "elapsed_msecs": 12082, "elapsed_msecs64": 12083, "elem": 12084, "elem_size": 12085, "element": 12086, "elements": 12087, "elemsize": 12088, "elen": 12089, "elf_check_arch": 12090, "elf_core_copy_kernel_regs": 12091, "elf_core_extra_data_size": 12092, "elf_core_extra_phdrs": 12093, "elf_core_write_extra_data": 12094, "elf_core_write_extra_phdrs": 12095, "elf_ehdr": 12096, "elf_half": 12097, "elf_header_check": 12098, "elf_note": 12099, "elf_prstatus": 12100, "elf_shdr": 12101, "elf_st_bind": 12102, "elf_st_type": 12103, "elf_sym": 12104, "elf_type": 12105, "elfcore_addr_max": 12106, "elfcorehdr_addr": 12107, "elfcorehdr_size": 12108, "elfmag": 12109, "elif": 12110, "else": 12111, "elt": 12112, "emergency_restart": 12113, "empty": 12114, "empty_buckets": 12115, "empty_exp": 12116, "empty_exp_now": 12117, "empty_hash": 12118, "empty_norm": 12119, "empty_rp": 12120, "en_flags": 12121, "enable": 12122, "enable_branch_tracing": 12123, "enable_cpus": 12124, "enable_data": 12125, "enable_event": 12126, "enable_event_str": 12127, "enable_irq": 12128, "enable_irqs": 12129, "enable_kprobe": 12130, "enable_kretprobe": 12131, "enable_mask": 12132, "enable_mmiotrace": 12133, "enable_nmi": 12134, "enable_nonboot_cpus": 12135, "enable_on_exec": 12136, "enable_percpu_irq": 12137, "enable_sched_clock_irqtime": 12138, "enable_stacktrace": 12139, "enable_trace_kprobe": 12140, "enable_trigger_data": 12141, "enabled": 12142, "enabled_functions": 12143, "enabled_kobj_attr": 12144, "enabled_perf_enter_syscalls": 12145, "enabled_perf_exit_syscalls": 12146, "enabled_show": 12147, "enabled_store": 12148, "enables": 12149, "enametoolong": 12150, "enanosleep_notsup": 12151, "encode_comp_t": 12152, "encode_float": 12153, "end": 12154, "end_addr": 12155, "end_code": 12156, "end_data": 12157, "end_lba": 12158, "end_of_stack": 12159, "end_p": 12160, "end_pfn": 12161, "end_swap_bio_read": 12162, "end_time": 12163, "ended": 12164, "endefcmd": 12165, "endp": 12166, "endtime": 12167, "enodata": 12168, "enodev": 12169, "enoent": 12170, "enoexec": 12171, "enoioctlcmd": 12172, "enokey": 12173, "enomem": 12174, "enomem_pwq": 12175, "enopkg": 12176, "enospc": 12177, "enosys": 12178, "enotdir": 12179, "enotsup": 12180, "enotsupp": 12181, "enotty": 12182, "enough_free_mem": 12183, "enough_swap": 12184, "enqueue": 12185, "enqueue_entity": 12186, "enqueue_entity_load_avg": 12187, "enqueue_flag": 12188, "enqueue_head": 12189, "enqueue_pushable_task": 12190, "enqueue_replenish": 12191, "enqueue_rt_entity": 12192, "enqueue_sleeper": 12193, "enqueue_task": 12194, "enqueue_task_fair": 12195, "enqueue_task_rt": 12196, "enqueue_top_rt_rq": 12197, "enqueue_wakeup": 12198, "enqueue_waking": 12199, "ent": 12200, "ent_cpu": 12201, "ent_size": 12202, "ent_ts": 12203, "enter": 12204, "enter_event": 12205, "enter_fields": 12206, "enter_funcs": 12207, "enter_kgdb": 12208, "enter_lazy_tlb": 12209, "enter_syscall_files": 12210, "entered_state": 12211, "entering": 12212, "entering_platform_hibernation": 12213, "entity_before": 12214, "entity_is_task": 12215, "entity_tick": 12216, "entries": 12217, "entries_bytes": 12218, "entries_per_page": 12219, "entry": 12220, "entry1": 12221, "entry2": 12222, "entry_count": 12223, "entry_handler": 12224, "entry_sidx": 12225, "entry_size": 12226, "entryfunc": 12227, "enum": 12228, "enum_map": 12229, "enum_replace": 12230, "enum_string": 12231, "enum_value": 12232, "env": 12233, "env_end": 12234, "env_start": 12235, "environment": 12236, "envp": 12237, "enxio": 12238, "eof": 12239, "eoi": 12240, "eopnotsupp": 12241, "eperm": 12242, "epoll_table": 12243, "equals": 12244, "erange": 12245, "erestart_restartblock": 12246, "erestartnohand": 12247, "erestartnointr": 12248, "erestartsys": 12249, "err": 12250, "err2": 12251, "err_alloc": 12252, "err_broadcast": 12253, "err_buffer": 12254, "err_cachep": 12255, "err_cast": 12256, "err_close": 12257, "err_code": 12258, "err_cpu": 12259, "err_desc": 12260, "err_destroy": 12261, "err_flags": 12262, "err_free": 12263, "err_free_css": 12264, "err_free_id": 12265, "err_free_info": 12266, "err_free_inst": 12267, "err_free_iter_info": 12268, "err_free_masks": 12269, "err_free_pd": 12270, "err_free_percpu_ref": 12271, "err_free_pqueue": 12272, "err_free_rq": 12273, "err_free_squeue": 12274, "err_free_wq": 12275, "err_kstat": 12276, "err_list_del": 12277, "err_no_task": 12278, "err_nomem": 12279, "err_out": 12280, "err_ptr": 12281, "err_put": 12282, "err_readtime": 12283, "err_rel": 12284, "err_remove": 12285, "err_size": 12286, "err_suspend": 12287, "err_text": 12288, "err_undo_css": 12289, "err_unlock": 12290, "err_wakealarm": 12291, "errcnt": 12292, "errno": 12293, "error": 12294, "error_packet": 12295, "error_path": 12296, "error_put": 12297, "error_put_key": 12298, "errors": 12299, "errout": 12300, "erule": 12301, "escaped": 12302, "esize": 12303, "esrch": 12304, "esterror": 12305, "et_rel": 12306, "etime": 12307, "ett_event_enable": 12308, "ett_none": 12309, "ett_snapshot": 12310, "ett_stacktrace": 12311, "ett_trace_onoff": 12312, "etype": 12313, "euid": 12314, "euidp": 12315, "eusers": 12316, "ev": 12317, "eval": 12318, "evector": 12319, "even_unformed": 12320, "event": 12321, "event_": 12322, "event_all": 12323, "event_branch": 12324, "event_buf_size": 12325, "event_call": 12326, "event_class_ftrace_": 12327, "event_clear_filter": 12328, "event_clear_no_set_filter_flag": 12329, "event_command": 12330, "event_context_switch": 12331, "event_create_dir": 12332, "event_dir": 12333, "event_disable_cmd": 12334, "event_disable_count_probe_ops": 12335, "event_disable_count_trigger_ops": 12336, "event_disable_probe_ops": 12337, "event_disable_trigger_ops": 12338, "event_dropped": 12339, "event_enable_cmd": 12340, "event_enable_count_probe": 12341, "event_enable_count_probe_ops": 12342, "event_enable_count_trigger": 12343, "event_enable_count_trigger_ops": 12344, "event_enable_file": 12345, "event_enable_free": 12346, "event_enable_func": 12347, "event_enable_get_trigger_ops": 12348, "event_enable_init": 12349, "event_enable_on_exec": 12350, "event_enable_print": 12351, "event_enable_probe": 12352, "event_enable_probe_ops": 12353, "event_enable_read": 12354, "event_enable_register_trigger": 12355, "event_enable_trigger": 12356, "event_enable_trigger_free": 12357, "event_enable_trigger_func": 12358, "event_enable_trigger_ops": 12359, "event_enable_trigger_print": 12360, "event_enable_unregister_trigger": 12361, "event_enable_write": 12362, "event_entry": 12363, "event_file": 12364, "event_file_data": 12365, "event_file_link": 12366, "event_filter": 12367, "event_filter_match": 12368, "event_filter_read": 12369, "event_filter_write": 12370, "event_flexible": 12371, "event_found": 12372, "event_funcgraph_entry": 12373, "event_funcgraph_exit": 12374, "event_function": 12375, "event_handler": 12376, "event_hash": 12377, "event_hashsize": 12378, "event_id": 12379, "event_id_read": 12380, "event_idx": 12381, "event_init": 12382, "event_len": 12383, "event_length": 12384, "event_limit": 12385, "event_list": 12386, "event_lock": 12387, "event_mapped": 12388, "event_mmiotrace_map": 12389, "event_mmiotrace_rw": 12390, "event_mutex": 12391, "event_no_set_filter_flag": 12392, "event_owner_kernel": 12393, "event_pinned": 12394, "event_probe_data": 12395, "event_remove": 12396, "event_sched_in": 12397, "event_sched_out": 12398, "event_set_filter": 12399, "event_set_filtered_flag": 12400, "event_set_no_set_filter_flag": 12401, "event_source": 12402, "event_status": 12403, "event_subsystem": 12404, "event_subsystem_dir": 12405, "event_subsystems": 12406, "event_test_stuff": 12407, "event_test_thread": 12408, "event_trace_add_tracer": 12409, "event_trace_del_tracer": 12410, "event_trace_enable": 12411, "event_trace_enable_again": 12412, "event_trace_init": 12413, "event_trace_memsetup": 12414, "event_trace_self_test_with_function": 12415, "event_trace_self_tests": 12416, "event_trigger_callback": 12417, "event_trigger_data": 12418, "event_trigger_fops": 12419, "event_trigger_free": 12420, "event_trigger_init": 12421, "event_trigger_open": 12422, "event_trigger_ops": 12423, "event_trigger_print": 12424, "event_trigger_regex_open": 12425, "event_trigger_regex_release": 12426, "event_trigger_regex_write": 12427, "event_trigger_release": 12428, "event_trigger_type": 12429, "event_trigger_unlock_commit": 12430, "event_trigger_unlock_commit_regs": 12431, "event_trigger_write": 12432, "event_triggers_call": 12433, "event_triggers_post_call": 12434, "event_triggers_seq_ops": 12435, "event_type": 12436, "event_type_t": 12437, "event_unmapped": 12438, "event_wakeup": 12439, "events": 12440, "events_check_enabled": 12441, "events_nested": 12442, "every": 12443, "evict_chunk": 12444, "evt": 12445, "evtdev": 12446, "ew": 12447, "ewouldblock": 12448, "ex_vector": 12449, "example": 12450, "exception": 12451, "exception_enter": 12452, "exception_exit": 12453, "exception_level": 12454, "exception_state": 12455, "exception_table_entry": 12456, "exchange": 12457, "excl_bit": 12458, "exclude_callchain_kernel": 12459, "exclude_callchain_user": 12460, "exclusive": 12461, "exclusive_bit": 12462, "exclusive_cnt": 12463, "exclusive_console": 12464, "exclusive_event_destroy": 12465, "exclusive_event_init": 12466, "exclusive_event_installable": 12467, "exclusive_event_match": 12468, "exe": 12469, "exe_fd": 12470, "exe_file": 12471, "exec": 12472, "exec_clock": 12473, "exec_fdpic_loadmap": 12474, "exec_max": 12475, "exec_start": 12476, "exec_vm": 12477, "execdomains_proc_fops": 12478, "execdomains_proc_open": 12479, "execdomains_proc_show": 12480, "executable": 12481, "execute_in_process_context": 12482, "execute_work": 12483, "executed": 12484, "execve": 12485, "existing": 12486, "exists": 12487, "exit": 12488, "exit_aio": 12489, "exit_code": 12490, "exit_creds": 12491, "exit_dead": 12492, "exit_err": 12493, "exit_event": 12494, "exit_files": 12495, "exit_free": 12496, "exit_free_rbtree": 12497, "exit_fs": 12498, "exit_idle": 12499, "exit_io_context": 12500, "exit_itimers": 12501, "exit_latency": 12502, "exit_loop": 12503, "exit_mmap": 12504, "exit_nofree": 12505, "exit_pi_state_list": 12506, "exit_ptrace": 12507, "exit_put": 12508, "exit_rcu": 12509, "exit_robust_list": 12510, "exit_root_id": 12511, "exit_sem": 12512, "exit_shm": 12513, "exit_signal": 12514, "exit_signals": 12515, "exit_state": 12516, "exit_syscall_files": 12517, "exit_task_namespaces": 12518, "exit_zombie": 12519, "exitcode": 12520, "exited": 12521, "exitf": 12522, "exp": 12523, "exp_1": 12524, "exp_15": 12525, "exp_5": 12526, "exp_sync": 12527, "exp_tasks": 12528, "expanded": 12529, "expect": 12530, "expected_type": 12531, "expedited_done": 12532, "expedited_done_exit": 12533, "expedited_done_lost": 12534, "expedited_done_tries": 12535, "expedited_normal": 12536, "expedited_start": 12537, "expedited_stoppedcpus": 12538, "expedited_tryfail": 12539, "expedited_workdone1": 12540, "expedited_workdone2": 12541, "expedited_wrap": 12542, "expediting": 12543, "expire": 12544, "expire_cfs_rq_runtime": 12545, "expire_func": 12546, "expires": 12547, "expires_limit": 12548, "expires_next": 12549, "explicit": 12550, "explored": 12551, "explored_states": 12552, "expmask": 12553, "export_per_cpu_symbol": 12554, "export_per_cpu_symbol_gpl": 12555, "export_symbol": 12556, "export_symbol_gpl": 12557, "export_tracepoint_symbol": 12558, "export_tracepoint_symbol_gpl": 12559, "exported": 12560, "expsize": 12561, "ext": 12562, "ext3": 12563, "extable": 12564, "extent": 12565, "extents": 12566, "extern": 12567, "external": 12568, "extra": 12569, "extra1": 12570, "extra2": 12571, "extra_flags": 12572, "extra_pages": 12573, "extra_size": 12574, "f": 12575, "f_bavail": 12576, "f_blocks": 12577, "f_cred": 12578, "f_diff": 12579, "f_flags": 12580, "f_mapping": 12581, "f_mode": 12582, "f_next": 12583, "f_op": 12584, "f_path": 12585, "f_pos": 12586, "f_printk": 12587, "f_show": 12588, "f_start": 12589, "f_struct": 12590, "f_weight": 12591, "facility": 12592, "fact": 12593, "factor": 12594, "fail": 12595, "fail_address_parse": 12596, "fail_all_buf": 12597, "fail_count": 12598, "fail_data_pages": 12599, "fail_defcmd": 12600, "fail_deprobe": 12601, "fail_deprobe_wake_new": 12602, "fail_free_buffer": 12603, "fail_free_buffers": 12604, "fail_free_cpumask": 12605, "fail_free_freeinit": 12606, "fail_free_reader": 12607, "fail_help": 12608, "fail_mem": 12609, "fail_name": 12610, "fail_nocontext": 12611, "fail_nomem": 12612, "fail_nomem_anon_vma_fork": 12613, "fail_nomem_policy": 12614, "fail_nopgd": 12615, "fail_usage": 12616, "fail_user_page": 12617, "failed": 12618, "failed_css": 12619, "failure": 12620, "fair_policy": 12621, "fair_sched_class": 12622, "fake_sched_class": 12623, "fake_signal_wake_up": 12624, "fake_task": 12625, "fakewriter_tasks": 12626, "fallback": 12627, "fallback_doms": 12628, "fallthrough": 12629, "false": 12630, "family": 12631, "family_registered": 12632, "fast_no_hz": 12633, "fast_read_ctr": 12634, "fasync": 12635, "fasync_helper": 12636, "fatal_signal_pending": 12637, "fault": 12638, "fault_flag_mkwrite": 12639, "fault_flag_write": 12640, "fault_handler": 12641, "fault_types": 12642, "faults": 12643, "faults_cpu": 12644, "fbq_classify_group": 12645, "fbq_classify_rq": 12646, "fbq_type": 12647, "fbuffer": 12648, "fcap": 12649, "fcap_ver": 12650, "fcheck_files": 12651, "fchown16": 12652, "fcount": 12653, "fd": 12654, "fd1": 12655, "fd2": 12656, "fdget": 12657, "fdput": 12658, "fds": 12659, "fe": 12660, "feature": 12661, "feature_bitmap": 12662, "features": 12663, "fentry": 12664, "fetch": 12665, "fetch_": 12666, "fetch_bitfield_string": 12667, "fetch_bitfield_string_size": 12668, "fetch_file_offset_string": 12669, "fetch_file_offset_string_size": 12670, "fetch_file_offset_u16": 12671, "fetch_file_offset_u32": 12672, "fetch_file_offset_u64": 12673, "fetch_file_offset_u8": 12674, "fetch_func_name": 12675, "fetch_func_t": 12676, "fetch_kernel_stack_address": 12677, "fetch_memory_": 12678, "fetch_mtd_": 12679, "fetch_mtd_bitfield": 12680, "fetch_mtd_deref": 12681, "fetch_mtd_end": 12682, "fetch_mtd_file_offset": 12683, "fetch_mtd_memory": 12684, "fetch_mtd_reg": 12685, "fetch_mtd_retval": 12686, "fetch_mtd_stack": 12687, "fetch_mtd_symbol": 12688, "fetch_or": 12689, "fetch_param": 12690, "fetch_reg_string": 12691, "fetch_reg_string_size": 12692, "fetch_retval_string": 12693, "fetch_retval_string_size": 12694, "fetch_robust_entry": 12695, "fetch_size": 12696, "fetch_stack_string": 12697, "fetch_stack_string_size": 12698, "fetch_symbol_string": 12699, "fetch_symbol_string_size": 12700, "fetch_symbol_u16": 12701, "fetch_symbol_u32": 12702, "fetch_symbol_u64": 12703, "fetch_symbol_u8": 12704, "fetch_task_cputime": 12705, "fetch_type": 12706, "fetch_type_string": 12707, "fetch_type_strsize": 12708, "fetch_user_stack_address": 12709, "ffs": 12710, "ffz": 12711, "fget": 12712, "fgraph_cpu_data": 12713, "fgraph_data": 12714, "fi_idx": 12715, "fi_ptr": 12716, "fi_size": 12717, "field": 12718, "field_cachep": 12719, "field_count": 12720, "field_is_signed": 12721, "field_len": 12722, "field_size": 12723, "field_string_func": 12724, "field_string_ip": 12725, "field_string_retip": 12726, "fieldflags": 12727, "fields": 12728, "file": 12729, "file_cachep": 12730, "file_caps_disable": 12731, "file_caps_enabled": 12732, "file_cpu_exclusive": 12733, "file_cpulist": 12734, "file_effective_cpulist": 12735, "file_effective_memlist": 12736, "file_end_write": 12737, "file_inode": 12738, "file_mem_exclusive": 12739, "file_mem_hardwall": 12740, "file_memlist": 12741, "file_memory_migrate": 12742, "file_memory_pressure": 12743, "file_memory_pressure_enabled": 12744, "file_mode": 12745, "file_name": 12746, "file_ns_capable": 12747, "file_offset": 12748, "file_open_name": 12749, "file_open_root": 12750, "file_operations": 12751, "file_sched_load_balance": 12752, "file_sched_relax_domain_level": 12753, "file_size": 12754, "file_spread_page": 12755, "file_spread_slab": 12756, "file_start_write_trylock": 12757, "file_system_type": 12758, "filename": 12759, "files": 12760, "files_cachep": 12761, "files_stat": 12762, "files_struct": 12763, "filesystems": 12764, "fill_ac": 12765, "fill_rwbs": 12766, "fill_stats": 12767, "fill_stats_for_pid": 12768, "fill_stats_for_tgid": 12769, "fill_tgid_exit": 12770, "filp": 12771, "filp1": 12772, "filp2": 12773, "filp_close": 12774, "filt_err_bad_subsys_filter": 12775, "filt_err_field_not_found": 12776, "filt_err_illegal_field_op": 12777, "filt_err_illegal_intval": 12778, "filt_err_illegal_not_op": 12779, "filt_err_invalid_filter": 12780, "filt_err_invalid_op": 12781, "filt_err_ip_field_only": 12782, "filt_err_missing_field": 12783, "filt_err_none": 12784, "filt_err_operand_too_long": 12785, "filt_err_too_many_operands": 12786, "filt_err_too_many_preds": 12787, "filt_err_unbalanced_paren": 12788, "filter": 12789, "filter_add_pred": 12790, "filter_assign_type": 12791, "filter_build_regex": 12792, "filter_chain": 12793, "filter_check_discard": 12794, "filter_disable": 12795, "filter_dyn_string": 12796, "filter_free_subsystem_filters": 12797, "filter_free_subsystem_preds": 12798, "filter_func_t": 12799, "filter_hash": 12800, "filter_item": 12801, "filter_list": 12802, "filter_match_preds": 12803, "filter_match_preds_cb": 12804, "filter_match_preds_data": 12805, "filter_op": 12806, "filter_op_ids": 12807, "filter_ops": 12808, "filter_opstack_clear": 12809, "filter_opstack_empty": 12810, "filter_opstack_pop": 12811, "filter_opstack_push": 12812, "filter_opstack_top": 12813, "filter_other": 12814, "filter_parse": 12815, "filter_parse_regex": 12816, "filter_parse_state": 12817, "filter_pred": 12818, "filter_pred_": 12819, "filter_pred_16": 12820, "filter_pred_32": 12821, "filter_pred_64": 12822, "filter_pred_8": 12823, "filter_pred_fn_t": 12824, "filter_pred_fold": 12825, "filter_pred_invalid": 12826, "filter_pred_is_right": 12827, "filter_pred_none": 12828, "filter_pred_pchar": 12829, "filter_pred_s16": 12830, "filter_pred_s32": 12831, "filter_pred_s64": 12832, "filter_pred_s8": 12833, "filter_pred_string": 12834, "filter_pred_strloc": 12835, "filter_pred_u16": 12836, "filter_pred_u32": 12837, "filter_pred_u64": 12838, "filter_pred_u8": 12839, "filter_pred_walkcb_t": 12840, "filter_ptr_string": 12841, "filter_ret": 12842, "filter_set_pred": 12843, "filter_static_string": 12844, "filter_str": 12845, "filter_string": 12846, "filter_trace_fn": 12847, "filter_type": 12848, "filtered": 12849, "filtering": 12850, "filterkey": 12851, "filterp": 12852, "filters": 12853, "final_count": 12854, "final_note": 12855, "find_active_uprobe": 12856, "find_and_alloc_map": 12857, "find_busiest_group": 12858, "find_busiest_queue": 12859, "find_chunk": 12860, "find_css_set": 12861, "find_event_file": 12862, "find_event_file_link": 12863, "find_existing_css_set": 12864, "find_fetch_type": 12865, "find_first_bit": 12866, "find_first_elem": 12867, "find_first_zero_bit": 12868, "find_ge_pid": 12869, "find_get_context": 12870, "find_get_pid": 12871, "find_idlest_cpu": 12872, "find_idlest_group": 12873, "find_lively_task_by_vpid": 12874, "find_lock_lowest_rq": 12875, "find_lowest_rq": 12876, "find_matching_se": 12877, "find_module": 12878, "find_module_all": 12879, "find_module_sections": 12880, "find_new_ilb": 12881, "find_next": 12882, "find_next_bit": 12883, "find_next_iomem_res": 12884, "find_next_mod_format": 12885, "find_next_offset": 12886, "find_next_push_cpu": 12887, "find_next_zero_bit": 12888, "find_node_in_range": 12889, "find_numa_distance": 12890, "find_pcpusec": 12891, "find_pid_ns": 12892, "find_pm_qos_object_by_minor": 12893, "find_probe_event": 12894, "find_process_by_pid": 12895, "find_prog_type": 12896, "find_regset": 12897, "find_resource": 12898, "find_sec": 12899, "find_symbol": 12900, "find_symbol_arg": 12901, "find_symbol_in_section": 12902, "find_syscall_meta": 12903, "find_task_by_pid_ns": 12904, "find_task_by_vpid": 12905, "find_trace_kprobe": 12906, "find_trace_probe_file": 12907, "find_uprobe": 12908, "find_usage_backwards": 12909, "find_usage_forwards": 12910, "find_user": 12911, "find_vma": 12912, "find_vpid": 12913, "find_worker_executing_work": 12914, "finish": 12915, "finish_arch_post_lock_switch": 12916, "finish_arch_switch": 12917, "finish_lock_switch": 12918, "finish_task_switch": 12919, "finish_wait": 12920, "finished": 12921, "finished_loading": 12922, "finishing": 12923, "finit_module": 12924, "fire_sched_in_preempt_notifiers": 12925, "fire_sched_out_preempt_notifiers": 12926, "first": 12927, "first_colon": 12928, "first_cpu": 12929, "first_filter": 12930, "first_flusher": 12931, "first_free_id": 12932, "first_idle_worker": 12933, "first_irq": 12934, "first_level_children_only": 12935, "first_node": 12936, "first_notrace": 12937, "first_online_node": 12938, "first_page": 12939, "first_sector": 12940, "first_space": 12941, "first_trees": 12942, "first_uprobe": 12943, "firstc": 12944, "firsterr": 12945, "firstnonnull": 12946, "firstreport": 12947, "firstsnap": 12948, "firsttime": 12949, "fix": 12950, "fix_small_imbalance": 12951, "fixed_1": 12952, "fixed_power_int": 12953, "fixed_regs": 12954, "fixing": 12955, "fixup_activate": 12956, "fixup_assert_init": 12957, "fixup_bpf_calls": 12958, "fixup_free": 12959, "fixup_init": 12960, "fixup_owner": 12961, "fk": 12962, "fl_mask": 12963, "flag": 12964, "flag_array": 12965, "flag_changed": 12966, "flags": 12967, "flags_fill_end": 12968, "flags_fill_full": 12969, "flags_fill_start": 12970, "flags_p": 12971, "flavor_mask": 12972, "flavors": 12973, "flen": 12974, "flexible_groups": 12975, "flim": 12976, "floor": 12977, "fls64": 12978, "flush": 12979, "flush_cache_dup_mm": 12980, "flush_cache_page": 12981, "flush_cache_range": 12982, "flush_cnt": 12983, "flush_color": 12984, "flush_dcache_mmap_lock": 12985, "flush_dcache_mmap_unlock": 12986, "flush_dcache_page": 12987, "flush_delayed_work": 12988, "flush_hold_queue": 12989, "flush_icache_range": 12990, "flush_insn_slot": 12991, "flush_itimer_signals": 12992, "flush_kthread_work": 12993, "flush_kthread_worker": 12994, "flush_module_icache": 12995, "flush_scheduled_work": 12996, "flush_signal_handlers": 12997, "flush_signals": 12998, "flush_sigqueue": 12999, "flush_sigqueue_mask": 13000, "flush_smp_call_function_queue": 13001, "flush_swap_writer": 13002, "flush_tlb_mm": 13003, "flush_work": 13004, "flush_workqueue": 13005, "flush_workqueue_prep_pwqs": 13006, "flusher_overflow": 13007, "flusher_queue": 13008, "fm_coef": 13009, "fm_maxcnt": 13010, "fm_maxticks": 13011, "fm_scale": 13012, "fmeter": 13013, "fmeter_getrate": 13014, "fmeter_init": 13015, "fmeter_markevent": 13016, "fmeter_update": 13017, "fmode_can_write": 13018, "fmode_read": 13019, "fmode_t": 13020, "fmode_write": 13021, "fmp": 13022, "fmt": 13023, "fmt_cnt": 13024, "fmt_size": 13025, "fmtchar": 13026, "fmtstr": 13027, "fmttype": 13028, "fn": 13029, "fold_pred": 13030, "fold_pred_cb": 13031, "fold_pred_data": 13032, "fold_pred_tree": 13033, "fold_pred_tree_cb": 13034, "foo": 13035, "fops": 13036, "for": 13037, "for_each_active_irq": 13038, "for_each_buffer_cpu": 13039, "for_each_class": 13040, "for_each_cpu": 13041, "for_each_cpu_and": 13042, "for_each_cpu_worker_pool": 13043, "for_each_css": 13044, "for_each_domain": 13045, "for_each_e_css": 13046, "for_each_event": 13047, "for_each_irq_desc": 13048, "for_each_irq_desc_reverse": 13049, "for_each_kdbcmd": 13050, "for_each_kimage_entry": 13051, "for_each_leaf_cfs_rq": 13052, "for_each_lower_domain": 13053, "for_each_msi_entry": 13054, "for_each_node": 13055, "for_each_node_mask": 13056, "for_each_online_cpu": 13057, "for_each_online_node": 13058, "for_each_pool": 13059, "for_each_pool_worker": 13060, "for_each_populated_zone": 13061, "for_each_possible_cpu": 13062, "for_each_present_cpu": 13063, "for_each_process": 13064, "for_each_process_thread": 13065, "for_each_pwq": 13066, "for_each_rcu_flavor": 13067, "for_each_root": 13068, "for_each_rt_rq": 13069, "for_each_sched_entity": 13070, "for_each_sched_rt_entity": 13071, "for_each_sd_topology": 13072, "for_each_set_bit": 13073, "for_each_subsys": 13074, "for_each_task_context_nr": 13075, "for_each_thread": 13076, "for_each_tracing_cpu": 13077, "for_ptracer": 13078, "forbidden_pages_map": 13079, "force": 13080, "force_balance": 13081, "force_default": 13082, "force_irqthreads": 13083, "force_qs_rnp": 13084, "force_quiescent_state": 13085, "force_resume_depth": 13086, "force_sd_overlap": 13087, "force_sig": 13088, "force_sig_info": 13089, "force_sigsegv": 13090, "force_successful_syscall_return": 13091, "force_unoptimize_kprobe": 13092, "force_up": 13093, "force_update": 13094, "forced": 13095, "fork": 13096, "fork_idle": 13097, "fork_init": 13098, "fork_out": 13099, "forkexec_idx": 13100, "format": 13101, "format_field_seperator": 13102, "format_header": 13103, "format_mod_start": 13104, "format_mod_stop": 13105, "format_printfmt": 13106, "forward": 13107, "forwards": 13108, "found": 13109, "found_child": 13110, "found_it": 13111, "found_parent": 13112, "four": 13113, "fp": 13114, "fp_old": 13115, "fp_size": 13116, "fpid": 13117, "fpid_next": 13118, "fpid_show": 13119, "fpid_start": 13120, "fpid_stop": 13121, "fprm": 13122, "fprog": 13123, "fprog32": 13124, "fput": 13125, "fqs": 13126, "fqs_burst_remaining": 13127, "fqs_duration": 13128, "fqs_holdoff": 13129, "fqs_resume_time": 13130, "fqs_state": 13131, "fqs_state_in": 13132, "fqs_stutter": 13133, "fqs_task": 13134, "fqslock": 13135, "frac": 13136, "frac_bits": 13137, "frame_pointer": 13138, "frame_ptr": 13139, "free": 13140, "free_aggr_kprobe": 13141, "free_all_swap_pages": 13142, "free_arch_cleanup": 13143, "free_area": 13144, "free_argv": 13145, "free_aux": 13146, "free_basic_memory_bitmaps": 13147, "free_bitfield_fetch_param": 13148, "free_bitmap": 13149, "free_bitmaps": 13150, "free_bt": 13151, "free_buffer": 13152, "free_buffer_page": 13153, "free_cgrp_cset_links": 13154, "free_chunk": 13155, "free_copy": 13156, "free_cpumask": 13157, "free_cpumask_var": 13158, "free_cpus": 13159, "free_cs": 13160, "free_deref_fetch_param": 13161, "free_desc": 13162, "free_dlo_mask": 13163, "free_dma": 13164, "free_env": 13165, "free_event": 13166, "free_event_filter": 13167, "free_event_rcu": 13168, "free_fair_sched_group": 13169, "free_filter": 13170, "free_filter_prog": 13171, "free_first_bitmap": 13172, "free_first_object": 13173, "free_fs_struct": 13174, "free_ftrace_hash": 13175, "free_ftrace_hash_rcu": 13176, "free_hash": 13177, "free_hash_entry": 13178, "free_highmem": 13179, "free_highmem_data": 13180, "free_htab": 13181, "free_image_page": 13182, "free_info": 13183, "free_insn_page": 13184, "free_instances": 13185, "free_irq": 13186, "free_key": 13187, "free_kmem_pages": 13188, "free_list": 13189, "free_list_of_pages": 13190, "free_log_buf": 13191, "free_map_info": 13192, "free_masks": 13193, "free_mem_extents": 13194, "free_mm": 13195, "free_modinfo": 13196, "free_modinfo_": 13197, "free_modprobe_argv": 13198, "free_module": 13199, "free_module_name": 13200, "free_module_param_attrs": 13201, "free_next_key": 13202, "free_notes_attrs": 13203, "free_nsproxy": 13204, "free_online": 13205, "free_out": 13206, "free_page": 13207, "free_pages": 13208, "free_pages_map": 13209, "free_percpu": 13210, "free_percpu_irq": 13211, "free_pid": 13212, "free_pid_ns": 13213, "free_pidmap": 13214, "free_prog": 13215, "free_pt": 13216, "free_resource": 13217, "free_rootdomain": 13218, "free_rp_inst": 13219, "free_rt_sched_group": 13220, "free_rto_mask": 13221, "free_sched_domain": 13222, "free_sched_group": 13223, "free_sched_group_rcu": 13224, "free_sched_groups": 13225, "free_second_object": 13226, "free_sect_attrs": 13227, "free_sgc": 13228, "free_signal_struct": 13229, "free_snapshot": 13230, "free_span": 13231, "free_states": 13232, "free_symbol_cache": 13233, "free_syscall_print_fmt": 13234, "free_task": 13235, "free_task_struct": 13236, "free_thread_info": 13237, "free_ti": 13238, "free_trace_kprobe": 13239, "free_trace_uprobe": 13240, "free_tree_refs": 13241, "free_trial_cpuset": 13242, "free_tsk": 13243, "free_uid": 13244, "free_unbound_pwq": 13245, "free_unload": 13246, "free_used_maps": 13247, "free_user": 13248, "free_user_ns": 13249, "free_uts_ns": 13250, "free_value": 13251, "free_workqueue_attrs": 13252, "free_zone_bm_rtree": 13253, "freed": 13254, "freehigh": 13255, "freeing_list": 13256, "freeinit": 13257, "freeme": 13258, "freepages_count": 13259, "freepages_delay": 13260, "freepages_delay_total": 13261, "freepages_start": 13262, "freeram": 13263, "frees": 13264, "freeswap": 13265, "freezable": 13266, "freezable_schedule": 13267, "freezable_schedule_timeout_interruptible": 13268, "freeze": 13269, "freeze_cgroup": 13270, "freeze_kernel_threads": 13271, "freeze_processes": 13272, "freeze_task": 13273, "freeze_timeout_msecs": 13274, "freeze_workqueues_begin": 13275, "freeze_workqueues_busy": 13276, "freezer": 13277, "freezer_apply_state": 13278, "freezer_attach": 13279, "freezer_cgrp_id": 13280, "freezer_cgrp_subsys": 13281, "freezer_change_state": 13282, "freezer_count": 13283, "freezer_css_alloc": 13284, "freezer_css_free": 13285, "freezer_css_offline": 13286, "freezer_css_online": 13287, "freezer_delta": 13288, "freezer_delta_lock": 13289, "freezer_do_not_count": 13290, "freezer_fork": 13291, "freezer_lock": 13292, "freezer_mutex": 13293, "freezer_parent_freezing_read": 13294, "freezer_read": 13295, "freezer_self_freezing_read": 13296, "freezer_should_skip": 13297, "freezer_state_flags": 13298, "freezer_state_strs": 13299, "freezer_test_done": 13300, "freezer_write": 13301, "freezing": 13302, "freezing_slow_path": 13303, "freq": 13304, "freq_count_stamp": 13305, "freq_norm": 13306, "frequency": 13307, "frequency_fls": 13308, "fried_cmppid": 13309, "from": 13310, "from_ancestor_ns": 13311, "from_cgrp": 13312, "from_kgid": 13313, "from_kgid_munged": 13314, "from_kprojid": 13315, "from_kprojid_munged": 13316, "from_kuid": 13317, "from_kuid_munged": 13318, "front": 13319, "frozen": 13320, "frozen_cpus": 13321, "fs": 13322, "fs_aio_max_nr": 13323, "fs_aio_nr": 13324, "fs_cachep": 13325, "fs_create": 13326, "fs_delete": 13327, "fs_delete_self": 13328, "fs_dentry": 13329, "fs_dir_notify": 13330, "fs_dq_allocated": 13331, "fs_dq_cache_hits": 13332, "fs_dq_drops": 13333, "fs_dq_free": 13334, "fs_dq_lookups": 13335, "fs_dq_reads": 13336, "fs_dq_syncs": 13337, "fs_dq_warnings": 13338, "fs_dq_writes": 13339, "fs_dqstats": 13340, "fs_event_on_child": 13341, "fs_in_ignored": 13342, "fs_initcall": 13343, "fs_inotify": 13344, "fs_kobj": 13345, "fs_lease_time": 13346, "fs_leases": 13347, "fs_maxfile": 13348, "fs_move": 13349, "fs_move_self": 13350, "fs_moved_from": 13351, "fs_moved_to": 13352, "fs_nrinode": 13353, "fs_ocfs2": 13354, "fs_overflowgid": 13355, "fs_overflowuid": 13356, "fs_pin": 13357, "fs_statinode": 13358, "fs_struct": 13359, "fs_table": 13360, "fs_type": 13361, "fs_unmount": 13362, "fs_xfs": 13363, "fsa": 13364, "fsgid": 13365, "fshift": 13366, "fsnotify_add_mark": 13367, "fsnotify_alloc_group": 13368, "fsnotify_destroy_mark": 13369, "fsnotify_duplicate_mark": 13370, "fsnotify_event_inode": 13371, "fsnotify_event_path": 13372, "fsnotify_find_inode_mark": 13373, "fsnotify_get_mark": 13374, "fsnotify_group": 13375, "fsnotify_init_mark": 13376, "fsnotify_mark": 13377, "fsnotify_ops": 13378, "fsnotify_put_mark": 13379, "fsuid": 13380, "ftbl": 13381, "ftest": 13382, "ftrace": 13383, "ftrace_add_profile": 13384, "ftrace_addr": 13385, "ftrace_allocate_pages": 13386, "ftrace_allocate_records": 13387, "ftrace_arch_code_modify_post_process": 13388, "ftrace_arch_code_modify_prepare": 13389, "ftrace_avail_fops": 13390, "ftrace_branch_data": 13391, "ftrace_buff_max": 13392, "ftrace_bug": 13393, "ftrace_callsites": 13394, "ftrace_check_record": 13395, "ftrace_clear_events": 13396, "ftrace_cmp_recs": 13397, "ftrace_cmp_type": 13398, "ftrace_code_disable": 13399, "ftrace_common_fields": 13400, "ftrace_control_list": 13401, "ftrace_cpu_disabled": 13402, "ftrace_cpudump_print": 13403, "ftrace_cpudump_probe": 13404, "ftrace_create_filter_files": 13405, "ftrace_create_function_files": 13406, "ftrace_ctx_fields": 13407, "ftrace_define_fields_": 13408, "ftrace_destroy_filter_files": 13409, "ftrace_destroy_function_files": 13410, "ftrace_disable_calls": 13411, "ftrace_disable_ftrace_graph_caller": 13412, "ftrace_disabled": 13413, "ftrace_dump": 13414, "ftrace_dump_buf": 13415, "ftrace_dump_mode": 13416, "ftrace_dump_on_oops": 13417, "ftrace_dump_print": 13418, "ftrace_dump_probe": 13419, "ftrace_enable_fops": 13420, "ftrace_enable_ftrace_graph_caller": 13421, "ftrace_enable_sysctl": 13422, "ftrace_enabled": 13423, "ftrace_entry": 13424, "ftrace_entry_dup": 13425, "ftrace_entry_reg": 13426, "ftrace_event_avail_open": 13427, "ftrace_event_buffer": 13428, "ftrace_event_buffer_commit": 13429, "ftrace_event_buffer_reserve": 13430, "ftrace_event_call": 13431, "ftrace_event_class": 13432, "ftrace_event_enable_disable": 13433, "ftrace_event_field": 13434, "ftrace_event_file": 13435, "ftrace_event_filter_fops": 13436, "ftrace_event_fl_enabled": 13437, "ftrace_event_fl_enabled_bit": 13438, "ftrace_event_fl_filtered": 13439, "ftrace_event_fl_no_set_filter": 13440, "ftrace_event_fl_recorded_cmd": 13441, "ftrace_event_fl_recorded_cmd_bit": 13442, "ftrace_event_fl_soft_disabled": 13443, "ftrace_event_fl_soft_disabled_bit": 13444, "ftrace_event_fl_soft_mode": 13445, "ftrace_event_fl_soft_mode_bit": 13446, "ftrace_event_fl_trigger_cond_bit": 13447, "ftrace_event_fl_trigger_mode_bit": 13448, "ftrace_event_format_fops": 13449, "ftrace_event_id_fops": 13450, "ftrace_event_is_function": 13451, "ftrace_event_list": 13452, "ftrace_event_name": 13453, "ftrace_event_open": 13454, "ftrace_event_reg": 13455, "ftrace_event_release": 13456, "ftrace_event_set_open": 13457, "ftrace_event_write": 13458, "ftrace_events": 13459, "ftrace_file": 13460, "ftrace_filter": 13461, "ftrace_filter_param": 13462, "ftrace_filter_write": 13463, "ftrace_find_event": 13464, "ftrace_find_profiled_func": 13465, "ftrace_find_tramp_ops_any": 13466, "ftrace_find_tramp_ops_curr": 13467, "ftrace_find_tramp_ops_new": 13468, "ftrace_fl_enabled": 13469, "ftrace_fl_ipmodify": 13470, "ftrace_fl_regs": 13471, "ftrace_fl_regs_en": 13472, "ftrace_fl_tramp": 13473, "ftrace_fl_tramp_en": 13474, "ftrace_force_list_func": 13475, "ftrace_free_filter": 13476, "ftrace_func_command": 13477, "ftrace_func_entry": 13478, "ftrace_func_hash": 13479, "ftrace_func_hashsize": 13480, "ftrace_func_probe": 13481, "ftrace_func_t": 13482, "ftrace_function_check_pred": 13483, "ftrace_function_filter_re": 13484, "ftrace_function_local_disable": 13485, "ftrace_function_local_disabled": 13486, "ftrace_function_local_enable": 13487, "ftrace_function_set_filter": 13488, "ftrace_function_set_filter_cb": 13489, "ftrace_function_set_regexp": 13490, "ftrace_get_addr_curr": 13491, "ftrace_get_addr_new": 13492, "ftrace_graph_active": 13493, "ftrace_graph_addr": 13494, "ftrace_graph_ent": 13495, "ftrace_graph_ent_entry": 13496, "ftrace_graph_entry": 13497, "ftrace_graph_entry_stub": 13498, "ftrace_graph_entry_test": 13499, "ftrace_graph_exit_task": 13500, "ftrace_graph_filter": 13501, "ftrace_graph_ignore_irqs": 13502, "ftrace_graph_init_idle_task": 13503, "ftrace_graph_init_task": 13504, "ftrace_graph_is_dead": 13505, "ftrace_graph_notrace": 13506, "ftrace_graph_notrace_addr": 13507, "ftrace_graph_probe_sched_switch": 13508, "ftrace_graph_ret": 13509, "ftrace_graph_ret_entry": 13510, "ftrace_graph_return": 13511, "ftrace_graph_skip_irqs": 13512, "ftrace_graph_stop": 13513, "ftrace_graph_tramp_addr": 13514, "ftrace_hash": 13515, "ftrace_hash_bits": 13516, "ftrace_hash_clear": 13517, "ftrace_hash_empty": 13518, "ftrace_hash_ipmodify_disable": 13519, "ftrace_hash_ipmodify_enable": 13520, "ftrace_hash_ipmodify_update": 13521, "ftrace_hash_max_bits": 13522, "ftrace_hash_move": 13523, "ftrace_hash_rec_disable": 13524, "ftrace_hash_rec_disable_modify": 13525, "ftrace_hash_rec_enable": 13526, "ftrace_hash_rec_enable_modify": 13527, "ftrace_hash_rec_update_modify": 13528, "ftrace_init_array_ops": 13529, "ftrace_init_dyn_tracefs": 13530, "ftrace_init_global_array_ops": 13531, "ftrace_init_tracefs": 13532, "ftrace_is_dead": 13533, "ftrace_iter_do_hash": 13534, "ftrace_iter_enabled": 13535, "ftrace_iter_filter": 13536, "ftrace_iter_hash": 13537, "ftrace_iter_notrace": 13538, "ftrace_iter_printall": 13539, "ftrace_iterator": 13540, "ftrace_kill": 13541, "ftrace_likely_update": 13542, "ftrace_list_end": 13543, "ftrace_location": 13544, "ftrace_location_range": 13545, "ftrace_lock": 13546, "ftrace_lookup_ip": 13547, "ftrace_make_call": 13548, "ftrace_make_nop": 13549, "ftrace_max_event": 13550, "ftrace_modify_all_code": 13551, "ftrace_modify_call": 13552, "ftrace_module_file_ops": 13553, "ftrace_module_init": 13554, "ftrace_nodyn_init": 13555, "ftrace_notrace": 13556, "ftrace_notrace_depth": 13557, "ftrace_now": 13558, "ftrace_nr_registered_ops": 13559, "ftrace_old_addr": 13560, "ftrace_ops": 13561, "ftrace_ops_control_func": 13562, "ftrace_ops_fl_adding": 13563, "ftrace_ops_fl_alloc_tramp": 13564, "ftrace_ops_fl_control": 13565, "ftrace_ops_fl_deleted": 13566, "ftrace_ops_fl_dynamic": 13567, "ftrace_ops_fl_enabled": 13568, "ftrace_ops_fl_initialized": 13569, "ftrace_ops_fl_ipmodify": 13570, "ftrace_ops_fl_modifying": 13571, "ftrace_ops_fl_recursion_safe": 13572, "ftrace_ops_fl_removing": 13573, "ftrace_ops_fl_save_regs": 13574, "ftrace_ops_fl_save_regs_if_supported": 13575, "ftrace_ops_fl_stub": 13576, "ftrace_ops_get_func": 13577, "ftrace_ops_get_list_func": 13578, "ftrace_ops_hash": 13579, "ftrace_ops_init": 13580, "ftrace_ops_list": 13581, "ftrace_ops_list_func": 13582, "ftrace_ops_no_ops": 13583, "ftrace_ops_recurs_func": 13584, "ftrace_ops_test": 13585, "ftrace_output_call": 13586, "ftrace_output_raw": 13587, "ftrace_page": 13588, "ftrace_pages": 13589, "ftrace_pages_start": 13590, "ftrace_pid": 13591, "ftrace_pid_add": 13592, "ftrace_pid_fops": 13593, "ftrace_pid_func": 13594, "ftrace_pid_function": 13595, "ftrace_pid_open": 13596, "ftrace_pid_release": 13597, "ftrace_pid_reset": 13598, "ftrace_pid_sops": 13599, "ftrace_pid_write": 13600, "ftrace_pids": 13601, "ftrace_pop_return_trace": 13602, "ftrace_print_bitmask_seq": 13603, "ftrace_print_flags_seq": 13604, "ftrace_print_hex_seq": 13605, "ftrace_print_symbols_seq": 13606, "ftrace_print_symbols_seq_u64": 13607, "ftrace_probe_ops": 13608, "ftrace_probe_print": 13609, "ftrace_profile": 13610, "ftrace_profile_alloc": 13611, "ftrace_profile_enabled": 13612, "ftrace_profile_fops": 13613, "ftrace_profile_free_filter": 13614, "ftrace_profile_hash_bits": 13615, "ftrace_profile_hash_size": 13616, "ftrace_profile_init": 13617, "ftrace_profile_init_cpu": 13618, "ftrace_profile_lock": 13619, "ftrace_profile_ops": 13620, "ftrace_profile_page": 13621, "ftrace_profile_pages_init": 13622, "ftrace_profile_reset": 13623, "ftrace_profile_set_filter": 13624, "ftrace_profile_stat": 13625, "ftrace_profile_stats": 13626, "ftrace_profile_tracefs": 13627, "ftrace_profile_write": 13628, "ftrace_raw_ftrace_test_filter": 13629, "ftrace_raw_output_prep": 13630, "ftrace_rec_count": 13631, "ftrace_rec_iter": 13632, "ftrace_rec_iter_next": 13633, "ftrace_rec_iter_record": 13634, "ftrace_rec_iter_start": 13635, "ftrace_ref_max": 13636, "ftrace_regex_open": 13637, "ftrace_regex_release": 13638, "ftrace_regs_addr": 13639, "ftrace_replace_code": 13640, "ftrace_reset_array_ops": 13641, "ftrace_ret_stack": 13642, "ftrace_retfunc_depth": 13643, "ftrace_retstack_alloc_size": 13644, "ftrace_return_to_handler": 13645, "ftrace_run_modify_code": 13646, "ftrace_run_stop_machine": 13647, "ftrace_run_update_code": 13648, "ftrace_set_clr_event": 13649, "ftrace_set_early_filter": 13650, "ftrace_set_event_fops": 13651, "ftrace_set_filter": 13652, "ftrace_set_filter_ip": 13653, "ftrace_set_global_filter": 13654, "ftrace_set_notrace": 13655, "ftrace_show_header_fops": 13656, "ftrace_shutdown": 13657, "ftrace_shutdown_sysctl": 13658, "ftrace_stack_entries": 13659, "ftrace_stacktrace": 13660, "ftrace_stacktrace_count": 13661, "ftrace_stacktrace_print": 13662, "ftrace_start_func_ret": 13663, "ftrace_start_up": 13664, "ftrace_startup": 13665, "ftrace_startup_all": 13666, "ftrace_startup_enable": 13667, "ftrace_startup_sysctl": 13668, "ftrace_stop_func_ret": 13669, "ftrace_stub": 13670, "ftrace_subsystem_dir": 13671, "ftrace_subsystem_filter_fops": 13672, "ftrace_suspend_notifier": 13673, "ftrace_suspend_notifier_call": 13674, "ftrace_swapper_pid": 13675, "ftrace_sync": 13676, "ftrace_sync_ipi": 13677, "ftrace_syscall_enter": 13678, "ftrace_syscall_exit": 13679, "ftrace_system_enable_fops": 13680, "ftrace_test_event_disable": 13681, "ftrace_test_event_filter": 13682, "ftrace_test_filter": 13683, "ftrace_test_record": 13684, "ftrace_text_reserved": 13685, "ftrace_timestamp": 13686, "ftrace_tr_enable_fops": 13687, "ftrace_trace_arrays": 13688, "ftrace_trace_function": 13689, "ftrace_trace_probe_callback": 13690, "ftrace_trace_stack": 13691, "ftrace_trace_stack_regs": 13692, "ftrace_trace_task": 13693, "ftrace_trace_userstack": 13694, "ftrace_traceoff": 13695, "ftrace_traceoff_count": 13696, "ftrace_traceoff_print": 13697, "ftrace_traceon": 13698, "ftrace_traceon_count": 13699, "ftrace_traceon_print": 13700, "ftrace_trigger_soft_disabled": 13701, "ftrace_update_calls": 13702, "ftrace_update_code": 13703, "ftrace_update_ftrace_func": 13704, "ftrace_update_ignore": 13705, "ftrace_update_make_call": 13706, "ftrace_update_make_nop": 13707, "ftrace_update_modify_call": 13708, "ftrace_update_pid_func": 13709, "ftrace_update_record": 13710, "ftrace_update_time": 13711, "ftrace_update_tot_cnt": 13712, "ftrace_update_trace_func": 13713, "ftrace_update_trampoline": 13714, "ftrace_warn_on": 13715, "ftrace_warn_on_once": 13716, "ftype": 13717, "fua": 13718, "full": 13719, "full_sysidle_state": 13720, "full_waiters": 13721, "full_waiters_pending": 13722, "fullstop": 13723, "fullstop_dontstop": 13724, "fullstop_mutex": 13725, "fullstop_rmmod": 13726, "fullstop_shutdown": 13727, "func": 13728, "func1_name": 13729, "func2_name": 13730, "func_begin": 13731, "func_end": 13732, "func_flags": 13733, "func_full_name": 13734, "func_graph_set_flag": 13735, "func_hash": 13736, "func_id": 13737, "func_match": 13738, "func_middle": 13739, "func_name": 13740, "func_opts": 13741, "func_pos": 13742, "func_prolog_dec": 13743, "func_prolog_preempt_disable": 13744, "func_ptr_is_kernel_text": 13745, "func_set_flag": 13746, "func_stack": 13747, "func_stack_trace": 13748, "funcgraph": 13749, "funcgraph_entry": 13750, "funcgraph_exit": 13751, "funcs": 13752, "function": 13753, "function_enabled": 13754, "function_filter_data": 13755, "function_graph": 13756, "function_name": 13757, "function_profile_call": 13758, "function_stack_trace_call": 13759, "function_stat_cmp": 13760, "function_stat_headers": 13761, "function_stat_next": 13762, "function_stat_show": 13763, "function_stat_start": 13764, "function_stats": 13765, "function_test_events_call": 13766, "function_trace": 13767, "function_trace_call": 13768, "function_trace_init": 13769, "function_trace_op": 13770, "function_trace_reset": 13771, "function_trace_start": 13772, "functions": 13773, "futex": 13774, "futex_cmd_mask": 13775, "futex_cmp_requeue": 13776, "futex_cmp_requeue_pi": 13777, "futex_cmpxchg_enabled": 13778, "futex_hashsize": 13779, "futex_lock_pi": 13780, "futex_offset": 13781, "futex_queues": 13782, "futex_requeue": 13783, "futex_tid_mask": 13784, "futex_uaddr": 13785, "futex_wait": 13786, "futex_wait_bitset": 13787, "futex_wait_requeue_pi": 13788, "futex_wake": 13789, "futex_wake_op": 13790, "fwork": 13791, "g": 13792, "gattr": 13793, "gc": 13794, "gc_flags": 13795, "gc_list": 13796, "gc_lock": 13797, "gcflags": 13798, "gcov_action": 13799, "gcov_add": 13800, "gcov_counters": 13801, "gcov_ctr_info": 13802, "gcov_data_fops": 13803, "gcov_data_magic": 13804, "gcov_enable_events": 13805, "gcov_event": 13806, "gcov_events_enabled": 13807, "gcov_fn_info": 13808, "gcov_fs_init": 13809, "gcov_h": 13810, "gcov_info": 13811, "gcov_info_add": 13812, "gcov_info_dup": 13813, "gcov_info_filename": 13814, "gcov_info_free": 13815, "gcov_info_head": 13816, "gcov_info_is_compatible": 13817, "gcov_info_link": 13818, "gcov_info_next": 13819, "gcov_info_reset": 13820, "gcov_info_unlink": 13821, "gcov_info_version": 13822, "gcov_init": 13823, "gcov_iter_free": 13824, "gcov_iter_get_info": 13825, "gcov_iter_new": 13826, "gcov_iter_next": 13827, "gcov_iter_start": 13828, "gcov_iter_write": 13829, "gcov_iterator": 13830, "gcov_link": 13831, "gcov_lock": 13832, "gcov_module_notifier": 13833, "gcov_nb": 13834, "gcov_node": 13835, "gcov_persist": 13836, "gcov_persist_setup": 13837, "gcov_remove": 13838, "gcov_reset_fops": 13839, "gcov_seq_next": 13840, "gcov_seq_open": 13841, "gcov_seq_ops": 13842, "gcov_seq_release": 13843, "gcov_seq_show": 13844, "gcov_seq_start": 13845, "gcov_seq_stop": 13846, "gcov_seq_write": 13847, "gcov_tag_counter_base": 13848, "gcov_tag_for_counter": 13849, "gcov_tag_function": 13850, "gcov_tag_function_length": 13851, "gcov_type": 13852, "gcov_version": 13853, "gdb_bpt_instr": 13854, "gdb_cmd_binwrite": 13855, "gdb_cmd_break": 13856, "gdb_cmd_detachkill": 13857, "gdb_cmd_exception_pass": 13858, "gdb_cmd_getregs": 13859, "gdb_cmd_memread": 13860, "gdb_cmd_memwrite": 13861, "gdb_cmd_query": 13862, "gdb_cmd_reboot": 13863, "gdb_cmd_reg_get": 13864, "gdb_cmd_reg_set": 13865, "gdb_cmd_setregs": 13866, "gdb_cmd_status": 13867, "gdb_cmd_task": 13868, "gdb_cmd_thread": 13869, "gdb_get_regs_helper": 13870, "gdb_hex_reg_helper": 13871, "gdb_regs": 13872, "gdb_regs_to_pt_regs": 13873, "gdb_serial_stub": 13874, "gdbmsgbuf": 13875, "gdbstub_exit": 13876, "gdbstub_msg_write": 13877, "gdbstub_prev_in_buf_pos": 13878, "gdbstub_read_wait": 13879, "gdbstub_state": 13880, "gdbstub_use_prev_in_buf": 13881, "gen": 13882, "generate_sched_domains": 13883, "generated": 13884, "generation": 13885, "generic_exec_single": 13886, "generic_file_llseek": 13887, "generic_handle_irq": 13888, "generic_handle_irq_desc": 13889, "generic_msi_domain_ops": 13890, "generic_ptrace_peekdata": 13891, "generic_ptrace_pokedata": 13892, "generic_smp_call_function_single_interrupt": 13893, "genl_admin_perm": 13894, "genl_family": 13895, "genl_id_generate": 13896, "genl_info": 13897, "genl_ops": 13898, "genl_register_family_with_ops": 13899, "genlhdr": 13900, "genlmsg_data": 13901, "genlmsg_end": 13902, "genlmsg_new": 13903, "genlmsg_put": 13904, "genlmsg_put_reply": 13905, "genlmsg_reply": 13906, "genlmsg_unicast": 13907, "genlmsghdr": 13908, "gentle_fair_sleepers": 13909, "get": 13910, "get_accumulated_info": 13911, "get_avenrun": 13912, "get_buffer": 13913, "get_cached_msi_msg": 13914, "get_callchain_buffers": 13915, "get_callchain_entry": 13916, "get_char_func": 13917, "get_child_by_name": 13918, "get_clock_desc": 13919, "get_cmdline": 13920, "get_compat_itimerspec": 13921, "get_compat_itimerval": 13922, "get_compat_sigevent": 13923, "get_count_order": 13924, "get_cpu": 13925, "get_cpu_idle_time_us": 13926, "get_cpu_iowait_time_us": 13927, "get_cpu_itimer": 13928, "get_cpu_usage": 13929, "get_cpu_var": 13930, "get_cred": 13931, "get_css_set": 13932, "get_ctx": 13933, "get_current_user": 13934, "get_dap_lock": 13935, "get_device": 13936, "get_dumpable": 13937, "get_endian": 13938, "get_fetch_size_function": 13939, "get_fields": 13940, "get_file": 13941, "get_file_raw_ptr": 13942, "get_file_rcu": 13943, "get_fn_info": 13944, "get_fn_size": 13945, "get_fp_mode": 13946, "get_fpemu_ctl": 13947, "get_fpexc_ctl": 13948, "get_fs": 13949, "get_fs_pwd": 13950, "get_fs_type": 13951, "get_func": 13952, "get_func_proto": 13953, "get_gendisk": 13954, "get_group": 13955, "get_group_info": 13956, "get_highmem_buffer": 13957, "get_highmem_page_buffer": 13958, "get_hwirq": 13959, "get_image_page": 13960, "get_incorrect_percent": 13961, "get_info_index": 13962, "get_iowait_load": 13963, "get_irq_regs": 13964, "get_jiffies_64": 13965, "get_kprobe": 13966, "get_ksymbol": 13967, "get_ksymbol_core": 13968, "get_ksymbol_mod": 13969, "get_ktype": 13970, "get_last_crashkernel": 13971, "get_link_target": 13972, "get_loc_data": 13973, "get_lock_depth": 13974, "get_lock_parent": 13975, "get_lock_stats": 13976, "get_mm_exe_file": 13977, "get_mm_hiwater_rss": 13978, "get_mm_hiwater_vm": 13979, "get_mm_rss": 13980, "get_modinfo": 13981, "get_monotonic_boottime": 13982, "get_monotonic_coarse": 13983, "get_monotonic_coarse64": 13984, "get_net": 13985, "get_next_timer_interrupt": 13986, "get_node_by_name": 13987, "get_node_info": 13988, "get_nohz_timer_target": 13989, "get_nr_threads": 13990, "get_nsproxy": 13991, "get_num_physpages": 13992, "get_numa_group": 13993, "get_offset": 13994, "get_online_cpus": 13995, "get_optimized_kprobe": 13996, "get_option": 13997, "get_order": 13998, "get_packet": 13999, "get_page": 14000, "get_parent": 14001, "get_parent_ip": 14002, "get_pdu_int": 14003, "get_pdu_remap": 14004, "get_pid": 14005, "get_pid_ns": 14006, "get_pid_task": 14007, "get_posix_clock": 14008, "get_pred_parent": 14009, "get_proc_ns": 14010, "get_prog": 14011, "get_pwq": 14012, "get_random_bytes": 14013, "get_random_int": 14014, "get_recursion_context": 14015, "get_return_for_leaf": 14016, "get_rloc_data": 14017, "get_rloc_len": 14018, "get_rloc_offs": 14019, "get_robust_list": 14020, "get_rq_runnable_load": 14021, "get_rr_interval": 14022, "get_rr_interval_fair": 14023, "get_rr_interval_idle": 14024, "get_rr_interval_rt": 14025, "get_safe_page": 14026, "get_saved_cmdlines": 14027, "get_sd_balance_interval": 14028, "get_sd_load_idx": 14029, "get_seccomp_filter": 14030, "get_seconds": 14031, "get_signal": 14032, "get_softlockup_thresh": 14033, "get_state": 14034, "get_state_synchronize_rcu": 14035, "get_swap_page_of_type": 14036, "get_swap_reader": 14037, "get_swap_writer": 14038, "get_symbol_offset": 14039, "get_symbol_pos": 14040, "get_sysctl": 14041, "get_sysctl_timer_migration": 14042, "get_taint": 14043, "get_task_comm": 14044, "get_task_cred": 14045, "get_task_io_context": 14046, "get_task_mm": 14047, "get_task_pid": 14048, "get_task_struct": 14049, "get_time": 14050, "get_timestamp": 14051, "get_trampoline_vaddr": 14052, "get_tree": 14053, "get_trigger_ops": 14054, "get_tsc_ctl": 14055, "get_type": 14056, "get_uid": 14057, "get_unalign_ctl": 14058, "get_unaligned_be16": 14059, "get_unaligned_be32": 14060, "get_unbound_pool": 14061, "get_unmapped_area": 14062, "get_update_sysctl_factor": 14063, "get_usage_char": 14064, "get_usage_chars": 14065, "get_user": 14066, "get_user_cpu_mask": 14067, "get_user_ns": 14068, "get_user_pages": 14069, "get_user_stack_nth": 14070, "get_utask": 14071, "get_uts_ns": 14072, "get_value": 14073, "get_vfs_caps_from_disk": 14074, "get_vtime_delta": 14075, "get_wchan": 14076, "get_work_color": 14077, "get_work_pool": 14078, "get_work_pool_id": 14079, "get_work_pwq": 14080, "get_xol_area": 14081, "get_zeroed_page": 14082, "getboottime64": 14083, "getcpu": 14084, "getcpu_cache": 14085, "getegid": 14086, "getegid16": 14087, "geteuid": 14088, "geteuid16": 14089, "getgid": 14090, "getgid16": 14091, "getgroups16": 14092, "gethostname": 14093, "getitimer": 14094, "getname": 14095, "getname_kernel": 14096, "getnstime_raw_and_real": 14097, "getnstimeofday": 14098, "getnstimeofday64": 14099, "getpgid": 14100, "getpgrp": 14101, "getpid": 14102, "getppid": 14103, "getpriority": 14104, "getrawmonotonic": 14105, "getrawmonotonic64": 14106, "getresgid": 14107, "getresgid16": 14108, "getresuid16": 14109, "getrlimit": 14110, "getrusage": 14111, "getsid": 14112, "getthread": 14113, "gettid": 14114, "gettime": 14115, "gettimeofday": 14116, "getuid": 14117, "getuid16": 14118, "gf": 14119, "gfp": 14120, "gfp_atomic": 14121, "gfp_extra_flags": 14122, "gfp_flags": 14123, "gfp_highuser": 14124, "gfp_kdb": 14125, "gfp_kernel": 14126, "gfp_mask": 14127, "gfp_nofs": 14128, "gfp_nowait": 14129, "gfp_t": 14130, "gfp_temporary": 14131, "gfp_trace": 14132, "gfp_user": 14133, "gfpflags": 14134, "gid": 14135, "gid_eq": 14136, "gid_gt": 14137, "gid_gte": 14138, "gid_lt": 14139, "gid_lte": 14140, "gid_m_show": 14141, "gid_m_start": 14142, "gid_map": 14143, "gid_t": 14144, "gid_valid": 14145, "gidsetsize": 14146, "glob": 14147, "global": 14148, "global_list": 14149, "global_ops": 14150, "global_page_state": 14151, "global_root_gid": 14152, "global_root_uid": 14153, "global_rt_period": 14154, "global_rt_runtime": 14155, "global_trace": 14156, "go": 14157, "going": 14158, "goner": 14159, "good_mm": 14160, "good_one": 14161, "good_sigevent": 14162, "got_name": 14163, "got_nohz_idle_kick": 14164, "got_you_moron": 14165, "gotcbs": 14166, "goto": 14167, "gp": 14168, "gp_activity": 14169, "gp_cond": 14170, "gp_cond1": 14171, "gp_duration": 14172, "gp_exp": 14173, "gp_exp1": 14174, "gp_flags": 14175, "gp_init_delay": 14176, "gp_kthread": 14177, "gp_max": 14178, "gp_normal": 14179, "gp_normal1": 14180, "gp_snap": 14181, "gp_start": 14182, "gp_state": 14183, "gp_sync": 14184, "gp_sync1": 14185, "gp_tasks": 14186, "gp_wq": 14187, "gpa": 14188, "gpage": 14189, "gpkt": 14190, "gpl": 14191, "gpl_compatible": 14192, "gpl_crcs": 14193, "gpl_future_crcs": 14194, "gpl_future_syms": 14195, "gpl_only": 14196, "gpl_syms": 14197, "gplok": 14198, "gpmax": 14199, "gpnum": 14200, "gps": 14201, "gpwrap": 14202, "gran": 14203, "graph": 14204, "graph_array": 14205, "graph_depth_fops": 14206, "graph_depth_read": 14207, "graph_depth_write": 14208, "graph_ent": 14209, "graph_functions": 14210, "graph_hang_thresh": 14211, "graph_init_task": 14212, "graph_lock": 14213, "graph_max_func_test": 14214, "graph_ops": 14215, "graph_ret": 14216, "graph_trace": 14217, "graph_trace_close": 14218, "graph_trace_entry_event": 14219, "graph_trace_init": 14220, "graph_trace_open": 14221, "graph_trace_reset": 14222, "graph_trace_ret_event": 14223, "graph_trace_update_thresh": 14224, "graph_tracer_flags": 14225, "graph_unlock": 14226, "greater": 14227, "greatest": 14228, "grep": 14229, "group": 14230, "group_at": 14231, "group_balance_cpu": 14232, "group_can_go_on": 14233, "group_capacity": 14234, "group_cfs_rq": 14235, "group_classify": 14236, "group_dead": 14237, "group_entry": 14238, "group_error": 14239, "group_event": 14240, "group_exit": 14241, "group_exit_code": 14242, "group_faults": 14243, "group_faults_cpu": 14244, "group_first_cpu": 14245, "group_flags": 14246, "group_has_capacity": 14247, "group_imbalance": 14248, "group_imbalanced": 14249, "group_info": 14250, "group_is_overloaded": 14251, "group_leader": 14252, "group_load": 14253, "group_lock": 14254, "group_no_capacity": 14255, "group_node": 14256, "group_other": 14257, "group_overloaded": 14258, "group_path": 14259, "group_rq": 14260, "group_rt_rq": 14261, "group_rwsem": 14262, "group_sched_in": 14263, "group_sched_out": 14264, "group_send_sig_info": 14265, "group_stop": 14266, "group_stop_count": 14267, "group_type": 14268, "group_usage": 14269, "group_weight": 14270, "groupimp": 14271, "grouplist": 14272, "groupmask": 14273, "groups": 14274, "groups16_from_user": 14275, "groups16_to_user": 14276, "groups_alloc": 14277, "groupweight": 14278, "grow_tree_refs": 14279, "grp": 14280, "grphi": 14281, "grplo": 14282, "grpmask": 14283, "grpnum": 14284, "gstop": 14285, "gstop_done": 14286, "gtime": 14287, "guarantee_online_cpus": 14288, "guarantee_online_mems": 14289, "h": 14290, "h_free": 14291, "h_load": 14292, "h_load_next": 14293, "h_nr_running": 14294, "h_offset": 14295, "h_used": 14296, "halt_fast_timekeeper": 14297, "handle": 14298, "handle_bad_irq": 14299, "handle_ctrl_cmd": 14300, "handle_edge_eoi_irq": 14301, "handle_edge_irq": 14302, "handle_error": 14303, "handle_event": 14304, "handle_fasteoi_irq": 14305, "handle_futex_death": 14306, "handle_irq": 14307, "handle_irq_event": 14308, "handle_irq_event_percpu": 14309, "handle_level_irq": 14310, "handle_nested_irq": 14311, "handle_one": 14312, "handle_op": 14313, "handle_path": 14314, "handle_percpu_devid_irq": 14315, "handle_percpu_irq": 14316, "handle_poweroff": 14317, "handle_simple_irq": 14318, "handle_singlestep": 14319, "handle_swbp": 14320, "handle_trampoline": 14321, "handle_unknown": 14322, "handle_uretprobe_chain": 14323, "handled": 14324, "handler": 14325, "handler_chain": 14326, "handler_data": 14327, "handler_errors": 14328, "handler_fn": 14329, "handler_name": 14330, "happens": 14331, "hard": 14332, "hard_irq_disable": 14333, "hard_watchdog_warn": 14334, "hardirq": 14335, "hardirq_context": 14336, "hardirq_count": 14337, "hardirq_disable_event": 14338, "hardirq_disable_ip": 14339, "hardirq_enable_event": 14340, "hardirq_enable_ip": 14341, "hardirq_offset": 14342, "hardirq_shift": 14343, "hardirq_verbose": 14344, "hardirqs_enabled": 14345, "hardirqs_off": 14346, "hardirqs_off_events": 14347, "hardirqs_on_events": 14348, "hardlockup_panic": 14349, "hardpps": 14350, "hardpps_update_phase": 14351, "hardsoft_irq": 14352, "has": 14353, "has_aux": 14354, "has_branch_stack": 14355, "has_child_subreaper": 14356, "has_cntl": 14357, "has_crcs": 14358, "has_free_capacity": 14359, "has_in_flight": 14360, "has_ns_capability": 14361, "has_ns_capability_noaudit": 14362, "has_pending": 14363, "has_pending_signals": 14364, "has_perm": 14365, "has_pushable_tasks": 14366, "hash": 14367, "hash32_ptr": 14368, "hash_32": 14369, "hash_add": 14370, "hash_algo_name": 14371, "hash_bits": 14372, "hash_contains_ip": 14373, "hash_del": 14374, "hash_early": 14375, "hash_entry": 14376, "hash_for_each": 14377, "hash_for_each_possible": 14378, "hash_head": 14379, "hash_init": 14380, "hash_lock": 14381, "hash_long": 14382, "hash_node": 14383, "hash_ptr": 14384, "hash_size": 14385, "hash_small": 14386, "hashent": 14387, "have": 14388, "have_arch_copy_siginfo_to_user": 14389, "have_arch_pick_mmap_layout": 14390, "have_jump_label": 14391, "have_lost": 14392, "have_rcu_nocb_mask": 14393, "have_rt_push_ipi": 14394, "hc": 14395, "hcpu": 14396, "hd": 14397, "hd_struct": 14398, "hdr": 14399, "he": 14400, "head": 14401, "head_bit": 14402, "head_page": 14403, "head_page_with_bit": 14404, "head_ptr": 14405, "header": 14406, "header_iter": 14407, "header_size": 14408, "height": 14409, "held_lock": 14410, "held_locks": 14411, "help": 14412, "help_msg": 14413, "helper_lock": 14414, "helper_unlock": 14415, "hentry": 14416, "here": 14417, "hex": 14418, "hex_asc": 14419, "hex_asc_hi": 14420, "hex_asc_lo": 14421, "hex_byte_pack": 14422, "hex_to_bin": 14423, "hhd": 14424, "hi1": 14425, "hi2": 14426, "hi_shift": 14427, "hi_softirq": 14428, "hib_bio_read_page": 14429, "hib_bio_write_page": 14430, "hib_resume_bdev": 14431, "hib_wait_on_bio_chain": 14432, "hibernate": 14433, "hibernate_image_size_init": 14434, "hibernate_preallocate_memory": 14435, "hibernate_reserved_size_init": 14436, "hibernate_sig": 14437, "hibernation_available": 14438, "hibernation_debug_sleep": 14439, "hibernation_first": 14440, "hibernation_invalid": 14441, "hibernation_max": 14442, "hibernation_mode": 14443, "hibernation_modes": 14444, "hibernation_ops": 14445, "hibernation_platform": 14446, "hibernation_platform_enter": 14447, "hibernation_reboot": 14448, "hibernation_restore": 14449, "hibernation_set_ops": 14450, "hibernation_shutdown": 14451, "hibernation_snapshot": 14452, "hibernation_suspend": 14453, "hibernation_test": 14454, "hidden": 14455, "hidx": 14456, "hierarchical_quota": 14457, "hierarchy_id": 14458, "high": 14459, "high2lowgid": 14460, "high2lowuid": 14461, "highbp": 14462, "highest_flag_domain": 14463, "highest_prio": 14464, "highmem_pbe": 14465, "highmem_pblist": 14466, "highpri": 14467, "highpri_nice_level": 14468, "highres": 14469, "hit": 14470, "hiter": 14471, "hits": 14472, "hiwater_rss": 14473, "hiwater_vm": 14474, "hlist": 14475, "hlist_add_head": 14476, "hlist_add_head_rcu": 14477, "hlist_del": 14478, "hlist_del_init": 14479, "hlist_del_rcu": 14480, "hlist_empty": 14481, "hlist_entry": 14482, "hlist_entry_safe": 14483, "hlist_first_rcu": 14484, "hlist_for_each_entry": 14485, "hlist_for_each_entry_rcu": 14486, "hlist_for_each_entry_rcu_notrace": 14487, "hlist_for_each_entry_safe": 14488, "hlist_head": 14489, "hlist_lock": 14490, "hlist_next_rcu": 14491, "hlist_node": 14492, "hlist_replace_rcu": 14493, "hlock": 14494, "hlock_class": 14495, "hlock_curr": 14496, "hnd": 14497, "hold_ctx": 14498, "hold_module_trace_bprintk_format": 14499, "holders_dir": 14500, "holding": 14501, "holdtime": 14502, "holdtime_stamp": 14503, "hole": 14504, "hole_end": 14505, "hole_start": 14506, "home_node": 14507, "hook": 14508, "host_data": 14509, "hostname": 14510, "hotcpu_notifier": 14511, "hotplug_cfd": 14512, "hotplug_cfd_notifier": 14513, "hotplug_cpu__broadcast_tick_pull": 14514, "hotplug_hrtick": 14515, "hotplug_threads": 14516, "hotplug_update_tasks": 14517, "hotplug_update_tasks_legacy": 14518, "hour": 14519, "housekeeping_affine": 14520, "housekeeping_mask": 14521, "how": 14522, "howto": 14523, "hp": 14524, "hp_thread_active": 14525, "hp_thread_none": 14526, "hp_thread_parked": 14527, "hr1": 14528, "hr2": 14529, "hr_delta": 14530, "hres_active": 14531, "hrint": 14532, "hrt": 14533, "hrtick": 14534, "hrtick_clear": 14535, "hrtick_csd": 14536, "hrtick_csd_pending": 14537, "hrtick_enabled": 14538, "hrtick_start": 14539, "hrtick_start_fair": 14540, "hrtick_timer": 14541, "hrtick_update": 14542, "hrtimer": 14543, "hrtimer_active": 14544, "hrtimer_add_expires": 14545, "hrtimer_add_expires_ns": 14546, "hrtimer_bases": 14547, "hrtimer_callback_running": 14548, "hrtimer_cancel": 14549, "hrtimer_cb_get_time": 14550, "hrtimer_cpu_base": 14551, "hrtimer_expires_remaining": 14552, "hrtimer_forward": 14553, "hrtimer_forward_now": 14554, "hrtimer_get_expires": 14555, "hrtimer_get_next_event": 14556, "hrtimer_get_remaining": 14557, "hrtimer_get_res": 14558, "hrtimer_get_softexpires": 14559, "hrtimer_init": 14560, "hrtimer_interrupt": 14561, "hrtimer_interrupts": 14562, "hrtimer_interrupts_saved": 14563, "hrtimer_is_hres_active": 14564, "hrtimer_is_queued": 14565, "hrtimer_max_clock_bases": 14566, "hrtimer_mode": 14567, "hrtimer_mode_abs": 14568, "hrtimer_mode_abs_pinned": 14569, "hrtimer_mode_rel": 14570, "hrtimer_mode_rel_pinned": 14571, "hrtimer_nanosleep": 14572, "hrtimer_nanosleep_restart": 14573, "hrtimer_norestart": 14574, "hrtimer_restart": 14575, "hrtimer_run_pending": 14576, "hrtimer_run_queues": 14577, "hrtimer_set_expires": 14578, "hrtimer_sleeper": 14579, "hrtimer_start": 14580, "hrtimer_start_expires": 14581, "hrtimer_try_to_cancel": 14582, "hrtimers_resume": 14583, "hsd": 14584, "ht": 14585, "htab": 14586, "htab_elem": 14587, "htab_map_alloc": 14588, "htab_map_delete_elem": 14589, "htab_map_free": 14590, "htab_map_get_next_key": 14591, "htab_map_hash": 14592, "htab_map_lookup_elem": 14593, "htab_map_update_elem": 14594, "htab_ops": 14595, "htab_type": 14596, "hugepages_treat_as_movable": 14597, "hugetlb_mempolicy_sysctl_handler": 14598, "hugetlb_overcommit_handler": 14599, "hugetlb_sysctl_handler": 14600, "hung_task_batching": 14601, "hung_task_init": 14602, "hung_task_panic": 14603, "hung_task_panic_setup": 14604, "hung_task_timeout_max": 14605, "hw": 14606, "hw_breakpoint": 14607, "hw_irq": 14608, "hw_nmi_get_sample_period": 14609, "hw_perf_event": 14610, "hwc": 14611, "hweight64": 14612, "hwirq": 14613, "hwirq_base": 14614, "hwirq_max": 14615, "hz": 14616, "hz_to_msec_den": 14617, "hz_to_msec_mul32": 14618, "hz_to_msec_num": 14619, "hz_to_msec_shr32": 14620, "hz_to_usec_den": 14621, "hz_to_usec_mul32": 14622, "hz_to_usec_num": 14623, "hz_to_usec_shr32": 14624, "i": 14625, "i_cdev": 14626, "i_fsnotify_marks": 14627, "i_generation": 14628, "i_gid": 14629, "i_ino": 14630, "i_mapping": 14631, "i_mmap": 14632, "i_mmap_lock_read": 14633, "i_mmap_lock_write": 14634, "i_mmap_unlock_read": 14635, "i_mmap_unlock_write": 14636, "i_mmap_writable": 14637, "i_mode": 14638, "i_mutex": 14639, "i_next": 14640, "i_private": 14641, "i_rdev": 14642, "i_sb": 14643, "i_size_read": 14644, "i_uid": 14645, "i_writecount": 14646, "ia_gid": 14647, "ia_uid": 14648, "ia_valid": 14649, "iattr": 14650, "id": 14651, "id2": 14652, "id_buf": 14653, "id_header_size": 14654, "id_type": 14655, "ida": 14656, "ida_destroy": 14657, "ida_init": 14658, "ida_simple_get": 14659, "ida_simple_remove": 14660, "idata": 14661, "ideal_runtime": 14662, "ident": 14663, "idle": 14664, "idle_active": 14665, "idle_balance": 14666, "idle_calls": 14667, "idle_cpu": 14668, "idle_cpus": 14669, "idle_cpus_mask": 14670, "idle_enter_fair": 14671, "idle_entrytime": 14672, "idle_exit_fair": 14673, "idle_exittime": 14674, "idle_expires": 14675, "idle_get_state": 14676, "idle_idx": 14677, "idle_init": 14678, "idle_jiffies": 14679, "idle_list": 14680, "idle_ret_stack": 14681, "idle_sched_class": 14682, "idle_set_state": 14683, "idle_sleeps": 14684, "idle_sleeptime": 14685, "idle_stamp": 14686, "idle_state": 14687, "idle_task": 14688, "idle_task_exit": 14689, "idle_thread_get": 14690, "idle_thread_set_boot_cpu": 14691, "idle_threads": 14692, "idle_threads_init": 14693, "idle_time_ns": 14694, "idle_timer": 14695, "idle_waketime": 14696, "idle_worker_timeout": 14697, "idlest": 14698, "idr": 14699, "idr_alloc": 14700, "idr_alloc_cyclic": 14701, "idr_destroy": 14702, "idr_find": 14703, "idr_get_next": 14704, "idr_init": 14705, "idr_preload": 14706, "idr_preload_end": 14707, "idr_remove": 14708, "idr_replace": 14709, "idx": 14710, "idx1": 14711, "idx2": 14712, "idx_invalid": 14713, "if": 14714, "if_assign": 14715, "ignore": 14716, "ignore_errors": 14717, "ignore_loglevel": 14718, "ignore_signals": 14719, "ignore_state": 14720, "ignored": 14721, "ignoring": 14722, "ignoring_children": 14723, "igrab": 14724, "ikconfig_cleanup": 14725, "ikconfig_file_ops": 14726, "ikconfig_init": 14727, "ikconfig_read_current": 14728, "ilb": 14729, "ilb_cpu": 14730, "illegal": 14731, "ilog2": 14732, "image": 14733, "image_loader_data": 14734, "image_pages": 14735, "image_ptr": 14736, "image_size": 14737, "imb": 14738, "imbalance": 14739, "imbalance_pct": 14740, "imbn": 14741, "iminor": 14742, "imm": 14743, "imm64": 14744, "immediately": 14745, "imp": 14746, "implementation": 14747, "important": 14748, "in": 14749, "in_atomic": 14750, "in_atomic_preempt_off": 14751, "in_dbg_master": 14752, "in_egroup_p": 14753, "in_exec": 14754, "in_group_p": 14755, "in_hardirq": 14756, "in_hash": 14757, "in_interrupt": 14758, "in_iowait": 14759, "in_irq": 14760, "in_lock_functions": 14761, "in_mask": 14762, "in_new": 14763, "in_nmi": 14764, "in_ns": 14765, "in_old": 14766, "in_other_hash": 14767, "in_quote": 14768, "in_serving_softirq": 14769, "in_softirq": 14770, "in_string": 14771, "in_suspend": 14772, "in_syscall": 14773, "inactive": 14774, "inblock": 14775, "inc": 14776, "inc_chains": 14777, "inc_mm_counter": 14778, "inc_rt_group": 14779, "inc_rt_migration": 14780, "inc_rt_prio": 14781, "inc_rt_prio_smp": 14782, "inc_rt_tasks": 14783, "incby": 14784, "include": 14785, "incorrect": 14786, "incr": 14787, "incr_error": 14788, "increment": 14789, "increment_cpu_stall_ticks": 14790, "increment_wakelocks_number": 14791, "ind": 14792, "ind_destination": 14793, "ind_done": 14794, "ind_indirection": 14795, "ind_page": 14796, "ind_source": 14797, "index": 14798, "individual": 14799, "infix": 14800, "infix_advance": 14801, "infix_get_op": 14802, "infix_next": 14803, "infix_peek": 14804, "infix_string": 14805, "inflight": 14806, "info": 14807, "info1": 14808, "info2": 14809, "info_test": 14810, "information": 14811, "infosec": 14812, "ing": 14813, "inh": 14814, "inherit": 14815, "inherit_stat": 14816, "inheritable": 14817, "inidle": 14818, "init": 14819, "init_aggr_kprobe": 14820, "init_and_link_css": 14821, "init_annotated_branch_stats": 14822, "init_blk_tracer": 14823, "init_branch_tracer": 14824, "init_callback_list": 14825, "init_cfs_bandwidth": 14826, "init_cfs_rq": 14827, "init_cfs_rq_runtime": 14828, "init_cgroup_housekeeping": 14829, "init_cgroup_root": 14830, "init_completion": 14831, "init_cpu_online": 14832, "init_cpu_possible": 14833, "init_cpu_present": 14834, "init_cred": 14835, "init_css_set": 14836, "init_default_callback_list": 14837, "init_defrootdomain": 14838, "init_delayed_work": 14839, "init_dl_bandwidth": 14840, "init_dl_bw": 14841, "init_dl_rq": 14842, "init_dl_task_timer": 14843, "init_fs_pin": 14844, "init_ftrace_syscalls": 14845, "init_graph_trace": 14846, "init_graph_tracefs": 14847, "init_groups": 14848, "init_header": 14849, "init_header_complete": 14850, "init_hlist_head": 14851, "init_hlist_node": 14852, "init_hrtick": 14853, "init_idle": 14854, "init_idle_bootup_task": 14855, "init_idle_pids": 14856, "init_idle_preempt_count": 14857, "init_ipc_ns": 14858, "init_irq_default_affinity": 14859, "init_irq_proc": 14860, "init_irq_work": 14861, "init_irqsoff_tracer": 14862, "init_kernel_text": 14863, "init_kprobe_trace": 14864, "init_kprobes": 14865, "init_kstat_irqs": 14866, "init_list_head": 14867, "init_llist_head": 14868, "init_lstats_procfs": 14869, "init_mm": 14870, "init_mmio_trace": 14871, "init_module": 14872, "init_name": 14873, "init_net": 14874, "init_new_context": 14875, "init_nocb_callback_list": 14876, "init_node": 14877, "init_nsproxy": 14878, "init_offset_mask": 14879, "init_ops_hash": 14880, "init_pid_ns": 14881, "init_pids": 14882, "init_posix_timers": 14883, "init_pred": 14884, "init_pwq": 14885, "init_radix_tree": 14886, "init_rcu_head": 14887, "init_rcu_head_on_stack": 14888, "init_reg_state": 14889, "init_ret": 14890, "init_ro_size": 14891, "init_rootdomain": 14892, "init_rq_hrtick": 14893, "init_rt_bandwidth": 14894, "init_rt_rq": 14895, "init_rttest": 14896, "init_rwsem": 14897, "init_sched_dl_class": 14898, "init_sched_domains": 14899, "init_sched_fair_class": 14900, "init_sched_groups_capacity": 14901, "init_sched_rt_class": 14902, "init_sd_lb_stats": 14903, "init_sigpending": 14904, "init_size": 14905, "init_srcu_struct": 14906, "init_srcu_struct_fields": 14907, "init_stat_file": 14908, "init_struct_pid": 14909, "init_syscall_trace": 14910, "init_task": 14911, "init_task_comm": 14912, "init_task_pid": 14913, "init_task_preempt_count": 14914, "init_task_runnable_average": 14915, "init_task_work": 14916, "init_test_thread": 14917, "init_text_size": 14918, "init_tg_cfs_entry": 14919, "init_tg_rt_entry": 14920, "init_timer_cpu": 14921, "init_timer_cpus": 14922, "init_timer_deferrable": 14923, "init_timer_key": 14924, "init_timer_on_stack_key": 14925, "init_timer_stats": 14926, "init_timers": 14927, "init_trace_uprobe_filter": 14928, "init_uprobe_trace": 14929, "init_uprobes": 14930, "init_user": 14931, "init_user_ns": 14932, "init_uts_ns": 14933, "init_utsname": 14934, "init_wait": 14935, "init_waitqueue_head": 14936, "init_wakeup_tracer": 14937, "init_work": 14938, "init_work_onstack": 14939, "init_worker_pool": 14940, "init_workqueues": 14941, "initcall_debug": 14942, "initcnt": 14943, "initial": 14944, "initial_count": 14945, "initial_jiffies": 14946, "initialiser": 14947, "initialization": 14948, "initrd_buf": 14949, "initrd_buf_len": 14950, "initrd_fd": 14951, "initsize": 14952, "initstate": 14953, "inlin": 14954, "inline": 14955, "ino": 14956, "ino_generation": 14957, "inode": 14958, "inode_f": 14959, "inode_mark": 14960, "inode_permission": 14961, "inodes_stat": 14962, "inotify_max_queued_events": 14963, "inotify_max_user_instances": 14964, "inotify_max_user_watches": 14965, "inotify_table": 14966, "inprogress": 14967, "input": 14968, "insert_hash": 14969, "insert_kthread_work": 14970, "insert_resource": 14971, "insert_resource_conflict": 14972, "insert_resource_expand_to_fit": 14973, "insert_stat": 14974, "insert_uprobe": 14975, "insert_work": 14976, "insert_wq_barrier": 14977, "insn": 14978, "insn_buf": 14979, "insn_cnt": 14980, "insn_idx": 14981, "insn_processed": 14982, "insn_size": 14983, "insn_stack": 14984, "insn_state": 14985, "insns": 14986, "insnsi": 14987, "inst": 14988, "install": 14989, "install_breakpoint": 14990, "install_special_mapping": 14991, "install_thread_keyring_to_cred": 14992, "installed": 14993, "instance": 14994, "instances": 14995, "instruction_pointer": 14996, "instruction_pointer_set": 14997, "int": 14998, "int64_t": 14999, "int_max": 15000, "int_min": 15001, "int_sqrt": 15002, "int_to_threadref": 15003, "inter": 15004, "internal": 15005, "internal_add_timer": 15006, "internal_trace_puts": 15007, "interp_fdpic_loadmap": 15008, "interrupt": 15009, "interrupted": 15010, "interrupts": 15011, "interval": 15012, "into": 15013, "inum": 15014, "inuse": 15015, "inv_weight": 15016, "invalid": 15017, "invalid_rcu_flavor": 15018, "invalid_uid": 15019, "invalidating": 15020, "invoke_rcu_callbacks": 15021, "invoke_rcu_callbacks_kthread": 15022, "invoke_rcu_core": 15023, "invoke_softirq": 15024, "io_context": 15025, "io_delay_type": 15026, "io_num": 15027, "io_schedule": 15028, "io_schedule_timeout": 15029, "io_space_limit": 15030, "io_start": 15031, "ioac": 15032, "ioc": 15033, "ioc_task_link": 15034, "iocsize_mask": 15035, "ioctl": 15036, "ioctx_lock": 15037, "ioctx_table": 15038, "iomem_is_exclusive": 15039, "iomem_map_sanity_check": 15040, "iomem_open": 15041, "iomem_resource": 15042, "ioport_resource": 15043, "ioports_open": 15044, "ioprio": 15045, "ioprio_valid": 15046, "ioread32be": 15047, "ioresource_busy": 15048, "ioresource_exclusive": 15049, "ioresource_io": 15050, "ioresource_mem": 15051, "ioresource_muxed": 15052, "ioresource_sizealign": 15053, "ioresource_startalign": 15054, "ioresource_unset": 15055, "ioresources_init": 15056, "iov_base": 15057, "iov_len": 15058, "iovec": 15059, "iowait": 15060, "iowait_count": 15061, "iowait_sleeptime": 15062, "iowait_sum": 15063, "iowrite32be": 15064, "ip": 15065, "ip_fmt": 15066, "ipc": 15067, "ipc_ns": 15068, "ipcp": 15069, "iput": 15070, "irq": 15071, "irq_ack": 15072, "irq_affinity_hint_proc_fops": 15073, "irq_affinity_hint_proc_open": 15074, "irq_affinity_hint_proc_show": 15075, "irq_affinity_list_proc_fops": 15076, "irq_affinity_list_proc_open": 15077, "irq_affinity_list_proc_show": 15078, "irq_affinity_list_proc_write": 15079, "irq_affinity_notify": 15080, "irq_affinity_proc_fops": 15081, "irq_affinity_proc_open": 15082, "irq_affinity_proc_show": 15083, "irq_affinity_proc_write": 15084, "irq_alloc_descs": 15085, "irq_alloc_domain_generic_chips": 15086, "irq_alloc_generic_chip": 15087, "irq_alloc_hwirqs": 15088, "irq_base": 15089, "irq_bitmap_bits": 15090, "irq_bus_lock": 15091, "irq_bus_sync_unlock": 15092, "irq_calc_mask": 15093, "irq_can_move_pcntxt": 15094, "irq_can_set_affinity": 15095, "irq_capable": 15096, "irq_check_poll": 15097, "irq_chip": 15098, "irq_chip_ack_parent": 15099, "irq_chip_compose_msi_msg": 15100, "irq_chip_eoi_parent": 15101, "irq_chip_generic": 15102, "irq_chip_mask_parent": 15103, "irq_chip_retrigger_hierarchy": 15104, "irq_chip_set_affinity_parent": 15105, "irq_chip_set_wake_parent": 15106, "irq_chip_type": 15107, "irq_chip_unmask_parent": 15108, "irq_chip_write_msi_msg": 15109, "irq_clear_status_flags": 15110, "irq_cnt": 15111, "irq_compose_msi_msg": 15112, "irq_context": 15113, "irq_copy_pending": 15114, "irq_count": 15115, "irq_cpu_offline": 15116, "irq_cpu_online": 15117, "irq_cpu_stop_queue_work": 15118, "irq_cpu_stop_queue_work_info": 15119, "irq_cpustat_t": 15120, "irq_create_direct_mapping": 15121, "irq_create_mapping": 15122, "irq_data": 15123, "irq_data_get_chip_type": 15124, "irq_data_get_irq_chip": 15125, "irq_data_get_irq_chip_data": 15126, "irq_data_to_desc": 15127, "irq_default_affinity": 15128, "irq_default_domain": 15129, "irq_default_init_flags": 15130, "irq_default_primary_handler": 15131, "irq_delta": 15132, "irq_depth": 15133, "irq_desc": 15134, "irq_desc_get_chip": 15135, "irq_desc_get_irq_data": 15136, "irq_desc_lock_class": 15137, "irq_desc_tree": 15138, "irq_disable": 15139, "irq_do_set_affinity": 15140, "irq_domain": 15141, "irq_domain_activate_irq": 15142, "irq_domain_add_hierarchy": 15143, "irq_domain_add_simple": 15144, "irq_domain_alloc_descs": 15145, "irq_domain_alloc_irqs_parent": 15146, "irq_domain_associate": 15147, "irq_domain_associate_many": 15148, "irq_domain_check_hierarchy": 15149, "irq_domain_chip_generic": 15150, "irq_domain_deactivate_irq": 15151, "irq_domain_disassociate": 15152, "irq_domain_free_irqs": 15153, "irq_domain_free_irqs_top": 15154, "irq_domain_list": 15155, "irq_domain_mapping": 15156, "irq_domain_mutex": 15157, "irq_domain_ops": 15158, "irq_domain_remove": 15159, "irq_domain_set_hwirq_and_chip": 15160, "irq_domain_xlate_onetwocell": 15161, "irq_enable": 15162, "irq_enter": 15163, "irq_eoi": 15164, "irq_events": 15165, "irq_exit": 15166, "irq_expand_nr_irqs": 15167, "irq_finalize_oneshot": 15168, "irq_find_host": 15169, "irq_find_mapping": 15170, "irq_flags": 15171, "irq_flags_to_clear": 15172, "irq_flags_to_set": 15173, "irq_flow_handler_t": 15174, "irq_forced_thread_fn": 15175, "irq_found": 15176, "irq_free_desc": 15177, "irq_free_descs": 15178, "irq_free_hwirqs": 15179, "irq_gc_ack_clr_bit": 15180, "irq_gc_ack_set_bit": 15181, "irq_gc_be_io": 15182, "irq_gc_eoi": 15183, "irq_gc_flags": 15184, "irq_gc_get_irq_data": 15185, "irq_gc_init_mask_cache": 15186, "irq_gc_init_nested_lock": 15187, "irq_gc_init_ops": 15188, "irq_gc_lock": 15189, "irq_gc_mask_cache_per_type": 15190, "irq_gc_mask_clr_bit": 15191, "irq_gc_mask_disable_reg": 15192, "irq_gc_mask_disable_reg_and_ack": 15193, "irq_gc_mask_set_bit": 15194, "irq_gc_no_mask": 15195, "irq_gc_noop": 15196, "irq_gc_resume": 15197, "irq_gc_set_wake": 15198, "irq_gc_shutdown": 15199, "irq_gc_suspend": 15200, "irq_gc_syscore_ops": 15201, "irq_gc_unlock": 15202, "irq_gc_unmask_enable_reg": 15203, "irq_generic_chip_ops": 15204, "irq_get_desc_buslock": 15205, "irq_get_desc_check_global": 15206, "irq_get_desc_check_percpu": 15207, "irq_get_desc_lock": 15208, "irq_get_domain_generic_chip": 15209, "irq_get_irq_data": 15210, "irq_get_irqchip_state": 15211, "irq_get_msi_desc": 15212, "irq_get_next_irq": 15213, "irq_get_pending": 15214, "irq_handled": 15215, "irq_handler_t": 15216, "irq_hw_number_t": 15217, "irq_init_desc": 15218, "irq_init_generic_chip": 15219, "irq_insert_desc": 15220, "irq_is_polled": 15221, "irq_level": 15222, "irq_lock_sparse": 15223, "irq_map_generic_chip": 15224, "irq_mark_irq": 15225, "irq_mask": 15226, "irq_mask_ack": 15227, "irq_may_run": 15228, "irq_modify_status": 15229, "irq_move_irq": 15230, "irq_move_masked_irq": 15231, "irq_move_pcntxt": 15232, "irq_move_pending": 15233, "irq_nested_lock_class": 15234, "irq_nested_primary_handler": 15235, "irq_nested_thread": 15236, "irq_no_balancing": 15237, "irq_noautoen": 15238, "irq_node_proc_fops": 15239, "irq_node_proc_open": 15240, "irq_node_proc_show": 15241, "irq_none": 15242, "irq_noprobe": 15243, "irq_norequest": 15244, "irq_nothread": 15245, "irq_offset": 15246, "irq_per_cpu": 15247, "irq_per_cpu_devid": 15248, "irq_percpu_disable": 15249, "irq_percpu_enable": 15250, "irq_pm_check_wakeup": 15251, "irq_pm_init_ops": 15252, "irq_pm_install_action": 15253, "irq_pm_remove_action": 15254, "irq_pm_shutdown": 15255, "irq_pm_syscore_ops": 15256, "irq_pm_syscore_resume": 15257, "irq_poll_active": 15258, "irq_poll_cpu": 15259, "irq_print_chip": 15260, "irq_put_desc_busunlock": 15261, "irq_put_desc_unlock": 15262, "irq_readl_be": 15263, "irq_reg_readl": 15264, "irq_reg_writel": 15265, "irq_release_resources": 15266, "irq_remove_generic_chip": 15267, "irq_request_resources": 15268, "irq_resume": 15269, "irq_retrigger": 15270, "irq_select_affinity": 15271, "irq_select_affinity_usr": 15272, "irq_set_affinity": 15273, "irq_set_affinity_hint": 15274, "irq_set_affinity_locked": 15275, "irq_set_affinity_notifier": 15276, "irq_set_chip": 15277, "irq_set_chip_and_handler": 15278, "irq_set_chip_and_handler_name": 15279, "irq_set_chip_data": 15280, "irq_set_default_host": 15281, "irq_set_handler": 15282, "irq_set_handler_data": 15283, "irq_set_irq_type": 15284, "irq_set_irq_wake": 15285, "irq_set_irqchip_state": 15286, "irq_set_lockdep_class": 15287, "irq_set_mask_ok": 15288, "irq_set_mask_ok_done": 15289, "irq_set_mask_ok_nocopy": 15290, "irq_set_msi_desc": 15291, "irq_set_msi_desc_off": 15292, "irq_set_parent": 15293, "irq_set_percpu_devid": 15294, "irq_set_percpu_devid_flags": 15295, "irq_set_status_flags": 15296, "irq_set_thread_affinity": 15297, "irq_set_type": 15298, "irq_set_wake": 15299, "irq_settings_can_autoenable": 15300, "irq_settings_can_move_pcntxt": 15301, "irq_settings_can_probe": 15302, "irq_settings_can_request": 15303, "irq_settings_can_thread": 15304, "irq_settings_clr_and_set": 15305, "irq_settings_clr_level": 15306, "irq_settings_clr_noprobe": 15307, "irq_settings_clr_norequest": 15308, "irq_settings_clr_nothread": 15309, "irq_settings_get_trigger_mask": 15310, "irq_settings_has_no_balance_set": 15311, "irq_settings_is_level": 15312, "irq_settings_is_nested_thread": 15313, "irq_settings_is_per_cpu": 15314, "irq_settings_is_per_cpu_devid": 15315, "irq_settings_is_polled": 15316, "irq_settings_set_level": 15317, "irq_settings_set_no_balancing": 15318, "irq_settings_set_noprobe": 15319, "irq_settings_set_norequest": 15320, "irq_settings_set_nothread": 15321, "irq_settings_set_per_cpu": 15322, "irq_settings_set_trigger_mask": 15323, "irq_setup_alt_chip": 15324, "irq_setup_forced_threading": 15325, "irq_setup_generic_chip": 15326, "irq_shutdown": 15327, "irq_spurious_proc_fops": 15328, "irq_spurious_proc_open": 15329, "irq_spurious_proc_show": 15330, "irq_start_time": 15331, "irq_startup": 15332, "irq_stat": 15333, "irq_state_clr_disabled": 15334, "irq_state_clr_masked": 15335, "irq_state_set_disabled": 15336, "irq_state_set_masked": 15337, "irq_suspend": 15338, "irq_thread": 15339, "irq_thread_check_affinity": 15340, "irq_thread_dtor": 15341, "irq_thread_fn": 15342, "irq_time": 15343, "irq_time_read": 15344, "irq_time_seq": 15345, "irq_time_write_begin": 15346, "irq_time_write_end": 15347, "irq_to_desc": 15348, "irq_trace": 15349, "irq_type_level_mask": 15350, "irq_type_none": 15351, "irq_type_probe": 15352, "irq_type_sense_mask": 15353, "irq_unlock_sparse": 15354, "irq_unmask": 15355, "irq_wait_for_interrupt": 15356, "irq_wait_for_poll": 15357, "irq_wake_thread": 15358, "irq_was_disabled": 15359, "irq_work": 15360, "irq_work_busy": 15361, "irq_work_claim": 15362, "irq_work_flags": 15363, "irq_work_lazy": 15364, "irq_work_needs_cpu": 15365, "irq_work_pending": 15366, "irq_work_queue": 15367, "irq_work_queue_on": 15368, "irq_work_run": 15369, "irq_work_run_list": 15370, "irq_work_sync": 15371, "irq_work_tick": 15372, "irq_write_msi_msg": 15373, "irq_writel_be": 15374, "irqaction": 15375, "irqc_is_hardirq": 15376, "irqc_is_nested": 15377, "irqchip_eoi_if_handled": 15378, "irqchip_eoi_threaded": 15379, "irqchip_irq_state": 15380, "irqchip_mask_on_suspend": 15381, "irqchip_oneshot_safe": 15382, "irqchip_onoffline_enabled": 15383, "irqchip_set_type_masked": 15384, "irqchip_skip_set_wake": 15385, "irqclass": 15386, "irqd_affinity_set": 15387, "irqd_can_balance": 15388, "irqd_can_move_in_process_context": 15389, "irqd_clear": 15390, "irqd_clr_move_pending": 15391, "irqd_get_trigger_type": 15392, "irqd_has_set": 15393, "irqd_irq_disabled": 15394, "irqd_irq_inprogress": 15395, "irqd_irq_masked": 15396, "irqd_is_level_type": 15397, "irqd_is_setaffinity_pending": 15398, "irqd_is_wakeup_armed": 15399, "irqd_is_wakeup_set": 15400, "irqd_level": 15401, "irqd_move_pcntxt": 15402, "irqd_no_balancing": 15403, "irqd_per_cpu": 15404, "irqd_set": 15405, "irqd_set_move_pending": 15406, "irqd_setaffinity_pending": 15407, "irqd_trigger_mask": 15408, "irqd_wakeup_armed": 15409, "irqd_wakeup_state": 15410, "irqf_cond_suspend": 15411, "irqf_early_resume": 15412, "irqf_force_resume": 15413, "irqf_irqpoll": 15414, "irqf_modify_mask": 15415, "irqf_no_suspend": 15416, "irqf_no_thread": 15417, "irqf_nobalancing": 15418, "irqf_oneshot": 15419, "irqf_percpu": 15420, "irqf_probe_shared": 15421, "irqf_shared": 15422, "irqf_trigger_mask": 15423, "irqfixup": 15424, "irqfixup_setup": 15425, "irqflags": 15426, "irqpoll_setup": 15427, "irqreader": 15428, "irqreturn_t": 15429, "irqs": 15430, "irqs_autodetect": 15431, "irqs_disabled": 15432, "irqs_disabled_flags": 15433, "irqs_inprogress": 15434, "irqs_masked": 15435, "irqs_off": 15436, "irqs_oneshot": 15437, "irqs_pending": 15438, "irqs_per_chip": 15439, "irqs_poll_inprogress": 15440, "irqs_replay": 15441, "irqs_resend": 15442, "irqs_spurious_disabled": 15443, "irqs_sum": 15444, "irqs_suspended": 15445, "irqs_unhandled": 15446, "irqs_waiting": 15447, "irqsafe": 15448, "irqsoff_busy": 15449, "irqsoff_flag_changed": 15450, "irqsoff_function_set": 15451, "irqsoff_graph_entry": 15452, "irqsoff_graph_return": 15453, "irqsoff_print_header": 15454, "irqsoff_print_line": 15455, "irqsoff_set_flag": 15456, "irqsoff_trace": 15457, "irqsoff_trace_close": 15458, "irqsoff_trace_open": 15459, "irqsoff_tracer": 15460, "irqsoff_tracer_call": 15461, "irqsoff_tracer_init": 15462, "irqsoff_tracer_reset": 15463, "irqsoff_tracer_start": 15464, "irqsoff_tracer_stop": 15465, "irqtf_affinity": 15466, "irqtf_forced_thread": 15467, "irqtf_runthread": 15468, "irqtf_warned": 15469, "irqtime_account_hi_update": 15470, "irqtime_account_idle_ticks": 15471, "irqtime_account_irq": 15472, "irqtime_account_process_tick": 15473, "irqtime_account_si_update": 15474, "is": 15475, "is_active": 15476, "is_add": 15477, "is_affinity_mask_valid": 15478, "is_ancestor": 15479, "is_arm_mapping_symbol": 15480, "is_audit_feature_set": 15481, "is_cgroup_event": 15482, "is_chained": 15483, "is_chained_work": 15484, "is_child_reaper": 15485, "is_child_subreaper": 15486, "is_compat_task": 15487, "is_core_symbol": 15488, "is_cpu_exclusive": 15489, "is_cpuset_online": 15490, "is_cpuset_subset": 15491, "is_current_pgrp_orphaned": 15492, "is_delete": 15493, "is_dwork": 15494, "is_early": 15495, "is_empty": 15496, "is_enabled": 15497, "is_err": 15498, "is_err_or_null": 15499, "is_err_value": 15500, "is_error_status": 15501, "is_event_hup": 15502, "is_exported": 15503, "is_ftrace_trampoline": 15504, "is_function_field": 15505, "is_global": 15506, "is_global_init": 15507, "is_good_name": 15508, "is_gpl": 15509, "is_graph": 15510, "is_hardlockup": 15511, "is_highmem": 15512, "is_idle_task": 15513, "is_kernel_event": 15514, "is_kernel_inittext": 15515, "is_kprobe": 15516, "is_ksym_addr": 15517, "is_kthread_should_stop": 15518, "is_last": 15519, "is_legal_op": 15520, "is_mem_exclusive": 15521, "is_mem_hardwall": 15522, "is_memory_migrate": 15523, "is_module_address": 15524, "is_module_percpu_address": 15525, "is_module_text_address": 15526, "is_op_char": 15527, "is_orphaned_child": 15528, "is_power_of_2": 15529, "is_precedence_lower": 15530, "is_ready": 15531, "is_register": 15532, "is_ret": 15533, "is_ret_probe": 15534, "is_return": 15535, "is_same_group": 15536, "is_sampling_event": 15537, "is_sched_load_balance": 15538, "is_si_special": 15539, "is_signed": 15540, "is_signed_type": 15541, "is_singleblock": 15542, "is_singlestep": 15543, "is_softlockup": 15544, "is_software_event": 15545, "is_spread_page": 15546, "is_spread_slab": 15547, "is_state_visited": 15548, "is_string_field": 15549, "is_swbp": 15550, "is_swbp_insn": 15551, "is_sysemu_singlestep": 15552, "is_sysidle_rcu_state": 15553, "is_thread_group": 15554, "is_tracing_stopped": 15555, "is_trap_at_addr": 15556, "is_trap_insn": 15557, "is_valid": 15558, "is_valid_access": 15559, "is_vm_hugetlb_page": 15560, "isadd": 15561, "isalnum": 15562, "isalpha": 15563, "isdigit": 15564, "isidle": 15565, "ismax": 15566, "isolated_cpu_setup": 15567, "isprint": 15568, "ispunct": 15569, "isspace": 15570, "istate": 15571, "it": 15572, "it_clock": 15573, "it_id": 15574, "it_id_not_set": 15575, "it_id_set": 15576, "it_interval": 15577, "it_lock": 15578, "it_new": 15579, "it_old": 15580, "it_overrun": 15581, "it_overrun_last": 15582, "it_pid": 15583, "it_real_fn": 15584, "it_real_incr": 15585, "it_requeue_pending": 15586, "it_sigev_notify": 15587, "it_signal": 15588, "it_value": 15589, "item": 15590, "items": 15591, "iter": 15592, "iter_end": 15593, "iter_event": 15594, "iter_flags": 15595, "iter_start": 15596, "iter_stop": 15597, "iter_stride": 15598, "iterate_chain_key": 15599, "iterate_mounts": 15600, "iterk": 15601, "iters": 15602, "itimer_delete": 15603, "itimer_get_remtime": 15604, "itimer_prof": 15605, "itimer_real": 15606, "itimer_virtual": 15607, "itimerspec": 15608, "itimerval": 15609, "itype": 15610, "iv": 15611, "ixol": 15612, "j": 15613, "j1": 15614, "jea": 15615, "jeb": 15616, "jf_left": 15617, "jhash": 15618, "jhash_1word": 15619, "jif": 15620, "jiffies": 15621, "jiffies_64": 15622, "jiffies_64_to_clock_t": 15623, "jiffies_force_qs": 15624, "jiffies_lock": 15625, "jiffies_resched": 15626, "jiffies_snap": 15627, "jiffies_stall": 15628, "jiffies_till_first_fqs": 15629, "jiffies_till_next_fqs": 15630, "jiffies_till_sched_qs": 15631, "jiffies_to_ahz": 15632, "jiffies_to_clock_t": 15633, "jiffies_to_cputime": 15634, "jiffies_to_msecs": 15635, "jiffies_to_nsecs": 15636, "jiffies_to_timespec": 15637, "jiffies_to_timeval": 15638, "jiffies_to_usecs": 15639, "jiffy": 15640, "jit_keyring": 15641, "jitcnt": 15642, "jited": 15643, "jitter": 15644, "jlm": 15645, "jmp_call": 15646, "jmp_exit": 15647, "jmp_ja": 15648, "jmp_jeq_k": 15649, "jmp_jeq_x": 15650, "jmp_jge_k": 15651, "jmp_jge_x": 15652, "jmp_jgt_k": 15653, "jmp_jgt_x": 15654, "jmp_jne_k": 15655, "jmp_jne_x": 15656, "jmp_jset_k": 15657, "jmp_jset_x": 15658, "jmp_jsge_k": 15659, "jmp_jsge_x": 15660, "jmp_jsgt_k": 15661, "jmp_jsgt_x": 15662, "jobctl": 15663, "jobctl_listening": 15664, "jobctl_pending_mask": 15665, "jobctl_stop_consume": 15666, "jobctl_stop_dequeued": 15667, "jobctl_stop_pending": 15668, "jobctl_stop_sigmask": 15669, "jobctl_trap_mask": 15670, "jobctl_trap_notify": 15671, "jobctl_trap_stop": 15672, "jobctl_trapping": 15673, "jobctl_trapping_bit": 15674, "join": 15675, "jp": 15676, "jph_val": 15677, "jprobe": 15678, "jps": 15679, "js": 15680, "jump_entries": 15681, "jump_entry": 15682, "jump_label_add_module": 15683, "jump_label_apply_nops": 15684, "jump_label_cmp": 15685, "jump_label_del_module": 15686, "jump_label_disable": 15687, "jump_label_enable": 15688, "jump_label_get_branch_default": 15689, "jump_label_get_entries": 15690, "jump_label_init": 15691, "jump_label_init_module": 15692, "jump_label_invalidate_module_init": 15693, "jump_label_lock": 15694, "jump_label_module_nb": 15695, "jump_label_module_notify": 15696, "jump_label_mutex": 15697, "jump_label_nop_size": 15698, "jump_label_rate_limit": 15699, "jump_label_sort_entries": 15700, "jump_label_t": 15701, "jump_label_text_reserved": 15702, "jump_label_type": 15703, "jump_label_unlock": 15704, "jump_label_update": 15705, "jump_label_update_timeout": 15706, "jumptable": 15707, "just": 15708, "k": 15709, "k_clock": 15710, "k_getrusage": 15711, "k_itimer": 15712, "k_itimer_rcu_free": 15713, "k_sigaction": 15714, "ka": 15715, "ka_restorer": 15716, "kaddr": 15717, "kallsym_iter": 15718, "kallsyms_addresses": 15719, "kallsyms_expand_symbol": 15720, "kallsyms_get_symbol_type": 15721, "kallsyms_init": 15722, "kallsyms_lookup": 15723, "kallsyms_lookup_name": 15724, "kallsyms_lookup_size_offset": 15725, "kallsyms_markers": 15726, "kallsyms_names": 15727, "kallsyms_num_syms": 15728, "kallsyms_on_each_symbol": 15729, "kallsyms_op": 15730, "kallsyms_open": 15731, "kallsyms_operations": 15732, "kallsyms_symbol_next": 15733, "kallsyms_token_index": 15734, "kallsyms_token_table": 15735, "kasprintf": 15736, "kauditd_send_multicast_skb": 15737, "kauditd_send_skb": 15738, "kauditd_task": 15739, "kauditd_thread": 15740, "kauditd_wait": 15741, "kb": 15742, "kb_mask": 15743, "kbasename": 15744, "kbuf": 15745, "kbuild_modname": 15746, "kc": 15747, "kcalloc": 15748, "kcmp": 15749, "kcmp_cookies_init": 15750, "kcmp_file": 15751, "kcmp_files": 15752, "kcmp_fs": 15753, "kcmp_io": 15754, "kcmp_lock": 15755, "kcmp_ptr": 15756, "kcmp_sighand": 15757, "kcmp_sysvsem": 15758, "kcmp_type": 15759, "kcmp_types": 15760, "kcmp_unlock": 15761, "kcmp_vm": 15762, "kcpustat": 15763, "kcpustat_this_cpu": 15764, "kdata": 15765, "kdb": 15766, "kdb_argcount": 15767, "kdb_badaddr": 15768, "kdb_badcpunum": 15769, "kdb_badint": 15770, "kdb_badlength": 15771, "kdb_badradix": 15772, "kdb_badreg": 15773, "kdb_badwidth": 15774, "kdb_base_cmd_max": 15775, "kdb_base_commands": 15776, "kdb_bc": 15777, "kdb_bfd_vma_fmt": 15778, "kdb_bfd_vma_fmt0": 15779, "kdb_bp": 15780, "kdb_bp_install": 15781, "kdb_bp_remove": 15782, "kdb_bp_t": 15783, "kdb_bptnotfound": 15784, "kdb_bptype": 15785, "kdb_breakpoints": 15786, "kdb_bt": 15787, "kdb_bt1": 15788, "kdb_check_flags": 15789, "kdb_check_regs": 15790, "kdb_cmd_cpu": 15791, "kdb_cmd_enabled": 15792, "kdb_cmd_go": 15793, "kdb_cmd_history_count": 15794, "kdb_cmd_init": 15795, "kdb_cmd_kgdb": 15796, "kdb_cmd_ss": 15797, "kdb_cmdflags_t": 15798, "kdb_cmds": 15799, "kdb_command_extend": 15800, "kdb_commands": 15801, "kdb_common_deinit_state": 15802, "kdb_common_init_state": 15803, "kdb_continue_catastrophic": 15804, "kdb_cpu": 15805, "kdb_curr_task": 15806, "kdb_current": 15807, "kdb_current_regs": 15808, "kdb_current_task": 15809, "kdb_db_bpt": 15810, "kdb_db_nobpt": 15811, "kdb_db_ss": 15812, "kdb_db_ssbpt": 15813, "kdb_dbtrap_t": 15814, "kdb_debug": 15815, "kdb_debug_flag_": 15816, "kdb_debug_flag_ar": 15817, "kdb_debug_flag_ara": 15818, "kdb_debug_flag_bb": 15819, "kdb_debug_flag_bb_summ": 15820, "kdb_debug_flag_bp": 15821, "kdb_debug_flag_mask": 15822, "kdb_debug_flag_shift": 15823, "kdb_debug_flag_state": 15824, "kdb_debug_state": 15825, "kdb_defcmd": 15826, "kdb_defcmd2": 15827, "kdb_diemsg": 15828, "kdb_disable_nmi": 15829, "kdb_dmesg": 15830, "kdb_do_each_thread": 15831, "kdb_dumpregs": 15832, "kdb_dupbpt": 15833, "kdb_ef": 15834, "kdb_enable_always_safe": 15835, "kdb_enable_always_safe_no_args": 15836, "kdb_enable_flow_ctrl": 15837, "kdb_enable_inspect": 15838, "kdb_enable_inspect_no_args": 15839, "kdb_enable_mem_read": 15840, "kdb_enable_mem_write": 15841, "kdb_enable_reboot": 15842, "kdb_enable_reg_read": 15843, "kdb_enable_reg_write": 15844, "kdb_enable_signal": 15845, "kdb_env": 15846, "kdb_event": 15847, "kdb_exec_defcmd": 15848, "kdb_flag": 15849, "kdb_flag_clear": 15850, "kdb_flag_set": 15851, "kdb_flags": 15852, "kdb_flags_index": 15853, "kdb_flags_stack": 15854, "kdb_ftdump": 15855, "kdb_func_t": 15856, "kdb_gdb_state_pass": 15857, "kdb_getarea": 15858, "kdb_getarea_size": 15859, "kdb_getphys": 15860, "kdb_getphysword": 15861, "kdb_getstr": 15862, "kdb_getword": 15863, "kdb_gmtime": 15864, "kdb_go": 15865, "kdb_go_count": 15866, "kdb_grep_help": 15867, "kdb_grep_leading": 15868, "kdb_grep_string": 15869, "kdb_grep_strlen": 15870, "kdb_grep_trailing": 15871, "kdb_grepping_flag": 15872, "kdb_handle_bp": 15873, "kdb_help": 15874, "kdb_init": 15875, "kdb_init_early": 15876, "kdb_init_full": 15877, "kdb_init_lvl": 15878, "kdb_initbptab": 15879, "kdb_initial_cpu": 15880, "kdb_inittab": 15881, "kdb_kgdb": 15882, "kdb_kill": 15883, "kdb_ks": 15884, "kdb_local": 15885, "kdb_lsmod": 15886, "kdb_machreg_fmt": 15887, "kdb_machreg_fmt0": 15888, "kdb_main_loop": 15889, "kdb_max_commands": 15890, "kdb_maxbpt": 15891, "kdb_md": 15892, "kdb_md_line": 15893, "kdb_mdr": 15894, "kdb_mm": 15895, "kdb_name_table": 15896, "kdb_nextline": 15897, "kdb_not_initialized": 15898, "kdb_notfound": 15899, "kdb_notimp": 15900, "kdb_parse": 15901, "kdb_parsebp": 15902, "kdb_pcu": 15903, "kdb_per_cpu": 15904, "kdb_pid": 15905, "kdb_poll_funcs": 15906, "kdb_poll_idx": 15907, "kdb_prev_t": 15908, "kdb_print_nameval": 15909, "kdb_printbp": 15910, "kdb_printf": 15911, "kdb_private": 15912, "kdb_process_cpu": 15913, "kdb_prompt_str": 15914, "kdb_ps": 15915, "kdb_ps1": 15916, "kdb_ps_suppressed": 15917, "kdb_putarea_size": 15918, "kdb_putword": 15919, "kdb_rd": 15920, "kdb_reason_break": 15921, "kdb_reason_debug": 15922, "kdb_reason_enter": 15923, "kdb_reason_enter_slave": 15924, "kdb_reason_keyboard": 15925, "kdb_reason_nmi": 15926, "kdb_reason_oops": 15927, "kdb_reason_recurse": 15928, "kdb_reason_sstep": 15929, "kdb_reason_switch": 15930, "kdb_reason_system_nmi": 15931, "kdb_reason_t": 15932, "kdb_reboot": 15933, "kdb_register": 15934, "kdb_register_flags": 15935, "kdb_repeat_no_args": 15936, "kdb_repeat_with_args": 15937, "kdb_restore_flags": 15938, "kdb_rm": 15939, "kdb_rwtypes": 15940, "kdb_save_flags": 15941, "kdb_send_sig_info": 15942, "kdb_set": 15943, "kdb_set_current_task": 15944, "kdb_setsinglestep": 15945, "kdb_show_stack": 15946, "kdb_sp_default": 15947, "kdb_sp_newline": 15948, "kdb_sp_paren": 15949, "kdb_sp_spacea": 15950, "kdb_sp_spaceb": 15951, "kdb_sp_symsize": 15952, "kdb_sp_value": 15953, "kdb_sr": 15954, "kdb_ss": 15955, "kdb_state": 15956, "kdb_state_clear": 15957, "kdb_state_set": 15958, "kdb_strdup": 15959, "kdb_stub": 15960, "kdb_summary": 15961, "kdb_symbol_print": 15962, "kdb_symtab_t": 15963, "kdb_sysinfo": 15964, "kdb_task_has_cpu": 15965, "kdb_task_state": 15966, "kdb_task_state_char": 15967, "kdb_task_state_string": 15968, "kdb_tm": 15969, "kdb_toomanybpt": 15970, "kdb_trap_printk": 15971, "kdb_tsk": 15972, "kdb_tskregs": 15973, "kdb_unregister": 15974, "kdb_walk_kallsyms": 15975, "kdb_walk_kallsyms_iter": 15976, "kdb_while_each_thread": 15977, "kdb_word_size": 15978, "kdbcmd_bc": 15979, "kdbcmd_bd": 15980, "kdbcmd_be": 15981, "kdbdebug": 15982, "kdbgetaddrarg": 15983, "kdbgetenv": 15984, "kdbgetintenv": 15985, "kdbgetsymval": 15986, "kdbgetu64arg": 15987, "kdbgetularg": 15988, "kdbnearsym": 15989, "kdbnearsym_cleanup": 15990, "kdbtab_t": 15991, "kdebug": 15992, "keep_bootcon": 15993, "keep_regs": 15994, "keep_working": 15995, "kegid": 15996, "kern_acct": 15997, "kern_alert": 15998, "kern_bootloader_type": 15999, "kern_cadpid": 16000, "kern_compat_log": 16001, "kern_cont": 16002, "kern_core_pattern": 16003, "kern_core_uses_pid": 16004, "kern_crit": 16005, "kern_ctlaltdel": 16006, "kern_debug": 16007, "kern_default": 16008, "kern_domainname": 16009, "kern_emerg": 16010, "kern_err": 16011, "kern_hotplug": 16012, "kern_hppa_pwrsw": 16013, "kern_hppa_unaligned": 16014, "kern_ia64_unaligned": 16015, "kern_ieee_emulation_warnings": 16016, "kern_info": 16017, "kern_ipc_perm": 16018, "kern_max_lock_depth": 16019, "kern_max_threads": 16020, "kern_modprobe": 16021, "kern_msgmax": 16022, "kern_msgmnb": 16023, "kern_msgmni": 16024, "kern_ngroups_max": 16025, "kern_nodename": 16026, "kern_osrelease": 16027, "kern_ostype": 16028, "kern_overflowgid": 16029, "kern_overflowuid": 16030, "kern_panic": 16031, "kern_panic_on_nmi": 16032, "kern_panic_on_oops": 16033, "kern_panic_on_warn": 16034, "kern_path": 16035, "kern_path_locked": 16036, "kern_pidmax": 16037, "kern_ppc_powersave_nap": 16038, "kern_printk": 16039, "kern_printk_ratelimit": 16040, "kern_printk_ratelimit_burst": 16041, "kern_pty": 16042, "kern_random": 16043, "kern_randomize": 16044, "kern_realrootdev": 16045, "kern_s390_user_debug_logging": 16046, "kern_sem": 16047, "kern_setuid_dumpable": 16048, "kern_sg_big_buff": 16049, "kern_shmall": 16050, "kern_shmmax": 16051, "kern_shmmni": 16052, "kern_sparc_reboot": 16053, "kern_sparc_scons_pwroff": 16054, "kern_sparc_stop_a": 16055, "kern_spin_retry": 16056, "kern_sysrq": 16057, "kern_table": 16058, "kern_unknown_nmi_panic": 16059, "kern_version": 16060, "kern_warning": 16061, "kernel": 16062, "kernel_add_sysfs_param": 16063, "kernel_attr_group": 16064, "kernel_attr_ro": 16065, "kernel_attr_rw": 16066, "kernel_buf": 16067, "kernel_buf_len": 16068, "kernel_cap_t": 16069, "kernel_config_data": 16070, "kernel_config_data_size": 16071, "kernel_cpustat": 16072, "kernel_ds": 16073, "kernel_fd": 16074, "kernel_halt": 16075, "kernel_kexec": 16076, "kernel_kobj": 16077, "kernel_param": 16078, "kernel_param_fl_unsafe": 16079, "kernel_param_ops": 16080, "kernel_param_ops_fl_noarg": 16081, "kernel_power_off": 16082, "kernel_read": 16083, "kernel_restart": 16084, "kernel_restart_prepare": 16085, "kernel_shutdown_prepare": 16086, "kernel_sigaction": 16087, "kernel_stack": 16088, "kernel_stack_pointer": 16089, "kernel_stat": 16090, "kernel_symbol": 16091, "kernel_text_address": 16092, "kernel_thread": 16093, "kernel_tp": 16094, "kernel_write": 16095, "kernfs_activate": 16096, "kernfs_break_active_protection": 16097, "kernfs_create_dir": 16098, "kernfs_create_root": 16099, "kernfs_destroy_root": 16100, "kernfs_dir": 16101, "kernfs_get": 16102, "kernfs_kill_sb": 16103, "kernfs_mount": 16104, "kernfs_node": 16105, "kernfs_node_from_dentry": 16106, "kernfs_notify": 16107, "kernfs_open_file": 16108, "kernfs_ops": 16109, "kernfs_pin_sb": 16110, "kernfs_put": 16111, "kernfs_remove": 16112, "kernfs_remove_by_name": 16113, "kernfs_rename": 16114, "kernfs_root": 16115, "kernfs_root_create_deactivated": 16116, "kernfs_root_from_sb": 16117, "kernfs_setattr": 16118, "kernfs_syscall_ops": 16119, "kernfs_type": 16120, "kernfs_unbreak_active_protection": 16121, "keuid": 16122, "kevent": 16123, "kexec_add_buffer": 16124, "kexec_apply_relocations": 16125, "kexec_arch": 16126, "kexec_arch_default": 16127, "kexec_arch_mask": 16128, "kexec_buf": 16129, "kexec_calculate_store_digests": 16130, "kexec_control_memory_limit": 16131, "kexec_control_page_size": 16132, "kexec_core_note_name": 16133, "kexec_crash_control_memory_limit": 16134, "kexec_crash_image": 16135, "kexec_crash_loaded": 16136, "kexec_crash_loaded_show": 16137, "kexec_crash_mem_align": 16138, "kexec_crash_size_show": 16139, "kexec_crash_size_store": 16140, "kexec_destination_memory_limit": 16141, "kexec_file_no_initramfs": 16142, "kexec_file_on_crash": 16143, "kexec_flags": 16144, "kexec_flush_icache_page": 16145, "kexec_image": 16146, "kexec_in_progress": 16147, "kexec_load": 16148, "kexec_load_disabled": 16149, "kexec_load_purgatory": 16150, "kexec_loaded": 16151, "kexec_loaded_show": 16152, "kexec_mutex": 16153, "kexec_on_crash": 16154, "kexec_on_panic": 16155, "kexec_preserve_context": 16156, "kexec_purgatory": 16157, "kexec_purgatory_find_symbol": 16158, "kexec_purgatory_get_set_symbol": 16159, "kexec_purgatory_get_symbol_addr": 16160, "kexec_purgatory_size": 16161, "kexec_segment": 16162, "kexec_segment_max": 16163, "kexec_sha_region": 16164, "kexec_should_crash": 16165, "kexec_source_memory_limit": 16166, "kexec_type_crash": 16167, "kexec_type_default": 16168, "key": 16169, "key2": 16170, "key_alloc_not_in_quota": 16171, "key_alloc_trusted": 16172, "key_create_or_update": 16173, "key_flag_builtin": 16174, "key_flag_trusted_only": 16175, "key_fsgid_changed": 16176, "key_fsuid_changed": 16177, "key_get": 16178, "key_id": 16179, "key_id_len": 16180, "key_len": 16181, "key_name": 16182, "key_pos_all": 16183, "key_pos_setattr": 16184, "key_put": 16185, "key_ref_put": 16186, "key_ref_t": 16187, "key_ref_to_ptr": 16188, "key_reqkey_defl_thread_keyring": 16189, "key_serial": 16190, "key_size": 16191, "key_sysctls": 16192, "key_type_asymmetric": 16193, "key_usr_read": 16194, "key_usr_search": 16195, "key_usr_view": 16196, "keyboard": 16197, "keyring_alloc": 16198, "keyring_search": 16199, "kf_ops": 16200, "kf_root": 16201, "kfree": 16202, "kfree_call_rcu": 16203, "kfree_rcu": 16204, "kfree_skb": 16205, "kgdb": 16206, "kgdb_active": 16207, "kgdb_arch_exit": 16208, "kgdb_arch_handle_exception": 16209, "kgdb_arch_init": 16210, "kgdb_arch_late": 16211, "kgdb_arch_pc": 16212, "kgdb_arch_remove_breakpoint": 16213, "kgdb_arch_set_breakpoint": 16214, "kgdb_arch_set_pc": 16215, "kgdb_bkpt": 16216, "kgdb_break": 16217, "kgdb_break_asap": 16218, "kgdb_break_tasklet_var": 16219, "kgdb_breakpoint": 16220, "kgdb_con_registered": 16221, "kgdb_connected": 16222, "kgdb_console_write": 16223, "kgdb_contthread": 16224, "kgdb_cpu_doing_single_step": 16225, "kgdb_cpu_enter": 16226, "kgdb_do_roundup": 16227, "kgdb_ebin2mem": 16228, "kgdb_exit": 16229, "kgdb_flush_swbreak_addr": 16230, "kgdb_handle_exception": 16231, "kgdb_hex2long": 16232, "kgdb_hex2mem": 16233, "kgdb_hw_breakpoint": 16234, "kgdb_info": 16235, "kgdb_initial_breakpoint": 16236, "kgdb_io": 16237, "kgdb_io_module_registered": 16238, "kgdb_io_ready": 16239, "kgdb_max_breakpoints": 16240, "kgdb_max_thread_query": 16241, "kgdb_mem2hex": 16242, "kgdb_nmicallback": 16243, "kgdb_nmicallin": 16244, "kgdb_panic_event": 16245, "kgdb_panic_event_nb": 16246, "kgdb_reenter_check": 16247, "kgdb_register_callbacks": 16248, "kgdb_register_io_module": 16249, "kgdb_registration_lock": 16250, "kgdb_restore": 16251, "kgdb_roundup_cpus": 16252, "kgdb_schedule_breakpoint": 16253, "kgdb_setting_breakpoint": 16254, "kgdb_single_step": 16255, "kgdb_skipexception": 16256, "kgdb_sstep_pid": 16257, "kgdb_state": 16258, "kgdb_tasklet_bpt": 16259, "kgdb_tasklet_breakpoint": 16260, "kgdb_trans": 16261, "kgdb_unregister_callbacks": 16262, "kgdb_unregister_io_module": 16263, "kgdb_use_con": 16264, "kgdb_usethread": 16265, "kgdb_usethreadid": 16266, "kgdb_validate_break_address": 16267, "kgdb_var": 16268, "kgdbcons": 16269, "kgdbreboot": 16270, "kgid": 16271, "kgid_has_mapping": 16272, "kgid_t": 16273, "kgidt_init": 16274, "khelper_wq": 16275, "khugepaged_exit": 16276, "khugepaged_fork": 16277, "kick": 16278, "kick_all_cpus_sync": 16279, "kick_kprobe_optimizer": 16280, "kick_process": 16281, "kill": 16282, "kill_as_cred_perm": 16283, "kill_css": 16284, "kill_fasync": 16285, "kill_ftrace_graph": 16286, "kill_kprobe": 16287, "kill_ok_by_cred": 16288, "kill_optimized_kprobe": 16289, "kill_pgrp": 16290, "kill_pid": 16291, "kill_pid_info": 16292, "kill_pid_info_as_cred": 16293, "kill_proc_info": 16294, "kill_rules": 16295, "kill_sb": 16296, "kill_something_info": 16297, "kill_test": 16298, "killed": 16299, "killed_trees": 16300, "killing": 16301, "kimage": 16302, "kimage_add_entry": 16303, "kimage_add_page": 16304, "kimage_alloc_control_pages": 16305, "kimage_alloc_crash_control_pages": 16306, "kimage_alloc_init": 16307, "kimage_alloc_normal_control_pages": 16308, "kimage_alloc_page": 16309, "kimage_alloc_pages": 16310, "kimage_dst_used": 16311, "kimage_entry_t": 16312, "kimage_file_alloc_init": 16313, "kimage_file_post_load_cleanup": 16314, "kimage_file_prepare_segments": 16315, "kimage_free": 16316, "kimage_free_entry": 16317, "kimage_free_extra_pages": 16318, "kimage_free_page_list": 16319, "kimage_free_pages": 16320, "kimage_is_destination_range": 16321, "kimage_load_crash_segment": 16322, "kimage_load_normal_segment": 16323, "kimage_load_segment": 16324, "kimage_no_dest": 16325, "kimage_set_destination": 16326, "kimage_terminate": 16327, "kin": 16328, "kiov": 16329, "kip": 16330, "kit": 16331, "kj": 16332, "kloginuid": 16333, "klp_alive": 16334, "klp_arch_set_pc": 16335, "klp_check_compiler_support": 16336, "klp_disable_func": 16337, "klp_disable_object": 16338, "klp_disable_patch": 16339, "klp_disabled": 16340, "klp_enable_func": 16341, "klp_enable_object": 16342, "klp_enable_patch": 16343, "klp_enabled": 16344, "klp_find_arg": 16345, "klp_find_callback": 16346, "klp_find_external_symbol": 16347, "klp_find_object_module": 16348, "klp_find_object_symbol": 16349, "klp_find_ops": 16350, "klp_find_verify_func_addr": 16351, "klp_free_funcs_limited": 16352, "klp_free_object_loaded": 16353, "klp_free_objects_limited": 16354, "klp_free_patch": 16355, "klp_ftrace_handler": 16356, "klp_func": 16357, "klp_init": 16358, "klp_init_func": 16359, "klp_init_object": 16360, "klp_init_object_loaded": 16361, "klp_init_patch": 16362, "klp_initialized": 16363, "klp_is_module": 16364, "klp_is_object_loaded": 16365, "klp_is_patch_registered": 16366, "klp_kobj_release_func": 16367, "klp_kobj_release_patch": 16368, "klp_ktype_func": 16369, "klp_ktype_patch": 16370, "klp_module_nb": 16371, "klp_module_notify": 16372, "klp_module_notify_coming": 16373, "klp_module_notify_going": 16374, "klp_mutex": 16375, "klp_object": 16376, "klp_ops": 16377, "klp_patch": 16378, "klp_patch_attrs": 16379, "klp_patches": 16380, "klp_register_patch": 16381, "klp_reloc": 16382, "klp_root_kobj": 16383, "klp_unregister_patch": 16384, "klp_verify_args": 16385, "klp_verify_callback": 16386, "klp_verify_vmlinux_symbol": 16387, "klp_write_module_reloc": 16388, "klp_write_object_relocations": 16389, "km": 16390, "kmalloc": 16391, "kmalloc_array": 16392, "kmalloc_node": 16393, "kmalloc_parameter": 16394, "kmalloced_param": 16395, "kmalloced_params": 16396, "kmap": 16397, "kmap_atomic": 16398, "kmem": 16399, "kmem_cache": 16400, "kmem_cache_alloc": 16401, "kmem_cache_alloc_node": 16402, "kmem_cache_create": 16403, "kmem_cache_free": 16404, "kmem_cache_zalloc": 16405, "kmemcheck_annotate_bitfield": 16406, "kmemcheck_enabled": 16407, "kmemcheck_mark_initialized": 16408, "kmemdup": 16409, "kmemleak_ignore": 16410, "kmemleak_load_module": 16411, "kmemleak_not_leak": 16412, "kmemleak_scan_area": 16413, "kmin": 16414, "kmod_concurrent": 16415, "kmod_loop_msg": 16416, "kmod_path_len": 16417, "kmsg_dump": 16418, "kmsg_dump_emerg": 16419, "kmsg_dump_halt": 16420, "kmsg_dump_poweroff": 16421, "kmsg_dump_restart": 16422, "kn": 16423, "knt1": 16424, "knt1_size": 16425, "kobj": 16426, "kobj2pinst": 16427, "kobj_add": 16428, "kobj_attribute": 16429, "kobj_completion": 16430, "kobj_sysfs_ops": 16431, "kobj_type": 16432, "kobject": 16433, "kobject_action": 16434, "kobject_action_type": 16435, "kobject_create_and_add": 16436, "kobject_get": 16437, "kobject_init": 16438, "kobject_init_and_add": 16439, "kobject_put": 16440, "kobject_uevent": 16441, "koldloginuid": 16442, "kout": 16443, "kp": 16444, "kp_post_handler": 16445, "kp_pre_handler": 16446, "kpage": 16447, "kparam": 16448, "kparam_array": 16449, "kparam_string": 16450, "kprobe": 16451, "kprobe_addr": 16452, "kprobe_aggrprobe": 16453, "kprobe_blacklist": 16454, "kprobe_blacklist_entry": 16455, "kprobe_blacklist_open": 16456, "kprobe_blacklist_seq_next": 16457, "kprobe_blacklist_seq_ops": 16458, "kprobe_blacklist_seq_show": 16459, "kprobe_blacklist_seq_start": 16460, "kprobe_disabled": 16461, "kprobe_disarmed": 16462, "kprobe_dispatcher": 16463, "kprobe_event_define_fields": 16464, "kprobe_event_system": 16465, "kprobe_events_ops": 16466, "kprobe_exceptions_nb": 16467, "kprobe_exceptions_notify": 16468, "kprobe_flag_disabled": 16469, "kprobe_flag_ftrace": 16470, "kprobe_flag_gone": 16471, "kprobe_flag_optimized": 16472, "kprobe_flush_task": 16473, "kprobe_ftrace": 16474, "kprobe_ftrace_enabled": 16475, "kprobe_ftrace_handler": 16476, "kprobe_ftrace_ops": 16477, "kprobe_funcs": 16478, "kprobe_gone": 16479, "kprobe_hash_bits": 16480, "kprobe_insn_cache": 16481, "kprobe_insn_page": 16482, "kprobe_insn_page_size": 16483, "kprobe_insn_slots": 16484, "kprobe_instance": 16485, "kprobe_lookup_name": 16486, "kprobe_module_nb": 16487, "kprobe_mutex": 16488, "kprobe_opcode_t": 16489, "kprobe_optimized": 16490, "kprobe_optimizer": 16491, "kprobe_optinsn_slots": 16492, "kprobe_optready": 16493, "kprobe_perf_func": 16494, "kprobe_profile_ops": 16495, "kprobe_prog_func_proto": 16496, "kprobe_prog_is_valid_access": 16497, "kprobe_prog_ops": 16498, "kprobe_queued": 16499, "kprobe_register": 16500, "kprobe_seq_next": 16501, "kprobe_seq_start": 16502, "kprobe_seq_stop": 16503, "kprobe_slot_state": 16504, "kprobe_table": 16505, "kprobe_table_size": 16506, "kprobe_target": 16507, "kprobe_tl": 16508, "kprobe_trace_entry_head": 16509, "kprobe_trace_func": 16510, "kprobe_trace_self_tests_init": 16511, "kprobe_trace_selftest_target": 16512, "kprobe_type": 16513, "kprobe_unused": 16514, "kprobes": 16515, "kprobes_all_disarmed": 16516, "kprobes_allow_optimization": 16517, "kprobes_fetch_type_table": 16518, "kprobes_inc_nmissed_count": 16519, "kprobes_initialized": 16520, "kprobes_module_callback": 16521, "kprobes_open": 16522, "kprobes_seq_ops": 16523, "kprojid": 16524, "kprojid_t": 16525, "kprojidt_init": 16526, "kps": 16527, "kptr_obfuscate": 16528, "kptr_restrict": 16529, "krealloc": 16530, "kref": 16531, "kref_get": 16532, "kref_init": 16533, "kref_put": 16534, "kretprobe": 16535, "kretprobe_blacklist": 16536, "kretprobe_blacklist_size": 16537, "kretprobe_dispatcher": 16538, "kretprobe_event_define_fields": 16539, "kretprobe_funcs": 16540, "kretprobe_hash_lock": 16541, "kretprobe_hash_unlock": 16542, "kretprobe_inst_table": 16543, "kretprobe_instance": 16544, "kretprobe_perf_func": 16545, "kretprobe_table_lock": 16546, "kretprobe_table_lock_ptr": 16547, "kretprobe_table_unlock": 16548, "kretprobe_trace_entry_head": 16549, "kretprobe_trace_func": 16550, "kretprobed": 16551, "krgid": 16552, "kruid": 16553, "krule": 16554, "ks": 16555, "ks_namebuf_prev": 16556, "ksegment": 16557, "ksegments": 16558, "kset": 16559, "kset_create_and_add": 16560, "kset_exit": 16561, "kset_find_obj": 16562, "kset_uevent_ops": 16563, "ksgid": 16564, "ksig": 16565, "ksignal": 16566, "ksm_exit": 16567, "ksm_fork": 16568, "ksoftirqd": 16569, "ksoftirqd_should_run": 16570, "kstack_depth_to_print": 16571, "kstat": 16572, "kstat_incr_irq_this_cpu": 16573, "kstat_incr_irqs_this_cpu": 16574, "kstat_incr_softirqs_this_cpu": 16575, "kstat_irqs": 16576, "kstat_irqs_cpu": 16577, "kstat_irqs_usr": 16578, "kstat_softirqs_cpu": 16579, "kstatfs": 16580, "kstk_eip": 16581, "kstrdup": 16582, "kstrndup": 16583, "kstrtoint": 16584, "kstrtol": 16585, "kstrtoll": 16586, "kstrtos16": 16587, "kstrtos32_from_user": 16588, "kstrtou16": 16589, "kstrtou32": 16590, "kstrtou64": 16591, "kstrtou8": 16592, "kstrtouint": 16593, "kstrtoul": 16594, "kstrtoul_from_user": 16595, "kstrtoull": 16596, "ksuid": 16597, "ksym": 16598, "ksym_buf": 16599, "ksym_name_len": 16600, "ksym_symbol_len": 16601, "ksysfs_init": 16602, "kt": 16603, "kthread": 16604, "kthread_bind": 16605, "kthread_bits": 16606, "kthread_create": 16607, "kthread_create_info": 16608, "kthread_create_list": 16609, "kthread_create_lock": 16610, "kthread_create_on_cpu": 16611, "kthread_create_on_node": 16612, "kthread_data": 16613, "kthread_flush_work": 16614, "kthread_flush_work_fn": 16615, "kthread_freezable_should_stop": 16616, "kthread_is_parked": 16617, "kthread_is_per_cpu": 16618, "kthread_park": 16619, "kthread_parkme": 16620, "kthread_prio": 16621, "kthread_prio_in": 16622, "kthread_run": 16623, "kthread_should_park": 16624, "kthread_should_stop": 16625, "kthread_status": 16626, "kthread_stop": 16627, "kthread_unpark": 16628, "kthread_work": 16629, "kthread_work_init": 16630, "kthread_worker": 16631, "kthread_worker_fn": 16632, "kthreadd": 16633, "kthreadd_task": 16634, "ktime": 16635, "ktime_add": 16636, "ktime_add_ns": 16637, "ktime_add_safe": 16638, "ktime_divns": 16639, "ktime_equal": 16640, "ktime_get": 16641, "ktime_get_boot_ns": 16642, "ktime_get_boottime": 16643, "ktime_get_mono_fast_ns": 16644, "ktime_get_ns": 16645, "ktime_get_raw": 16646, "ktime_get_raw_fast_ns": 16647, "ktime_get_real": 16648, "ktime_get_real_seconds": 16649, "ktime_get_real_ts": 16650, "ktime_get_seconds": 16651, "ktime_get_ts": 16652, "ktime_get_ts64": 16653, "ktime_get_update_offsets_now": 16654, "ktime_get_update_offsets_tick": 16655, "ktime_get_with_offset": 16656, "ktime_low_res": 16657, "ktime_max": 16658, "ktime_mono_to_any": 16659, "ktime_now": 16660, "ktime_sec": 16661, "ktime_set": 16662, "ktime_sub": 16663, "ktime_t": 16664, "ktime_to_ns": 16665, "ktime_to_timespec": 16666, "ktime_to_timespec64": 16667, "ktime_to_timeval": 16668, "ktime_to_us": 16669, "kts": 16670, "ktv": 16671, "ktx": 16672, "ktype": 16673, "kuid": 16674, "kuid_has_mapping": 16675, "kuid_t": 16676, "kuidt_init": 16677, "kunmap": 16678, "kunmap_atomic": 16679, "kvfree": 16680, "kvm_check_and_clear_guest_paused": 16681, "kwatchdog": 16682, "kzalloc": 16683, "kzalloc_node": 16684, "l": 16685, "l1": 16686, "l1_cache_bytes": 16687, "l2": 16688, "l_new": 16689, "l_next": 16690, "l_old": 16691, "l_show": 16692, "l_start": 16693, "l_stop": 16694, "label": 16695, "lagged": 16696, "laptop_mode": 16697, "large": 16698, "largest": 16699, "last": 16700, "last_accelerate": 16701, "last_active": 16702, "last_addr": 16703, "last_advance_all": 16704, "last_arrival": 16705, "last_balance": 16706, "last_buddy": 16707, "last_bytesperword": 16708, "last_check": 16709, "last_cpupid": 16710, "last_cpupid_mask": 16711, "last_decay": 16712, "last_entry": 16713, "last_ftrace_enabled": 16714, "last_h_load_update": 16715, "last_highmem_page": 16716, "last_highmem_page_copied": 16717, "last_i": 16718, "last_index": 16719, "last_jiffies": 16720, "last_jiffies_update": 16721, "last_load_update_tick": 16722, "last_msg": 16723, "last_overrun": 16724, "last_page": 16725, "last_pid": 16726, "last_pool": 16727, "last_queued": 16728, "last_radix": 16729, "last_repeat": 16730, "last_residency": 16731, "last_runnable_update": 16732, "last_sched_tick": 16733, "last_seed": 16734, "last_siginfo": 16735, "last_stack_tracer_enabled": 16736, "last_sum_exec_runtime": 16737, "last_switch_count": 16738, "last_system": 16739, "last_task": 16740, "last_task_numa_placement": 16741, "last_tick": 16742, "last_time": 16743, "last_unhandled": 16744, "last_unloaded_module": 16745, "last_update": 16746, "last_update_time": 16747, "last_wakee": 16748, "last_write": 16749, "lasterr": 16750, "lasterr_pos": 16751, "lastp": 16752, "lastreport": 16753, "lat": 16754, "lat_flag": 16755, "lat_print_generic": 16756, "lat_print_timestamp": 16757, "latch": 16758, "late": 16759, "late_initcall": 16760, "late_initcall_sync": 16761, "latency": 16762, "latency_lock": 16763, "latency_record": 16764, "latency_record_count": 16765, "latencytop_enabled": 16766, "later_mask": 16767, "latest_idle_timestamp": 16768, "latest_ns": 16769, "layout_and_allocate": 16770, "layout_sections": 16771, "layout_symtab": 16772, "lazy": 16773, "lazy_list": 16774, "lb_balanced": 16775, "lb_bias": 16776, "lb_count": 16777, "lb_env": 16778, "lb_failed": 16779, "lb_gained": 16780, "lb_hot_gained": 16781, "lb_imbalance": 16782, "lb_min": 16783, "lb_nobusyg": 16784, "lb_nobusyq": 16785, "lbf_all_pinned": 16786, "lbf_dst_pinned": 16787, "lbf_need_break": 16788, "lbf_some_pinned": 16789, "lbuf": 16790, "lc_next": 16791, "lc_show": 16792, "lc_start": 16793, "lc_stop": 16794, "lchown16": 16795, "ld": 16796, "ld_abs_b": 16797, "ld_abs_h": 16798, "ld_abs_w": 16799, "ld_imm64_to_map_ptr": 16800, "ld_imm_dw": 16801, "ld_ind_b": 16802, "ld_ind_h": 16803, "ld_ind_w": 16804, "ld_moved": 16805, "ldata": 16806, "ldst": 16807, "ldx_mem_": 16808, "ldx_mem_b": 16809, "ldx_mem_dw": 16810, "ldx_mem_h": 16811, "ldx_mem_w": 16812, "le16_to_cpu": 16813, "leader": 16814, "leader_pid": 16815, "leaf": 16816, "leaf_cfs_rq_list": 16817, "leaf_ret": 16818, "leap": 16819, "lease_break_time": 16820, "leases_enable": 16821, "leave": 16822, "leaves": 16823, "left": 16824, "left_child": 16825, "leftmost": 16826, "legacy_cftypes": 16827, "legacy_queue": 16828, "len": 16829, "len1": 16830, "len2": 16831, "len_left": 16832, "len_or_zero": 16833, "len_ptr": 16834, "len_sent": 16835, "length": 16836, "lenp": 16837, "level": 16838, "levelcnt": 16839, "levels": 16840, "levels_needed": 16841, "levelspread": 16842, "lg": 16843, "lg_global_lock": 16844, "lg_global_unlock": 16845, "lg_local_lock": 16846, "lg_local_lock_cpu": 16847, "lg_local_unlock": 16848, "lg_local_unlock_cpu": 16849, "lg_lock_init": 16850, "lglock": 16851, "lhs": 16852, "licence": 16853, "license": 16854, "license_is_gpl_compatible": 16855, "like": 16856, "likely": 16857, "lim": 16858, "limit": 16859, "limited": 16860, "limits": 16861, "line": 16862, "linear": 16863, "linear_revmap": 16864, "lineno_checksum": 16865, "lines": 16866, "link": 16867, "link1": 16868, "link2": 16869, "link_css_set": 16870, "link_pwq": 16871, "link_target": 16872, "linked": 16873, "linked_page": 16874, "linked_page_data_size": 16875, "links": 16876, "links_to_free": 16877, "linux_binprm": 16878, "linux_reboot_cmd_cad_off": 16879, "linux_reboot_cmd_cad_on": 16880, "linux_reboot_cmd_halt": 16881, "linux_reboot_cmd_power_off": 16882, "linux_reboot_cmd_restart": 16883, "linux_reboot_cmd_restart2": 16884, "linux_reboot_magic1": 16885, "linux_reboot_magic2": 16886, "linux_reboot_magic2a": 16887, "linux_reboot_magic2b": 16888, "linux_reboot_magic2c": 16889, "linux_regs": 16890, "linux_version_code": 16891, "list": 16892, "list_add": 16893, "list_add_event": 16894, "list_add_leaf_cfs_rq": 16895, "list_add_rcu": 16896, "list_add_tail": 16897, "list_add_tail_rcu": 16898, "list_del": 16899, "list_del_event": 16900, "list_del_init": 16901, "list_del_leaf_cfs_rq": 16902, "list_del_rcu": 16903, "list_empty": 16904, "list_empty_careful": 16905, "list_entries": 16906, "list_entry": 16907, "list_entry_rcu": 16908, "list_first_entry": 16909, "list_first_entry_or_null": 16910, "list_first_or_null_rcu": 16911, "list_for_each": 16912, "list_for_each_entry": 16913, "list_for_each_entry_continue": 16914, "list_for_each_entry_rcu": 16915, "list_for_each_entry_reverse": 16916, "list_for_each_entry_safe": 16917, "list_for_each_entry_safe_continue": 16918, "list_for_each_entry_safe_from": 16919, "list_head": 16920, "list_head_init": 16921, "list_is_last": 16922, "list_is_singular": 16923, "list_move": 16924, "list_move_tail": 16925, "list_next_entry": 16926, "list_node": 16927, "list_op_pending": 16928, "list_p": 16929, "list_poison2": 16930, "list_prev_entry": 16931, "list_replace": 16932, "list_replace_init": 16933, "list_replace_rcu": 16934, "list_rotate_left": 16935, "list_splice_init": 16936, "list_splice_tail": 16937, "list_splice_tail_init": 16938, "listener": 16939, "listener_array": 16940, "listener_list": 16941, "listeners": 16942, "listnr": 16943, "live": 16944, "lld": 16945, "llist": 16946, "llist_add": 16947, "llist_del_all": 16948, "llist_empty": 16949, "llist_entry": 16950, "llist_for_each_entry": 16951, "llist_for_each_entry_safe": 16952, "llist_head": 16953, "llist_next": 16954, "llist_node": 16955, "llist_reverse_order": 16956, "llnode": 16957, "llong_max": 16958, "llong_min": 16959, "llseek": 16960, "llu": 16961, "lluns": 16962, "llx": 16963, "load": 16964, "load_a": 16965, "load_above_capacity": 16966, "load_addr": 16967, "load_avg": 16968, "load_avg_contrib": 16969, "load_avg_max": 16970, "load_avg_max_n": 16971, "load_avg_period": 16972, "load_b": 16973, "load_balance": 16974, "load_balance_mask": 16975, "load_byte": 16976, "load_contrib": 16977, "load_frac": 16978, "load_freq": 16979, "load_half": 16980, "load_header": 16981, "load_idx": 16982, "load_image": 16983, "load_image_lzo": 16984, "load_info": 16985, "load_int": 16986, "load_module": 16987, "load_per_task": 16988, "load_system_certificate_list": 16989, "load_too_imbalanced": 16990, "load_weight": 16991, "load_word": 16992, "loaded": 16993, "loaded_info": 16994, "loads": 16995, "loc": 16996, "local": 16997, "local64_read": 16998, "local64_set": 16999, "local64_xchg": 17000, "local_add": 17001, "local_add_return": 17002, "local_bh_disable": 17003, "local_bh_enable": 17004, "local_clock": 17005, "local_clock_stable": 17006, "local_cmpxchg": 17007, "local_cpu": 17008, "local_cpu_mask": 17009, "local_debuggerinfo": 17010, "local_dec": 17011, "local_dec_and_test": 17012, "local_distance": 17013, "local_group": 17014, "local_hash": 17015, "local_inc": 17016, "local_inc_return": 17017, "local_irq_disable": 17018, "local_irq_enable": 17019, "local_irq_restore": 17020, "local_irq_save": 17021, "local_list": 17022, "local_n": 17023, "local_read": 17024, "local_samples_len": 17025, "local_save_flags": 17026, "local_set": 17027, "local_softirq_pending": 17028, "local_stat": 17029, "local_sub": 17030, "local_t": 17031, "local_xchg": 17032, "locate_mem_hole_bottom_up": 17033, "locate_mem_hole_callback": 17034, "locate_mem_hole_top_down": 17035, "locate_module_kobject": 17036, "lock": 17037, "lock_accessed": 17038, "lock_acquire": 17039, "lock_acquire_exclusive": 17040, "lock_acquire_shared": 17041, "lock_acquired": 17042, "lock_busted_ops": 17043, "lock_chain": 17044, "lock_chain_get_class": 17045, "lock_chains": 17046, "lock_class": 17047, "lock_class_key": 17048, "lock_class_stats": 17049, "lock_classes": 17050, "lock_contended": 17051, "lock_contended_flags": 17052, "lock_count": 17053, "lock_cq": 17054, "lock_dep_map": 17055, "lock_device_hotplug": 17056, "lock_enabled_": 17057, "lock_enabled_hardirq": 17058, "lock_enabled_hardirq_read": 17059, "lock_enabled_softirq": 17060, "lock_enabled_softirq_read": 17061, "lock_entry": 17062, "lock_flag": 17063, "lock_from": 17064, "lock_id": 17065, "lock_init_error": 17066, "lock_is_held": 17067, "lock_is_read_held": 17068, "lock_is_write_held": 17069, "lock_key": 17070, "lock_len": 17071, "lock_limit": 17072, "lock_list": 17073, "lock_map_acquire": 17074, "lock_map_acquire_read": 17075, "lock_map_acquire_tryread": 17076, "lock_map_release": 17077, "lock_name": 17078, "lock_page": 17079, "lock_point": 17080, "lock_release": 17081, "lock_release_holdtime": 17082, "lock_release_nested": 17083, "lock_release_non_nested": 17084, "lock_set_class": 17085, "lock_set_subclass": 17086, "lock_stat": 17087, "lock_stat_cmp": 17088, "lock_stat_data": 17089, "lock_stat_open": 17090, "lock_stat_release": 17091, "lock_stat_seq": 17092, "lock_stat_write": 17093, "lock_stats": 17094, "lock_stress_stats": 17095, "lock_system_sleep": 17096, "lock_task_sighand": 17097, "lock_time": 17098, "lock_time_add": 17099, "lock_time_inc": 17100, "lock_timer": 17101, "lock_timer_base": 17102, "lock_torture_cleanup": 17103, "lock_torture_cxt": 17104, "lock_torture_init": 17105, "lock_torture_ops": 17106, "lock_torture_print_module_parms": 17107, "lock_torture_reader": 17108, "lock_torture_stats": 17109, "lock_torture_stats_print": 17110, "lock_torture_writer": 17111, "lock_usage_bit": 17112, "lock_usage_chars": 17113, "lock_usage_states": 17114, "lock_used": 17115, "lock_used_in_": 17116, "lock_used_in_hardirq": 17117, "lock_used_in_hardirq_read": 17118, "lock_used_in_reclaim_fs": 17119, "lock_used_in_reclaim_fs_read": 17120, "lock_used_in_softirq": 17121, "lock_used_in_softirq_read": 17122, "lockdep": 17123, "lockdep_assert_held": 17124, "lockdep_chains_open": 17125, "lockdep_chains_ops": 17126, "lockdep_clear_current_reclaim_state": 17127, "lockdep_copy_map": 17128, "lockdep_count_backward_deps": 17129, "lockdep_count_forward_deps": 17130, "lockdep_dependency_gen_id": 17131, "lockdep_depth": 17132, "lockdep_free_key_range": 17133, "lockdep_init": 17134, "lockdep_init_error": 17135, "lockdep_init_map": 17136, "lockdep_init_trace": 17137, "lockdep_init_trace_data": 17138, "lockdep_initialized": 17139, "lockdep_is_held": 17140, "lockdep_key": 17141, "lockdep_lock": 17142, "lockdep_map": 17143, "lockdep_now_unreliable": 17144, "lockdep_off": 17145, "lockdep_ok": 17146, "lockdep_on": 17147, "lockdep_open": 17148, "lockdep_ops": 17149, "lockdep_print_held_locks": 17150, "lockdep_proc_init": 17151, "lockdep_rcu_suspicious": 17152, "lockdep_reclaim_gfp": 17153, "lockdep_recursion": 17154, "lockdep_reset": 17155, "lockdep_reset_lock": 17156, "lockdep_set_class": 17157, "lockdep_set_class_and_name": 17158, "lockdep_set_current_reclaim_state": 17159, "lockdep_softirq_end": 17160, "lockdep_softirq_enter": 17161, "lockdep_softirq_exit": 17162, "lockdep_softirq_start": 17163, "lockdep_state": 17164, "lockdep_stats": 17165, "lockdep_stats_debug_show": 17166, "lockdep_stats_open": 17167, "lockdep_stats_show": 17168, "lockdep_still_ok": 17169, "lockdep_subclass_key": 17170, "lockdep_sys_exit": 17171, "lockdep_tasklist_lock_is_held": 17172, "lockdep_trace_alloc": 17173, "locked": 17174, "locked_shm": 17175, "locked_vm": 17176, "lockf_": 17177, "lockf_enabled_hardirq": 17178, "lockf_enabled_hardirq_read": 17179, "lockf_enabled_irq": 17180, "lockf_enabled_irq_read": 17181, "lockf_enabled_softirq": 17182, "lockf_enabled_softirq_read": 17183, "lockf_used": 17184, "lockf_used_in_hardirq": 17185, "lockf_used_in_hardirq_read": 17186, "lockf_used_in_irq": 17187, "lockf_used_in_irq_read": 17188, "lockf_used_in_softirq": 17189, "lockf_used_in_softirq_read": 17190, "locking": 17191, "locks_after": 17192, "locks_before": 17193, "lockstat_clock": 17194, "lockstat_ops": 17195, "locktorture_runnable_init": 17196, "locktype": 17197, "lockup_detector_init": 17198, "lockwakeup": 17199, "loff_t": 17200, "log": 17201, "log_action": 17202, "log_align": 17203, "log_buf": 17204, "log_buf_len": 17205, "log_cont": 17206, "log_first_idx": 17207, "log_first_seq": 17208, "log_flags": 17209, "log_from_idx": 17210, "log_len": 17211, "log_level": 17212, "log_line_max": 17213, "log_lvl": 17214, "log_make_free_space": 17215, "log_newline": 17216, "log_next": 17217, "log_next_idx": 17218, "log_next_seq": 17219, "log_nocons": 17220, "log_passwd": 17221, "log_prefix": 17222, "log_size": 17223, "log_ubuf": 17224, "log_wait": 17225, "logarithmic_accumulation": 17226, "logbuf_has_space": 17227, "logbuf_lock": 17228, "logged": 17229, "logging": 17230, "loginuid": 17231, "loglevel": 17232, "long": 17233, "long_act": 17234, "long_max": 17235, "long_min": 17236, "longdelay": 17237, "longdelay_ms": 17238, "longdelay_us": 17239, "longjmp_break_handler": 17240, "look_up_lock_class": 17241, "lookup": 17242, "lookup_chain_cache": 17243, "lookup_elem_raw": 17244, "lookup_format": 17245, "lookup_module_symbol_attrs": 17246, "lookup_module_symbol_name": 17247, "lookup_resource": 17248, "lookup_symbol": 17249, "lookup_symbol_attrs": 17250, "lookup_symbol_name": 17251, "loop": 17252, "loop_break": 17253, "loop_max": 17254, "loops": 17255, "loops_per_jiffy": 17256, "loops_per_msec": 17257, "lost": 17258, "lost_event": 17259, "lost_events": 17260, "low": 17261, "low2highgid": 17262, "low2highuid": 17263, "low_free_pages": 17264, "low_shift": 17265, "lowbp": 17266, "lower": 17267, "lower_first": 17268, "lower_last": 17269, "lower_ns": 17270, "lowering": 17271, "lowest_flag_domain": 17272, "lowest_in_progress": 17273, "lowest_mask": 17274, "lowest_rq": 17275, "lowmem_reserve_ratio_sysctl_handler": 17276, "lp": 17277, "lparam": 17278, "lpj": 17279, "lr": 17280, "lrsa": 17281, "lrsp": 17282, "lru": 17283, "lru_cache_add_active_or_unevictable": 17284, "ls": 17285, "ls_next": 17286, "ls_show": 17287, "ls_start": 17288, "ls_stop": 17289, "lsh": 17290, "lsm_rule": 17291, "lsm_setid_fs": 17292, "lsm_setid_id": 17293, "lsm_setid_re": 17294, "lsm_setid_res": 17295, "lsm_str": 17296, "lstats_fops": 17297, "lstats_open": 17298, "lstats_show": 17299, "lstats_write": 17300, "lt": 17301, "lt_backtracedepth": 17302, "lt_savecount": 17303, "lu": 17304, "lval": 17305, "lvalp": 17306, "lvl": 17307, "lw": 17308, "lwsa": 17309, "lwsp": 17310, "lx": 17311, "lzero": 17312, "lzo1x_1_compress": 17313, "lzo1x_1_mem_compress": 17314, "lzo1x_decompress_safe": 17315, "lzo1x_worst_compress": 17316, "lzo_cmp_pages": 17317, "lzo_cmp_size": 17318, "lzo_compress_threadfn": 17319, "lzo_decompress_threadfn": 17320, "lzo_header": 17321, "lzo_max_rd_pages": 17322, "lzo_min_rd_pages": 17323, "lzo_threads": 17324, "lzo_unc_pages": 17325, "lzo_unc_size": 17326, "m": 17327, "m1": 17328, "m2": 17329, "m_next": 17330, "m_show": 17331, "m_start": 17332, "m_stop": 17333, "machine": 17334, "machine_crash_shutdown": 17335, "machine_emergency_restart": 17336, "machine_halt": 17337, "machine_kexec": 17338, "machine_kexec_cleanup": 17339, "machine_kexec_prepare": 17340, "machine_power_off": 17341, "machine_restart": 17342, "machine_shutdown": 17343, "machine_suspend": 17344, "maddr": 17345, "magic": 17346, "magic1": 17347, "magic2": 17348, "magic_end": 17349, "magic_etc": 17350, "magic_size": 17351, "magic_start": 17352, "main": 17353, "main_extable_sort_needed": 17354, "main_ops": 17355, "maj": 17356, "maj_flt": 17357, "major": 17358, "make": 17359, "make_data_rloc": 17360, "make_key_ref": 17361, "make_kgid": 17362, "make_kprojid": 17363, "make_kuid": 17364, "manage_workers": 17365, "manager": 17366, "manager_arb": 17367, "managing": 17368, "mantsize": 17369, "map": 17370, "map_alloc": 17371, "map_cmdline_to_pid": 17372, "map_count": 17373, "map_create": 17374, "map_delete_elem": 17375, "map_denywrite": 17376, "map_executable": 17377, "map_fd": 17378, "map_flags": 17379, "map_free": 17380, "map_get_next_key": 17381, "map_hugetlb": 17382, "map_id": 17383, "map_id_down": 17384, "map_id_range_down": 17385, "map_id_up": 17386, "map_info": 17387, "map_locked": 17388, "map_lookup_elem": 17389, "map_page_entries": 17390, "map_pid_to_cmdline": 17391, "map_private": 17392, "map_ptr": 17393, "map_shared": 17394, "map_type": 17395, "map_update_elem": 17396, "map_write": 17397, "mapp": 17398, "mapped": 17399, "mapping": 17400, "mappings_overlap": 17401, "maps": 17402, "mark": 17403, "mark_explored": 17404, "mark_free_pages": 17405, "mark_held_locks": 17406, "mark_irqflags": 17407, "mark_lock": 17408, "mark_lock_accessed": 17409, "mark_lock_irq": 17410, "mark_nosave_pages": 17411, "mark_reg_unknown_value": 17412, "mark_swapfiles": 17413, "mark_type": 17414, "mark_unsafe_pages": 17415, "mark_work_canceling": 17416, "markerlen": 17417, "marking": 17418, "mask": 17419, "mask_ack_irq": 17420, "mask_cache": 17421, "mask_cache_priv": 17422, "mask_declare_1": 17423, "mask_declare_8": 17424, "mask_i": 17425, "mask_irq": 17426, "mask_m": 17427, "mask_maps": 17428, "mask_tc_bit": 17429, "mask_type": 17430, "masked": 17431, "maskp": 17432, "masks": 17433, "masters_in_kgdb": 17434, "match": 17435, "match_data": 17436, "match_end_only": 17437, "match_entries": 17438, "match_front_only": 17439, "match_full": 17440, "match_held_lock": 17441, "match_middle_only": 17442, "match_state": 17443, "match_tree_refs": 17444, "match_uprobe": 17445, "mattr": 17446, "max": 17447, "max_active": 17448, "max_active_show": 17449, "max_active_store": 17450, "max_arch_header_size": 17451, "max_arg_strlen": 17452, "max_argstr_len": 17453, "max_bfs_queue_depth": 17454, "max_bpf_reg": 17455, "max_bpf_stack": 17456, "max_buf": 17457, "max_buffer": 17458, "max_bytes_for_cpu": 17459, "max_cfs_quota_period": 17460, "max_cftype_name": 17461, "max_cgroup_root_namelen": 17462, "max_cgroup_type_namelen": 17463, "max_circular_queue_size": 17464, "max_clock": 17465, "max_clocks": 17466, "max_cmdlineconsoles": 17467, "max_cost": 17468, "max_count": 17469, "max_cycles": 17470, "max_data": 17471, "max_delta": 17472, "max_delta_ns": 17473, "max_delta_ticks": 17474, "max_depth": 17475, "max_dl_prio": 17476, "max_dma_channels": 17477, "max_entries": 17478, "max_entries_bits": 17479, "max_errno": 17480, "max_event_name_len": 17481, "max_execve_audit_len": 17482, "max_extfrag_threshold": 17483, "max_faults": 17484, "max_files": 17485, "max_filter_pred": 17486, "max_filter_str_val": 17487, "max_graph_depth": 17488, "max_group": 17489, "max_group_faults": 17490, "max_group_nid": 17491, "max_hang_time": 17492, "max_idle_balance_cost": 17493, "max_idle_ns": 17494, "max_idle_workers_ratio": 17495, "max_insn_size": 17496, "max_insns_per_path": 17497, "max_interrupts": 17498, "max_interval": 17499, "max_iores_level": 17500, "max_jiffy_offset": 17501, "max_kmod_concurrent": 17502, "max_latency": 17503, "max_level": 17504, "max_load_balance_interval": 17505, "max_load_idx": 17506, "max_lock": 17507, "max_lock_depth": 17508, "max_lockdep_chain_hlocks": 17509, "max_lockdep_chains": 17510, "max_lockdep_depth": 17511, "max_lockdep_entries": 17512, "max_lockdep_keys": 17513, "max_lockdep_keys_bits": 17514, "max_lockdep_subclasses": 17515, "max_modprobes": 17516, "max_namelen": 17517, "max_newidle_lb_cost": 17518, "max_nice": 17519, "max_nid": 17520, "max_node": 17521, "max_nr_zones": 17522, "max_numnodes": 17523, "max_obj_num": 17524, "max_offline": 17525, "max_online": 17526, "max_order": 17527, "max_pid_ns_level": 17528, "max_pinned_interval": 17529, "max_prio": 17530, "max_proctitle_audit_len": 17531, "max_pull": 17532, "max_rcu_lvls": 17533, "max_restart": 17534, "max_rt_prio": 17535, "max_rt_test_mutexes": 17536, "max_rt_test_threads": 17537, "max_samples_per_tick": 17538, "max_scan": 17539, "max_scan_window": 17540, "max_sched_granularity_ns": 17541, "max_sched_tunable_scaling": 17542, "max_schedule_timeout": 17543, "max_score": 17544, "max_sec_in_jiffies": 17545, "max_sequence": 17546, "max_shares": 17547, "max_size": 17548, "max_size_nested": 17549, "max_softirq_restart": 17550, "max_softirq_time": 17551, "max_stack_lock": 17552, "max_stack_size": 17553, "max_stack_trace": 17554, "max_stack_trace_entries": 17555, "max_string_size": 17556, "max_swapfiles": 17557, "max_t": 17558, "max_tasks_shown_per_css": 17559, "max_threads": 17560, "max_threads_suggested": 17561, "max_tickadj": 17562, "max_tickadj_scaled": 17563, "max_trace_args": 17564, "max_trace_lock": 17565, "max_tracer_size": 17566, "max_tval": 17567, "max_uprobe_xol_slots": 17568, "max_uretprobe_depth": 17569, "max_used_maps": 17570, "max_user_rt_prio": 17571, "max_vruntime": 17572, "max_wakeup_granularity_ns": 17573, "max_work": 17574, "max_write_len": 17575, "max_zone_pfn": 17576, "maxactive": 17577, "maxadj": 17578, "maxargc": 17579, "maxattr": 17580, "maxcpu": 17581, "maxdist": 17582, "maxerror": 17583, "maxexp2": 17584, "maxfract": 17585, "maxfract2": 17586, "maxfreq": 17587, "maxfreq_scaled": 17588, "maximum": 17589, "maxj": 17590, "maxlen": 17591, "maxlr": 17592, "maxolduid": 17593, "maxreserve": 17594, "maxrss": 17595, "maxshift": 17596, "maxtc": 17597, "may": 17598, "may_access_skb": 17599, "may_exec": 17600, "may_init_module": 17601, "may_ptrace_stop": 17602, "may_setgroups": 17603, "may_start_working": 17604, "maybe_create_worker": 17605, "maybe_kfree_parameter": 17606, "maybe_relocated": 17607, "mayday_initial_timeout": 17608, "mayday_interval": 17609, "mayday_node": 17610, "mayday_timer": 17611, "maydays": 17612, "mb": 17613, "mb_ret": 17614, "mbytes": 17615, "mc": 17616, "mchunk": 17617, "mckenney": 17618, "mcount_addr": 17619, "mcount_insn_size": 17620, "mcount_record": 17621, "mcs_spin_lock": 17622, "mcs_spin_unlock": 17623, "mcs_spinlock": 17624, "mdcount": 17625, "mdelay": 17626, "me": 17627, "means": 17628, "mem": 17629, "mem_bm_set_bit_check": 17630, "mem_cgroup": 17631, "mem_cgroup_cancel_charge": 17632, "mem_cgroup_commit_charge": 17633, "mem_cgroup_try_charge": 17634, "mem_extent": 17635, "mem_extents": 17636, "mem_from": 17637, "mem_idx": 17638, "mem_len": 17639, "mem_node": 17640, "mem_to": 17641, "mem_total": 17642, "mem_unit": 17643, "mem_zone_bm_rtree": 17644, "memblock_virt_alloc": 17645, "membuf_idx": 17646, "memcg": 17647, "memchr_inv": 17648, "memcmp": 17649, "memcpy": 17650, "memcpy_func": 17651, "memmove": 17652, "memory": 17653, "memory_bandwidth_notifier": 17654, "memory_bandwidth_pm_qos": 17655, "memory_bitmap": 17656, "memory_bm_clear_bit": 17657, "memory_bm_clear_current": 17658, "memory_bm_create": 17659, "memory_bm_find_bit": 17660, "memory_bm_free": 17661, "memory_bm_next_pfn": 17662, "memory_bm_pfn_present": 17663, "memory_bm_position_reset": 17664, "memory_bm_set_bit": 17665, "memory_bm_test_bit": 17666, "memory_bw_constraints": 17667, "memparse": 17668, "mempolicy": 17669, "mems_allowed": 17670, "mems_allowed_seq": 17671, "mems_updated": 17672, "memset": 17673, "memsz": 17674, "mend": 17675, "merge": 17676, "message": 17677, "message_loglevel_default": 17678, "messages": 17679, "meta": 17680, "method": 17681, "mg_dst_cset": 17682, "mg_node": 17683, "mg_preload_node": 17684, "mg_src_cgrp": 17685, "mg_tasks": 17686, "mg_tasks_head": 17687, "mid": 17688, "middle": 17689, "might": 17690, "might_sleep": 17691, "might_sleep_if": 17692, "migrate": 17693, "migrate_degrades_locality": 17694, "migrate_improves_locality": 17695, "migrate_swap": 17696, "migrate_swap_stop": 17697, "migrate_task_rq": 17698, "migrate_task_rq_fair": 17699, "migrate_task_to": 17700, "migrate_tasks": 17701, "migrate_timer_list": 17702, "migrate_timers": 17703, "migrate_to_reboot_cpu": 17704, "migrated": 17705, "migration_arg": 17706, "migration_call": 17707, "migration_cpu_stop": 17708, "migration_init": 17709, "migration_notifier": 17710, "migration_swap_arg": 17711, "min": 17712, "min_amount": 17713, "min_bandwidth_expiration": 17714, "min_cfs_quota_period": 17715, "min_cfs_rq_runtime": 17716, "min_clock": 17717, "min_delta": 17718, "min_delta_limit": 17719, "min_delta_ns": 17720, "min_delta_ticks": 17721, "min_exit_latency": 17722, "min_expire": 17723, "min_extfrag_threshold": 17724, "min_flt": 17725, "min_free_kbytes": 17726, "min_free_kbytes_sysctl_handler": 17727, "min_interval": 17728, "min_level": 17729, "min_load": 17730, "min_load_idx": 17731, "min_nice": 17732, "min_offline": 17733, "min_online": 17734, "min_sched_granularity_ns": 17735, "min_sched_tunable_scaling": 17736, "min_shares": 17737, "min_size": 17738, "min_size_nested": 17739, "min_t": 17740, "min_threads": 17741, "min_vruntime": 17742, "min_vruntime_copy": 17743, "min_wakeup_granularity_ns": 17744, "mini": 17745, "minimum_image_size": 17746, "minlen": 17747, "minolduid": 17748, "minor": 17749, "misc": 17750, "misc_dynamic_minor": 17751, "misc_register": 17752, "miscdevice": 17753, "mismatch": 17754, "misrouted_irq": 17755, "missed_events": 17756, "missed_updates": 17757, "missing": 17758, "mk": 17759, "mk_pid": 17760, "mk_pte": 17761, "mk_reply": 17762, "mkdir": 17763, "mkobj": 17764, "mktime64": 17765, "mm": 17766, "mm_access": 17767, "mm_alloc": 17768, "mm_alloc_pgd": 17769, "mm_anonpages": 17770, "mm_cachep": 17771, "mm_count": 17772, "mm_filepages": 17773, "mm_free_pgd": 17774, "mm_init": 17775, "mm_init_aio": 17776, "mm_init_cpumask": 17777, "mm_init_owner": 17778, "mm_nr_pmds": 17779, "mm_nr_pmds_init": 17780, "mm_rb": 17781, "mm_release": 17782, "mm_segment_t": 17783, "mm_struct": 17784, "mm_users": 17785, "mmap": 17786, "mmap2": 17787, "mmap_count": 17788, "mmap_data": 17789, "mmap_event": 17790, "mmap_init": 17791, "mmap_locked": 17792, "mmap_max_addr": 17793, "mmap_min_addr_handler": 17794, "mmap_mutex": 17795, "mmap_sem": 17796, "mmap_user": 17797, "mmdrop": 17798, "mmf_dump_filter_default": 17799, "mmf_exe_file_changed": 17800, "mmf_has_uprobes": 17801, "mmf_init_mask": 17802, "mmf_recalc_uprobes": 17803, "mmio_close": 17804, "mmio_pipe_open": 17805, "mmio_print_line": 17806, "mmio_print_map": 17807, "mmio_print_mark": 17808, "mmio_print_pcidev": 17809, "mmio_print_rw": 17810, "mmio_probe": 17811, "mmio_read": 17812, "mmio_reset_data": 17813, "mmio_trace_array": 17814, "mmio_trace_init": 17815, "mmio_trace_mapping": 17816, "mmio_trace_printk": 17817, "mmio_trace_reset": 17818, "mmio_trace_rw": 17819, "mmio_trace_start": 17820, "mmio_tracer": 17821, "mmio_unknown_op": 17822, "mmio_unprobe": 17823, "mmio_write": 17824, "mmiotrace_map": 17825, "mmiotrace_rw": 17826, "mmlist": 17827, "mmlist_lock": 17828, "mmput": 17829, "mmu_notifier_invalidate_range_end": 17830, "mmu_notifier_invalidate_range_start": 17831, "mmu_notifier_mm_destroy": 17832, "mmu_notifier_mm_init": 17833, "mmun_end": 17834, "mmun_start": 17835, "mnt": 17836, "mnt_clone_internal": 17837, "mnt_drop_write": 17838, "mnt_flags": 17839, "mnt_noexec": 17840, "mnt_ns": 17841, "mnt_root": 17842, "mnt_want_write": 17843, "mntput": 17844, "mod": 17845, "mod_delayed_work": 17846, "mod_delayed_work_on": 17847, "mod_extract_mpi_array": 17848, "mod_find_symname": 17849, "mod_fmt": 17850, "mod_initfree": 17851, "mod_kobject_put": 17852, "mod_make_digest": 17853, "mod_name": 17854, "mod_number_of_pages": 17855, "mod_percpu": 17856, "mod_sysfs_fini": 17857, "mod_sysfs_init": 17858, "mod_sysfs_setup": 17859, "mod_sysfs_teardown": 17860, "mod_timer": 17861, "mod_timer_pending": 17862, "mod_timer_pinned": 17863, "mod_verify_sig": 17864, "mod_zone_page_state": 17865, "modaddr": 17866, "mode": 17867, "mode1_syscalls": 17868, "mode1_syscalls_32": 17869, "modes": 17870, "modify": 17871, "modinfo_": 17872, "modinfo_attr": 17873, "modinfo_attrs": 17874, "modinfo_coresize": 17875, "modinfo_initsize": 17876, "modinfo_initstate": 17877, "modinfo_refcnt": 17878, "modinfo_srcversion": 17879, "modinfo_taint": 17880, "modinfo_version": 17881, "modlen": 17882, "modmagic": 17883, "modname": 17884, "modprobe_path": 17885, "module": 17886, "module_add_modinfo_attrs": 17887, "module_addr_max": 17888, "module_address_lookup": 17889, "module_alias": 17890, "module_alloc": 17891, "module_alloc_update_bounds": 17892, "module_arch_cleanup": 17893, "module_arch_freeing_init": 17894, "module_attr_show": 17895, "module_attr_store": 17896, "module_attribute": 17897, "module_author": 17898, "module_bug_cleanup": 17899, "module_core": 17900, "module_deallocate": 17901, "module_description": 17902, "module_event": 17903, "module_exit": 17904, "module_finalize": 17905, "module_flags": 17906, "module_flags_taint": 17907, "module_frob_arch_sections": 17908, "module_get": 17909, "module_get_kallsym": 17910, "module_init": 17911, "module_init_ignore_modversions": 17912, "module_init_ignore_vermagic": 17913, "module_is_live": 17914, "module_kallsyms_lookup_name": 17915, "module_kallsyms_on_each_symbol": 17916, "module_kobj_release": 17917, "module_kobject": 17918, "module_kset": 17919, "module_ktype": 17920, "module_layout": 17921, "module_license": 17922, "module_memfree": 17923, "module_mutex": 17924, "module_name": 17925, "module_name_len": 17926, "module_notes_attrs": 17927, "module_notes_read": 17928, "module_notify_list": 17929, "module_param": 17930, "module_param_attrs": 17931, "module_param_named": 17932, "module_param_prefix": 17933, "module_param_sysfs_remove": 17934, "module_param_sysfs_setup": 17935, "module_parm_desc": 17936, "module_put": 17937, "module_ref_base": 17938, "module_refcount": 17939, "module_region": 17940, "module_remove_modinfo_attrs": 17941, "module_sect_attr": 17942, "module_sect_attrs": 17943, "module_sect_show": 17944, "module_sig_check": 17945, "module_sig_string": 17946, "module_signature": 17947, "module_state_coming": 17948, "module_state_going": 17949, "module_state_live": 17950, "module_state_unformed": 17951, "module_sysfs_initialized": 17952, "module_sysfs_ops": 17953, "module_trace_bprintk_format_nb": 17954, "module_trace_bprintk_format_notify": 17955, "module_uevent": 17956, "module_uevent_ops": 17957, "module_unload_free": 17958, "module_unload_init": 17959, "module_use": 17960, "module_version_attribute": 17961, "module_wq": 17962, "modules": 17963, "modules_disabled": 17964, "modules_op": 17965, "modules_open": 17966, "modversion_info": 17967, "mon": 17968, "mon_day": 17969, "mono": 17970, "more": 17971, "more2boost": 17972, "more_balance": 17973, "moreprompt": 17974, "most": 17975, "mount": 17976, "mountopts": 17977, "move": 17978, "move_down": 17979, "move_linked_works": 17980, "move_module": 17981, "move_pages": 17982, "move_queued_task": 17983, "move_type": 17984, "move_up_from_left": 17985, "move_up_from_right": 17986, "moved_load": 17987, "moveimp": 17988, "mp": 17989, "mpi": 17990, "mpnt": 17991, "mpol_dup": 17992, "mpol_f_moron": 17993, "mpol_get": 17994, "mpol_mf_move_all": 17995, "mpol_put": 17996, "mpol_rebind_mm": 17997, "mpol_rebind_step1": 17998, "mpol_rebind_step2": 17999, "mpol_rebind_task": 18000, "mpx_disable_management": 18001, "mpx_enable_management": 18002, "mq_attr": 18003, "mq_curmsgs": 18004, "mq_flags": 18005, "mq_getsetattr": 18006, "mq_maxmsg": 18007, "mq_msgsize": 18008, "mq_notify": 18009, "mq_open": 18010, "mq_sendrecv": 18011, "mqd_t": 18012, "mqdes": 18013, "mqstat": 18014, "ms": 18015, "msdata": 18016, "msec": 18017, "msec_per_sec": 18018, "msec_to_hz_adj32": 18019, "msec_to_hz_mul32": 18020, "msec_to_hz_shr32": 18021, "msecs": 18022, "msecs_to_jiffies": 18023, "msg": 18024, "msg_data": 18025, "msg_file": 18026, "msg_len": 18027, "msg_prio": 18028, "msg_size": 18029, "msg_type": 18030, "msi_alloc_info_t": 18031, "msi_check": 18032, "msi_create_irq_domain": 18033, "msi_desc": 18034, "msi_domain_activate": 18035, "msi_domain_alloc": 18036, "msi_domain_alloc_irqs": 18037, "msi_domain_deactivate": 18038, "msi_domain_free": 18039, "msi_domain_free_irqs": 18040, "msi_domain_info": 18041, "msi_domain_ops": 18042, "msi_domain_ops_check": 18043, "msi_domain_ops_default": 18044, "msi_domain_ops_get_hwirq": 18045, "msi_domain_ops_init": 18046, "msi_domain_ops_prepare": 18047, "msi_domain_ops_set_desc": 18048, "msi_domain_set_affinity": 18049, "msi_domain_update_chip_ops": 18050, "msi_domain_update_dom_ops": 18051, "msi_finish": 18052, "msi_flag_identity_map": 18053, "msi_flag_use_def_chip_ops": 18054, "msi_flag_use_def_dom_ops": 18055, "msi_free": 18056, "msi_get_domain_info": 18057, "msi_init": 18058, "msi_msg": 18059, "msi_prepare": 18060, "msk": 18061, "mskptr": 18062, "mskreg": 18063, "msleep": 18064, "msleep_interruptible": 18065, "mstart": 18066, "much": 18067, "mul": 18068, "mul_u64_u32_shr": 18069, "mult": 18070, "mult_adj": 18071, "multi": 18072, "multi_cpu_stop": 18073, "multi_stop_data": 18074, "multi_stop_disable_irq": 18075, "multi_stop_exit": 18076, "multi_stop_none": 18077, "multi_stop_prepare": 18078, "multi_stop_run": 18079, "multi_stop_state": 18080, "multiplier": 18081, "munlock_vma_page": 18082, "munmap_notifier": 18083, "must": 18084, "mutex": 18085, "mutex_acquire": 18086, "mutex_acquire_nest": 18087, "mutex_can_spin_on_owner": 18088, "mutex_clear_owner": 18089, "mutex_debug_free": 18090, "mutex_debug_init": 18091, "mutex_destroy": 18092, "mutex_init": 18093, "mutex_is_locked": 18094, "mutex_lock": 18095, "mutex_lock_interruptible": 18096, "mutex_lock_interruptible_nested": 18097, "mutex_lock_killable": 18098, "mutex_lock_killable_nested": 18099, "mutex_lock_nested": 18100, "mutex_lock_ops": 18101, "mutex_optimistic_spin": 18102, "mutex_release": 18103, "mutex_remove_waiter": 18104, "mutex_set_owner": 18105, "mutex_spin_on_owner": 18106, "mutex_try_to_acquire": 18107, "mutex_trylock": 18108, "mutex_unlock": 18109, "mutex_waiter": 18110, "mutexes": 18111, "muxed_resource_wait": 18112, "my_grp": 18113, "my_q": 18114, "my_rdp": 18115, "my_scd": 18116, "mylat": 18117, "mynode": 18118, "mypatch": 18119, "n": 18120, "n_balk_blkd_tasks": 18121, "n_balk_boost_tasks": 18122, "n_balk_exp_gp_tasks": 18123, "n_balk_nos": 18124, "n_balk_notblocked": 18125, "n_balk_notyet": 18126, "n_barrier_attempts": 18127, "n_barrier_cbs": 18128, "n_barrier_done": 18129, "n_barrier_successes": 18130, "n_buckets": 18131, "n_cbfloods": 18132, "n_cbs_adopted": 18133, "n_cbs_invoked": 18134, "n_cbs_orphaned": 18135, "n_counters": 18136, "n_ctrs": 18137, "n_descsz": 18138, "n_exp_boosts": 18139, "n_force_qs": 18140, "n_force_qs_gpstart": 18141, "n_force_qs_lh": 18142, "n_force_qs_ngp": 18143, "n_force_qs_snap": 18144, "n_functions": 18145, "n_lock_acquired": 18146, "n_lock_fail": 18147, "n_lock_torture_errors": 18148, "n_logical_preds": 18149, "n_memory": 18150, "n_namesz": 18151, "n_nocbs_invoked": 18152, "n_normal_boosts": 18153, "n_normal_preds": 18154, "n_offline_attempts": 18155, "n_offline_successes": 18156, "n_online_attempts": 18157, "n_online_successes": 18158, "n_preds": 18159, "n_rcu_pending": 18160, "n_rcu_torture_alloc": 18161, "n_rcu_torture_alloc_fail": 18162, "n_rcu_torture_barrier_error": 18163, "n_rcu_torture_boost_failure": 18164, "n_rcu_torture_boost_ktrerror": 18165, "n_rcu_torture_boost_rterror": 18166, "n_rcu_torture_boosts": 18167, "n_rcu_torture_error": 18168, "n_rcu_torture_free": 18169, "n_rcu_torture_mberror": 18170, "n_rcu_torture_timers": 18171, "n_rp_cb_ready": 18172, "n_rp_cpu_needs_gp": 18173, "n_rp_gp_completed": 18174, "n_rp_gp_started": 18175, "n_rp_need_nothing": 18176, "n_rp_nocb_defer_wakeup": 18177, "n_rp_qs_pending": 18178, "n_rp_report_qs": 18179, "n_stress": 18180, "n_tasks_boosted": 18181, "n_type": 18182, "n_utask": 18183, "na": 18184, "name": 18185, "name_buf": 18186, "name_count": 18187, "name_len": 18188, "name_match": 18189, "name_max": 18190, "name_skip": 18191, "name_struct": 18192, "name_to_dev_t": 18193, "name_unique": 18194, "name_user": 18195, "name_version": 18196, "namebuf": 18197, "namefmt": 18198, "namelen": 18199, "nameoff": 18200, "names_list": 18201, "nand": 18202, "nanosleep": 18203, "narg": 18204, "nargs": 18205, "nattr": 18206, "nb": 18207, "nb_args": 18208, "nblock": 18209, "nbut": 18210, "nbytes": 18211, "ncbflooders": 18212, "ncsw": 18213, "ndetected": 18214, "ndoms": 18215, "ndoms_cur": 18216, "ndots": 18217, "ndst": 18218, "ndw": 18219, "nearest_hardwall_ancestor": 18220, "need": 18221, "need_active_balance": 18222, "need_decay": 18223, "need_forkexit_callback": 18224, "need_future_gp": 18225, "need_loop": 18226, "need_more_worker": 18227, "need_prep": 18228, "need_prune": 18229, "need_pull_rt_task": 18230, "need_qs": 18231, "need_rcu_nocb_mask": 18232, "need_rebuild_sched_domains": 18233, "need_resched": 18234, "need_seqretry": 18235, "need_serialize": 18236, "need_sid": 18237, "need_siglock": 18238, "need_to_create_worker": 18239, "needcheck": 18240, "needed": 18241, "needgp": 18242, "needmore": 18243, "needreport": 18244, "needs_unthr": 18245, "needwake": 18246, "neg": 18247, "neg_one": 18248, "negative": 18249, "negp": 18250, "nentry": 18251, "nest": 18252, "nest_lock": 18253, "nested": 18254, "net": 18255, "net_atalk": 18256, "net_atalk_aarp_expiry_time": 18257, "net_atalk_aarp_resolve_time": 18258, "net_atalk_aarp_retransmit_limit": 18259, "net_atalk_aarp_tick_time": 18260, "net_ax25": 18261, "net_ax25_backoff_type": 18262, "net_ax25_connect_mode": 18263, "net_ax25_dama_slave_timeout": 18264, "net_ax25_default_mode": 18265, "net_ax25_extended_window": 18266, "net_ax25_idle_timeout": 18267, "net_ax25_ip_default_mode": 18268, "net_ax25_n2": 18269, "net_ax25_paclen": 18270, "net_ax25_protocol": 18271, "net_ax25_standard_window": 18272, "net_ax25_t1_timeout": 18273, "net_ax25_t2_timeout": 18274, "net_ax25_t3_timeout": 18275, "net_cipsov4_cache_bucket_size": 18276, "net_cipsov4_cache_enable": 18277, "net_cipsov4_rbm_optfmt": 18278, "net_cipsov4_rbm_strictvalid": 18279, "net_core": 18280, "net_core_aevent_etime": 18281, "net_core_aevent_rseqth": 18282, "net_core_budget": 18283, "net_core_dev_weight": 18284, "net_core_max_backlog": 18285, "net_core_msg_burst": 18286, "net_core_msg_cost": 18287, "net_core_optmem_max": 18288, "net_core_rmem_default": 18289, "net_core_rmem_max": 18290, "net_core_somaxconn": 18291, "net_core_warnings": 18292, "net_core_wmem_default": 18293, "net_core_wmem_max": 18294, "net_decnet": 18295, "net_decnet_conf": 18296, "net_decnet_conf_ddcmp": 18297, "net_decnet_conf_dev_forwarding": 18298, "net_decnet_conf_dev_priority": 18299, "net_decnet_conf_dev_t2": 18300, "net_decnet_conf_dev_t3": 18301, "net_decnet_conf_ether": 18302, "net_decnet_conf_gre": 18303, "net_decnet_conf_loopback": 18304, "net_decnet_conf_ppp": 18305, "net_decnet_conf_x25": 18306, "net_decnet_debug_level": 18307, "net_decnet_default_device": 18308, "net_decnet_di_count": 18309, "net_decnet_dn_count": 18310, "net_decnet_dr_count": 18311, "net_decnet_dst_gc_interval": 18312, "net_decnet_mem": 18313, "net_decnet_no_fc_max_cwnd": 18314, "net_decnet_node_address": 18315, "net_decnet_node_name": 18316, "net_decnet_rmem": 18317, "net_decnet_time_wait": 18318, "net_decnet_wmem": 18319, "net_device": 18320, "net_generic": 18321, "net_ipv4": 18322, "net_ipv4_conf": 18323, "net_ipv4_conf_accept_redirects": 18324, "net_ipv4_conf_accept_source_route": 18325, "net_ipv4_conf_arp_accept": 18326, "net_ipv4_conf_arp_announce": 18327, "net_ipv4_conf_arp_ignore": 18328, "net_ipv4_conf_arp_notify": 18329, "net_ipv4_conf_arpfilter": 18330, "net_ipv4_conf_bootp_relay": 18331, "net_ipv4_conf_force_igmp_version": 18332, "net_ipv4_conf_forwarding": 18333, "net_ipv4_conf_log_martians": 18334, "net_ipv4_conf_mc_forwarding": 18335, "net_ipv4_conf_medium_id": 18336, "net_ipv4_conf_nopolicy": 18337, "net_ipv4_conf_noxfrm": 18338, "net_ipv4_conf_promote_secondaries": 18339, "net_ipv4_conf_proxy_arp": 18340, "net_ipv4_conf_rp_filter": 18341, "net_ipv4_conf_secure_redirects": 18342, "net_ipv4_conf_send_redirects": 18343, "net_ipv4_conf_shared_media": 18344, "net_ipv4_conf_tag": 18345, "net_ipv4_default_ttl": 18346, "net_ipv4_dynaddr": 18347, "net_ipv4_forward": 18348, "net_ipv4_icmp_echo_ignore_all": 18349, "net_ipv4_icmp_echo_ignore_broadcasts": 18350, "net_ipv4_icmp_errors_use_inbound_ifaddr": 18351, "net_ipv4_icmp_ignore_bogus_error_responses": 18352, "net_ipv4_icmp_ratelimit": 18353, "net_ipv4_icmp_ratemask": 18354, "net_ipv4_igmp_max_memberships": 18355, "net_ipv4_igmp_max_msf": 18356, "net_ipv4_inet_peer_gc_maxtime": 18357, "net_ipv4_inet_peer_gc_mintime": 18358, "net_ipv4_inet_peer_maxttl": 18359, "net_ipv4_inet_peer_minttl": 18360, "net_ipv4_inet_peer_threshold": 18361, "net_ipv4_ipfrag_high_thresh": 18362, "net_ipv4_ipfrag_low_thresh": 18363, "net_ipv4_ipfrag_secret_interval": 18364, "net_ipv4_ipfrag_time": 18365, "net_ipv4_local_port_range": 18366, "net_ipv4_neigh": 18367, "net_ipv4_netfilter": 18368, "net_ipv4_nf_conntrack_buckets": 18369, "net_ipv4_nf_conntrack_checksum": 18370, "net_ipv4_nf_conntrack_count": 18371, "net_ipv4_nf_conntrack_log_invalid": 18372, "net_ipv4_nf_conntrack_max": 18373, "net_ipv4_nf_conntrack_tcp_be_liberal": 18374, "net_ipv4_nf_conntrack_tcp_loose": 18375, "net_ipv4_nf_conntrack_tcp_max_retrans": 18376, "net_ipv4_no_pmtu_disc": 18377, "net_ipv4_nonlocal_bind": 18378, "net_ipv4_route": 18379, "net_ipv4_route_error_burst": 18380, "net_ipv4_route_error_cost": 18381, "net_ipv4_route_flush": 18382, "net_ipv4_route_gc_elasticity": 18383, "net_ipv4_route_gc_min_interval": 18384, "net_ipv4_route_gc_min_interval_ms": 18385, "net_ipv4_route_gc_thresh": 18386, "net_ipv4_route_gc_timeout": 18387, "net_ipv4_route_max_size": 18388, "net_ipv4_route_min_advmss": 18389, "net_ipv4_route_min_pmtu": 18390, "net_ipv4_route_mtu_expires": 18391, "net_ipv4_route_redirect_load": 18392, "net_ipv4_route_redirect_number": 18393, "net_ipv4_route_redirect_silence": 18394, "net_ipv4_tcp_fin_timeout": 18395, "net_ipv4_tcp_keepalive_intvl": 18396, "net_ipv4_tcp_keepalive_probes": 18397, "net_ipv4_tcp_keepalive_time": 18398, "net_ipv4_tcp_retrans_collapse": 18399, "net_ipv4_tcp_retries1": 18400, "net_ipv4_tcp_retries2": 18401, "net_ipv4_tcp_sack": 18402, "net_ipv4_tcp_syn_retries": 18403, "net_ipv4_tcp_timestamps": 18404, "net_ipv4_tcp_window_scaling": 18405, "net_ipv4_tcp_workaround_signed_windows": 18406, "net_ipv6": 18407, "net_ipv6_accept_ra": 18408, "net_ipv6_accept_ra_defrtr": 18409, "net_ipv6_accept_ra_from_local": 18410, "net_ipv6_accept_ra_pinfo": 18411, "net_ipv6_accept_ra_rt_info_max_plen": 18412, "net_ipv6_accept_ra_rtr_pref": 18413, "net_ipv6_accept_redirects": 18414, "net_ipv6_accept_source_route": 18415, "net_ipv6_autoconf": 18416, "net_ipv6_bindv6only": 18417, "net_ipv6_conf": 18418, "net_ipv6_dad_transmits": 18419, "net_ipv6_force_mld_version": 18420, "net_ipv6_forwarding": 18421, "net_ipv6_hop_limit": 18422, "net_ipv6_icmp": 18423, "net_ipv6_icmp_ratelimit": 18424, "net_ipv6_ip6frag_high_thresh": 18425, "net_ipv6_ip6frag_low_thresh": 18426, "net_ipv6_ip6frag_secret_interval": 18427, "net_ipv6_ip6frag_time": 18428, "net_ipv6_max_addresses": 18429, "net_ipv6_max_desync_factor": 18430, "net_ipv6_mld_max_msf": 18431, "net_ipv6_mtu": 18432, "net_ipv6_neigh": 18433, "net_ipv6_proxy_ndp": 18434, "net_ipv6_regen_max_retry": 18435, "net_ipv6_route": 18436, "net_ipv6_route_gc_elasticity": 18437, "net_ipv6_route_gc_interval": 18438, "net_ipv6_route_gc_min_interval": 18439, "net_ipv6_route_gc_min_interval_ms": 18440, "net_ipv6_route_gc_thresh": 18441, "net_ipv6_route_gc_timeout": 18442, "net_ipv6_route_max_size": 18443, "net_ipv6_route_min_advmss": 18444, "net_ipv6_route_mtu_expires": 18445, "net_ipv6_rtr_probe_interval": 18446, "net_ipv6_rtr_solicit_delay": 18447, "net_ipv6_rtr_solicit_interval": 18448, "net_ipv6_rtr_solicits": 18449, "net_ipv6_temp_prefered_lft": 18450, "net_ipv6_temp_valid_lft": 18451, "net_ipv6_use_tempaddr": 18452, "net_ipx": 18453, "net_ipx_pprop_broadcasting": 18454, "net_irda": 18455, "net_irda_debug": 18456, "net_irda_devname": 18457, "net_irda_discovery": 18458, "net_irda_discovery_slots": 18459, "net_irda_discovery_timeout": 18460, "net_irda_fast_poll": 18461, "net_irda_lap_keepalive_time": 18462, "net_irda_max_baud_rate": 18463, "net_irda_max_noreply_time": 18464, "net_irda_max_tx_data_size": 18465, "net_irda_max_tx_window": 18466, "net_irda_min_tx_turn_time": 18467, "net_irda_slot_timeout": 18468, "net_irda_warn_noreply_time": 18469, "net_llc": 18470, "net_llc2": 18471, "net_llc2_ack_timeout": 18472, "net_llc2_busy_timeout": 18473, "net_llc2_p_timeout": 18474, "net_llc2_rej_timeout": 18475, "net_llc_station": 18476, "net_llc_station_ack_timeout": 18477, "net_neigh_app_solicit": 18478, "net_neigh_delay_probe_time": 18479, "net_neigh_gc_interval": 18480, "net_neigh_gc_stale_time": 18481, "net_neigh_gc_thresh1": 18482, "net_neigh_gc_thresh2": 18483, "net_neigh_gc_thresh3": 18484, "net_neigh_mcast_solicit": 18485, "net_neigh_proxy_qlen": 18486, "net_neigh_reachable_time": 18487, "net_neigh_reachable_time_ms": 18488, "net_neigh_retrans_time_ms": 18489, "net_neigh_ucast_solicit": 18490, "net_neigh_unres_qlen": 18491, "net_netfilter": 18492, "net_netrom": 18493, "net_netrom_default_path_quality": 18494, "net_netrom_link_fails_count": 18495, "net_netrom_network_ttl_initialiser": 18496, "net_netrom_obsolescence_count_initialiser": 18497, "net_netrom_reset": 18498, "net_netrom_routing_control": 18499, "net_netrom_transport_acknowledge_delay": 18500, "net_netrom_transport_busy_delay": 18501, "net_netrom_transport_maximum_tries": 18502, "net_netrom_transport_no_activity_timeout": 18503, "net_netrom_transport_requested_window_size": 18504, "net_netrom_transport_timeout": 18505, "net_nf_conntrack_buckets": 18506, "net_nf_conntrack_checksum": 18507, "net_nf_conntrack_count": 18508, "net_nf_conntrack_frag6_high_thresh": 18509, "net_nf_conntrack_frag6_low_thresh": 18510, "net_nf_conntrack_log_invalid": 18511, "net_nf_conntrack_max": 18512, "net_nf_conntrack_tcp_be_liberal": 18513, "net_nf_conntrack_tcp_loose": 18514, "net_nf_conntrack_tcp_max_retrans": 18515, "net_ns": 18516, "net_proto_conf_all": 18517, "net_proto_conf_default": 18518, "net_rose": 18519, "net_rose_ack_hold_back_timeout": 18520, "net_rose_call_request_timeout": 18521, "net_rose_clear_request_timeout": 18522, "net_rose_link_fail_timeout": 18523, "net_rose_max_vcs": 18524, "net_rose_no_activity_timeout": 18525, "net_rose_reset_request_timeout": 18526, "net_rose_restart_request_timeout": 18527, "net_rose_routing_control": 18528, "net_rose_window_size": 18529, "net_sctp": 18530, "net_sctp_addip_enable": 18531, "net_sctp_association_max_retrans": 18532, "net_sctp_hb_interval": 18533, "net_sctp_max_burst": 18534, "net_sctp_max_init_retransmits": 18535, "net_sctp_path_max_retrans": 18536, "net_sctp_preserve_enable": 18537, "net_sctp_prsctp_enable": 18538, "net_sctp_rcvbuf_policy": 18539, "net_sctp_rto_alpha": 18540, "net_sctp_rto_beta": 18541, "net_sctp_rto_initial": 18542, "net_sctp_rto_max": 18543, "net_sctp_rto_min": 18544, "net_sctp_sack_timeout": 18545, "net_sctp_sndbuf_policy": 18546, "net_sctp_valid_cookie_life": 18547, "net_tcp_abort_on_overflow": 18548, "net_tcp_adv_win_scale": 18549, "net_tcp_allowed_cong_control": 18550, "net_tcp_app_win": 18551, "net_tcp_base_mss": 18552, "net_tcp_cong_control": 18553, "net_tcp_dsack": 18554, "net_tcp_ecn": 18555, "net_tcp_fack": 18556, "net_tcp_frto": 18557, "net_tcp_frto_response": 18558, "net_tcp_low_latency": 18559, "net_tcp_max_orphans": 18560, "net_tcp_max_ssthresh": 18561, "net_tcp_max_syn_backlog": 18562, "net_tcp_max_tw_buckets": 18563, "net_tcp_mem": 18564, "net_tcp_moderate_rcvbuf": 18565, "net_tcp_mtu_probing": 18566, "net_tcp_no_metrics_save": 18567, "net_tcp_orphan_retries": 18568, "net_tcp_reordering": 18569, "net_tcp_rfc1337": 18570, "net_tcp_rmem": 18571, "net_tcp_slow_start_after_idle": 18572, "net_tcp_stdurg": 18573, "net_tcp_synack_retries": 18574, "net_tcp_syncookies": 18575, "net_tcp_tso_win_divisor": 18576, "net_tcp_tw_recycle": 18577, "net_tcp_tw_reuse": 18578, "net_tcp_wmem": 18579, "net_tr": 18580, "net_tr_rif_timeout": 18581, "net_unix": 18582, "net_unix_max_dgram_qlen": 18583, "net_x25": 18584, "net_x25_ack_hold_back_timeout": 18585, "net_x25_call_request_timeout": 18586, "net_x25_clear_request_timeout": 18587, "net_x25_forward": 18588, "net_x25_reset_request_timeout": 18589, "net_x25_restart_request_timeout": 18590, "netlink_ack": 18591, "netlink_audit": 18592, "netlink_capable": 18593, "netlink_cb": 18594, "netlink_has_listeners": 18595, "netlink_kernel_cfg": 18596, "netlink_kernel_create": 18597, "netlink_kernel_release": 18598, "netlink_unicast": 18599, "network_lat_constraints": 18600, "network_lat_notifier": 18601, "network_lat_pm_qos": 18602, "network_throughput_notifier": 18603, "network_throughput_pm_qos": 18604, "network_tput_constraints": 18605, "never": 18606, "new": 18607, "new32": 18608, "new64": 18609, "new_action": 18610, "new_attrs": 18611, "new_base": 18612, "new_bit": 18613, "new_blocked": 18614, "new_bm": 18615, "new_bw": 18616, "new_cap": 18617, "new_cgrp": 18618, "new_class": 18619, "new_clock": 18620, "new_count": 18621, "new_cpu": 18622, "new_cpumask": 18623, "new_cpus": 18624, "new_cred": 18625, "new_cset": 18626, "new_css": 18627, "new_dbg_io_ops": 18628, "new_decode_dev": 18629, "new_dl": 18630, "new_dst_cpu": 18631, "new_exe_file": 18632, "new_ext": 18633, "new_fd": 18634, "new_fdp": 18635, "new_feature": 18636, "new_filter_string": 18637, "new_flag": 18638, "new_fs": 18639, "new_fsp": 18640, "new_func": 18641, "new_hash": 18642, "new_head": 18643, "new_idmap_permitted": 18644, "new_index": 18645, "new_ioc": 18646, "new_ka": 18647, "new_len": 18648, "new_load": 18649, "new_lock": 18650, "new_map": 18651, "new_mask": 18652, "new_mems": 18653, "new_mp": 18654, "new_name_str": 18655, "new_node": 18656, "new_ns": 18657, "new_nsp": 18658, "new_nsproxy": 18659, "new_opcode": 18660, "new_page": 18661, "new_pages": 18662, "new_parent": 18663, "new_pcap": 18664, "new_pgs": 18665, "new_pos": 18666, "new_prog": 18667, "new_rd": 18668, "new_res": 18669, "new_rlim": 18670, "new_sa": 18671, "new_sb": 18672, "new_sc": 18673, "new_set": 18674, "new_setting": 18675, "new_size": 18676, "new_sl": 18677, "new_spec": 18678, "new_ss": 18679, "new_ss_mask": 18680, "new_t": 18681, "new_tasks": 18682, "new_timer": 18683, "new_timer_id": 18684, "new_tp": 18685, "new_ts": 18686, "new_tz": 18687, "new_user": 18688, "new_utsname": 18689, "new_value": 18690, "newblocked": 18691, "newcookie": 18692, "newdev": 18693, "newf": 18694, "newidle_idx": 18695, "newlen": 18696, "newmask": 18697, "newmems": 18698, "newmm": 18699, "newoldstate": 18700, "newprio": 18701, "newset": 18702, "newset32": 18703, "newsize": 18704, "newsp": 18705, "newstate": 18706, "newtail": 18707, "newts": 18708, "newuname": 18709, "newval": 18710, "next": 18711, "next_arg": 18712, "next_balance": 18713, "next_bio": 18714, "next_buddy": 18715, "next_buddy_marked": 18716, "next_color": 18717, "next_cookie": 18718, "next_cpu": 18719, "next_ctx": 18720, "next_decay_max_lb_cost": 18721, "next_entry": 18722, "next_event": 18723, "next_event_type": 18724, "next_group": 18725, "next_index": 18726, "next_insn": 18727, "next_instance": 18728, "next_jiffies": 18729, "next_key": 18730, "next_l": 18731, "next_line": 18732, "next_nb": 18733, "next_node": 18734, "next_nr": 18735, "next_page": 18736, "next_parent": 18737, "next_pi": 18738, "next_pid": 18739, "next_pidmap": 18740, "next_pool": 18741, "next_prio": 18742, "next_queue": 18743, "next_res": 18744, "next_resource": 18745, "next_rq": 18746, "next_scan": 18747, "next_signal": 18748, "next_state": 18749, "next_string": 18750, "next_swap": 18751, "next_task": 18752, "next_task_group": 18753, "next_thread": 18754, "next_timer": 18755, "next_timer_max_delta": 18756, "next_ts": 18757, "next_uentry": 18758, "next_update": 18759, "nextarg": 18760, "nextargp": 18761, "nextc": 18762, "nextevt": 18763, "nextp": 18764, "nextr": 18765, "nextseq": 18766, "nextval": 18767, "nextw": 18768, "nfakewriters": 18769, "nfb": 18770, "nflags": 18771, "nfreed": 18772, "ng": 18773, "ngarbage": 18774, "ngroups": 18775, "ngroups_max": 18776, "nh": 18777, "nhit": 18778, "nice": 18779, "nice_0_load": 18780, "nice_0_shift": 18781, "nice_rlim": 18782, "nice_to_prio": 18783, "nice_to_rlimit": 18784, "niceval": 18785, "nid": 18786, "ninterval": 18787, "nivcsw": 18788, "nj": 18789, "nl": 18790, "nl_cfg_f_nonroot_recv": 18791, "nla_get_u32": 18792, "nla_len": 18793, "nla_policy": 18794, "nla_string": 18795, "nla_total_size": 18796, "nla_u32": 18797, "nlattr": 18798, "nlen": 18799, "nlh": 18800, "nlm_f_ack": 18801, "nlm_f_multi": 18802, "nlmsg_data": 18803, "nlmsg_done": 18804, "nlmsg_flags": 18805, "nlmsg_free": 18806, "nlmsg_hdr": 18807, "nlmsg_hdrlen": 18808, "nlmsg_len": 18809, "nlmsg_multicast": 18810, "nlmsg_new": 18811, "nlmsg_next": 18812, "nlmsg_ok": 18813, "nlmsg_pid": 18814, "nlmsg_put": 18815, "nlmsg_seq": 18816, "nlmsg_type": 18817, "nlmsghdr": 18818, "nloaded": 18819, "nlpd": 18820, "nlsk": 18821, "nmaskbits": 18822, "nmi_watchdog_enabled": 18823, "nmi_watchdog_enabled_bit": 18824, "nmissed": 18825, "nmsk": 18826, "no": 18827, "no_action": 18828, "no_blink": 18829, "no_children": 18830, "no_cmdline_map": 18831, "no_console_suspend": 18832, "no_constraint_value": 18833, "no_irq_affinity": 18834, "no_irq_chip": 18835, "no_join": 18836, "no_llseek": 18837, "no_nice": 18838, "no_numa": 18839, "no_poll_char": 18840, "no_printk": 18841, "no_suspend_depth": 18842, "no_unaligned_warning": 18843, "no_uprobe_events": 18844, "nocb": 18845, "nocb_defer_wakeup": 18846, "nocb_follower_head": 18847, "nocb_follower_tail": 18848, "nocb_follower_wait": 18849, "nocb_gp_head": 18850, "nocb_gp_tail": 18851, "nocb_gp_wq": 18852, "nocb_head": 18853, "nocb_kthread": 18854, "nocb_leader": 18855, "nocb_leader_sleep": 18856, "nocb_leader_wait": 18857, "nocb_next_follower": 18858, "nocb_q_count": 18859, "nocb_q_count_lazy": 18860, "nocb_tail": 18861, "nocb_wq": 18862, "noclean": 18863, "nocompress": 18864, "node": 18865, "node_bit": 18866, "node_distance": 18867, "node_found": 18868, "node_isset": 18869, "node_lock": 18870, "node_mask_none": 18871, "node_online_map": 18872, "node_pfn": 18873, "node_possible_map": 18874, "node_random": 18875, "node_set": 18876, "node_stamp": 18877, "node_states": 18878, "nodelist_parse": 18879, "nodemask": 18880, "nodemask_pr_args": 18881, "nodemask_t": 18882, "nodename": 18883, "nodep": 18884, "nodes": 18885, "nodes_and": 18886, "nodes_clear": 18887, "nodes_empty": 18888, "nodes_equal": 18889, "nodes_intersects": 18890, "nodes_or": 18891, "nodes_setall": 18892, "nodes_subset": 18893, "nodes_weight": 18894, "nohibernate": 18895, "nohz": 18896, "nohz_balance_enter_idle": 18897, "nohz_balance_exit_idle": 18898, "nohz_balance_kick": 18899, "nohz_balancer_kick": 18900, "nohz_flags": 18901, "nohz_full_kick_ipi": 18902, "nohz_full_kick_work": 18903, "nohz_full_kick_work_func": 18904, "nohz_idle": 18905, "nohz_idle_balance": 18906, "nohz_kick_needed": 18907, "nohz_mode": 18908, "nohz_mode_highres": 18909, "nohz_mode_inactive": 18910, "nohz_mode_lowres": 18911, "nohz_stamp": 18912, "nohz_tick_stopped": 18913, "noinline": 18914, "noirq": 18915, "noirqdebug": 18916, "noirqdebug_setup": 18917, "nokprobe_inline": 18918, "nokprobe_symbol": 18919, "non_isolated_cpus": 18920, "none": 18921, "nonlazy_posted": 18922, "nonlazy_posted_snap": 18923, "nonly": 18924, "nonseekable_open": 18925, "nontask_capacity": 18926, "noop": 18927, "noop_llseek": 18928, "noop_ret": 18929, "nop": 18930, "nop_test_accept": 18931, "nop_test_refuse": 18932, "nop_trace": 18933, "noresume": 18934, "norm": 18935, "normal_prio": 18936, "normalize_cfs_quota": 18937, "normalize_rt_tasks": 18938, "normalize_task": 18939, "normalized_sysctl_": 18940, "normalized_sysctl_sched_latency": 18941, "normalized_sysctl_sched_min_granularity": 18942, "normalized_sysctl_sched_wakeup_granularity": 18943, "nosave_region": 18944, "nosave_regions": 18945, "nosect": 18946, "nosmp": 18947, "not": 18948, "not_gpl_only": 18949, "not_in_range": 18950, "not_init": 18951, "not_visited": 18952, "note": 18953, "note_buf_t": 18954, "note_gp_changes": 18955, "note_interrupt": 18956, "notes": 18957, "notes_attr": 18958, "notes_attrs": 18959, "notes_size": 18960, "nother": 18961, "notice": 18962, "notification": 18963, "notification_mask": 18964, "notifier": 18965, "notifier_block": 18966, "notifier_call": 18967, "notifier_call_chain": 18968, "notifier_chain_cond_register": 18969, "notifier_chain_register": 18970, "notifier_chain_unregister": 18971, "notifier_data": 18972, "notifier_from_errno": 18973, "notifier_mask": 18974, "notifier_to_errno": 18975, "notifiers": 18976, "notify": 18977, "notify_bad": 18978, "notify_cpu_starting": 18979, "notify_die": 18980, "notify_done": 18981, "notify_ok": 18982, "notify_on_release": 18983, "notify_stop_mask": 18984, "notrace": 18985, "notrace_hash": 18986, "notused": 18987, "now": 18988, "now_gtod": 18989, "nowarn": 18990, "np": 18991, "nr": 18992, "nr_accumulated_samples": 18993, "nr_actions": 18994, "nr_active": 18995, "nr_active_anon": 18996, "nr_active_file": 18997, "nr_alloc": 18998, "nr_args": 18999, "nr_balance_failed": 19000, "nr_blocks": 19001, "nr_busy": 19002, "nr_busy_cpus": 19003, "nr_bytes": 19004, "nr_callchain_events": 19005, "nr_calls": 19006, "nr_cgrps": 19007, "nr_chain_hlocks": 19008, "nr_comm_events": 19009, "nr_compat_longs": 19010, "nr_context_switches": 19011, "nr_copy_pages": 19012, "nr_cpu_ids": 19013, "nr_cpumask_bits": 19014, "nr_cpus": 19015, "nr_cpus_allowed": 19016, "nr_cpus_bits": 19017, "nr_cpusets": 19018, "nr_cyclic_check_recursions": 19019, "nr_cyclic_checks": 19020, "nr_dirtied": 19021, "nr_dirtied_pause": 19022, "nr_drainers": 19023, "nr_entries": 19024, "nr_events": 19025, "nr_exclusive": 19026, "nr_extents": 19027, "nr_failed_migrations_affine": 19028, "nr_failed_migrations_hot": 19029, "nr_failed_migrations_running": 19030, "nr_faults": 19031, "nr_file_mapped": 19032, "nr_find_usage_backwards_checks": 19033, "nr_find_usage_backwards_recursions": 19034, "nr_find_usage_forwards_checks": 19035, "nr_find_usage_forwards_recursions": 19036, "nr_forced_migrations": 19037, "nr_free": 19038, "nr_free_highpages": 19039, "nr_free_pages": 19040, "nr_freq": 19041, "nr_freq_events": 19042, "nr_garbage": 19043, "nr_hangs": 19044, "nr_hardirq_chains": 19045, "nr_hardirq_read_safe": 19046, "nr_hardirq_read_unsafe": 19047, "nr_hardirq_safe": 19048, "nr_hardirq_unsafe": 19049, "nr_hashed": 19050, "nr_highmem": 19051, "nr_highmem_p": 19052, "nr_hits": 19053, "nr_idle": 19054, "nr_ids": 19055, "nr_in_flight": 19056, "nr_inactive_anon": 19057, "nr_inactive_file": 19058, "nr_io_wait": 19059, "nr_iowait": 19060, "nr_iowait_cpu": 19061, "nr_irq_read_safe": 19062, "nr_irq_read_unsafe": 19063, "nr_irq_safe": 19064, "nr_irq_unsafe": 19065, "nr_irqs": 19066, "nr_irqs_legacy": 19067, "nr_kernel_stack": 19068, "nr_latency": 19069, "nr_list_entries": 19070, "nr_load_updates": 19071, "nr_lock_chains": 19072, "nr_lock_classes": 19073, "nr_loops": 19074, "nr_meta_pages": 19075, "nr_migrations": 19076, "nr_migrations_cold": 19077, "nr_mmap_events": 19078, "nr_mpi": 19079, "nr_node_ids": 19080, "nr_numa_hint_fault_buckets": 19081, "nr_numa_hint_fault_stats": 19082, "nr_numa_hint_fault_types": 19083, "nr_numa_running": 19084, "nr_of_irqs": 19085, "nr_opts": 19086, "nr_pageflags": 19087, "nr_pages": 19088, "nr_pages_same": 19089, "nr_pages_to_update": 19090, "nr_periods": 19091, "nr_preferred_running": 19092, "nr_process_chains": 19093, "nr_processes": 19094, "nr_profile_grp": 19095, "nr_pte_updates": 19096, "nr_ptes": 19097, "nr_pwqs_to_flush": 19098, "nr_range": 19099, "nr_removed": 19100, "nr_retries": 19101, "nr_rq": 19102, "nr_running": 19103, "nr_scan_pages": 19104, "nr_sects": 19105, "nr_segments": 19106, "nr_siblings": 19107, "nr_slab_reclaimable": 19108, "nr_sleeping": 19109, "nr_softirq_chains": 19110, "nr_softirq_read_safe": 19111, "nr_softirq_read_unsafe": 19112, "nr_softirq_safe": 19113, "nr_softirq_unsafe": 19114, "nr_softirqs": 19115, "nr_spread_over": 19116, "nr_stack_trace_entries": 19117, "nr_stat": 19118, "nr_stopped": 19119, "nr_switches": 19120, "nr_syscalls": 19121, "nr_systemwide": 19122, "nr_task_events": 19123, "nr_tasks": 19124, "nr_threads": 19125, "nr_throttled": 19126, "nr_ticks": 19127, "nr_to_call": 19128, "nr_to_init": 19129, "nr_to_read": 19130, "nr_to_write": 19131, "nr_todo": 19132, "nr_uncategorized": 19133, "nr_uninterruptible": 19134, "nr_unused": 19135, "nr_unused_locks": 19136, "nr_waiters": 19137, "nr_wakeups": 19138, "nr_wakeups_affine": 19139, "nr_wakeups_affine_attempts": 19140, "nr_wakeups_idle": 19141, "nr_wakeups_local": 19142, "nr_wakeups_migrate": 19143, "nr_wakeups_passive": 19144, "nr_wakeups_remote": 19145, "nr_wakeups_sync": 19146, "nr_workers": 19147, "nrcpus": 19148, "nreaders": 19149, "nreaders_stress": 19150, "nrealreaders": 19151, "nrealreaders_stress": 19152, "nrealwriters_stress": 19153, "nrq": 19154, "ns": 19155, "ns2usecs": 19156, "ns_alloc_inum": 19157, "ns_capable": 19158, "ns_common": 19159, "ns_free_inum": 19160, "ns_ninterval": 19161, "ns_nval": 19162, "ns_of_pid": 19163, "ns_offset": 19164, "ns_to_jiffies": 19165, "ns_to_ktime": 19166, "ns_to_timespec": 19167, "ns_to_timespec64": 19168, "nsec": 19169, "nsec_conversion": 19170, "nsec_fls": 19171, "nsec_high": 19172, "nsec_jiffie_sc": 19173, "nsec_per_jiffy": 19174, "nsec_per_msec": 19175, "nsec_per_sec": 19176, "nsec_per_usec": 19177, "nsec_rem": 19178, "nsec_to_ahz": 19179, "nsec_to_clock_t": 19180, "nsecps": 19181, "nsecs": 19182, "nsecs_raw": 19183, "nsecs_real": 19184, "nsecs_rem": 19185, "nsecs_str": 19186, "nsecs_to_cputime": 19187, "nsecs_to_cputime64": 19188, "nsecs_to_jiffies": 19189, "nsecs_to_jiffies64": 19190, "nsecs_to_usecs": 19191, "nsections": 19192, "nset": 19193, "nsleep": 19194, "nsleep_restart": 19195, "nslot": 19196, "nsproxy": 19197, "nsproxy_cache_init": 19198, "nsproxy_cachep": 19199, "nsrc": 19200, "nstack": 19201, "nstype": 19202, "nsynctypes": 19203, "nt_prstatus": 19204, "nte": 19205, "nthe": 19206, "nto": 19207, "ntp_clear": 19208, "ntp_err_mult": 19209, "ntp_error": 19210, "ntp_error_shift": 19211, "ntp_init": 19212, "ntp_interval_freq": 19213, "ntp_interval_length": 19214, "ntp_notify_cmos_timer": 19215, "ntp_offset_chunk": 19216, "ntp_phase_limit": 19217, "ntp_scale_shift": 19218, "ntp_synced": 19219, "ntp_tick": 19220, "ntp_tick_length": 19221, "ntp_update_frequency": 19222, "ntp_update_offset": 19223, "ntp_update_offset_fll": 19224, "ntp_validate_timex": 19225, "ntpinterval": 19226, "null": 19227, "null_pm_qos": 19228, "nullsz": 19229, "num": 19230, "num_active_cpus": 19231, "num_chips": 19232, "num_counter_active": 19233, "num_cpus": 19234, "num_cpus_frozen": 19235, "num_ct": 19236, "num_ctors": 19237, "num_debug": 19238, "num_exentries": 19239, "num_ftrace_callsites": 19240, "num_gpl_future_syms": 19241, "num_gpl_syms": 19242, "num_jump_entries": 19243, "num_kp": 19244, "num_loaded": 19245, "num_obj": 19246, "num_online_cpus": 19247, "num_pages": 19248, "num_params": 19249, "num_physpages": 19250, "num_possible_cpus": 19251, "num_possible_nodes": 19252, "num_rcu_lvl": 19253, "num_rcu_lvl_0": 19254, "num_rcu_lvl_1": 19255, "num_rcu_lvl_2": 19256, "num_rcu_lvl_3": 19257, "num_rcu_lvl_4": 19258, "num_rcu_nodes": 19259, "num_syms": 19260, "num_symtab": 19261, "num_tests": 19262, "num_threads": 19263, "num_to_init": 19264, "num_trace_bprintk_fmt": 19265, "num_trace_enums": 19266, "num_trace_events": 19267, "num_tracepoints": 19268, "num_types": 19269, "num_unused_gpl_syms": 19270, "num_unused_syms": 19271, "num_versions": 19272, "numa": 19273, "numa_backplane": 19274, "numa_cpu": 19275, "numa_cpubuf": 19276, "numa_direct": 19277, "numa_faults": 19278, "numa_faults_locality": 19279, "numa_faults_stats": 19280, "numa_favour_higher": 19281, "numa_get_avg_runtime": 19282, "numa_glueless_mesh": 19283, "numa_group": 19284, "numa_level": 19285, "numa_mem": 19286, "numa_membuf": 19287, "numa_migrate_preferred": 19288, "numa_migrate_retry": 19289, "numa_next_scan": 19290, "numa_no_node": 19291, "numa_pages_migrated": 19292, "numa_period_slots": 19293, "numa_period_threshold": 19294, "numa_preferred_nid": 19295, "numa_pwq_tbl": 19296, "numa_pwq_tbl_install": 19297, "numa_resist_lower": 19298, "numa_scan_offset": 19299, "numa_scan_period": 19300, "numa_scan_period_max": 19301, "numa_scan_seq": 19302, "numa_stats": 19303, "numa_topology_type": 19304, "numa_work": 19305, "numa_zonelist_order": 19306, "numa_zonelist_order_handler": 19307, "numa_zonelist_order_len": 19308, "numabalancing_enabled": 19309, "number": 19310, "number_of_wakelocks": 19311, "numbers": 19312, "numchips": 19313, "numregbytes": 19314, "nused": 19315, "nval": 19316, "nvcsw": 19317, "nvec": 19318, "nvec_used": 19319, "nvisit": 19320, "nwatch": 19321, "nwhich": 19322, "nwriters_stress": 19323, "nxt": 19324, "nxtcompleted": 19325, "nxtlist": 19326, "nxttail": 19327, "nyou": 19328, "o": 19329, "o_accmode": 19330, "o_append": 19331, "o_cloexec": 19332, "o_largefile": 19333, "o_rdonly": 19334, "o_rdwr": 19335, "o_trunc": 19336, "o_utask": 19337, "o_wronly": 19338, "oact": 19339, "obj": 19340, "obj_tree": 19341, "object_debug": 19342, "object_size": 19343, "objname": 19344, "objs": 19345, "objtree": 19346, "odebug_state_active": 19347, "odebug_state_notavailable": 19348, "oentry": 19349, "of": 19350, "of_cft": 19351, "of_css": 19352, "of_node": 19353, "of_node_full_name": 19354, "of_node_get": 19355, "of_node_put": 19356, "of_node_to_nid": 19357, "off": 19358, "offline": 19359, "offline_css": 19360, "offline_fqs": 19361, "offline_waitq": 19362, "offp": 19363, "offs": 19364, "offs_boot": 19365, "offs_real": 19366, "offs_tai": 19367, "offset": 19368, "offset64": 19369, "offset_to_vaddr": 19370, "offsetof": 19371, "offsets": 19372, "oflag": 19373, "oflags": 19374, "ok": 19375, "old": 19376, "old32": 19377, "old64": 19378, "old_addr": 19379, "old_base": 19380, "old_bt": 19381, "old_bw": 19382, "old_cgrp": 19383, "old_clock": 19384, "old_contrib": 19385, "old_count": 19386, "old_cset": 19387, "old_css": 19388, "old_dbg_io_ops": 19389, "old_delta": 19390, "old_encode_dev": 19391, "old_entries": 19392, "old_entry": 19393, "old_exe": 19394, "old_exe_file": 19395, "old_ext": 19396, "old_feature": 19397, "old_flag": 19398, "old_flags": 19399, "old_fs": 19400, "old_fsgid": 19401, "old_fsuid": 19402, "old_getrlimit": 19403, "old_gid_t": 19404, "old_hash": 19405, "old_idx": 19406, "old_index": 19407, "old_iowait": 19408, "old_ka": 19409, "old_load": 19410, "old_lock": 19411, "old_lvl": 19412, "old_mems_allowed": 19413, "old_name": 19414, "old_notify": 19415, "old_ns": 19416, "old_opcode": 19417, "old_p": 19418, "old_page": 19419, "old_pcap": 19420, "old_period": 19421, "old_prio": 19422, "old_ptr": 19423, "old_pwq": 19424, "old_rb": 19425, "old_rd": 19426, "old_regs": 19427, "old_rhpp": 19428, "old_rlim": 19429, "old_rp": 19430, "old_runtime": 19431, "old_sa": 19432, "old_sc": 19433, "old_set": 19434, "old_setting": 19435, "old_sigaction": 19436, "old_sigset_t": 19437, "old_size": 19438, "old_spec": 19439, "old_ss": 19440, "old_stop": 19441, "old_tail": 19442, "old_tk": 19443, "old_tu": 19444, "old_uid_t": 19445, "old_userobj": 19446, "old_utsname": 19447, "old_val": 19448, "old_vsyscall_fixup": 19449, "old_write": 19450, "oldcount": 19451, "oldcs": 19452, "oldest": 19453, "oldf": 19454, "oldfs": 19455, "oldlen": 19456, "oldlenp": 19457, "oldloginuid": 19458, "oldmask": 19459, "oldmm": 19460, "oldold_utsname": 19461, "oldpolicy": 19462, "oldprio": 19463, "oldrss": 19464, "oldsessionid": 19465, "oldset": 19466, "oldstarttime": 19467, "oldstate": 19468, "oldtail": 19469, "oldts": 19470, "olduname": 19471, "oldval": 19472, "omsk": 19473, "on": 19474, "on_cpu": 19475, "on_dfl": 19476, "on_each_cpu": 19477, "on_each_cpu_cond": 19478, "on_each_cpu_mask": 19479, "on_exit_work": 19480, "on_list": 19481, "on_null_domain": 19482, "on_rq": 19483, "on_rt_rq": 19484, "on_sig_stack": 19485, "oncpu": 19486, "one": 19487, "one_hundred": 19488, "one_jiffy_scaled": 19489, "one_ss": 19490, "one_ul": 19491, "oneshot": 19492, "online": 19493, "online_cpus": 19494, "online_css": 19495, "only": 19496, "onoff_get_trigger_ops": 19497, "onoff_holdoff": 19498, "onoff_interval": 19499, "onoff_task": 19500, "onstack": 19501, "oom_callback_count": 19502, "oom_callback_wq": 19503, "oom_head": 19504, "oom_killer_disable": 19505, "oom_killer_enable": 19506, "oom_score_adj": 19507, "oom_score_adj_min": 19508, "oops_in_progress": 19509, "oops_setup": 19510, "op": 19511, "op_and": 19512, "op_band": 19513, "op_eq": 19514, "op_ge": 19515, "op_glob": 19516, "op_gt": 19517, "op_le": 19518, "op_lt": 19519, "op_ne": 19520, "op_none": 19521, "op_not": 19522, "op_open_paren": 19523, "op_or": 19524, "opcode": 19525, "opdata": 19526, "open": 19527, "open_softirq": 19528, "operand": 19529, "operand1": 19530, "operand2": 19531, "operation": 19532, "operations": 19533, "ops": 19534, "ops_references_rec": 19535, "ops_traces_mod": 19536, "opstack": 19537, "opstack_op": 19538, "opstr": 19539, "opt": 19540, "opt_kgdb_con": 19541, "opt_kgdb_wait": 19542, "opt_nokgdbroundup": 19543, "opt_pre_handler": 19544, "optimize_all_kprobes": 19545, "optimize_delay": 19546, "optimize_kprobe": 19547, "optimized_kprobe": 19548, "optimizing_list": 19549, "optimizing_work": 19550, "optinsn": 19551, "option": 19552, "options": 19553, "opts": 19554, "or": 19555, "or_softirq_pending": 19556, "order": 19557, "ordered_wq_attrs": 19558, "orig": 19559, "orig_address": 19560, "orig_bm": 19561, "orig_cred": 19562, "orig_end": 19563, "orig_fn": 19564, "orig_p": 19565, "orig_page": 19566, "orig_prog": 19567, "orig_ret_vaddr": 19568, "orig_sig": 19569, "orig_src_load": 19570, "orig_tai": 19571, "original": 19572, "orphan_donelist": 19573, "orphan_donetail": 19574, "orphan_lock": 19575, "orphan_nxtlist": 19576, "orphan_nxttail": 19577, "orphans_remove": 19578, "orphans_remove_sched": 19579, "orphans_remove_work": 19580, "oset": 19581, "osid": 19582, "osq": 19583, "osq_lock": 19584, "osq_lock_init": 19585, "osq_unlock": 19586, "osrelease": 19587, "oss": 19588, "ostype": 19589, "other": 19590, "other_branch": 19591, "other_hash": 19592, "oublock": 19593, "out": 19594, "out_again": 19595, "out_all_pinned": 19596, "out_alloc": 19597, "out_balanced": 19598, "out_bdput": 19599, "out_bug": 19600, "out_cancel_attach": 19601, "out_cancel_ref": 19602, "out_clean": 19603, "out_cleanup": 19604, "out_deactivate": 19605, "out_dec": 19606, "out_destroy": 19607, "out_disable": 19608, "out_enable": 19609, "out_eoi": 19610, "out_err": 19611, "out_err_free": 19612, "out_fail": 19613, "out_finish": 19614, "out_free": 19615, "out_free_ca": 19616, "out_free_cgrp": 19617, "out_free_control_pages": 19618, "out_free_cpus_allowed": 19619, "out_free_cpuusage": 19620, "out_free_desc": 19621, "out_free_digest": 19622, "out_free_id": 19623, "out_free_image": 19624, "out_free_map": 19625, "out_free_new_mask": 19626, "out_free_post_load_bufs": 19627, "out_free_sha_regions": 19628, "out_free_tfm": 19629, "out_ipc": 19630, "out_irq": 19631, "out_iter_end": 19632, "out_kfree_skb": 19633, "out_kill": 19634, "out_locked": 19635, "out_mask": 19636, "out_mput": 19637, "out_net": 19638, "out_no_start": 19639, "out_nocheck": 19640, "out_notify": 19641, "out_ns": 19642, "out_null": 19643, "out_of_line_wait_on_atomic_t": 19644, "out_of_line_wait_on_bit": 19645, "out_of_line_wait_on_bit_lock": 19646, "out_of_line_wait_on_bit_timeout": 19647, "out_one_pinned": 19648, "out_pid": 19649, "out_put": 19650, "out_put_task": 19651, "out_put_task_struct": 19652, "out_putname": 19653, "out_reg": 19654, "out_release": 19655, "out_release_tset": 19656, "out_replace": 19657, "out_reset": 19658, "out_restore": 19659, "out_save": 19660, "out_set": 19661, "out_set_class_cache": 19662, "out_thread": 19663, "out_unlock": 19664, "out_unlock_bdev": 19665, "out_unlock_cgroup": 19666, "out_unlock_set": 19667, "out_unlocked": 19668, "out_unreg": 19669, "out_unreg_holders": 19670, "out_unreg_param": 19671, "out_uts": 19672, "out_va_end": 19673, "outgoingcpu": 19674, "output": 19675, "output_event": 19676, "output_printk": 19677, "outsparse": 19678, "ovalue": 19679, "over": 19680, "overcommit_kbytes_handler": 19681, "overcommit_ratio_handler": 19682, "overflow": 19683, "overflow_count": 19684, "overflow_projid": 19685, "overflowgid": 19686, "overflowuid": 19687, "overhead": 19688, "overload": 19689, "overloaded": 19690, "override": 19691, "override_architecture": 19692, "override_creds": 19693, "override_release": 19694, "override_rlimit": 19695, "overrun": 19696, "overrun_detected": 19697, "overruns": 19698, "overwrite": 19699, "overwrite_flag": 19700, "owatch": 19701, "owner": 19702, "owner_cpu": 19703, "owner_entry": 19704, "ownername": 19705, "owners": 19706, "p": 19707, "p1": 19708, "p2": 19709, "p64": 19710, "p_event": 19711, "p_list": 19712, "p_ns": 19713, "p_rq": 19714, "pacct": 19715, "pacct_struct": 19716, "pack_threadid": 19717, "padata": 19718, "padata_add_cpu": 19719, "padata_alloc": 19720, "padata_alloc_pd": 19721, "padata_alloc_possible": 19722, "padata_attr_ro": 19723, "padata_attr_rw": 19724, "padata_attr_type": 19725, "padata_cpu_callback": 19726, "padata_cpu_hash": 19727, "padata_cpu_parallel": 19728, "padata_cpu_serial": 19729, "padata_default_attrs": 19730, "padata_do_parallel": 19731, "padata_do_serial": 19732, "padata_flush_queues": 19733, "padata_free": 19734, "padata_free_pd": 19735, "padata_get_next": 19736, "padata_index_to_cpu": 19737, "padata_init": 19738, "padata_init_pqueues": 19739, "padata_init_squeues": 19740, "padata_instance": 19741, "padata_invalid": 19742, "padata_list": 19743, "padata_parallel_queue": 19744, "padata_parallel_worker": 19745, "padata_priv": 19746, "padata_register_cpumask_notifier": 19747, "padata_remove_cpu": 19748, "padata_reorder": 19749, "padata_reorder_timer": 19750, "padata_replace": 19751, "padata_reset": 19752, "padata_serial_queue": 19753, "padata_serial_worker": 19754, "padata_set_cpumask": 19755, "padata_set_cpumasks": 19756, "padata_setup_cpumasks": 19757, "padata_start": 19758, "padata_stop": 19759, "padata_sysfs_entry": 19760, "padata_sysfs_ops": 19761, "padata_sysfs_release": 19762, "padata_sysfs_show": 19763, "padata_sysfs_store": 19764, "padata_unregister_cpumask_notifier": 19765, "padata_validate_cpumask": 19766, "page": 19767, "page_add_new_anon_rmap": 19768, "page_address": 19769, "page_cache_release": 19770, "page_cache_shift": 19771, "page_check_address": 19772, "page_cluster": 19773, "page_cpupid_xchg_last": 19774, "page_entries": 19775, "page_is_guard": 19776, "page_is_ram": 19777, "page_kernel": 19778, "page_key_alloc": 19779, "page_key_free": 19780, "page_key_write": 19781, "page_mapped": 19782, "page_mask": 19783, "page_mkwrite": 19784, "page_off": 19785, "page_order": 19786, "page_remove_rmap": 19787, "page_shift": 19788, "page_size": 19789, "page_table_lock": 19790, "page_to_pfn": 19791, "page_zone": 19792, "pageanon": 19793, "pagebusy": 19794, "pageerror": 19795, "pagefault_disable": 19796, "pagefault_enable": 19797, "pagehighmem": 19798, "pager": 19799, "pagereserved": 19800, "pages": 19801, "pages32": 19802, "pages_for_io": 19803, "pages_highmem": 19804, "pageslab": 19805, "pageuptodate": 19806, "panic": 19807, "panic_blink": 19808, "panic_blink_spd": 19809, "panic_block": 19810, "panic_lock": 19811, "panic_notifier_list": 19812, "panic_on_io_nmi": 19813, "panic_on_oops": 19814, "panic_on_unrecovered_nmi": 19815, "panic_on_warn": 19816, "panic_smp_self_stop": 19817, "panic_timeout": 19818, "panic_timer_step": 19819, "par": 19820, "parallel": 19821, "parallel_cpumask": 19822, "parallel_cpumask_attr": 19823, "parallel_data": 19824, "parallel_mask": 19825, "parallel_work": 19826, "param": 19827, "param_array": 19828, "param_array_free": 19829, "param_array_get": 19830, "param_array_ops": 19831, "param_array_set": 19832, "param_attr_show": 19833, "param_attr_store": 19834, "param_attribute": 19835, "param_check_unsafe": 19836, "param_free_charp": 19837, "param_get_": 19838, "param_get_bool": 19839, "param_get_charp": 19840, "param_get_int": 19841, "param_get_invbool": 19842, "param_get_string": 19843, "param_lock": 19844, "param_max_stack": 19845, "param_ops_": 19846, "param_ops_bint": 19847, "param_ops_bool": 19848, "param_ops_charp": 19849, "param_ops_invbool": 19850, "param_ops_string": 19851, "param_set_": 19852, "param_set_bint": 19853, "param_set_bool": 19854, "param_set_charp": 19855, "param_set_copystring": 19856, "param_set_invbool": 19857, "param_sysfs_builtin": 19858, "param_sysfs_init": 19859, "parameqn": 19860, "params": 19861, "paravirt_steal_clock": 19862, "paravirt_steal_enabled": 19863, "paravirt_steal_rq_enabled": 19864, "parent": 19865, "parent_b": 19866, "parent_ca": 19867, "parent_cs": 19868, "parent_css": 19869, "parent_ctx": 19870, "parent_data": 19871, "parent_entity": 19872, "parent_event": 19873, "parent_exec_id": 19874, "parent_freezer": 19875, "parent_gen": 19876, "parent_ip": 19877, "parent_irq": 19878, "parent_kn": 19879, "parent_len": 19880, "parent_map": 19881, "parent_ns": 19882, "parent_path": 19883, "parent_pid_ns": 19884, "parent_quota": 19885, "parent_tidptr": 19886, "parentlen": 19887, "parg": 19888, "park": 19889, "parked": 19890, "parse": 19891, "parse_args": 19892, "parse_cgroupfs_options": 19893, "parse_crashkernel_mem": 19894, "parse_crashkernel_simple": 19895, "parse_crashkernel_suffix": 19896, "parse_error": 19897, "parse_grep": 19898, "parse_init": 19899, "parse_one": 19900, "parse_operand": 19901, "parse_probe_arg": 19902, "parse_probe_vars": 19903, "parse_rcu_nocb_poll": 19904, "parser": 19905, "part": 19906, "part_devt": 19907, "partial_group": 19908, "partition_sched_domains": 19909, "partno": 19910, "pass_exception": 19911, "passed_quiesce": 19912, "passing": 19913, "patch": 19914, "path": 19915, "path1": 19916, "path2": 19917, "path_equal": 19918, "path_is_under": 19919, "path_max": 19920, "path_put": 19921, "pathbuf": 19922, "pathlen": 19923, "pathname": 19924, "pattern": 19925, "paul": 19926, "pause": 19927, "pause_graph_tracing": 19928, "pause_on_oops": 19929, "pause_on_oops_flag": 19930, "pause_on_oops_lock": 19931, "payload": 19932, "pb": 19933, "pbe": 19934, "pbes_per_linked_page": 19935, "pbuf": 19936, "pc": 19937, "pc_clock_adjtime": 19938, "pc_clock_getres": 19939, "pc_clock_gettime": 19940, "pc_clock_settime": 19941, "pc_timer_create": 19942, "pc_timer_delete": 19943, "pc_timer_gettime": 19944, "pc_timer_settime": 19945, "pcache": 19946, "pci_any_id": 19947, "pci_dev": 19948, "pci_dev_driver": 19949, "pci_dev_put": 19950, "pci_driver": 19951, "pci_get_device": 19952, "pci_msi_mask_irq": 19953, "pci_msi_unmask_irq": 19954, "pci_region_flag_mask": 19955, "pcount": 19956, "pcpu": 19957, "pcpu_list": 19958, "pcpumask": 19959, "pcpusec": 19960, "pcred": 19961, "pcs": 19962, "pd": 19963, "pd_list": 19964, "pd_new": 19965, "pd_old": 19966, "pdata": 19967, "pde_data": 19968, "pdeath_signal": 19969, "pdev": 19970, "pdflush_proc_obsolete": 19971, "pdu": 19972, "pdu_buf": 19973, "pdu_data": 19974, "pdu_len": 19975, "pdu_start": 19976, "pe": 19977, "peek_stack": 19978, "pend": 19979, "pending": 19980, "pending_disable": 19981, "pending_kill": 19982, "pending_list": 19983, "pending_mask": 19984, "pending_only": 19985, "pending_updates": 19986, "pending_wakeup": 19987, "pentry": 19988, "pep": 19989, "per": 19990, "per_cpu": 19991, "per_cpu_ptr": 19992, "per_cpu_ref": 19993, "per_cpu_show": 19994, "per_linux": 19995, "per_linux32": 19996, "per_rcu_node_period": 19997, "percent": 19998, "percent_a": 19999, "percent_b": 20000, "percpu": 20001, "percpu_dev_id": 20002, "percpu_dir": 20003, "percpu_down_read": 20004, "percpu_down_write": 20005, "percpu_enabled": 20006, "percpu_free_rwsem": 20007, "percpu_modalloc": 20008, "percpu_modcopy": 20009, "percpu_modfree": 20010, "percpu_pagelist_fraction": 20011, "percpu_pagelist_fraction_sysctl_handler": 20012, "percpu_ref": 20013, "percpu_ref_exit": 20014, "percpu_ref_init": 20015, "percpu_ref_kill": 20016, "percpu_ref_kill_and_confirm": 20017, "percpu_ref_tryget_live": 20018, "percpu_rw_semaphore": 20019, "percpu_size": 20020, "percpu_up_read": 20021, "percpu_up_write": 20022, "perf": 20023, "perf_adjust_freq_unthr_context": 20024, "perf_adjust_period": 20025, "perf_attach_task": 20026, "perf_attach_task_data": 20027, "perf_aux_flag_overwrite": 20028, "perf_aux_flag_truncated": 20029, "perf_aux_gfp": 20030, "perf_aux_output_begin": 20031, "perf_aux_output_end": 20032, "perf_aux_output_skip": 20033, "perf_aux_size": 20034, "perf_branch_entry": 20035, "perf_calculate_period": 20036, "perf_callchain": 20037, "perf_callchain_entry": 20038, "perf_callchain_kernel": 20039, "perf_callchain_store": 20040, "perf_callchain_user": 20041, "perf_cgroup_defer_enabled": 20042, "perf_cgroup_events": 20043, "perf_cgroup_match": 20044, "perf_cgroup_sched_in": 20045, "perf_cgroup_sched_out": 20046, "perf_cgroup_set_shadow_time": 20047, "perf_cgroup_set_timestamp": 20048, "perf_clock": 20049, "perf_comm_event": 20050, "perf_compat_ioctl": 20051, "perf_context_kernel": 20052, "perf_context_user": 20053, "perf_count_hw_cpu_cycles": 20054, "perf_count_sw_cpu_migrations": 20055, "perf_cpu_context": 20056, "perf_cpu_hrtimer_restart": 20057, "perf_cpu_time_max_percent_handler": 20058, "perf_ctx_lock": 20059, "perf_ctx_unlock": 20060, "perf_data_size": 20061, "perf_detach_cgroup": 20062, "perf_duration_warn": 20063, "perf_duration_work": 20064, "perf_ef_reload": 20065, "perf_ef_start": 20066, "perf_ef_update": 20067, "perf_event": 20068, "perf_event__output_id_sample": 20069, "perf_event_attr": 20070, "perf_event_aux": 20071, "perf_event_aux_ctx": 20072, "perf_event_aux_event": 20073, "perf_event_aux_output_cb": 20074, "perf_event_can_stop_tick": 20075, "perf_event_clock": 20076, "perf_event_comm": 20077, "perf_event_comm_event": 20078, "perf_event_comm_match": 20079, "perf_event_comm_output": 20080, "perf_event_context": 20081, "perf_event_context_sched_in": 20082, "perf_event_context_sched_out": 20083, "perf_event_count": 20084, "perf_event_create_kernel_counter": 20085, "perf_event_ctx_activate": 20086, "perf_event_ctx_deactivate": 20087, "perf_event_ctx_lock": 20088, "perf_event_ctx_lock_nested": 20089, "perf_event_ctx_unlock": 20090, "perf_event_ctxp": 20091, "perf_event_disable": 20092, "perf_event_enable": 20093, "perf_event_enable_on_exec": 20094, "perf_event_exec": 20095, "perf_event_for_each": 20096, "perf_event_for_each_child": 20097, "perf_event_fork": 20098, "perf_event_free_bpf_prog": 20099, "perf_event_free_filter": 20100, "perf_event_free_task": 20101, "perf_event_header": 20102, "perf_event_header__init_id": 20103, "perf_event_index": 20104, "perf_event_init_task": 20105, "perf_event_init_userpage": 20106, "perf_event_ioc_disable": 20107, "perf_event_ioc_enable": 20108, "perf_event_ioc_id": 20109, "perf_event_ioc_period": 20110, "perf_event_ioc_refresh": 20111, "perf_event_ioc_reset": 20112, "perf_event_ioc_set_bpf": 20113, "perf_event_ioc_set_filter": 20114, "perf_event_ioc_set_output": 20115, "perf_event_list": 20116, "perf_event_max_sample_rate": 20117, "perf_event_mmap_event": 20118, "perf_event_mmap_match": 20119, "perf_event_mmap_output": 20120, "perf_event_mmap_page": 20121, "perf_event_mutex": 20122, "perf_event_output": 20123, "perf_event_period": 20124, "perf_event_pid": 20125, "perf_event_read": 20126, "perf_event_read_event": 20127, "perf_event_read_group": 20128, "perf_event_read_one": 20129, "perf_event_read_value": 20130, "perf_event_refresh": 20131, "perf_event_release_kernel": 20132, "perf_event_sched_in": 20133, "perf_event_set_bpf_prog": 20134, "perf_event_set_filter": 20135, "perf_event_set_output": 20136, "perf_event_state_active": 20137, "perf_event_state_error": 20138, "perf_event_state_exit": 20139, "perf_event_state_inactive": 20140, "perf_event_state_off": 20141, "perf_event_sync_stat": 20142, "perf_event_task": 20143, "perf_event_task_disable": 20144, "perf_event_task_match": 20145, "perf_event_task_output": 20146, "perf_event_task_sched_in": 20147, "perf_event_task_sched_out": 20148, "perf_event_task_tick": 20149, "perf_event_tid": 20150, "perf_event_time": 20151, "perf_event_update_userpage": 20152, "perf_event_wakeup": 20153, "perf_events": 20154, "perf_fasync": 20155, "perf_fetch_caller_regs": 20156, "perf_fget_light": 20157, "perf_flag_all": 20158, "perf_flag_fd_cloexec": 20159, "perf_flag_fd_no_group": 20160, "perf_flag_fd_output": 20161, "perf_flag_pid_cgroup": 20162, "perf_fops": 20163, "perf_format_group": 20164, "perf_format_id": 20165, "perf_format_total_time_enabled": 20166, "perf_format_total_time_running": 20167, "perf_format_total_times": 20168, "perf_ftrace_event_register": 20169, "perf_ftrace_function_call": 20170, "perf_ftrace_function_disable": 20171, "perf_ftrace_function_enable": 20172, "perf_ftrace_function_register": 20173, "perf_ftrace_function_unregister": 20174, "perf_get_aux": 20175, "perf_get_regs_user": 20176, "perf_group_attach": 20177, "perf_group_detach": 20178, "perf_group_software": 20179, "perf_guest_cbs": 20180, "perf_guest_info_callbacks": 20181, "perf_hes_stopped": 20182, "perf_install_in_context": 20183, "perf_instruction_pointer": 20184, "perf_ioc_flag_group": 20185, "perf_ioctl": 20186, "perf_lock_task_context": 20187, "perf_log_itrace_start": 20188, "perf_log_throttle": 20189, "perf_max_trace_size": 20190, "perf_misc_flags": 20191, "perf_mmap": 20192, "perf_mmap_alloc_page": 20193, "perf_mmap_close": 20194, "perf_mmap_event": 20195, "perf_mmap_fault": 20196, "perf_mmap_free_page": 20197, "perf_mmap_open": 20198, "perf_mmap_to_page": 20199, "perf_mmap_unmark_page": 20200, "perf_mmap_vmops": 20201, "perf_nr_contexts": 20202, "perf_output_begin": 20203, "perf_output_copy": 20204, "perf_output_end": 20205, "perf_output_get_handle": 20206, "perf_output_handle": 20207, "perf_output_put": 20208, "perf_output_put_handle": 20209, "perf_output_read": 20210, "perf_output_read_group": 20211, "perf_output_read_one": 20212, "perf_output_sample": 20213, "perf_output_sample_regs": 20214, "perf_output_sample_ustack": 20215, "perf_output_skip": 20216, "perf_output_wakeup": 20217, "perf_paranoid_cpu": 20218, "perf_paranoid_tracepoint_raw": 20219, "perf_pending_event": 20220, "perf_perm": 20221, "perf_pmu_cap_aux_no_sg": 20222, "perf_pmu_cap_aux_sw_doublebuf": 20223, "perf_pmu_cap_exclusive": 20224, "perf_pmu_disable": 20225, "perf_pmu_enable": 20226, "perf_pmu_sched_task": 20227, "perf_poll": 20228, "perf_prepare_sample": 20229, "perf_probe": 20230, "perf_proc_update_handler": 20231, "perf_read": 20232, "perf_read_event": 20233, "perf_read_hw": 20234, "perf_record_comm": 20235, "perf_record_exit": 20236, "perf_record_fork": 20237, "perf_record_misc_comm_exec": 20238, "perf_record_mmap2": 20239, "perf_record_read": 20240, "perf_record_sample": 20241, "perf_refcount": 20242, "perf_reg_abi": 20243, "perf_reg_value": 20244, "perf_register_guest_info_callbacks": 20245, "perf_regs": 20246, "perf_release": 20247, "perf_remove_from_context": 20248, "perf_remove_from_owner": 20249, "perf_rotate_context": 20250, "perf_sample_addr": 20251, "perf_sample_allowed_ns": 20252, "perf_sample_branch_hv": 20253, "perf_sample_branch_kernel": 20254, "perf_sample_branch_perm_plm": 20255, "perf_sample_branch_stack": 20256, "perf_sample_callchain": 20257, "perf_sample_cpu": 20258, "perf_sample_data": 20259, "perf_sample_data_src": 20260, "perf_sample_event_took": 20261, "perf_sample_id": 20262, "perf_sample_identifier": 20263, "perf_sample_ip": 20264, "perf_sample_period": 20265, "perf_sample_period_ns": 20266, "perf_sample_raw": 20267, "perf_sample_read": 20268, "perf_sample_regs_abi_none": 20269, "perf_sample_regs_intr": 20270, "perf_sample_regs_user": 20271, "perf_sample_stack_user": 20272, "perf_sample_stream_id": 20273, "perf_sample_tid": 20274, "perf_sample_time": 20275, "perf_sample_transaction": 20276, "perf_sample_ustack_size": 20277, "perf_sample_weight": 20278, "perf_sched_cb_dec": 20279, "perf_sched_cb_inc": 20280, "perf_sched_cb_usages": 20281, "perf_sched_events": 20282, "perf_set_shadow_time": 20283, "perf_sw_event_sched": 20284, "perf_swevent_get_recursion_context": 20285, "perf_swevent_put_recursion_context": 20286, "perf_syscall_enter": 20287, "perf_syscall_exit": 20288, "perf_sysenter_disable": 20289, "perf_sysenter_enable": 20290, "perf_sysexit_disable": 20291, "perf_sysexit_enable": 20292, "perf_task_event": 20293, "perf_throttled_count": 20294, "perf_throttled_seq": 20295, "perf_trace_add": 20296, "perf_trace_buf": 20297, "perf_trace_buf_prepare": 20298, "perf_trace_buf_submit": 20299, "perf_trace_del": 20300, "perf_trace_destroy": 20301, "perf_trace_event_close": 20302, "perf_trace_event_init": 20303, "perf_trace_event_open": 20304, "perf_trace_event_perm": 20305, "perf_trace_event_reg": 20306, "perf_trace_event_unreg": 20307, "perf_trace_init": 20308, "perf_trace_t": 20309, "perf_type_hardware": 20310, "perf_unregister_guest_info_callbacks": 20311, "perf_user_stack_pointer": 20312, "perf_ustack_task_size": 20313, "perf_workqueue_init": 20314, "perf_wq": 20315, "perform": 20316, "period": 20317, "period_left": 20318, "period_slot": 20319, "period_timer": 20320, "periodic": 20321, "periods": 20322, "perm": 20323, "perm_gid": 20324, "perm_mode": 20325, "perm_tr": 20326, "perm_tr_len": 20327, "perm_uid": 20328, "permitted": 20329, "pernet_operations": 20330, "persistent_clock_exists": 20331, "persistent_clock_is_local": 20332, "persistent_keyring_register": 20333, "persistent_keyring_register_sem": 20334, "personality": 20335, "pf": 20336, "pf_dumpcore": 20337, "pf_exiting": 20338, "pf_forknoexec": 20339, "pf_freezer_skip": 20340, "pf_frozen": 20341, "pf_kthread": 20342, "pf_mce_early": 20343, "pf_mce_process": 20344, "pf_memalloc": 20345, "pf_mutex_tester": 20346, "pf_no_setaffinity": 20347, "pf_nofreeze": 20348, "pf_nproc_exceeded": 20349, "pf_signaled": 20350, "pf_superpriv": 20351, "pf_suspend_task": 20352, "pf_used_async": 20353, "pf_vcpu": 20354, "pf_wq_worker": 20355, "pflags": 20356, "pfn": 20357, "pfn_down": 20358, "pfn_is_nosave": 20359, "pfn_to_page": 20360, "pfn_up": 20361, "pfn_valid": 20362, "pg": 20363, "pg_any": 20364, "pg_offp": 20365, "pg_safe": 20366, "pg_unsafe_clear": 20367, "pg_unsafe_keep": 20368, "pgd": 20369, "pgd_alloc": 20370, "pgd_free": 20371, "pgid": 20372, "pgoff": 20373, "pgoff_t": 20374, "pgrp": 20375, "phase1_result": 20376, "phase_ts": 20377, "phys": 20378, "phys_to_virt": 20379, "pi": 20380, "pi_blocked_on": 20381, "pi_lock": 20382, "pi_state_cache": 20383, "pi_state_list": 20384, "pi_task": 20385, "pi_tree_entry": 20386, "pi_waiters": 20387, "pi_waiters_leftmost": 20388, "pick_highest_pushable_task": 20389, "pick_next_entity": 20390, "pick_next_pushable_task": 20391, "pick_next_rt_entity": 20392, "pick_next_task": 20393, "pick_next_task_fair": 20394, "pick_next_task_idle": 20395, "pick_next_task_rt": 20396, "pick_rt_task": 20397, "pid": 20398, "pid1": 20399, "pid2": 20400, "pid_alive": 20401, "pid_before": 20402, "pid_cache": 20403, "pid_cachep": 20404, "pid_caches_lh": 20405, "pid_caches_mutex": 20406, "pid_chain": 20407, "pid_count": 20408, "pid_fry": 20409, "pid_hash": 20410, "pid_hashfn": 20411, "pid_link": 20412, "pid_max": 20413, "pid_max_default": 20414, "pid_max_limit": 20415, "pid_max_max": 20416, "pid_max_min": 20417, "pid_namespace": 20418, "pid_namespaces_init": 20419, "pid_nr": 20420, "pid_nr_ns": 20421, "pid_ns": 20422, "pid_ns_cachep": 20423, "pid_ns_ctl_handler": 20424, "pid_ns_ctl_table": 20425, "pid_ns_for_children": 20426, "pid_ns_prepare_proc": 20427, "pid_ns_release_proc": 20428, "pid_t": 20429, "pid_task": 20430, "pid_type": 20431, "pid_vnr": 20432, "pidhash_init": 20433, "pidhash_shift": 20434, "pidhash_size": 20435, "pidlist_allocate": 20436, "pidlist_array_load": 20437, "pidlist_free": 20438, "pidlist_mutex": 20439, "pidlist_too_large": 20440, "pidlist_uniq": 20441, "pidlists": 20442, "pidmap": 20443, "pidmap_entries": 20444, "pidmap_lock": 20445, "pidns_get": 20446, "pidns_hash_adding": 20447, "pidns_install": 20448, "pidns_operations": 20449, "pidns_put": 20450, "pids": 20451, "pids_per_cpu_default": 20452, "pids_per_cpu_min": 20453, "pidtype_max": 20454, "pidtype_pgid": 20455, "pidtype_pid": 20456, "pidtype_sid": 20457, "pin": 20458, "pin_count": 20459, "pin_insert": 20460, "pin_kill": 20461, "pin_remove": 20462, "pinned": 20463, "pinned_groups": 20464, "pinned_sb": 20465, "pinned_vm": 20466, "pinst": 20467, "pinst_has_cpu": 20468, "pip": 20469, "pipe": 20470, "pipe_close": 20471, "pipe_count": 20472, "pipe_inode_info": 20473, "pipe_max_size": 20474, "pipe_min_size": 20475, "pipe_open": 20476, "pipe_proc_fn": 20477, "pipesummary": 20478, "pk": 20479, "pkey_algo_rsa": 20480, "pkey_hash__last": 20481, "pkey_id_x509": 20482, "pks": 20483, "pkt": 20484, "place_entity": 20485, "platform": 20486, "platform_begin": 20487, "platform_device": 20488, "platform_driver": 20489, "platform_end": 20490, "platform_finish": 20491, "platform_hibernation_ops": 20492, "platform_leave": 20493, "platform_mode": 20494, "platform_pre_restore": 20495, "platform_pre_snapshot": 20496, "platform_recover": 20497, "platform_restore_cleanup": 20498, "platform_support": 20499, "please": 20500, "plen": 20501, "plist_add": 20502, "plist_del": 20503, "plist_first": 20504, "plist_first_entry": 20505, "plist_for_each": 20506, "plist_for_each_entry": 20507, "plist_head": 20508, "plist_head_empty": 20509, "plist_head_init": 20510, "plist_last": 20511, "plist_node": 20512, "plist_node_init": 20513, "plug": 20514, "plug_thread": 20515, "pm": 20516, "pm_async": 20517, "pm_async_enabled": 20518, "pm_async_show": 20519, "pm_async_store": 20520, "pm_autosleep_init": 20521, "pm_autosleep_lock": 20522, "pm_autosleep_set_state": 20523, "pm_autosleep_state": 20524, "pm_autosleep_unlock": 20525, "pm_chain_head": 20526, "pm_event_hibernate": 20527, "pm_freezing": 20528, "pm_get_wakeup_count": 20529, "pm_hibernation_prepare": 20530, "pm_labels": 20531, "pm_message_t": 20532, "pm_mutex": 20533, "pm_nosig_freezing": 20534, "pm_notifier": 20535, "pm_notifier_call_chain": 20536, "pm_post_hibernation": 20537, "pm_post_restore": 20538, "pm_post_suspend": 20539, "pm_power_off": 20540, "pm_power_off_prepare": 20541, "pm_prepare_console": 20542, "pm_print_active_wakeup_sources": 20543, "pm_print_times": 20544, "pm_print_times_enabled": 20545, "pm_print_times_init": 20546, "pm_qos_add_notifier": 20547, "pm_qos_add_req": 20548, "pm_qos_add_request": 20549, "pm_qos_array": 20550, "pm_qos_class": 20551, "pm_qos_constraints": 20552, "pm_qos_cpu_dma_lat_default_value": 20553, "pm_qos_cpu_dma_latency": 20554, "pm_qos_dbg_open": 20555, "pm_qos_dbg_show_requests": 20556, "pm_qos_debug_fops": 20557, "pm_qos_default_value": 20558, "pm_qos_flags": 20559, "pm_qos_flags_remove_req": 20560, "pm_qos_flags_request": 20561, "pm_qos_get_value": 20562, "pm_qos_lock": 20563, "pm_qos_max": 20564, "pm_qos_memory_bandwidth_default_value": 20565, "pm_qos_min": 20566, "pm_qos_network_lat_default_value": 20567, "pm_qos_network_throughput_default_value": 20568, "pm_qos_num_classes": 20569, "pm_qos_object": 20570, "pm_qos_power_fops": 20571, "pm_qos_power_init": 20572, "pm_qos_power_miscdev": 20573, "pm_qos_power_open": 20574, "pm_qos_power_read": 20575, "pm_qos_power_release": 20576, "pm_qos_power_write": 20577, "pm_qos_read_value": 20578, "pm_qos_remove_notifier": 20579, "pm_qos_remove_req": 20580, "pm_qos_remove_request": 20581, "pm_qos_req_action": 20582, "pm_qos_request": 20583, "pm_qos_request_active": 20584, "pm_qos_set_value": 20585, "pm_qos_sum": 20586, "pm_qos_update_flags": 20587, "pm_qos_update_req": 20588, "pm_qos_update_request": 20589, "pm_qos_update_request_timeout": 20590, "pm_qos_update_target": 20591, "pm_qos_work_fn": 20592, "pm_restore_console": 20593, "pm_restore_gfp_mask": 20594, "pm_restore_prepare": 20595, "pm_restrict_gfp_mask": 20596, "pm_save_wakeup_count": 20597, "pm_show_wakelocks": 20598, "pm_states": 20599, "pm_suspend": 20600, "pm_suspend_max": 20601, "pm_suspend_mem": 20602, "pm_suspend_min": 20603, "pm_suspend_on": 20604, "pm_suspend_prepare": 20605, "pm_suspend_standby": 20606, "pm_sysrq_init": 20607, "pm_system_wakeup": 20608, "pm_test_level": 20609, "pm_test_show": 20610, "pm_tests": 20611, "pm_wake_lock": 20612, "pm_wake_unlock": 20613, "pm_wakep_autosleep_enabled": 20614, "pm_wakeup_clear": 20615, "pm_wakeup_pending": 20616, "pmask": 20617, "pmd_huge_pte": 20618, "pmod": 20619, "pmsg_freeze": 20620, "pmsg_hibernate": 20621, "pmsg_quiesce": 20622, "pmsg_recover": 20623, "pmsg_restore": 20624, "pmsg_thaw": 20625, "pmtmr": 20626, "pmu": 20627, "pmu_cpu_context": 20628, "pmus": 20629, "pmus_lock": 20630, "pmus_srcu": 20631, "pn": 20632, "pnr": 20633, "pnt": 20634, "pointer": 20635, "points": 20636, "poison_end": 20637, "poison_free": 20638, "poison_inuse": 20639, "pol": 20640, "policy": 20641, "poll": 20642, "poll_spurious_irq_interval": 20643, "poll_spurious_irq_timer": 20644, "poll_spurious_irqs": 20645, "poll_table": 20646, "poll_wait": 20647, "pollhup": 20648, "pollin": 20649, "pollrdnorm": 20650, "pool": 20651, "pool_disassociated": 20652, "pool_id": 20653, "pool_ids": 20654, "pool_mayday_timeout": 20655, "pool_workqueue": 20656, "pop_stack": 20657, "populate_kprobe_blacklist": 20658, "populate_seccomp_data": 20659, "populated": 20660, "populated_cnt": 20661, "populated_kn": 20662, "port": 20663, "portid": 20664, "pos": 20665, "pos_css": 20666, "pos_f": 20667, "posix_clock": 20668, "posix_clock_compat_ioctl": 20669, "posix_clock_desc": 20670, "posix_clock_fasync": 20671, "posix_clock_file_operations": 20672, "posix_clock_ioctl": 20673, "posix_clock_mmap": 20674, "posix_clock_open": 20675, "posix_clock_poll": 20676, "posix_clock_read": 20677, "posix_clock_realtime_adj": 20678, "posix_clock_realtime_get": 20679, "posix_clock_realtime_set": 20680, "posix_clock_register": 20681, "posix_clock_release": 20682, "posix_clock_unregister": 20683, "posix_clocks": 20684, "posix_cpu_timers_can_stop_tick": 20685, "posix_cpu_timers_init": 20686, "posix_cpu_timers_init_group": 20687, "posix_get_boottime": 20688, "posix_get_coarse_res": 20689, "posix_get_monotonic_coarse": 20690, "posix_get_monotonic_raw": 20691, "posix_get_realtime_coarse": 20692, "posix_get_tai": 20693, "posix_ktime_get_ts": 20694, "posix_timer_add": 20695, "posix_timer_by_id": 20696, "posix_timer_event": 20697, "posix_timer_fn": 20698, "posix_timer_id": 20699, "posix_timers": 20700, "posix_timers_cache": 20701, "posix_timers_hashtable": 20702, "posix_timers_register_clock": 20703, "possible": 20704, "post_exception": 20705, "post_handler": 20706, "post_relocation": 20707, "post_schedule": 20708, "post_schedule_rt": 20709, "post_trigger": 20710, "postfix": 20711, "postfix_append_op": 20712, "postfix_append_operand": 20713, "postfix_clear": 20714, "postfix_elt": 20715, "posth_val": 20716, "postponed": 20717, "power": 20718, "power_attr": 20719, "power_down": 20720, "power_kobj": 20721, "power_up": 20722, "poweroff_cmd": 20723, "poweroff_cmd_path_len": 20724, "poweroff_work": 20725, "powner": 20726, "pp": 20727, "ppc_rtas": 20728, "ppid": 20729, "ppm_scale": 20730, "ppm_scale_inv": 20731, "ppm_scale_inv_shift": 20732, "ppos": 20733, "ppp": 20734, "pprev": 20735, "pps_calcnt": 20736, "pps_clear": 20737, "pps_dec_valid": 20738, "pps_errcnt": 20739, "pps_fbase": 20740, "pps_fill_timex": 20741, "pps_freq": 20742, "pps_inc_freq_interval": 20743, "pps_intcnt": 20744, "pps_intcount": 20745, "pps_intmin": 20746, "pps_jitcnt": 20747, "pps_jitter": 20748, "pps_maxwander": 20749, "pps_normalize_ts": 20750, "pps_normtime": 20751, "pps_phase_filter_add": 20752, "pps_phase_filter_get": 20753, "pps_reset_freq_interval": 20754, "pps_set_freq": 20755, "pps_shift": 20756, "pps_stabil": 20757, "pps_stbcnt": 20758, "pps_tf": 20759, "pps_valid": 20760, "ppsfreq": 20761, "pqf": 20762, "pqueue": 20763, "pr_alert": 20764, "pr_cont": 20765, "pr_cont_cgroup_name": 20766, "pr_cont_pool_info": 20767, "pr_cont_work": 20768, "pr_crit": 20769, "pr_crit_once": 20770, "pr_debug": 20771, "pr_devel": 20772, "pr_emerg": 20773, "pr_err": 20774, "pr_fmt": 20775, "pr_get_child_subreaper": 20776, "pr_get_dumpable": 20777, "pr_get_fp_mode": 20778, "pr_get_fpemu": 20779, "pr_get_fpexc": 20780, "pr_get_no_new_privs": 20781, "pr_get_pdeathsig": 20782, "pr_get_thp_disable": 20783, "pr_get_tid_address": 20784, "pr_get_timing": 20785, "pr_get_unalign": 20786, "pr_info": 20787, "pr_info_once": 20788, "pr_mce_kill": 20789, "pr_mce_kill_clear": 20790, "pr_mce_kill_default": 20791, "pr_mce_kill_early": 20792, "pr_mce_kill_get": 20793, "pr_mce_kill_late": 20794, "pr_mce_kill_set": 20795, "pr_mpx_disable_management": 20796, "pr_mpx_enable_management": 20797, "pr_notice": 20798, "pr_notice_once": 20799, "pr_pid": 20800, "pr_reg": 20801, "pr_set_child_subreaper": 20802, "pr_set_dumpable": 20803, "pr_set_fp_mode": 20804, "pr_set_fpemu": 20805, "pr_set_fpexc": 20806, "pr_set_mm": 20807, "pr_set_mm_arg_end": 20808, "pr_set_mm_arg_start": 20809, "pr_set_mm_auxv": 20810, "pr_set_mm_brk": 20811, "pr_set_mm_end_code": 20812, "pr_set_mm_end_data": 20813, "pr_set_mm_env_end": 20814, "pr_set_mm_env_start": 20815, "pr_set_mm_exe_file": 20816, "pr_set_mm_map": 20817, "pr_set_mm_map_size": 20818, "pr_set_mm_start_brk": 20819, "pr_set_mm_start_code": 20820, "pr_set_mm_start_data": 20821, "pr_set_mm_start_stack": 20822, "pr_set_name": 20823, "pr_set_no_new_privs": 20824, "pr_set_pdeathsig": 20825, "pr_set_thp_disable": 20826, "pr_set_timerslack": 20827, "pr_set_timing": 20828, "pr_set_unalign": 20829, "pr_timing_statistical": 20830, "pr_warn": 20831, "pr_warn_once": 20832, "pr_warning": 20833, "prandom_u32": 20834, "prctl": 20835, "prctl_get_tid_address": 20836, "prctl_map": 20837, "prctl_mm_map": 20838, "prctl_set_mm": 20839, "prctl_set_mm_exe_file": 20840, "prctl_set_mm_map": 20841, "prctl_set_seccomp": 20842, "pre_exception": 20843, "pre_handler": 20844, "pre_handler_kretprobe": 20845, "pre_restore": 20846, "pre_snapshot": 20847, "pre_ssout": 20848, "pre_unpark": 20849, "preallocate_image_highmem": 20850, "preallocate_image_memory": 20851, "preallocated_names": 20852, "prec": 20853, "precedence": 20854, "precision": 20855, "pred": 20856, "pred_stack": 20857, "preds": 20858, "preempt": 20859, "preempt_active": 20860, "preempt_check_resched": 20861, "preempt_count": 20862, "preempt_count_add": 20863, "preempt_count_dec": 20864, "preempt_count_equals": 20865, "preempt_count_set": 20866, "preempt_count_sub": 20867, "preempt_disable": 20868, "preempt_disable_ip": 20869, "preempt_disable_notrace": 20870, "preempt_enable": 20871, "preempt_enable_no_resched": 20872, "preempt_enable_notrace": 20873, "preempt_fold_need_resched": 20874, "preempt_mask": 20875, "preempt_notifier": 20876, "preempt_notifier_register": 20877, "preempt_notifier_unregister": 20878, "preempt_notifiers": 20879, "preempt_offset": 20880, "preempt_schedule": 20881, "preempt_schedule_common": 20882, "preempt_schedule_context": 20883, "preempt_schedule_irq": 20884, "preempt_set_need_resched": 20885, "preempt_timestamp": 20886, "preempt_trace": 20887, "preemptible": 20888, "preemption": 20889, "preemptirqsoff_tracer": 20890, "preemptirqsoff_tracer_init": 20891, "preemptoff_tracer": 20892, "preemptoff_tracer_init": 20893, "pref_node_fork": 20894, "prefer_sibling": 20895, "preferred_console": 20896, "preferred_group_nid": 20897, "prefetch": 20898, "prefix": 20899, "prefix_len": 20900, "prefix_max": 20901, "prefix_name": 20902, "preflow_handler": 20903, "preh_val": 20904, "preloaded_csets": 20905, "prelock_base": 20906, "prepare": 20907, "prepare_arch_switch": 20908, "prepare_creds": 20909, "prepare_highmem_image": 20910, "prepare_image": 20911, "prepare_kernel_cred": 20912, "prepare_kprobe": 20913, "prepare_lock_switch": 20914, "prepare_optimized_kprobe": 20915, "prepare_reply": 20916, "prepare_signal": 20917, "prepare_task_switch": 20918, "prepare_to_wait": 20919, "prepare_to_wait_event": 20920, "prepare_to_wait_exclusive": 20921, "prepare_uprobe": 20922, "prepare_uretprobe": 20923, "prepared": 20924, "preparing": 20925, "present": 20926, "preserve_context": 20927, "preset_lpj": 20928, "prev": 20929, "prev_bit": 20930, "prev_chain_key": 20931, "prev_class": 20932, "prev_count": 20933, "prev_cpu": 20934, "prev_cputime": 20935, "prev_ctx": 20936, "prev_eff_load": 20937, "prev_hlock": 20938, "prev_insn_idx": 20939, "prev_irq_time": 20940, "prev_jiffy": 20941, "prev_len": 20942, "prev_lower_first": 20943, "prev_lower_last": 20944, "prev_mm": 20945, "prev_nr": 20946, "prev_offset": 20947, "prev_overruns": 20948, "prev_padding": 20949, "prev_page": 20950, "prev_pid": 20951, "prev_prio": 20952, "prev_state": 20953, "prev_steal_time": 20954, "prev_steal_time_rq": 20955, "prev_subbuf": 20956, "prev_sum_exec_runtime": 20957, "prev_time": 20958, "prev_upper_first": 20959, "prev_upper_last": 20960, "prev_value": 20961, "primary": 20962, "primary_event_id": 20963, "print": 20964, "print_base": 20965, "print_bpf_insn": 20966, "print_cfs_group_stats": 20967, "print_cfs_rq": 20968, "print_cfs_stats": 20969, "print_circular_bug": 20970, "print_counts": 20971, "print_cpu": 20972, "print_cpu_stall": 20973, "print_cpu_stall_fast_no_hz": 20974, "print_cpu_stall_info": 20975, "print_cpu_stall_info_begin": 20976, "print_cpu_stall_info_end": 20977, "print_deadlock_bug": 20978, "print_deadlock_scenario": 20979, "print_disabled": 20980, "print_dl_rq": 20981, "print_dl_stats": 20982, "print_entry": 20983, "print_event_filter": 20984, "print_fatal_signal": 20985, "print_fatal_signals": 20986, "print_fmt": 20987, "print_fn_t": 20988, "print_freed_lock_bug": 20989, "print_graph_abs_time": 20990, "print_graph_comment": 20991, "print_graph_cpu": 20992, "print_graph_duration": 20993, "print_graph_entry": 20994, "print_graph_entry_leaf": 20995, "print_graph_entry_nested": 20996, "print_graph_function": 20997, "print_graph_function_event": 20998, "print_graph_function_flags": 20999, "print_graph_headers": 21000, "print_graph_headers_flags": 21001, "print_graph_irq": 21002, "print_graph_lat_fmt": 21003, "print_graph_proc": 21004, "print_graph_prologue": 21005, "print_graph_return": 21006, "print_header": 21007, "print_held_locks_bug": 21008, "print_ip_ins": 21009, "print_ip_sym": 21010, "print_irq_desc": 21011, "print_irq_lock_scenario": 21012, "print_irqtrace_events": 21013, "print_kernel_ident": 21014, "print_kprobe_event": 21015, "print_kretprobe_event": 21016, "print_lat_header": 21017, "print_line": 21018, "print_line_t": 21019, "print_lock": 21020, "print_lock_contention_bug": 21021, "print_lock_name": 21022, "print_lock_nested_lock_not_held": 21023, "print_lockdep_cache": 21024, "print_lockdep_off": 21025, "print_max": 21026, "print_max_stack": 21027, "print_modules": 21028, "print_name": 21029, "print_name_offset": 21030, "print_once": 21031, "print_one_line": 21032, "print_one_rcu_data": 21033, "print_one_rcu_node_boost": 21034, "print_one_rcu_pending": 21035, "print_one_rcu_state": 21036, "print_oops_end_marker": 21037, "print_other_cpu_stall": 21038, "print_out": 21039, "print_owner": 21040, "print_rq": 21041, "print_rt_rq": 21042, "print_rt_stats": 21043, "print_shortest_lock_dependencies": 21044, "print_stack_trace": 21045, "print_subsystem_event_filter": 21046, "print_symbol": 21047, "print_syscall_exit": 21048, "print_tainted": 21049, "print_task": 21050, "print_tickdevice": 21051, "print_trace_header": 21052, "print_trace_line": 21053, "print_type_": 21054, "print_type_fmt_name": 21055, "print_type_format_": 21056, "print_type_func_name": 21057, "print_type_func_t": 21058, "print_unload_info": 21059, "print_unlock_imbalance_bug": 21060, "print_uprobe_event": 21061, "print_usage_bug": 21062, "print_usage_bug_scenario": 21063, "print_verifier_state": 21064, "print_worker_info": 21065, "printed": 21066, "printed_something": 21067, "printk": 21068, "printk_deferred": 21069, "printk_deferred_once": 21070, "printk_delay_msec": 21071, "printk_lock": 21072, "printk_log": 21073, "printk_once": 21074, "printk_ratelimit": 21075, "printk_ratelimit_state": 21076, "printk_ratelimited": 21077, "printk_task": 21078, "prints": 21079, "prio": 21080, "prio_changed": 21081, "prio_changed_fair": 21082, "prio_changed_idle": 21083, "prio_changed_rt": 21084, "prio_high": 21085, "prio_low": 21086, "prio_pgrp": 21087, "prio_process": 21088, "prio_to_nice": 21089, "prio_to_weight": 21090, "prio_to_wmult": 21091, "prio_user": 21092, "priority": 21093, "priv": 21094, "private": 21095, "private_data": 21096, "prlimit64": 21097, "probe": 21098, "probe_arg": 21099, "probe_event_disable": 21100, "probe_event_enable": 21101, "probe_irq_mask": 21102, "probe_irq_off": 21103, "probe_irq_on": 21104, "probe_kernel_address": 21105, "probe_kernel_read": 21106, "probe_kernel_write": 21107, "probe_kthread_data": 21108, "probe_likely_condition": 21109, "probe_list": 21110, "probe_lock": 21111, "probe_remove_event_call": 21112, "probe_sched_switch": 21113, "probe_sched_wakeup": 21114, "probe_wakeup": 21115, "probe_wakeup_migrate_task": 21116, "probe_wakeup_sched_switch": 21117, "probed_mod": 21118, "probes_open": 21119, "probes_profile_seq_show": 21120, "probes_seq_next": 21121, "probes_seq_op": 21122, "probes_seq_show": 21123, "probes_seq_start": 21124, "probes_seq_stop": 21125, "probes_write": 21126, "probing_active": 21127, "proc": 21128, "proc_caches_init": 21129, "proc_cap_handler": 21130, "proc_cgroupstats_operations": 21131, "proc_cgroupstats_show": 21132, "proc_cleanup_work": 21133, "proc_clear_tty": 21134, "proc_coredump_connector": 21135, "proc_cpuset_show": 21136, "proc_create": 21137, "proc_create_data": 21138, "proc_dir_entry": 21139, "proc_dma_show": 21140, "proc_do_cad_pid": 21141, "proc_dohung_task_timeout_secs": 21142, "proc_dointvec": 21143, "proc_dointvec_jiffies": 21144, "proc_dointvec_minmax": 21145, "proc_dointvec_minmax_coredump": 21146, "proc_dointvec_minmax_sysadmin": 21147, "proc_dointvec_ms_jiffies": 21148, "proc_dointvec_userhz_jiffies": 21149, "proc_dostring": 21150, "proc_dostring_coredump": 21151, "proc_doulongvec_minmax": 21152, "proc_doulongvec_ms_jiffies_minmax": 21153, "proc_event_gid": 21154, "proc_event_uid": 21155, "proc_execdomains_init": 21156, "proc_fork_connector": 21157, "proc_get_long": 21158, "proc_gid_map_write": 21159, "proc_gid_seq_operations": 21160, "proc_handler": 21161, "proc_id_connector": 21162, "proc_iomem_operations": 21163, "proc_ioports_operations": 21164, "proc_kprobes_optimization_handler": 21165, "proc_lock_stat_operations": 21166, "proc_lockdep_chains_operations": 21167, "proc_lockdep_operations": 21168, "proc_lockdep_stats_operations": 21169, "proc_mkdir": 21170, "proc_mnt": 21171, "proc_modules_init": 21172, "proc_modules_operations": 21173, "proc_nmi_watchdog": 21174, "proc_nr_dentry": 21175, "proc_nr_files": 21176, "proc_nr_inodes": 21177, "proc_ns_fget": 21178, "proc_ns_operations": 21179, "proc_pid_init_ino": 21180, "proc_profile_operations": 21181, "proc_projid_map_write": 21182, "proc_projid_seq_operations": 21183, "proc_ptrace_connector": 21184, "proc_put_char": 21185, "proc_put_long": 21186, "proc_remove": 21187, "proc_sched_autogroup_set_nice": 21188, "proc_sched_autogroup_show_task": 21189, "proc_sched_set_task": 21190, "proc_sched_show_task": 21191, "proc_set_size": 21192, "proc_setgroups_show": 21193, "proc_setgroups_write": 21194, "proc_sid_connector": 21195, "proc_skip_char": 21196, "proc_skip_spaces": 21197, "proc_soft_watchdog": 21198, "proc_taint": 21199, "proc_uid_map_write": 21200, "proc_uid_seq_operations": 21201, "proc_user_init_ino": 21202, "proc_watchdog": 21203, "proc_watchdog_common": 21204, "proc_watchdog_thresh": 21205, "proc_watchdog_update": 21206, "proc_work": 21207, "proc_wspace_sep": 21208, "process": 21209, "process_adj_status": 21210, "process_adjtimex_modes": 21211, "process_bpf_exit": 21212, "process_counts": 21213, "process_keyring": 21214, "process_one_work": 21215, "process_ops": 21216, "process_scheduled_works": 21217, "process_srcu": 21218, "process_timeout": 21219, "processed": 21220, "processes": 21221, "procname": 21222, "procs": 21223, "proctitle": 21224, "producer": 21225, "producer_fifo": 21226, "producer_nice": 21227, "production": 21228, "prof_buffer": 21229, "prof_cpu_mask": 21230, "prof_cpu_mask_proc_fops": 21231, "prof_cpu_mask_proc_open": 21232, "prof_cpu_mask_proc_show": 21233, "prof_cpu_mask_proc_write": 21234, "prof_exp": 21235, "prof_len": 21236, "prof_on": 21237, "prof_shift": 21238, "profile_cpu_callback": 21239, "profile_discard_flip_buffers": 21240, "profile_event_register": 21241, "profile_event_unregister": 21242, "profile_flip_buffers": 21243, "profile_flip_mutex": 21244, "profile_graph_entry": 21245, "profile_graph_return": 21246, "profile_grpshift": 21247, "profile_grpsz": 21248, "profile_handoff_task": 21249, "profile_hit": 21250, "profile_hits": 21251, "profile_init": 21252, "profile_munmap": 21253, "profile_nop": 21254, "profile_open": 21255, "profile_pc": 21256, "profile_records_size": 21257, "profile_seq_op": 21258, "profile_setup": 21259, "profile_task_exit": 21260, "profile_tick": 21261, "profile_type": 21262, "profiles_per_page": 21263, "profiling": 21264, "profiling_show": 21265, "profiling_store": 21266, "prog": 21267, "prog_fd": 21268, "prog_type": 21269, "proglen": 21270, "projid": 21271, "projid_m_show": 21272, "projid_m_start": 21273, "projid_map": 21274, "projid_t": 21275, "prompt": 21276, "prot": 21277, "prot_exec": 21278, "prot_read": 21279, "prot_write": 21280, "prove_locking": 21281, "proxy_owner": 21282, "prstatus": 21283, "prune_list": 21284, "prune_one": 21285, "prune_thread": 21286, "prune_tree_thread": 21287, "prv": 21288, "ps": 21289, "pse": 21290, "pse_depth": 21291, "psig": 21292, "pskb_expand_head": 21293, "psp": 21294, "pstart": 21295, "pt_exitkill": 21296, "pt_ptrace_cap": 21297, "pt_ptraced": 21298, "pt_regs": 21299, "pt_regs_to_gdb_regs": 21300, "pt_seized": 21301, "pte_pfn": 21302, "pte_t": 21303, "pte_unmap_unlock": 21304, "ptep": 21305, "ptep_clear_flush_notify": 21306, "ptid": 21307, "ptl": 21308, "ptr": 21309, "ptr_err": 21310, "ptr_to_compat": 21311, "ptr_to_ctx": 21312, "ptr_to_map_value": 21313, "ptr_to_map_value_or_null": 21314, "ptr_to_stack": 21315, "ptrace": 21316, "ptrace_attach": 21317, "ptrace_check_attach": 21318, "ptrace_cont": 21319, "ptrace_detach": 21320, "ptrace_disable": 21321, "ptrace_do_notify": 21322, "ptrace_entry": 21323, "ptrace_event": 21324, "ptrace_event_clone": 21325, "ptrace_event_enabled": 21326, "ptrace_event_fork": 21327, "ptrace_event_pid": 21328, "ptrace_event_seccomp": 21329, "ptrace_event_stop": 21330, "ptrace_event_vfork": 21331, "ptrace_event_vfork_done": 21332, "ptrace_freeze_traced": 21333, "ptrace_get_task_struct": 21334, "ptrace_geteventmsg": 21335, "ptrace_getfdpic": 21336, "ptrace_getfdpic_exec": 21337, "ptrace_getfdpic_interp": 21338, "ptrace_getregset": 21339, "ptrace_getsiginfo": 21340, "ptrace_getsigmask": 21341, "ptrace_has_cap": 21342, "ptrace_init_task": 21343, "ptrace_interrupt": 21344, "ptrace_kill": 21345, "ptrace_listen": 21346, "ptrace_may_access": 21347, "ptrace_message": 21348, "ptrace_mode_attach": 21349, "ptrace_mode_noaudit": 21350, "ptrace_mode_read": 21351, "ptrace_notify": 21352, "ptrace_o_mask": 21353, "ptrace_oldsetoptions": 21354, "ptrace_peek_siginfo": 21355, "ptrace_peekdata": 21356, "ptrace_peeksiginfo": 21357, "ptrace_peeksiginfo_args": 21358, "ptrace_peeksiginfo_shared": 21359, "ptrace_peektext": 21360, "ptrace_pokedata": 21361, "ptrace_poketext": 21362, "ptrace_readdata": 21363, "ptrace_regset": 21364, "ptrace_reparented": 21365, "ptrace_request": 21366, "ptrace_resume": 21367, "ptrace_seize": 21368, "ptrace_setoptions": 21369, "ptrace_setregset": 21370, "ptrace_setsiginfo": 21371, "ptrace_setsigmask": 21372, "ptrace_signal": 21373, "ptrace_signal_deliver": 21374, "ptrace_signal_wake_up": 21375, "ptrace_singleblock": 21376, "ptrace_singlestep": 21377, "ptrace_stop": 21378, "ptrace_syscall": 21379, "ptrace_sysemu": 21380, "ptrace_sysemu_singlestep": 21381, "ptrace_traceme": 21382, "ptrace_trap_notify": 21383, "ptrace_unfreeze_traced": 21384, "ptrace_writedata": 21385, "ptraced": 21386, "pts_norm": 21387, "pty_max": 21388, "pty_nr": 21389, "ptype": 21390, "public_key_signature": 21391, "pull_rt_task": 21392, "pulled_task": 21393, "punc": 21394, "purgatory_buf": 21395, "purgatory_info": 21396, "purgatory_load_addr": 21397, "push_cpu": 21398, "push_flags": 21399, "push_insn": 21400, "push_irq_work_func": 21401, "push_lock": 21402, "push_rt_task": 21403, "push_rt_tasks": 21404, "push_stack": 21405, "push_work": 21406, "pushable_dl_tasks": 21407, "pushable_dl_tasks_leftmost": 21408, "pushable_dl_tasks_root": 21409, "pushable_tasks": 21410, "put": 21411, "put_addr": 21412, "put_callchain_buffers": 21413, "put_callchain_entry": 21414, "put_clock_desc": 21415, "put_compat_itimerspec": 21416, "put_compat_itimerval": 21417, "put_compat_rusage": 21418, "put_cpu": 21419, "put_cpu_ptr": 21420, "put_cpu_var": 21421, "put_cred": 21422, "put_cred_rcu": 21423, "put_cset": 21424, "put_css_set": 21425, "put_css_set_locked": 21426, "put_ctx": 21427, "put_event": 21428, "put_files_struct": 21429, "put_filesystem": 21430, "put_group_info": 21431, "put_io_context": 21432, "put_ipc_ns": 21433, "put_lock_stats": 21434, "put_mnt_ns": 21435, "put_net": 21436, "put_numa_group": 21437, "put_online_cpus": 21438, "put_packet": 21439, "put_page": 21440, "put_pid": 21441, "put_pid_ns": 21442, "put_posix_clock": 21443, "put_prev_entity": 21444, "put_prev_task": 21445, "put_prev_task_fair": 21446, "put_prev_task_fake": 21447, "put_prev_task_idle": 21448, "put_prev_task_rt": 21449, "put_pwq": 21450, "put_pwq_unlocked": 21451, "put_recursion_context": 21452, "put_seccomp_filter": 21453, "put_signal_struct": 21454, "put_system": 21455, "put_task_struct": 21456, "put_tree": 21457, "put_tree_ref": 21458, "put_unbound_pool": 21459, "put_uprobe": 21460, "put_user": 21461, "put_user_ns": 21462, "put_uts_ns": 21463, "putname": 21464, "pvclock_gtod_chain": 21465, "pvclock_gtod_register_notifier": 21466, "pvclock_gtod_unregister_notifier": 21467, "pwd": 21468, "pwq": 21469, "pwq_activate_delayed_work": 21470, "pwq_activate_first_delayed": 21471, "pwq_adjust_max_active": 21472, "pwq_cache": 21473, "pwq_dec_nr_in_flight": 21474, "pwq_tbl": 21475, "pwq_unbound_release_workfn": 21476, "pwqs": 21477, "pwqs_node": 21478, "pwrsw_enabled": 21479, "q": 21480, "qbytes": 21481, "qcfs_rq": 21482, "qhimark": 21483, "ql": 21484, "qlen": 21485, "qlen_last_fqs_check": 21486, "qlen_lazy": 21487, "qll": 21488, "qlowmark": 21489, "qos": 21490, "qrwlock": 21491, "qs_pending": 21492, "qsmask": 21493, "qsmaskinit": 21494, "qsmaskinitnext": 21495, "qsupported": 21496, "queue": 21497, "queue_delayed_work": 21498, "queue_delayed_work_on": 21499, "queue_kthread_work": 21500, "queue_lock": 21501, "queue_read_lock_slowpath": 21502, "queue_stop_cpus_work": 21503, "queue_up_suspend_work": 21504, "queue_work": 21505, "queue_work_on": 21506, "queue_write_lock_slowpath": 21507, "queued": 21508, "quick": 21509, "quota": 21510, "quota_us": 21511, "quote": 21512, "quoted": 21513, "r": 21514, "r1": 21515, "r2": 21516, "r3": 21517, "r4": 21518, "r5": 21519, "r_next": 21520, "r_open": 21521, "r_show": 21522, "r_start": 21523, "r_stop": 21524, "radix": 21525, "radix_tree": 21526, "radix_tree_delete": 21527, "radix_tree_insert": 21528, "radix_tree_lookup": 21529, "rahead": 21530, "raise_softirq": 21531, "raise_softirq_irqoff": 21532, "raised": 21533, "raised_list": 21534, "ram_res": 21535, "ran": 21536, "rand": 21537, "rand1": 21538, "rand_lock": 21539, "random_boot_id": 21540, "random_entropy_count": 21541, "random_poolsize": 21542, "random_read_thresh": 21543, "random_table": 21544, "random_uuid": 21545, "random_write_thresh": 21546, "randomize_va_space": 21547, "range": 21548, "rate_limit": 21549, "ratelimit": 21550, "rating": 21551, "ratio": 21552, "raw": 21553, "raw_": 21554, "raw_cpu_inc": 21555, "raw_cpu_ptr": 21556, "raw_cpu_read": 21557, "raw_cpu_write": 21558, "raw_data": 21559, "raw_init": 21560, "raw_interval": 21561, "raw_local_irq_restore": 21562, "raw_local_irq_save": 21563, "raw_lock": 21564, "raw_notifier_call_chain": 21565, "raw_notifier_chain_register": 21566, "raw_notifier_chain_unregister": 21567, "raw_notifier_head": 21568, "raw_nsecs": 21569, "raw_read_can_lock": 21570, "raw_read_seqcount": 21571, "raw_rq": 21572, "raw_secs": 21573, "raw_smp_processor_id": 21574, "raw_spin_is_locked": 21575, "raw_spin_lock": 21576, "raw_spin_lock_init": 21577, "raw_spin_lock_irq": 21578, "raw_spin_lock_irqsave": 21579, "raw_spin_lock_nested": 21580, "raw_spin_trylock": 21581, "raw_spin_trylock_irqsave": 21582, "raw_spin_unlock": 21583, "raw_spin_unlock_irq": 21584, "raw_spin_unlock_irqrestore": 21585, "raw_spin_unlock_wait": 21586, "raw_spinlock": 21587, "raw_spinlock_t": 21588, "raw_time": 21589, "raw_ts": 21590, "raw_write_can_lock": 21591, "raw_write_seqcount_latch": 21592, "rb": 21593, "rb_add_time_stamp": 21594, "rb_advance_iter": 21595, "rb_advance_reader": 21596, "rb_alignment": 21597, "rb_alloc": 21598, "rb_alloc_aux": 21599, "rb_alloc_aux_page": 21600, "rb_allocate_cpu_buffer": 21601, "rb_allocate_pages": 21602, "rb_arch_alignment": 21603, "rb_buffer_off": 21604, "rb_buffer_peek": 21605, "rb_buffers_disabled_bit": 21606, "rb_buffers_on": 21607, "rb_buffers_on_bit": 21608, "rb_calculate_event_length": 21609, "rb_check_bpage": 21610, "rb_check_list": 21611, "rb_check_pages": 21612, "rb_clear_node": 21613, "rb_commit": 21614, "rb_commit_index": 21615, "rb_cpu_notify": 21616, "rb_data": 21617, "rb_decrement_entry": 21618, "rb_empty_node": 21619, "rb_empty_root": 21620, "rb_end_commit": 21621, "rb_entry": 21622, "rb_erase": 21623, "rb_event_data": 21624, "rb_event_data_length": 21625, "rb_event_discard": 21626, "rb_event_index": 21627, "rb_event_is_commit": 21628, "rb_event_length": 21629, "rb_event_set_padding": 21630, "rb_event_ts_length": 21631, "rb_evnt_hdr_size": 21632, "rb_evnt_min_size": 21633, "rb_first": 21634, "rb_fl_overwrite": 21635, "rb_flag_mask": 21636, "rb_force_8byte_alignment": 21637, "rb_free": 21638, "rb_free_aux": 21639, "rb_free_aux_page": 21640, "rb_free_cpu_buffer": 21641, "rb_free_rcu": 21642, "rb_free_work": 21643, "rb_get_reader_page": 21644, "rb_hammer": 21645, "rb_hammer_test": 21646, "rb_handle_head_page": 21647, "rb_has_aux": 21648, "rb_head_page_activate": 21649, "rb_head_page_deactivate": 21650, "rb_head_page_replace": 21651, "rb_head_page_set": 21652, "rb_head_page_set_head": 21653, "rb_head_page_set_normal": 21654, "rb_head_page_set_update": 21655, "rb_inc_iter": 21656, "rb_inc_page": 21657, "rb_init_page": 21658, "rb_insert_color": 21659, "rb_insert_pages": 21660, "rb_ipi": 21661, "rb_irq_work": 21662, "rb_is_head_page": 21663, "rb_is_reader_page": 21664, "rb_item": 21665, "rb_iter_head_event": 21666, "rb_iter_peek": 21667, "rb_iter_reset": 21668, "rb_last": 21669, "rb_left": 21670, "rb_leftmost": 21671, "rb_len_time_extend": 21672, "rb_len_time_stamp": 21673, "rb_link": 21674, "rb_link_node": 21675, "rb_list_head": 21676, "rb_list_head_clear": 21677, "rb_lost_events": 21678, "rb_max_small_data": 21679, "rb_missed_events": 21680, "rb_missed_stored": 21681, "rb_move_tail": 21682, "rb_next": 21683, "rb_node": 21684, "rb_null_event": 21685, "rb_num_of_entries": 21686, "rb_ok_to_lock": 21687, "rb_page": 21688, "rb_page_commit": 21689, "rb_page_entries": 21690, "rb_page_head": 21691, "rb_page_moved": 21692, "rb_page_normal": 21693, "rb_page_size": 21694, "rb_page_update": 21695, "rb_page_write": 21696, "rb_parent": 21697, "rb_per_cpu_empty": 21698, "rb_prev": 21699, "rb_reader_event": 21700, "rb_remove_pages": 21701, "rb_reserve_next_event": 21702, "rb_reset_cpu": 21703, "rb_reset_reader_page": 21704, "rb_reset_tail": 21705, "rb_right": 21706, "rb_root": 21707, "rb_set_commit_to_write": 21708, "rb_set_head_page": 21709, "rb_set_list_to_head": 21710, "rb_start_commit": 21711, "rb_string": 21712, "rb_tail_page_update": 21713, "rb_test": 21714, "rb_test_buffer_size": 21715, "rb_test_data": 21716, "rb_test_started": 21717, "rb_threads": 21718, "rb_time_stamp": 21719, "rb_try_to_discard": 21720, "rb_update_event": 21721, "rb_update_iter_read_stamp": 21722, "rb_update_pages": 21723, "rb_update_read_stamp": 21724, "rb_update_write_stamp": 21725, "rb_wake_up_waiters": 21726, "rb_wakeups": 21727, "rb_warn_on": 21728, "rb_write_intcnt": 21729, "rb_write_mask": 21730, "rb_write_something": 21731, "rbi": 21732, "rbip": 21733, "rbtree_postorder_for_each_entry_safe": 21734, "rbwork": 21735, "rc": 21736, "rchan": 21737, "rchan_buf": 21738, "rchan_callbacks": 21739, "rchar": 21740, "rcp": 21741, "rcrmp": 21742, "rctx": 21743, "rctxp": 21744, "rcu": 21745, "rcu_accelerate_cbs": 21746, "rcu_access_pointer": 21747, "rcu_adopt_orphan_cbs": 21748, "rcu_advance_cbs": 21749, "rcu_all_qs": 21750, "rcu_assign_pointer": 21751, "rcu_barrier": 21752, "rcu_barrier_bh": 21753, "rcu_barrier_callback": 21754, "rcu_barrier_func": 21755, "rcu_barrier_sched": 21756, "rcu_barrier_tasks": 21757, "rcu_batch": 21758, "rcu_batch_dequeue": 21759, "rcu_batch_empty": 21760, "rcu_batch_init": 21761, "rcu_batch_move": 21762, "rcu_batch_queue": 21763, "rcu_batches": 21764, "rcu_batches_completed": 21765, "rcu_batches_completed_bh": 21766, "rcu_batches_completed_sched": 21767, "rcu_batches_started": 21768, "rcu_batches_started_bh": 21769, "rcu_batches_started_sched": 21770, "rcu_bh": 21771, "rcu_bh_ctrlblk": 21772, "rcu_bh_data": 21773, "rcu_bh_flavor": 21774, "rcu_bh_force_quiescent_state": 21775, "rcu_bh_lock_key": 21776, "rcu_bh_lock_map": 21777, "rcu_bh_ops": 21778, "rcu_bh_qs": 21779, "rcu_bh_state": 21780, "rcu_bh_torture_deferred_free": 21781, "rcu_bh_torture_read_lock": 21782, "rcu_bh_torture_read_unlock": 21783, "rcu_bind_gp_kthread": 21784, "rcu_blocked_node": 21785, "rcu_blocking_is_gp": 21786, "rcu_boost": 21787, "rcu_boost_delay_jiffies": 21788, "rcu_boost_inflight": 21789, "rcu_boost_kthread": 21790, "rcu_boost_kthread_setaffinity": 21791, "rcu_boot_init_nocb_percpu_data": 21792, "rcu_boot_init_percpu_data": 21793, "rcu_bootup_announce": 21794, "rcu_bootup_announce_oddness": 21795, "rcu_busted_ops": 21796, "rcu_busted_torture_deferred_free": 21797, "rcu_callback_key": 21798, "rcu_callback_map": 21799, "rcu_can_boost": 21800, "rcu_capacity": 21801, "rcu_cbs_completed": 21802, "rcu_check_callbacks": 21803, "rcu_check_gp_kthread_starvation": 21804, "rcu_check_quiescent_state": 21805, "rcu_cleanup_after_idle": 21806, "rcu_cleanup_dead_cpu": 21807, "rcu_cleanup_dead_rnp": 21808, "rcu_cleanup_dying_cpu": 21809, "rcu_cleanup_dying_idle_cpu": 21810, "rcu_copy_process": 21811, "rcu_cpu_has_callbacks": 21812, "rcu_cpu_has_work": 21813, "rcu_cpu_kthread": 21814, "rcu_cpu_kthread_cpu": 21815, "rcu_cpu_kthread_loops": 21816, "rcu_cpu_kthread_park": 21817, "rcu_cpu_kthread_setup": 21818, "rcu_cpu_kthread_should_run": 21819, "rcu_cpu_kthread_status": 21820, "rcu_cpu_kthread_task": 21821, "rcu_cpu_notify": 21822, "rcu_cpu_stall_reset": 21823, "rcu_cpu_stall_suppress": 21824, "rcu_cpu_stall_timeout": 21825, "rcu_cpu_thread_spec": 21826, "rcu_ctrlblk": 21827, "rcu_data": 21828, "rcu_delta_jiffies": 21829, "rcu_dereference": 21830, "rcu_dereference_bh": 21831, "rcu_dereference_check": 21832, "rcu_dereference_check_sched_domain": 21833, "rcu_dereference_raw": 21834, "rcu_dereference_raw_notrace": 21835, "rcu_dereference_sched": 21836, "rcu_do_batch": 21837, "rcu_done_tail": 21838, "rcu_dump_cpu_stacks": 21839, "rcu_dynticks": 21840, "rcu_dynticks_task_enter": 21841, "rcu_dynticks_task_exit": 21842, "rcu_early_boot_tests": 21843, "rcu_end_inkernel_boot": 21844, "rcu_eqs_enter": 21845, "rcu_eqs_enter_common": 21846, "rcu_eqs_exit": 21847, "rcu_eqs_exit_common": 21848, "rcu_expedite_gp": 21849, "rcu_expedited": 21850, "rcu_expedited_nesting": 21851, "rcu_fanout_1": 21852, "rcu_fanout_2": 21853, "rcu_fanout_3": 21854, "rcu_fanout_4": 21855, "rcu_fanout_leaf": 21856, "rcu_flavor": 21857, "rcu_for_each_leaf_node": 21858, "rcu_for_each_node_breadth_first": 21859, "rcu_for_each_nonleaf_node_breadth_first": 21860, "rcu_force_qs": 21861, "rcu_force_quiescent_state": 21862, "rcu_fqs_class": 21863, "rcu_free_pool": 21864, "rcu_free_pwq": 21865, "rcu_free_wq": 21866, "rcu_future_gp_cleanup": 21867, "rcu_future_needs_gp": 21868, "rcu_get_root": 21869, "rcu_gp_cleanup": 21870, "rcu_gp_flag_fqs": 21871, "rcu_gp_flag_init": 21872, "rcu_gp_fqs": 21873, "rcu_gp_idle": 21874, "rcu_gp_in_progress": 21875, "rcu_gp_init": 21876, "rcu_gp_is_expedited": 21877, "rcu_gp_kthread": 21878, "rcu_gp_kthread_wake": 21879, "rcu_gp_wait_fqs": 21880, "rcu_gp_wait_gps": 21881, "rcu_gp_wait_init": 21882, "rcu_head": 21883, "rcu_idle_count_callbacks_posted": 21884, "rcu_idle_enter": 21885, "rcu_idle_exit": 21886, "rcu_idle_gp_delay": 21887, "rcu_idle_lazy_gp_delay": 21888, "rcu_implicit_dynticks_qs": 21889, "rcu_init": 21890, "rcu_init_geometry": 21891, "rcu_init_levelspread": 21892, "rcu_init_new_rnp": 21893, "rcu_init_nohz": 21894, "rcu_init_one": 21895, "rcu_init_one_nocb": 21896, "rcu_init_percpu_data": 21897, "rcu_init_pointer": 21898, "rcu_initiate_boost": 21899, "rcu_initiate_boost_trace": 21900, "rcu_irq_enter": 21901, "rcu_irq_exit": 21902, "rcu_is_callbacks_kthread": 21903, "rcu_is_cpu_rrupt_from_idle": 21904, "rcu_is_nocb_cpu": 21905, "rcu_is_watching": 21906, "rcu_jiffies_fqs_div": 21907, "rcu_jiffies_till_force_qs": 21908, "rcu_jiffies_till_stall_check": 21909, "rcu_kick_nohz_cpu": 21910, "rcu_kthread_do_work": 21911, "rcu_kthread_max": 21912, "rcu_kthread_offcpu": 21913, "rcu_kthread_running": 21914, "rcu_kthread_waiting": 21915, "rcu_kthread_yielding": 21916, "rcu_leak_callback": 21917, "rcu_lock_acquire": 21918, "rcu_lock_break": 21919, "rcu_lock_key": 21920, "rcu_lock_map": 21921, "rcu_lock_release": 21922, "rcu_lockdep_assert": 21923, "rcu_lockdep_current_cpu_online": 21924, "rcu_momentary_dyntick_idle": 21925, "rcu_needs_cpu": 21926, "rcu_next_node_entry": 21927, "rcu_next_ready_tail": 21928, "rcu_next_size": 21929, "rcu_next_tail": 21930, "rcu_nmi_enter": 21931, "rcu_nmi_exit": 21932, "rcu_no_completed": 21933, "rcu_nocb_adopt_orphan_cbs": 21934, "rcu_nocb_cpu_needs_barrier": 21935, "rcu_nocb_gp_cleanup": 21936, "rcu_nocb_gp_set": 21937, "rcu_nocb_kthread": 21938, "rcu_nocb_leader_stride": 21939, "rcu_nocb_mask": 21940, "rcu_nocb_need_deferred_wakeup": 21941, "rcu_nocb_poll": 21942, "rcu_nocb_q_lengths": 21943, "rcu_nocb_setup": 21944, "rcu_nocb_wait_gp": 21945, "rcu_node": 21946, "rcu_node_boost_fops": 21947, "rcu_node_boost_open": 21948, "rcu_node_class": 21949, "rcu_node_entry": 21950, "rcu_nogp_wake": 21951, "rcu_nogp_wake_force": 21952, "rcu_nogp_wake_not": 21953, "rcu_nohz_full_cpu": 21954, "rcu_nonidle": 21955, "rcu_note_context_switch": 21956, "rcu_note_voluntary_context_switch": 21957, "rcu_num_lvls": 21958, "rcu_num_nodes": 21959, "rcu_oom_callback": 21960, "rcu_oom_nb": 21961, "rcu_oom_notify": 21962, "rcu_oom_notify_cpu": 21963, "rcu_ops": 21964, "rcu_organize_nocb_kthreads": 21965, "rcu_panic": 21966, "rcu_panic_block": 21967, "rcu_pending": 21968, "rcu_pending_fops": 21969, "rcu_pending_op": 21970, "rcu_pending_open": 21971, "rcu_pm_notify": 21972, "rcu_preempt": 21973, "rcu_preempt_blocked_readers_cgp": 21974, "rcu_preempt_boost_start_gp": 21975, "rcu_preempt_check_blocked_tasks": 21976, "rcu_preempt_check_callbacks": 21977, "rcu_preempt_data": 21978, "rcu_preempt_depth": 21979, "rcu_preempt_do_callbacks": 21980, "rcu_preempt_has_tasks": 21981, "rcu_preempt_note_context_switch": 21982, "rcu_preempt_qs": 21983, "rcu_preempt_state": 21984, "rcu_preempted_readers_exp": 21985, "rcu_prepare_cpu": 21986, "rcu_prepare_for_idle": 21987, "rcu_prepare_kthreads": 21988, "rcu_print_detail_task_stall": 21989, "rcu_print_detail_task_stall_rnp": 21990, "rcu_print_task_stall": 21991, "rcu_print_task_stall_begin": 21992, "rcu_print_task_stall_end": 21993, "rcu_process_callbacks": 21994, "rcu_qs_ctr": 21995, "rcu_qs_ctr_snap": 21996, "rcu_qsctr_help": 21997, "rcu_read_delay": 21998, "rcu_read_lock": 21999, "rcu_read_lock_bh": 22000, "rcu_read_lock_bh_held": 22001, "rcu_read_lock_held": 22002, "rcu_read_lock_nesting": 22003, "rcu_read_lock_sched": 22004, "rcu_read_lock_sched_held": 22005, "rcu_read_unlock": 22006, "rcu_read_unlock_bh": 22007, "rcu_read_unlock_sched": 22008, "rcu_read_unlock_special": 22009, "rcu_register_oom_notifier": 22010, "rcu_report_exp_rnp": 22011, "rcu_report_qs_rdp": 22012, "rcu_report_qs_rnp": 22013, "rcu_report_qs_rsp": 22014, "rcu_report_unblock_qs_rnp": 22015, "rcu_rnp_online_cpus": 22016, "rcu_save_dyntick": 22017, "rcu_sched": 22018, "rcu_sched_ctrlblk": 22019, "rcu_sched_data": 22020, "rcu_sched_flavor": 22021, "rcu_sched_force_quiescent_state": 22022, "rcu_sched_lock_key": 22023, "rcu_sched_lock_map": 22024, "rcu_sched_qs": 22025, "rcu_sched_qs_mask": 22026, "rcu_sched_state": 22027, "rcu_sched_torture_deferred_free": 22028, "rcu_scheduler_active": 22029, "rcu_scheduler_fully_active": 22030, "rcu_scheduler_starting": 22031, "rcu_self_test": 22032, "rcu_self_test_bh": 22033, "rcu_self_test_counter": 22034, "rcu_self_test_sched": 22035, "rcu_send_cbs_to_orphanage": 22036, "rcu_signal_init": 22037, "rcu_sleep_check": 22038, "rcu_softirq": 22039, "rcu_spawn_all_nocb_kthreads": 22040, "rcu_spawn_boost_kthreads": 22041, "rcu_spawn_gp_kthread": 22042, "rcu_spawn_nocb_kthreads": 22043, "rcu_spawn_one_boost_kthread": 22044, "rcu_spawn_one_nocb_kthread": 22045, "rcu_spawn_tasks_kthread": 22046, "rcu_special": 22047, "rcu_stall_delay_delta": 22048, "rcu_stall_rat_delay": 22049, "rcu_start_future_gp": 22050, "rcu_start_gp": 22051, "rcu_start_gp_advanced": 22052, "rcu_state": 22053, "rcu_state_initializer": 22054, "rcu_state_name": 22055, "rcu_state_p": 22056, "rcu_struct_flavors": 22057, "rcu_sync_torture_init": 22058, "rcu_synchronize": 22059, "rcu_sys_is_idle": 22060, "rcu_sysidle_cb": 22061, "rcu_sysidle_check_cpu": 22062, "rcu_sysidle_delay": 22063, "rcu_sysidle_enter": 22064, "rcu_sysidle_exit": 22065, "rcu_sysidle_force_exit": 22066, "rcu_sysidle_full": 22067, "rcu_sysidle_full_noted": 22068, "rcu_sysidle_head": 22069, "rcu_sysidle_init_percpu_data": 22070, "rcu_sysidle_long": 22071, "rcu_sysidle_not": 22072, "rcu_sysidle_report": 22073, "rcu_sysidle_report_gp": 22074, "rcu_sysidle_short": 22075, "rcu_sysrq_end": 22076, "rcu_sysrq_start": 22077, "rcu_task_stall_timeout": 22078, "rcu_tasks_cbs_head": 22079, "rcu_tasks_cbs_lock": 22080, "rcu_tasks_cbs_tail": 22081, "rcu_tasks_cbs_wq": 22082, "rcu_tasks_flavor": 22083, "rcu_tasks_holdout": 22084, "rcu_tasks_holdout_list": 22085, "rcu_tasks_holdouts": 22086, "rcu_tasks_idle_cpu": 22087, "rcu_tasks_kthread": 22088, "rcu_tasks_kthread_mutex": 22089, "rcu_tasks_kthread_ptr": 22090, "rcu_tasks_nvcsw": 22091, "rcu_tasks_torture_deferred_free": 22092, "rcu_test_debug_objects": 22093, "rcu_torture": 22094, "rcu_torture_alloc": 22095, "rcu_torture_barrier": 22096, "rcu_torture_barrier_cbf": 22097, "rcu_torture_barrier_cleanup": 22098, "rcu_torture_barrier_init": 22099, "rcu_torture_batch": 22100, "rcu_torture_boost": 22101, "rcu_torture_boost_cb": 22102, "rcu_torture_cb": 22103, "rcu_torture_cbflood": 22104, "rcu_torture_cbflood_cb": 22105, "rcu_torture_cleanup": 22106, "rcu_torture_count": 22107, "rcu_torture_current": 22108, "rcu_torture_current_version": 22109, "rcu_torture_deferred_free": 22110, "rcu_torture_err_cb": 22111, "rcu_torture_fqs": 22112, "rcu_torture_free": 22113, "rcu_torture_freelist": 22114, "rcu_torture_init": 22115, "rcu_torture_leak_cb": 22116, "rcu_torture_lock": 22117, "rcu_torture_ops": 22118, "rcu_torture_pipe_len": 22119, "rcu_torture_pipe_update": 22120, "rcu_torture_pipe_update_one": 22121, "rcu_torture_print_module_parms": 22122, "rcu_torture_read_lock": 22123, "rcu_torture_read_unlock": 22124, "rcu_torture_reader": 22125, "rcu_torture_removed": 22126, "rcu_torture_stall": 22127, "rcu_torture_stall_init": 22128, "rcu_torture_stats": 22129, "rcu_torture_stats_print": 22130, "rcu_torture_timer": 22131, "rcu_torture_wcount": 22132, "rcu_torture_writer": 22133, "rcu_torture_writer_state": 22134, "rcu_tortures": 22135, "rcu_trace": 22136, "rcu_trace_clock_local": 22137, "rcu_trace_sub_qlen": 22138, "rcu_tree_noncore": 22139, "rcu_try_advance_all_cbs": 22140, "rcu_unexpedite_gp": 22141, "rcu_user_enter": 22142, "rcu_user_exit": 22143, "rcu_verify_early_boot_tests": 22144, "rcu_wait": 22145, "rcu_wait_tail": 22146, "rcu_wake_cond": 22147, "rcubarrier_fops": 22148, "rcubarrier_open": 22149, "rcucblist": 22150, "rcudata": 22151, "rcudata_fops": 22152, "rcudata_open": 22153, "rcudate_op": 22154, "rcudir": 22155, "rcuexp_fops": 22156, "rcuexp_open": 22157, "rcugp_fops": 22158, "rcugp_open": 22159, "rcuhead_debug_descr": 22160, "rcuhead_fixup_activate": 22161, "rcuhier_fops": 22162, "rcuhier_open": 22163, "rcutorture_booster_cleanup": 22164, "rcutorture_booster_init": 22165, "rcutorture_cpu_nb": 22166, "rcutorture_fops": 22167, "rcutorture_get_gp_data": 22168, "rcutorture_open": 22169, "rcutorture_record_progress": 22170, "rcutorture_record_test_transition": 22171, "rcutorture_runnable_init": 22172, "rcutorture_tasks_ops": 22173, "rcutorture_testseq": 22174, "rcutorture_trace_dump": 22175, "rcutorture_type": 22176, "rcutorture_vernum": 22177, "rcutorturename": 22178, "rcutree_trace_cleanup": 22179, "rcutree_trace_init": 22180, "rd": 22181, "rda": 22182, "rdev": 22183, "rdp": 22184, "rdp_last": 22185, "rdp_leader": 22186, "rdp_old_leader": 22187, "rdp_prev": 22188, "rdp_spawn": 22189, "rdtp": 22190, "re": 22191, "re_cnt": 22192, "reached": 22193, "read": 22194, "read_boot_clock": 22195, "read_boot_clock64": 22196, "read_bytes": 22197, "read_can_lock": 22198, "read_char": 22199, "read_cred_subscribers": 22200, "read_delay": 22201, "read_done": 22202, "read_event": 22203, "read_events": 22204, "read_format": 22205, "read_holdtime": 22206, "read_lock": 22207, "read_lock_irq": 22208, "read_lock_irqsave": 22209, "read_mapping_page": 22210, "read_once": 22211, "read_page": 22212, "read_pages": 22213, "read_persistent_clock": 22214, "read_persistent_clock64": 22215, "read_profile": 22216, "read_s64": 22217, "read_seqbegin": 22218, "read_seqbegin_or_lock_irqsave": 22219, "read_seqcount_begin": 22220, "read_seqcount_retry": 22221, "read_seqretry": 22222, "read_size": 22223, "read_stamp": 22224, "read_start": 22225, "read_syscalls": 22226, "read_trylock": 22227, "read_u64": 22228, "read_unlock": 22229, "read_unlock_irq": 22230, "read_unlock_irqrestore": 22231, "read_waittime": 22232, "reader": 22233, "reader_finish": 22234, "reader_lock": 22235, "reader_lock_key": 22236, "reader_page": 22237, "reader_tasks": 22238, "readlock": 22239, "readme": 22240, "readpage": 22241, "readpos": 22242, "readunlock": 22243, "ready": 22244, "real": 22245, "real_blocked": 22246, "real_cred": 22247, "real_end": 22248, "real_ns": 22249, "real_parent": 22250, "real_root_dev": 22251, "real_start_time": 22252, "real_timer": 22253, "real_tk": 22254, "reallocate_resource": 22255, "rear": 22256, "reason": 22257, "rebalance_domains": 22258, "rebind_subsystems": 22259, "rebind_workers": 22260, "reboot": 22261, "reboot_command": 22262, "reboot_cpu": 22263, "reboot_default": 22264, "reboot_force": 22265, "reboot_hard": 22266, "reboot_mode": 22267, "reboot_mutex": 22268, "reboot_notifier_list": 22269, "reboot_pid_ns": 22270, "reboot_type": 22271, "rebuild_sched_domains": 22272, "rebuild_sched_domains_locked": 22273, "rec": 22274, "recalc_sigpending": 22275, "recalc_sigpending_and_wake": 22276, "recalc_sigpending_tsk": 22277, "recent": 22278, "recheck": 22279, "reclaim_distance": 22280, "reclaim_fs": 22281, "reclaim_fs_verbose": 22282, "reclaim_verbose": 22283, "record": 22284, "record_count": 22285, "record_count_len": 22286, "record_count_tag": 22287, "record_disabled": 22288, "record_file_magic": 22289, "record_function_check": 22290, "record_function_ident": 22291, "record_function_tag": 22292, "record_functon_tag_len": 22293, "record_gcov_version": 22294, "record_gp_stall_check_time": 22295, "record_it": 22296, "record_num": 22297, "record_time_stamp": 22298, "record_wakee": 22299, "records": 22300, "recover": 22301, "recursion": 22302, "recursive": 22303, "recycle_rp_inst": 22304, "redo": 22305, "reduce_fls": 22306, "redundant_hardirqs_off": 22307, "redundant_hardirqs_on": 22308, "redundant_softirqs_off": 22309, "redundant_softirqs_on": 22310, "reentry": 22311, "ref": 22312, "ref_count": 22313, "ref_module": 22314, "refcnt": 22315, "refcount": 22316, "referenced_filters": 22317, "references": 22318, "reflect": 22319, "reflush": 22320, "refresh": 22321, "refresh_timer": 22322, "refs": 22323, "refuse": 22324, "refusing": 22325, "reg": 22326, "reg16": 22327, "reg32": 22328, "reg64": 22329, "reg8": 22330, "reg_arg_type": 22331, "reg_base": 22332, "reg_event_syscall_enter": 22333, "reg_event_syscall_exit": 22334, "reg_readl": 22335, "reg_state": 22336, "reg_type_str": 22337, "reg_writel": 22338, "regex": 22339, "regex_lock": 22340, "regex_match_end": 22341, "regex_match_front": 22342, "regex_match_full": 22343, "regex_match_middle": 22344, "regex_type": 22345, "regfn": 22346, "region": 22347, "region_devres": 22348, "region_is_ram": 22349, "register": 22350, "register_aggr_kprobe": 22351, "register_array_map": 22352, "register_console": 22353, "register_cpu_notifier": 22354, "register_default_affinity_proc": 22355, "register_die_notifier": 22356, "register_event_cmds": 22357, "register_event_command": 22358, "register_filesystem": 22359, "register_for_each_vma": 22360, "register_ftrace_command": 22361, "register_ftrace_event": 22362, "register_ftrace_function": 22363, "register_ftrace_function_probe": 22364, "register_ftrace_graph": 22365, "register_ftrace_profiler": 22366, "register_handler_proc": 22367, "register_hotcpu_notifier": 22368, "register_hotmemory_notifier": 22369, "register_htab_map": 22370, "register_irq_proc": 22371, "register_irqsoff": 22372, "register_irqsoff_function": 22373, "register_jprobe": 22374, "register_jprobes": 22375, "register_kprobe": 22376, "register_kprobe_event": 22377, "register_kprobe_prog_ops": 22378, "register_kprobes": 22379, "register_kretprobe": 22380, "register_kretprobes": 22381, "register_lock_class": 22382, "register_module_notifier": 22383, "register_oom_notifier": 22384, "register_pernet_subsys": 22385, "register_pm_notifier": 22386, "register_pm_qos_misc": 22387, "register_preemptirqsoff": 22388, "register_preemptoff": 22389, "register_reboot_notifier": 22390, "register_restart_handler": 22391, "register_rwsem": 22392, "register_sched_domain_sysctl": 22393, "register_snapshot_trigger": 22394, "register_stat_tracer": 22395, "register_syscore_ops": 22396, "register_sysctl_paths": 22397, "register_sysctl_table": 22398, "register_sysrq_key": 22399, "register_trace_block_bio_backmerge": 22400, "register_trace_block_bio_bounce": 22401, "register_trace_block_bio_complete": 22402, "register_trace_block_bio_frontmerge": 22403, "register_trace_block_bio_queue": 22404, "register_trace_block_bio_remap": 22405, "register_trace_block_getrq": 22406, "register_trace_block_plug": 22407, "register_trace_block_rq_abort": 22408, "register_trace_block_rq_complete": 22409, "register_trace_block_rq_insert": 22410, "register_trace_block_rq_issue": 22411, "register_trace_block_rq_remap": 22412, "register_trace_block_rq_requeue": 22413, "register_trace_block_sleeprq": 22414, "register_trace_block_split": 22415, "register_trace_block_unplug": 22416, "register_trace_kprobe": 22417, "register_trace_sched_migrate_task": 22418, "register_trace_sched_switch": 22419, "register_trace_sched_wakeup": 22420, "register_trace_sched_wakeup_new": 22421, "register_trace_sys_enter": 22422, "register_trace_sys_exit": 22423, "register_trace_uprobe": 22424, "register_tracer": 22425, "register_trigger": 22426, "register_trigger_cmds": 22427, "register_trigger_enable_disable_cmds": 22428, "register_trigger_snapshot_cmd": 22429, "register_trigger_stacktrace_cmd": 22430, "register_uprobe_event": 22431, "register_wakeup_function": 22432, "registered": 22433, "registers": 22434, "registration": 22435, "regno": 22436, "regnum": 22437, "regs": 22438, "regs_get_kernel_stack_nth": 22439, "regs_get_register": 22440, "regs_intr": 22441, "regs_query_register_offset": 22442, "regs_return_value": 22443, "regs_user": 22444, "regs_user_copy": 22445, "regset": 22446, "regset_no": 22447, "regsets": 22448, "regular": 22449, "rel": 22450, "rel_msec": 22451, "rel_ts": 22452, "rel_usec": 22453, "relative_expiry_time": 22454, "relative_sleep_states": 22455, "relax_domain_level": 22456, "relay": 22457, "relay_buf_full": 22458, "relay_close": 22459, "relay_file_operations": 22460, "relay_flush": 22461, "relay_hotcpu_callback": 22462, "relay_open": 22463, "relay_reserve": 22464, "releasable_read": 22465, "release": 22466, "release_agent": 22467, "release_agent_path": 22468, "release_agent_path_lock": 22469, "release_agent_work": 22470, "release_all_trace_kprobes": 22471, "release_callchain_buffers": 22472, "release_callchain_buffers_rcu": 22473, "release_child_resources": 22474, "release_maps": 22475, "release_mem_region_adjustable": 22476, "release_node": 22477, "release_posix_timer": 22478, "release_resource": 22479, "release_swap_reader": 22480, "release_swap_writer": 22481, "reloc": 22482, "reloc_start": 22483, "relock": 22484, "relocs": 22485, "rem": 22486, "remain": 22487, "remainder": 22488, "remaining": 22489, "remcom_in_buffer": 22490, "remcom_out_buffer": 22491, "remote": 22492, "remote_clock": 22493, "remote_function": 22494, "remote_function_call": 22495, "remount_fs": 22496, "remove": 22497, "remove_breakpoint": 22498, "remove_buf_file": 22499, "remove_event": 22500, "remove_event_file_dir": 22501, "remove_event_from_tracers": 22502, "remove_filter_string": 22503, "remove_ftrace_list_ops": 22504, "remove_ftrace_ops": 22505, "remove_hash_entry": 22506, "remove_hw_breakpoint": 22507, "remove_info": 22508, "remove_irq": 22509, "remove_links": 22510, "remove_node": 22511, "remove_notes_attrs": 22512, "remove_percpu_irq": 22513, "remove_proc_entry": 22514, "remove_sect_attrs": 22515, "remove_subsystem": 22516, "remove_tasks_in_empty_cpuset": 22517, "remove_wait_queue": 22518, "removed_load": 22519, "removed_mask": 22520, "removed_ops": 22521, "removing": 22522, "rename": 22523, "rename_lock": 22524, "reopt": 22525, "reorder": 22526, "reorder_objects": 22527, "rep_skb": 22528, "repeat": 22529, "replace_filter_string": 22530, "replace_map_fd_with_map_ptr": 22531, "replace_preds": 22532, "replace_system_preds": 22533, "replenish": 22534, "reply": 22535, "report": 22536, "report_bad_irq": 22537, "report_latency": 22538, "report_probe": 22539, "req": 22540, "req_": 22541, "req_cpu": 22542, "req_sync": 22543, "req_type_block_pc": 22544, "reqd_free_pages": 22545, "request": 22546, "request_any_context_irq": 22547, "request_asymmetric_key": 22548, "request_dma": 22549, "request_irq": 22550, "request_key_auth": 22551, "request_percpu_irq": 22552, "request_queue": 22553, "request_resource": 22554, "request_resource_conflict": 22555, "request_skb": 22556, "request_threaded_irq": 22557, "requeue_pending": 22558, "requeue_rt_entity": 22559, "requeue_task_rt": 22560, "required": 22561, "res": 22562, "resched": 22563, "resched_cpu": 22564, "resched_curr": 22565, "resched_mask": 22566, "rescue_wq": 22567, "rescuer": 22568, "rescuer_nice_level": 22569, "rescuer_thread": 22570, "resend": 22571, "resend_irqs": 22572, "resend_tasklet": 22573, "reserve": 22574, "reserve_region_with_split": 22575, "reserve_setup": 22576, "reserved": 22577, "reserved_field_names": 22578, "reserved_pids": 22579, "reserved_size": 22580, "reset": 22581, "reset_counts": 22582, "reset_cpu_stall_ticks": 22583, "reset_dentry": 22584, "reset_entries": 22585, "reset_hung_task": 22586, "reset_hung_task_detector": 22587, "reset_iter": 22588, "reset_iter_read": 22589, "reset_kprobe_instance": 22590, "reset_node": 22591, "reset_on_fork": 22592, "reset_ptenuma_scan": 22593, "reset_read": 22594, "reset_stat_session": 22595, "reset_vma_resv_huge_pages": 22596, "reset_write": 22597, "resize_buffer_duplicate_size": 22598, "resize_disabled": 22599, "resolution": 22600, "resolve_symbol": 22601, "resolve_symbol_wait": 22602, "resource": 22603, "resource_alignment": 22604, "resource_clip": 22605, "resource_constraint": 22606, "resource_contains": 22607, "resource_entry": 22608, "resource_list_create_entry": 22609, "resource_list_destroy_entry": 22610, "resource_list_free": 22611, "resource_lock": 22612, "resource_op": 22613, "resource_size": 22614, "resource_size_t": 22615, "resource_type": 22616, "rest": 22617, "restart": 22618, "restart_block": 22619, "restart_handler_list": 22620, "restart_syscall": 22621, "restart_watchdog_hrtimer": 22622, "restore_altstack": 22623, "restore_cleanup": 22624, "restore_console": 22625, "restore_highmem": 22626, "restore_pblist": 22627, "restore_processor_state": 22628, "restore_unbound_workers_cpumask": 22629, "restorer": 22630, "result": 22631, "resume": 22632, "resume_console": 22633, "resume_delay": 22634, "resume_device_irqs": 22635, "resume_devices": 22636, "resume_file": 22637, "resume_irq": 22638, "resume_irqs": 22639, "resume_swap_area": 22640, "resume_target_kernel": 22641, "resume_wait": 22642, "resuming": 22643, "ret": 22644, "ret_addr": 22645, "ret_entry": 22646, "ret_handler": 22647, "ret_integer": 22648, "ret_ip": 22649, "ret_ptr_to_map_value_or_null": 22650, "ret_stack": 22651, "ret_stack_list": 22652, "ret_state": 22653, "ret_type": 22654, "ret_void": 22655, "retain": 22656, "retarget": 22657, "retarget_shared_pending": 22658, "retfunc": 22659, "retries": 22660, "retry": 22661, "retry_delete": 22662, "retry_find_task": 22663, "retry_task": 22664, "rettime": 22665, "return": 22666, "return_cfs_rq_runtime": 22667, "return_code": 22668, "return_instance": 22669, "return_instances": 22670, "return_normal": 22671, "return_valid": 22672, "retval": 22673, "reuse_unused_kprobe": 22674, "reverse": 22675, "revert_creds": 22676, "revmap_direct_max_irq": 22677, "revmap_size": 22678, "revmap_tree": 22679, "revmap_trees_mutex": 22680, "reweight_entity": 22681, "rewrite_section_headers": 22682, "rgid": 22683, "rgidp": 22684, "rh": 22685, "rh1": 22686, "rh2": 22687, "rhcount": 22688, "rhcount_lazy": 22689, "rhp": 22690, "rhs": 22691, "rhtp": 22692, "ri": 22693, "right": 22694, "right_child": 22695, "rimage": 22696, "ring": 22697, "ring_buffer": 22698, "ring_buffer_all_cpus": 22699, "ring_buffer_alloc": 22700, "ring_buffer_alloc_read_page": 22701, "ring_buffer_attach": 22702, "ring_buffer_benchmark_exit": 22703, "ring_buffer_benchmark_init": 22704, "ring_buffer_bytes_cpu": 22705, "ring_buffer_change_overwrite": 22706, "ring_buffer_commit_overrun_cpu": 22707, "ring_buffer_consume": 22708, "ring_buffer_discard_commit": 22709, "ring_buffer_dropped_events_cpu": 22710, "ring_buffer_empty": 22711, "ring_buffer_empty_cpu": 22712, "ring_buffer_entries": 22713, "ring_buffer_entries_cpu": 22714, "ring_buffer_event": 22715, "ring_buffer_event_data": 22716, "ring_buffer_event_length": 22717, "ring_buffer_expanded": 22718, "ring_buffer_flags": 22719, "ring_buffer_free": 22720, "ring_buffer_free_read_page": 22721, "ring_buffer_get": 22722, "ring_buffer_init": 22723, "ring_buffer_iter": 22724, "ring_buffer_iter_empty": 22725, "ring_buffer_iter_peek": 22726, "ring_buffer_iter_reset": 22727, "ring_buffer_lock_reserve": 22728, "ring_buffer_normalize_time_stamp": 22729, "ring_buffer_oldest_event_ts": 22730, "ring_buffer_overrun_cpu": 22731, "ring_buffer_overruns": 22732, "ring_buffer_page_len": 22733, "ring_buffer_peek": 22734, "ring_buffer_per_cpu": 22735, "ring_buffer_poll_wait": 22736, "ring_buffer_print_entry_header": 22737, "ring_buffer_print_page_header": 22738, "ring_buffer_put": 22739, "ring_buffer_read": 22740, "ring_buffer_read_events_cpu": 22741, "ring_buffer_read_finish": 22742, "ring_buffer_read_page": 22743, "ring_buffer_read_prepare": 22744, "ring_buffer_read_prepare_sync": 22745, "ring_buffer_read_start": 22746, "ring_buffer_record_disable": 22747, "ring_buffer_record_disable_cpu": 22748, "ring_buffer_record_enable": 22749, "ring_buffer_record_enable_cpu": 22750, "ring_buffer_record_is_on": 22751, "ring_buffer_record_off": 22752, "ring_buffer_record_on": 22753, "ring_buffer_reset": 22754, "ring_buffer_reset_cpu": 22755, "ring_buffer_resize": 22756, "ring_buffer_set_clock": 22757, "ring_buffer_size": 22758, "ring_buffer_swap_cpu": 22759, "ring_buffer_time_stamp": 22760, "ring_buffer_unlock_commit": 22761, "ring_buffer_wait": 22762, "ring_buffer_wakeup": 22763, "ring_buffer_writable": 22764, "ring_buffer_write": 22765, "ring_iter": 22766, "ring_size": 22767, "ringbuf_type_data": 22768, "ringbuf_type_data_type_len_max": 22769, "ringbuf_type_padding": 22770, "ringbuf_type_time_extend": 22771, "ringbuf_type_time_stamp": 22772, "rl": 22773, "rlen": 22774, "rlim": 22775, "rlim64": 22776, "rlim64_infinity": 22777, "rlim64_is_infinity": 22778, "rlim64_to_rlim": 22779, "rlim_cur": 22780, "rlim_infinity": 22781, "rlim_max": 22782, "rlim_nlimits": 22783, "rlim_rtprio": 22784, "rlim_to_rlim64": 22785, "rlimit": 22786, "rlimit64": 22787, "rlimit_cpu": 22788, "rlimit_data": 22789, "rlimit_fsize": 22790, "rlimit_memlock": 22791, "rlimit_nofile": 22792, "rlimit_nproc": 22793, "rlimit_rtprio": 22794, "rlimit_rttime": 22795, "rlimit_sigpending": 22796, "rlist": 22797, "rloc": 22798, "rlock": 22799, "rmb": 22800, "rmdir": 22801, "rmt": 22802, "rmtp": 22803, "rn": 22804, "rname": 22805, "rnd": 22806, "rnp": 22807, "rnp_c": 22808, "rnp_index": 22809, "rnp_leaf": 22810, "rnp_old": 22811, "rnp_p": 22812, "rnp_root": 22813, "rnp_up": 22814, "ro_size": 22815, "robust_list": 22816, "robust_list_limit": 22817, "roffs": 22818, "rollback": 22819, "room_left": 22820, "root": 22821, "root_cgrp": 22822, "root_cpuacct": 22823, "root_cpuacct_cpuusage": 22824, "root_cs": 22825, "root_css": 22826, "root_domain": 22827, "root_irq_dir": 22828, "root_list": 22829, "root_mnt": 22830, "root_node": 22831, "root_swap": 22832, "root_task_group": 22833, "root_task_group_load": 22834, "root_user": 22835, "rotate": 22836, "rotate_ctx": 22837, "rotate_disable": 22838, "rotor": 22839, "round_jiffies": 22840, "round_jiffies_common": 22841, "round_jiffies_relative": 22842, "round_up": 22843, "roundup": 22844, "roundup_pow_of_two": 22845, "rp": 22846, "rp1": 22847, "rpage": 22848, "rpdu": 22849, "rpm_idle": 22850, "rpm_resume": 22851, "rpm_return_int": 22852, "rpm_suspend": 22853, "rpos": 22854, "rps": 22855, "rq": 22856, "rq0_min_vruntime": 22857, "rq1": 22858, "rq2": 22859, "rq_attach_root": 22860, "rq_clock": 22861, "rq_clock_skip_update": 22862, "rq_clock_task": 22863, "rq_cpu": 22864, "rq_cpu_time": 22865, "rq_data_dir": 22866, "rq_disk": 22867, "rq_last_tick_reset": 22868, "rq_nohz_flag_bits": 22869, "rq_of": 22870, "rq_of_rt_rq": 22871, "rq_of_rt_se": 22872, "rq_offline": 22873, "rq_offline_fair": 22874, "rq_offline_rt": 22875, "rq_online": 22876, "rq_online_fair": 22877, "rq_online_rt": 22878, "rq_sched_info": 22879, "rq_sched_info_arrive": 22880, "rq_sched_info_depart": 22881, "rq_sched_info_dequeued": 22882, "rqcf_act_skip": 22883, "rqcf_req_skip": 22884, "rqtp": 22885, "rr_interval": 22886, "rr_timeslice": 22887, "rrln": 22888, "rrsp": 22889, "rsa": 22890, "rsh": 22891, "rsize": 22892, "rsp": 22893, "rspdir": 22894, "rspin_until_writer_unlock": 22895, "rss": 22896, "rss_stat": 22897, "rt": 22898, "rt_avg": 22899, "rt_b": 22900, "rt_bandwidth": 22901, "rt_bandwidth_enabled": 22902, "rt_clear_overload": 22903, "rt_constraints_mutex": 22904, "rt_delta": 22905, "rt_entity_is_task": 22906, "rt_max_tries": 22907, "rt_mutex": 22908, "rt_mutex_adjust_pi": 22909, "rt_mutex_check_prio": 22910, "rt_mutex_deadlock_account_lock": 22911, "rt_mutex_deadlock_account_unlock": 22912, "rt_mutex_debug_task_free": 22913, "rt_mutex_finish_proxy_lock": 22914, "rt_mutex_full_chainwalk": 22915, "rt_mutex_get_top_task": 22916, "rt_mutex_has_waiters": 22917, "rt_mutex_init_proxy_locked": 22918, "rt_mutex_init_task": 22919, "rt_mutex_lock": 22920, "rt_mutex_lock_interruptible": 22921, "rt_mutex_min_chainwalk": 22922, "rt_mutex_next_owner": 22923, "rt_mutex_owner": 22924, "rt_mutex_owner_maskall": 22925, "rt_mutex_print_deadlock": 22926, "rt_mutex_proxy_unlock": 22927, "rt_mutex_setprio": 22928, "rt_mutex_start_proxy_lock": 22929, "rt_mutex_timed_futex_lock": 22930, "rt_mutex_top_waiter": 22931, "rt_mutex_unlock": 22932, "rt_mutex_waiter": 22933, "rt_nr_boosted": 22934, "rt_nr_migratory": 22935, "rt_nr_running": 22936, "rt_nr_total": 22937, "rt_overloaded": 22938, "rt_period": 22939, "rt_period_timer": 22940, "rt_period_us": 22941, "rt_policy": 22942, "rt_prio": 22943, "rt_prio_array": 22944, "rt_priority": 22945, "rt_push_ipi": 22946, "rt_push_ipi_executing": 22947, "rt_push_ipi_restart": 22948, "rt_queued": 22949, "rt_rq": 22950, "rt_rq_iter_t": 22951, "rt_rq_of_se": 22952, "rt_rq_throttled": 22953, "rt_runtime": 22954, "rt_runtime_lock": 22955, "rt_runtime_share": 22956, "rt_runtime_us": 22957, "rt_sched_class": 22958, "rt_schedulable_data": 22959, "rt_se": 22960, "rt_se_boosted": 22961, "rt_se_nr_running": 22962, "rt_se_prio": 22963, "rt_set_overload": 22964, "rt_sigaction": 22965, "rt_sigpending": 22966, "rt_sigprocmask": 22967, "rt_sigqueueinfo": 22968, "rt_sigsuspend": 22969, "rt_sigtimedwait": 22970, "rt_task": 22971, "rt_task_of": 22972, "rt_tgsigqueueinfo": 22973, "rt_throttled": 22974, "rt_time": 22975, "rtc": 22976, "rtc_class": 22977, "rtc_device": 22978, "rtc_read_time": 22979, "rtc_set_alarm": 22980, "rtc_time": 22981, "rtc_time_to_tm": 22982, "rtc_timer": 22983, "rtc_timer_init": 22984, "rtc_tm_to_time": 22985, "rtc_wkalrm": 22986, "rtcdev": 22987, "rtcdev_lock": 22988, "rtctimer": 22989, "rtcv_snap": 22990, "rtime": 22991, "rtmutex_chainwalk": 22992, "rtmutex_common": 22993, "rtn": 22994, "rtn_tp": 22995, "rto_count": 22996, "rto_mask": 22997, "rto_next_cpu": 22998, "rtort_free": 22999, "rtort_mbtest": 23000, "rtort_pipe_count": 23001, "rtort_rcu": 23002, "rtree": 23003, "rtree_next_node": 23004, "rtree_node": 23005, "rtst": 23006, "rttest_event": 23007, "rttest_lock": 23008, "rttest_lockcont": 23009, "rttest_lockint": 23010, "rttest_lockintnowait": 23011, "rttest_locknowait": 23012, "rttest_nop": 23013, "rttest_reset": 23014, "rttest_resetevent": 23015, "rttest_schedot": 23016, "rttest_schedrt": 23017, "rttest_signal": 23018, "rttest_subsys": 23019, "rttest_unlock": 23020, "rtws_cond_get": 23021, "rtws_cond_sync": 23022, "rtws_def_free": 23023, "rtws_delay": 23024, "rtws_exp_sync": 23025, "rtws_fixed_delay": 23026, "rtws_replace": 23027, "rtws_stopping": 23028, "rtws_stutter": 23029, "rtws_sync": 23030, "ru": 23031, "ru_idrss": 23032, "ru_inblock": 23033, "ru_isrss": 23034, "ru_ixrss": 23035, "ru_majflt": 23036, "ru_maxrss": 23037, "ru_minflt": 23038, "ru_msgrcv": 23039, "ru_msgsnd": 23040, "ru_nivcsw": 23041, "ru_nsignals": 23042, "ru_nswap": 23043, "ru_nvcsw": 23044, "ru_oublock": 23045, "ru_stime": 23046, "ru_utime": 23047, "ruid": 23048, "ruidp": 23049, "rule": 23050, "rules": 23051, "run": 23052, "run_delay": 23053, "run_ksoftirqd": 23054, "run_list": 23055, "run_local_timers": 23056, "run_node": 23057, "run_posix_cpu_timers": 23058, "run_rebalance_domains": 23059, "run_threads": 23060, "run_time": 23061, "run_timer_softirq": 23062, "run_tracer_selftest": 23063, "runnable": 23064, "runnable_avg": 23065, "runnable_avg_sum": 23066, "runnable_avg_yn_inv": 23067, "runnable_avg_yn_sum": 23068, "runnable_contrib": 23069, "runnable_load_avg": 23070, "running": 23071, "running_avg_sum": 23072, "running_clock": 23073, "running_helpers": 23074, "running_helpers_timeout": 23075, "running_helpers_waitq": 23076, "running_list": 23077, "running_sample_length": 23078, "running_timer": 23079, "running_trace_list": 23080, "running_trace_lock": 23081, "runqueues": 23082, "runtime": 23083, "runtime_enabled": 23084, "runtime_expires": 23085, "runtime_inf": 23086, "runtime_refresh_within": 23087, "runtime_remaining": 23088, "runtime_was_enabled": 23089, "rusage": 23090, "rusage_both": 23091, "rusage_children": 23092, "rusage_self": 23093, "rusage_thread": 23094, "rw": 23095, "rw_lock_irq_ops": 23096, "rw_lock_ops": 23097, "rw_sem": 23098, "rw_semaphore": 23099, "rwbs": 23100, "rwbs_len": 23101, "rwlock": 23102, "rwlock_bug": 23103, "rwlock_bug_on": 23104, "rwlock_init": 23105, "rwlock_magic": 23106, "rwlock_t": 23107, "rwsem": 23108, "rwsem_acquire": 23109, "rwsem_acquire_nest": 23110, "rwsem_acquire_read": 23111, "rwsem_active_mask": 23112, "rwsem_active_read_bias": 23113, "rwsem_active_write_bias": 23114, "rwsem_atomic_add": 23115, "rwsem_atomic_update": 23116, "rwsem_can_spin_on_owner": 23117, "rwsem_clear_owner": 23118, "rwsem_down_read_failed": 23119, "rwsem_down_write_failed": 23120, "rwsem_downgrade_wake": 23121, "rwsem_is_locked": 23122, "rwsem_key": 23123, "rwsem_lock_ops": 23124, "rwsem_optimistic_spin": 23125, "rwsem_release": 23126, "rwsem_set_owner": 23127, "rwsem_spin_on_owner": 23128, "rwsem_try_write_lock": 23129, "rwsem_try_write_lock_unqueued": 23130, "rwsem_unlocked_value": 23131, "rwsem_waiter": 23132, "rwsem_waiter_type": 23133, "rwsem_waiting_bias": 23134, "rwsem_waiting_for_read": 23135, "rwsem_waiting_for_write": 23136, "rwsem_wake": 23137, "rwsem_wake_any": 23138, "rwsem_wake_read_owned": 23139, "rwsem_wake_readers": 23140, "rwsem_wake_type": 23141, "s": 23142, "s16": 23143, "s2": 23144, "s32": 23145, "s64": 23146, "s8": 23147, "s_alloc": 23148, "s_data": 23149, "s_dev": 23150, "s_dst": 23151, "s_ifmt": 23152, "s_ifreg": 23153, "s_irugo": 23154, "s_irusr": 23155, "s_irwxugo": 23156, "s_isreg": 23157, "s_iwgrp": 23158, "s_iwoth": 23159, "s_iwusr": 23160, "s_next": 23161, "s_show": 23162, "s_src": 23163, "s_start": 23164, "s_stop": 23165, "s_time_gran": 23166, "s_type": 23167, "sa": 23168, "sa_flags": 23169, "sa_handler": 23170, "sa_mask": 23171, "sa_nocldstop": 23172, "sa_nocldwait": 23173, "sa_nodefer": 23174, "sa_nomask": 23175, "sa_none": 23176, "sa_oneshot": 23177, "sa_restorer": 23178, "sa_rootdomain": 23179, "sa_sd": 23180, "sa_sd_storage": 23181, "sabbr": 23182, "safe": 23183, "safe_highmem_bm": 23184, "safe_highmem_pages": 23185, "safe_needed": 23186, "safe_pages_list": 23187, "same": 23188, "same_magic": 23189, "same_root": 23190, "same_thread_group": 23191, "sample": 23192, "sample_data": 23193, "sample_freq": 23194, "sample_id_all": 23195, "sample_len_ns": 23196, "sample_period": 23197, "sample_regs_intr": 23198, "sample_regs_user": 23199, "sample_stack_user": 23200, "sample_step": 23201, "sample_type": 23202, "sanity_check_segment_list": 23203, "sas_ss_flags": 23204, "sas_ss_size": 23205, "sas_ss_sp": 23206, "sattr": 23207, "sav_total": 23208, "save": 23209, "save_adjust": 23210, "save_current_task": 23211, "save_defcmd_set": 23212, "save_flags": 23213, "save_ftrace_enabled": 23214, "save_global_flags": 23215, "save_global_trampoline": 23216, "save_highmem": 23217, "save_image": 23218, "save_image_lzo": 23219, "save_info": 23220, "save_len": 23221, "save_max": 23222, "save_processor_state": 23223, "save_stack_trace": 23224, "save_stack_trace_regs": 23225, "save_stack_trace_tsk": 23226, "save_timestamp": 23227, "save_trace": 23228, "saveable": 23229, "saveable_highmem_page": 23230, "saved": 23231, "saved_auxv": 23232, "saved_cmdlines": 23233, "saved_cmdlines_buffer": 23234, "saved_cmdlines_default": 23235, "saved_cmdlines_size": 23236, "saved_ftrace_func": 23237, "saved_instr": 23238, "saved_latency": 23239, "saved_max_active": 23240, "saved_max_pfn": 23241, "saved_sigmask": 23242, "saved_tracer": 23243, "savedcmd": 23244, "sb": 23245, "sbe_balanced": 23246, "sbe_count": 23247, "sbe_pushed": 23248, "sbf_balanced": 23249, "sbf_count": 23250, "sbf_pushed": 23251, "sbuf": 23252, "sc": 23253, "scale": 23254, "scale_freq": 23255, "scale_load": 23256, "scale_load_down": 23257, "scale_rt_capacity": 23258, "scale_stime": 23259, "scaled": 23260, "scaled_busy_load_per_task": 23261, "scan": 23262, "scan_size": 23263, "scancode": 23264, "scd": 23265, "scenario": 23266, "sched": 23267, "sched_annotate_sleep": 23268, "sched_attr": 23269, "sched_attr_size_ver0": 23270, "sched_autogroup_create_attach": 23271, "sched_autogroup_detach": 23272, "sched_autogroup_exit": 23273, "sched_autogroup_fork": 23274, "sched_avg": 23275, "sched_avg_period": 23276, "sched_avg_update": 23277, "sched_batch": 23278, "sched_can_stop_tick": 23279, "sched_capacity_scale": 23280, "sched_capacity_shift": 23281, "sched_cfs_bandwidth_slice": 23282, "sched_cfs_period_timer": 23283, "sched_cfs_slack_timer": 23284, "sched_class": 23285, "sched_class_highest": 23286, "sched_clk": 23287, "sched_clock": 23288, "sched_clock_cpu": 23289, "sched_clock_data": 23290, "sched_clock_idle_sleep_event": 23291, "sched_clock_idle_wakeup_event": 23292, "sched_clock_init": 23293, "sched_clock_irqtime": 23294, "sched_clock_local": 23295, "sched_clock_remote": 23296, "sched_clock_running": 23297, "sched_clock_stable": 23298, "sched_clock_tick": 23299, "sched_clock_work": 23300, "sched_contributes_to_load": 23301, "sched_count": 23302, "sched_cpu_active": 23303, "sched_cpu_inactive": 23304, "sched_create_group": 23305, "sched_deadline": 23306, "sched_debug": 23307, "sched_debug_enabled": 23308, "sched_debug_header": 23309, "sched_debug_lock": 23310, "sched_debug_setup": 23311, "sched_debug_show": 23312, "sched_debug_start": 23313, "sched_destroy_group": 23314, "sched_dl_do_global": 23315, "sched_dl_entity": 23316, "sched_dl_global_validate": 23317, "sched_domain": 23318, "sched_domain_attr": 23319, "sched_domain_debug": 23320, "sched_domain_debug_one": 23321, "sched_domain_level_max": 23322, "sched_domain_span": 23323, "sched_domain_topology": 23324, "sched_domain_topology_level": 23325, "sched_domains_curr_level": 23326, "sched_domains_mutex": 23327, "sched_domains_numa_distance": 23328, "sched_domains_numa_levels": 23329, "sched_domains_numa_masks": 23330, "sched_domains_numa_masks_update": 23331, "sched_domains_tmpmask": 23332, "sched_entity": 23333, "sched_exec": 23334, "sched_exp": 23335, "sched_feat": 23336, "sched_feat_fops": 23337, "sched_feat_keys": 23338, "sched_feat_open": 23339, "sched_feat_set": 23340, "sched_feat_show": 23341, "sched_feat_write": 23342, "sched_fifo": 23343, "sched_find_first_bit": 23344, "sched_flag_reset_on_fork": 23345, "sched_flags": 23346, "sched_fork": 23347, "sched_get_priority_max": 23348, "sched_get_priority_min": 23349, "sched_getaffinity": 23350, "sched_getattr": 23351, "sched_getparam": 23352, "sched_goidle": 23353, "sched_group": 23354, "sched_group_capacity": 23355, "sched_group_cpus": 23356, "sched_group_mask": 23357, "sched_group_rt_period": 23358, "sched_group_rt_runtime": 23359, "sched_group_set_rt_period": 23360, "sched_group_set_rt_runtime": 23361, "sched_group_set_shares": 23362, "sched_idle": 23363, "sched_ilb_notifier": 23364, "sched_in": 23365, "sched_info": 23366, "sched_info_arrive": 23367, "sched_info_depart": 23368, "sched_info_dequeued": 23369, "sched_info_on": 23370, "sched_info_queued": 23371, "sched_info_reset_dequeued": 23372, "sched_info_switch": 23373, "sched_init_debug": 23374, "sched_init_granularity": 23375, "sched_init_numa": 23376, "sched_init_smp": 23377, "sched_latency": 23378, "sched_load_resolution": 23379, "sched_load_scale": 23380, "sched_load_shift": 23381, "sched_max_numa_distance": 23382, "sched_min_granularity": 23383, "sched_move_task": 23384, "sched_nice": 23385, "sched_normal": 23386, "sched_nr_latency": 23387, "sched_nr_migrate_break": 23388, "sched_numa_topology_type": 23389, "sched_numa_warn": 23390, "sched_offline_group": 23391, "sched_online_group": 23392, "sched_ops": 23393, "sched_out": 23394, "sched_param": 23395, "sched_period": 23396, "sched_policy": 23397, "sched_preempt_enable_no_resched": 23398, "sched_priority": 23399, "sched_proc_update_handler": 23400, "sched_profiling": 23401, "sched_read_attr": 23402, "sched_ref": 23403, "sched_register_mutex": 23404, "sched_reset_on_fork": 23405, "sched_rr": 23406, "sched_rr_get_interval": 23407, "sched_rr_handler": 23408, "sched_rr_timeslice": 23409, "sched_rt_avg_update": 23410, "sched_rt_bandwidth": 23411, "sched_rt_bandwidth_account": 23412, "sched_rt_can_attach": 23413, "sched_rt_do_global": 23414, "sched_rt_entity": 23415, "sched_rt_global_constraints": 23416, "sched_rt_global_validate": 23417, "sched_rt_handler": 23418, "sched_rt_period": 23419, "sched_rt_period_mask": 23420, "sched_rt_period_rt_rq": 23421, "sched_rt_period_timer": 23422, "sched_rt_rq_dequeue": 23423, "sched_rt_rq_enqueue": 23424, "sched_rt_runtime": 23425, "sched_rt_runtime_exceeded": 23426, "sched_runtime": 23427, "sched_set_stop_task": 23428, "sched_setaffinity": 23429, "sched_setattr": 23430, "sched_setnuma": 23431, "sched_setscheduler": 23432, "sched_setscheduler_nocheck": 23433, "sched_show_numa": 23434, "sched_show_task": 23435, "sched_skew_tick": 23436, "sched_slice": 23437, "sched_softirq": 23438, "sched_submit_work": 23439, "sched_task": 23440, "sched_task_group": 23441, "sched_timer": 23442, "sched_torture_read_lock": 23443, "sched_torture_read_unlock": 23444, "sched_ttwu_pending": 23445, "sched_tunable_scaling": 23446, "sched_tunable_scaling_names": 23447, "sched_tunablescaling_end": 23448, "sched_tunablescaling_linear": 23449, "sched_tunablescaling_log": 23450, "sched_tunablescaling_none": 23451, "sched_vslice": 23452, "sched_wakeup_granularity": 23453, "schedpar": 23454, "schedstat_add": 23455, "schedstat_inc": 23456, "schedstat_set": 23457, "schedstat_start": 23458, "schedstat_version": 23459, "schedule": 23460, "schedule_debug": 23461, "schedule_delayed_work": 23462, "schedule_hrtimeout": 23463, "schedule_hrtimeout_range": 23464, "schedule_next_timer": 23465, "schedule_on_each_cpu": 23466, "schedule_orphans_remove": 23467, "schedule_preempt_disabled": 23468, "schedule_rt_mutex": 23469, "schedule_rt_mutex_test": 23470, "schedule_tail": 23471, "schedule_timeout": 23472, "schedule_timeout_interruptible": 23473, "schedule_timeout_uninterruptible": 23474, "schedule_user": 23475, "schedule_work": 23476, "schedule_work_on": 23477, "scheduled": 23478, "scheduler_ipi": 23479, "scheduler_running": 23480, "scheduler_tick": 23481, "scheduler_tick_max_deferment": 23482, "sci_ptr": 23483, "scnprintf": 23484, "scons_pwroff": 23485, "sconsole": 23486, "score": 23487, "score_nearby_nodes": 23488, "scpu": 23489, "sd": 23490, "sd_alloc_ctl_cpu_table": 23491, "sd_alloc_ctl_domain_table": 23492, "sd_alloc_ctl_entry": 23493, "sd_asym": 23494, "sd_asym_packing": 23495, "sd_attr_init": 23496, "sd_balance_exec": 23497, "sd_balance_fork": 23498, "sd_balance_newidle": 23499, "sd_balance_wake": 23500, "sd_busy": 23501, "sd_ctl_dir": 23502, "sd_ctl_root": 23503, "sd_data": 23504, "sd_degenerate": 23505, "sd_flag": 23506, "sd_flags": 23507, "sd_free_ctl_entry": 23508, "sd_init": 23509, "sd_init_name": 23510, "sd_lb_stats": 23511, "sd_llc": 23512, "sd_llc_id": 23513, "sd_llc_size": 23514, "sd_load_balance": 23515, "sd_local": 23516, "sd_numa": 23517, "sd_numa_mask": 23518, "sd_overlap": 23519, "sd_parent": 23520, "sd_parent_degenerate": 23521, "sd_prefer_sibling": 23522, "sd_serialize": 23523, "sd_share_cpucapacity": 23524, "sd_share_pkg_resources": 23525, "sd_share_powerdomain": 23526, "sd_sysctl_header": 23527, "sd_wake_affine": 23528, "sd_weight": 23529, "sdd": 23530, "sdelta": 23531, "sdg": 23532, "sds": 23533, "sdtl_overlap": 23534, "se": 23535, "se_depth": 23536, "search": 23537, "search_exception_tables": 23538, "search_extable": 23539, "search_module_extables": 23540, "searchprompt": 23541, "sec": 23542, "sec_conversion": 23543, "sec_fls": 23544, "sec_jiffie_sc": 23545, "secbase": 23546, "seccomp": 23547, "seccomp_assign_mode": 23548, "seccomp_attach_filter": 23549, "seccomp_can_sync_threads": 23550, "seccomp_check_filter": 23551, "seccomp_data": 23552, "seccomp_debug": 23553, "seccomp_filter": 23554, "seccomp_filter_flag_mask": 23555, "seccomp_filter_flag_tsync": 23556, "seccomp_filter_free": 23557, "seccomp_may_assign_mode": 23558, "seccomp_mode": 23559, "seccomp_mode_disabled": 23560, "seccomp_mode_filter": 23561, "seccomp_mode_strict": 23562, "seccomp_phase1": 23563, "seccomp_phase1_ok": 23564, "seccomp_phase1_skip": 23565, "seccomp_phase2": 23566, "seccomp_prepare_filter": 23567, "seccomp_prepare_user_filter": 23568, "seccomp_ret_action": 23569, "seccomp_ret_allow": 23570, "seccomp_ret_data": 23571, "seccomp_ret_errno": 23572, "seccomp_ret_kill": 23573, "seccomp_ret_trace": 23574, "seccomp_ret_trap": 23575, "seccomp_run_filters": 23576, "seccomp_send_sigsys": 23577, "seccomp_set_mode_filter": 23578, "seccomp_set_mode_strict": 23579, "seccomp_sync_threads": 23580, "secctx": 23581, "sechdr": 23582, "sechdrs": 23583, "sechdrs_c": 23584, "secid": 23585, "second": 23586, "second_length": 23587, "second_overflow": 23588, "second_pass": 23589, "seconds": 23590, "secs": 23591, "secs_to_cputime": 23592, "secsize": 23593, "secstrings": 23594, "sect": 23595, "sect_attrs": 23596, "sect_empty": 23597, "section": 23598, "section_addr": 23599, "section_objs": 23600, "sector": 23601, "sector_from": 23602, "sector_t": 23603, "secure_computing_strict": 23604, "securebits": 23605, "securebits_default": 23606, "security": 23607, "security_audit_rule_free": 23608, "security_audit_rule_init": 23609, "security_audit_rule_known": 23610, "security_audit_rule_match": 23611, "security_capable": 23612, "security_capable_noaudit": 23613, "security_capget": 23614, "security_cred_alloc_blank": 23615, "security_cred_free": 23616, "security_inode_getsecid": 23617, "security_ipc_getsecid": 23618, "security_kernel_create_files_as": 23619, "security_kernel_module_from_file": 23620, "security_kernel_module_request": 23621, "security_prepare_creds": 23622, "security_ptrace_access_check": 23623, "security_ptrace_traceme": 23624, "security_release_secctx": 23625, "security_secid_to_secctx": 23626, "security_settime": 23627, "security_task_create": 23628, "security_task_fix_setuid": 23629, "security_task_free": 23630, "security_task_getpgid": 23631, "security_task_getscheduler": 23632, "security_task_getsecid": 23633, "security_task_getsid": 23634, "security_task_kill": 23635, "security_task_prctl": 23636, "security_task_setnice": 23637, "security_task_setpgid": 23638, "security_task_setrlimit": 23639, "security_task_setscheduler": 23640, "security_vm_enough_memory_mm": 23641, "see": 23642, "seed": 23643, "seg": 23644, "segment": 23645, "segment_bytes": 23646, "segments": 23647, "segv_bnderr": 23648, "seize": 23649, "seized": 23650, "select": 23651, "select_bucket": 23652, "select_comparison_fn": 23653, "select_fallback_rq": 23654, "select_idle_sibling": 23655, "select_insn": 23656, "select_task_rq": 23657, "select_task_rq_fair": 23658, "select_task_rq_idle": 23659, "select_task_rq_rt": 23660, "selected_console": 23661, "self": 23662, "self_exec_id": 23663, "selfmag": 23664, "selfparking": 23665, "selftest": 23666, "selinux_audit_rule_update": 23667, "selinux_is_enabled": 23668, "sem": 23669, "semaphore": 23670, "semaphore_waiter": 23671, "send": 23672, "send_cpu_listeners": 23673, "send_mayday": 23674, "send_ready": 23675, "send_reply": 23676, "send_sig": 23677, "send_sig_forced": 23678, "send_sig_info": 23679, "send_sig_noinfo": 23680, "send_sig_priv": 23681, "send_signal": 23682, "send_sigqueue": 23683, "sep": 23684, "separate_irq_context": 23685, "seq": 23686, "seq_buf_bprintf": 23687, "seq_buf_buffer_left": 23688, "seq_buf_has_overflowed": 23689, "seq_buf_path": 23690, "seq_buf_print_seq": 23691, "seq_buf_printf": 23692, "seq_buf_putc": 23693, "seq_buf_putmem": 23694, "seq_buf_putmem_hex": 23695, "seq_buf_to_user": 23696, "seq_buf_used": 23697, "seq_buf_vprintf": 23698, "seq_cft": 23699, "seq_css": 23700, "seq_file": 23701, "seq_header": 23702, "seq_line": 23703, "seq_list_next": 23704, "seq_list_start": 23705, "seq_list_start_head": 23706, "seq_lock_time": 23707, "seq_lseek": 23708, "seq_next": 23709, "seq_nr": 23710, "seq_ns": 23711, "seq_open": 23712, "seq_operations": 23713, "seq_ops": 23714, "seq_print_ip_sym": 23715, "seq_print_sym_offset": 23716, "seq_print_sym_short": 23717, "seq_print_user_ip": 23718, "seq_print_userip_objs": 23719, "seq_printf": 23720, "seq_put_field": 23721, "seq_put_hex_field": 23722, "seq_putc": 23723, "seq_puts": 23724, "seq_read": 23725, "seq_release": 23726, "seq_release_private": 23727, "seq_show": 23728, "seq_start": 23729, "seq_start_token": 23730, "seq_stats": 23731, "seq_stop": 23732, "seq_time": 23733, "seq_user_ns": 23734, "seq_write": 23735, "seq_write_gcov_u32": 23736, "seq_write_gcov_u64": 23737, "seqcount_init": 23738, "seqcount_t": 23739, "seqlock_init": 23740, "seqlock_t": 23741, "sequence": 23742, "sequential_io": 23743, "sequential_io_avg": 23744, "serial": 23745, "serial_cpumask": 23746, "serial_cpumask_attr": 23747, "serial_mask": 23748, "serial_nr": 23749, "serial_work": 23750, "server": 23751, "session": 23752, "session_id": 23753, "session_keyring": 23754, "session_list": 23755, "sessionid": 23756, "set": 23757, "set32": 23758, "set_alarm": 23759, "set_all_modules_text_ro": 23760, "set_all_modules_text_rw": 23761, "set_bit": 23762, "set_blocksize": 23763, "set_buf_size": 23764, "set_buffer": 23765, "set_buffer_entries": 23766, "set_child_tid": 23767, "set_cmdline": 23768, "set_cmdline_ftrace": 23769, "set_cond": 23770, "set_cpu_active": 23771, "set_cpu_itimer": 23772, "set_cpu_online": 23773, "set_cpu_possible": 23774, "set_cpu_present": 23775, "set_cpu_rq_start_time": 23776, "set_cpu_sd_state_busy": 23777, "set_cpu_sd_state_idle": 23778, "set_cpus_allowed": 23779, "set_cpus_allowed_ptr": 23780, "set_cpus_allowed_rt": 23781, "set_create_files_as": 23782, "set_cred_subscribers": 23783, "set_cred_user_ns": 23784, "set_curr_task": 23785, "set_curr_task_fair": 23786, "set_curr_task_idle": 23787, "set_curr_task_rt": 23788, "set_current_blocked": 23789, "set_current_groups": 23790, "set_current_state": 23791, "set_desc": 23792, "set_domain_attribute": 23793, "set_dumpable": 23794, "set_endian": 23795, "set_filter": 23796, "set_flag": 23797, "set_fp_mode": 23798, "set_fpemu_ctl": 23799, "set_fpexc_ctl": 23800, "set_freezable": 23801, "set_fs": 23802, "set_ftrace_dump_on_oops": 23803, "set_ftrace_early_filters": 23804, "set_ftrace_filter": 23805, "set_ftrace_notrace": 23806, "set_ftrace_pid": 23807, "set_ftrace_pid_function": 23808, "set_ftrace_pid_task": 23809, "set_ftrace_swapper": 23810, "set_function_trace_op": 23811, "set_graph_array": 23812, "set_graph_function": 23813, "set_graph_notrace": 23814, "set_hw_breakpoint": 23815, "set_irq_regs": 23816, "set_irq_wake_real": 23817, "set_kprobe_instance": 23818, "set_last_buddy": 23819, "set_last_pid": 23820, "set_license": 23821, "set_load_weight": 23822, "set_max_threads": 23823, "set_mb": 23824, "set_memory_nx": 23825, "set_memory_ro": 23826, "set_memory_rw": 23827, "set_memory_x": 23828, "set_mems_allowed": 23829, "set_mm_exe_file": 23830, "set_mode": 23831, "set_next_buddy": 23832, "set_next_entity": 23833, "set_next_event": 23834, "set_next_ktime": 23835, "set_normalized_timespec": 23836, "set_normalized_timespec64": 23837, "set_notify_resume": 23838, "set_nr_and_not_polling": 23839, "set_nr_if_polling": 23840, "set_ns": 23841, "set_numabalancing_state": 23842, "set_one_prio": 23843, "set_one_prio_perm": 23844, "set_orig_insn": 23845, "set_page_attributes": 23846, "set_page_private": 23847, "set_personality": 23848, "set_post_schedule": 23849, "set_preempt_need_resched": 23850, "set_print_fmt": 23851, "set_process_cpu_timer": 23852, "set_pte_at_notify": 23853, "set_restore_sigmask": 23854, "set_robust_list": 23855, "set_rq_offline": 23856, "set_rq_online": 23857, "set_sample_period": 23858, "set_sched_clock_stable": 23859, "set_sched_topology": 23860, "set_section_ro_nx": 23861, "set_skip_buddy": 23862, "set_softirq_pending": 23863, "set_special_pids": 23864, "set_state": 23865, "set_state_oneshot": 23866, "set_state_periodic": 23867, "set_state_shutdown": 23868, "set_str": 23869, "set_swbp": 23870, "set_syscall_print_fmt": 23871, "set_sysctl": 23872, "set_table_entry": 23873, "set_task_comm": 23874, "set_task_cpu": 23875, "set_task_rq": 23876, "set_task_stack_end_magic": 23877, "set_task_state": 23878, "set_thread_flag": 23879, "set_tid_address": 23880, "set_timer_slack": 23881, "set_to_char": 23882, "set_trace_boot_clock": 23883, "set_trace_boot_options": 23884, "set_tracepoint_printk": 23885, "set_tracer_flag": 23886, "set_tracing_thresh": 23887, "set_trigger_filter": 23888, "set_tsc_ctl": 23889, "set_tsk_need_resched": 23890, "set_tsk_thread_flag": 23891, "set_tsk_trace_trace": 23892, "set_unalign_ctl": 23893, "set_user": 23894, "set_user_nice": 23895, "set_work_data": 23896, "set_work_pool_and_clear_pending": 23897, "set_work_pool_and_keep_pending": 23898, "set_work_pwq": 23899, "set_worker_desc": 23900, "setdomainname": 23901, "setfsgid": 23902, "setfsgid16": 23903, "setfsuid": 23904, "setfsuid16": 23905, "setgid": 23906, "setgid16": 23907, "setgroups16": 23908, "setgroups_allowed": 23909, "sethostname": 23910, "setitimer": 23911, "setjmp_pre_handler": 23912, "setmax_mm_hiwater_rss": 23913, "setns": 23914, "setpageprivate": 23915, "setparam_policy": 23916, "setpgid": 23917, "setregid": 23918, "setregid16": 23919, "setresgid": 23920, "setresgid16": 23921, "setresuid16": 23922, "setreuid": 23923, "setreuid16": 23924, "setrlimit": 23925, "setsid": 23926, "settimeofday": 23927, "setting": 23928, "setuid16": 23929, "setup": 23930, "setup_affinity": 23931, "setup_autogroup": 23932, "setup_aux": 23933, "setup_crash_kexec_post_notifiers": 23934, "setup_elfcorehdr": 23935, "setup_forced_irqthreads": 23936, "setup_irq": 23937, "setup_load_info": 23938, "setup_max_cpus": 23939, "setup_modinfo": 23940, "setup_modinfo_": 23941, "setup_percpu_irq": 23942, "setup_print_fatal_signals": 23943, "setup_profiling_timer": 23944, "setup_relax_domain_level": 23945, "setup_test_suspend": 23946, "setup_thread_stack": 23947, "setup_timer": 23948, "setup_timer_on_stack": 23949, "setup_trace_event": 23950, "sf": 23951, "sf_crc32_mode": 23952, "sf_nocompress_mode": 23953, "sf_platform_mode": 23954, "sg": 23955, "sg_big_buff": 23956, "sg_cpus": 23957, "sg_imbalanced": 23958, "sg_lb_stats": 23959, "sg_mask": 23960, "sg_span": 23961, "sgc": 23962, "sgetmask": 23963, "sgid": 23964, "sgidp": 23965, "sgs": 23966, "sh_addr": 23967, "sh_addralign": 23968, "sh_entsize": 23969, "sh_flags": 23970, "sh_info": 23971, "sh_link": 23972, "sh_name": 23973, "sh_offset": 23974, "sh_size": 23975, "sh_type": 23976, "sha256_digest_size": 23977, "sha_region_sz": 23978, "sha_regions": 23979, "shadow_ctx_time": 23980, "shadow_pid": 23981, "shadow_timekeeper": 23982, "shallowest_idle_cpu": 23983, "shardware": 23984, "shared": 23985, "shared_pending": 23986, "shared_vm": 23987, "sharedram": 23988, "shares": 23989, "shares_mutex": 23990, "shareval": 23991, "shash_desc": 23992, "shdr": 23993, "shf_alloc": 23994, "shf_execinstr": 23995, "shf_write": 23996, "shift": 23997, "shift_change": 23998, "shift_pll": 23999, "shift_right": 24000, "shm_init_task": 24001, "shmem_mapping": 24002, "shmem_read_mapping_page": 24003, "shn_abs": 24004, "shn_common": 24005, "shn_loreserve": 24006, "shn_undef": 24007, "shnum": 24008, "short": 24009, "shortdelay_us": 24010, "should_free": 24011, "should_numa_migrate_memory": 24012, "should_resched": 24013, "should_stop": 24014, "should_we_balance": 24015, "show": 24016, "show_active": 24017, "show_available_triggers": 24018, "show_coresize": 24019, "show_cpumask": 24020, "show_event_seq_ops": 24021, "show_header": 24022, "show_initsize": 24023, "show_initstate": 24024, "show_interrupts": 24025, "show_irq_affinity": 24026, "show_kprobe_addr": 24027, "show_modinfo_": 24028, "show_mutex": 24029, "show_one_rcugp": 24030, "show_options": 24031, "show_pwq": 24032, "show_rcu_gp_kthreads": 24033, "show_rcu_node_boost": 24034, "show_rcu_pending": 24035, "show_rcubarrier": 24036, "show_rcudata": 24037, "show_rcuexp": 24038, "show_rcugp": 24039, "show_rcuhier": 24040, "show_rcutorture": 24041, "show_refcnt": 24042, "show_regs": 24043, "show_schedstat": 24044, "show_set_event_seq_ops": 24045, "show_special": 24046, "show_stack": 24047, "show_state_filter": 24048, "show_taint": 24049, "show_unhandled_signals": 24050, "show_workqueue_state": 24051, "shows": 24052, "sht_nobits": 24053, "sht_note": 24054, "sht_rel": 24055, "sht_rela": 24056, "sht_symtab": 24057, "shuffint": 24058, "shuffle_idle_cpu": 24059, "shuffle_interval": 24060, "shuffle_task": 24061, "shuffle_task_list": 24062, "shuffle_task_mutex": 24063, "shuffle_tmp_mask": 24064, "shuffler_task": 24065, "shutdown": 24066, "shutdown_secs": 24067, "shutdown_task": 24068, "shutdown_time": 24069, "si": 24070, "si1": 24071, "si2": 24072, "si_addr": 24073, "si_addr_lsb": 24074, "si_arch": 24075, "si_band": 24076, "si_call_addr": 24077, "si_code": 24078, "si_errno": 24079, "si_fd": 24080, "si_fromkernel": 24081, "si_fromuser": 24082, "si_kernel": 24083, "si_load_shift": 24084, "si_lower": 24085, "si_meminfo": 24086, "si_overrun": 24087, "si_pid": 24088, "si_private": 24089, "si_ptr": 24090, "si_signo": 24091, "si_status": 24092, "si_stime": 24093, "si_swapinfo": 24094, "si_sys_private": 24095, "si_syscall": 24096, "si_tid": 24097, "si_timer": 24098, "si_tkill": 24099, "si_trapno": 24100, "si_uid": 24101, "si_upper": 24102, "si_user": 24103, "si_utime": 24104, "si_value": 24105, "sibling": 24106, "sibling_list": 24107, "sibling_only": 24108, "siblings": 24109, "sid": 24110, "sig": 24111, "sig_block": 24112, "sig_data": 24113, "sig_dfl": 24114, "sig_enforce": 24115, "sig_fatal": 24116, "sig_handler": 24117, "sig_handler_ignored": 24118, "sig_ign": 24119, "sig_ignored": 24120, "sig_kernel_coredump": 24121, "sig_kernel_ignore": 24122, "sig_kernel_only": 24123, "sig_kernel_stop": 24124, "sig_kernel_stop_mask": 24125, "sig_len": 24126, "sig_ok": 24127, "sig_setmask": 24128, "sig_task_ignored": 24129, "sig_unblock": 24130, "sigaction": 24131, "sigaddset": 24132, "sigaddsetmask": 24133, "sigalrm": 24134, "sigaltstack": 24135, "sigandnsets": 24136, "sigandsets": 24137, "sigbus": 24138, "sigchld": 24139, "sigcnt": 24140, "sigcont": 24141, "sigdelset": 24142, "sigdelsetmask": 24143, "sigemptyset": 24144, "sigev_none": 24145, "sigev_notify": 24146, "sigev_notify_thread_id": 24147, "sigev_signal": 24148, "sigev_signo": 24149, "sigev_thread": 24150, "sigev_thread_id": 24151, "sigev_value": 24152, "sigevent": 24153, "sigevent_t": 24154, "sigfpe": 24155, "sigh": 24156, "sighand": 24157, "sighand_cachep": 24158, "sighand_ctor": 24159, "sighand_struct": 24160, "sighup": 24161, "sigill": 24162, "siginfo": 24163, "siginfo_t": 24164, "siginitset": 24165, "sigint": 24166, "sigio": 24167, "sigisemptyset": 24168, "sigismember": 24169, "sigkill": 24170, "sigkill_pending": 24171, "siglock": 24172, "sigmask": 24173, "sign": 24174, "signal": 24175, "signal_cachep": 24176, "signal_cld_continued": 24177, "signal_cld_mask": 24178, "signal_cld_stopped": 24179, "signal_delivered": 24180, "signal_group_coredump": 24181, "signal_group_exit": 24182, "signal_pending": 24183, "signal_pending_state": 24184, "signal_pt_regs": 24185, "signal_setup_done": 24186, "signal_stop_continued": 24187, "signal_stop_stopped": 24188, "signal_struct": 24189, "signal_unkillable": 24190, "signal_wake_up": 24191, "signal_wake_up_state": 24192, "signalfd_cleanup": 24193, "signalfd_notify": 24194, "signalfd_wqh": 24195, "signals": 24196, "signals_init": 24197, "signed": 24198, "signer": 24199, "signer_len": 24200, "signo": 24201, "signotset": 24202, "signr": 24203, "sigorsets": 24204, "sigpending": 24205, "sigprocmask": 24206, "sigq": 24207, "sigqueue": 24208, "sigqueue_alloc": 24209, "sigqueue_cachep": 24210, "sigqueue_free": 24211, "sigqueue_prealloc": 24212, "sigquit": 24213, "sigrtmax": 24214, "sigrtmin": 24215, "sigsegv": 24216, "sigset_from_compat": 24217, "sigset_t": 24218, "sigset_to_compat": 24219, "sigsetsize": 24220, "sigstop": 24221, "sigsuspend": 24222, "sigsys": 24223, "sigterm": 24224, "sigtrap": 24225, "sigusr1": 24226, "sigusr2": 24227, "simple": 24228, "simple_align_resource": 24229, "simple_open": 24230, "simple_read_from_buffer": 24231, "simple_strtol": 24232, "simple_strtoul": 24233, "simplify_symbols": 24234, "simulate": 24235, "single_depth_nesting": 24236, "single_open": 24237, "single_release": 24238, "single_task_running": 24239, "sival_int": 24240, "sixty": 24241, "size": 24242, "size_bits": 24243, "size_buf": 24244, "size_t": 24245, "sizeof": 24246, "sizeof_trace_entry": 24247, "sizeof_trace_kprobe": 24248, "sizeof_trace_uprobe": 24249, "sizeop": 24250, "sk": 24251, "sk_buff": 24252, "sk_buff_head": 24253, "sk_sndtimeo": 24254, "skb": 24255, "skb_clone": 24256, "skb_copy": 24257, "skb_copy_bits": 24258, "skb_cur": 24259, "skb_dequeue": 24260, "skb_get": 24261, "skb_mac_header": 24262, "skb_network_header": 24263, "skb_next": 24264, "skb_put": 24265, "skb_queue_head_init": 24266, "skb_queue_len": 24267, "skb_queue_purge": 24268, "skb_queue_tail": 24269, "skb_tail_pointer": 24270, "skb_tailroom": 24271, "skbp": 24272, "skew": 24273, "skew_prefix": 24274, "skew_tick": 24275, "skf_ll_off": 24276, "skf_net_off": 24277, "skip": 24278, "skip_full_check": 24279, "skip_it": 24280, "skip_lines": 24281, "skip_more": 24282, "skip_spaces": 24283, "skip_time_extend": 24284, "skip_wait": 24285, "skipped_entries": 24286, "sl": 24287, "slab_destroy_by_rcu": 24288, "slab_hwcache_align": 24289, "slab_is_available": 24290, "slab_notrack": 24291, "slab_panic": 24292, "slack": 24293, "slack_hz": 24294, "slack_runtime": 24295, "slack_timer": 24296, "slaves_in_kgdb": 24297, "sleep": 24298, "sleep_jf": 24299, "sleep_length": 24300, "sleep_max": 24301, "sleep_profiling": 24302, "sleep_start": 24303, "sleep_time": 24304, "sleep_time_bin": 24305, "sleep_usecs": 24306, "sleeping_thread_to_gdb_regs": 24307, "sleeptime_injected": 24308, "slen": 24309, "slice": 24310, "slice_max": 24311, "sln": 24312, "slot": 24313, "slot_addr": 24314, "slot_clean": 24315, "slot_count": 24316, "slot_dirty": 24317, "slot_nr": 24318, "slot_type": 24319, "slot_used": 24320, "slots_per_page": 24321, "slow_acct_process": 24322, "slow_read_ctr": 24323, "slowpath_args": 24324, "slows": 24325, "sm_ref": 24326, "small_event_size": 24327, "smp_announce": 24328, "smp_call_func_t": 24329, "smp_call_function": 24330, "smp_call_function_any": 24331, "smp_call_function_many": 24332, "smp_call_function_single": 24333, "smp_call_function_single_async": 24334, "smp_cpus_done": 24335, "smp_debug_locks_warn_on": 24336, "smp_hotplug_thread": 24337, "smp_load_acquire": 24338, "smp_mb": 24339, "smp_mb__after_atomic": 24340, "smp_mb__after_unlock_lock": 24341, "smp_mb__before_atomic": 24342, "smp_mb__before_spinlock": 24343, "smp_processor_id": 24344, "smp_read_barrier_depends": 24345, "smp_rmb": 24346, "smp_send_reschedule": 24347, "smp_store_release": 24348, "smp_wmb": 24349, "smpboot_create_threads": 24350, "smpboot_destroy_threads": 24351, "smpboot_h": 24352, "smpboot_park_thread": 24353, "smpboot_park_threads": 24354, "smpboot_register_percpu_thread": 24355, "smpboot_thread_call": 24356, "smpboot_thread_data": 24357, "smpboot_thread_fn": 24358, "smpboot_thread_init": 24359, "smpboot_thread_notifier": 24360, "smpboot_threads_lock": 24361, "smpboot_unpark_thread": 24362, "smpboot_unpark_threads": 24363, "smpboot_unregister_percpu_thread": 24364, "smt": 24365, "smt_gain": 24366, "sname": 24367, "snap": 24368, "snap_done": 24369, "snapshot": 24370, "snapshot_additional_pages": 24371, "snapshot_alloc_swap_page": 24372, "snapshot_atomic_restore": 24373, "snapshot_avail_swap_size": 24374, "snapshot_compat_ioctl": 24375, "snapshot_count_trigger": 24376, "snapshot_count_trigger_ops": 24377, "snapshot_create_image": 24378, "snapshot_data": 24379, "snapshot_device": 24380, "snapshot_device_available": 24381, "snapshot_device_init": 24382, "snapshot_fops": 24383, "snapshot_free": 24384, "snapshot_freeze": 24385, "snapshot_get_image_size": 24386, "snapshot_get_trigger_ops": 24387, "snapshot_handle": 24388, "snapshot_image_loaded": 24389, "snapshot_ioc_magic": 24390, "snapshot_ioc_maxnr": 24391, "snapshot_ioctl": 24392, "snapshot_minor": 24393, "snapshot_open": 24394, "snapshot_platform_support": 24395, "snapshot_power_off": 24396, "snapshot_pref_image_size": 24397, "snapshot_raw": 24398, "snapshot_read": 24399, "snapshot_read_next": 24400, "snapshot_release": 24401, "snapshot_s2ram": 24402, "snapshot_set_swap_area": 24403, "snapshot_state": 24404, "snapshot_trigger": 24405, "snapshot_trigger_ops": 24406, "snapshot_trigger_print": 24407, "snapshot_unfreeze": 24408, "snapshot_write": 24409, "snapshot_write_finalize": 24410, "snapshot_write_next": 24411, "snd_portid": 24412, "snode": 24413, "snprint_stack_trace": 24414, "snprintf": 24415, "sock": 24416, "sock_filter": 24417, "sock_fprog": 24418, "sock_net": 24419, "sockaddr": 24420, "sockaddr_len": 24421, "sockaddr_storage": 24422, "socketcall": 24423, "soft": 24424, "soft_disable": 24425, "soft_lockup_hrtimer_cnt": 24426, "soft_lockup_nmi_warn": 24427, "soft_watchdog_enabled": 24428, "soft_watchdog_enabled_bit": 24429, "soft_watchdog_warn": 24430, "softirq": 24431, "softirq_action": 24432, "softirq_bit": 24433, "softirq_context": 24434, "softirq_count": 24435, "softirq_disable_event": 24436, "softirq_disable_ip": 24437, "softirq_disable_offset": 24438, "softirq_enable_event": 24439, "softirq_enable_ip": 24440, "softirq_init": 24441, "softirq_lock_offset": 24442, "softirq_mask": 24443, "softirq_offset": 24444, "softirq_shift": 24445, "softirq_snap": 24446, "softirq_threads": 24447, "softirq_to_name": 24448, "softirq_vec": 24449, "softirq_verbose": 24450, "softirqs_enabled": 24451, "softirqs_off_events": 24452, "softirqs_on_events": 24453, "softlockup_all_cpu_backtrace": 24454, "softlockup_panic": 24455, "softlockup_task_ptr_saved": 24456, "softlockup_touch_sync": 24457, "softlockup_watchdog": 24458, "software": 24459, "software_resume": 24460, "some": 24461, "sort": 24462, "sort_extable": 24463, "sort_main_extable": 24464, "source": 24465, "source_entry": 24466, "source_list": 24467, "source_load": 24468, "sp": 24469, "sp_list": 24470, "space": 24471, "spaces": 24472, "span": 24473, "span_weight": 24474, "spanned_pages": 24475, "spare_pages": 24476, "sparse_irq_lock": 24477, "spawn_ksoftirqd": 24478, "special": 24479, "specific_send_sig_info": 24480, "specified": 24481, "spilled_regs": 24482, "spin": 24483, "spin_acquire": 24484, "spin_acquire_nest": 24485, "spin_bug": 24486, "spin_bug_on": 24487, "spin_dump": 24488, "spin_is_locked": 24489, "spin_lock": 24490, "spin_lock_bh": 24491, "spin_lock_init": 24492, "spin_lock_irq": 24493, "spin_lock_irq_ops": 24494, "spin_lock_irqsave": 24495, "spin_lock_mutex": 24496, "spin_lock_nested": 24497, "spin_lock_ops": 24498, "spin_msec": 24499, "spin_needbreak": 24500, "spin_release": 24501, "spin_retry": 24502, "spin_trylock": 24503, "spin_trylock_bh": 24504, "spin_unlock": 24505, "spin_unlock_bh": 24506, "spin_unlock_irq": 24507, "spin_unlock_irqrestore": 24508, "spin_unlock_mutex": 24509, "spincnt": 24510, "spinlock_magic": 24511, "spinlock_owner_init": 24512, "spinlock_size": 24513, "spinlock_t": 24514, "splice_pipe": 24515, "splice_read": 24516, "split_ns": 24517, "split_page": 24518, "split_rss_counting": 24519, "spread": 24520, "spread0": 24521, "spread_flag_changed": 24522, "sprint_backtrace": 24523, "sprint_symbol": 24524, "sprint_symbol_no_offset": 24525, "sprintf": 24526, "spurious_deferred": 24527, "squeue": 24528, "sr1": 24529, "sr2": 24530, "src": 24531, "src_capacity": 24532, "src_cfs_rq": 24533, "src_cgrp": 24534, "src_cpu": 24535, "src_cset": 24536, "src_csets": 24537, "src_load": 24538, "src_nid": 24539, "src_op": 24540, "src_reg": 24541, "src_reg_type": 24542, "src_root": 24543, "src_rq": 24544, "src_stats": 24545, "src_task": 24546, "src_tree": 24547, "srctree": 24548, "srcu": 24549, "srcu_advance_batches": 24550, "srcu_barrier": 24551, "srcu_batches_completed": 24552, "srcu_callback_batch": 24553, "srcu_collect_new": 24554, "srcu_ctl": 24555, "srcu_flavor": 24556, "srcu_flip": 24557, "srcu_init_notifier_head": 24558, "srcu_interval": 24559, "srcu_invoke_callbacks": 24560, "srcu_notifier_call_chain": 24561, "srcu_notifier_chain_register": 24562, "srcu_notifier_chain_unregister": 24563, "srcu_notifier_head": 24564, "srcu_ops": 24565, "srcu_read_delay": 24566, "srcu_read_lock": 24567, "srcu_read_lock_held": 24568, "srcu_read_unlock": 24569, "srcu_readers_active": 24570, "srcu_readers_active_idx": 24571, "srcu_readers_active_idx_check": 24572, "srcu_readers_seq_idx": 24573, "srcu_reschedule": 24574, "srcu_retry_check_delay": 24575, "srcu_struct": 24576, "srcu_struct_array": 24577, "srcu_torture_barrier": 24578, "srcu_torture_call": 24579, "srcu_torture_completed": 24580, "srcu_torture_deferred_free": 24581, "srcu_torture_read_lock": 24582, "srcu_torture_read_unlock": 24583, "srcu_torture_stats": 24584, "srcu_torture_synchronize": 24585, "srcu_torture_synchronize_expedited": 24586, "srcversion": 24587, "ss": 24588, "ss_disable": 24589, "ss_flags": 24590, "ss_mask": 24591, "ss_onstack": 24592, "ss_size": 24593, "ss_sp": 24594, "ssbpt": 24595, "sscanf": 24596, "ssecs": 24597, "ssetmask": 24598, "ssid": 24599, "ssize_t": 24600, "ssleep": 24601, "sstep_cpu": 24602, "sstep_tries": 24603, "st": 24604, "st_info": 24605, "st_l": 24606, "st_mem_": 24607, "st_mem_b": 24608, "st_mem_dw": 24609, "st_mem_h": 24610, "st_mem_w": 24611, "st_name": 24612, "st_shndx": 24613, "st_size": 24614, "st_t": 24615, "st_value": 24616, "sta_clockerr": 24617, "sta_freqhold": 24618, "sta_mode": 24619, "sta_nano": 24620, "sta_pll": 24621, "sta_ppserror": 24622, "sta_ppsfreq": 24623, "sta_ppsjitter": 24624, "sta_ppssignal": 24625, "sta_ppstime": 24626, "sta_ppswander": 24627, "sta_ronly": 24628, "sta_unsync": 24629, "stabil": 24630, "stack": 24631, "stack_canary": 24632, "stack_dump_index": 24633, "stack_dump_trace": 24634, "stack_end_magic": 24635, "stack_entry": 24636, "stack_invalid": 24637, "stack_max_size": 24638, "stack_max_size_fops": 24639, "stack_max_size_read": 24640, "stack_max_size_write": 24641, "stack_misc": 24642, "stack_node": 24643, "stack_relative": 24644, "stack_size": 24645, "stack_skip": 24646, "stack_slot_type": 24647, "stack_spill": 24648, "stack_start": 24649, "stack_sysctl_mutex": 24650, "stack_t": 24651, "stack_trace": 24652, "stack_trace_entries": 24653, "stack_trace_filter": 24654, "stack_trace_filter_buf": 24655, "stack_trace_filter_fops": 24656, "stack_trace_filter_open": 24657, "stack_trace_fops": 24658, "stack_trace_init": 24659, "stack_trace_open": 24660, "stack_trace_seq_ops": 24661, "stack_trace_sysctl": 24662, "stack_tracer_enabled": 24663, "stack_user_size": 24664, "stack_vm": 24665, "stackend": 24666, "stacktrace": 24667, "stacktrace_count_probe_ops": 24668, "stacktrace_count_trigger": 24669, "stacktrace_count_trigger_ops": 24670, "stacktrace_get_trigger_ops": 24671, "stacktrace_probe_ops": 24672, "stacktrace_trigger": 24673, "stacktrace_trigger_ops": 24674, "stacktrace_trigger_print": 24675, "stall": 24676, "stall_cpu": 24677, "stall_cpu_holdoff": 24678, "stall_task": 24679, "stamp": 24680, "standard_param_def": 24681, "standby": 24682, "start": 24683, "start_addr": 24684, "start_bandwidth_timer": 24685, "start_branch_trace": 24686, "start_brk": 24687, "start_cfs_slack_bandwidth": 24688, "start_code": 24689, "start_comm": 24690, "start_critical_timing": 24691, "start_critical_timings": 24692, "start_data": 24693, "start_debit": 24694, "start_flush_work": 24695, "start_func": 24696, "start_func_tracer": 24697, "start_graph_tracing": 24698, "start_index": 24699, "start_irqsoff_tracer": 24700, "start_lba": 24701, "start_lock": 24702, "start_pfn": 24703, "start_pg": 24704, "start_pid": 24705, "start_rt_bandwidth": 24706, "start_sect": 24707, "start_site": 24708, "start_stack": 24709, "start_time": 24710, "start_tstamp": 24711, "start_txn": 24712, "start_wakeup_tracer": 24713, "started": 24714, "startf": 24715, "starting_runtime": 24716, "starttime": 24717, "stask": 24718, "stat": 24719, "stat_addr": 24720, "stat_cmp": 24721, "stat_dir": 24722, "stat_headers": 24723, "stat_interval": 24724, "stat_mutex": 24725, "stat_nam": 24726, "stat_next": 24727, "stat_node": 24728, "stat_release": 24729, "stat_root": 24730, "stat_seq_init": 24731, "stat_seq_next": 24732, "stat_seq_show": 24733, "stat_seq_start": 24734, "stat_seq_stop": 24735, "stat_session": 24736, "stat_show": 24737, "stat_start": 24738, "state": 24739, "state_filter": 24740, "state_list_mark": 24741, "state_name": 24742, "state_names": 24743, "state_rcu_head_queued": 24744, "state_rcu_head_ready": 24745, "state_show": 24746, "state_to_char": 24747, "state_use_accessors": 24748, "state_verbose": 24749, "state_verbose_f": 24750, "states": 24751, "states_equal": 24752, "static": 24753, "static_branch_": 24754, "static_key": 24755, "static_key_": 24756, "static_key_check_use": 24757, "static_key_deferred": 24758, "static_key_enabled": 24759, "static_key_false": 24760, "static_key_init": 24761, "static_key_init_false": 24762, "static_key_initialized": 24763, "static_key_mod": 24764, "static_key_slow_dec": 24765, "static_key_slow_dec_deferred": 24766, "static_key_slow_inc": 24767, "static_lockdep_map_init": 24768, "static_obj": 24769, "static_prio": 24770, "statistics": 24771, "statp": 24772, "stats": 24773, "stats_lock": 24774, "stats_task": 24775, "status": 24776, "status_use_accessors": 24777, "statusp": 24778, "stb_weak": 24779, "stbcnt": 24780, "std": 24781, "std_nice": 24782, "stddev": 24783, "steal": 24784, "steal_account_process_tick": 24785, "steal_ct": 24786, "stepping": 24787, "still_pending": 24788, "stime": 24789, "stimescaled": 24790, "stmt": 24791, "stop": 24792, "stop_a_enabled": 24793, "stop_at": 24794, "stop_branch_trace": 24795, "stop_count": 24796, "stop_cpus": 24797, "stop_cpus_lock": 24798, "stop_cpus_mutex": 24799, "stop_cpus_work": 24800, "stop_critical_timing": 24801, "stop_critical_timings": 24802, "stop_func_tracer": 24803, "stop_irqsoff_tracer": 24804, "stop_machine": 24805, "stop_machine_from_inactive_cpu": 24806, "stop_machine_initialized": 24807, "stop_one_cpu": 24808, "stop_one_cpu_nowait": 24809, "stop_sched_class": 24810, "stop_trace_on_warning": 24811, "stop_two_cpus": 24812, "stop_wakeup_tracer": 24813, "stopper": 24814, "store": 24815, "store_cpumask": 24816, "store_gcov_u32": 24817, "store_gcov_u64": 24818, "store_stacktrace": 24819, "store_trace_args": 24820, "store_uevent": 24821, "stp": 24822, "str": 24823, "str_item": 24824, "str_len": 24825, "str_loc": 24826, "strcat": 24827, "strchr": 24828, "strcmp": 24829, "strcpy": 24830, "strcspn": 24831, "stream_id": 24832, "strict_iomem": 24833, "strict_iomem_checks": 24834, "strict_read_checks": 24835, "strim": 24836, "string": 24837, "string_size": 24838, "strlcpy": 24839, "strlen": 24840, "strncasecmp": 24841, "strncat": 24842, "strncmp": 24843, "strncpy": 24844, "strncpy_from_user": 24845, "strndup_user": 24846, "strnlen_user": 24847, "strnstr": 24848, "stroffs": 24849, "strong_try_module_get": 24850, "strpbrk": 24851, "strrchr": 24852, "strsect": 24853, "strsep": 24854, "strstarts": 24855, "strstr": 24856, "strstrip": 24857, "strtab": 24858, "strtab_size": 24859, "strtobool": 24860, "strtolfn": 24861, "struct": 24862, "struct_name": 24863, "stt_object": 24864, "stub_timer": 24865, "stutter": 24866, "stutter_pause_test": 24867, "stutter_task": 24868, "stutter_wait": 24869, "stx_mem_": 24870, "stx_mem_b": 24871, "stx_mem_dw": 24872, "stx_mem_h": 24873, "stx_mem_w": 24874, "stx_xadd_dw": 24875, "stx_xadd_w": 24876, "sub": 24877, "sub_info": 24878, "sub_nr_running": 24879, "subbuf": 24880, "subbuf_start": 24881, "subclass": 24882, "subkeys": 24883, "submit": 24884, "submit_bio": 24885, "subprocess_info": 24886, "subscribers": 24887, "subset": 24888, "subset_ns": 24889, "subsys": 24890, "subsys_initcall": 24891, "subsys_mask": 24892, "subsys_system_register": 24893, "subsys_virtual_register": 24894, "subsystem": 24895, "subsystem_filter_read": 24896, "subsystem_filter_write": 24897, "subsystem_open": 24898, "subsystem_release": 24899, "subsystems": 24900, "subtime": 24901, "subtract_blocked_load_contrib": 24902, "subtract_range": 24903, "subtree_control": 24904, "success": 24905, "suffix": 24906, "suffix_high": 24907, "suffix_low": 24908, "suffix_null": 24909, "suffix_tbl": 24910, "suid": 24911, "suid_dump_disable": 24912, "suid_dump_root": 24913, "suid_dump_user": 24914, "suid_dumpable": 24915, "suidp": 24916, "sum": 24917, "sum_exec_runtime": 24918, "sum_forward_deps": 24919, "sum_nr_running": 24920, "sum_offline": 24921, "sum_online": 24922, "sum_sched_runtime": 24923, "sum_sleep_runtime": 24924, "sum_weighted_load": 24925, "super_block": 24926, "supported": 24927, "suppress": 24928, "suspend": 24929, "suspend_console": 24930, "suspend_device_irq": 24931, "suspend_device_irqs": 24932, "suspend_devices_and_enter": 24933, "suspend_enter": 24934, "suspend_freeze_processes": 24935, "suspend_resume": 24936, "suspend_state_t": 24937, "suspend_test_finish": 24938, "suspend_test_start": 24939, "suspend_test_start_time": 24940, "suspend_thaw_processes": 24941, "suspend_type": 24942, "suspend_work": 24943, "suspending": 24944, "swahw32": 24945, "swap": 24946, "swap_area": 24947, "swap_free": 24948, "swap_map_handle": 24949, "swap_map_page": 24950, "swap_map_page_list": 24951, "swap_offset": 24952, "swap_page": 24953, "swap_read_page": 24954, "swap_reader_finish": 24955, "swap_type_of": 24956, "swap_write_page": 24957, "swap_writer_finish": 24958, "swapdev_block": 24959, "swapin_count": 24960, "swapin_delay": 24961, "swapin_delay_total": 24962, "swdev": 24963, "switch": 24964, "switch_count": 24965, "switch_mm": 24966, "switch_task_namespaces": 24967, "switch_to": 24968, "switched": 24969, "switched_from": 24970, "switched_from_fair": 24971, "switched_from_rt": 24972, "switched_to": 24973, "switched_to_fair": 24974, "switched_to_idle": 24975, "switched_to_rt": 24976, "switching": 24977, "swp_entry": 24978, "swp_offset": 24979, "swsusp_alloc": 24980, "swsusp_arch_resume": 24981, "swsusp_arch_suspend": 24982, "swsusp_check": 24983, "swsusp_close": 24984, "swsusp_extent": 24985, "swsusp_extents": 24986, "swsusp_extents_insert": 24987, "swsusp_free": 24988, "swsusp_header": 24989, "swsusp_header_init": 24990, "swsusp_info": 24991, "swsusp_page_is_forbidden": 24992, "swsusp_page_is_free": 24993, "swsusp_read": 24994, "swsusp_resume_block": 24995, "swsusp_resume_device": 24996, "swsusp_save": 24997, "swsusp_set_page_forbidden": 24998, "swsusp_set_page_free": 24999, "swsusp_show_speed": 25000, "swsusp_swap_check": 25001, "swsusp_swap_in_use": 25002, "swsusp_unmark": 25003, "swsusp_unset_page_forbidden": 25004, "swsusp_unset_page_free": 25005, "swsusp_write": 25006, "sym": 25007, "sym_buf": 25008, "sym_end": 25009, "sym_flags": 25010, "sym_name": 25011, "sym_start": 25012, "symaddr": 25013, "symbol": 25014, "symbol_array": 25015, "symbol_cache": 25016, "symbol_end": 25017, "symbol_name": 25018, "symbol_offset": 25019, "symbol_put_addr": 25020, "symbol_start": 25021, "symbolic": 25022, "symbols": 25023, "symbolsize": 25024, "symname": 25025, "symnum": 25026, "symoffs": 25027, "syms": 25028, "symsearch": 25029, "symsec": 25030, "symsect": 25031, "symtab": 25032, "symtab_p": 25033, "symtab_p2": 25034, "symversion": 25035, "sync": 25036, "sync_cmos_work": 25037, "sync_filesystems": 25038, "sync_rcu_preempt_exp_count": 25039, "sync_rcu_preempt_exp_done": 25040, "sync_rcu_preempt_exp_init1": 25041, "sync_rcu_preempt_exp_init2": 25042, "sync_rcu_preempt_exp_mutex": 25043, "sync_rcu_preempt_exp_wq": 25044, "sync_read": 25045, "synced": 25046, "synchronize_hardirq": 25047, "synchronize_irq": 25048, "synchronize_net": 25049, "synchronize_rcu": 25050, "synchronize_rcu_bh": 25051, "synchronize_rcu_bh_expedited": 25052, "synchronize_rcu_busted": 25053, "synchronize_rcu_expedited": 25054, "synchronize_rcu_tasks": 25055, "synchronize_sched": 25056, "synchronize_sched_expedited": 25057, "synchronize_sched_expedited_cpu_stop": 25058, "synchronize_srcu": 25059, "synchronize_srcu_exp_trycount": 25060, "synchronize_srcu_expedited": 25061, "synchronize_srcu_trycount": 25062, "synchronous_mask": 25063, "syncing": 25064, "synctype": 25065, "sys32_quotactl": 25066, "sys_accept": 25067, "sys_accept4": 25068, "sys_acct": 25069, "sys_add_key": 25070, "sys_bdflush": 25071, "sys_bind": 25072, "sys_bpf": 25073, "sys_capget": 25074, "sys_capset": 25075, "sys_chown": 25076, "sys_chown16": 25077, "sys_clock_adjtime": 25078, "sys_clock_getres": 25079, "sys_clock_gettime": 25080, "sys_clock_nanosleep": 25081, "sys_clock_settime": 25082, "sys_connect": 25083, "sys_data": 25084, "sys_delete_module": 25085, "sys_epoll_create": 25086, "sys_epoll_create1": 25087, "sys_epoll_ctl": 25088, "sys_epoll_pwait": 25089, "sys_epoll_wait": 25090, "sys_eventfd": 25091, "sys_eventfd2": 25092, "sys_execveat": 25093, "sys_fadvise64": 25094, "sys_fadvise64_64": 25095, "sys_fanotify_init": 25096, "sys_fanotify_mark": 25097, "sys_fchown": 25098, "sys_fchown16": 25099, "sys_finit_module": 25100, "sys_flock": 25101, "sys_futex": 25102, "sys_get_mempolicy": 25103, "sys_get_robust_list": 25104, "sys_getegid16": 25105, "sys_geteuid16": 25106, "sys_getgid16": 25107, "sys_getgroups": 25108, "sys_getgroups16": 25109, "sys_getpeername": 25110, "sys_getpgid": 25111, "sys_getresgid": 25112, "sys_getresgid16": 25113, "sys_getresuid": 25114, "sys_getresuid16": 25115, "sys_getsockname": 25116, "sys_getsockopt": 25117, "sys_getuid16": 25118, "sys_halt": 25119, "sys_init_module": 25120, "sys_inotify_add_watch": 25121, "sys_inotify_init": 25122, "sys_inotify_init1": 25123, "sys_inotify_rm_watch": 25124, "sys_io_cancel": 25125, "sys_io_destroy": 25126, "sys_io_getevents": 25127, "sys_io_setup": 25128, "sys_io_submit": 25129, "sys_ioprio_get": 25130, "sys_ioprio_set": 25131, "sys_ipc": 25132, "sys_kcmp": 25133, "sys_kexec_file_load": 25134, "sys_kexec_load": 25135, "sys_keyctl": 25136, "sys_lchown": 25137, "sys_lchown16": 25138, "sys_listen": 25139, "sys_lookup_dcookie": 25140, "sys_madvise": 25141, "sys_mbind": 25142, "sys_memfd_create": 25143, "sys_migrate_pages": 25144, "sys_mincore": 25145, "sys_mlock": 25146, "sys_mlockall": 25147, "sys_move_pages": 25148, "sys_mprotect": 25149, "sys_mq_getsetattr": 25150, "sys_mq_notify": 25151, "sys_mq_open": 25152, "sys_mq_timedreceive": 25153, "sys_mq_timedsend": 25154, "sys_mq_unlink": 25155, "sys_mremap": 25156, "sys_msgctl": 25157, "sys_msgget": 25158, "sys_msgrcv": 25159, "sys_msgsnd": 25160, "sys_msync": 25161, "sys_munlock": 25162, "sys_munlockall": 25163, "sys_name_to_handle_at": 25164, "sys_ni_syscall": 25165, "sys_old_getrlimit": 25166, "sys_open_by_handle_at": 25167, "sys_pciconfig_iobase": 25168, "sys_pciconfig_read": 25169, "sys_pciconfig_write": 25170, "sys_perf_event_open": 25171, "sys_perf_refcount_enter": 25172, "sys_perf_refcount_exit": 25173, "sys_power_off": 25174, "sys_process_vm_readv": 25175, "sys_process_vm_writev": 25176, "sys_quotactl": 25177, "sys_recv": 25178, "sys_recvfrom": 25179, "sys_recvmmsg": 25180, "sys_recvmsg": 25181, "sys_refcount_enter": 25182, "sys_refcount_exit": 25183, "sys_remap_file_pages": 25184, "sys_request_key": 25185, "sys_restart": 25186, "sys_rt_sigpending": 25187, "sys_rt_sigprocmask": 25188, "sys_rt_sigsuspend": 25189, "sys_s390_pci_mmio_read": 25190, "sys_s390_pci_mmio_write": 25191, "sys_sched_yield": 25192, "sys_seccomp": 25193, "sys_semctl": 25194, "sys_semget": 25195, "sys_semop": 25196, "sys_semtimedop": 25197, "sys_send": 25198, "sys_sendmmsg": 25199, "sys_sendmsg": 25200, "sys_sendto": 25201, "sys_set_mempolicy": 25202, "sys_set_robust_list": 25203, "sys_setfsgid": 25204, "sys_setfsgid16": 25205, "sys_setfsuid": 25206, "sys_setfsuid16": 25207, "sys_setgid": 25208, "sys_setgid16": 25209, "sys_setgroups": 25210, "sys_setgroups16": 25211, "sys_setregid": 25212, "sys_setregid16": 25213, "sys_setresgid": 25214, "sys_setresgid16": 25215, "sys_setresuid": 25216, "sys_setresuid16": 25217, "sys_setreuid": 25218, "sys_setreuid16": 25219, "sys_setsockopt": 25220, "sys_setuid": 25221, "sys_setuid16": 25222, "sys_sgetmask": 25223, "sys_shmat": 25224, "sys_shmctl": 25225, "sys_shmdt": 25226, "sys_shmget": 25227, "sys_shutdown": 25228, "sys_signalfd": 25229, "sys_signalfd4": 25230, "sys_sigpending": 25231, "sys_socket": 25232, "sys_socketcall": 25233, "sys_socketpair": 25234, "sys_spu_create": 25235, "sys_spu_run": 25236, "sys_ssetmask": 25237, "sys_subpage_prot": 25238, "sys_swapoff": 25239, "sys_swapon": 25240, "sys_sync": 25241, "sys_sysfs": 25242, "sys_syslog": 25243, "sys_timer_create": 25244, "sys_timer_gettime": 25245, "sys_timer_settime": 25246, "sys_timerfd_create": 25247, "sys_timerfd_gettime": 25248, "sys_timerfd_settime": 25249, "sys_tz": 25250, "sys_uselib": 25251, "sys_vm86": 25252, "sys_vm86old": 25253, "sys_wait4": 25254, "sys_waitid": 25255, "syscall": 25256, "syscall_define0": 25257, "syscall_define1": 25258, "syscall_define2": 25259, "syscall_define3": 25260, "syscall_define4": 25261, "syscall_define5": 25262, "syscall_define6": 25263, "syscall_enter_define_fields": 25264, "syscall_enter_register": 25265, "syscall_exit_define_fields": 25266, "syscall_exit_register": 25267, "syscall_field": 25268, "syscall_get_arch": 25269, "syscall_get_arguments": 25270, "syscall_get_enter_fields": 25271, "syscall_get_nr": 25272, "syscall_get_return_value": 25273, "syscall_metadata": 25274, "syscall_nr": 25275, "syscall_nr_to_meta": 25276, "syscall_rollback": 25277, "syscall_set_return_value": 25278, "syscall_trace_enter": 25279, "syscall_trace_exit": 25280, "syscall_trace_lock": 25281, "syscall_tracepoint_update": 25282, "syscall_whitelist": 25283, "syscalls_metadata": 25284, "syscore_ops": 25285, "syscore_resume": 25286, "syscore_shutdown": 25287, "syscore_suspend": 25288, "syscr": 25289, "sysctl": 25290, "sysctl_": 25291, "sysctl_admin_reserve_kbytes": 25292, "sysctl_base_table": 25293, "sysctl_compact_memory": 25294, "sysctl_compact_unevictable_allowed": 25295, "sysctl_compaction_handler": 25296, "sysctl_drop_caches": 25297, "sysctl_extfrag_handler": 25298, "sysctl_extfrag_threshold": 25299, "sysctl_getname": 25300, "sysctl_hugetlb_shm_group": 25301, "sysctl_hung_task_check_count": 25302, "sysctl_hung_task_panic": 25303, "sysctl_hung_task_timeout_secs": 25304, "sysctl_hung_task_warnings": 25305, "sysctl_ieee_emulation_warnings": 25306, "sysctl_init": 25307, "sysctl_kprobes_optimization": 25308, "sysctl_legacy_va_layout": 25309, "sysctl_lowmem_reserve_ratio": 25310, "sysctl_max_map_count": 25311, "sysctl_max_threads": 25312, "sysctl_memory_failure_early_kill": 25313, "sysctl_memory_failure_recovery": 25314, "sysctl_min_slab_ratio": 25315, "sysctl_min_slab_ratio_sysctl_handler": 25316, "sysctl_min_unmapped_ratio": 25317, "sysctl_min_unmapped_ratio_sysctl_handler": 25318, "sysctl_nr_open": 25319, "sysctl_nr_open_max": 25320, "sysctl_nr_open_min": 25321, "sysctl_nr_trim_pages": 25322, "sysctl_numa_balancing": 25323, "sysctl_numa_balancing_scan_delay": 25324, "sysctl_numa_balancing_scan_period_max": 25325, "sysctl_numa_balancing_scan_period_min": 25326, "sysctl_numa_balancing_scan_size": 25327, "sysctl_oom_dump_tasks": 25328, "sysctl_oom_kill_allocating_task": 25329, "sysctl_overcommit_kbytes": 25330, "sysctl_overcommit_memory": 25331, "sysctl_overcommit_ratio": 25332, "sysctl_panic_on_oom": 25333, "sysctl_panic_on_stackoverflow": 25334, "sysctl_perf_cpu_time_max_percent": 25335, "sysctl_perf_event_mlock": 25336, "sysctl_perf_event_paranoid": 25337, "sysctl_perf_event_sample_rate": 25338, "sysctl_protected_hardlinks": 25339, "sysctl_protected_symlinks": 25340, "sysctl_sched_autogroup_enabled": 25341, "sysctl_sched_cfs_bandwidth_slice": 25342, "sysctl_sched_child_runs_first": 25343, "sysctl_sched_features": 25344, "sysctl_sched_latency": 25345, "sysctl_sched_migration_cost": 25346, "sysctl_sched_min_granularity": 25347, "sysctl_sched_nr_migrate": 25348, "sysctl_sched_rt_period": 25349, "sysctl_sched_rt_runtime": 25350, "sysctl_sched_shares_window": 25351, "sysctl_sched_time_avg": 25352, "sysctl_sched_tunable_scaling": 25353, "sysctl_sched_wakeup_granularity": 25354, "sysctl_softlockup_all_cpu_backtrace": 25355, "sysctl_stat_interval": 25356, "sysctl_timer_migration": 25357, "sysctl_tsb_ratio": 25358, "sysctl_user_reserve_kbytes": 25359, "sysctl_vfs_cache_pressure": 25360, "sysctl_writes_legacy": 25361, "sysctl_writes_strict": 25362, "sysctl_writes_warn": 25363, "syscw": 25364, "sysfs_attr_init": 25365, "sysfs_bin_attr_init": 25366, "sysfs_blk_trace_attr_show": 25367, "sysfs_blk_trace_attr_store": 25368, "sysfs_create_bin_file": 25369, "sysfs_create_file": 25370, "sysfs_create_group": 25371, "sysfs_create_link": 25372, "sysfs_get_uname": 25373, "sysfs_ops": 25374, "sysfs_remove_bin_file": 25375, "sysfs_remove_file": 25376, "sysfs_remove_group": 25377, "sysfs_remove_link": 25378, "sysfs_show_current_tick_dev": 25379, "sysfs_test_command": 25380, "sysfs_test_status": 25381, "sysfs_unbind_tick_dev": 25382, "sysinfo": 25383, "syslog": 25384, "syslog_idx": 25385, "syslog_partial": 25386, "syslog_prev": 25387, "syslog_seq": 25388, "sysname": 25389, "sysrq_dbg_op": 25390, "sysrq_enable_boot": 25391, "sysrq_handle_dbg": 25392, "sysrq_key_op": 25393, "sysrq_poweroff_op": 25394, "sysrq_sched_debug_show": 25395, "sysrq_sysctl_handler": 25396, "sysrq_toggle_support": 25397, "system": 25398, "system_booting": 25399, "system_certificate_list": 25400, "system_certificate_list_size": 25401, "system_enable_read": 25402, "system_enable_write": 25403, "system_entering_hibernation": 25404, "system_fl_free_name": 25405, "system_freezable_power_efficient_wq": 25406, "system_freezable_wq": 25407, "system_freezing_cnt": 25408, "system_halt": 25409, "system_highpri_wq": 25410, "system_long_wq": 25411, "system_power_efficient_wq": 25412, "system_power_off": 25413, "system_ram": 25414, "system_refcount": 25415, "system_refcount_dec": 25416, "system_refcount_inc": 25417, "system_restart": 25418, "system_running": 25419, "system_state": 25420, "system_states": 25421, "system_tr_open": 25422, "system_trusted_keyring": 25423, "system_trusted_keyring_init": 25424, "system_unbound_wq": 25425, "system_wq": 25426, "systems": 25427, "sysvsem": 25428, "sz": 25429, "t": 25430, "t0": 25431, "t1": 25432, "t2": 25433, "t3": 25434, "t_action": 25435, "t_bytes": 25436, "t_error": 25437, "t_hash": 25438, "t_hash_next": 25439, "t_hash_show": 25440, "t_hash_start": 25441, "t_next": 25442, "t_sec": 25443, "t_sector": 25444, "t_show": 25445, "t_start": 25446, "t_stop": 25447, "t_uid": 25448, "table": 25449, "table_lock": 25450, "tablep": 25451, "tag": 25452, "tag_chunk": 25453, "tag_mount": 25454, "tagged": 25455, "taglen": 25456, "tai": 25457, "tai_offset": 25458, "tail": 25459, "tail_page": 25460, "taint": 25461, "taint_bad_page": 25462, "taint_cpu_out_of_spec": 25463, "taint_crap": 25464, "taint_die": 25465, "taint_firmware_workaround": 25466, "taint_forced_module": 25467, "taint_forced_rmmod": 25468, "taint_livepatch": 25469, "taint_machine_check": 25470, "taint_oot_module": 25471, "taint_overridden_acpi_table": 25472, "taint_proprietary_module": 25473, "taint_softlockup": 25474, "taint_unsigned_module": 25475, "taint_user": 25476, "taint_warn": 25477, "tainted_mask": 25478, "taints": 25479, "take_cpu_down": 25480, "take_cpu_down_param": 25481, "taken": 25482, "takeover_tasklets": 25483, "takes": 25484, "targ": 25485, "target": 25486, "target2": 25487, "target_attrs": 25488, "target_auid": 25489, "target_comm": 25490, "target_cpu": 25491, "target_entry": 25492, "target_entry1": 25493, "target_list": 25494, "target_load": 25495, "target_pid": 25496, "target_rq": 25497, "target_sessionid": 25498, "target_sid": 25499, "target_uid": 25500, "target_value": 25501, "tarray": 25502, "task": 25503, "task1": 25504, "task2": 25505, "task_active_pid_ns": 25506, "task_ca": 25507, "task_can_attach": 25508, "task_capacity": 25509, "task_cfs_rq": 25510, "task_cgroup_from_root": 25511, "task_cgroup_path": 25512, "task_clear_jobctl_pending": 25513, "task_clear_jobctl_trapping": 25514, "task_clear_spread_page": 25515, "task_clear_spread_slab": 25516, "task_comm_len": 25517, "task_contributes_to_load": 25518, "task_cpu": 25519, "task_cputime": 25520, "task_cputime_adjusted": 25521, "task_cputime_scaled": 25522, "task_creation": 25523, "task_cred_xxx": 25524, "task_cs": 25525, "task_css": 25526, "task_css_check": 25527, "task_css_is_root": 25528, "task_css_set": 25529, "task_ctx": 25530, "task_ctx_data": 25531, "task_ctx_nr": 25532, "task_ctx_sched_out": 25533, "task_ctx_size": 25534, "task_curr": 25535, "task_current": 25536, "task_dead": 25537, "task_delay_info": 25538, "task_delta": 25539, "task_event": 25540, "task_exit_notifier": 25541, "task_faults": 25542, "task_faults_idx": 25543, "task_fork": 25544, "task_fork_fair": 25545, "task_frag": 25546, "task_free_notifier": 25547, "task_freezer": 25548, "task_function_call": 25549, "task_group": 25550, "task_group_account_field": 25551, "task_group_is_autogroup": 25552, "task_group_lock": 25553, "task_group_path": 25554, "task_groups": 25555, "task_gtime": 25556, "task_h_load": 25557, "task_handoff_register": 25558, "task_handoff_unregister": 25559, "task_has_dl_policy": 25560, "task_has_mempolicy": 25561, "task_has_pi_waiters": 25562, "task_has_rt_policy": 25563, "task_hot": 25564, "task_interruptible": 25565, "task_io_accounting_init": 25566, "task_io_get_inblock": 25567, "task_io_get_oublock": 25568, "task_is_stopped": 25569, "task_is_stopped_or_traced": 25570, "task_is_traced": 25571, "task_killable": 25572, "task_list": 25573, "task_lock": 25574, "task_move_group": 25575, "task_move_group_fair": 25576, "task_nice": 25577, "task_no_new_privs": 25578, "task_node": 25579, "task_normal": 25580, "task_nr_scan_windows": 25581, "task_numa_assign": 25582, "task_numa_compare": 25583, "task_numa_env": 25584, "task_numa_fault": 25585, "task_numa_find_cpu": 25586, "task_numa_free": 25587, "task_numa_group": 25588, "task_numa_group_id": 25589, "task_numa_migrate": 25590, "task_numa_placement": 25591, "task_numa_work": 25592, "task_of": 25593, "task_on_rq_migrating": 25594, "task_on_rq_queued": 25595, "task_parked": 25596, "task_participate_group_stop": 25597, "task_pgrp": 25598, "task_pid": 25599, "task_pid_nr": 25600, "task_pid_nr_ns": 25601, "task_pid_vnr": 25602, "task_pos": 25603, "task_ppid_nr": 25604, "task_pt_regs": 25605, "task_rlimit": 25606, "task_rlimit_max": 25607, "task_rq": 25608, "task_rq_lock": 25609, "task_rq_unlock": 25610, "task_running": 25611, "task_scan_max": 25612, "task_scan_min": 25613, "task_sched_runtime": 25614, "task_session": 25615, "task_set_jobctl_pending": 25616, "task_set_no_new_privs": 25617, "task_set_spread_page": 25618, "task_set_spread_slab": 25619, "task_size": 25620, "task_sleep": 25621, "task_stack_end_corrupted": 25622, "task_state_change": 25623, "task_state_char": 25624, "task_state_to_char_str": 25625, "task_stopped": 25626, "task_struct": 25627, "task_struct_cachep": 25628, "task_tgid": 25629, "task_tgid_nr": 25630, "task_tgid_nr_ns": 25631, "task_tgid_vnr": 25632, "task_thread_info": 25633, "task_tick": 25634, "task_tick_fair": 25635, "task_tick_idle": 25636, "task_tick_numa": 25637, "task_tick_rt": 25638, "task_top_pi_waiter": 25639, "task_traced": 25640, "task_uid": 25641, "task_uninterruptible": 25642, "task_unlock": 25643, "task_user_regset_view": 25644, "task_waking": 25645, "task_waking_fair": 25646, "task_wants_autogroup": 25647, "task_weight": 25648, "task_woken": 25649, "task_woken_rt": 25650, "task_work_add": 25651, "task_work_cancel": 25652, "task_work_func_t": 25653, "task_work_run": 25654, "task_works": 25655, "taskimp": 25656, "tasklet": 25657, "tasklet_action": 25658, "tasklet_hi_action": 25659, "tasklet_hi_schedule": 25660, "tasklet_hi_vec": 25661, "tasklet_hrtimer": 25662, "tasklet_hrtimer_init": 25663, "tasklet_init": 25664, "tasklet_kill": 25665, "tasklet_kill_immediate": 25666, "tasklet_schedule": 25667, "tasklet_softirq": 25668, "tasklet_state_run": 25669, "tasklet_state_sched": 25670, "tasklet_struct": 25671, "tasklet_trylock": 25672, "tasklet_unlock": 25673, "tasklet_unlock_wait": 25674, "tasklet_vec": 25675, "tasklist_lock": 25676, "tasks": 25677, "tasks_frozen": 25678, "tasks_head": 25679, "tasks_ops": 25680, "tasks_rcu_exit_srcu": 25681, "tasks_timeline": 25682, "tasks_torture_read_lock": 25683, "tasks_torture_read_unlock": 25684, "taskstats": 25685, "taskstats_cache": 25686, "taskstats_cmd_attr_deregister_cpumask": 25687, "taskstats_cmd_attr_max": 25688, "taskstats_cmd_attr_pid": 25689, "taskstats_cmd_attr_register_cpumask": 25690, "taskstats_cmd_attr_tgid": 25691, "taskstats_cmd_get": 25692, "taskstats_cmd_get_policy": 25693, "taskstats_cmd_new": 25694, "taskstats_cpumask_maxlen": 25695, "taskstats_exit": 25696, "taskstats_genl_name": 25697, "taskstats_genl_version": 25698, "taskstats_init": 25699, "taskstats_init_early": 25700, "taskstats_needs_padding": 25701, "taskstats_ops": 25702, "taskstats_packet_size": 25703, "taskstats_seqnum": 25704, "taskstats_tgid_alloc": 25705, "taskstats_tgid_free": 25706, "taskstats_type_pid": 25707, "taskstats_type_tgid": 25708, "taskstats_user_cmd": 25709, "taskstats_version": 25710, "taskweight": 25711, "tb": 25712, "tb_fmt": 25713, "tbase_get_base": 25714, "tbase_get_deferrable": 25715, "tbase_get_irqsafe": 25716, "tbl": 25717, "tbl_data": 25718, "tbl_size": 25719, "tbuf": 25720, "tc": 25721, "tcd_param": 25722, "tconv": 25723, "tcred": 25724, "td": 25725, "tdata": 25726, "te_blk_io_trace": 25727, "tell_cpu_to_push": 25728, "temp_attr": 25729, "temp_end": 25730, "temp_num": 25731, "temp_start": 25732, "template": 25733, "ten_thousand": 25734, "test": 25735, "test_and_clear_bit": 25736, "test_and_set_bit": 25737, "test_bit": 25738, "test_boost": 25739, "test_boost_duration": 25740, "test_boost_interval": 25741, "test_callback": 25742, "test_core": 25743, "test_cpus": 25744, "test_devices": 25745, "test_enable_data": 25746, "test_filter_data": 25747, "test_filter_data_t": 25748, "test_first": 25749, "test_freezer": 25750, "test_func": 25751, "test_kprobe": 25752, "test_malloc": 25753, "test_max": 25754, "test_mutex": 25755, "test_no_idle_hz": 25756, "test_none": 25757, "test_opcodes": 25758, "test_platform": 25759, "test_pred_visited": 25760, "test_pred_visited_fn": 25761, "test_probe1": 25762, "test_probe2": 25763, "test_probe3": 25764, "test_rec_ops_needs_regs": 25765, "test_rec_probe": 25766, "test_recsafe_probe": 25767, "test_regs_probe": 25768, "test_repeat_count_current": 25769, "test_repeat_count_max": 25770, "test_ringbuffer": 25771, "test_spinlock": 25772, "test_spinlock_irq": 25773, "test_state": 25774, "test_state_label": 25775, "test_suspend": 25776, "test_suspend_seconds": 25777, "test_taint": 25778, "test_thread": 25779, "test_thread_data": 25780, "test_thread_flag": 25781, "test_time_stamp": 25782, "test_tsk_need_resched": 25783, "test_tsk_trace_trace": 25784, "test_type": 25785, "test_wakealarm": 25786, "test_walk_pred_cb": 25787, "test_work": 25788, "text_len": 25789, "text_mutex": 25790, "text_size": 25791, "tfc": 25792, "tfm": 25793, "tg": 25794, "tg_cfs_bandwidth": 25795, "tg_cfs_schedulable_down": 25796, "tg_contrib": 25797, "tg_get_cfs_period": 25798, "tg_get_cfs_quota": 25799, "tg_has_rt_tasks": 25800, "tg_load_contrib": 25801, "tg_nop": 25802, "tg_rt_schedulable": 25803, "tg_runnable_contrib": 25804, "tg_set_cfs_bandwidth": 25805, "tg_set_cfs_period": 25806, "tg_set_cfs_quota": 25807, "tg_set_rt_bandwidth": 25808, "tg_throttle_down": 25809, "tg_unthrottle_up": 25810, "tg_visitor": 25811, "tg_weight": 25812, "tgid": 25813, "tgstime": 25814, "tgutime": 25815, "than": 25816, "that": 25817, "that_cpu": 25818, "thaw": 25819, "thaw_kernel_threads": 25820, "thaw_processes": 25821, "thaw_workqueues": 25822, "the": 25823, "these": 25824, "third": 25825, "this": 25826, "this_clock": 25827, "this_cpu": 25828, "this_cpu_cpumask_var_ptr": 25829, "this_cpu_dec": 25830, "this_cpu_inc": 25831, "this_cpu_inc_return": 25832, "this_cpu_ksoftirqd": 25833, "this_cpu_ptr": 25834, "this_cpu_read": 25835, "this_cpu_write": 25836, "this_cpupid": 25837, "this_css": 25838, "this_eff_load": 25839, "this_flusher": 25840, "this_group": 25841, "this_len": 25842, "this_load": 25843, "this_module": 25844, "this_rq": 25845, "this_rq_lock": 25846, "this_scd": 25847, "this_syscall": 25848, "this_tr": 25849, "those": 25850, "thr": 25851, "thr_query": 25852, "thread": 25853, "thread_ack": 25854, "thread_comm": 25855, "thread_data": 25856, "thread_flags": 25857, "thread_fn": 25858, "thread_group": 25859, "thread_group_cputime": 25860, "thread_group_cputime_adjusted": 25861, "thread_group_cputime_init": 25862, "thread_group_cputimer": 25863, "thread_group_empty": 25864, "thread_group_leader": 25865, "thread_head": 25866, "thread_info": 25867, "thread_info_cache": 25868, "thread_info_cache_init": 25869, "thread_keyring": 25870, "thread_mask": 25871, "thread_node": 25872, "thread_should_run": 25873, "thread_size": 25874, "thread_size_order": 25875, "threadfn": 25876, "threadgroup": 25877, "threadgroup_change_begin": 25878, "threadgroup_change_end": 25879, "threadgroup_lock": 25880, "threadgroup_unlock": 25881, "threadid": 25882, "threadinfo_gfp": 25883, "threads": 25884, "threads_active": 25885, "threads_handled": 25886, "threads_handled_last": 25887, "threads_oneshot": 25888, "thref": 25889, "thresh": 25890, "threshold": 25891, "throttle_cfs_rq": 25892, "throttle_count": 25893, "throttled": 25894, "throttled_cfs_rq": 25895, "throttled_clock": 25896, "throttled_clock_task": 25897, "throttled_clock_task_time": 25898, "throttled_hierarchy": 25899, "throttled_lb_pair": 25900, "throttled_list": 25901, "throttled_time": 25902, "ti": 25903, "tick": 25904, "tick_bc_dev": 25905, "tick_broadcast": 25906, "tick_broadcast_clear_oneshot": 25907, "tick_broadcast_control": 25908, "tick_broadcast_device": 25909, "tick_broadcast_enter": 25910, "tick_broadcast_force": 25911, "tick_broadcast_force_mask": 25912, "tick_broadcast_forced": 25913, "tick_broadcast_init": 25914, "tick_broadcast_init_next_event": 25915, "tick_broadcast_init_sysfs": 25916, "tick_broadcast_lock": 25917, "tick_broadcast_mask": 25918, "tick_broadcast_mode": 25919, "tick_broadcast_off": 25920, "tick_broadcast_on": 25921, "tick_broadcast_oneshot_active": 25922, "tick_broadcast_oneshot_available": 25923, "tick_broadcast_oneshot_control": 25924, "tick_broadcast_oneshot_mask": 25925, "tick_broadcast_pending_mask": 25926, "tick_broadcast_set_affinity": 25927, "tick_broadcast_set_event": 25928, "tick_broadcast_setup_oneshot": 25929, "tick_broadcast_start_periodic": 25930, "tick_broadcast_state": 25931, "tick_broadcast_switch_to_oneshot": 25932, "tick_broadcast_update_freq": 25933, "tick_cancel_sched_timer": 25934, "tick_check_broadcast_device": 25935, "tick_check_broadcast_expired": 25936, "tick_check_new_device": 25937, "tick_check_oneshot_broadcast_this_cpu": 25938, "tick_check_oneshot_change": 25939, "tick_check_replacement": 25940, "tick_cleanup_dead_cpu": 25941, "tick_clock_notify": 25942, "tick_cpu_device": 25943, "tick_cpu_sched": 25944, "tick_device": 25945, "tick_device_is_functional": 25946, "tick_device_mode": 25947, "tick_device_setup_broadcast_func": 25948, "tick_device_uses_broadcast": 25949, "tick_do_broadcast": 25950, "tick_do_periodic_broadcast": 25951, "tick_do_timer_boot": 25952, "tick_do_timer_cpu": 25953, "tick_do_timer_none": 25954, "tick_do_update_jiffies64": 25955, "tick_error": 25956, "tick_get_broadcast_device": 25957, "tick_get_broadcast_mask": 25958, "tick_get_broadcast_oneshot_mask": 25959, "tick_get_device": 25960, "tick_get_tick_dev": 25961, "tick_get_tick_sched": 25962, "tick_gtod": 25963, "tick_handle_oneshot_broadcast": 25964, "tick_handle_periodic": 25965, "tick_handle_periodic_broadcast": 25966, "tick_handover_do_timer": 25967, "tick_init_highres": 25968, "tick_init_jiffy_update": 25969, "tick_init_sysfs": 25970, "tick_install_broadcast_device": 25971, "tick_install_replacement": 25972, "tick_irq_enter": 25973, "tick_irq_exit": 25974, "tick_is_broadcast_device": 25975, "tick_is_oneshot_available": 25976, "tick_length": 25977, "tick_length_base": 25978, "tick_next_period": 25979, "tick_nohz_account_idle_ticks": 25980, "tick_nohz_active": 25981, "tick_nohz_enabled": 25982, "tick_nohz_enabled_snap": 25983, "tick_nohz_full_cpu": 25984, "tick_nohz_full_enabled": 25985, "tick_nohz_full_kick": 25986, "tick_nohz_full_kick_all": 25987, "tick_nohz_full_kick_cpu": 25988, "tick_nohz_full_mask": 25989, "tick_nohz_full_running": 25990, "tick_nohz_full_setup": 25991, "tick_nohz_full_stop_tick": 25992, "tick_nohz_get_sleep_length": 25993, "tick_nohz_handler": 25994, "tick_nohz_idle_enter": 25995, "tick_nohz_idle_exit": 25996, "tick_nohz_init": 25997, "tick_nohz_irq_enter": 25998, "tick_nohz_irq_exit": 25999, "tick_nohz_kick_tick": 26000, "tick_nohz_mode": 26001, "tick_nohz_reprogram": 26002, "tick_nohz_restart": 26003, "tick_nohz_restart_sched_tick": 26004, "tick_nohz_start_idle": 26005, "tick_nohz_stop_idle": 26006, "tick_nohz_stop_sched_tick": 26007, "tick_nohz_switch_to_nohz": 26008, "tick_nohz_task_switch": 26009, "tick_nohz_tick_stopped": 26010, "tick_nohz_update_jiffies": 26011, "tick_nsec": 26012, "tick_oneshot_mode_active": 26013, "tick_oneshot_notify": 26014, "tick_oneshot_possible": 26015, "tick_percpu_dev": 26016, "tick_period": 26017, "tick_program_event": 26018, "tick_raw": 26019, "tick_receive_broadcast": 26020, "tick_resume": 26021, "tick_resume_broadcast": 26022, "tick_resume_broadcast_oneshot": 26023, "tick_resume_check_broadcast": 26024, "tick_resume_oneshot": 26025, "tick_sched": 26026, "tick_sched_do_timer": 26027, "tick_sched_handle": 26028, "tick_sched_timer": 26029, "tick_set_periodic_handler": 26030, "tick_setup_hrtimer_broadcast": 26031, "tick_setup_oneshot": 26032, "tick_setup_periodic": 26033, "tick_setup_sched_timer": 26034, "tick_shutdown": 26035, "tick_shutdown_broadcast": 26036, "tick_shutdown_broadcast_oneshot": 26037, "tick_stopped": 26038, "tick_suspend": 26039, "tick_suspend_broadcast": 26040, "tick_switch_to_oneshot": 26041, "tick_usec": 26042, "tickdev_mode_oneshot": 26043, "tickdev_mode_periodic": 26044, "ticks": 26045, "ticks_this_gp": 26046, "ticks_title": 26047, "ticks_value": 26048, "tid": 26049, "tid_addr": 26050, "tid_entry": 26051, "tidptr": 26052, "tif_memdie": 26053, "tif_nohz": 26054, "tif_notsc": 26055, "tif_polling_nrflag": 26056, "tif_seccomp": 26057, "tif_sigpending": 26058, "tif_syscall_audit": 26059, "tif_syscall_emu": 26060, "tif_syscall_trace": 26061, "tif_uprobe": 26062, "till_stall_check": 26063, "time": 26064, "time64_t": 26065, "time_adjust": 26066, "time_after": 26067, "time_after_eq": 26068, "time_before": 26069, "time_before_eq": 26070, "time_constant": 26071, "time_delta": 26072, "time_enabled": 26073, "time_error": 26074, "time_esterror": 26075, "time_freq": 26076, "time_hardirqs_off": 26077, "time_hardirqs_on": 26078, "time_is_before_jiffies": 26079, "time_left": 26080, "time_maxerror": 26081, "time_offset": 26082, "time_ok": 26083, "time_passed": 26084, "time_reftime": 26085, "time_running": 26086, "time_slice": 26087, "time_squared": 26088, "time_stamp": 26089, "time_start": 26090, "time_state": 26091, "time_status": 26092, "time_stop": 26093, "time_t": 26094, "time_tai": 26095, "timecounter": 26096, "timecounter_cyc2time": 26097, "timecounter_init": 26098, "timecounter_read": 26099, "timecounter_read_delta": 26100, "timed_out": 26101, "timekeeper": 26102, "timekeeper_lock": 26103, "timekeeping": 26104, "timekeeping_adjust": 26105, "timekeeping_apply_adjustment": 26106, "timekeeping_check_update": 26107, "timekeeping_clocktai": 26108, "timekeeping_forward_now": 26109, "timekeeping_freqadjust": 26110, "timekeeping_get_delta": 26111, "timekeeping_get_ns": 26112, "timekeeping_get_tai_offset": 26113, "timekeeping_init": 26114, "timekeeping_init_ops": 26115, "timekeeping_inject_offset": 26116, "timekeeping_inject_sleeptime64": 26117, "timekeeping_internal": 26118, "timekeeping_last_warning": 26119, "timekeeping_max_deferment": 26120, "timekeeping_notify": 26121, "timekeeping_overflow_seen": 26122, "timekeeping_resume": 26123, "timekeeping_rtc_skipresume": 26124, "timekeeping_rtc_skipsuspend": 26125, "timekeeping_set_tai_offset": 26126, "timekeeping_suspend": 26127, "timekeeping_suspend_time": 26128, "timekeeping_suspended": 26129, "timekeeping_syscore_ops": 26130, "timekeeping_underflow_seen": 26131, "timekeeping_update": 26132, "timekeeping_valid_for_hres": 26133, "timeout": 26134, "timeout_jiffies": 26135, "timeout_ms": 26136, "timeout_ns": 26137, "timeout_start": 26138, "timeout_us": 26139, "timer": 26140, "timer_abstime": 26141, "timer_active": 26142, "timer_cpu_notify": 26143, "timer_create": 26144, "timer_debug_descr": 26145, "timer_debug_hint": 26146, "timer_del": 26147, "timer_delete": 26148, "timer_delete_hook": 26149, "timer_entry_static": 26150, "timer_event_spec": 26151, "timer_fixup_activate": 26152, "timer_fixup_assert_init": 26153, "timer_fixup_free": 26154, "timer_fixup_init": 26155, "timer_flag": 26156, "timer_flag_mask": 26157, "timer_get": 26158, "timer_getoverrun": 26159, "timer_gettime": 26160, "timer_id": 26161, "timer_jiffies": 26162, "timer_list": 26163, "timer_list_iter": 26164, "timer_not_pinned": 26165, "timer_pending": 26166, "timer_pinned": 26167, "timer_register_cpu_notifier": 26168, "timer_retry": 26169, "timer_set": 26170, "timer_set_base": 26171, "timer_settime": 26172, "timer_slack_ns": 26173, "timer_softirq": 26174, "timer_stats": 26175, "timer_stats_account_timer": 26176, "timer_stats_active": 26177, "timer_stats_flag_deferrable": 26178, "timer_stats_timer_clear_start_info": 26179, "timer_stats_timer_set_start_info": 26180, "timer_stats_update_stats": 26181, "timer_t": 26182, "timerf": 26183, "timerqueue": 26184, "timerqueue_add": 26185, "timerqueue_del": 26186, "timerqueue_getnext": 26187, "timerqueue_head": 26188, "timers": 26189, "times": 26190, "timespec": 26191, "timespec64": 26192, "timespec64_add": 26193, "timespec64_add_ns": 26194, "timespec64_compare": 26195, "timespec64_sub": 26196, "timespec64_to_ktime": 26197, "timespec64_to_timespec": 26198, "timespec64_valid_strict": 26199, "timespec_add_ns": 26200, "timespec_add_safe": 26201, "timespec_sub": 26202, "timespec_to_jiffies": 26203, "timespec_to_ktime": 26204, "timespec_to_ns": 26205, "timespec_to_timespec64": 26206, "timespec_trunc": 26207, "timespec_valid": 26208, "timestamp": 26209, "timeval": 26210, "timeval_to_cputime": 26211, "timeval_to_jiffies": 26212, "timeval_to_ktime": 26213, "timeval_to_ns": 26214, "timeval_valid": 26215, "timex": 26216, "timezone": 26217, "timr": 26218, "tiny": 26219, "title": 26220, "tk": 26221, "tk_clear_ntp": 26222, "tk_clock_was_set": 26223, "tk_core": 26224, "tk_debug_account_sleep_time": 26225, "tk_debug_show_sleep_time": 26226, "tk_fast": 26227, "tk_fast_mono": 26228, "tk_fast_raw": 26229, "tk_mirror": 26230, "tk_normalize_xtime": 26231, "tk_offs_boot": 26232, "tk_offs_max": 26233, "tk_offs_real": 26234, "tk_offs_tai": 26235, "tk_offsets": 26236, "tk_read_base": 26237, "tk_set_wall_to_mono": 26238, "tk_set_xtime": 26239, "tk_setup_internals": 26240, "tk_update_ktime_data": 26241, "tk_update_sleep_time": 26242, "tk_xtime": 26243, "tk_xtime_add": 26244, "tkf": 26245, "tkr": 26246, "tkr_dummy": 26247, "tkr_mono": 26248, "tkr_raw": 26249, "tl": 26250, "tlb_migrate_finish": 26251, "tloc": 26252, "tls_val": 26253, "tm": 26254, "tm_hour": 26255, "tm_mday": 26256, "tm_min": 26257, "tm_mon": 26258, "tm_ref": 26259, "tm_sec": 26260, "tm_year": 26261, "tmono": 26262, "tmp": 26263, "tmp_attrs": 26264, "tmp_bitmap": 26265, "tmp_cs": 26266, "tmp_cset": 26267, "tmp_hex": 26268, "tmp_iter_page": 26269, "tmp_l": 26270, "tmp_link": 26271, "tmp_links": 26272, "tmp_list": 26273, "tmp_p": 26274, "tmp_raw": 26275, "tmp_seq": 26276, "tmp_sgs": 26277, "tmp_ss_mask": 26278, "tmp_task": 26279, "tmpbuflen": 26280, "tmpmask": 26281, "tmpstr": 26282, "tmptaint": 26283, "tmr": 26284, "tms": 26285, "tms_cstime": 26286, "tms_cutime": 26287, "tms_stime": 26288, "tms_utime": 26289, "tn": 26290, "tne": 26291, "tnf_fault_local": 26292, "tnf_migrate_fail": 26293, "tnf_migrated": 26294, "tnf_no_group": 26295, "tnf_shared": 26296, "tnt": 26297, "tnts": 26298, "to": 26299, "to_acct": 26300, "to_alloc": 26301, "to_change": 26302, "to_cpumask": 26303, "to_delayed_work": 26304, "to_free_highmem": 26305, "to_free_normal": 26306, "to_kthread": 26307, "to_live_kthread": 26308, "to_module_attr": 26309, "to_module_kobject": 26310, "to_param_attr": 26311, "to_pid_ns": 26312, "to_ratio": 26313, "to_remove": 26314, "to_remove_page": 26315, "to_rtc_device": 26316, "to_send": 26317, "to_tell": 26318, "to_user_ns": 26319, "to_uts_ns": 26320, "to_wakeup": 26321, "tocopy": 26322, "todo": 26323, "tofree": 26324, "tok": 26325, "token": 26326, "tolerance": 26327, "tolower": 26328, "tomono": 26329, "too": 26330, "too_long": 26331, "too_many_workers": 26332, "took": 26333, "top_cpuset": 26334, "top_down": 26335, "top_op": 26336, "top_trace_array": 26337, "topology_sd_flags": 26338, "torture_cleanup_begin": 26339, "torture_cleanup_end": 26340, "torture_create_kthread": 26341, "torture_flag": 26342, "torture_init_begin": 26343, "torture_init_end": 26344, "torture_kthread_stopping": 26345, "torture_lock_busted_write_delay": 26346, "torture_lock_busted_write_lock": 26347, "torture_lock_busted_write_unlock": 26348, "torture_lock_spin_write_unlock_irq": 26349, "torture_must_stop": 26350, "torture_must_stop_irq": 26351, "torture_mutex": 26352, "torture_mutex_delay": 26353, "torture_mutex_lock": 26354, "torture_mutex_unlock": 26355, "torture_onoff": 26356, "torture_onoff_cleanup": 26357, "torture_onoff_failures": 26358, "torture_onoff_init": 26359, "torture_onoff_stats": 26360, "torture_ops": 26361, "torture_param": 26362, "torture_random": 26363, "torture_random_add": 26364, "torture_random_mult": 26365, "torture_random_refresh": 26366, "torture_random_state": 26367, "torture_runnable": 26368, "torture_rwlock": 26369, "torture_rwlock_read_delay": 26370, "torture_rwlock_read_lock": 26371, "torture_rwlock_read_lock_irq": 26372, "torture_rwlock_read_unlock": 26373, "torture_rwlock_read_unlock_irq": 26374, "torture_rwlock_write_delay": 26375, "torture_rwlock_write_lock": 26376, "torture_rwlock_write_lock_irq": 26377, "torture_rwlock_write_unlock": 26378, "torture_rwlock_write_unlock_irq": 26379, "torture_rwsem": 26380, "torture_rwsem_down_read": 26381, "torture_rwsem_down_write": 26382, "torture_rwsem_read_delay": 26383, "torture_rwsem_up_read": 26384, "torture_rwsem_up_write": 26385, "torture_rwsem_write_delay": 26386, "torture_shuffle": 26387, "torture_shuffle_cleanup": 26388, "torture_shuffle_init": 26389, "torture_shuffle_task_register": 26390, "torture_shuffle_task_unregister_all": 26391, "torture_shuffle_tasks": 26392, "torture_shutdown": 26393, "torture_shutdown_absorb": 26394, "torture_shutdown_cleanup": 26395, "torture_shutdown_hook": 26396, "torture_shutdown_init": 26397, "torture_shutdown_nb": 26398, "torture_shutdown_notify": 26399, "torture_spin_lock_write_delay": 26400, "torture_spin_lock_write_lock": 26401, "torture_spin_lock_write_lock_irq": 26402, "torture_spin_lock_write_unlock": 26403, "torture_spinlock": 26404, "torture_stop_kthread": 26405, "torture_stutter": 26406, "torture_stutter_cleanup": 26407, "torture_stutter_init": 26408, "torture_type": 26409, "tot_reqs": 26410, "total": 26411, "total_alloc": 26412, "total_bw": 26413, "total_capacity": 26414, "total_dropped": 26415, "total_events": 26416, "total_faults": 26417, "total_forks": 26418, "total_insns": 26419, "total_len": 26420, "total_load": 26421, "total_lost": 26422, "total_numa_faults": 26423, "total_read": 26424, "total_ref_count": 26425, "total_size": 26426, "total_time_enabled": 26427, "total_time_running": 26428, "total_value": 26429, "total_vm": 26430, "total_written": 26431, "totalcpuusage": 26432, "totalhigh": 26433, "totalram": 26434, "totalram_pages": 26435, "totalswap": 26436, "totqlen": 26437, "touch_all_softlockup_watchdogs": 26438, "touch_nmi_watchdog": 26439, "touch_softlockup_watchdog": 26440, "touch_softlockup_watchdog_sync": 26441, "touch_ts": 26442, "toupper": 26443, "tp": 26444, "tp_": 26445, "tp_args": 26446, "tp_event": 26447, "tp_fast_assign": 26448, "tp_flag_profile": 26449, "tp_flag_registered": 26450, "tp_flag_trace": 26451, "tp_list": 26452, "tp_printk": 26453, "tp_proto": 26454, "tp_struct__entry": 26455, "tpadding": 26456, "tps": 26457, "tptr": 26458, "tr": 26459, "tr_a": 26460, "tr_b": 26461, "trace": 26462, "trace_access_lock": 26463, "trace_access_lock_init": 26464, "trace_access_unlock": 26465, "trace_active": 26466, "trace_add_event_call": 26467, "trace_array": 26468, "trace_array_cpu": 26469, "trace_array_fl_global": 26470, "trace_array_get": 26471, "trace_array_printk": 26472, "trace_array_printk_buf": 26473, "trace_array_put": 26474, "trace_array_vprintk": 26475, "trace_assign_type": 26476, "trace_benchmark": 26477, "trace_benchmark_event": 26478, "trace_benchmark_event_enabled": 26479, "trace_benchmark_reg": 26480, "trace_benchmark_unreg": 26481, "trace_blk": 26482, "trace_blk_event": 26483, "trace_blk_event_funcs": 26484, "trace_blk_opt_classic": 26485, "trace_boot_clock": 26486, "trace_boot_clock_buf": 26487, "trace_boot_options": 26488, "trace_boot_options_buf": 26489, "trace_bprint": 26490, "trace_bprintk_fmt": 26491, "trace_bprintk_fmt_list": 26492, "trace_bprintk_fmt_start": 26493, "trace_bputs": 26494, "trace_branch": 26495, "trace_branch_disable": 26496, "trace_branch_enable": 26497, "trace_branch_event": 26498, "trace_branch_funcs": 26499, "trace_branch_print": 26500, "trace_buf": 26501, "trace_buf_size": 26502, "trace_buf_size_default": 26503, "trace_buffer": 26504, "trace_buffer_bit": 26505, "trace_buffer_irq_bit": 26506, "trace_buffer_iter": 26507, "trace_buffer_lock_reserve": 26508, "trace_buffer_nmi_bit": 26509, "trace_buffer_sirq_bit": 26510, "trace_buffer_unlock_commit": 26511, "trace_call_bpf": 26512, "trace_clear_recursion": 26513, "trace_clock": 26514, "trace_clock_global": 26515, "trace_clock_jiffies": 26516, "trace_clock_local": 26517, "trace_clock_struct": 26518, "trace_cmdline_lock": 26519, "trace_cmdline_save": 26520, "trace_context_mask": 26521, "trace_control_bit": 26522, "trace_create_file": 26523, "trace_create_new_event": 26524, "trace_create_savedcmd": 26525, "trace_ctx": 26526, "trace_ctx_event": 26527, "trace_ctx_funcs": 26528, "trace_ctx_hex": 26529, "trace_ctx_print": 26530, "trace_ctx_raw": 26531, "trace_ctxwake_bin": 26532, "trace_ctxwake_hex": 26533, "trace_ctxwake_print": 26534, "trace_ctxwake_raw": 26535, "trace_current_buffer_lock_reserve": 26536, "trace_default_header": 26537, "trace_define_common_fields": 26538, "trace_define_field": 26539, "trace_destroy_fields": 26540, "trace_display_graph": 26541, "trace_do_benchmark": 26542, "trace_dump_stack": 26543, "trace_empty": 26544, "trace_entry": 26545, "trace_enum_map": 26546, "trace_enum_map_head": 26547, "trace_enum_map_item": 26548, "trace_enum_map_tail": 26549, "trace_enum_maps": 26550, "trace_enum_mutex": 26551, "trace_enums": 26552, "trace_event": 26553, "trace_event_buffer_lock_reserve": 26554, "trace_event_enable_cmd_record": 26555, "trace_event_enable_disable": 26556, "trace_event_enum_update": 26557, "trace_event_fl_cap_any": 26558, "trace_event_fl_filtered": 26559, "trace_event_fl_ignore_enable": 26560, "trace_event_fl_kprobe": 26561, "trace_event_fl_no_set_filter": 26562, "trace_event_fl_tracepoint": 26563, "trace_event_fl_use_call_filter": 26564, "trace_event_fl_was_enabled": 26565, "trace_event_fn": 26566, "trace_event_functions": 26567, "trace_event_init": 26568, "trace_event_raw_init": 26569, "trace_event_read_lock": 26570, "trace_event_read_unlock": 26571, "trace_event_sem": 26572, "trace_event_trigger_enable_disable": 26573, "trace_events": 26574, "trace_events_filter_test": 26575, "trace_file_lat_fmt": 26576, "trace_file_size": 26577, "trace_file_time_in_ns": 26578, "trace_find_cmdline": 26579, "trace_find_event_field": 26580, "trace_find_mark": 26581, "trace_find_next_entry": 26582, "trace_find_next_entry_inc": 26583, "trace_flag_hardirq": 26584, "trace_flag_irqs_nosupport": 26585, "trace_flag_irqs_off": 26586, "trace_flag_need_resched": 26587, "trace_flag_preempt_resched": 26588, "trace_flag_softirq": 26589, "trace_flag_type": 26590, "trace_flags": 26591, "trace_fn": 26592, "trace_fn_bin": 26593, "trace_fn_event": 26594, "trace_fn_funcs": 26595, "trace_fn_hex": 26596, "trace_fn_raw": 26597, "trace_fn_trace": 26598, "trace_format_open": 26599, "trace_ftrace_bit": 26600, "trace_ftrace_irq_bit": 26601, "trace_ftrace_max": 26602, "trace_ftrace_nmi_bit": 26603, "trace_ftrace_sirq_bit": 26604, "trace_ftrace_start": 26605, "trace_func_graph_ent_t": 26606, "trace_func_graph_ret_t": 26607, "trace_func_opt_stack": 26608, "trace_func_size": 26609, "trace_function": 26610, "trace_get_context_bit": 26611, "trace_get_fields": 26612, "trace_get_syscall_nr": 26613, "trace_get_user": 26614, "trace_graph_ent": 26615, "trace_graph_entry": 26616, "trace_graph_entry_watchdog": 26617, "trace_graph_function": 26618, "trace_graph_indent": 26619, "trace_graph_print_abs_time": 26620, "trace_graph_print_cpu": 26621, "trace_graph_print_duration": 26622, "trace_graph_print_fill_mask": 26623, "trace_graph_print_fill_shift": 26624, "trace_graph_print_irqs": 26625, "trace_graph_print_overhead": 26626, "trace_graph_print_overrun": 26627, "trace_graph_print_proc": 26628, "trace_graph_print_tail": 26629, "trace_graph_ret": 26630, "trace_graph_return": 26631, "trace_graph_thresh_entry": 26632, "trace_graph_thresh_return": 26633, "trace_handle_return": 26634, "trace_hardirq_context": 26635, "trace_hardirq_enter": 26636, "trace_hardirq_exit": 26637, "trace_hardirqs_enabled": 26638, "trace_hardirqs_off": 26639, "trace_hardirqs_off_caller": 26640, "trace_hardirqs_on": 26641, "trace_hardirqs_on_caller": 26642, "trace_header_multi_read": 26643, "trace_include_file": 26644, "trace_include_path": 26645, "trace_init_global_iter": 26646, "trace_internal_bit": 26647, "trace_internal_irq_bit": 26648, "trace_internal_nmi_bit": 26649, "trace_internal_sirq_bit": 26650, "trace_irq_bit": 26651, "trace_irq_handler_entry": 26652, "trace_irq_handler_exit": 26653, "trace_iter_annotate": 26654, "trace_iter_bin": 26655, "trace_iter_block": 26656, "trace_iter_branch": 26657, "trace_iter_context_info": 26658, "trace_iter_function": 26659, "trace_iter_graph_time": 26660, "trace_iter_hex": 26661, "trace_iter_irq_info": 26662, "trace_iter_latency_fmt": 26663, "trace_iter_markers": 26664, "trace_iter_overwrite": 26665, "trace_iter_preemptonly": 26666, "trace_iter_print_parent": 26667, "trace_iter_printk": 26668, "trace_iter_printk_msgonly": 26669, "trace_iter_raw": 26670, "trace_iter_record_cmd": 26671, "trace_iter_sleep_time": 26672, "trace_iter_stacktrace": 26673, "trace_iter_stop_on_free": 26674, "trace_iter_sym_addr": 26675, "trace_iter_sym_mask": 26676, "trace_iter_sym_offset": 26677, "trace_iter_sym_userobj": 26678, "trace_iter_userstacktrace": 26679, "trace_iter_verbose": 26680, "trace_iterator": 26681, "trace_iterator_flags": 26682, "trace_itimer_expire": 26683, "trace_itimer_state": 26684, "trace_keep_overwrite": 26685, "trace_kprobe": 26686, "trace_kprobe_has_gone": 26687, "trace_kprobe_is_on_module": 26688, "trace_kprobe_is_return": 26689, "trace_kprobe_module_callback": 26690, "trace_kprobe_module_nb": 26691, "trace_kprobe_offset": 26692, "trace_kprobe_symbol": 26693, "trace_kprobe_within_module": 26694, "trace_latency_header": 26695, "trace_likely_condition": 26696, "trace_list_max": 26697, "trace_list_start": 26698, "trace_lock_acquire": 26699, "trace_lock_acquired": 26700, "trace_lock_contended": 26701, "trace_lock_release": 26702, "trace_lookup_stack": 26703, "trace_mark": 26704, "trace_marker": 26705, "trace_mmio_map": 26706, "trace_mmio_rw": 26707, "trace_mmiotrace_map": 26708, "trace_mmiotrace_rw": 26709, "trace_module_add_events": 26710, "trace_module_free": 26711, "trace_module_get": 26712, "trace_module_has_bad_taint": 26713, "trace_module_nb": 26714, "trace_module_notify": 26715, "trace_module_remove_events": 26716, "trace_nop_print": 26717, "trace_note": 26718, "trace_note_time": 26719, "trace_note_tsk": 26720, "trace_on": 26721, "trace_ops": 26722, "trace_options": 26723, "trace_opts": 26724, "trace_overrun": 26725, "trace_parser": 26726, "trace_parser_clear": 26727, "trace_parser_cont": 26728, "trace_parser_get_init": 26729, "trace_parser_loaded": 26730, "trace_parser_put": 26731, "trace_pipe": 26732, "trace_pipe_raw": 26733, "trace_pm_qos_add_request": 26734, "trace_pm_qos_remove_request": 26735, "trace_pm_qos_update_flags": 26736, "trace_pm_qos_update_request": 26737, "trace_pm_qos_update_request_timeout": 26738, "trace_pm_qos_update_target": 26739, "trace_preempt_off": 26740, "trace_preempt_on": 26741, "trace_print": 26742, "trace_print_bprintk_msg_only": 26743, "trace_print_bputs_msg_only": 26744, "trace_print_context": 26745, "trace_print_flags": 26746, "trace_print_flags_u64": 26747, "trace_print_graph_duration": 26748, "trace_print_lat_context": 26749, "trace_print_lat_fmt": 26750, "trace_print_printk_msg_only": 26751, "trace_print_seq": 26752, "trace_printk": 26753, "trace_printk_init_buffers": 26754, "trace_printk_seq": 26755, "trace_printk_start_comm": 26756, "trace_probe": 26757, "trace_probe_is_enabled": 26758, "trace_probe_is_registered": 26759, "trace_rcu_barrier": 26760, "trace_rcu_batch_end": 26761, "trace_rcu_batch_start": 26762, "trace_rcu_callback": 26763, "trace_rcu_dyntick": 26764, "trace_rcu_fqs": 26765, "trace_rcu_future_gp": 26766, "trace_rcu_future_grace_period": 26767, "trace_rcu_grace_period": 26768, "trace_rcu_grace_period_init": 26769, "trace_rcu_invoke_callback": 26770, "trace_rcu_invoke_kfree_callback": 26771, "trace_rcu_kfree_callback": 26772, "trace_rcu_nocb_wake": 26773, "trace_rcu_preempt_task": 26774, "trace_rcu_quiescent_state_report": 26775, "trace_rcu_torture_read": 26776, "trace_rcu_unlock_preempted_task": 26777, "trace_rcu_utilization": 26778, "trace_record_cmdline_disabled": 26779, "trace_recursion": 26780, "trace_recursion_clear": 26781, "trace_recursion_set": 26782, "trace_recursion_test": 26783, "trace_recursive_lock": 26784, "trace_recursive_unlock": 26785, "trace_reg": 26786, "trace_reg_perf_add": 26787, "trace_reg_perf_close": 26788, "trace_reg_perf_del": 26789, "trace_reg_perf_open": 26790, "trace_reg_perf_register": 26791, "trace_reg_perf_unregister": 26792, "trace_reg_register": 26793, "trace_reg_unregister": 26794, "trace_remove_event_call": 26795, "trace_save_cmdline": 26796, "trace_sched_kthread_stop": 26797, "trace_sched_kthread_stop_ret": 26798, "trace_sched_migrate_task": 26799, "trace_sched_move_numa": 26800, "trace_sched_pi_setprio": 26801, "trace_sched_process_fork": 26802, "trace_sched_process_hang": 26803, "trace_sched_stat_blocked": 26804, "trace_sched_stat_iowait": 26805, "trace_sched_stat_runtime": 26806, "trace_sched_stat_sleep": 26807, "trace_sched_stat_wait": 26808, "trace_sched_stick_numa": 26809, "trace_sched_swap_numa": 26810, "trace_sched_switch": 26811, "trace_sched_wait_task": 26812, "trace_sched_wake_idle_without_ipi": 26813, "trace_sched_wakeup": 26814, "trace_sched_wakeup_new": 26815, "trace_search_list": 26816, "trace_selftest": 26817, "trace_selftest_dynamic_test_func": 26818, "trace_selftest_dynamic_test_func2": 26819, "trace_selftest_function_recursion": 26820, "trace_selftest_function_regs": 26821, "trace_selftest_ops": 26822, "trace_selftest_recursion_cnt": 26823, "trace_selftest_regs_found": 26824, "trace_selftest_regs_not_found": 26825, "trace_selftest_regs_start": 26826, "trace_selftest_regs_stat": 26827, "trace_selftest_startup_branch": 26828, "trace_selftest_startup_dynamic_tracing": 26829, "trace_selftest_startup_function": 26830, "trace_selftest_startup_function_graph": 26831, "trace_selftest_startup_irqsoff": 26832, "trace_selftest_startup_nop": 26833, "trace_selftest_startup_preemptirqsoff": 26834, "trace_selftest_startup_preemptoff": 26835, "trace_selftest_startup_sched_switch": 26836, "trace_selftest_startup_wakeup": 26837, "trace_selftest_test_dyn_cnt": 26838, "trace_selftest_test_dyn_func": 26839, "trace_selftest_test_global_cnt": 26840, "trace_selftest_test_global_func": 26841, "trace_selftest_test_probe1_cnt": 26842, "trace_selftest_test_probe1_func": 26843, "trace_selftest_test_probe2_cnt": 26844, "trace_selftest_test_probe2_func": 26845, "trace_selftest_test_probe3_cnt": 26846, "trace_selftest_test_probe3_func": 26847, "trace_selftest_test_recursion_func": 26848, "trace_selftest_test_recursion_safe_func": 26849, "trace_selftest_test_regs_func": 26850, "trace_seq": 26851, "trace_seq_bitmask": 26852, "trace_seq_bprintf": 26853, "trace_seq_buf_left": 26854, "trace_seq_buf_used": 26855, "trace_seq_buffer_ptr": 26856, "trace_seq_has_overflowed": 26857, "trace_seq_init": 26858, "trace_seq_path": 26859, "trace_seq_printf": 26860, "trace_seq_putc": 26861, "trace_seq_putmem": 26862, "trace_seq_putmem_hex": 26863, "trace_seq_puts": 26864, "trace_seq_to_buffer": 26865, "trace_seq_to_user": 26866, "trace_seq_used": 26867, "trace_seq_vprintf": 26868, "trace_set_clr_event": 26869, "trace_signal_already_pending": 26870, "trace_signal_deliver": 26871, "trace_signal_delivered": 26872, "trace_signal_generate": 26873, "trace_signal_ignored": 26874, "trace_signal_lose_info": 26875, "trace_signal_overflow_fail": 26876, "trace_softirq_context": 26877, "trace_softirq_entry": 26878, "trace_softirq_exit": 26879, "trace_softirq_raise": 26880, "trace_softirqs_enabled": 26881, "trace_softirqs_off": 26882, "trace_softirqs_on": 26883, "trace_stack": 26884, "trace_stack_print": 26885, "trace_stat_seq_ops": 26886, "trace_state": 26887, "trace_stop_cmdline_recording": 26888, "trace_suspend_resume": 26889, "trace_system": 26890, "trace_task_newtask": 26891, "trace_test_and_set_recursion": 26892, "trace_test_buffer": 26893, "trace_test_buffer_cpu": 26894, "trace_tick_stop": 26895, "trace_timer_cancel": 26896, "trace_timer_expire_entry": 26897, "trace_timer_expire_exit": 26898, "trace_timer_init": 26899, "trace_timer_start": 26900, "trace_type": 26901, "trace_type_handled": 26902, "trace_type_no_consume": 26903, "trace_type_partial_line": 26904, "trace_type_unhandled": 26905, "trace_types": 26906, "trace_types_lock": 26907, "trace_uprobe": 26908, "trace_uprobe_filter": 26909, "trace_uprobe_register": 26910, "trace_user_enter": 26911, "trace_user_exit": 26912, "trace_user_stack": 26913, "trace_valid_entry": 26914, "trace_vbprintk": 26915, "trace_vprintk": 26916, "trace_wake": 26917, "trace_wake_event": 26918, "trace_wake_funcs": 26919, "trace_wake_hex": 26920, "trace_wake_print": 26921, "trace_wake_raw": 26922, "trace_wakeup_test_thread": 26923, "trace_workqueue_activate_work": 26924, "trace_workqueue_execute_end": 26925, "trace_workqueue_execute_start": 26926, "trace_workqueue_queue_work": 26927, "traceable": 26928, "traced": 26929, "tracefs": 26930, "tracefs_create_dir": 26931, "tracefs_create_file": 26932, "tracefs_remove": 26933, "tracefs_remove_recursive": 26934, "tracehook_signal_handler": 26935, "traceoff": 26936, "traceoff_count_probe_ops": 26937, "traceoff_count_trigger": 26938, "traceoff_count_trigger_ops": 26939, "traceoff_probe_ops": 26940, "traceoff_trigger": 26941, "traceoff_trigger_ops": 26942, "traceoff_trigger_print": 26943, "traceon": 26944, "traceon_count_probe_ops": 26945, "traceon_count_trigger": 26946, "traceon_count_trigger_ops": 26947, "traceon_probe_ops": 26948, "traceon_trigger": 26949, "traceon_trigger_ops": 26950, "traceon_trigger_print": 26951, "tracepoint": 26952, "tracepoint_iter_lock": 26953, "tracepoint_print_iter": 26954, "tracepoint_printk": 26955, "tracepoint_probe_register": 26956, "tracepoint_probe_unregister": 26957, "tracepoint_string": 26958, "tracepoint_synchronize_unregister": 26959, "tracepoints_ptrs": 26960, "traceprobe_command": 26961, "traceprobe_conflict_field_name": 26962, "traceprobe_free_probe_arg": 26963, "traceprobe_parse_probe_arg": 26964, "traceprobe_probes_write": 26965, "traceprobe_split_symbol_offset": 26966, "traceprobe_update_arg": 26967, "tracer": 26968, "tracer_enabled": 26969, "tracer_flags": 26970, "tracer_init": 26971, "tracer_irqs_off": 26972, "tracer_opt": 26973, "tracer_preempt_off": 26974, "tracer_stat": 26975, "tracer_tracing_is_on": 26976, "tracer_tracing_off": 26977, "tracer_tracing_on": 26978, "tracers": 26979, "traces": 26980, "tracing": 26981, "tracing_alloc_snapshot": 26982, "tracing_buffer_mask": 26983, "tracing_cpu": 26984, "tracing_cpumask": 26985, "tracing_disabled": 26986, "tracing_dl": 26987, "tracing_get_trace_entry": 26988, "tracing_graph_pause": 26989, "tracing_init_dentry": 26990, "tracing_is_disabled": 26991, "tracing_is_enabled": 26992, "tracing_is_on": 26993, "tracing_iter_reset": 26994, "tracing_lseek": 26995, "tracing_max_latency": 26996, "tracing_off": 26997, "tracing_off_permanent": 26998, "tracing_on": 26999, "tracing_open_generic": 27000, "tracing_record_cmdline": 27001, "tracing_reset": 27002, "tracing_reset_all_online_cpus": 27003, "tracing_reset_current": 27004, "tracing_reset_online_cpus": 27005, "tracing_sched_register": 27006, "tracing_sched_switch_trace": 27007, "tracing_sched_unregister": 27008, "tracing_sched_wakeup_trace": 27009, "tracing_selftest_disabled": 27010, "tracing_selftest_running": 27011, "tracing_set_tracer": 27012, "tracing_snapshot": 27013, "tracing_start": 27014, "tracing_start_cmdline_record": 27015, "tracing_start_function_trace": 27016, "tracing_start_sched_switch": 27017, "tracing_stat_fops": 27018, "tracing_stat_init": 27019, "tracing_stat_open": 27020, "tracing_stat_release": 27021, "tracing_stop": 27022, "tracing_stop_cmdline_record": 27023, "tracing_stop_function_trace": 27024, "tracing_stop_sched_switch": 27025, "tracing_stop_tr": 27026, "tracing_thresh": 27027, "tracing_update_buffers": 27028, "tramp_name": 27029, "trampoline": 27030, "trampoline_size": 27031, "trampoline_vaddr": 27032, "transfer_pid": 27033, "translate_user_vaddr": 27034, "trap": 27035, "trapnr": 27036, "tree": 27037, "tree_count": 27038, "tree_entry": 27039, "tree_list": 27040, "trees": 27041, "trial": 27042, "trial_cpus": 27043, "trialcs": 27044, "trigger": 27045, "trigger_all_cpu_backtrace": 27046, "trigger_allbutself_cpu_backtrace": 27047, "trigger_cmd_mutex": 27048, "trigger_commands": 27049, "trigger_data": 27050, "trigger_data_free": 27051, "trigger_disable_cmd": 27052, "trigger_enable": 27053, "trigger_enable_cmd": 27054, "trigger_load_balance": 27055, "trigger_next": 27056, "trigger_ops": 27057, "trigger_process_regex": 27058, "trigger_show": 27059, "trigger_snapshot_cmd": 27060, "trigger_stacktrace_cmd": 27061, "trigger_start": 27062, "trigger_stop": 27063, "trigger_traceoff_cmd": 27064, "trigger_traceon_cmd": 27065, "trigger_type": 27066, "triggers": 27067, "trim_init_extable": 27068, "trim_marked": 27069, "trs_count": 27070, "trs_state": 27071, "trsp": 27072, "true": 27073, "true_branch": 27074, "truesize": 27075, "truncated": 27076, "try_check_zero": 27077, "try_force_unload": 27078, "try_get_online_cpus": 27079, "try_misrouted_irq": 27080, "try_module_get": 27081, "try_one_irq": 27082, "try_online_node": 27083, "try_reader_grant": 27084, "try_release_module_ref": 27085, "try_stop_cpus": 27086, "try_stop_module": 27087, "try_to_del_timer_sync": 27088, "try_to_force_load": 27089, "try_to_free_swap": 27090, "try_to_freeze": 27091, "try_to_freeze_tasks": 27092, "try_to_grab_pending": 27093, "try_to_optimize_kprobe": 27094, "try_to_push_tasks": 27095, "try_to_suspend": 27096, "try_to_wake_up": 27097, "try_to_wake_up_local": 27098, "trycount": 27099, "trying": 27100, "trylock": 27101, "trylock_loop": 27102, "ts": 27103, "ts64": 27104, "ts_comm_len": 27105, "ts_delta": 27106, "ts_delta_test": 27107, "ts_mask": 27108, "ts_new": 27109, "ts_nsec": 27110, "ts_raw": 27111, "ts_real": 27112, "ts_rem": 27113, "ts_shift": 27114, "tsave": 27115, "tsc": 27116, "tsdelta": 27117, "tset": 27118, "tsk": 27119, "tsk1": 27120, "tsk2": 27121, "tsk_bw": 27122, "tsk_cache_hot": 27123, "tsk_cpus_allowed": 27124, "tsk_fork_get_node": 27125, "tsk_is_pi_blocked": 27126, "tsk_restore_flags": 27127, "tstamp": 27128, "tstamp_enabled": 27129, "tstamp_running": 27130, "tstamp_stopped": 27131, "tstat_hash_mask": 27132, "tstat_hash_size": 27133, "tstat_hash_table": 27134, "tstat_hashentry": 27135, "tstat_lookup": 27136, "tstats_lookup_lock": 27137, "tstruct": 27138, "tt": 27139, "ttime_delta": 27140, "ttime_extend": 27141, "ttimer": 27142, "ttramp": 27143, "ttwu_activate": 27144, "ttwu_count": 27145, "ttwu_do_activate": 27146, "ttwu_do_wakeup": 27147, "ttwu_local": 27148, "ttwu_move_affine": 27149, "ttwu_move_balance": 27150, "ttwu_queue": 27151, "ttwu_queue_remote": 27152, "ttwu_remote": 27153, "ttwu_stat": 27154, "ttwu_wake_remote": 27155, "tty": 27156, "tty_audit_fork": 27157, "tty_devnum": 27158, "tty_kref_get": 27159, "tty_struct": 27160, "ttya": 27161, "ttyb": 27162, "ttype": 27163, "ttype_len": 27164, "ttys": 27165, "ttys0": 27166, "ttys1": 27167, "tu": 27168, "turning_on": 27169, "tv": 27170, "tv1": 27171, "tv2": 27172, "tv3": 27173, "tv4": 27174, "tv5": 27175, "tv64": 27176, "tv_list": 27177, "tv_nsec": 27178, "tv_sec": 27179, "tv_usec": 27180, "tvec": 27181, "tvec_base": 27182, "tvec_bases": 27183, "tvn_bits": 27184, "tvn_mask": 27185, "tvn_size": 27186, "tvr_bits": 27187, "tvr_mask": 27188, "two": 27189, "tx": 27190, "txc": 27191, "txc_p": 27192, "txn": 27193, "type": 27194, "type_info": 27195, "type_len": 27196, "type_str": 27197, "typedef": 27198, "typeof": 27199, "types": 27200, "tz": 27201, "tz_minuteswest": 27202, "u": 27203, "u16": 27204, "u32": 27205, "u32_max": 27206, "u64": 27207, "u64_to_ptr": 27208, "u8": 27209, "u_dst": 27210, "u_event": 27211, "u_src": 27212, "u_swap_area": 27213, "uaddr": 27214, "uaddr2": 27215, "uaf": 27216, "uargs": 27217, "uattr": 27218, "ubuf": 27219, "ubytes": 27220, "uc": 27221, "ucb": 27222, "uchunk": 27223, "udd": 27224, "udelay": 27225, "udelay_test_debugfs_file": 27226, "udelay_test_iterations": 27227, "udelay_test_lock": 27228, "udelay_test_open": 27229, "udelay_test_show": 27230, "udelay_test_single": 27231, "udelay_test_usecs": 27232, "udelay_test_write": 27233, "udelta": 27234, "uentry": 27235, "uevent": 27236, "uevent_filter": 27237, "uevent_helper": 27238, "uevent_helper_path_len": 27239, "uevent_helper_show": 27240, "uevent_helper_store": 27241, "uevent_seqnum": 27242, "uevent_seqnum_show": 27243, "ufd": 27244, "uid": 27245, "uid_cache_init": 27246, "uid_cachep": 27247, "uid_eq": 27248, "uid_gid_extent": 27249, "uid_gid_map": 27250, "uid_gid_map_max_extents": 27251, "uid_gt": 27252, "uid_gte": 27253, "uid_hash_find": 27254, "uid_hash_insert": 27255, "uid_hash_remove": 27256, "uid_keyring": 27257, "uid_lt": 27258, "uid_lte": 27259, "uid_m_show": 27260, "uid_m_start": 27261, "uid_map": 27262, "uid_t": 27263, "uid_valid": 27264, "uidhash_bits": 27265, "uidhash_lock": 27266, "uidhash_mask": 27267, "uidhash_node": 27268, "uidhash_sz": 27269, "uidhash_table": 27270, "uidhashentry": 27271, "uinfo": 27272, "uinsns_per_page": 27273, "uint": 27274, "uint32_t": 27275, "uint64_t": 27276, "uint_cmp_ge": 27277, "uint_max": 27278, "uiov": 27279, "ukey": 27280, "ullong": 27281, "ullong_max": 27282, "ulong": 27283, "ulong2long": 27284, "ulong_cmp_ge": 27285, "ulong_cmp_lt": 27286, "ulong_max": 27287, "um": 27288, "umask": 27289, "umh_complete": 27290, "umh_disable_depth": 27291, "umh_disabled": 27292, "umh_freezing": 27293, "umh_killable": 27294, "umh_no_wait": 27295, "umh_sysctl_lock": 27296, "umh_wait_exec": 27297, "umh_wait_proc": 27298, "umhelper_sem": 27299, "umod": 27300, "umode_t": 27301, "unable": 27302, "unaccount_event": 27303, "unaccount_event_cpu": 27304, "unaligned_dump_stack": 27305, "unaligned_enabled": 27306, "uname": 27307, "uname26": 27308, "unapply_uprobe": 27309, "unbind_device": 27310, "unbind_work": 27311, "unblock_all_signals": 27312, "unblocked": 27313, "unbound_attrs": 27314, "unbound_pool_hash": 27315, "unbound_pwq_by_node": 27316, "unbound_release_work": 27317, "unbound_std_wq_attrs": 27318, "unc": 27319, "unc_len": 27320, "unclone_ctx": 27321, "undef": 27322, "undo": 27323, "undo_list": 27324, "unewset": 27325, "unext_key": 27326, "unfreeze_cgroup": 27327, "unhandled_signal": 27328, "uninitialized_var": 27329, "union": 27330, "unique_pmu": 27331, "unknown": 27332, "unknown_module_param_cb": 27333, "unknown_nmi_panic": 27334, "unknown_value": 27335, "unlikely": 27336, "unlimited": 27337, "unlink_mod": 27338, "unloaded_info": 27339, "unlock": 27340, "unlock_and_return": 27341, "unlock_creds": 27342, "unlock_device_hotplug": 27343, "unlock_out": 27344, "unlock_page": 27345, "unlock_system_sleep": 27346, "unlock_task_sighand": 27347, "unlock_tasklist": 27348, "unlock_timer": 27349, "unlocked_ioctl": 27350, "unmap": 27351, "unmask": 27352, "unmask_irq": 27353, "unmask_threaded_irq": 27354, "unoptimize_kprobe": 27355, "unoptimizing_list": 27356, "unpack_orig_pfns": 27357, "unpark": 27358, "unpause_graph_tracing": 27359, "unreachable": 27360, "unreg": 27361, "unreg_event_syscall_enter": 27362, "unreg_event_syscall_exit": 27363, "unregister": 27364, "unregister_console": 27365, "unregister_cpu_notifier": 27366, "unregister_die_notifier": 27367, "unregister_event_command": 27368, "unregister_fair_sched_group": 27369, "unregister_ftrace_event": 27370, "unregister_ftrace_function": 27371, "unregister_ftrace_function_probe_func": 27372, "unregister_ftrace_graph": 27373, "unregister_ftrace_profiler": 27374, "unregister_handler_proc": 27375, "unregister_hotcpu_notifier": 27376, "unregister_irq_proc": 27377, "unregister_irqsoff_function": 27378, "unregister_jprobe": 27379, "unregister_jprobes": 27380, "unregister_kprobe": 27381, "unregister_kprobe_event": 27382, "unregister_kprobes": 27383, "unregister_kretprobe": 27384, "unregister_kretprobes": 27385, "unregister_module_notifier": 27386, "unregister_pm_notifier": 27387, "unregister_reboot_notifier": 27388, "unregister_restart_handler": 27389, "unregister_sched_domain_sysctl": 27390, "unregister_stat_tracer": 27391, "unregister_sysctl_table": 27392, "unregister_sysrq_key": 27393, "unregister_trace_block_bio_backmerge": 27394, "unregister_trace_block_bio_bounce": 27395, "unregister_trace_block_bio_complete": 27396, "unregister_trace_block_bio_frontmerge": 27397, "unregister_trace_block_bio_queue": 27398, "unregister_trace_block_bio_remap": 27399, "unregister_trace_block_getrq": 27400, "unregister_trace_block_plug": 27401, "unregister_trace_block_rq_abort": 27402, "unregister_trace_block_rq_complete": 27403, "unregister_trace_block_rq_insert": 27404, "unregister_trace_block_rq_issue": 27405, "unregister_trace_block_rq_remap": 27406, "unregister_trace_block_rq_requeue": 27407, "unregister_trace_block_sleeprq": 27408, "unregister_trace_block_split": 27409, "unregister_trace_block_unplug": 27410, "unregister_trace_kprobe": 27411, "unregister_trace_sched_migrate_task": 27412, "unregister_trace_sched_switch": 27413, "unregister_trace_sched_wakeup": 27414, "unregister_trace_sched_wakeup_new": 27415, "unregister_trace_sys_enter": 27416, "unregister_trace_sys_exit": 27417, "unregister_trace_uprobe": 27418, "unregister_trigger": 27419, "unregister_trigger_enable_disable_cmds": 27420, "unregister_uprobe_event": 27421, "unregister_wakeup_function": 27422, "unregistered": 27423, "unroll_tree_refs": 27424, "unsafe": 27425, "unsafe_ptr": 27426, "unset_module_core_ro_nx": 27427, "unset_module_init_ro_nx": 27428, "unshare": 27429, "unshare_fd": 27430, "unshare_files": 27431, "unshare_flags": 27432, "unshare_fs": 27433, "unshare_nsproxy_namespaces": 27434, "unshare_userns": 27435, "unsigned": 27436, "unstable": 27437, "unsupported": 27438, "untag_chunk": 27439, "unthrottle_cfs_rq": 27440, "unthrottle_offline_cfs_rqs": 27441, "unusable_pages": 27442, "unused": 27443, "unused1": 27444, "unused2": 27445, "unused3": 27446, "unused_crcs": 27447, "unused_dev_name": 27448, "unused_gpl_crcs": 27449, "unused_gpl_syms": 27450, "unused_syms": 27451, "unwind": 27452, "uoffset": 27453, "uoss": 27454, "uoss_ptr": 27455, "up": 27456, "up_console_sem": 27457, "up_read": 27458, "up_read_non_owner": 27459, "up_write": 27460, "update": 27461, "update_all_ops": 27462, "update_avg": 27463, "update_bitfield_fetch_param": 27464, "update_blocked_averages": 27465, "update_cfs_rq": 27466, "update_cfs_rq_blocked_load": 27467, "update_cfs_rq_h_load": 27468, "update_cfs_shares": 27469, "update_cgrp_time_from_cpuctx": 27470, "update_cgrp_time_from_event": 27471, "update_cnt": 27472, "update_cond_flag": 27473, "update_context_time": 27474, "update_count": 27475, "update_cpu_capacity": 27476, "update_cpu_load_active": 27477, "update_cpu_load_nohz": 27478, "update_cpumask": 27479, "update_cpumasks_hier": 27480, "update_curr": 27481, "update_curr_fair": 27482, "update_curr_idle": 27483, "update_curr_rt": 27484, "update_deref_fetch_param": 27485, "update_domain_attr": 27486, "update_domain_attr_tree": 27487, "update_done": 27488, "update_entity_load_avg": 27489, "update_event_printk": 27490, "update_event_times": 27491, "update_fast_ctr": 27492, "update_fast_timekeeper": 27493, "update_flag": 27494, "update_ftrace_function": 27495, "update_function_graph_func": 27496, "update_group_capacity": 27497, "update_group_times": 27498, "update_idle_cpu_load": 27499, "update_if_frozen": 27500, "update_iter": 27501, "update_load_add": 27502, "update_load_set": 27503, "update_load_sub": 27504, "update_lsm_rule": 27505, "update_max_interval": 27506, "update_max_tr": 27507, "update_max_tr_single": 27508, "update_min_vruntime": 27509, "update_next_balance": 27510, "update_nodemask": 27511, "update_nodemasks_hier": 27512, "update_numa_active_node_mask": 27513, "update_numa_stats": 27514, "update_pages_handler": 27515, "update_pages_work": 27516, "update_perf_cpu_limits": 27517, "update_process_times": 27518, "update_protections": 27519, "update_pvclock_gtod": 27520, "update_relax_domain_level": 27521, "update_rlimit_cpu": 27522, "update_rmtp": 27523, "update_rq_clock": 27524, "update_rq_clock_task": 27525, "update_rq_runnable_avg": 27526, "update_rt_migration": 27527, "update_runtime_enabled": 27528, "update_sd_lb_stats": 27529, "update_sd_pick_busiest": 27530, "update_sg_lb_stats": 27531, "update_state": 27532, "update_stats_curr_start": 27533, "update_stats_dequeue": 27534, "update_stats_enqueue": 27535, "update_stats_wait_end": 27536, "update_stats_wait_start": 27537, "update_symbol_cache": 27538, "update_sysctl": 27539, "update_task_scan_period": 27540, "update_tasks_cpumask": 27541, "update_tasks_flags": 27542, "update_tasks_nodemask": 27543, "update_thresh": 27544, "update_top_cache_domain": 27545, "update_traceon_count": 27546, "update_ts_time_stats": 27547, "update_vsyscall": 27548, "update_vsyscall_old": 27549, "update_vsyscall_tz": 27550, "update_wall_time": 27551, "update_watchdog": 27552, "update_watchdog_all_cpus": 27553, "upending": 27554, "upid": 27555, "upper_first": 27556, "upper_last": 27557, "uprobe": 27558, "uprobe_apply": 27559, "uprobe_buffer_disable": 27560, "uprobe_buffer_enable": 27561, "uprobe_buffer_get": 27562, "uprobe_buffer_init": 27563, "uprobe_buffer_put": 27564, "uprobe_buffer_refcnt": 27565, "uprobe_clear_state": 27566, "uprobe_consumer": 27567, "uprobe_copy_insn": 27568, "uprobe_copy_process": 27569, "uprobe_cpu_buffer": 27570, "uprobe_deny_signal": 27571, "uprobe_dispatch_data": 27572, "uprobe_dispatcher": 27573, "uprobe_dup_mmap": 27574, "uprobe_end_dup_mmap": 27575, "uprobe_event_define_fields": 27576, "uprobe_event_system": 27577, "uprobe_events_ops": 27578, "uprobe_exception_nb": 27579, "uprobe_filter_ctx": 27580, "uprobe_filter_event": 27581, "uprobe_filter_is_empty": 27582, "uprobe_filter_mmap": 27583, "uprobe_filter_register": 27584, "uprobe_filter_unregister": 27585, "uprobe_free_utask": 27586, "uprobe_funcs": 27587, "uprobe_get_swbp_addr": 27588, "uprobe_get_trap_addr": 27589, "uprobe_handler_mask": 27590, "uprobe_handler_remove": 27591, "uprobe_is_active": 27592, "uprobe_list": 27593, "uprobe_lock": 27594, "uprobe_mmap": 27595, "uprobe_munmap": 27596, "uprobe_notify_resume": 27597, "uprobe_opcode_t": 27598, "uprobe_perf_close": 27599, "uprobe_perf_filter": 27600, "uprobe_perf_func": 27601, "uprobe_perf_open": 27602, "uprobe_post_sstep_notifier": 27603, "uprobe_pre_sstep_notifier": 27604, "uprobe_profile_ops": 27605, "uprobe_register": 27606, "uprobe_start_dup_mmap": 27607, "uprobe_swbp_insn": 27608, "uprobe_swbp_insn_size": 27609, "uprobe_task": 27610, "uprobe_trace_entry_head": 27611, "uprobe_trace_func": 27612, "uprobe_unregister": 27613, "uprobe_warn": 27614, "uprobe_write_opcode": 27615, "uprobe_xol_slot_bytes": 27616, "uprobes_fetch_type_table": 27617, "uprobes_hash_sz": 27618, "uprobes_mmap_hash": 27619, "uprobes_mmap_mutex": 27620, "uprobes_state": 27621, "uprobes_tree": 27622, "uprobes_treelock": 27623, "uptime": 27624, "uptr": 27625, "uretprobe_dispatcher": 27626, "uretprobe_perf_func": 27627, "uretprobe_trace_func": 27628, "uru": 27629, "us": 27630, "usable": 27631, "usage": 27632, "usage_bit": 27633, "usage_mask": 27634, "usage_str": 27635, "usage_traces": 27636, "use": 27637, "use_default": 27638, "use_dfl": 27639, "use_dfl_pwq": 27640, "use_kmalloc": 27641, "use_max_tr": 27642, "use_split_pmd_ptlocks": 27643, "use_task_css_set_links": 27644, "use_ww_ctx": 27645, "usec_per_msec": 27646, "usec_per_sec": 27647, "usec_rem": 27648, "usec_to_hz_adj32": 27649, "usec_to_hz_mul32": 27650, "usec_to_hz_shr32": 27651, "usecs": 27652, "usecs_rem": 27653, "usecs_str": 27654, "usecs_to_jiffies": 27655, "used": 27656, "used_map_cnt": 27657, "used_maps": 27658, "used_space": 27659, "user": 27660, "user_auxv": 27661, "user_disable_single_step": 27662, "user_enable_block_step": 27663, "user_enable_single_step": 27664, "user_extra": 27665, "user_filter": 27666, "user_hz": 27667, "user_lock_limit": 27668, "user_locked": 27669, "user_mask_ptr": 27670, "user_mode": 27671, "user_namespace": 27672, "user_namespaces_init": 27673, "user_ns": 27674, "user_ns_cachep": 27675, "user_only": 27676, "user_page": 27677, "user_regset": 27678, "user_regset_view": 27679, "user_stack": 27680, "user_stack_pointer": 27681, "user_struct": 27682, "user_tick": 27683, "user_tv": 27684, "usermodehelper_bset": 27685, "usermodehelper_disable": 27686, "usermodehelper_disabled": 27687, "usermodehelper_disabled_waitq": 27688, "usermodehelper_enable": 27689, "usermodehelper_inheritable": 27690, "usermodehelper_init": 27691, "usermodehelper_read_lock_wait": 27692, "usermodehelper_read_trylock": 27693, "usermodehelper_table": 27694, "userns_fixup_signal_uid": 27695, "userns_flags": 27696, "userns_get": 27697, "userns_init_flags": 27698, "userns_install": 27699, "userns_may_setgroups": 27700, "userns_operations": 27701, "userns_put": 27702, "userns_setgroups_allowed": 27703, "userns_state_mutex": 27704, "userpg": 27705, "users": 27706, "userstack_entry": 27707, "uset": 27708, "ushort": 27709, "ushrt_max": 27710, "using_ftrace_ops_list_func": 27711, "usize": 27712, "usleep_range": 27713, "uspertick": 27714, "usrc": 27715, "uss": 27716, "uss32": 27717, "uss_ptr": 27718, "ut": 27719, "utask": 27720, "utask_running": 27721, "utask_sstep": 27722, "utask_sstep_ack": 27723, "utask_sstep_trapped": 27724, "uthese": 27725, "utilization_avg_contrib": 27726, "utilization_delta": 27727, "utilization_load_avg": 27728, "utime": 27729, "utimescaled": 27730, "utp": 27731, "uts": 27732, "uts_namespace": 27733, "uts_ns": 27734, "uts_proc_domainname": 27735, "uts_proc_hostname": 27736, "uts_proc_notify": 27737, "uts_release": 27738, "uts_sem": 27739, "utsname": 27740, "utsns_get": 27741, "utsns_install": 27742, "utsns_operations": 27743, "utsns_put": 27744, "utv": 27745, "utx": 27746, "uuid": 27747, "uvalue": 27748, "v": 27749, "v0": 27750, "v1": 27751, "v2": 27752, "va": 27753, "va_copy": 27754, "va_end": 27755, "va_list": 27756, "va_start": 27757, "vaddr": 27758, "vaddr_to_offset": 27759, "val": 27760, "val2": 27761, "val3": 27762, "val_a": 27763, "val_b": 27764, "val_idx": 27765, "valid": 27766, "valid_signal": 27767, "valid_state": 27768, "valid_vma": 27769, "validate_chain": 27770, "validate_change": 27771, "validate_coredump_safety": 27772, "validate_creds": 27773, "validate_creds_for_do_exit": 27774, "validate_prctl_map": 27775, "valp": 27776, "value": 27777, "value_regno": 27778, "value_size": 27779, "values": 27780, "var": 27781, "variable": 27782, "varray": 27783, "vattr": 27784, "vb": 27785, "vc": 27786, "vcaps": 27787, "vd": 27788, "vdiff": 27789, "vdso32_enabled": 27790, "vdso_enabled": 27791, "ve": 27792, "vec": 27793, "vec_nr": 27794, "vendor": 27795, "ver": 27796, "verbose": 27797, "verbose_torout_errstring": 27798, "verbose_torout_string": 27799, "verif_pid": 27800, "verifier_env": 27801, "verifier_stack_elem": 27802, "verifier_state": 27803, "verifier_state_list": 27804, "verify_export_symbols": 27805, "verify_opcode": 27806, "verify_read": 27807, "verify_write": 27808, "vermagic": 27809, "vermagic_string": 27810, "vernum": 27811, "vers": 27812, "versindex": 27813, "version": 27814, "version_code": 27815, "version_sysfs_builtin": 27816, "versions": 27817, "very_verbose": 27818, "vf": 27819, "vfork": 27820, "vfork_done": 27821, "vfree": 27822, "vfs_cap_flags_effective": 27823, "vfs_cap_revision_mask": 27824, "vfs_cap_revision_shift": 27825, "vfs_getattr": 27826, "vfs_read": 27827, "vfs_statfs": 27828, "vfsmount": 27829, "vfsmount_mark": 27830, "vg": 27831, "vh": 27832, "via": 27833, "victim": 27834, "view": 27835, "virq": 27836, "virt": 27837, "virt_addr_valid": 27838, "virt_exp": 27839, "virt_to_head_page": 27840, "virt_to_page": 27841, "virt_to_phys": 27842, "virtmem": 27843, "virtual": 27844, "visible": 27845, "vleft": 27846, "vm_account": 27847, "vm_area_cachep": 27848, "vm_area_struct": 27849, "vm_block_dump": 27850, "vm_bug_on_mm": 27851, "vm_denywrite": 27852, "vm_dirty_background": 27853, "vm_dirty_bytes": 27854, "vm_dirty_ratio": 27855, "vm_dontcopy": 27856, "vm_dontdump": 27857, "vm_dontexpand": 27858, "vm_drop_pagecache": 27859, "vm_end": 27860, "vm_exec": 27861, "vm_fault": 27862, "vm_fault_sigbus": 27863, "vm_file": 27864, "vm_flags": 27865, "vm_flags_t": 27866, "vm_highmem_is_dirtyable": 27867, "vm_hugetlb": 27868, "vm_hugetlb_group": 27869, "vm_init_def_mask": 27870, "vm_io": 27871, "vm_laptop_mode": 27872, "vm_legacy_va_layout": 27873, "vm_locked": 27874, "vm_lowmem_reserve_ratio": 27875, "vm_max_map_count": 27876, "vm_mayexec": 27877, "vm_mayshare": 27878, "vm_min_free_kbytes": 27879, "vm_min_slab": 27880, "vm_min_unmapped": 27881, "vm_mm": 27882, "vm_next": 27883, "vm_nohugepage": 27884, "vm_operations_struct": 27885, "vm_ops": 27886, "vm_overcommit_memory": 27887, "vm_overcommit_ratio": 27888, "vm_page_cluster": 27889, "vm_page_prot": 27890, "vm_panic_on_oom": 27891, "vm_percpu_pagelist_fraction": 27892, "vm_pgoff": 27893, "vm_prev": 27894, "vm_rb": 27895, "vm_read": 27896, "vm_shared": 27897, "vm_start": 27898, "vm_stat_account": 27899, "vm_swappiness": 27900, "vm_table": 27901, "vm_unacct_memory": 27902, "vm_vdso_enabled": 27903, "vm_vfs_cache_pressure": 27904, "vm_write": 27905, "vm_zone_reclaim_mode": 27906, "vma": 27907, "vma_dup_policy": 27908, "vma_end": 27909, "vma_has_uprobes": 27910, "vma_interval_tree_foreach": 27911, "vma_interval_tree_insert_after": 27912, "vma_migratable": 27913, "vma_pages": 27914, "vma_policy": 27915, "vma_policy_mof": 27916, "vma_size": 27917, "vmacache": 27918, "vmacache_flush": 27919, "vmacache_seqnum": 27920, "vmalloc": 27921, "vmalloc_exec": 27922, "vmalloc_sync_all": 27923, "vmalloc_to_page": 27924, "vmalloc_user": 27925, "vmcoreinfo_bytes": 27926, "vmcoreinfo_data": 27927, "vmcoreinfo_max_size": 27928, "vmcoreinfo_note": 27929, "vmcoreinfo_note_size": 27930, "vmcoreinfo_size": 27931, "vmf": 27932, "vmlinux_symbol_str": 27933, "vmstart": 27934, "vnr": 27935, "void": 27936, "vp": 27937, "vpid": 27938, "vprintk": 27939, "vruntime": 27940, "vscnprintf": 27941, "vsize": 27942, "vsnprintf": 27943, "vtime_account_idle": 27944, "vtime_account_system": 27945, "vtime_account_user": 27946, "vtime_accounting_enabled": 27947, "vtime_common_account_irq_enter": 27948, "vtime_common_task_switch": 27949, "vtime_delta": 27950, "vtime_gen_account_irq_exit": 27951, "vtime_guest_enter": 27952, "vtime_guest_exit": 27953, "vtime_init_idle": 27954, "vtime_seqlock": 27955, "vtime_sleeping": 27956, "vtime_snap": 27957, "vtime_snap_whence": 27958, "vtime_sys": 27959, "vtime_task_switch": 27960, "vtime_user": 27961, "vtime_user_enter": 27962, "vtime_user_exit": 27963, "vzalloc": 27964, "w": 27965, "w1": 27966, "w2": 27967, "w4": 27968, "w8": 27969, "wait": 27970, "wait4": 27971, "wait_again": 27972, "wait_atomic_t_bit_nr": 27973, "wait_bit": 27974, "wait_bit_action_f": 27975, "wait_bit_key": 27976, "wait_bit_queue": 27977, "wait_blkd_tasks": 27978, "wait_chldexit": 27979, "wait_count": 27980, "wait_done": 27981, "wait_event": 27982, "wait_event_interruptible": 27983, "wait_event_interruptible_timeout": 27984, "wait_for_auditd": 27985, "wait_for_completion": 27986, "wait_for_completion_killable": 27987, "wait_for_device_probe": 27988, "wait_for_helper": 27989, "wait_for_kprobe_optimizer": 27990, "wait_for_threads": 27991, "wait_for_vfork_done": 27992, "wait_list": 27993, "wait_lock": 27994, "wait_max": 27995, "wait_on_bit": 27996, "wait_on_page_locked": 27997, "wait_on_pipe": 27998, "wait_queue_head_t": 27999, "wait_queue_t": 28000, "wait_rcu_gp": 28001, "wait_start": 28002, "wait_sum": 28003, "wait_table": 28004, "wait_table_bits": 28005, "wait_task_inactive": 28006, "wait_woken": 28007, "waiter": 28008, "waiters": 28009, "waiters_leftmost": 28010, "waiters_pending": 28011, "waitid": 28012, "waiting": 28013, "waitq": 28014, "waitqueue_active": 28015, "waittime": 28016, "waittime_stamp": 28017, "wake": 28018, "wake_active": 28019, "wake_affine": 28020, "wake_atomic_t_function": 28021, "wake_bit_function": 28022, "wake_cpu": 28023, "wake_depth": 28024, "wake_enabled": 28025, "wake_entry": 28026, "wake_flags": 28027, "wake_idx": 28028, "wake_list": 28029, "wake_nocb_leader": 28030, "wake_threads_waitq": 28031, "wake_type": 28032, "wake_up": 28033, "wake_up_all": 28034, "wake_up_all_idle_cpus": 28035, "wake_up_atomic_t": 28036, "wake_up_bit": 28037, "wake_up_full_nohz_cpu": 28038, "wake_up_idle_cpu": 28039, "wake_up_if_idle": 28040, "wake_up_interruptible": 28041, "wake_up_new_task": 28042, "wake_up_nohz_cpu": 28043, "wake_up_process": 28044, "wake_up_state": 28045, "wake_up_worker": 28046, "wake_wide": 28047, "wakee": 28048, "wakee_flip_decay_ts": 28049, "wakee_flips": 28050, "wakelock": 28051, "wakelock_lookup_add": 28052, "wakelocks_gc": 28053, "wakelocks_gc_count": 28054, "wakelocks_limit_exceeded": 28055, "wakelocks_lock": 28056, "wakelocks_lru_add": 28057, "wakelocks_lru_list": 28058, "wakelocks_lru_most_recent": 28059, "wakelocks_tree": 28060, "wakeme_after_rcu": 28061, "wakeup": 28062, "wakeup_busy": 28063, "wakeup_count": 28064, "wakeup_cpu": 28065, "wakeup_current_cpu": 28066, "wakeup_dl": 28067, "wakeup_dl_tracer": 28068, "wakeup_dl_tracer_init": 28069, "wakeup_events": 28070, "wakeup_flag_changed": 28071, "wakeup_full": 28072, "wakeup_function_set": 28073, "wakeup_gran": 28074, "wakeup_graph_entry": 28075, "wakeup_graph_return": 28076, "wakeup_interval": 28077, "wakeup_lock": 28078, "wakeup_preempt_entity": 28079, "wakeup_preemption": 28080, "wakeup_print_header": 28081, "wakeup_print_line": 28082, "wakeup_prio": 28083, "wakeup_reset": 28084, "wakeup_rt": 28085, "wakeup_rt_tracer": 28086, "wakeup_rt_tracer_init": 28087, "wakeup_set_flag": 28088, "wakeup_softirqd": 28089, "wakeup_source": 28090, "wakeup_source_add": 28091, "wakeup_source_register": 28092, "wakeup_source_unregister": 28093, "wakeup_task": 28094, "wakeup_test_data": 28095, "wakeup_trace": 28096, "wakeup_trace_close": 28097, "wakeup_trace_open": 28098, "wakeup_tracer": 28099, "wakeup_tracer_call": 28100, "wakeup_tracer_init": 28101, "wakeup_tracer_reset": 28102, "wakeup_tracer_start": 28103, "wakeup_tracer_stop": 28104, "wakeup_watermark": 28105, "wakewrite": 28106, "walk": 28107, "walk_iomem_res": 28108, "walk_pred_abort": 28109, "walk_pred_default": 28110, "walk_pred_parent": 28111, "walk_pred_tree": 28112, "walk_return": 28113, "walk_system_ram_range": 28114, "walk_system_ram_res": 28115, "walk_tg_tree": 28116, "walk_tg_tree_from": 28117, "walker": 28118, "wall_to_monotonic": 28119, "want": 28120, "want_affine": 28121, "want_early": 28122, "wants_signal": 28123, "warn": 28124, "warn_bad_state": 28125, "warn_cpu_offline": 28126, "warn_deprecated_v2": 28127, "warn_failed_init_tracer": 28128, "warn_legacy_capability_use": 28129, "warn_no_rtc": 28130, "warn_no_thread": 28131, "warn_on": 28132, "warn_on_once": 28133, "warn_once": 28134, "warn_ratelimit": 28135, "warn_slowpath_common": 28136, "warn_slowpath_fmt": 28137, "warn_slowpath_fmt_taint": 28138, "warn_slowpath_null": 28139, "warn_sysctl_write": 28140, "warned": 28141, "warned_broken_hierarchy": 28142, "warning": 28143, "warning_freq": 28144, "warp_clock": 28145, "was": 28146, "was_freezing": 28147, "was_frozen": 28148, "was_periodic": 28149, "was_set": 28150, "was_stopped": 28151, "watch": 28152, "watch_found": 28153, "watchdog": 28154, "watchdog_cleanup": 28155, "watchdog_disable": 28156, "watchdog_disable_all_cpus": 28157, "watchdog_enable": 28158, "watchdog_enable_all_cpus": 28159, "watchdog_enabled": 28160, "watchdog_ev": 28161, "watchdog_hrtimer": 28162, "watchdog_interrupt_count": 28163, "watchdog_nmi_disable": 28164, "watchdog_nmi_disable_all": 28165, "watchdog_nmi_enable": 28166, "watchdog_nmi_enable_all": 28167, "watchdog_nmi_touch": 28168, "watchdog_overflow_callback": 28169, "watchdog_param": 28170, "watchdog_proc_mutex": 28171, "watchdog_running": 28172, "watchdog_set_prio": 28173, "watchdog_should_run": 28174, "watchdog_stamp": 28175, "watchdog_task": 28176, "watchdog_threads": 28177, "watchdog_thresh": 28178, "watchdog_timer_fn": 28179, "watchdog_touch_ts": 28180, "watchdog_user_enabled": 28181, "watches": 28182, "watermark": 28183, "way": 28184, "wchar": 28185, "wcount": 28186, "wd_attr": 28187, "wd_hw_attr": 28188, "wd_last": 28189, "wd_now": 28190, "we": 28191, "weak": 28192, "weight": 28193, "weight_idleprio": 28194, "weighted_cpuload": 28195, "wf_fork": 28196, "wf_migrated": 28197, "wf_sync": 28198, "wfc": 28199, "wg": 28200, "what": 28201, "what2act": 28202, "when": 28203, "whence": 28204, "which": 28205, "which_clock": 28206, "whichcpu": 28207, "while": 28208, "while_each_pid_task": 28209, "while_each_pid_thread": 28210, "while_each_thread": 28211, "while_for_each_event_file": 28212, "while_for_each_ftrace_op": 28213, "while_for_each_ftrace_rec": 28214, "who": 28215, "why": 28216, "width": 28217, "will": 28218, "will_be_gpl_only": 28219, "windows": 28220, "with": 28221, "within": 28222, "within_kprobe_blacklist": 28223, "within_module": 28224, "within_module_core": 28225, "within_module_init": 28226, "without": 28227, "wl": 28228, "wl_gc_count_max": 28229, "wl_gc_time_sec": 28230, "wlist": 28231, "wm": 28232, "wmb": 28233, "wmult_const": 28234, "wmult_idleprio": 28235, "wmult_shift": 28236, "woke_up": 28237, "woken": 28238, "woken_wake_function": 28239, "word": 28240, "words": 28241, "work": 28242, "work1": 28243, "work2": 28244, "work_buf": 28245, "work_busy": 28246, "work_busy_pending": 28247, "work_busy_running": 28248, "work_color": 28249, "work_color_to_flags": 28250, "work_cpu_unbound": 28251, "work_data_bits": 28252, "work_debug_descr": 28253, "work_debug_hint": 28254, "work_exited": 28255, "work_fixup_activate": 28256, "work_fixup_free": 28257, "work_fixup_init": 28258, "work_flags": 28259, "work_for_cpu": 28260, "work_for_cpu_fn": 28261, "work_func_t": 28262, "work_is_canceling": 28263, "work_list": 28264, "work_next_color": 28265, "work_no_color": 28266, "work_nr_colors": 28267, "work_offq_canceling": 28268, "work_offq_pool_none": 28269, "work_offq_pool_shift": 28270, "work_on_cpu": 28271, "work_pending": 28272, "work_static": 28273, "work_struct": 28274, "work_struct_color_shift": 28275, "work_struct_delayed": 28276, "work_struct_delayed_bit": 28277, "work_struct_flag_mask": 28278, "work_struct_linked": 28279, "work_struct_linked_bit": 28280, "work_struct_pending": 28281, "work_struct_pending_bit": 28282, "work_struct_pwq": 28283, "work_struct_static_bit": 28284, "work_struct_wq_data_mask": 28285, "worker": 28286, "worker_attach_to_pool": 28287, "worker_clr_flags": 28288, "worker_cpu_intensive": 28289, "worker_desc_len": 28290, "worker_detach_from_pool": 28291, "worker_die": 28292, "worker_enter_idle": 28293, "worker_flags": 28294, "worker_ida": 28295, "worker_idle": 28296, "worker_leave_idle": 28297, "worker_not_running": 28298, "worker_pool": 28299, "worker_pool_assign_id": 28300, "worker_pool_idr": 28301, "worker_prep": 28302, "worker_ptr": 28303, "worker_rebound": 28304, "worker_set_flags": 28305, "worker_thread": 28306, "worker_unbound": 28307, "workers": 28308, "worklist": 28309, "workp": 28310, "workqueue": 28311, "workqueue_attrs": 28312, "workqueue_congested": 28313, "workqueue_cpu_down_callback": 28314, "workqueue_freezing": 28315, "workqueue_set_max_active": 28316, "workqueue_struct": 28317, "workqueue_sysfs_register": 28318, "workqueue_sysfs_unregister": 28319, "workqueues": 28320, "works": 28321, "would": 28322, "wq": 28323, "wq_barrier": 28324, "wq_barrier_func": 28325, "wq_busy": 28326, "wq_calc_node_cpumask": 28327, "wq_clamp_max_active": 28328, "wq_cpu_intensive": 28329, "wq_cpumask_show": 28330, "wq_cpumask_store": 28331, "wq_dev": 28332, "wq_device": 28333, "wq_device_release": 28334, "wq_dfl_active": 28335, "wq_flag_exclusive": 28336, "wq_flag_woken": 28337, "wq_flusher": 28338, "wq_freezable": 28339, "wq_highpri": 28340, "wq_max_active": 28341, "wq_mayday_lock": 28342, "wq_name_len": 28343, "wq_nice_show": 28344, "wq_nice_store": 28345, "wq_numa_enabled": 28346, "wq_numa_init": 28347, "wq_numa_possible_cpumask": 28348, "wq_numa_show": 28349, "wq_numa_store": 28350, "wq_pool_ids_show": 28351, "wq_pool_mutex": 28352, "wq_power_efficient": 28353, "wq_subsys": 28354, "wq_sysfs": 28355, "wq_sysfs_groups": 28356, "wq_sysfs_init": 28357, "wq_sysfs_prep_attrs": 28358, "wq_sysfs_unbound_attrs": 28359, "wq_unbind_fn": 28360, "wq_unbound": 28361, "wq_unbound_max_active": 28362, "wq_update_unbound_numa": 28363, "wq_update_unbound_numa_attrs_buf": 28364, "wq_worker_sleeping": 28365, "wq_worker_waking_up": 28366, "wqattrs_equal": 28367, "wqattrs_hash": 28368, "wrap_max": 28369, "wrap_min": 28370, "wraps": 28371, "write": 28372, "write_bufsize": 28373, "write_bytes": 28374, "write_can_lock": 28375, "write_char": 28376, "write_ctr": 28377, "write_delay": 28378, "write_holdtime": 28379, "write_irq_affinity": 28380, "write_iteration": 28381, "write_lock": 28382, "write_lock_irq": 28383, "write_lock_irqsave": 28384, "write_mask": 28385, "write_mem_msg": 28386, "write_once": 28387, "write_page": 28388, "write_profile": 28389, "write_s64": 28390, "write_seqcount_begin": 28391, "write_seqcount_end": 28392, "write_seqlock": 28393, "write_seqlock_irqsave": 28394, "write_sequnlock": 28395, "write_sequnlock_irqrestore": 28396, "write_stamp": 28397, "write_syscalls": 28398, "write_u64": 28399, "write_unlock": 28400, "write_unlock_irq": 28401, "write_unlock_irqrestore": 28402, "write_waitq": 28403, "write_waittime": 28404, "writelock": 28405, "writer_task": 28406, "writer_tasks": 28407, "writes": 28408, "writeunlock": 28409, "written": 28410, "wrk": 28411, "wrt_sysctl": 28412, "ws": 28413, "wtm": 28414, "ww": 28415, "ww_acquire_ctx": 28416, "ww_class": 28417, "ww_ctx": 28418, "ww_mutex": 28419, "ww_mutex_deadlock_injection": 28420, "ww_mutex_lock_acquired": 28421, "ww_mutex_set_context_fastpath": 28422, "ww_mutex_set_context_slowpath": 28423, "ww_mutex_unlock": 28424, "x": 28425, "x86": 28426, "xacct_add_tsk": 28427, "xchg": 28428, "xfs_buf_age": 28429, "xfs_buf_timer": 28430, "xfs_errlevel": 28431, "xfs_filestream_timer": 28432, "xfs_inherit_noatime": 28433, "xfs_inherit_nodfrg": 28434, "xfs_inherit_nodump": 28435, "xfs_inherit_nosym": 28436, "xfs_inherit_sync": 28437, "xfs_panic_mask": 28438, "xfs_rotorstep": 28439, "xfs_sgid_inherit": 28440, "xfs_stats_clear": 28441, "xfs_symlink_mode": 28442, "xfs_syncd_timer": 28443, "xinterval": 28444, "xlate": 28445, "xmitcsum": 28446, "xol_add_vma": 28447, "xol_area": 28448, "xol_free_insn_slot": 28449, "xol_get_insn_slot": 28450, "xol_take_insn_slot": 28451, "xol_vaddr": 28452, "xor": 28453, "xt": 28454, "xtime_interval": 28455, "xtime_nsec": 28456, "xtime_remainder": 28457, "xtime_sec": 28458, "xtime_update": 28459, "xyz": 28460, "y": 28461, "year": 28462, "yes": 28463, "yield": 28464, "yield_task": 28465, "yield_task_fair": 28466, "yield_task_rt": 28467, "yield_to": 28468, "yield_to_task": 28469, "yield_to_task_fair": 28470, "yielded": 28471, "yld_count": 28472, "you": 28473, "your": 28474, "z": 28475, "zalloc_cpumask_var": 28476, "zalloc_cpumask_var_node": 28477, "zap_class": 28478, "zap_other_threads": 28479, "zap_pid_ns_processes": 28480, "zd": 28481, "zero": 28482, "zero_buf": 28483, "zero_buf_sz": 28484, "zero_cpu_stall_ticks": 28485, "zero_page": 28486, "zombie": 28487, "zone": 28488, "zone_end": 28489, "zone_end_pfn": 28490, "zone_found": 28491, "zone_page_state": 28492, "zone_reclaim_mode": 28493, "zone_start": 28494, "zone_start_pfn": 28495, "zones": 28496, "{": 28497, "|": 28498, "||": 28499, "}": 28500, "~": 28501}, "itos": {"0": "<UNK>", "1": "\n", "2": "!", "3": "!=", "4": "\"\n\t\t\t\t\t   \"", "5": "\"\n\t\t\t\t\t  \"", "6": "\"\n\t\t\t\t\t\"", "7": "\"\n\t\t\t\t     \"", "8": "\"\n\t\t\t\t    \"", "9": "\"\n\t\t\t\t   \"", "10": "\"\n\t\t\t\t\"", "11": "\"\n\t\t\t       \"", "12": "\"\n\t\t\t     \"", "13": "\"\n\t\t\t   \"", "14": "\"\n\t\t\t\"", "15": "\"\n\t\t\tgoto cpy_name;\n\t\t}\n\t\t\n\t\tname = d_path(&file->f_path, buf, path_max - sizeof(u64));\n\t\tif (is_err(name)) {\n\t\t\tname = \"", "16": "\"\n\t\t       \"", "17": "\"\n\t\t    \"", "18": "\"\n\t\t   \"", "19": "\"\n\t\t \"", "20": "\"\n\t\t\"", "21": "\"\n\t\tgoto cpy_name;\n\t}\n\ncpy_name:\n\tstrlcpy(tmp, name, sizeof(tmp));\n\tname = tmp;\ngot_name:\n\t\n\tsize = strlen(name)+1;\n\twhile (!is_aligned(size, sizeof(u64)))\n\t\tname[size++] = '\\0';\n\n\tmmap_event->file_name = name;\n\tmmap_event->file_size = size;\n\tmmap_event->maj = maj;\n\tmmap_event->min = min;\n\tmmap_event->ino = ino;\n\tmmap_event->ino_generation = gen;\n\tmmap_event->prot = prot;\n\tmmap_event->flags = flags;\n\n\tif (!(vma->vm_flags & vm_exec))\n\t\tmmap_event->event_id.header.misc |= perf_record_misc_mmap_data;\n\n\tmmap_event->event_id.header.size = sizeof(mmap_event->event_id) + size;\n\n\tperf_event_aux(perf_event_mmap_output,\n\t\t       mmap_event,\n\t\t       null);\n\n\tkfree(buf);\n}\n\nvoid perf_event_mmap(struct vm_area_struct *vma)\n{\n\tstruct perf_mmap_event mmap_event;\n\n\tif (!atomic_read(&nr_mmap_events))\n\t\treturn;\n\n\tmmap_event = (struct perf_mmap_event){\n\t\t.vma\t= vma,\n\t\t\n\t\t\n\t\t.event_id  = {\n\t\t\t.header = {\n\t\t\t\t.type = perf_record_mmap,\n\t\t\t\t.misc = perf_record_misc_user,\n\t\t\t\t\n\t\t\t},\n\t\t\t\n\t\t\t\n\t\t\t.start  = vma->vm_start,\n\t\t\t.len    = vma->vm_end - vma->vm_start,\n\t\t\t.pgoff  = (u64)vma->vm_pgoff << page_shift,\n\t\t},\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t};\n\n\tperf_event_mmap_event(&mmap_event);\n}\n\nvoid perf_event_aux_event(struct perf_event *event, unsigned long head,\n\t\t\t  unsigned long size, u64 flags)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\toffset;\n\t\tu64\t\t\t\tsize;\n\t\tu64\t\t\t\tflags;\n\t} rec = {\n\t\t.header = {\n\t\t\t.type = perf_record_aux,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(rec),\n\t\t},\n\t\t.offset\t\t= head,\n\t\t.size\t\t= size,\n\t\t.flags\t\t= flags,\n\t};\n\tint ret;\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n\n\nstatic void perf_log_throttle(struct perf_event *event, int enable)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tint ret;\n\n\tstruct {\n\t\tstruct perf_event_header\theader;\n\t\tu64\t\t\t\ttime;\n\t\tu64\t\t\t\tid;\n\t\tu64\t\t\t\tstream_id;\n\t} throttle_event = {\n\t\t.header = {\n\t\t\t.type = perf_record_throttle,\n\t\t\t.misc = 0,\n\t\t\t.size = sizeof(throttle_event),\n\t\t},\n\t\t.time\t\t= perf_event_clock(event),\n\t\t.id\t\t= primary_event_id(event),\n\t\t.stream_id\t= event->id,\n\t};\n\n\tif (enable)\n\t\tthrottle_event.header.type = perf_record_unthrottle;\n\n\tperf_event_header__init_id(&throttle_event.header, &sample, event);\n\n\tret = perf_output_begin(&handle, event,\n\t\t\t\tthrottle_event.header.size);\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, throttle_event);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\tperf_output_end(&handle);\n}\n\nstatic void perf_log_itrace_start(struct perf_event *event)\n{\n\tstruct perf_output_handle handle;\n\tstruct perf_sample_data sample;\n\tstruct perf_aux_event {\n\t\tstruct perf_event_header        header;\n\t\tu32\t\t\t\tpid;\n\t\tu32\t\t\t\ttid;\n\t} rec;\n\tint ret;\n\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\tif (!(event->pmu->capabilities & perf_pmu_cap_itrace) ||\n\t    event->hw.itrace_started)\n\t\treturn;\n\n\tevent->hw.itrace_started = 1;\n\n\trec.header.type\t= perf_record_itrace_start;\n\trec.header.misc\t= 0;\n\trec.header.size\t= sizeof(rec);\n\trec.pid\t= perf_event_pid(event, current);\n\trec.tid\t= perf_event_tid(event, current);\n\n\tperf_event_header__init_id(&rec.header, &sample, event);\n\tret = perf_output_begin(&handle, event, rec.header.size);\n\n\tif (ret)\n\t\treturn;\n\n\tperf_output_put(&handle, rec);\n\tperf_event__output_id_sample(event, &handle, &sample);\n\n\tperf_output_end(&handle);\n}\n\n\n\nstatic int __perf_event_overflow(struct perf_event *event,\n\t\t\t\t   int throttle, struct perf_sample_data *data,\n\t\t\t\t   struct pt_regs *regs)\n{\n\tint events = atomic_read(&event->event_limit);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 seq;\n\tint ret = 0;\n\n\t\n\tif (unlikely(!is_sampling_event(event)))\n\t\treturn 0;\n\n\tseq = __this_cpu_read(perf_throttled_seq);\n\tif (seq != hwc->interrupts_seq) {\n\t\thwc->interrupts_seq = seq;\n\t\thwc->interrupts = 1;\n\t} else {\n\t\thwc->interrupts++;\n\t\tif (unlikely(throttle\n\t\t\t     && hwc->interrupts >= max_samples_per_tick)) {\n\t\t\t__this_cpu_inc(perf_throttled_count);\n\t\t\thwc->interrupts = max_interrupts;\n\t\t\tperf_log_throttle(event, 0);\n\t\t\ttick_nohz_full_kick();\n\t\t\tret = 1;\n\t\t}\n\t}\n\n\tif (event->attr.freq) {\n\t\tu64 now = perf_clock();\n\t\ts64 delta = now - hwc->freq_time_stamp;\n\n\t\thwc->freq_time_stamp = now;\n\n\t\tif (delta > 0 && delta < 2*tick_nsec)\n\t\t\tperf_adjust_period(event, delta, hwc->last_period, true);\n\t}\n\n\t\n\n\tevent->pending_kill = poll_in;\n\tif (events && atomic_dec_and_test(&event->event_limit)) {\n\t\tret = 1;\n\t\tevent->pending_kill = poll_hup;\n\t\tevent->pending_disable = 1;\n\t\tirq_work_queue(&event->pending);\n\t}\n\n\tif (event->overflow_handler)\n\t\tevent->overflow_handler(event, data, regs);\n\telse\n\t\tperf_event_output(event, data, regs);\n\n\tif (event->fasync && event->pending_kill) {\n\t\tevent->pending_wakeup = 1;\n\t\tirq_work_queue(&event->pending);\n\t}\n\n\treturn ret;\n}\n\nint perf_event_overflow(struct perf_event *event,\n\t\t\t  struct perf_sample_data *data,\n\t\t\t  struct pt_regs *regs)\n{\n\treturn __perf_event_overflow(event, 1, data, regs);\n}\n\n\n\nstruct swevent_htable {\n\tstruct swevent_hlist\t\t*swevent_hlist;\n\tstruct mutex\t\t\thlist_mutex;\n\tint\t\t\t\thlist_refcount;\n\n\t\n\tint\t\t\t\trecursion[perf_nr_contexts];\n\n\t\n\tbool\t\t\t\tonline;\n};\n\nstatic define_per_cpu(struct swevent_htable, swevent_htable);\n\n\n\nu64 perf_swevent_set_period(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tu64 period = hwc->last_period;\n\tu64 nr, offset;\n\ts64 old, val;\n\n\thwc->last_period = hwc->sample_period;\n\nagain:\n\told = val = local64_read(&hwc->period_left);\n\tif (val < 0)\n\t\treturn 0;\n\n\tnr = div64_u64(period + val, period);\n\toffset = nr * period;\n\tval -= offset;\n\tif (local64_cmpxchg(&hwc->period_left, old, val) != old)\n\t\tgoto again;\n\n\treturn nr;\n}\n\nstatic void perf_swevent_overflow(struct perf_event *event, u64 overflow,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\tint throttle = 0;\n\n\tif (!overflow)\n\t\toverflow = perf_swevent_set_period(event);\n\n\tif (hwc->interrupts == max_interrupts)\n\t\treturn;\n\n\tfor (; overflow; overflow--) {\n\t\tif (__perf_event_overflow(event, throttle,\n\t\t\t\t\t    data, regs)) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t\tthrottle = 1;\n\t}\n}\n\nstatic void perf_swevent_event(struct perf_event *event, u64 nr,\n\t\t\t       struct perf_sample_data *data,\n\t\t\t       struct pt_regs *regs)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tlocal64_add(nr, &event->count);\n\n\tif (!regs)\n\t\treturn;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tif ((event->attr.sample_type & perf_sample_period) && !event->attr.freq) {\n\t\tdata->period = nr;\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\t} else\n\t\tdata->period = event->hw.last_period;\n\n\tif (nr == 1 && hwc->sample_period == 1 && !event->attr.freq)\n\t\treturn perf_swevent_overflow(event, 1, data, regs);\n\n\tif (local64_add_negative(nr, &hwc->period_left))\n\t\treturn;\n\n\tperf_swevent_overflow(event, 0, data, regs);\n}\n\nstatic int perf_exclude_event(struct perf_event *event,\n\t\t\t      struct pt_regs *regs)\n{\n\tif (event->hw.state & perf_hes_stopped)\n\t\treturn 1;\n\n\tif (regs) {\n\t\tif (event->attr.exclude_user && user_mode(regs))\n\t\t\treturn 1;\n\n\t\tif (event->attr.exclude_kernel && !user_mode(regs))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic int perf_swevent_match(struct perf_event *event,\n\t\t\t\tenum perf_type_id type,\n\t\t\t\tu32 event_id,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->attr.type != type)\n\t\treturn 0;\n\n\tif (event->attr.config != event_id)\n\t\treturn 0;\n\n\tif (perf_exclude_event(event, regs))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic inline u64 swevent_hash(u64 type, u32 event_id)\n{\n\tu64 val = event_id | (type << 32);\n\n\treturn hash_64(val, swevent_hlist_bits);\n}\n\nstatic inline struct hlist_head *\n__find_swevent_head(struct swevent_hlist *hlist, u64 type, u32 event_id)\n{\n\tu64 hash = swevent_hash(type, event_id);\n\n\treturn &hlist->heads[hash];\n}\n\n\nstatic inline struct hlist_head *\nfind_swevent_head_rcu(struct swevent_htable *swhash, u64 type, u32 event_id)\n{\n\tstruct swevent_hlist *hlist;\n\n\thlist = rcu_dereference(swhash->swevent_hlist);\n\tif (!hlist)\n\t\treturn null;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\n\nstatic inline struct hlist_head *\nfind_swevent_head(struct swevent_htable *swhash, struct perf_event *event)\n{\n\tstruct swevent_hlist *hlist;\n\tu32 event_id = event->attr.config;\n\tu64 type = event->attr.type;\n\n\t\n\thlist = rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t  lockdep_is_held(&event->ctx->lock));\n\tif (!hlist)\n\t\treturn null;\n\n\treturn __find_swevent_head(hlist, type, event_id);\n}\n\nstatic void do_perf_sw_event(enum perf_type_id type, u32 event_id,\n\t\t\t\t    u64 nr,\n\t\t\t\t    struct perf_sample_data *data,\n\t\t\t\t    struct pt_regs *regs)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct perf_event *event;\n\tstruct hlist_head *head;\n\n\trcu_read_lock();\n\thead = find_swevent_head_rcu(swhash, type, event_id);\n\tif (!head)\n\t\tgoto end;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_swevent_match(event, type, event_id, data, regs))\n\t\t\tperf_swevent_event(event, nr, data, regs);\n\t}\nend:\n\trcu_read_unlock();\n}\n\ndefine_per_cpu(struct pt_regs, __perf_regs[4]);\n\nint perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}\nexport_symbol_gpl(perf_swevent_get_recursion_context);\n\ninline void perf_swevent_put_recursion_context(int rctx)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\tput_recursion_context(swhash->recursion, rctx);\n}\n\nvoid ___perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tstruct perf_sample_data data;\n\n\tif (warn_on_once(!regs))\n\t\treturn;\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdo_perf_sw_event(perf_type_software, event_id, nr, &data, regs);\n}\n\nvoid __perf_sw_event(u32 event_id, u64 nr, struct pt_regs *regs, u64 addr)\n{\n\tint rctx;\n\n\tpreempt_disable_notrace();\n\trctx = perf_swevent_get_recursion_context();\n\tif (unlikely(rctx < 0))\n\t\tgoto fail;\n\n\t___perf_sw_event(event_id, nr, regs, addr);\n\n\tperf_swevent_put_recursion_context(rctx);\nfail:\n\tpreempt_enable_notrace();\n}\n\nstatic void perf_swevent_read(struct perf_event *event)\n{\n}\n\nstatic int perf_swevent_add(struct perf_event *event, int flags)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\tstruct hw_perf_event *hwc = &event->hw;\n\tstruct hlist_head *head;\n\n\tif (is_sampling_event(event)) {\n\t\thwc->last_period = hwc->sample_period;\n\t\tperf_swevent_set_period(event);\n\t}\n\n\thwc->state = !(flags & perf_ef_start);\n\n\thead = find_swevent_head(swhash, event);\n\tif (!head) {\n\t\t\n\t\twarn_on_once(swhash->online);\n\t\treturn -einval;\n\t}\n\n\thlist_add_head_rcu(&event->hlist_entry, head);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void perf_swevent_del(struct perf_event *event, int flags)\n{\n\thlist_del_rcu(&event->hlist_entry);\n}\n\nstatic void perf_swevent_start(struct perf_event *event, int flags)\n{\n\tevent->hw.state = 0;\n}\n\nstatic void perf_swevent_stop(struct perf_event *event, int flags)\n{\n\tevent->hw.state = perf_hes_stopped;\n}\n\n\nstatic inline struct swevent_hlist *\nswevent_hlist_deref(struct swevent_htable *swhash)\n{\n\treturn rcu_dereference_protected(swhash->swevent_hlist,\n\t\t\t\t\t lockdep_is_held(&swhash->hlist_mutex));\n}\n\nstatic void swevent_hlist_release(struct swevent_htable *swhash)\n{\n\tstruct swevent_hlist *hlist = swevent_hlist_deref(swhash);\n\n\tif (!hlist)\n\t\treturn;\n\n\trcu_init_pointer(swhash->swevent_hlist, null);\n\tkfree_rcu(hlist, rcu_head);\n}\n\nstatic void swevent_hlist_put_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!--swhash->hlist_refcount)\n\t\tswevent_hlist_release(swhash);\n\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n\nstatic void swevent_hlist_put(struct perf_event *event)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tswevent_hlist_put_cpu(event, cpu);\n}\n\nstatic int swevent_hlist_get_cpu(struct perf_event *event, int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\tint err = 0;\n\n\tmutex_lock(&swhash->hlist_mutex);\n\n\tif (!swevent_hlist_deref(swhash) && cpu_online(cpu)) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc(sizeof(*hlist), gfp_kernel);\n\t\tif (!hlist) {\n\t\t\terr = -enomem;\n\t\t\tgoto exit;\n\t\t}\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tswhash->hlist_refcount++;\nexit:\n\tmutex_unlock(&swhash->hlist_mutex);\n\n\treturn err;\n}\n\nstatic int swevent_hlist_get(struct perf_event *event)\n{\n\tint err;\n\tint cpu, failed_cpu;\n\n\tget_online_cpus();\n\tfor_each_possible_cpu(cpu) {\n\t\terr = swevent_hlist_get_cpu(event, cpu);\n\t\tif (err) {\n\t\t\tfailed_cpu = cpu;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tput_online_cpus();\n\n\treturn 0;\nfail:\n\tfor_each_possible_cpu(cpu) {\n\t\tif (cpu == failed_cpu)\n\t\t\tbreak;\n\t\tswevent_hlist_put_cpu(event, cpu);\n\t}\n\n\tput_online_cpus();\n\treturn err;\n}\n\nstruct static_key perf_swevent_enabled[perf_count_sw_max];\n\nstatic void sw_perf_event_destroy(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\twarn_on(event->parent);\n\n\tstatic_key_slow_dec(&perf_swevent_enabled[event_id]);\n\tswevent_hlist_put(event);\n}\n\nstatic int perf_swevent_init(struct perf_event *event)\n{\n\tu64 event_id = event->attr.config;\n\n\tif (event->attr.type != perf_type_software)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\tswitch (event_id) {\n\tcase perf_count_sw_cpu_clock:\n\tcase perf_count_sw_task_clock:\n\t\treturn -enoent;\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\tif (event_id >= perf_count_sw_max)\n\t\treturn -enoent;\n\n\tif (!event->parent) {\n\t\tint err;\n\n\t\terr = swevent_hlist_get(event);\n\t\tif (err)\n\t\t\treturn err;\n\n\t\tstatic_key_slow_inc(&perf_swevent_enabled[event_id]);\n\t\tevent->destroy = sw_perf_event_destroy;\n\t}\n\n\treturn 0;\n}\n\nstatic struct pmu perf_swevent = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= perf_pmu_cap_no_nmi,\n\n\t.event_init\t= perf_swevent_init,\n\t.add\t\t= perf_swevent_add,\n\t.del\t\t= perf_swevent_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\n#ifdef config_event_tracing\n\nstatic int perf_tp_filter_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data)\n{\n\tvoid *record = data->raw->data;\n\n\tif (likely(!event->filter) || filter_match_preds(event->filter, record))\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic int perf_tp_event_match(struct perf_event *event,\n\t\t\t\tstruct perf_sample_data *data,\n\t\t\t\tstruct pt_regs *regs)\n{\n\tif (event->hw.state & perf_hes_stopped)\n\t\treturn 0;\n\t\n\tif (event->attr.exclude_kernel)\n\t\treturn 0;\n\n\tif (!perf_tp_filter_match(event, data))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nvoid perf_tp_event(u64 addr, u64 count, void *record, int entry_size,\n\t\t   struct pt_regs *regs, struct hlist_head *head, int rctx,\n\t\t   struct task_struct *task)\n{\n\tstruct perf_sample_data data;\n\tstruct perf_event *event;\n\n\tstruct perf_raw_record raw = {\n\t\t.size = entry_size,\n\t\t.data = record,\n\t};\n\n\tperf_sample_data_init(&data, addr, 0);\n\tdata.raw = &raw;\n\n\thlist_for_each_entry_rcu(event, head, hlist_entry) {\n\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\tperf_swevent_event(event, count, &data, regs);\n\t}\n\n\t\n\tif (task && task != current) {\n\t\tstruct perf_event_context *ctx;\n\t\tstruct trace_entry *entry = record;\n\n\t\trcu_read_lock();\n\t\tctx = rcu_dereference(task->perf_event_ctxp[perf_sw_context]);\n\t\tif (!ctx)\n\t\t\tgoto unlock;\n\n\t\tlist_for_each_entry_rcu(event, &ctx->event_list, event_entry) {\n\t\t\tif (event->attr.type != perf_type_tracepoint)\n\t\t\t\tcontinue;\n\t\t\tif (event->attr.config != entry->type)\n\t\t\t\tcontinue;\n\t\t\tif (perf_tp_event_match(event, &data, regs))\n\t\t\t\tperf_swevent_event(event, count, &data, regs);\n\t\t}\nunlock:\n\t\trcu_read_unlock();\n\t}\n\n\tperf_swevent_put_recursion_context(rctx);\n}\nexport_symbol_gpl(perf_tp_event);\n\nstatic void tp_perf_event_destroy(struct perf_event *event)\n{\n\tperf_trace_destroy(event);\n}\n\nstatic int perf_tp_event_init(struct perf_event *event)\n{\n\tint err;\n\n\tif (event->attr.type != perf_type_tracepoint)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\terr = perf_trace_init(event);\n\tif (err)\n\t\treturn err;\n\n\tevent->destroy = tp_perf_event_destroy;\n\n\treturn 0;\n}\n\nstatic struct pmu perf_tracepoint = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.event_init\t= perf_tp_event_init,\n\t.add\t\t= perf_trace_add,\n\t.del\t\t= perf_trace_del,\n\t.start\t\t= perf_swevent_start,\n\t.stop\t\t= perf_swevent_stop,\n\t.read\t\t= perf_swevent_read,\n};\n\nstatic inline void perf_tp_register(void)\n{\n\tperf_pmu_register(&perf_tracepoint, \"", "22": "\"\n\t\"", "23": "\"\n\n\n\n#ifdef config_smp\nstatic int\nselect_task_rq_stop(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\treturn task_cpu(p); \n}\n#endif \n\nstatic void\ncheck_preempt_curr_stop(struct rq *rq, struct task_struct *p, int flags)\n{\n\t\n}\n\nstatic struct task_struct *\npick_next_task_stop(struct rq *rq, struct task_struct *prev)\n{\n\tstruct task_struct *stop = rq->stop;\n\n\tif (!stop || !task_on_rq_queued(stop))\n\t\treturn null;\n\n\tput_prev_task(rq, prev);\n\n\tstop->se.exec_start = rq_clock_task(rq);\n\n\treturn stop;\n}\n\nstatic void\nenqueue_task_stop(struct rq *rq, struct task_struct *p, int flags)\n{\n\tadd_nr_running(rq, 1);\n}\n\nstatic void\ndequeue_task_stop(struct rq *rq, struct task_struct *p, int flags)\n{\n\tsub_nr_running(rq, 1);\n}\n\nstatic void yield_task_stop(struct rq *rq)\n{\n\tbug(); \n}\n\nstatic void put_prev_task_stop(struct rq *rq, struct task_struct *prev)\n{\n\tstruct task_struct *curr = rq->curr;\n\tu64 delta_exec;\n\n\tdelta_exec = rq_clock_task(rq) - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec < 0))\n\t\tdelta_exec = 0;\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t\tmax(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = rq_clock_task(rq);\n\tcpuacct_charge(curr, delta_exec);\n}\n\nstatic void task_tick_stop(struct rq *rq, struct task_struct *curr, int queued)\n{\n}\n\nstatic void set_curr_task_stop(struct rq *rq)\n{\n\tstruct task_struct *stop = rq->stop;\n\n\tstop->se.exec_start = rq_clock_task(rq);\n}\n\nstatic void switched_to_stop(struct rq *rq, struct task_struct *p)\n{\n\tbug(); \n}\n\nstatic void\nprio_changed_stop(struct rq *rq, struct task_struct *p, int oldprio)\n{\n\tbug(); \n}\n\nstatic unsigned int\nget_rr_interval_stop(struct rq *rq, struct task_struct *task)\n{\n\treturn 0;\n}\n\nstatic void update_curr_stop(struct rq *rq)\n{\n}\n\n\nconst struct sched_class stop_sched_class = {\n\t.next\t\t\t= &dl_sched_class,\n\n\t.enqueue_task\t\t= enqueue_task_stop,\n\t.dequeue_task\t\t= dequeue_task_stop,\n\t.yield_task\t\t= yield_task_stop,\n\n\t.check_preempt_curr\t= check_preempt_curr_stop,\n\n\t.pick_next_task\t\t= pick_next_task_stop,\n\t.put_prev_task\t\t= put_prev_task_stop,\n\n#ifdef config_smp\n\t.select_task_rq\t\t= select_task_rq_stop,\n#endif\n\n\t.set_curr_task          = set_curr_task_stop,\n\t.task_tick\t\t= task_tick_stop,\n\n\t.get_rr_interval\t= get_rr_interval_stop,\n\n\t.prio_changed\t\t= prio_changed_stop,\n\t.switched_to\t\t= switched_to_stop,\n\t.update_curr\t\t= update_curr_stop,\n};\n\n\n#include <linux/module.h>\n#include <linux/ftrace.h>\n\n#include \"", "24": "\"\n\n\n\n#ifndef config_have_futex_cmpxchg\nint __read_mostly futex_cmpxchg_enabled;\n#endif\n\n\n#define flags_shared\t\t0x01\n#define flags_clockrt\t\t0x02\n#define flags_has_timeout\t0x04\n\n\nstruct futex_pi_state {\n\t\n\tstruct list_head list;\n\n\t\n\tstruct rt_mutex pi_mutex;\n\n\tstruct task_struct *owner;\n\tatomic_t refcount;\n\n\tunion futex_key key;\n};\n\n\nstruct futex_q {\n\tstruct plist_node list;\n\n\tstruct task_struct *task;\n\tspinlock_t *lock_ptr;\n\tunion futex_key key;\n\tstruct futex_pi_state *pi_state;\n\tstruct rt_mutex_waiter *rt_waiter;\n\tunion futex_key *requeue_pi_key;\n\tu32 bitset;\n};\n\nstatic const struct futex_q futex_q_init = {\n\t\n\t.key = futex_key_init,\n\t.bitset = futex_bitset_match_any\n};\n\n\nstruct futex_hash_bucket {\n\tatomic_t waiters;\n\tspinlock_t lock;\n\tstruct plist_head chain;\n} ____cacheline_aligned_in_smp;\n\nstatic unsigned long __read_mostly futex_hashsize;\n\nstatic struct futex_hash_bucket *futex_queues;\n\nstatic inline void futex_get_mm(union futex_key *key)\n{\n\tatomic_inc(&key->private.mm->mm_count);\n\t\n\tsmp_mb__after_atomic();\n}\n\n\nstatic inline void hb_waiters_inc(struct futex_hash_bucket *hb)\n{\n#ifdef config_smp\n\tatomic_inc(&hb->waiters);\n\t\n\tsmp_mb__after_atomic();\n#endif\n}\n\n\nstatic inline void hb_waiters_dec(struct futex_hash_bucket *hb)\n{\n#ifdef config_smp\n\tatomic_dec(&hb->waiters);\n#endif\n}\n\nstatic inline int hb_waiters_pending(struct futex_hash_bucket *hb)\n{\n#ifdef config_smp\n\treturn atomic_read(&hb->waiters);\n#else\n\treturn 1;\n#endif\n}\n\n\nstatic struct futex_hash_bucket *hash_futex(union futex_key *key)\n{\n\tu32 hash = jhash2((u32*)&key->both.word,\n\t\t\t  (sizeof(key->both.word)+sizeof(key->both.ptr))/4,\n\t\t\t  key->both.offset);\n\treturn &futex_queues[hash & (futex_hashsize - 1)];\n}\n\n\nstatic inline int match_futex(union futex_key *key1, union futex_key *key2)\n{\n\treturn (key1 && key2\n\t\t&& key1->both.word == key2->both.word\n\t\t&& key1->both.ptr == key2->both.ptr\n\t\t&& key1->both.offset == key2->both.offset);\n}\n\n\nstatic void get_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr)\n\t\treturn;\n\n\tswitch (key->both.offset & (fut_off_inode|fut_off_mmshared)) {\n\tcase fut_off_inode:\n\t\tihold(key->shared.inode); \n\t\tbreak;\n\tcase fut_off_mmshared:\n\t\tfutex_get_mm(key); \n\t\tbreak;\n\tdefault:\n\t\t\n\t\tsmp_mb(); \n\t}\n}\n\n\nstatic void drop_futex_key_refs(union futex_key *key)\n{\n\tif (!key->both.ptr) {\n\t\t\n\t\twarn_on_once(1);\n\t\treturn;\n\t}\n\n\tswitch (key->both.offset & (fut_off_inode|fut_off_mmshared)) {\n\tcase fut_off_inode:\n\t\tiput(key->shared.inode);\n\t\tbreak;\n\tcase fut_off_mmshared:\n\t\tmmdrop(key->private.mm);\n\t\tbreak;\n\t}\n}\n\n\nstatic int\nget_futex_key(u32 __user *uaddr, int fshared, union futex_key *key, int rw)\n{\n\tunsigned long address = (unsigned long)uaddr;\n\tstruct mm_struct *mm = current->mm;\n\tstruct page *page, *page_head;\n\tint err, ro = 0;\n\n\t\n\tkey->both.offset = address % page_size;\n\tif (unlikely((address % sizeof(u32)) != 0))\n\t\treturn -einval;\n\taddress -= key->both.offset;\n\n\tif (unlikely(!access_ok(rw, uaddr, sizeof(u32))))\n\t\treturn -efault;\n\n\t\n\tif (!fshared) {\n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t\tget_futex_key_refs(key);  \n\t\treturn 0;\n\t}\n\nagain:\n\terr = get_user_pages_fast(address, 1, 1, &page);\n\t\n\tif (err == -efault && rw == verify_read) {\n\t\terr = get_user_pages_fast(address, 1, 0, &page);\n\t\tro = 1;\n\t}\n\tif (err < 0)\n\t\treturn err;\n\telse\n\t\terr = 0;\n\n#ifdef config_transparent_hugepage\n\tpage_head = page;\n\tif (unlikely(pagetail(page))) {\n\t\tput_page(page);\n\t\t\n\t\tlocal_irq_disable();\n\t\tif (likely(__get_user_pages_fast(address, 1, !ro, &page) == 1)) {\n\t\t\tpage_head = compound_head(page);\n\t\t\t\n\t\t\tif (page != page_head) {\n\t\t\t\tget_page(page_head);\n\t\t\t\tput_page(page);\n\t\t\t}\n\t\t\tlocal_irq_enable();\n\t\t} else {\n\t\t\tlocal_irq_enable();\n\t\t\tgoto again;\n\t\t}\n\t}\n#else\n\tpage_head = compound_head(page);\n\tif (page != page_head) {\n\t\tget_page(page_head);\n\t\tput_page(page);\n\t}\n#endif\n\n\tlock_page(page_head);\n\n\t\n\tif (!page_head->mapping) {\n\t\tint shmem_swizzled = pageswapcache(page_head);\n\t\tunlock_page(page_head);\n\t\tput_page(page_head);\n\t\tif (shmem_swizzled)\n\t\t\tgoto again;\n\t\treturn -efault;\n\t}\n\n\t\n\tif (pageanon(page_head)) {\n\t\t\n\t\tif (ro) {\n\t\t\terr = -efault;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey->both.offset |= fut_off_mmshared; \n\t\tkey->private.mm = mm;\n\t\tkey->private.address = address;\n\t} else {\n\t\tkey->both.offset |= fut_off_inode; \n\t\tkey->shared.inode = page_head->mapping->host;\n\t\tkey->shared.pgoff = basepage_index(page);\n\t}\n\n\tget_futex_key_refs(key); \n\nout:\n\tunlock_page(page_head);\n\tput_page(page_head);\n\treturn err;\n}\n\nstatic inline void put_futex_key(union futex_key *key)\n{\n\tdrop_futex_key_refs(key);\n}\n\n\nstatic int fault_in_user_writeable(u32 __user *uaddr)\n{\n\tstruct mm_struct *mm = current->mm;\n\tint ret;\n\n\tdown_read(&mm->mmap_sem);\n\tret = fixup_user_fault(current, mm, (unsigned long)uaddr,\n\t\t\t       fault_flag_write);\n\tup_read(&mm->mmap_sem);\n\n\treturn ret < 0 ? ret : 0;\n}\n\n\nstatic struct futex_q *futex_top_waiter(struct futex_hash_bucket *hb,\n\t\t\t\t\tunion futex_key *key)\n{\n\tstruct futex_q *this;\n\n\tplist_for_each_entry(this, &hb->chain, list) {\n\t\tif (match_futex(&this->key, key))\n\t\t\treturn this;\n\t}\n\treturn null;\n}\n\nstatic int cmpxchg_futex_value_locked(u32 *curval, u32 __user *uaddr,\n\t\t\t\t      u32 uval, u32 newval)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = futex_atomic_cmpxchg_inatomic(curval, uaddr, uval, newval);\n\tpagefault_enable();\n\n\treturn ret;\n}\n\nstatic int get_futex_value_locked(u32 *dest, u32 __user *from)\n{\n\tint ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dest, from, sizeof(u32));\n\tpagefault_enable();\n\n\treturn ret ? -efault : 0;\n}\n\n\n\nstatic int refill_pi_state_cache(void)\n{\n\tstruct futex_pi_state *pi_state;\n\n\tif (likely(current->pi_state_cache))\n\t\treturn 0;\n\n\tpi_state = kzalloc(sizeof(*pi_state), gfp_kernel);\n\n\tif (!pi_state)\n\t\treturn -enomem;\n\n\tinit_list_head(&pi_state->list);\n\t\n\tpi_state->owner = null;\n\tatomic_set(&pi_state->refcount, 1);\n\tpi_state->key = futex_key_init;\n\n\tcurrent->pi_state_cache = pi_state;\n\n\treturn 0;\n}\n\nstatic struct futex_pi_state * alloc_pi_state(void)\n{\n\tstruct futex_pi_state *pi_state = current->pi_state_cache;\n\n\twarn_on(!pi_state);\n\tcurrent->pi_state_cache = null;\n\n\treturn pi_state;\n}\n\n\nstatic void free_pi_state(struct futex_pi_state *pi_state)\n{\n\tif (!pi_state)\n\t\treturn;\n\n\tif (!atomic_dec_and_test(&pi_state->refcount))\n\t\treturn;\n\n\t\n\tif (pi_state->owner) {\n\t\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\n\t\trt_mutex_proxy_unlock(&pi_state->pi_mutex, pi_state->owner);\n\t}\n\n\tif (current->pi_state_cache)\n\t\tkfree(pi_state);\n\telse {\n\t\t\n\t\tpi_state->owner = null;\n\t\tatomic_set(&pi_state->refcount, 1);\n\t\tcurrent->pi_state_cache = pi_state;\n\t}\n}\n\n\nstatic struct task_struct * futex_find_get_task(pid_t pid)\n{\n\tstruct task_struct *p;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p)\n\t\tget_task_struct(p);\n\n\trcu_read_unlock();\n\n\treturn p;\n}\n\n\nvoid exit_pi_state_list(struct task_struct *curr)\n{\n\tstruct list_head *next, *head = &curr->pi_state_list;\n\tstruct futex_pi_state *pi_state;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key = futex_key_init;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\t\n\traw_spin_lock_irq(&curr->pi_lock);\n\twhile (!list_empty(head)) {\n\n\t\tnext = head->next;\n\t\tpi_state = list_entry(next, struct futex_pi_state, list);\n\t\tkey = pi_state->key;\n\t\thb = hash_futex(&key);\n\t\traw_spin_unlock_irq(&curr->pi_lock);\n\n\t\tspin_lock(&hb->lock);\n\n\t\traw_spin_lock_irq(&curr->pi_lock);\n\t\t\n\t\tif (head->next != next) {\n\t\t\tspin_unlock(&hb->lock);\n\t\t\tcontinue;\n\t\t}\n\n\t\twarn_on(pi_state->owner != curr);\n\t\twarn_on(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\tpi_state->owner = null;\n\t\traw_spin_unlock_irq(&curr->pi_lock);\n\n\t\trt_mutex_unlock(&pi_state->pi_mutex);\n\n\t\tspin_unlock(&hb->lock);\n\n\t\traw_spin_lock_irq(&curr->pi_lock);\n\t}\n\traw_spin_unlock_irq(&curr->pi_lock);\n}\n\n\n\n\nstatic int attach_to_pi_state(u32 uval, struct futex_pi_state *pi_state,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & futex_tid_mask;\n\n\t\n\tif (unlikely(!pi_state))\n\t\treturn -einval;\n\n\twarn_on(!atomic_read(&pi_state->refcount));\n\n\t\n\tif (uval & futex_owner_died) {\n\t\t\n\t\tif (!pi_state->owner) {\n\t\t\t\n\t\t\tif (pid)\n\t\t\t\treturn -einval;\n\t\t\t\n\t\t\tgoto out_state;\n\t\t}\n\n\t\t\n\t\tif (!pid)\n\t\t\tgoto out_state;\n\t} else {\n\t\t\n\t\tif (!pi_state->owner)\n\t\t\treturn -einval;\n\t}\n\n\t\n\tif (pid != task_pid_vnr(pi_state->owner))\n\t\treturn -einval;\nout_state:\n\tatomic_inc(&pi_state->refcount);\n\t*ps = pi_state;\n\treturn 0;\n}\n\n\nstatic int attach_to_pi_owner(u32 uval, union futex_key *key,\n\t\t\t      struct futex_pi_state **ps)\n{\n\tpid_t pid = uval & futex_tid_mask;\n\tstruct futex_pi_state *pi_state;\n\tstruct task_struct *p;\n\n\t\n\tif (!pid)\n\t\treturn -esrch;\n\tp = futex_find_get_task(pid);\n\tif (!p)\n\t\treturn -esrch;\n\n\tif (unlikely(p->flags & pf_kthread)) {\n\t\tput_task_struct(p);\n\t\treturn -eperm;\n\t}\n\n\t\n\traw_spin_lock_irq(&p->pi_lock);\n\tif (unlikely(p->flags & pf_exiting)) {\n\t\t\n\t\tint ret = (p->flags & pf_exitpidone) ? -esrch : -eagain;\n\n\t\traw_spin_unlock_irq(&p->pi_lock);\n\t\tput_task_struct(p);\n\t\treturn ret;\n\t}\n\n\t\n\tpi_state = alloc_pi_state();\n\n\t\n\trt_mutex_init_proxy_locked(&pi_state->pi_mutex, p);\n\n\t\n\tpi_state->key = *key;\n\n\twarn_on(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &p->pi_state_list);\n\tpi_state->owner = p;\n\traw_spin_unlock_irq(&p->pi_lock);\n\n\tput_task_struct(p);\n\n\t*ps = pi_state;\n\n\treturn 0;\n}\n\nstatic int lookup_pi_state(u32 uval, struct futex_hash_bucket *hb,\n\t\t\t   union futex_key *key, struct futex_pi_state **ps)\n{\n\tstruct futex_q *match = futex_top_waiter(hb, key);\n\n\t\n\tif (match)\n\t\treturn attach_to_pi_state(uval, match->pi_state, ps);\n\n\t\n\treturn attach_to_pi_owner(uval, key, ps);\n}\n\nstatic int lock_pi_update_atomic(u32 __user *uaddr, u32 uval, u32 newval)\n{\n\tu32 uninitialized_var(curval);\n\n\tif (unlikely(cmpxchg_futex_value_locked(&curval, uaddr, uval, newval)))\n\t\treturn -efault;\n\n\t\n\treturn curval != uval ? -eagain : 0;\n}\n\n\nstatic int futex_lock_pi_atomic(u32 __user *uaddr, struct futex_hash_bucket *hb,\n\t\t\t\tunion futex_key *key,\n\t\t\t\tstruct futex_pi_state **ps,\n\t\t\t\tstruct task_struct *task, int set_waiters)\n{\n\tu32 uval, newval, vpid = task_pid_vnr(task);\n\tstruct futex_q *match;\n\tint ret;\n\n\t\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\treturn -efault;\n\n\t\n\tif ((unlikely((uval & futex_tid_mask) == vpid)))\n\t\treturn -edeadlk;\n\n\t\n\tmatch = futex_top_waiter(hb, key);\n\tif (match)\n\t\treturn attach_to_pi_state(uval, match->pi_state, ps);\n\n\t\n\tif (!(uval & futex_tid_mask)) {\n\t\t\n\t\tnewval = uval & futex_owner_died;\n\t\tnewval |= vpid;\n\n\t\t\n\t\tif (set_waiters)\n\t\t\tnewval |= futex_waiters;\n\n\t\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\t\t\n\t\treturn ret < 0 ? ret : 1;\n\t}\n\n\t\n\tnewval = uval | futex_waiters;\n\tret = lock_pi_update_atomic(uaddr, uval, newval);\n\tif (ret)\n\t\treturn ret;\n\t\n\treturn attach_to_pi_owner(uval, key, ps);\n}\n\n\nstatic void __unqueue_futex(struct futex_q *q)\n{\n\tstruct futex_hash_bucket *hb;\n\n\tif (warn_on_smp(!q->lock_ptr || !spin_is_locked(q->lock_ptr))\n\t    || warn_on(plist_node_empty(&q->list)))\n\t\treturn;\n\n\thb = container_of(q->lock_ptr, struct futex_hash_bucket, lock);\n\tplist_del(&q->list, &hb->chain);\n\thb_waiters_dec(hb);\n}\n\n\nstatic void wake_futex(struct futex_q *q)\n{\n\tstruct task_struct *p = q->task;\n\n\tif (warn(q->pi_state || q->rt_waiter, \"", "25": "\"\n\n\n\nstatic void\nrt_mutex_set_owner(struct rt_mutex *lock, struct task_struct *owner)\n{\n\tunsigned long val = (unsigned long)owner;\n\n\tif (rt_mutex_has_waiters(lock))\n\t\tval |= rt_mutex_has_waiters;\n\n\tlock->owner = (struct task_struct *)val;\n}\n\nstatic inline void clear_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tlock->owner = (struct task_struct *)\n\t\t\t((unsigned long)lock->owner & ~rt_mutex_has_waiters);\n}\n\nstatic void fixup_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tif (!rt_mutex_has_waiters(lock))\n\t\tclear_rt_mutex_waiters(lock);\n}\n\n\n#if defined(__have_arch_cmpxchg) && !defined(config_debug_rt_mutexes)\n# define rt_mutex_cmpxchg(l,c,n)\t(cmpxchg(&l->owner, c, n) == c)\nstatic inline void mark_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tunsigned long owner, *p = (unsigned long *) &lock->owner;\n\n\tdo {\n\t\towner = *p;\n\t} while (cmpxchg(p, owner, owner | rt_mutex_has_waiters) != owner);\n}\n\n\nstatic inline bool unlock_rt_mutex_safe(struct rt_mutex *lock)\n\t__releases(lock->wait_lock)\n{\n\tstruct task_struct *owner = rt_mutex_owner(lock);\n\n\tclear_rt_mutex_waiters(lock);\n\traw_spin_unlock(&lock->wait_lock);\n\t\n\treturn rt_mutex_cmpxchg(lock, owner, null);\n}\n\n#else\n# define rt_mutex_cmpxchg(l,c,n)\t(0)\nstatic inline void mark_rt_mutex_waiters(struct rt_mutex *lock)\n{\n\tlock->owner = (struct task_struct *)\n\t\t\t((unsigned long)lock->owner | rt_mutex_has_waiters);\n}\n\n\nstatic inline bool unlock_rt_mutex_safe(struct rt_mutex *lock)\n\t__releases(lock->wait_lock)\n{\n\tlock->owner = null;\n\traw_spin_unlock(&lock->wait_lock);\n\treturn true;\n}\n#endif\n\nstatic inline int\nrt_mutex_waiter_less(struct rt_mutex_waiter *left,\n\t\t     struct rt_mutex_waiter *right)\n{\n\tif (left->prio < right->prio)\n\t\treturn 1;\n\n\t\n\tif (dl_prio(left->prio))\n\t\treturn (left->task->dl.deadline < right->task->dl.deadline);\n\n\treturn 0;\n}\n\nstatic void\nrt_mutex_enqueue(struct rt_mutex *lock, struct rt_mutex_waiter *waiter)\n{\n\tstruct rb_node **link = &lock->waiters.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct rt_mutex_waiter *entry;\n\tint leftmost = 1;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct rt_mutex_waiter, tree_entry);\n\t\tif (rt_mutex_waiter_less(waiter, entry)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tlock->waiters_leftmost = &waiter->tree_entry;\n\n\trb_link_node(&waiter->tree_entry, parent, link);\n\trb_insert_color(&waiter->tree_entry, &lock->waiters);\n}\n\nstatic void\nrt_mutex_dequeue(struct rt_mutex *lock, struct rt_mutex_waiter *waiter)\n{\n\tif (rb_empty_node(&waiter->tree_entry))\n\t\treturn;\n\n\tif (lock->waiters_leftmost == &waiter->tree_entry)\n\t\tlock->waiters_leftmost = rb_next(&waiter->tree_entry);\n\n\trb_erase(&waiter->tree_entry, &lock->waiters);\n\trb_clear_node(&waiter->tree_entry);\n}\n\nstatic void\nrt_mutex_enqueue_pi(struct task_struct *task, struct rt_mutex_waiter *waiter)\n{\n\tstruct rb_node **link = &task->pi_waiters.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct rt_mutex_waiter *entry;\n\tint leftmost = 1;\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct rt_mutex_waiter, pi_tree_entry);\n\t\tif (rt_mutex_waiter_less(waiter, entry)) {\n\t\t\tlink = &parent->rb_left;\n\t\t} else {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\ttask->pi_waiters_leftmost = &waiter->pi_tree_entry;\n\n\trb_link_node(&waiter->pi_tree_entry, parent, link);\n\trb_insert_color(&waiter->pi_tree_entry, &task->pi_waiters);\n}\n\nstatic void\nrt_mutex_dequeue_pi(struct task_struct *task, struct rt_mutex_waiter *waiter)\n{\n\tif (rb_empty_node(&waiter->pi_tree_entry))\n\t\treturn;\n\n\tif (task->pi_waiters_leftmost == &waiter->pi_tree_entry)\n\t\ttask->pi_waiters_leftmost = rb_next(&waiter->pi_tree_entry);\n\n\trb_erase(&waiter->pi_tree_entry, &task->pi_waiters);\n\trb_clear_node(&waiter->pi_tree_entry);\n}\n\n\nint rt_mutex_getprio(struct task_struct *task)\n{\n\tif (likely(!task_has_pi_waiters(task)))\n\t\treturn task->normal_prio;\n\n\treturn min(task_top_pi_waiter(task)->prio,\n\t\t   task->normal_prio);\n}\n\nstruct task_struct *rt_mutex_get_top_task(struct task_struct *task)\n{\n\tif (likely(!task_has_pi_waiters(task)))\n\t\treturn null;\n\n\treturn task_top_pi_waiter(task)->task;\n}\n\n\nint rt_mutex_check_prio(struct task_struct *task, int newprio)\n{\n\tif (!task_has_pi_waiters(task))\n\t\treturn 0;\n\n\treturn task_top_pi_waiter(task)->task->prio <= newprio;\n}\n\n\nstatic void __rt_mutex_adjust_prio(struct task_struct *task)\n{\n\tint prio = rt_mutex_getprio(task);\n\n\tif (task->prio != prio || dl_prio(prio))\n\t\trt_mutex_setprio(task, prio);\n}\n\n\nstatic void rt_mutex_adjust_prio(struct task_struct *task)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\t__rt_mutex_adjust_prio(task);\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n}\n\n\nstatic bool rt_mutex_cond_detect_deadlock(struct rt_mutex_waiter *waiter,\n\t\t\t\t\t  enum rtmutex_chainwalk chwalk)\n{\n\t\n\treturn debug_rt_mutex_detect_deadlock(waiter, chwalk);\n}\n\n\nint max_lock_depth = 1024;\n\nstatic inline struct rt_mutex *task_blocked_on_lock(struct task_struct *p)\n{\n\treturn p->pi_blocked_on ? p->pi_blocked_on->lock : null;\n}\n\n\nstatic int rt_mutex_adjust_prio_chain(struct task_struct *task,\n\t\t\t\t      enum rtmutex_chainwalk chwalk,\n\t\t\t\t      struct rt_mutex *orig_lock,\n\t\t\t\t      struct rt_mutex *next_lock,\n\t\t\t\t      struct rt_mutex_waiter *orig_waiter,\n\t\t\t\t      struct task_struct *top_task)\n{\n\tstruct rt_mutex_waiter *waiter, *top_waiter = orig_waiter;\n\tstruct rt_mutex_waiter *prerequeue_top_waiter;\n\tint ret = 0, depth = 0;\n\tstruct rt_mutex *lock;\n\tbool detect_deadlock;\n\tunsigned long flags;\n\tbool requeue = true;\n\n\tdetect_deadlock = rt_mutex_cond_detect_deadlock(orig_waiter, chwalk);\n\n\t\n again:\n\t\n\tif (++depth > max_lock_depth) {\n\t\tstatic int prev_max;\n\n\t\t\n\t\tif (prev_max != max_lock_depth) {\n\t\t\tprev_max = max_lock_depth;\n\t\t\tprintk(kern_warning \"", "26": "\"\n\n\ndefine_per_cpu(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\n\t.lock = __raw_spin_lock_unlocked(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = hrtimer_base_monotonic,\n\t\t\t.clockid = clock_monotonic,\n\t\t\t.get_time = &ktime_get,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t\t{\n\t\t\t.index = hrtimer_base_realtime,\n\t\t\t.clockid = clock_realtime,\n\t\t\t.get_time = &ktime_get_real,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t\t{\n\t\t\t.index = hrtimer_base_boottime,\n\t\t\t.clockid = clock_boottime,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t\t{\n\t\t\t.index = hrtimer_base_tai,\n\t\t\t.clockid = clock_tai,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t\t.resolution = ktime_low_res,\n\t\t},\n\t}\n};\n\nstatic const int hrtimer_clock_to_base_table[max_clocks] = {\n\t[clock_realtime]\t= hrtimer_base_realtime,\n\t[clock_monotonic]\t= hrtimer_base_monotonic,\n\t[clock_boottime]\t= hrtimer_base_boottime,\n\t[clock_tai]\t\t= hrtimer_base_tai,\n};\n\nstatic inline int hrtimer_clockid_to_base(clockid_t clock_id)\n{\n\treturn hrtimer_clock_to_base_table[clock_id];\n}\n\n\n\nstatic void hrtimer_get_softirq_time(struct hrtimer_cpu_base *base)\n{\n\tktime_t xtim, mono, boot, tai;\n\tktime_t off_real, off_boot, off_tai;\n\n\tmono = ktime_get_update_offsets_tick(&off_real, &off_boot, &off_tai);\n\tboot = ktime_add(mono, off_boot);\n\txtim = ktime_add(mono, off_real);\n\ttai = ktime_add(mono, off_tai);\n\n\tbase->clock_base[hrtimer_base_realtime].softirq_time = xtim;\n\tbase->clock_base[hrtimer_base_monotonic].softirq_time = mono;\n\tbase->clock_base[hrtimer_base_boottime].softirq_time = boot;\n\tbase->clock_base[hrtimer_base_tai].softirq_time = tai;\n}\n\n\n#ifdef config_smp\n\n\nstatic\nstruct hrtimer_clock_base *lock_hrtimer_base(const struct hrtimer *timer,\n\t\t\t\t\t     unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base;\n\n\tfor (;;) {\n\t\tbase = timer->base;\n\t\tif (likely(base != null)) {\n\t\t\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\t\t\tif (likely(base == timer->base))\n\t\t\t\treturn base;\n\t\t\t\n\t\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}\n\n\nstatic int\nhrtimer_check_target(struct hrtimer *timer, struct hrtimer_clock_base *new_base)\n{\n#ifdef config_high_res_timers\n\tktime_t expires;\n\n\tif (!new_base->cpu_base->hres_active)\n\t\treturn 0;\n\n\texpires = ktime_sub(hrtimer_get_expires(timer), new_base->offset);\n\treturn expires.tv64 <= new_base->cpu_base->expires_next.tv64;\n#else\n\treturn 0;\n#endif\n}\n\n\nstatic inline struct hrtimer_clock_base *\nswitch_hrtimer_base(struct hrtimer *timer, struct hrtimer_clock_base *base,\n\t\t    int pinned)\n{\n\tstruct hrtimer_clock_base *new_base;\n\tstruct hrtimer_cpu_base *new_cpu_base;\n\tint this_cpu = smp_processor_id();\n\tint cpu = get_nohz_timer_target(pinned);\n\tint basenum = base->index;\n\nagain:\n\tnew_cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tnew_base = &new_cpu_base->clock_base[basenum];\n\n\tif (base != new_base) {\n\t\t\n\t\tif (unlikely(hrtimer_callback_running(timer)))\n\t\t\treturn base;\n\n\t\t\n\t\ttimer->base = null;\n\t\traw_spin_unlock(&base->cpu_base->lock);\n\t\traw_spin_lock(&new_base->cpu_base->lock);\n\n\t\tif (cpu != this_cpu && hrtimer_check_target(timer, new_base)) {\n\t\t\tcpu = this_cpu;\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traw_spin_lock(&base->cpu_base->lock);\n\t\t\ttimer->base = base;\n\t\t\tgoto again;\n\t\t}\n\t\ttimer->base = new_base;\n\t} else {\n\t\tif (cpu != this_cpu && hrtimer_check_target(timer, new_base)) {\n\t\t\tcpu = this_cpu;\n\t\t\tgoto again;\n\t\t}\n\t}\n\treturn new_base;\n}\n\n#else \n\nstatic inline struct hrtimer_clock_base *\nlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\n\traw_spin_lock_irqsave(&base->cpu_base->lock, *flags);\n\n\treturn base;\n}\n\n# define switch_hrtimer_base(t, b, p)\t(b)\n\n#endif\t\n\n\n#if bits_per_long < 64\n\nu64 __ktime_divns(const ktime_t kt, s64 div)\n{\n\tu64 dclc;\n\tint sft = 0;\n\n\tdclc = ktime_to_ns(kt);\n\t\n\twhile (div >> 32) {\n\t\tsft++;\n\t\tdiv >>= 1;\n\t}\n\tdclc >>= sft;\n\tdo_div(dclc, (unsigned long) div);\n\n\treturn dclc;\n}\nexport_symbol_gpl(__ktime_divns);\n#endif \n\n\nktime_t ktime_add_safe(const ktime_t lhs, const ktime_t rhs)\n{\n\tktime_t res = ktime_add(lhs, rhs);\n\n\t\n\tif (res.tv64 < 0 || res.tv64 < lhs.tv64 || res.tv64 < rhs.tv64)\n\t\tres = ktime_set(ktime_sec_max, 0);\n\n\treturn res;\n}\n\nexport_symbol_gpl(ktime_add_safe);\n\n#ifdef config_debug_objects_timers\n\nstatic struct debug_obj_descr hrtimer_debug_descr;\n\nstatic void *hrtimer_debug_hint(void *addr)\n{\n\treturn ((struct hrtimer *) addr)->function;\n}\n\n\nstatic int hrtimer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase odebug_state_active:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_init(timer, &hrtimer_debug_descr);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nstatic int hrtimer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tswitch (state) {\n\n\tcase odebug_state_notavailable:\n\t\twarn_on_once(1);\n\t\treturn 0;\n\n\tcase odebug_state_active:\n\t\twarn_on(1);\n\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\n\nstatic int hrtimer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct hrtimer *timer = addr;\n\n\tswitch (state) {\n\tcase odebug_state_active:\n\t\thrtimer_cancel(timer);\n\t\tdebug_object_free(timer, &hrtimer_debug_descr);\n\t\treturn 1;\n\tdefault:\n\t\treturn 0;\n\t}\n}\n\nstatic struct debug_obj_descr hrtimer_debug_descr = {\n\t.name\t\t= \"", "27": "\"\n\n\ndefine_per_cpu(struct tick_device, tick_cpu_device);\n\nktime_t tick_next_period;\nktime_t tick_period;\n\n\nint tick_do_timer_cpu __read_mostly = tick_do_timer_boot;\n\n\nstruct tick_device *tick_get_device(int cpu)\n{\n\treturn &per_cpu(tick_cpu_device, cpu);\n}\n\n\nint tick_is_oneshot_available(void)\n{\n\tstruct clock_event_device *dev = __this_cpu_read(tick_cpu_device.evtdev);\n\n\tif (!dev || !(dev->features & clock_evt_feat_oneshot))\n\t\treturn 0;\n\tif (!(dev->features & clock_evt_feat_c3stop))\n\t\treturn 1;\n\treturn tick_broadcast_oneshot_available();\n}\n\n\nstatic void tick_periodic(int cpu)\n{\n\tif (tick_do_timer_cpu == cpu) {\n\t\twrite_seqlock(&jiffies_lock);\n\n\t\t\n\t\ttick_next_period = ktime_add(tick_next_period, tick_period);\n\n\t\tdo_timer(1);\n\t\twrite_sequnlock(&jiffies_lock);\n\t\tupdate_wall_time();\n\t}\n\n\tupdate_process_times(user_mode(get_irq_regs()));\n\tprofile_tick(cpu_profiling);\n}\n\n\nvoid tick_handle_periodic(struct clock_event_device *dev)\n{\n\tint cpu = smp_processor_id();\n\tktime_t next = dev->next_event;\n\n\ttick_periodic(cpu);\n\n\tif (dev->state != clock_evt_state_oneshot)\n\t\treturn;\n\tfor (;;) {\n\t\t\n\t\tnext = ktime_add(next, tick_period);\n\n\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\treturn;\n\t\t\n\t\tif (timekeeping_valid_for_hres())\n\t\t\ttick_periodic(cpu);\n\t}\n}\n\n\nvoid tick_setup_periodic(struct clock_event_device *dev, int broadcast)\n{\n\ttick_set_periodic_handler(dev, broadcast);\n\n\t\n\tif (!tick_device_is_functional(dev))\n\t\treturn;\n\n\tif ((dev->features & clock_evt_feat_periodic) &&\n\t    !tick_broadcast_oneshot_active()) {\n\t\tclockevents_set_state(dev, clock_evt_state_periodic);\n\t} else {\n\t\tunsigned long seq;\n\t\tktime_t next;\n\n\t\tdo {\n\t\t\tseq = read_seqbegin(&jiffies_lock);\n\t\t\tnext = tick_next_period;\n\t\t} while (read_seqretry(&jiffies_lock, seq));\n\n\t\tclockevents_set_state(dev, clock_evt_state_oneshot);\n\n\t\tfor (;;) {\n\t\t\tif (!clockevents_program_event(dev, next, false))\n\t\t\t\treturn;\n\t\t\tnext = ktime_add(next, tick_period);\n\t\t}\n\t}\n}\n\n\nstatic void tick_setup_device(struct tick_device *td,\n\t\t\t      struct clock_event_device *newdev, int cpu,\n\t\t\t      const struct cpumask *cpumask)\n{\n\tktime_t next_event;\n\tvoid (*handler)(struct clock_event_device *) = null;\n\n\t\n\tif (!td->evtdev) {\n\t\t\n\t\tif (tick_do_timer_cpu == tick_do_timer_boot) {\n\t\t\tif (!tick_nohz_full_cpu(cpu))\n\t\t\t\ttick_do_timer_cpu = cpu;\n\t\t\telse\n\t\t\t\ttick_do_timer_cpu = tick_do_timer_none;\n\t\t\ttick_next_period = ktime_get();\n\t\t\ttick_period = ktime_set(0, nsec_per_sec / hz);\n\t\t}\n\n\t\t\n\t\ttd->mode = tickdev_mode_periodic;\n\t} else {\n\t\thandler = td->evtdev->event_handler;\n\t\tnext_event = td->evtdev->next_event;\n\t\ttd->evtdev->event_handler = clockevents_handle_noop;\n\t}\n\n\ttd->evtdev = newdev;\n\n\t\n\tif (!cpumask_equal(newdev->cpumask, cpumask))\n\t\tirq_set_affinity(newdev->irq, cpumask);\n\n\t\n\tif (tick_device_uses_broadcast(newdev, cpu))\n\t\treturn;\n\n\tif (td->mode == tickdev_mode_periodic)\n\t\ttick_setup_periodic(newdev, 0);\n\telse\n\t\ttick_setup_oneshot(newdev, handler, next_event);\n}\n\nvoid tick_install_replacement(struct clock_event_device *newdev)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tint cpu = smp_processor_id();\n\n\tclockevents_exchange_device(td->evtdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & clock_evt_feat_oneshot)\n\t\ttick_oneshot_notify();\n}\n\nstatic bool tick_check_percpu(struct clock_event_device *curdev,\n\t\t\t      struct clock_event_device *newdev, int cpu)\n{\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\treturn false;\n\tif (cpumask_equal(newdev->cpumask, cpumask_of(cpu)))\n\t\treturn true;\n\t\n\tif (newdev->irq >= 0 && !irq_can_set_affinity(newdev->irq))\n\t\treturn false;\n\t\n\tif (curdev && cpumask_equal(curdev->cpumask, cpumask_of(cpu)))\n\t\treturn false;\n\treturn true;\n}\n\nstatic bool tick_check_preferred(struct clock_event_device *curdev,\n\t\t\t\t struct clock_event_device *newdev)\n{\n\t\n\tif (!(newdev->features & clock_evt_feat_oneshot)) {\n\t\tif (curdev && (curdev->features & clock_evt_feat_oneshot))\n\t\t\treturn false;\n\t\tif (tick_oneshot_mode_active())\n\t\t\treturn false;\n\t}\n\n\t\n\treturn !curdev ||\n\t\tnewdev->rating > curdev->rating ||\n\t       !cpumask_equal(curdev->cpumask, newdev->cpumask);\n}\n\n\nbool tick_check_replacement(struct clock_event_device *curdev,\n\t\t\t    struct clock_event_device *newdev)\n{\n\tif (!tick_check_percpu(curdev, newdev, smp_processor_id()))\n\t\treturn false;\n\n\treturn tick_check_preferred(curdev, newdev);\n}\n\n\nvoid tick_check_new_device(struct clock_event_device *newdev)\n{\n\tstruct clock_event_device *curdev;\n\tstruct tick_device *td;\n\tint cpu;\n\n\tcpu = smp_processor_id();\n\tif (!cpumask_test_cpu(cpu, newdev->cpumask))\n\t\tgoto out_bc;\n\n\ttd = &per_cpu(tick_cpu_device, cpu);\n\tcurdev = td->evtdev;\n\n\t\n\tif (!tick_check_percpu(curdev, newdev, cpu))\n\t\tgoto out_bc;\n\n\t\n\tif (!tick_check_preferred(curdev, newdev))\n\t\tgoto out_bc;\n\n\tif (!try_module_get(newdev->owner))\n\t\treturn;\n\n\t\n\tif (tick_is_broadcast_device(curdev)) {\n\t\tclockevents_shutdown(curdev);\n\t\tcurdev = null;\n\t}\n\tclockevents_exchange_device(curdev, newdev);\n\ttick_setup_device(td, newdev, cpu, cpumask_of(cpu));\n\tif (newdev->features & clock_evt_feat_oneshot)\n\t\ttick_oneshot_notify();\n\treturn;\n\nout_bc:\n\t\n\ttick_install_broadcast_device(newdev);\n}\n\n#ifdef config_hotplug_cpu\n\nvoid tick_handover_do_timer(void)\n{\n\tif (tick_do_timer_cpu == smp_processor_id()) {\n\t\tint cpu = cpumask_first(cpu_online_mask);\n\n\t\ttick_do_timer_cpu = (cpu < nr_cpu_ids) ? cpu :\n\t\t\ttick_do_timer_none;\n\t}\n}\n\n\nvoid tick_shutdown(unsigned int cpu)\n{\n\tstruct tick_device *td = &per_cpu(tick_cpu_device, cpu);\n\tstruct clock_event_device *dev = td->evtdev;\n\n\ttd->mode = tickdev_mode_periodic;\n\tif (dev) {\n\t\t\n\t\tdev->state = clock_evt_state_detached;\n\t\tdev->mode = clock_evt_mode_unused;\n\t\tclockevents_exchange_device(dev, null);\n\t\tdev->event_handler = clockevents_handle_noop;\n\t\ttd->evtdev = null;\n\t}\n}\n#endif\n\n\nvoid tick_suspend_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\n\tclockevents_shutdown(td->evtdev);\n}\n\n\nvoid tick_resume_local(void)\n{\n\tstruct tick_device *td = this_cpu_ptr(&tick_cpu_device);\n\tbool broadcast = tick_resume_check_broadcast();\n\n\tclockevents_tick_resume(td->evtdev);\n\tif (!broadcast) {\n\t\tif (td->mode == tickdev_mode_periodic)\n\t\t\ttick_setup_periodic(td->evtdev, 0);\n\t\telse\n\t\t\ttick_resume_oneshot();\n\t}\n}\n\n\nvoid tick_suspend(void)\n{\n\ttick_suspend_local();\n\ttick_suspend_broadcast();\n}\n\n\nvoid tick_resume(void)\n{\n\ttick_resume_broadcast();\n\ttick_resume_local();\n}\n\nstatic define_raw_spinlock(tick_freeze_lock);\nstatic unsigned int tick_freeze_depth;\n\n\nvoid tick_freeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\ttick_freeze_depth++;\n\tif (tick_freeze_depth == num_online_cpus())\n\t\ttimekeeping_suspend();\n\telse\n\t\ttick_suspend_local();\n\n\traw_spin_unlock(&tick_freeze_lock);\n}\n\n\nvoid tick_unfreeze(void)\n{\n\traw_spin_lock(&tick_freeze_lock);\n\n\tif (tick_freeze_depth == num_online_cpus())\n\t\ttimekeeping_resume();\n\telse\n\t\ttick_resume_local();\n\n\ttick_freeze_depth--;\n\n\traw_spin_unlock(&tick_freeze_lock);\n}\n\n\nvoid __init tick_init(void)\n{\n\ttick_broadcast_init();\n\ttick_nohz_init();\n}\n\n\n#include <linux/proc_fs.h>\n#include <linux/sched.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/utsname.h>\n#include <linux/mempolicy.h>\n\n#include \"", "28": "\"\n\n\nenum {\n\ttrace_nop_opt_accept = 0x1,\n\ttrace_nop_opt_refuse = 0x2\n};\n\n\nstatic struct tracer_opt nop_opts[] = {\n\t\n\t{ tracer_opt(test_nop_accept, trace_nop_opt_accept) },\n\t\n\t{ tracer_opt(test_nop_refuse, trace_nop_opt_refuse) },\n\t{ } \n};\n\nstatic struct tracer_flags nop_flags = {\n\t\n\t.val = 0, \n\t.opts = nop_opts\n};\n\nstatic struct trace_array\t*ctx_trace;\n\nstatic void start_nop_trace(struct trace_array *tr)\n{\n\t\n}\n\nstatic void stop_nop_trace(struct trace_array *tr)\n{\n\t\n}\n\nstatic int nop_trace_init(struct trace_array *tr)\n{\n\tctx_trace = tr;\n\tstart_nop_trace(tr);\n\treturn 0;\n}\n\nstatic void nop_trace_reset(struct trace_array *tr)\n{\n\tstop_nop_trace(tr);\n}\n\n\nstatic int nop_set_flag(struct trace_array *tr, u32 old_flags, u32 bit, int set)\n{\n\t\n\tif (bit == trace_nop_opt_accept) {\n\t\tprintk(kern_debug \"", "29": "\"\n\n\nstatic int convert_prio(int prio)\n{\n\tint cpupri;\n\n\tif (prio == cpupri_invalid)\n\t\tcpupri = cpupri_invalid;\n\telse if (prio == max_prio)\n\t\tcpupri = cpupri_idle;\n\telse if (prio >= max_rt_prio)\n\t\tcpupri = cpupri_normal;\n\telse\n\t\tcpupri = max_rt_prio - prio + 1;\n\n\treturn cpupri;\n}\n\n\nint cpupri_find(struct cpupri *cp, struct task_struct *p,\n\t\tstruct cpumask *lowest_mask)\n{\n\tint idx = 0;\n\tint task_pri = convert_prio(p->prio);\n\n\tbug_on(task_pri >= cpupri_nr_priorities);\n\n\tfor (idx = 0; idx < task_pri; idx++) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[idx];\n\t\tint skip = 0;\n\n\t\tif (!atomic_read(&(vec)->count))\n\t\t\tskip = 1;\n\t\t\n\t\tsmp_rmb();\n\n\t\t\n\t\tif (skip)\n\t\t\tcontinue;\n\n\t\tif (cpumask_any_and(&p->cpus_allowed, vec->mask) >= nr_cpu_ids)\n\t\t\tcontinue;\n\n\t\tif (lowest_mask) {\n\t\t\tcpumask_and(lowest_mask, &p->cpus_allowed, vec->mask);\n\n\t\t\t\n\t\t\tif (cpumask_any(lowest_mask) >= nr_cpu_ids)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nvoid cpupri_set(struct cpupri *cp, int cpu, int newpri)\n{\n\tint *currpri = &cp->cpu_to_pri[cpu];\n\tint oldpri = *currpri;\n\tint do_mb = 0;\n\n\tnewpri = convert_prio(newpri);\n\n\tbug_on(newpri >= cpupri_nr_priorities);\n\n\tif (newpri == oldpri)\n\t\treturn;\n\n\t\n\tif (likely(newpri != cpupri_invalid)) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[newpri];\n\n\t\tcpumask_set_cpu(cpu, vec->mask);\n\t\t\n\t\tsmp_mb__before_atomic();\n\t\tatomic_inc(&(vec)->count);\n\t\tdo_mb = 1;\n\t}\n\tif (likely(oldpri != cpupri_invalid)) {\n\t\tstruct cpupri_vec *vec  = &cp->pri_to_cpu[oldpri];\n\n\t\t\n\t\tif (do_mb)\n\t\t\tsmp_mb__after_atomic();\n\n\t\t\n\t\tatomic_dec(&(vec)->count);\n\t\tsmp_mb__after_atomic();\n\t\tcpumask_clear_cpu(cpu, vec->mask);\n\t}\n\n\t*currpri = newpri;\n}\n\n\nint cpupri_init(struct cpupri *cp)\n{\n\tint i;\n\n\tmemset(cp, 0, sizeof(*cp));\n\n\tfor (i = 0; i < cpupri_nr_priorities; i++) {\n\t\tstruct cpupri_vec *vec = &cp->pri_to_cpu[i];\n\n\t\tatomic_set(&vec->count, 0);\n\t\tif (!zalloc_cpumask_var(&vec->mask, gfp_kernel))\n\t\t\tgoto cleanup;\n\t}\n\n\tcp->cpu_to_pri = kcalloc(nr_cpu_ids, sizeof(int), gfp_kernel);\n\tif (!cp->cpu_to_pri)\n\t\tgoto cleanup;\n\n\tfor_each_possible_cpu(i)\n\t\tcp->cpu_to_pri[i] = cpupri_invalid;\n\n\treturn 0;\n\ncleanup:\n\tfor (i--; i >= 0; i--)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n\treturn -enomem;\n}\n\n\nvoid cpupri_cleanup(struct cpupri *cp)\n{\n\tint i;\n\n\tkfree(cp->cpu_to_pri);\n\tfor (i = 0; i < cpupri_nr_priorities; i++)\n\t\tfree_cpumask_var(cp->pri_to_cpu[i].mask);\n}\n\n\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/capability.h>\n#include <linux/completion.h>\n#include <linux/personality.h>\n#include <linux/tty.h>\n#include <linux/iocontext.h>\n#include <linux/key.h>\n#include <linux/security.h>\n#include <linux/cpu.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/freezer.h>\n#include <linux/binfmts.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/ptrace.h>\n#include <linux/profile.h>\n#include <linux/mount.h>\n#include <linux/proc_fs.h>\n#include <linux/kthread.h>\n#include <linux/mempolicy.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/cgroup.h>\n#include <linux/syscalls.h>\n#include <linux/signal.h>\n#include <linux/posix-timers.h>\n#include <linux/cn_proc.h>\n#include <linux/mutex.h>\n#include <linux/futex.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/audit.h> \n#include <linux/resource.h>\n#include <linux/blkdev.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/tracehook.h>\n#include <linux/fs_struct.h>\n#include <linux/init_task.h>\n#include <linux/perf_event.h>\n#include <trace/events/sched.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/oom.h>\n#include <linux/writeback.h>\n#include <linux/shm.h>\n\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n\nstatic void exit_mm(struct task_struct *tsk);\n\nstatic void __unhash_process(struct task_struct *p, bool group_dead)\n{\n\tnr_threads--;\n\tdetach_pid(p, pidtype_pid);\n\tif (group_dead) {\n\t\tdetach_pid(p, pidtype_pgid);\n\t\tdetach_pid(p, pidtype_sid);\n\n\t\tlist_del_rcu(&p->tasks);\n\t\tlist_del_init(&p->sibling);\n\t\t__this_cpu_dec(process_counts);\n\t}\n\tlist_del_rcu(&p->thread_group);\n\tlist_del_rcu(&p->thread_node);\n}\n\n\nstatic void __exit_signal(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tbool group_dead = thread_group_leader(tsk);\n\tstruct sighand_struct *sighand;\n\tstruct tty_struct *uninitialized_var(tty);\n\tcputime_t utime, stime;\n\n\tsighand = rcu_dereference_check(tsk->sighand,\n\t\t\t\t\tlockdep_tasklist_lock_is_held());\n\tspin_lock(&sighand->siglock);\n\n\tposix_cpu_timers_exit(tsk);\n\tif (group_dead) {\n\t\tposix_cpu_timers_exit_group(tsk);\n\t\ttty = sig->tty;\n\t\tsig->tty = null;\n\t} else {\n\t\t\n\t\tif (unlikely(has_group_leader_pid(tsk)))\n\t\t\tposix_cpu_timers_exit_group(tsk);\n\n\t\t\n\t\tif (sig->notify_count > 0 && !--sig->notify_count)\n\t\t\twake_up_process(sig->group_exit_task);\n\n\t\tif (tsk == sig->curr_target)\n\t\t\tsig->curr_target = next_thread(tsk);\n\t}\n\n\t\n\ttask_cputime(tsk, &utime, &stime);\n\twrite_seqlock(&sig->stats_lock);\n\tsig->utime += utime;\n\tsig->stime += stime;\n\tsig->gtime += task_gtime(tsk);\n\tsig->min_flt += tsk->min_flt;\n\tsig->maj_flt += tsk->maj_flt;\n\tsig->nvcsw += tsk->nvcsw;\n\tsig->nivcsw += tsk->nivcsw;\n\tsig->inblock += task_io_get_inblock(tsk);\n\tsig->oublock += task_io_get_oublock(tsk);\n\ttask_io_accounting_add(&sig->ioac, &tsk->ioac);\n\tsig->sum_sched_runtime += tsk->se.sum_exec_runtime;\n\tsig->nr_threads--;\n\t__unhash_process(tsk, group_dead);\n\twrite_sequnlock(&sig->stats_lock);\n\n\t\n\tflush_sigqueue(&tsk->pending);\n\ttsk->sighand = null;\n\tspin_unlock(&sighand->siglock);\n\n\t__cleanup_sighand(sighand);\n\tclear_tsk_thread_flag(tsk, tif_sigpending);\n\tif (group_dead) {\n\t\tflush_sigqueue(&sig->shared_pending);\n\t\ttty_kref_put(tty);\n\t}\n}\n\nstatic void delayed_put_task_struct(struct rcu_head *rhp)\n{\n\tstruct task_struct *tsk = container_of(rhp, struct task_struct, rcu);\n\n\tperf_event_delayed_put(tsk);\n\ttrace_sched_process_free(tsk);\n\tput_task_struct(tsk);\n}\n\n\nvoid release_task(struct task_struct *p)\n{\n\tstruct task_struct *leader;\n\tint zap_leader;\nrepeat:\n\t\n\trcu_read_lock();\n\tatomic_dec(&__task_cred(p)->user->processes);\n\trcu_read_unlock();\n\n\tproc_flush_task(p);\n\n\twrite_lock_irq(&tasklist_lock);\n\tptrace_release_task(p);\n\t__exit_signal(p);\n\n\t\n\tzap_leader = 0;\n\tleader = p->group_leader;\n\tif (leader != p && thread_group_empty(leader)\n\t\t\t&& leader->exit_state == exit_zombie) {\n\t\t\n\t\tzap_leader = do_notify_parent(leader, leader->exit_signal);\n\t\tif (zap_leader)\n\t\t\tleader->exit_state = exit_dead;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\trelease_thread(p);\n\tcall_rcu(&p->rcu, delayed_put_task_struct);\n\n\tp = leader;\n\tif (unlikely(zap_leader))\n\t\tgoto repeat;\n}\n\n\nstatic int will_become_orphaned_pgrp(struct pid *pgrp,\n\t\t\t\t\tstruct task_struct *ignored_task)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, pidtype_pgid, p) {\n\t\tif ((p == ignored_task) ||\n\t\t    (p->exit_state && thread_group_empty(p)) ||\n\t\t    is_global_init(p->real_parent))\n\t\t\tcontinue;\n\n\t\tif (task_pgrp(p->real_parent) != pgrp &&\n\t\t    task_session(p->real_parent) == task_session(p))\n\t\t\treturn 0;\n\t} while_each_pid_task(pgrp, pidtype_pgid, p);\n\n\treturn 1;\n}\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), null);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}\n\nstatic bool has_stopped_jobs(struct pid *pgrp)\n{\n\tstruct task_struct *p;\n\n\tdo_each_pid_task(pgrp, pidtype_pgid, p) {\n\t\tif (p->signal->flags & signal_stop_stopped)\n\t\t\treturn true;\n\t} while_each_pid_task(pgrp, pidtype_pgid, p);\n\n\treturn false;\n}\n\n\nstatic void\nkill_orphaned_pgrp(struct task_struct *tsk, struct task_struct *parent)\n{\n\tstruct pid *pgrp = task_pgrp(tsk);\n\tstruct task_struct *ignored_task = tsk;\n\n\tif (!parent)\n\t\t\n\t\tparent = tsk->real_parent;\n\telse\n\t\t\n\t\tignored_task = null;\n\n\tif (task_pgrp(parent) != pgrp &&\n\t    task_session(parent) == task_session(tsk) &&\n\t    will_become_orphaned_pgrp(pgrp, ignored_task) &&\n\t    has_stopped_jobs(pgrp)) {\n\t\t__kill_pgrp_info(sighup, send_sig_priv, pgrp);\n\t\t__kill_pgrp_info(sigcont, send_sig_priv, pgrp);\n\t}\n}\n\n#ifdef config_memcg\n\nvoid mm_update_next_owner(struct mm_struct *mm)\n{\n\tstruct task_struct *c, *g, *p = current;\n\nretry:\n\t\n\tif (mm->owner != p)\n\t\treturn;\n\t\n\tif (atomic_read(&mm->mm_users) <= 1) {\n\t\tmm->owner = null;\n\t\treturn;\n\t}\n\n\tread_lock(&tasklist_lock);\n\t\n\tlist_for_each_entry(c, &p->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t\n\tlist_for_each_entry(c, &p->real_parent->children, sibling) {\n\t\tif (c->mm == mm)\n\t\t\tgoto assign_new_owner;\n\t}\n\n\t\n\tfor_each_process(g) {\n\t\tif (g->flags & pf_kthread)\n\t\t\tcontinue;\n\t\tfor_each_thread(g, c) {\n\t\t\tif (c->mm == mm)\n\t\t\t\tgoto assign_new_owner;\n\t\t\tif (c->mm)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\tread_unlock(&tasklist_lock);\n\t\n\tmm->owner = null;\n\treturn;\n\nassign_new_owner:\n\tbug_on(c == p);\n\tget_task_struct(c);\n\t\n\ttask_lock(c);\n\t\n\tread_unlock(&tasklist_lock);\n\tif (c->mm != mm) {\n\t\ttask_unlock(c);\n\t\tput_task_struct(c);\n\t\tgoto retry;\n\t}\n\tmm->owner = c;\n\ttask_unlock(c);\n\tput_task_struct(c);\n}\n#endif \n\n\nstatic void exit_mm(struct task_struct *tsk)\n{\n\tstruct mm_struct *mm = tsk->mm;\n\tstruct core_state *core_state;\n\n\tmm_release(tsk, mm);\n\tif (!mm)\n\t\treturn;\n\tsync_mm_rss(mm);\n\t\n\tdown_read(&mm->mmap_sem);\n\tcore_state = mm->core_state;\n\tif (core_state) {\n\t\tstruct core_thread self;\n\n\t\tup_read(&mm->mmap_sem);\n\n\t\tself.task = tsk;\n\t\tself.next = xchg(&core_state->dumper.next, &self);\n\t\t\n\t\tif (atomic_dec_and_test(&core_state->nr_threads))\n\t\t\tcomplete(&core_state->startup);\n\n\t\tfor (;;) {\n\t\t\tset_task_state(tsk, task_uninterruptible);\n\t\t\tif (!self.task) \n\t\t\t\tbreak;\n\t\t\tfreezable_schedule();\n\t\t}\n\t\t__set_task_state(tsk, task_running);\n\t\tdown_read(&mm->mmap_sem);\n\t}\n\tatomic_inc(&mm->mm_count);\n\tbug_on(mm != tsk->active_mm);\n\t\n\ttask_lock(tsk);\n\ttsk->mm = null;\n\tup_read(&mm->mmap_sem);\n\tenter_lazy_tlb(mm, current);\n\ttask_unlock(tsk);\n\tmm_update_next_owner(mm);\n\tmmput(mm);\n\tif (test_thread_flag(tif_memdie))\n\t\tunmark_oom_victim();\n}\n\nstatic struct task_struct *find_alive_thread(struct task_struct *p)\n{\n\tstruct task_struct *t;\n\n\tfor_each_thread(p, t) {\n\t\tif (!(t->flags & pf_exiting))\n\t\t\treturn t;\n\t}\n\treturn null;\n}\n\nstatic struct task_struct *find_child_reaper(struct task_struct *father)\n\t__releases(&tasklist_lock)\n\t__acquires(&tasklist_lock)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(father);\n\tstruct task_struct *reaper = pid_ns->child_reaper;\n\n\tif (likely(reaper != father))\n\t\treturn reaper;\n\n\treaper = find_alive_thread(father);\n\tif (reaper) {\n\t\tpid_ns->child_reaper = reaper;\n\t\treturn reaper;\n\t}\n\n\twrite_unlock_irq(&tasklist_lock);\n\tif (unlikely(pid_ns == &init_pid_ns)) {\n\t\tpanic(\"", "30": "\"\n\n\nstruct module_signature {\n\tu8\talgo;\t\t\n\tu8\thash;\t\t\n\tu8\tid_type;\t\n\tu8\tsigner_len;\t\n\tu8\tkey_id_len;\t\n\tu8\t__pad[3];\n\t__be32\tsig_len;\t\n};\n\n\nstatic struct public_key_signature *mod_make_digest(enum hash_algo hash,\n\t\t\t\t\t\t    const void *mod,\n\t\t\t\t\t\t    unsigned long modlen)\n{\n\tstruct public_key_signature *pks;\n\tstruct crypto_shash *tfm;\n\tstruct shash_desc *desc;\n\tsize_t digest_size, desc_size;\n\tint ret;\n\n\tpr_devel(\"", "31": "\"\n\n\nvoid\nclocks_calc_mult_shift(u32 *mult, u32 *shift, u32 from, u32 to, u32 maxsec)\n{\n\tu64 tmp;\n\tu32 sft, sftacc= 32;\n\n\t\n\ttmp = ((u64)maxsec * from) >> 32;\n\twhile (tmp) {\n\t\ttmp >>=1;\n\t\tsftacc--;\n\t}\n\n\t\n\tfor (sft = 32; sft > 0; sft--) {\n\t\ttmp = (u64) to << sft;\n\t\ttmp += from / 2;\n\t\tdo_div(tmp, from);\n\t\tif ((tmp >> sftacc) == 0)\n\t\t\tbreak;\n\t}\n\t*mult = tmp;\n\t*shift = sft;\n}\n\n\nstatic struct clocksource *curr_clocksource;\nstatic list_head(clocksource_list);\nstatic define_mutex(clocksource_mutex);\nstatic char override_name[cs_name_len];\nstatic int finished_booting;\n\n#ifdef config_clocksource_watchdog\nstatic void clocksource_watchdog_work(struct work_struct *work);\nstatic void clocksource_select(void);\n\nstatic list_head(watchdog_list);\nstatic struct clocksource *watchdog;\nstatic struct timer_list watchdog_timer;\nstatic declare_work(watchdog_work, clocksource_watchdog_work);\nstatic define_spinlock(watchdog_lock);\nstatic int watchdog_running;\nstatic atomic_t watchdog_reset_pending;\n\nstatic int clocksource_watchdog_kthread(void *data);\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating);\n\n\n#define watchdog_interval (hz >> 1)\n#define watchdog_threshold (nsec_per_sec >> 4)\n\nstatic void clocksource_watchdog_work(struct work_struct *work)\n{\n\t\n\tkthread_run(clocksource_watchdog_kthread, null, \"", "32": "\"\n\n#define cmd_buflen 256\nchar kdb_prompt_str[cmd_buflen];\n\nint kdb_trap_printk;\n\nstatic int kgdb_transition_check(char *buffer)\n{\n\tif (buffer[0] != '+' && buffer[0] != '$') {\n\t\tkdb_state_set(kgdb_trans);\n\t\tkdb_printf(\"", "33": "\"\n\n#define kprobe_event_system \"", "34": "\"\n\n#define suspend_console\t(max_nr_consoles-1)\n\nstatic int orig_fgconsole, orig_kmsg;\n\nstatic define_mutex(vt_switch_mutex);\n\nstruct pm_vt_switch {\n\tstruct list_head head;\n\tstruct device *dev;\n\tbool required;\n};\n\nstatic list_head(pm_vt_switch_list);\n\n\n\nvoid pm_vt_switch_required(struct device *dev, bool required)\n{\n\tstruct pm_vt_switch *entry, *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\t\n\t\t\ttmp->required = required;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tentry = kmalloc(sizeof(*entry), gfp_kernel);\n\tif (!entry)\n\t\tgoto out;\n\n\tentry->required = required;\n\tentry->dev = dev;\n\n\tlist_add(&entry->head, &pm_vt_switch_list);\nout:\n\tmutex_unlock(&vt_switch_mutex);\n}\nexport_symbol(pm_vt_switch_required);\n\n\nvoid pm_vt_switch_unregister(struct device *dev)\n{\n\tstruct pm_vt_switch *tmp;\n\n\tmutex_lock(&vt_switch_mutex);\n\tlist_for_each_entry(tmp, &pm_vt_switch_list, head) {\n\t\tif (tmp->dev == dev) {\n\t\t\tlist_del(&tmp->head);\n\t\t\tkfree(tmp);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&vt_switch_mutex);\n}\nexport_symbol(pm_vt_switch_unregister);\n\n\nstatic bool pm_vt_switch(void)\n{\n\tstruct pm_vt_switch *entry;\n\tbool ret = true;\n\n\tmutex_lock(&vt_switch_mutex);\n\tif (list_empty(&pm_vt_switch_list))\n\t\tgoto out;\n\n\tif (!console_suspend_enabled)\n\t\tgoto out;\n\n\tlist_for_each_entry(entry, &pm_vt_switch_list, head) {\n\t\tif (entry->required)\n\t\t\tgoto out;\n\t}\n\n\tret = false;\nout:\n\tmutex_unlock(&vt_switch_mutex);\n\treturn ret;\n}\n\nint pm_prepare_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn 0;\n\n\torig_fgconsole = vt_move_to_console(suspend_console, 1);\n\tif (orig_fgconsole < 0)\n\t\treturn 1;\n\n\torig_kmsg = vt_kmsg_redirect(suspend_console);\n\treturn 0;\n}\n\nvoid pm_restore_console(void)\n{\n\tif (!pm_vt_switch())\n\t\treturn;\n\n\tif (orig_fgconsole >= 0) {\n\t\tvt_move_to_console(orig_fgconsole, 0);\n\t\tvt_kmsg_redirect(orig_kmsg);\n\t}\n}\n\n\n#include <linux/kernel.h>\n#include <linux/err.h>\n#include <crypto/public_key.h>\n#include <crypto/hash.h>\n#include <keys/asymmetric-type.h>\n#include <keys/system_keyring.h>\n#include \"", "35": "\"\n\n#include <linux/slab.h>\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !rb_empty_node(&dl_se->rb_node);\n}\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->rb_leftmost == &dl_se->rb_node;\n}\n\nvoid init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == runtime_inf)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}\n\nvoid init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->rb_root = rb_root;\n\n#ifdef config_smp\n\t\n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = rb_root;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n}\n\n#ifdef config_smp\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}\n\nstatic void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}\n\nstatic void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}\n\n\nstatic void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_node **link = &dl_rq->pushable_dl_tasks_root.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct task_struct *entry;\n\tint leftmost = 1;\n\n\tbug_on(!rb_empty_node(&p->pushable_dl_tasks));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct task_struct,\n\t\t\t\t pushable_dl_tasks);\n\t\tif (dl_entity_preempt(&p->dl, &entry->dl))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tdl_rq->pushable_dl_tasks_leftmost = &p->pushable_dl_tasks;\n\n\trb_link_node(&p->pushable_dl_tasks, parent, link);\n\trb_insert_color(&p->pushable_dl_tasks, &dl_rq->pushable_dl_tasks_root);\n}\n\nstatic void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (rb_empty_node(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tif (dl_rq->pushable_dl_tasks_leftmost == &p->pushable_dl_tasks) {\n\t\tstruct rb_node *next_node;\n\n\t\tnext_node = rb_next(&p->pushable_dl_tasks);\n\t\tdl_rq->pushable_dl_tasks_leftmost = next_node;\n\t}\n\n\trb_erase(&p->pushable_dl_tasks, &dl_rq->pushable_dl_tasks_root);\n\trb_clear_node(&p->pushable_dl_tasks);\n}\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !rb_empty_root(&rq->dl.pushable_dl_tasks_root);\n}\n\nstatic int push_dl_task(struct rq *rq);\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn dl_task(prev);\n}\n\nstatic inline void set_post_schedule(struct rq *rq)\n{\n\trq->post_schedule = has_pushable_dl_tasks(rq);\n}\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq);\n\nstatic void dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = null;\n\tbool fallback = false;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t\n\t\tfallback = true;\n\t\tcpu = cpumask_any_and(cpu_active_mask, tsk_cpus_allowed(p));\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t\n\t\t\tbug_on(dl_bandwidth_enabled());\n\n\t\t\t\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tdeactivate_task(rq, p, 0);\n\tset_task_cpu(p, later_rq->cpu);\n\tactivate_task(later_rq, p, enqueue_replenish);\n\n\tif (!fallback)\n\t\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n}\n\n#else\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}\n\nstatic inline int pull_dl_task(struct rq *rq)\n{\n\treturn 0;\n}\n\nstatic inline void set_post_schedule(struct rq *rq)\n{\n}\n#endif \n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags);\n\n\nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\t       struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\twarn_on(!dl_se->dl_new || dl_se->dl_throttled);\n\n\t\n\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\tdl_se->runtime = pi_se->dl_runtime;\n\tdl_se->dl_new = 0;\n}\n\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tbug_on(pi_se->dl_runtime <= 0);\n\n\t\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\t\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"", "36": "\"\n\nchar *_braille_console_setup(char **str, char **brl_options)\n{\n\tif (!memcmp(*str, \"", "37": "\"\n\nconst char *pm_labels[] = { \"", "38": "\"\n#endif\n\t\"", "39": "\"\n#endif\n\nstruct trace_option_dentry {\n\tstruct tracer_opt\t\t*opt;\n\tstruct tracer_flags\t\t*flags;\n\tstruct trace_array\t\t*tr;\n\tstruct dentry\t\t\t*entry;\n};\n\nstatic ssize_t\ntrace_options_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t\tloff_t *ppos)\n{\n\tstruct trace_option_dentry *topt = filp->private_data;\n\tchar *buf;\n\n\tif (topt->flags->val & topt->opt->bit)\n\t\tbuf = \"", "40": "\"\n#endif\n#endif \n\t\"", "41": "\"\n#endif\n#ifdef config_function_graph_tracer\n\t\"", "42": "\"\n#endif\n#ifdef config_stack_tracer\n\t\"", "43": "\"\n#endif\n#ifdef config_tracer_snapshot\n\t\"", "44": "\"\n#endif \n#ifdef config_function_tracer\n\t\"", "45": "\"\n#ifdef config_dynamic_ftrace\n\t\"", "46": "\"\n#ifdef config_stacktrace\n\t\"", "47": "\"\n#ifdef config_x86_64\n\t\"", "48": "\"\n#include \"", "49": "\"\n;\n\nstatic ssize_t\ntracing_readme_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\treturn simple_read_from_buffer(ubuf, cnt, ppos,\n\t\t\t\t\treadme_msg, strlen(readme_msg));\n}\n\nstatic const struct file_operations tracing_readme_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_readme_read,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic void *saved_cmdlines_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tunsigned int *ptr = v;\n\n\tif (*pos || m->count)\n\t\tptr++;\n\n\t(*pos)++;\n\n\tfor (; ptr < &savedcmd->map_cmdline_to_pid[savedcmd->cmdline_num];\n\t     ptr++) {\n\t\tif (*ptr == -1 || *ptr == no_cmdline_map)\n\t\t\tcontinue;\n\n\t\treturn ptr;\n\t}\n\n\treturn null;\n}\n\nstatic void *saved_cmdlines_start(struct seq_file *m, loff_t *pos)\n{\n\tvoid *v;\n\tloff_t l = 0;\n\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\tv = &savedcmd->map_cmdline_to_pid[0];\n\twhile (l <= *pos) {\n\t\tv = saved_cmdlines_next(m, v, &l);\n\t\tif (!v)\n\t\t\treturn null;\n\t}\n\n\treturn v;\n}\n\nstatic void saved_cmdlines_stop(struct seq_file *m, void *v)\n{\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n\nstatic int saved_cmdlines_show(struct seq_file *m, void *v)\n{\n\tchar buf[task_comm_len];\n\tunsigned int *pid = v;\n\n\t__trace_find_cmdline(*pid, buf);\n\tseq_printf(m, \"", "50": "\"                 \"", "51": "\"                \"", "52": "\"               function calls\\n\"", "53": "\"               |   |   |   |\\n\"", "54": "\"              events:    %ld\\n\"", "55": "\"            task   pid         tree-key  switches  prio\"", "56": "\"         check your cmos/bios settings.\\n\"", "57": "\"         lost events:   %ld\\n\"", "58": "\"         please report this, consider using a different clocksource, if possible.\\n\"", "59": "\"         read events:   %ld\\n\"", "60": "\"         timekeeping: your kernel is sick, but tries to cope by capping time updates\\n\"", "61": "\"         your kernel is probably still fine.\\n\"", "62": "\"        -----    ----   --------\\n\"", "63": "\"        depth    size   location    (%d entries)\\n\"", "64": "\"        depth    size   location\"", "65": "\"        total events:   %ld\\n\"", "66": "\"       --------                \"", "67": "\"       ----\\n\"", "68": "\"       alloced bytes:    %ld\\n\"", "69": "\"       biggest event:    %d\\n\"", "70": "\"       cpu0\\n\"", "71": "\"       dropped bytes:    %ld\\n\"", "72": "\"       function                \"", "73": "\"       written bytes:    %ld\\n\"", "74": "\"      %s %s %.*s\\n\"", "75": "\"      smallest event:    %d\\n\"", "76": "\"      time (secs)        count\\n\"", "77": "\"      timekeeping: your kernel is still fine, but is feeling a bit nervous\\n\"", "78": "\"      |         \"", "79": "\"     exec-runtime         sum-exec        sum-sleep\\n\"", "80": "\"     last function: %pf\\n\"", "81": "\"     the %s domain not a subset of the %s domain\\n\"", "82": "\"     time       \"", "83": "\"    \"", "84": "\"    (%d entries)\\n\"", "85": "\"    balk: nt=%lu egt=%lu bt=%lu nb=%lu ny=%lu nos=%lu\\n\"", "86": "\"    delayed:\"", "87": "\"    in-flight:\"", "88": "\"    lock(\"", "89": "\"    pending:\"", "90": "\"    |\\n\"", "91": "\"   (ftrace buffer empty)\\n\"", "92": "\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"", "93": "\"   miss      hit    % \"", "94": "\"   pattern or ^pattern or pattern$ or ^pattern$\\n\"", "95": "\"   |    |        \"", "96": "\"   |   |      \"", "97": "\"  \"", "98": "\"  %-11.11s \"", "99": "\"  %-30.30s  %10lu\"", "100": "\"  %ps flags:%lx\\n\"", "101": "\"  %s %-44s %15lu\\n\"", "102": "\"  %s\"", "103": "\"  'grep' is just a key word.\\n\"", "104": "\"  +\"", "105": "\"  ----              ----\\n\"", "106": "\"  --------                               \"", "107": "\"  --------                               ---\\n\"", "108": "\"  .%-15s: %lu nsecs\\n\"", "109": "\"  .%-15s: %lu\\n\"", "110": "\"  .%-30s: %d\\n\"", "111": "\"  .%-30s: %ld.%06ld\\n\"", "112": "\"  .%-30s: %ld\\n\"", "113": "\"  .%-30s: %lld.%06ld\\n\"", "114": "\"  .%-30s: %lld\\n\"", "115": "\"  .%-30s: %lu\\n\"", "116": "\"  .%-40s: %d (%s)\\n\"", "117": "\"  .%-40s: %ld.%06ld\\n\"", "118": "\"  .%-40s: %ld\\n\"", "119": "\"  ...\\n\"", "120": "\"  <interrupt>\\n\"", "121": "\"  and if there are spaces in the pattern, you may \"", "122": "\"  any command's output may be filtered through an \"", "123": "\"  change the kernel config_debug_rodata=n\\n\"", "124": "\"  duration   \"", "125": "\"  echo global > /sys/kernel/debug/tracing/trace_clock\\n\"", "126": "\"  error: does not match running \"", "127": "\"  error: no saved data for this cpu\\n\"", "128": "\"  file              line\\n\"", "129": "\"  from func %ps return to %lx\\n\"", "130": "\"  func:file:line\\n\"", "131": "\"  function                               \"", "132": "\"  function                               hit\\n\"", "133": "\"  lock(\"", "134": "\"  ok  \"", "135": "\"  or use hw breaks: help bph\\n\"", "136": "\"  pwq %d:\"", "137": "\"  recorded len bytes:   %ld\\n\"", "138": "\"  task                        pc stack   pid father\\n\"", "139": "\"  task                pc stack   pid father\\n\"", "140": "\"  task %d\\n\"", "141": "\"  task/pid       \"", "142": "\"  the pattern may include a very limited set of \"", "143": "\" \"", "144": "\" #%d\"", "145": "\" %*d\"", "146": "\" %*pbl\"", "147": "\" %-8s\"", "148": "\" %12llu: \"", "149": "\" %14lu \"", "150": "\" %4lld: \"", "151": "\" %4lldus%c: \"", "152": "\" %5d:%3d:%c %s [%03d] %5d:%3d:%c %s\\n\"", "153": "\" %5lu.%06lu: \"", "154": "\" %8s\"", "155": "\" %d\"", "156": "\" %d(%ld,%ld)\"", "157": "\" %i \"", "158": "\" %llx\"", "159": "\" %lx <-- %lx\"", "160": "\" %ps\"", "161": "\" %s does not support one-shot mode.\\n\"", "162": "\" %s is not functional.\\n\"", "163": "\" %s\"", "164": "\" %s%d\"", "165": "\" %s%s\"", "166": "\" %s+%u\"", "167": "\" %s:0x%p\"", "168": "\" %s=\"", "169": "\" %s=%s\"", "170": "\" %s=(fault)\"", "171": "\" %s=\\\"%s\\\"\"", "172": "\" %s\\n\"", "173": "\" %u %u %u %u %u %u %u %u %u %u %u %u\\n\"", "174": "\" '-'.\\n\"", "175": "\" (\"", "176": "\" (%ld)%s\"", "177": "\" (%s)\"", "178": "\" (cpu_capacity = %d)\"", "179": "\" (live)\"", "180": "\" (loading)\"", "181": "\" (overruns: %lu)\\n\"", "182": "\" (owned by %s)\\n\"", "183": "\" (t=%lu jiffies g=%ld c=%ld q=%lu)\\n\"", "184": "\" (unloading)\"", "185": "\" */\\n\"", "186": "\" ,\n\t\tconsole->name, console->index);\n\n\tres = _braille_unregister_console(console);\n\tif (res)\n\t\treturn res;\n\n\tres = 1;\n\tconsole_lock();\n\tif (console_drivers == console) {\n\t\tconsole_drivers=console->next;\n\t\tres = 0;\n\t} else if (console_drivers) {\n\t\tfor (a=console_drivers->next, b=console_drivers ;\n\t\t     a; b=a, a=b->next) {\n\t\t\tif (a == console) {\n\t\t\t\tb->next = a->next;\n\t\t\t\tres = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (console_drivers != null && console->flags & con_consdev)\n\t\tconsole_drivers->flags |= con_consdev;\n\n\tconsole->flags &= ~con_enabled;\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\treturn res;\n}\nexport_symbol(unregister_console);\n\nstatic int __init printk_late_init(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con) {\n\t\tif (!keep_bootcon && con->flags & con_boot) {\n\t\t\tunregister_console(con);\n\t\t}\n\t}\n\thotcpu_notifier(console_cpu_notify, 0);\n\treturn 0;\n}\nlate_initcall(printk_late_init);\n\n#if defined config_printk\n\n#define printk_pending_wakeup\t0x01\n#define printk_pending_output\t0x02\n\nstatic define_per_cpu(int, printk_pending);\n\nstatic void wake_up_klogd_work_func(struct irq_work *irq_work)\n{\n\tint pending = __this_cpu_xchg(printk_pending, 0);\n\n\tif (pending & printk_pending_output) {\n\t\t\n\t\tif (console_trylock())\n\t\t\tconsole_unlock();\n\t}\n\n\tif (pending & printk_pending_wakeup)\n\t\twake_up_interruptible(&log_wait);\n}\n\nstatic define_per_cpu(struct irq_work, wake_up_klogd_work) = {\n\t.func = wake_up_klogd_work_func,\n\t.flags = irq_work_lazy,\n};\n\nvoid wake_up_klogd(void)\n{\n\tpreempt_disable();\n\tif (waitqueue_active(&log_wait)) {\n\t\tthis_cpu_or(printk_pending, printk_pending_wakeup);\n\t\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\t}\n\tpreempt_enable();\n}\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tpreempt_disable();\n\tva_start(args, fmt);\n\tr = vprintk_emit(0, loglevel_sched, null, 0, fmt, args);\n\tva_end(args);\n\n\t__this_cpu_or(printk_pending, printk_pending_output);\n\tirq_work_queue(this_cpu_ptr(&wake_up_klogd_work));\n\tpreempt_enable();\n\n\treturn r;\n}\n\n\ndefine_ratelimit_state(printk_ratelimit_state, 5 * hz, 10);\n\nint __printk_ratelimit(const char *func)\n{\n\treturn ___ratelimit(&printk_ratelimit_state, func);\n}\nexport_symbol(__printk_ratelimit);\n\n\nbool printk_timed_ratelimit(unsigned long *caller_jiffies,\n\t\t\tunsigned int interval_msecs)\n{\n\tunsigned long elapsed = jiffies - *caller_jiffies;\n\n\tif (*caller_jiffies && elapsed <= msecs_to_jiffies(interval_msecs))\n\t\treturn false;\n\n\t*caller_jiffies = jiffies;\n\treturn true;\n}\nexport_symbol(printk_timed_ratelimit);\n\nstatic define_spinlock(dump_list_lock);\nstatic list_head(dump_list);\n\n\nint kmsg_dump_register(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -ebusy;\n\n\t\n\tif (!dumper->dump)\n\t\treturn -einval;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\t\n\tif (!dumper->registered) {\n\t\tdumper->registered = 1;\n\t\tlist_add_tail_rcu(&dumper->list, &dump_list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\n\treturn err;\n}\nexport_symbol_gpl(kmsg_dump_register);\n\n\nint kmsg_dump_unregister(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\tint err = -einval;\n\n\tspin_lock_irqsave(&dump_list_lock, flags);\n\tif (dumper->registered) {\n\t\tdumper->registered = 0;\n\t\tlist_del_rcu(&dumper->list);\n\t\terr = 0;\n\t}\n\tspin_unlock_irqrestore(&dump_list_lock, flags);\n\tsynchronize_rcu();\n\n\treturn err;\n}\nexport_symbol_gpl(kmsg_dump_unregister);\n\nstatic bool always_kmsg_dump;\nmodule_param_named(always_kmsg_dump, always_kmsg_dump, bool, s_irugo | s_iwusr);\n\n\nvoid kmsg_dump(enum kmsg_dump_reason reason)\n{\n\tstruct kmsg_dumper *dumper;\n\tunsigned long flags;\n\n\tif ((reason > kmsg_dump_oops) && !always_kmsg_dump)\n\t\treturn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(dumper, &dump_list, list) {\n\t\tif (dumper->max_reason && reason > dumper->max_reason)\n\t\t\tcontinue;\n\n\t\t\n\t\tdumper->active = true;\n\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tdumper->cur_seq = clear_seq;\n\t\tdumper->cur_idx = clear_idx;\n\t\tdumper->next_seq = log_next_seq;\n\t\tdumper->next_idx = log_next_idx;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\t\t\n\t\tdumper->dump(dumper, reason);\n\n\t\t\n\t\tdumper->active = false;\n\t}\n\trcu_read_unlock();\n}\n\n\nbool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, 0, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}\n\n\nbool kmsg_dump_get_line(struct kmsg_dumper *dumper, bool syslog,\n\t\t\tchar *line, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tbool ret;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tret = kmsg_dump_get_line_nolock(dumper, syslog, line, size, len);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\treturn ret;\n}\nexport_symbol_gpl(kmsg_dump_get_line);\n\n\nbool kmsg_dump_get_buffer(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t  char *buf, size_t size, size_t *len)\n{\n\tunsigned long flags;\n\tu64 seq;\n\tu32 idx;\n\tu64 next_seq;\n\tu32 next_idx;\n\tenum log_flags prev;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t\n\tif (dumper->cur_seq >= dumper->next_seq) {\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\tgoto out;\n\t}\n\n\t\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\tprev = 0;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, prev, true, null, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t\tprev = msg->flags;\n\t}\n\n\t\n\tseq = dumper->cur_seq;\n\tidx = dumper->cur_idx;\n\tprev = 0;\n\twhile (l > size && seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl -= msg_print_text(msg, prev, true, null, 0);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t\tprev = msg->flags;\n\t}\n\n\t\n\tnext_seq = seq;\n\tnext_idx = idx;\n\n\tl = 0;\n\twhile (seq < dumper->next_seq) {\n\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\tl += msg_print_text(msg, prev, syslog, buf + l, size - l);\n\t\tidx = log_next(idx);\n\t\tseq++;\n\t\tprev = msg->flags;\n\t}\n\n\tdumper->next_seq = next_seq;\n\tdumper->next_idx = next_idx;\n\tret = true;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}\nexport_symbol_gpl(kmsg_dump_get_buffer);\n\n\nvoid kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}\n\n\nvoid kmsg_dump_rewind(struct kmsg_dumper *dumper)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tkmsg_dump_rewind_nolock(dumper);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n}\nexport_symbol_gpl(kmsg_dump_rewind);\n\nstatic char dump_stack_arch_desc_str[128];\n\n\nvoid __init dump_stack_set_arch_desc(const char *fmt, ...)\n{\n\tva_list args;\n\n\tva_start(args, fmt);\n\tvsnprintf(dump_stack_arch_desc_str, sizeof(dump_stack_arch_desc_str),\n\t\t  fmt, args);\n\tva_end(args);\n}\n\n\nvoid dump_stack_print_info(const char *log_lvl)\n{\n\tprintk(\"", "187": "\" ,\n\t\tnewcon->name, newcon->index);\n\tif (bcon &&\n\t    ((newcon->flags & (con_consdev | con_boot)) == con_consdev) &&\n\t    !keep_bootcon) {\n\t\t\n\t\tfor_each_console(bcon)\n\t\t\tif (bcon->flags & con_boot)\n\t\t\t\tunregister_console(bcon);\n\t}\n}\nexport_symbol(register_console);\n\nint unregister_console(struct console *console)\n{\n        struct console *a, *b;\n\tint res;\n\n\tpr_info(\"", "188": "\" - unable to \"", "189": "\" ------- ---------  - \"", "190": "\" ------------------------------------------\\n\"", "191": "\" -> [%p] \"", "192": "\" ... kernel command line filter set: force pass ... \"", "193": "\" 0x%p\"", "194": "\" 0x%pk\"", "195": "\" : \"", "196": "\" <\"", "197": "\" <- \"", "198": "\" <-\"", "199": "\" = \"", "200": "\" => \"", "201": "\" [ \"", "202": "\" [%p] {%s:%d}\\n\"", "203": "\" [%p] {%s}\\n\"", "204": "\" [%s]\"", "205": "\" [debug]\"", "206": "\" [last unloaded: %s]\"", "207": "\" \\n\"", "208": "\" \\t\"", "209": "\" a%d\"", "210": "\" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\"", "211": "\" active=%d/%d%s\\n\"", "212": "\" actual: \"", "213": "\" all direct dependencies:       %11lu\\n\"", "214": "\" alloced and written from above\\n\"", "215": "\" and \"", "216": "\" and 15 (pass and disconnect)\\n\"", "217": "\" auid=%u ses=%u\"", "218": "\" b=%ld\"", "219": "\" bd:%5ld\"", "220": "\" call or barrier ops missing for %s,\\n\"", "221": "\" cap_fe=%d cap_fver=%x\"", "222": "\" chain lookup hits:             %11llu\\n\"", "223": "\" chain lookup misses:           %11llu\\n\"", "224": "\" ci=%lu nci=%lu co=%lu ca=%lu\\n\"", "225": "\" cleared\\n\"", "226": "\" combined max dependencies:     %11u\\n\"", "227": "\" comm=\"", "228": "\" correct incorrect  % \"", "229": "\" cpu\"", "230": "\" cpu%d\\n\"", "231": "\" cpus=%*pbl\"", "232": "\" cwd=\"", "233": "\" cyclic checks:                 %11llu\\n\"", "234": "\" debug_locks:                   %11u\\n\"", "235": "\" dependency chain hlocks:       %11d [max: %lu]\\n\"", "236": "\" dependency chains:             %11lu [max: %lu]\\n\"", "237": "\" dev=%02x:%02x mode=%#ho\"", "238": "\" dir=\"", "239": "\" direct dependencies:           %11lu [max: %lu]\\n\"", "240": "\" disabled\\n\"", "241": "\" disables this message.\\n\"", "242": "\" dt=%d/%llx/%d df=%lu\"", "243": "\" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\"", "244": "\" enabled\"", "245": "\" euid=%u suid=%u fsuid=%u\"", "246": "\" exe=\"", "247": "\" exe=(null)\"", "248": "\" expected tramp: %lx\\n\"", "249": "\" fd:%5ld\"", "250": "\" fe=%d\"", "251": "\" feature=%s old=%u new=%u old_lock=%u new_lock=%u res=%d\"", "252": "\" field_string_func \"", "253": "\" field_string_ip;\n\t} else {\n\t\tfmt = \"", "254": "\" field_string_retip;\n\t}\n\n\t\n#define len_or_zero (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, len_or_zero, \"", "255": "\" find-mask backwards checks:    %11llu\\n\"", "256": "\" find-mask forwards checks:     %11llu\\n\"", "257": "\" flags=0x%x nice=%d\"", "258": "\" fmt\n\n#include <linux/kernel.h>\n#include <linux/console.h>\n#include <linux/string.h>\n\n#include \"", "259": "\" fp%d=%s\"", "260": "\" grace periods expedited from boot/sysfs for %s,\\n\"", "261": "\" hardirq off events:            %11llu\\n\"", "262": "\" hardirq on events:             %11llu\\n\"", "263": "\" hardirq-read-safe locks:       %11lu\\n\"", "264": "\" hardirq-read-unsafe locks:     %11lu\\n\"", "265": "\" hardirq-safe locks:            %11lu\\n\"", "266": "\" hardirq-unsafe locks:          %11lu\\n\"", "267": "\" has parent\"", "268": "\" if %s\\n\"", "269": "\" ignoring it.\\n\"", "270": "\" in-hardirq chains:             %11u\\n\"", "271": "\" in-process chains:             %11u\\n\"", "272": "\" in-softirq chains:             %11u\\n\"", "273": "\" indirect dependencies:         %11lu\\n\"", "274": "\" inode=%lu\"", "275": "\" irq-read-safe locks:           %11lu\\n\"", "276": "\" irq-read-unsafe locks:         %11lu\\n\"", "277": "\" irq-safe locks:                %11lu\\n\"", "278": "\" irq-unsafe locks:              %11lu\\n\"", "279": "\" key=\"", "280": "\" kt=%d/%c ktl=%x\"", "281": "\" list=%d res=%d\"", "282": "\" list=%d res=1\"", "283": "\" lock-classes:                  %11lu [max: %lu]\\n\"", "284": "\" lock: %ps, .magic: %08x, .owner: %s/%d, \"", "285": "\" locked it.\\n\"", "286": "\" mag %x, put %p, usage %d, subscr %d\\n\"", "287": "\" manager: %d\"", "288": "\" max bfs queue depth:           %11u\\n\"", "289": "\" max locking depth:             %11u\\n\"", "290": "\" may be due to missing lock nesting notation\\n\\n\"", "291": "\" mayday\"", "292": "\" mems_allowed=%*pbl\\n\"", "293": "\" misfeature support will be removed\\n\"", "294": "\" miss \"", "295": "\" name=\"", "296": "\" name=(null)\"", "297": "\" nametype=\"", "298": "\" nestedness limit pid/tgid=%d/%d\\n\"", "299": "\" no tick device\\n\"", "300": "\" node=%d\"", "301": "\" obj=%s\"", "302": "\" obj=(none)\"", "303": "\" ocomm=\"", "304": "\" of=%lu\"", "305": "\" old-auid=%u auid=%u old-ses=%u ses=%u res=%d\"", "306": "\" old-log_passwd=%d new-log_passwd=%d res=%d\"", "307": "\" op=\"", "308": "\" op=tty_set old-enabled=%d new-enabled=%d\"", "309": "\" ops:%8ld\"", "310": "\" or \\\"^pat tern$\\\"\\n\"", "311": "\" osid=%u\"", "312": "\" ouid=%u ogid=%u rdev=%02x:%02x\"", "313": "\" p%d\"", "314": "\" path=\"", "315": "\" per=%lx\"", "316": "\" pid=%d comm=\"", "317": "\" possible unsafe locking scenario:\\n\\n\"", "318": "\" ppid=%d pid=%d auid=%u uid=%u gid=%u\"", "319": "\" probe to kernel_sched_migrate_task\\n\"", "320": "\" probe to kernel_sched_switch\\n\"", "321": "\" probe to kernel_sched_wakeup\\n\"", "322": "\" probe to kernel_sched_wakeup_new\\n\"", "323": "\" protection\"", "324": "\" ql=%ld/%ld qs=%c%c%c%c\"", "325": "\" r\"", "326": "\" r%d=%s\"", "327": "\" rcu barrier testing omitted from run.\\n\"", "328": "\" recorded size bytes:   %ld\\n\"", "329": "\" redundant hardirq offs:        %11llu\\n\"", "330": "\" redundant hardirq ons:         %11llu\\n\"", "331": "\" redundant softirq offs:        %11llu\\n\"", "332": "\" redundant softirq ons:         %11llu\\n\"", "333": "\" res=%d\"", "334": "\" res=0\"", "335": "\" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\"", "336": "\" sig=%ld\"", "337": "\" softirq off events:            %11llu\\n\"", "338": "\" softirq on events:             %11llu\\n\"", "339": "\" softirq-read-safe locks:       %11lu\\n\"", "340": "\" softirq-read-unsafe locks:     %11lu\\n\"", "341": "\" softirq-safe locks:            %11lu\\n\"", "342": "\" softirq-unsafe locks:          %11lu\\n\"", "343": "\" stack-trace entries:           %11lu [max: %lu]\\n\"", "344": "\" subj=%s\"", "345": "\" subsystem\\n\"", "346": "\" success=%s exit=%ld\"", "347": "\" suppressed,\\nuse 'ps a' to see all.\\n\"", "348": "\" testing of dynamic grace-period expediting diabled.\\n\"", "349": "\" threaded [<%p>] %pf\"", "350": "\" uncategorized locks:           %11lu\\n\"", "351": "\" unused locks:                  %11lu\\n\"", "352": "\" with dropped events, record len and size may not match\\n\"", "353": "\" workers=%d\"", "354": "\" zero suppressed\\n\"", "355": "\" {\"", "356": "\" |  \"", "357": "\" | \"", "358": "\"!!! \"", "359": "\"!!!\"", "360": "\"!\"", "361": "\"!=\"", "362": "\"!@#$%^&*()?+\\\\?+|:';\\\",.<>/?abcdefghijklmnopqrstuv\"", "363": "\"\"", "364": "\"#              | |       |          |         |   \"", "365": "\"#           task-pid    cpu#    timestamp  correct\"", "366": "\"#  stack tracer disabled\\n\"", "367": "\"#  |     |     |           |   |   |\\n\"", "368": "\"# available triggers:\\n\"", "369": "\"# bursts in flood, zero to disable\"", "370": "\"# callbacks per burst in flood\"", "371": "\"# dev   cpu timestamp     pid act flg\\n\"", "372": "\"# if no events are modified, an error message will be displayed here\"", "373": "\"# kernel command line\\n\"", "374": "\"# of callbacks/kthreads for barrier testing\"", "375": "\"# of writes between timestamp readings\"", "376": "\"# only events with the given fields will be affected.\\n\"", "377": "\"# or 'echo 1 > /proc/sys/kernel/stack_tracer_enabled'\\n\"", "378": "\"# to enable the stack tracer, either add 'stacktrace' to the\\n\"", "379": "\"# use this to set filters for multiple events.\\n\"", "380": "\"### global filter ###\\n\"", "381": "\"#%.*s  _-----=> irqs-off        \\n\"", "382": "\"#%.*s / _----=> need-resched    \\n\"", "383": "\"#%.*s| / _---=> hardirq/softirq \\n\"", "384": "\"#%.*s|| / _--=> preempt-depth   \\n\"", "385": "\"#%.*s||| /                      \\n\"", "386": "\"#%d\"", "387": "\"#\\n\"", "388": "\"#subsys_name\\thierarchy\\tnum_cgroups\\tenabled\\n\"", "389": "\"$retval\"", "390": "\"$stack $stack0 +0($stack)\"", "391": "\"%%0%dlx \"", "392": "\"%%16.16l%c \"", "393": "\"%%2.2l%c \"", "394": "\"%%4.4l%c \"", "395": "\"%%8.8l%c \"", "396": "\"%*c\"", "397": "\"%*c[<%p>] %ps\\n\"", "398": "\"%*d: \"", "399": "\"%*pb\"", "400": "\"%*pb\\n\"", "401": "\"%*pbl\\n\"", "402": "\"%*s domain %d: \"", "403": "\"%*s groups:\"", "404": "\"%*s%0*llx-%0*llx : %s\\n\"", "405": "\"%-*s      pid   parent [*] cpu state %-*s command\\n\"", "406": "\"%-15.15s %-20.20s %s\\n\"", "407": "\"%-15.15s %-20s%s%s\\n\"", "408": "\"%-15.15s %c\"", "409": "\"%-20s%8u  0x%p \"", "410": "\"%-40s: %ld.%06ld\\n\"", "411": "\"%-40s: %ld\\n\"", "412": "\"%-45s:%14ld.%06ld\\n\"", "413": "\"%-45s:%21ld\\n\"", "414": "\"%016lx tail class: [%p] %s\\n\"", "415": "\"%016lx\"", "416": "\"%02ld:%02ld\\n\"", "417": "\"%02lx 0x%lx %d\\n\"", "418": "\"%02x \"", "419": "\"%08lx\"", "420": "\"%08x\"", "421": "\"%10u \"", "422": "\"%10u %10u %10u\\n\"", "423": "\"%14lu \"", "424": "\"%14s %14s\\n\"", "425": "\"%14s set\\n\"", "426": "\"%15ld %15ld %15ld.%06ld %15ld.%06ld %15ld.%06ld\"", "427": "\"%15s %5d %9ld.%06ld %9ld %5d \"", "428": "\"%16s %5d %3d %d %08x %08lx \"", "429": "\"%16s-%-5d [%03d] \"", "430": "\"%16s:%5d [%p, %3d]\"", "431": "\"%38s-r:\"", "432": "\"%38s-w:\"", "433": "\"%3d%cc=%ld g=%ld pq=%d/%d qp=%d\"", "434": "\"%3d%cnp=%ld \"", "435": "\"%3d,%-3d %2d %5d.%09lu %5u %2s %3s \"", "436": "\"%3d,%-3d %2s %3s \"", "437": "\"%3ld) %8d   %5d   \"", "438": "\"%40s %14lu %29s %ps\\n\"", "439": "\"%40s %14s %14s %14s %14s %14s %14s %14s %14s %14s %14s \"", "440": "\"%40s:\"", "441": "\"%4d \"", "442": "\"%5d \"", "443": "\"%5lu %5d %6d 0x%08lx\\n\"", "444": "\"%5lu.%06lu |  \"", "445": "\"%8.8s-%-5d %3d\"", "446": "\"%8lu %8lu \"", "447": "\"%9ld.%06ld %9ld.%06ld %9ld.%06ld\"", "448": "\"%=\"", "449": "\"%c\"", "450": "\"%c%c%c\"", "451": "\"%c:%s/%s\"", "452": "\"%c_%s_0x%lx\"", "453": "\"%d %d %c %d %d %d %c\\n\"", "454": "\"%d %d\"", "455": "\"%d day%s \"", "456": "\"%d idle process%s (state i)%s\\n\"", "457": "\"%d lock%s held by %s/%d:\\n\"", "458": "\"%d sleeping system daemon (state m) \"", "459": "\"%d\"", "460": "\"%d: %d: %s\\n\"", "461": "\"%d:%d tasks=%c%c%c%c kt=%c ntb=%lu neb=%lu nnb=%lu \"", "462": "\"%d:%d%s\"", "463": "\"%d\\n\"", "464": "\"%hhu\"", "465": "\"%hi\"", "466": "\"%hu\"", "467": "\"%i %lu %lu\"", "468": "\"%i\"", "469": "\"%i\\n\"", "470": "\"%ld\"", "471": "\"%ld\\n\"", "472": "\"%li\"", "473": "\"%lld\\n\"", "474": "\"%llu \"", "475": "\"%llu + %u <- (%d,%d) %llu\\n\"", "476": "\"%llu + %u [%d]\\n\"", "477": "\"%llu + %u [%s]\\n\"", "478": "\"%llu / %llu [%s]\\n\"", "479": "\"%llu [%d]\\n\"", "480": "\"%llu\"", "481": "\"%llu\\n\"", "482": "\"%llx\"", "483": "\"%lu\"", "484": "\"%lx %lx %lx %d %x %x\"", "485": "\"%lx %lx %lx %d %x\"", "486": "\"%lx %lx\\n\"", "487": "\"%lx/%lx->%lx %c%c>%c %d:%d ^%d    \"", "488": "\"%p  %s  %p \"", "489": "\"%p  %s  %s+0x%x  %s \"", "490": "\"%p\"", "491": "\"%p: %c%c nvcsw: %lu/%lu holdout: %d idle_cpu: %d/%d\\n\"", "492": "\"%pk %c %s\\n\"", "493": "\"%pk %c %s\\t[%s]\\n\"", "494": "\"%ps() {\\n\"", "495": "\"%ps();\\n\"", "496": "\"%ps: %s\"", "497": "\"%ps:\"", "498": "\"%ps:%ps\"", "499": "\"%ps:%s\"", "500": "\"%ps\\n\"", "501": "\"%s \"", "502": "\"%s %.*s %s\\n\"", "503": "\"%s %d%s:%pf\"", "504": "\"%s %lld\\n\"", "505": "\"%s %pf\"", "506": "\"%s %u\"", "507": "\"%s (%d) created nested cgroup for controller \\\"%s\\\" which has incomplete hierarchy support. nested cgroups may change behavior in the future.\\n\"", "508": "\"%s (%d): error creating kset\\n\"", "509": "\"%s (%d, #threads: %d)\\n\"", "510": "\"%s -> 0x%lx\\n\"", "511": "\"%s = \"", "512": "\"%s already dying\\n\"", "513": "\"%s bar(%d)\"", "514": "\"%s called for unknown object.\"", "515": "\"%s calls setitimer() with new_value null pointer.\"", "516": "\"%s cpuset=\"", "517": "\"%s depends on broadcast, but no broadcast function available\\n\"", "518": "\"%s didn't like hwirq-0x%lx to virq%i mapping (rc=%d)\\n\"", "519": "\"%s does not use %s!\\n\"", "520": "\"%s entered refrigerator\\n\"", "521": "\"%s kthread starved for %ld jiffies!\\n\"", "522": "\"%s left refrigerator\\n\"", "523": "\"%s type has no corresponding fetch method.\\n\"", "524": "\"%s unusing %s\\n\"", "525": "\"%s uses %s!\\n\"", "526": "\"%s\"", "527": "\"%s%s \"", "528": "\"%s%s per-cpu(idx=%d):\"", "529": "\"%s%s%s%s\\n\"", "530": "\"%s(\"", "531": "\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\"", "532": "\"%s(, %lx) called with null domain\\n\"", "533": "\"%s, func %p help %s\\n\"", "534": "\"%s,\"", "535": "\"%s-%ld\"", "536": "\"%s.%s\"", "537": "\"%s/%d [hc%u[%lu]:sc%u[%lu]:he%u:se%u] takes:\\n\"", "538": "\"%s/%d is deadlocking current task %s/%d\\n\\n\"", "539": "\"%s/%d is leaving the kernel with locks still held!\\n\"", "540": "\"%s/%d is trying to acquire lock:\\n\"", "541": "\"%s/%d is trying to contend lock (\"", "542": "\"%s/%d is trying to lock:\\n\"", "543": "\"%s/%d is trying to release lock (\"", "544": "\"%s/%d\"", "545": "\"%s/%d, %p\\n\"", "546": "\"%s/%s.%s\"", "547": "\"%s:  total: %lld  max/min: %ld/%ld %s  fail: %d %s\\n\"", "548": "\"%s: \"", "549": "\"%s: %016llx\"", "550": "\"%s: %02x\"", "551": "\"%s: %04x\"", "552": "\"%s: %08x\"", "553": "\"%s: %d\\n\"", "554": "\"%s: %lx%s\"", "555": "\"%s: %s: kernel tainted.\\n\"", "556": "\"%s: '%s'->init suspiciously returned %d, it should \"", "557": "\"%s: (\"", "558": "\"%s: (0x%lx <- 0x%lx)\"", "559": "\"%s: (0x%lx)\"", "560": "\"%s: 0x%%0%zulx%s\"", "561": "\"%s: ??\"", "562": "\"%s: `%s' invalid for parameter `%s'\\n\"", "563": "\"%s: `%s' too large for parameter `%s'\\n\"", "564": "\"%s: attempt to bring up cpu %u failed\\n\"", "565": "\"%s: attempt to take down cpu %u failed\\n\"", "566": "\"%s: bad constraints on qos?\\n\"", "567": "\"%s: bad qos param!\\n\"", "568": "\"%s: bp %d bp_enabled %d\\n\"", "569": "\"%s: bp_installed %d\\n\"", "570": "\"%s: can only take %i arguments\\n\"", "571": "\"%s: could not allocate %lu bytes percpu data\\n\"", "572": "\"%s: debug_kmalloc memory leak dah_first %d\\n\"", "573": "\"%s: delayed bp\\n\"", "574": "\"%s: disagrees about version of symbol %s\\n\"", "575": "\"%s: exports duplicate symbol %s\"", "576": "\"%s: failed to add %s, err=%d\\n\"", "577": "\"%s: failed to set breakpoint at 0x%lx\\n\"", "578": "\"%s: h_used %p size %d caller %p\\n\"", "579": "\"%s: h_used %p size %d\\n\"", "580": "\"%s: has both .ctors and .init_array.\\n\"", "581": "\"%s: ignoring obsolete parameters\\n\"", "582": "\"%s: loading module anyway...\\n\"", "583": "\"%s: module has bad taint, not creating trace events\\n\"", "584": "\"%s: module has no symbols (stripped?)\\n\"", "585": "\"%s: module is already loaded\\n\"", "586": "\"%s: module is from the staging directory, the quality \"", "587": "\"%s: module license '%s' taints kernel.\\n\"", "588": "\"%s: module sysfs not initialized\\n\"", "589": "\"%s: module verification failed: signature \"", "590": "\"%s: option '%s' enabled irq's!\\n\"", "591": "\"%s: out of memory loading\\n\"", "592": "\"%s: parameters '%s' after `--' ignored\\n\"", "593": "\"%s: per-cpu alignment %li > %li\\n\"", "594": "\"%s: please compile with -fno-common\\n\"", "595": "\"%s: string doesn't fit in %u chars.\\n\"", "596": "\"%s: string parameter too long\\n\"", "597": "\"%s: unknown parameter '%s' ignored\\n\"", "598": "\"%s: unknown parameter `%s'\\n\"", "599": "\"%s: unknown symbol %s (err %li)\\n\"", "600": "\"%s: version magic '%s' should be '%s'\\n\"", "601": "\"%s: wait state: %d ->state: %#lx\\n\"", "602": "\"%s:\"", "603": "\"%s:%d %s!\\n\"", "604": "\"%s:%s:%s\"", "605": "\"%s=%u old=%u\"", "606": "\"%s\\\" \\\"%s\\\"\\n\"", "607": "\"%s\\n\"", "608": "\"%s\\t%d\\t%d\\t%d\\n\"", "609": "\"%sname=%s\"", "610": "\"%sworkqueue: %s %pf\"", "611": "\"%u \"", "612": "\"%u\"", "613": "\"%u:%s:%s (%u)\"", "614": "\"%u:%u:%u  ==+ %u:%u:%u [%03u]\"", "615": "\"%u:%u:%u  ==> %u:%u:%u [%03u]\"", "616": "\"%u\\n\"", "617": "\"%x\"", "618": "\"%zu\\n\"", "619": "\"&\"", "620": "\"&&\"", "621": "\"&=\"", "622": "\"&struct->lockfield\"", "623": "\"'function_profile_enabled' entry\\n\"", "624": "\"'kprobe_events' entry\\n\"", "625": "\"'kprobe_profile' entry\\n\"", "626": "\"'trace_stat' entry\\n\"", "627": "\"(\"", "628": "\"(%02x) %s\\n\"", "629": "\"(%02x) %sr%d %s %s%d\\n\"", "630": "\"(%02x) %sr%d %s %sr%d\\n\"", "631": "\"(%02x) *(%s *)(r%d %+d) = %d\\n\"", "632": "\"(%02x) *(%s *)(r%d %+d) = r%d\\n\"", "633": "\"(%02x) call %d\\n\"", "634": "\"(%02x) exit\\n\"", "635": "\"(%02x) goto pc%+d\\n\"", "636": "\"(%02x) if r%d %s 0x%x goto pc%+d\\n\"", "637": "\"(%02x) if r%d %s r%d goto pc%+d\\n\"", "638": "\"(%02x) lock *(%s *)(r%d %+d) += r%d\\n\"", "639": "\"(%02x) r%d = *(%s *)(r%d %+d)\\n\"", "640": "\"(%02x) r%d = 0x%x\\n\"", "641": "\"(%02x) r0 = *(%s *)skb[%d]\\n\"", "642": "\"(%02x) r0 = *(%s *)skb[r%d + %d]\\n\"", "643": "\"(%d %d %d %d %d) \"", "644": "\"((((((((a == 1) && (b == 1)) || (c == 1)) && (d == 1)) || \"", "645": "\"((((((((a == 1) || (b == 1)) && (c == 1)) || (d == 1)) && \"", "646": "\"((a == 1 || b == 1) || (c == 1 || d == 1) || \"", "647": "\"(a == 1 && b == 1) && (c == 1 && d == 1) && \"", "648": "\"(a == 1 && b == 1) || (c == 1 && d == 1) || \"", "649": "\"(a == 1 || b == 1) && (c == 1 || d == 1) && \"", "650": "\"(detected by %d, t=%ld jiffies, g=%ld, c=%ld, q=%lu)\\n\"", "651": "\"(e == 1 && f == 1) || (g == 1 && h == 1)\"", "652": "\"(e == 1 || f == 1) && (g == 1 || h == 1)\"", "653": "\"(e == 1 || f == 1)) && (g == 1 || h == 1)\"", "654": "\"(e == 1)) && (f == 1)) || (g == 1)) && (h == 1))\"", "655": "\"(e == 1)) || (f == 1)) && (g == 1)) || (h == 1))\"", "656": "\"(incompatible version)\\n\"", "657": "\"(ks=%d,vs=%d)\"", "658": "\"(no arch support)\"", "659": "\"(none)\"", "660": "\"(null)\"", "661": "\"(out of memory)\\n\"", "662": "\"(rescuer)\"", "663": "\"(test in progress)\"", "664": "\"(u32) \"", "665": "\")\n};\n\n#ifdef config_debug_lock_alloc\n#include <linux/kernel_stat.h>\n\nint rcu_scheduler_active __read_mostly;\nexport_symbol_gpl(rcu_scheduler_active);\n\n\nvoid __init rcu_scheduler_starting(void)\n{\n\twarn_on(nr_context_switches() > 0);\n\trcu_scheduler_active = 1;\n}\n\n#endif \n\n#ifdef config_rcu_trace\n\nstatic void rcu_trace_sub_qlen(struct rcu_ctrlblk *rcp, int n)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\trcp->qlen -= n;\n\tlocal_irq_restore(flags);\n}\n\n\nstatic int show_tiny_stats(struct seq_file *m, void *unused)\n{\n\tseq_printf(m, \"", "666": "\")\n};\n\nstatic struct rcu_ctrlblk rcu_bh_ctrlblk = {\n\t.donetail\t= &rcu_bh_ctrlblk.rcucblist,\n\t.curtail\t= &rcu_bh_ctrlblk.rcucblist,\n\trcu_trace(.name = \"", "667": "\") == 0 || !strlen(glob)))\n\t\tglob = null;\n\telse if (glob) {\n\t\tint not;\n\n\t\ttype = filter_parse_regex(glob, strlen(glob), &search, &not);\n\t\tlen = strlen(search);\n\n\t\t\n\t\tif (warn_on(not))\n\t\t\treturn;\n\t}\n\n\tmutex_lock(&trace_probe_ops.func_hash->regex_lock);\n\n\thash = alloc_and_copy_ftrace_hash(ftrace_hash_default_bits, *orig_hash);\n\tif (!hash)\n\t\t\n\t\tgoto out_unlock;\n\n\tinit_list_head(&free_list);\n\n\tfor (i = 0; i < ftrace_func_hashsize; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\n\t\thlist_for_each_entry_safe(entry, tmp, hhd, node) {\n\n\t\t\t\n\t\t\tif ((flags & probe_test_func) && entry->ops != ops)\n\t\t\t\tcontinue;\n\n\t\t\tif ((flags & probe_test_data) && entry->data != data)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tif (glob) {\n\t\t\t\tkallsyms_lookup(entry->ip, null, null,\n\t\t\t\t\t\tnull, str);\n\t\t\t\tif (!ftrace_match(str, glob, len, type))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\trec_entry = ftrace_lookup_ip(hash, entry->ip);\n\t\t\t\n\t\t\tif (rec_entry)\n\t\t\t\tfree_hash_entry(hash, rec_entry);\n\n\t\t\thlist_del_rcu(&entry->node);\n\t\t\tlist_add(&entry->free_list, &free_list);\n\t\t}\n\t}\n\tmutex_lock(&ftrace_lock);\n\t__disable_ftrace_function_probe();\n\t\n\tret = ftrace_hash_move(&trace_probe_ops, 1, orig_hash, hash);\n\tsynchronize_sched();\n\tif (!ret)\n\t\tfree_ftrace_hash_rcu(old_hash);\n\n\tlist_for_each_entry_safe(entry, p, &free_list, free_list) {\n\t\tlist_del(&entry->free_list);\n\t\tftrace_free_entry(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\t\t\n out_unlock:\n\tmutex_unlock(&trace_probe_ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n}\n\nvoid\nunregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,\n\t\t\t\tvoid *data)\n{\n\t__unregister_ftrace_function_probe(glob, ops, data,\n\t\t\t\t\t  probe_test_func | probe_test_data);\n}\n\nvoid\nunregister_ftrace_function_probe_func(char *glob, struct ftrace_probe_ops *ops)\n{\n\t__unregister_ftrace_function_probe(glob, ops, null, probe_test_func);\n}\n\nvoid unregister_ftrace_function_probe_all(char *glob)\n{\n\t__unregister_ftrace_function_probe(glob, null, null, 0);\n}\n\nstatic list_head(ftrace_commands);\nstatic define_mutex(ftrace_cmd_mutex);\n\n\n__init int register_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p;\n\tint ret = 0;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = -ebusy;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\tlist_add(&cmd->list, &ftrace_commands);\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}\n\n\n__init int unregister_ftrace_command(struct ftrace_func_command *cmd)\n{\n\tstruct ftrace_func_command *p, *n;\n\tint ret = -enodev;\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &ftrace_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}\n\nstatic int ftrace_process_regex(struct ftrace_hash *hash,\n\t\t\t\tchar *buff, int len, int enable)\n{\n\tchar *func, *command, *next = buff;\n\tstruct ftrace_func_command *p;\n\tint ret = -einval;\n\n\tfunc = strsep(&next, \"", "668": "\") == 0 || strcmp(buff, \"", "669": "\") == 0)\n\t\tbuff[0] = 0;\n\n\t\n\tif (strcmp(buff, \"", "670": "\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 11);\n\t\t\t\tstrcpy(buffer, \"", "671": "\") == 0) {\n\t\t\t\tkdb_gdb_state_pass(lastchar - 5);\n\t\t\t\tstrcpy(buffer, \"", "672": "\") == 0) {\n\t\tbuff[0] = 0;\n\t\tnot = 1;\n\t}\n\n\treturn match_records(hash, buff, strlen(buff), mod, not);\n}\n\n\n\nstatic int\nftrace_mod_callback(struct ftrace_hash *hash,\n\t\t    char *func, char *cmd, char *param, int enable)\n{\n\tchar *mod;\n\tint ret = -einval;\n\n\t\n\n\t\n\tif (!param)\n\t\treturn ret;\n\n\tmod = strsep(&param, \"", "673": "\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   kdb_enable_always_safe);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn kdb_notimp;\n\ts->command = kzalloc((s->count + 1) * sizeof(*(s->command)), gfp_kdb);\n\tif (!s->command) {\n\t\tkdb_printf(\"", "674": "\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~kdb_debug_flag_mask) {\n\t\t\tkdb_printf(\"", "675": "\") ?: \"", "676": "\") at:\\n\"", "677": "\")\"", "678": "\"))\n\t\t\treturn -einval;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"", "679": "\"))\n\t\thrtimer_hres_enabled = 0;\n\telse if (!strcmp(str, \"", "680": "\"))\n\t\thrtimer_hres_enabled = 1;\n\telse\n\t\treturn 0;\n\treturn 1;\n}\n\n__setup(\"", "681": "\"))\n\t\treturn;\n\n\t\n\tget_task_struct(p);\n\n\t__unqueue_futex(q);\n\t\n\tsmp_wmb();\n\tq->lock_ptr = null;\n\n\twake_up_state(p, task_normal);\n\tput_task_struct(p);\n}\n\nstatic int wake_futex_pi(u32 __user *uaddr, u32 uval, struct futex_q *this)\n{\n\tstruct task_struct *new_owner;\n\tstruct futex_pi_state *pi_state = this->pi_state;\n\tu32 uninitialized_var(curval), newval;\n\tint ret = 0;\n\n\tif (!pi_state)\n\t\treturn -einval;\n\n\t\n\tif (pi_state->owner != current)\n\t\treturn -einval;\n\n\traw_spin_lock(&pi_state->pi_mutex.wait_lock);\n\tnew_owner = rt_mutex_next_owner(&pi_state->pi_mutex);\n\n\t\n\tif (!new_owner)\n\t\tnew_owner = this->task;\n\n\t\n\tnewval = futex_waiters | task_pid_vnr(new_owner);\n\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\tret = -efault;\n\telse if (curval != uval)\n\t\tret = -einval;\n\tif (ret) {\n\t\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\t\treturn ret;\n\t}\n\n\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\twarn_on(list_empty(&pi_state->list));\n\tlist_del_init(&pi_state->list);\n\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\n\traw_spin_lock_irq(&new_owner->pi_lock);\n\twarn_on(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &new_owner->pi_state_list);\n\tpi_state->owner = new_owner;\n\traw_spin_unlock_irq(&new_owner->pi_lock);\n\n\traw_spin_unlock(&pi_state->pi_mutex.wait_lock);\n\trt_mutex_unlock(&pi_state->pi_mutex);\n\n\treturn 0;\n}\n\n\nstatic inline void\ndouble_lock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tif (hb1 <= hb2) {\n\t\tspin_lock(&hb1->lock);\n\t\tif (hb1 < hb2)\n\t\t\tspin_lock_nested(&hb2->lock, single_depth_nesting);\n\t} else { \n\t\tspin_lock(&hb2->lock);\n\t\tspin_lock_nested(&hb1->lock, single_depth_nesting);\n\t}\n}\n\nstatic inline void\ndouble_unlock_hb(struct futex_hash_bucket *hb1, struct futex_hash_bucket *hb2)\n{\n\tspin_unlock(&hb1->lock);\n\tif (hb1 != hb2)\n\t\tspin_unlock(&hb2->lock);\n}\n\n\nstatic int\nfutex_wake(u32 __user *uaddr, unsigned int flags, int nr_wake, u32 bitset)\n{\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *this, *next;\n\tunion futex_key key = futex_key_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -einval;\n\n\tret = get_futex_key(uaddr, flags & flags_shared, &key, verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\thb = hash_futex(&key);\n\n\t\n\tif (!hb_waiters_pending(hb))\n\t\tgoto out_put_key;\n\n\tspin_lock(&hb->lock);\n\n\tplist_for_each_entry_safe(this, next, &hb->chain, list) {\n\t\tif (match_futex (&this->key, &key)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -einval;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (!(this->bitset & bitset))\n\t\t\t\tcontinue;\n\n\t\t\twake_futex(this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tspin_unlock(&hb->lock);\nout_put_key:\n\tput_futex_key(&key);\nout:\n\treturn ret;\n}\n\n\nstatic int\nfutex_wake_op(u32 __user *uaddr1, unsigned int flags, u32 __user *uaddr2,\n\t      int nr_wake, int nr_wake2, int op)\n{\n\tunion futex_key key1 = futex_key_init, key2 = futex_key_init;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\tint ret, op_ret;\n\nretry:\n\tret = get_futex_key(uaddr1, flags & flags_shared, &key1, verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & flags_shared, &key2, verify_write);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\tdouble_lock_hb(hb1, hb2);\n\top_ret = futex_atomic_op_inuser(op, uaddr2);\n\tif (unlikely(op_ret < 0)) {\n\n\t\tdouble_unlock_hb(hb1, hb2);\n\n#ifndef config_mmu\n\t\t\n\t\tret = op_ret;\n\t\tgoto out_put_keys;\n#endif\n\n\t\tif (unlikely(op_ret != -efault)) {\n\t\t\tret = op_ret;\n\t\t\tgoto out_put_keys;\n\t\t}\n\n\t\tret = fault_in_user_writeable(uaddr2);\n\t\tif (ret)\n\t\t\tgoto out_put_keys;\n\n\t\tif (!(flags & flags_shared))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&key2);\n\t\tput_futex_key(&key1);\n\t\tgoto retry;\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (match_futex (&this->key, &key1)) {\n\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\tret = -einval;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\twake_futex(this);\n\t\t\tif (++ret >= nr_wake)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (op_ret > 0) {\n\t\top_ret = 0;\n\t\tplist_for_each_entry_safe(this, next, &hb2->chain, list) {\n\t\t\tif (match_futex (&this->key, &key2)) {\n\t\t\t\tif (this->pi_state || this->rt_waiter) {\n\t\t\t\t\tret = -einval;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t\twake_futex(this);\n\t\t\t\tif (++op_ret >= nr_wake2)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret += op_ret;\n\t}\n\nout_unlock:\n\tdouble_unlock_hb(hb1, hb2);\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret;\n}\n\n\nstatic inline\nvoid requeue_futex(struct futex_q *q, struct futex_hash_bucket *hb1,\n\t\t   struct futex_hash_bucket *hb2, union futex_key *key2)\n{\n\n\t\n\tif (likely(&hb1->chain != &hb2->chain)) {\n\t\tplist_del(&q->list, &hb1->chain);\n\t\thb_waiters_dec(hb1);\n\t\tplist_add(&q->list, &hb2->chain);\n\t\thb_waiters_inc(hb2);\n\t\tq->lock_ptr = &hb2->lock;\n\t}\n\tget_futex_key_refs(key2);\n\tq->key = *key2;\n}\n\n\nstatic inline\nvoid requeue_pi_wake_futex(struct futex_q *q, union futex_key *key,\n\t\t\t   struct futex_hash_bucket *hb)\n{\n\tget_futex_key_refs(key);\n\tq->key = *key;\n\n\t__unqueue_futex(q);\n\n\twarn_on(!q->rt_waiter);\n\tq->rt_waiter = null;\n\n\tq->lock_ptr = &hb->lock;\n\n\twake_up_state(q->task, task_normal);\n}\n\n\nstatic int futex_proxy_trylock_atomic(u32 __user *pifutex,\n\t\t\t\t struct futex_hash_bucket *hb1,\n\t\t\t\t struct futex_hash_bucket *hb2,\n\t\t\t\t union futex_key *key1, union futex_key *key2,\n\t\t\t\t struct futex_pi_state **ps, int set_waiters)\n{\n\tstruct futex_q *top_waiter = null;\n\tu32 curval;\n\tint ret, vpid;\n\n\tif (get_futex_value_locked(&curval, pifutex))\n\t\treturn -efault;\n\n\t\n\ttop_waiter = futex_top_waiter(hb1, key1);\n\n\t\n\tif (!top_waiter)\n\t\treturn 0;\n\n\t\n\tif (!match_futex(top_waiter->requeue_pi_key, key2))\n\t\treturn -einval;\n\n\t\n\tvpid = task_pid_vnr(top_waiter->task);\n\tret = futex_lock_pi_atomic(pifutex, hb2, key2, ps, top_waiter->task,\n\t\t\t\t   set_waiters);\n\tif (ret == 1) {\n\t\trequeue_pi_wake_futex(top_waiter, key2, hb2);\n\t\treturn vpid;\n\t}\n\treturn ret;\n}\n\n\nstatic int futex_requeue(u32 __user *uaddr1, unsigned int flags,\n\t\t\t u32 __user *uaddr2, int nr_wake, int nr_requeue,\n\t\t\t u32 *cmpval, int requeue_pi)\n{\n\tunion futex_key key1 = futex_key_init, key2 = futex_key_init;\n\tint drop_count = 0, task_count = 0, ret;\n\tstruct futex_pi_state *pi_state = null;\n\tstruct futex_hash_bucket *hb1, *hb2;\n\tstruct futex_q *this, *next;\n\n\tif (requeue_pi) {\n\t\t\n\t\tif (uaddr1 == uaddr2)\n\t\t\treturn -einval;\n\n\t\t\n\t\tif (refill_pi_state_cache())\n\t\t\treturn -enomem;\n\t\t\n\t\tif (nr_wake != 1)\n\t\t\treturn -einval;\n\t}\n\nretry:\n\tret = get_futex_key(uaddr1, flags & flags_shared, &key1, verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\tret = get_futex_key(uaddr2, flags & flags_shared, &key2,\n\t\t\t    requeue_pi ? verify_write : verify_read);\n\tif (unlikely(ret != 0))\n\t\tgoto out_put_key1;\n\n\t\n\tif (requeue_pi && match_futex(&key1, &key2)) {\n\t\tret = -einval;\n\t\tgoto out_put_keys;\n\t}\n\n\thb1 = hash_futex(&key1);\n\thb2 = hash_futex(&key2);\n\nretry_private:\n\thb_waiters_inc(hb2);\n\tdouble_lock_hb(hb1, hb2);\n\n\tif (likely(cmpval != null)) {\n\t\tu32 curval;\n\n\t\tret = get_futex_value_locked(&curval, uaddr1);\n\n\t\tif (unlikely(ret)) {\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\n\t\t\tret = get_user(curval, uaddr1);\n\t\t\tif (ret)\n\t\t\t\tgoto out_put_keys;\n\n\t\t\tif (!(flags & flags_shared))\n\t\t\t\tgoto retry_private;\n\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tgoto retry;\n\t\t}\n\t\tif (curval != *cmpval) {\n\t\t\tret = -eagain;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (requeue_pi && (task_count - nr_wake < nr_requeue)) {\n\t\t\n\t\tret = futex_proxy_trylock_atomic(uaddr2, hb1, hb2, &key1,\n\t\t\t\t\t\t &key2, &pi_state, nr_requeue);\n\n\t\t\n\t\tif (ret > 0) {\n\t\t\twarn_on(pi_state);\n\t\t\tdrop_count++;\n\t\t\ttask_count++;\n\t\t\t\n\t\t\tret = lookup_pi_state(ret, hb2, &key2, &pi_state);\n\t\t}\n\n\t\tswitch (ret) {\n\t\tcase 0:\n\t\t\tbreak;\n\t\tcase -efault:\n\t\t\tfree_pi_state(pi_state);\n\t\t\tpi_state = null;\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tret = fault_in_user_writeable(uaddr2);\n\t\t\tif (!ret)\n\t\t\t\tgoto retry;\n\t\t\tgoto out;\n\t\tcase -eagain:\n\t\t\t\n\t\t\tfree_pi_state(pi_state);\n\t\t\tpi_state = null;\n\t\t\tdouble_unlock_hb(hb1, hb2);\n\t\t\thb_waiters_dec(hb2);\n\t\t\tput_futex_key(&key2);\n\t\t\tput_futex_key(&key1);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tplist_for_each_entry_safe(this, next, &hb1->chain, list) {\n\t\tif (task_count - nr_wake >= nr_requeue)\n\t\t\tbreak;\n\n\t\tif (!match_futex(&this->key, &key1))\n\t\t\tcontinue;\n\n\t\t\n\t\tif ((requeue_pi && !this->rt_waiter) ||\n\t\t    (!requeue_pi && this->rt_waiter) ||\n\t\t    this->pi_state) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (++task_count <= nr_wake && !requeue_pi) {\n\t\t\twake_futex(this);\n\t\t\tcontinue;\n\t\t}\n\n\t\t\n\t\tif (requeue_pi && !match_futex(this->requeue_pi_key, &key2)) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (requeue_pi) {\n\t\t\t\n\t\t\tatomic_inc(&pi_state->refcount);\n\t\t\tthis->pi_state = pi_state;\n\t\t\tret = rt_mutex_start_proxy_lock(&pi_state->pi_mutex,\n\t\t\t\t\t\t\tthis->rt_waiter,\n\t\t\t\t\t\t\tthis->task);\n\t\t\tif (ret == 1) {\n\t\t\t\t\n\t\t\t\trequeue_pi_wake_futex(this, &key2, hb2);\n\t\t\t\tdrop_count++;\n\t\t\t\tcontinue;\n\t\t\t} else if (ret) {\n\t\t\t\t\n\t\t\t\tthis->pi_state = null;\n\t\t\t\tfree_pi_state(pi_state);\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\t\trequeue_futex(this, hb1, hb2, &key2);\n\t\tdrop_count++;\n\t}\n\nout_unlock:\n\tfree_pi_state(pi_state);\n\tdouble_unlock_hb(hb1, hb2);\n\thb_waiters_dec(hb2);\n\n\t\n\twhile (--drop_count >= 0)\n\t\tdrop_futex_key_refs(&key1);\n\nout_put_keys:\n\tput_futex_key(&key2);\nout_put_key1:\n\tput_futex_key(&key1);\nout:\n\treturn ret ? ret : task_count;\n}\n\n\nstatic inline struct futex_hash_bucket *queue_lock(struct futex_q *q)\n\t__acquires(&hb->lock)\n{\n\tstruct futex_hash_bucket *hb;\n\n\thb = hash_futex(&q->key);\n\n\t\n\thb_waiters_inc(hb);\n\n\tq->lock_ptr = &hb->lock;\n\n\tspin_lock(&hb->lock); \n\treturn hb;\n}\n\nstatic inline void\nqueue_unlock(struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tspin_unlock(&hb->lock);\n\thb_waiters_dec(hb);\n}\n\n\nstatic inline void queue_me(struct futex_q *q, struct futex_hash_bucket *hb)\n\t__releases(&hb->lock)\n{\n\tint prio;\n\n\t\n\tprio = min(current->normal_prio, max_rt_prio);\n\n\tplist_node_init(&q->list, prio);\n\tplist_add(&q->list, &hb->chain);\n\tq->task = current;\n\tspin_unlock(&hb->lock);\n}\n\n\nstatic int unqueue_me(struct futex_q *q)\n{\n\tspinlock_t *lock_ptr;\n\tint ret = 0;\n\n\t\nretry:\n\tlock_ptr = q->lock_ptr;\n\tbarrier();\n\tif (lock_ptr != null) {\n\t\tspin_lock(lock_ptr);\n\t\t\n\t\tif (unlikely(lock_ptr != q->lock_ptr)) {\n\t\t\tspin_unlock(lock_ptr);\n\t\t\tgoto retry;\n\t\t}\n\t\t__unqueue_futex(q);\n\n\t\tbug_on(q->pi_state);\n\n\t\tspin_unlock(lock_ptr);\n\t\tret = 1;\n\t}\n\n\tdrop_futex_key_refs(&q->key);\n\treturn ret;\n}\n\n\nstatic void unqueue_me_pi(struct futex_q *q)\n\t__releases(q->lock_ptr)\n{\n\t__unqueue_futex(q);\n\n\tbug_on(!q->pi_state);\n\tfree_pi_state(q->pi_state);\n\tq->pi_state = null;\n\n\tspin_unlock(q->lock_ptr);\n}\n\n\nstatic int fixup_pi_state_owner(u32 __user *uaddr, struct futex_q *q,\n\t\t\t\tstruct task_struct *newowner)\n{\n\tu32 newtid = task_pid_vnr(newowner) | futex_waiters;\n\tstruct futex_pi_state *pi_state = q->pi_state;\n\tstruct task_struct *oldowner = pi_state->owner;\n\tu32 uval, uninitialized_var(curval), newval;\n\tint ret;\n\n\t\n\tif (!pi_state->owner)\n\t\tnewtid |= futex_owner_died;\n\n\t\nretry:\n\tif (get_futex_value_locked(&uval, uaddr))\n\t\tgoto handle_fault;\n\n\twhile (1) {\n\t\tnewval = (uval & futex_owner_died) | newtid;\n\n\t\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, newval))\n\t\t\tgoto handle_fault;\n\t\tif (curval == uval)\n\t\t\tbreak;\n\t\tuval = curval;\n\t}\n\n\t\n\tif (pi_state->owner != null) {\n\t\traw_spin_lock_irq(&pi_state->owner->pi_lock);\n\t\twarn_on(list_empty(&pi_state->list));\n\t\tlist_del_init(&pi_state->list);\n\t\traw_spin_unlock_irq(&pi_state->owner->pi_lock);\n\t}\n\n\tpi_state->owner = newowner;\n\n\traw_spin_lock_irq(&newowner->pi_lock);\n\twarn_on(!list_empty(&pi_state->list));\n\tlist_add(&pi_state->list, &newowner->pi_state_list);\n\traw_spin_unlock_irq(&newowner->pi_lock);\n\treturn 0;\n\n\t\nhandle_fault:\n\tspin_unlock(q->lock_ptr);\n\n\tret = fault_in_user_writeable(uaddr);\n\n\tspin_lock(q->lock_ptr);\n\n\t\n\tif (pi_state->owner != oldowner)\n\t\treturn 0;\n\n\tif (ret)\n\t\treturn ret;\n\n\tgoto retry;\n}\n\nstatic long futex_wait_restart(struct restart_block *restart);\n\n\nstatic int fixup_owner(u32 __user *uaddr, struct futex_q *q, int locked)\n{\n\tstruct task_struct *owner;\n\tint ret = 0;\n\n\tif (locked) {\n\t\t\n\t\tif (q->pi_state->owner != current)\n\t\t\tret = fixup_pi_state_owner(uaddr, q, current);\n\t\tgoto out;\n\t}\n\n\t\n\tif (q->pi_state->owner == current) {\n\t\t\n\t\tif (rt_mutex_trylock(&q->pi_state->pi_mutex)) {\n\t\t\tlocked = 1;\n\t\t\tgoto out;\n\t\t}\n\n\t\t\n\t\traw_spin_lock(&q->pi_state->pi_mutex.wait_lock);\n\t\towner = rt_mutex_owner(&q->pi_state->pi_mutex);\n\t\tif (!owner)\n\t\t\towner = rt_mutex_next_owner(&q->pi_state->pi_mutex);\n\t\traw_spin_unlock(&q->pi_state->pi_mutex.wait_lock);\n\t\tret = fixup_pi_state_owner(uaddr, q, owner);\n\t\tgoto out;\n\t}\n\n\t\n\tif (rt_mutex_owner(&q->pi_state->pi_mutex) == current)\n\t\tprintk(kern_err \"", "682": "\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_recursive(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}\n\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\t\n\tif (irq_domain_is_auto_recursive(domain))\n\t\treturn 0;\n\n\tdomain = domain->parent;\n\tif (domain)\n\t\treturn irq_domain_alloc_irqs_recursive(domain, irq_base,\n\t\t\t\t\t\t       nr_irqs, arg);\n\treturn -enosys;\n}\n\n\nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\t\n\tif (!irq_domain_is_auto_recursive(domain) && domain->parent)\n\t\tirq_domain_free_irqs_recursive(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs);\n}\n\n\nvoid irq_domain_activate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (irq_data->parent_data)\n\t\t\tirq_domain_activate_irq(irq_data->parent_data);\n\t\tif (domain->ops->activate)\n\t\t\tdomain->ops->activate(domain, irq_data);\n\t}\n}\n\n\nvoid irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\tirq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t\n\tif (domain->ops->alloc)\n\t\tdomain->flags |= irq_domain_flag_hierarchy;\n}\n#else\t\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : null;\n}\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}\n#endif\t\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/osq_lock.h>\n\n\nstatic define_per_cpu_shared_aligned(struct optimistic_spin_node, osq_node);\n\n\nstatic inline int encode_cpu(int cpu_nr)\n{\n\treturn cpu_nr + 1;\n}\n\nstatic inline struct optimistic_spin_node *decode_cpu(int encoded_cpu_val)\n{\n\tint cpu_nr = encoded_cpu_val - 1;\n\n\treturn per_cpu_ptr(&osq_node, cpu_nr);\n}\n\n\nstatic inline struct optimistic_spin_node *\nosq_wait_next(struct optimistic_spin_queue *lock,\n\t      struct optimistic_spin_node *node,\n\t      struct optimistic_spin_node *prev)\n{\n\tstruct optimistic_spin_node *next = null;\n\tint curr = encode_cpu(smp_processor_id());\n\tint old;\n\n\t\n\told = prev ? prev->cpu : osq_unlocked_val;\n\n\tfor (;;) {\n\t\tif (atomic_read(&lock->tail) == curr &&\n\t\t    atomic_cmpxchg(&lock->tail, curr, old) == curr) {\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (node->next) {\n\t\t\tnext = xchg(&node->next, null);\n\t\t\tif (next)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcpu_relax_lowlatency();\n\t}\n\n\treturn next;\n}\n\nbool osq_lock(struct optimistic_spin_queue *lock)\n{\n\tstruct optimistic_spin_node *node = this_cpu_ptr(&osq_node);\n\tstruct optimistic_spin_node *prev, *next;\n\tint curr = encode_cpu(smp_processor_id());\n\tint old;\n\n\tnode->locked = 0;\n\tnode->next = null;\n\tnode->cpu = curr;\n\n\told = atomic_xchg(&lock->tail, curr);\n\tif (old == osq_unlocked_val)\n\t\treturn true;\n\n\tprev = decode_cpu(old);\n\tnode->prev = prev;\n\twrite_once(prev->next, node);\n\n\t\n\n\twhile (!read_once(node->locked)) {\n\t\t\n\t\tif (need_resched())\n\t\t\tgoto unqueue;\n\n\t\tcpu_relax_lowlatency();\n\t}\n\treturn true;\n\nunqueue:\n\t\n\n\tfor (;;) {\n\t\tif (prev->next == node &&\n\t\t    cmpxchg(&prev->next, node, null) == node)\n\t\t\tbreak;\n\n\t\t\n\t\tif (smp_load_acquire(&node->locked))\n\t\t\treturn true;\n\n\t\tcpu_relax_lowlatency();\n\n\t\t\n\t\tprev = read_once(node->prev);\n\t}\n\n\t\n\n\tnext = osq_wait_next(lock, node, prev);\n\tif (!next)\n\t\treturn false;\n\n\t\n\n\twrite_once(next->prev, prev);\n\twrite_once(prev->next, next);\n\n\treturn false;\n}\n\nvoid osq_unlock(struct optimistic_spin_queue *lock)\n{\n\tstruct optimistic_spin_node *node, *next;\n\tint curr = encode_cpu(smp_processor_id());\n\n\t\n\tif (likely(atomic_cmpxchg(&lock->tail, curr, osq_unlocked_val) == curr))\n\t\treturn;\n\n\t\n\tnode = this_cpu_ptr(&osq_node);\n\tnext = xchg(&node->next, null);\n\tif (next) {\n\t\twrite_once(next->locked, 1);\n\t\treturn;\n\t}\n\n\tnext = osq_wait_next(lock, node, null);\n\tif (next)\n\t\twrite_once(next->locked, 1);\n}\n\n#include <linux/module.h>\n#include <linux/mutex.h>\n#include <linux/types.h>\n#include <linux/jhash.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/tracepoint.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/static_key.h>\n\nextern struct tracepoint * const __start___tracepoints_ptrs[];\nextern struct tracepoint * const __stop___tracepoints_ptrs[];\n\n\nstatic const int tracepoint_debug;\n\n#ifdef config_modules\n\nstatic define_mutex(tracepoint_module_list_mutex);\n\n\nstatic list_head(tracepoint_module_list);\n#endif \n\n\nstatic define_mutex(tracepoints_mutex);\n\n\nstruct tp_probes {\n\tstruct rcu_head rcu;\n\tstruct tracepoint_func probes[0];\n};\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), gfp_kernel);\n\treturn p == null ? null : p->probes;\n}\n\nstatic void rcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(kern_debug \"", "683": "\"))\n\t\tstrcpy(buf, \"", "684": "\")) {\n\t\tprintk(\"", "685": "\"),\n\t\t\t\tstate, false);\n\t\t\tevents_check_enabled = false;\n\t\t}\n\t\tsyscore_resume();\n\t}\n\n\tarch_suspend_enable_irqs();\n\tbug_on(irqs_disabled());\n\n enable_cpus:\n\tenable_nonboot_cpus();\n\n platform_wake:\n\tplatform_resume_noirq(state);\n\tdpm_resume_noirq(pmsg_resume);\n\n platform_early_resume:\n\tplatform_resume_early(state);\n\n devices_early_resume:\n\tdpm_resume_early(pmsg_resume);\n\n platform_finish:\n\tplatform_resume_finish(state);\n\treturn error;\n}\n\n\nint suspend_devices_and_enter(suspend_state_t state)\n{\n\tint error;\n\tbool wakeup = false;\n\n\tif (!sleep_state_supported(state))\n\t\treturn -enosys;\n\n\terror = platform_suspend_begin(state);\n\tif (error)\n\t\tgoto close;\n\n\tsuspend_console();\n\tsuspend_test_start();\n\terror = dpm_suspend_start(pmsg_suspend);\n\tif (error) {\n\t\tpr_err(\"", "686": "\"),\n\t\t\t\tstate, true);\n\t\t\terror = suspend_ops->enter(state);\n\t\t\ttrace_suspend_resume(tps(\"", "687": "\"),\n\t       init_utsname()->version);\n\n\tif (dump_stack_arch_desc_str[0] != '\\0')\n\t\tprintk(\"", "688": "\"), 0, false);\n\tif (!error)\n\t\treturn 0;\n\n\tsuspend_stats.failed_freeze++;\n\tdpm_save_failed_step(suspend_freeze);\n finish:\n\tpm_notifier_call_chain(pm_post_suspend);\n\tpm_restore_console();\n\treturn error;\n}\n\n\nvoid __weak arch_suspend_disable_irqs(void)\n{\n\tlocal_irq_disable();\n}\n\n\nvoid __weak arch_suspend_enable_irqs(void)\n{\n\tlocal_irq_enable();\n}\n\n\nstatic int suspend_enter(suspend_state_t state, bool *wakeup)\n{\n\tint error;\n\n\terror = platform_suspend_prepare(state);\n\tif (error)\n\t\tgoto platform_finish;\n\n\terror = dpm_suspend_late(pmsg_suspend);\n\tif (error) {\n\t\tprintk(kern_err \"", "689": "\"), 0, false);\n\n\tpr_debug(\"", "690": "\"), 0, true);\n\terror = suspend_freeze_processes();\n\ttrace_suspend_resume(tps(\"", "691": "\"), 0, true);\n\tprintk(kern_info \"", "692": "\"), state, false);\n\t\tgoto platform_wake;\n\t}\n\n\terror = disable_nonboot_cpus();\n\tif (error || suspend_test(test_cpus))\n\t\tgoto enable_cpus;\n\n\tarch_suspend_disable_irqs();\n\tbug_on(!irqs_disabled());\n\n\terror = syscore_suspend();\n\tif (!error) {\n\t\t*wakeup = pm_wakeup_pending();\n\t\tif (!(suspend_test(test_core) || *wakeup)) {\n\t\t\ttrace_suspend_resume(tps(\"", "693": "\"), state, false);\n\tpr_debug(\"", "694": "\"), state, false);\n\n close:\n\tplatform_resume_end(state);\n\treturn error;\n\n recover_platform:\n\tplatform_recover(state);\n\tgoto resume_devices;\n}\n\n\nstatic void suspend_finish(void)\n{\n\tsuspend_thaw_processes();\n\tpm_notifier_call_chain(pm_post_suspend);\n\tpm_restore_console();\n}\n\n\nstatic int enter_state(suspend_state_t state)\n{\n\tint error;\n\n\ttrace_suspend_resume(tps(\"", "695": "\"), state, true);\n\t\tfreeze_enter();\n\t\ttrace_suspend_resume(tps(\"", "696": "\"), state, true);\n\tif (state == pm_suspend_freeze) {\n#ifdef config_pm_debug\n\t\tif (pm_test_level != test_none && pm_test_level <= test_cpus) {\n\t\t\tpr_warning(\"", "697": "\"), state, true);\n\tresume_console();\n\ttrace_suspend_resume(tps(\"", "698": "\");\n\t\t\t\tkdb_state_set(doing_kgdb);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t\tif (lastchar - buffer >= 11 &&\n\t\t\t    strcmp(lastchar - 11, \"", "699": "\");\n\t\t\t\tkdb_state_set(doing_kgdb);\n\t\t\t\treturn buffer;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tgoto poll_again;\n}\n\n\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, cmd_buflen);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t\n\treturn kdb_read(buffer, bufsize);\n}\n\n\n\nstatic void kdb_input_flush(void)\n{\n\tget_char_func *f;\n\tint res;\n\tint flush_delay = 1;\n\twhile (flush_delay) {\n\t\tflush_delay--;\nempty:\n\t\ttouch_nmi_watchdog();\n\t\tfor (f = &kdb_poll_funcs[0]; *f; ++f) {\n\t\t\tres = (*f)();\n\t\t\tif (res != -1) {\n\t\t\t\tflush_delay = 1;\n\t\t\t\tgoto empty;\n\t\t\t}\n\t\t}\n\t\tif (flush_delay)\n\t\t\tmdelay(1);\n\t}\n}\n\n\n\nstatic char kdb_buffer[256];\t\nstatic char *next_avail = kdb_buffer;\nstatic int  size_avail;\nstatic int  suspend_grep;\n\n\nstatic int kdb_search_string(char *searched, char *searchfor)\n{\n\tchar firstchar, *cp;\n\tint len1, len2;\n\n\t\n\tlen1 = strlen(searched)-1;\n\tlen2 = strlen(searchfor);\n\tif (len1 < len2)\n\t\treturn 0;\n\tif (kdb_grep_leading && kdb_grep_trailing && len1 != len2)\n\t\treturn 0;\n\tif (kdb_grep_leading) {\n\t\tif (!strncmp(searched, searchfor, len2))\n\t\t\treturn 1;\n\t} else if (kdb_grep_trailing) {\n\t\tif (!strncmp(searched+len1-len2, searchfor, len2))\n\t\t\treturn 1;\n\t} else {\n\t\tfirstchar = *searchfor;\n\t\tcp = searched;\n\t\twhile ((cp = strchr(cp, firstchar))) {\n\t\t\tif (!strncmp(cp, searchfor, len2))\n\t\t\t\treturn 1;\n\t\t\tcp++;\n\t\t}\n\t}\n\treturn 0;\n}\n\nint vkdb_printf(enum kdb_msgsrc src, const char *fmt, va_list ap)\n{\n\tint diag;\n\tint linecount;\n\tint colcount;\n\tint logging, saved_loglevel = 0;\n\tint saved_trap_printk;\n\tint got_printf_lock = 0;\n\tint retlen = 0;\n\tint fnd, len;\n\tchar *cp, *cp2, *cphold = null, replaced_byte = ' ';\n\tchar *moreprompt = \"", "700": "\");\n\t\t\t*strchrnul(kdb_grep_string, '\\n') = '\\0';\n\t\t\tkdb_grepping_flag += kdb_grepping_flag_search;\n\t\t\tsuspend_grep = 1; \n\t\t} else if (buf1[0] && buf1[0] != '\\n') {\n\t\t\t\n\t\t\tsuspend_grep = 1; \n\t\t\tif (buf1[0] != '/')\n\t\t\t\tkdb_printf(\n\t\t\t\t    \"", "701": "\");\n\t\t\t--cp;\n\t\t}\n\t\tbreak;\n\tcase 14: \n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"", "702": "\");\n\t\t\telse\n\t\t\t\tkdb_printf(\"", "703": "\");\n\t\t\terr = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\tdentry = relay_create_buf_file(chan, chan->buf[i], i);\n\t\tif (unlikely(!dentry)) {\n\t\t\terr = -einval;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (curr_cpu == i) {\n\t\t\tlocal_irq_save(flags);\n\t\t\trelay_set_buf_dentry(chan->buf[i], dentry);\n\t\t\tlocal_irq_restore(flags);\n\t\t} else {\n\t\t\tdisp.buf = chan->buf[i];\n\t\t\tdisp.dentry = dentry;\n\t\t\tsmp_mb();\n\t\t\t\n\t\t\terr = smp_call_function_single(i,\n\t\t\t\t\t\t       __relay_set_buf_dentry,\n\t\t\t\t\t\t       &disp, 1);\n\t\t}\n\t\tif (unlikely(err))\n\t\t\tbreak;\n\t}\n\tput_cpu();\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn err;\n}\n\n\nsize_t relay_switch_subbuf(struct rchan_buf *buf, size_t length)\n{\n\tvoid *old, *new;\n\tsize_t old_subbuf, new_subbuf;\n\n\tif (unlikely(length > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\tif (buf->offset != buf->chan->subbuf_size + 1) {\n\t\tbuf->prev_padding = buf->chan->subbuf_size - buf->offset;\n\t\told_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\t\tbuf->padding[old_subbuf] = buf->prev_padding;\n\t\tbuf->subbufs_produced++;\n\t\tif (buf->dentry)\n\t\t\td_inode(buf->dentry)->i_size +=\n\t\t\t\tbuf->chan->subbuf_size -\n\t\t\t\tbuf->padding[old_subbuf];\n\t\telse\n\t\t\tbuf->early_bytes += buf->chan->subbuf_size -\n\t\t\t\t\t    buf->padding[old_subbuf];\n\t\tsmp_mb();\n\t\tif (waitqueue_active(&buf->read_wait))\n\t\t\t\n\t\t\tmod_timer(&buf->timer, jiffies + 1);\n\t}\n\n\told = buf->data;\n\tnew_subbuf = buf->subbufs_produced % buf->chan->n_subbufs;\n\tnew = buf->start + new_subbuf * buf->chan->subbuf_size;\n\tbuf->offset = 0;\n\tif (!buf->chan->cb->subbuf_start(buf, new, old, buf->prev_padding)) {\n\t\tbuf->offset = buf->chan->subbuf_size + 1;\n\t\treturn 0;\n\t}\n\tbuf->data = new;\n\tbuf->padding[new_subbuf] = 0;\n\n\tif (unlikely(length + buf->offset > buf->chan->subbuf_size))\n\t\tgoto toobig;\n\n\treturn length;\n\ntoobig:\n\tbuf->chan->last_toobig = length;\n\treturn 0;\n}\nexport_symbol_gpl(relay_switch_subbuf);\n\n\nvoid relay_subbufs_consumed(struct rchan *chan,\n\t\t\t    unsigned int cpu,\n\t\t\t    size_t subbufs_consumed)\n{\n\tstruct rchan_buf *buf;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (cpu >= nr_cpus || !chan->buf[cpu] ||\n\t\t\t\t\tsubbufs_consumed > chan->n_subbufs)\n\t\treturn;\n\n\tbuf = chan->buf[cpu];\n\tif (subbufs_consumed > buf->subbufs_produced - buf->subbufs_consumed)\n\t\tbuf->subbufs_consumed = buf->subbufs_produced;\n\telse\n\t\tbuf->subbufs_consumed += subbufs_consumed;\n}\nexport_symbol_gpl(relay_subbufs_consumed);\n\n\nvoid relay_close(struct rchan *chan)\n{\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tmutex_lock(&relay_channels_mutex);\n\tif (chan->is_global && chan->buf[0])\n\t\trelay_close_buf(chan->buf[0]);\n\telse\n\t\tfor_each_possible_cpu(i)\n\t\t\tif (chan->buf[i])\n\t\t\t\trelay_close_buf(chan->buf[i]);\n\n\tif (chan->last_toobig)\n\t\tprintk(kern_warning \"", "704": "\");\n\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\tif (kallsyms_symbol_next(p_tmp, i) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tkdb_printf(\"", "705": "\");\n\t\t\tkdb_getstr(kdb_grep_string, kdb_grep_strlen,\n\t\t\t\t   kdbgetenv(\"", "706": "\");\n\t\t\tkdb_printf(\"", "707": "\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tcp = buffer;\n\t\t}\n\t\tbreak;\n\tcase 5: \n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"", "708": "\");\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"", "709": "\");\n\t\t\tkdb_state_set(doing_kgdb);\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic int kdb_read_get_key(char *buffer, size_t bufsize)\n{\n#define escape_udelay 1000\n#define escape_delay (2*1000000/escape_udelay) \n\tchar escape_data[5];\t\n\tchar *ped = escape_data;\n\tint escape_delay = 0;\n\tget_char_func *f, *f_escape = null;\n\tint key;\n\n\tfor (f = &kdb_poll_funcs[0]; ; ++f) {\n\t\tif (*f == null) {\n\t\t\t\n\t\t\ttouch_nmi_watchdog();\n\t\t\tf = &kdb_poll_funcs[0];\n\t\t}\n\t\tif (escape_delay == 2) {\n\t\t\t*ped = '\\0';\n\t\t\tped = escape_data;\n\t\t\t--escape_delay;\n\t\t}\n\t\tif (escape_delay == 1) {\n\t\t\tkey = *ped++;\n\t\t\tif (!*ped)\n\t\t\t\t--escape_delay;\n\t\t\tbreak;\n\t\t}\n\t\tkey = (*f)();\n\t\tif (key == -1) {\n\t\t\tif (escape_delay) {\n\t\t\t\tudelay(escape_udelay);\n\t\t\t\t--escape_delay;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (bufsize <= 2) {\n\t\t\tif (key == '\\r')\n\t\t\t\tkey = '\\n';\n\t\t\t*buffer++ = key;\n\t\t\t*buffer = '\\0';\n\t\t\treturn -1;\n\t\t}\n\t\tif (escape_delay == 0 && key == '\\e') {\n\t\t\tescape_delay = escape_delay;\n\t\t\tped = escape_data;\n\t\t\tf_escape = f;\n\t\t}\n\t\tif (escape_delay) {\n\t\t\t*ped++ = key;\n\t\t\tif (f_escape != f) {\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (ped - escape_data == 1) {\n\t\t\t\t\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 2) {\n\t\t\t\t\n\t\t\t\tif (key != '[')\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 3) {\n\t\t\t\t\n\t\t\t\tint mapkey = 0;\n\t\t\t\tswitch (key) {\n\t\t\t\tcase 'a': \n\t\t\t\t\tmapkey = 16;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b': \n\t\t\t\t\tmapkey = 14;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c': \n\t\t\t\t\tmapkey = 6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd': \n\t\t\t\t\tmapkey = 2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '1': \n\t\t\t\tcase '3': \n\t\t\t\t\n\t\t\t\tcase '4':\n\t\t\t\t\tmapkey = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (mapkey != -1) {\n\t\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t\t}\n\t\t\t\t\tescape_delay = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t} else if (ped - escape_data == 4) {\n\t\t\t\t\n\t\t\t\tint mapkey = 0;\n\t\t\t\tif (key == '~') {\n\t\t\t\t\tswitch (escape_data[2]) {\n\t\t\t\t\tcase '1': \n\t\t\t\t\t\tmapkey = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '3': \n\t\t\t\t\t\tmapkey = 4;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase '4': \n\t\t\t\t\t\tmapkey = 5;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (mapkey > 0) {\n\t\t\t\t\tescape_data[0] = mapkey;\n\t\t\t\t\tescape_data[1] = '\\0';\n\t\t\t\t}\n\t\t\t\tescape_delay = 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tbreak;\t\n\t}\n\treturn key;\n}\n\n\n\nstatic char *kdb_read(char *buffer, size_t bufsize)\n{\n\tchar *cp = buffer;\n\tchar *bufend = buffer+bufsize-2;\t\n\tchar *lastchar;\n\tchar *p_tmp;\n\tchar tmp;\n\tstatic char tmpbuffer[cmd_buflen];\n\tint len = strlen(buffer);\n\tint len_tmp;\n\tint tab = 0;\n\tint count;\n\tint i;\n\tint diag, dtab_count;\n\tint key;\n\n\n\tdiag = kdbgetintenv(\"", "710": "\");\n\t\t\tprint_name_offset(m, dev->set_state_oneshot);\n\t\t\tseq_printf(m, \"", "711": "\");\n\t\t\tprint_name_offset(m, dev->set_state_periodic);\n\t\t\tseq_printf(m, \"", "712": "\");\n\t\t\tprint_name_offset(m, dev->set_state_shutdown);\n\t\t\tseq_printf(m, \"", "713": "\");\n\t\t\tprint_name_offset(m, dev->tick_resume);\n\t\t\tseq_printf(m, \"", "714": "\");\n\t\t\tprint_stack_trace(class->usage_traces + bit, len);\n\t\t}\n\t}\n\tprintk(\"", "715": "\");\n\t\t\treturn -eagain;\n\t\t}\n#endif\n\t} else if (!valid_state(state)) {\n\t\treturn -einval;\n\t}\n\tif (!mutex_trylock(&pm_mutex))\n\t\treturn -ebusy;\n\n\tif (state == pm_suspend_freeze)\n\t\tfreeze_begin();\n\n\ttrace_suspend_resume(tps(\"", "716": "\");\n\t\t\tseq_printf(m, \"", "717": "\");\n\t\t\tsuspend_grep = 1; \n\t\t} else if (buf1[0] == '/' && !kdb_grepping_flag) {\n\t\t\tkdb_printf(\"", "718": "\");\n\t\t\tsuspend_grep = 1; \n\t\t} else if (buf1[0] == '\\n') {\n\t\t\tkdb_nextline = linecount - 1;\n\t\t\tkdb_printf(\"", "719": "\");\n\t\t\ttest_ftrace_alive(m);\n\t\t}\n\t\tif (iter->snapshot && trace_empty(iter))\n\t\t\tprint_snapshot_help(m, iter);\n\t\telse if (iter->trace && iter->trace->print_header)\n\t\t\titer->trace->print_header(m);\n\t\telse\n\t\t\ttrace_default_header(m);\n\n\t} else if (iter->leftover) {\n\t\t\n\t\tret = trace_print_seq(m, &iter->seq);\n\n\t\t\n\t\titer->leftover = ret;\n\n\t} else {\n\t\tprint_trace_line(iter);\n\t\tret = trace_print_seq(m, &iter->seq);\n\t\t\n\t\titer->leftover = ret;\n\t}\n\n\treturn 0;\n}\n\n\nstatic inline int tracing_get_cpu(struct inode *inode)\n{\n\tif (inode->i_cdev) \n\t\treturn (long)inode->i_cdev - 1;\n\treturn ring_buffer_all_cpus;\n}\n\nstatic const struct seq_operations tracer_seq_ops = {\n\t.start\t\t= s_start,\n\t.next\t\t= s_next,\n\t.stop\t\t= s_stop,\n\t.show\t\t= s_show,\n};\n\nstatic struct trace_iterator *\n__tracing_open(struct inode *inode, struct file *file, bool snapshot)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint cpu;\n\n\tif (tracing_disabled)\n\t\treturn err_ptr(-enodev);\n\n\titer = __seq_open_private(file, &tracer_seq_ops, sizeof(*iter));\n\tif (!iter)\n\t\treturn err_ptr(-enomem);\n\n\titer->buffer_iter = kzalloc(sizeof(*iter->buffer_iter) * num_possible_cpus(),\n\t\t\t\t    gfp_kernel);\n\tif (!iter->buffer_iter)\n\t\tgoto release;\n\n\t\n\tmutex_lock(&trace_types_lock);\n\titer->trace = kzalloc(sizeof(*iter->trace), gfp_kernel);\n\tif (!iter->trace)\n\t\tgoto fail;\n\n\t*iter->trace = *tr->current_trace;\n\n\tif (!zalloc_cpumask_var(&iter->started, gfp_kernel))\n\t\tgoto fail;\n\n\titer->tr = tr;\n\n#ifdef config_tracer_max_trace\n\t\n\tif (tr->current_trace->print_max || snapshot)\n\t\titer->trace_buffer = &tr->max_buffer;\n\telse\n#endif\n\t\titer->trace_buffer = &tr->trace_buffer;\n\titer->snapshot = snapshot;\n\titer->pos = -1;\n\titer->cpu_file = tracing_get_cpu(inode);\n\tmutex_init(&iter->mutex);\n\n\t\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t\n\tif (ring_buffer_overruns(iter->trace_buffer->buffer))\n\t\titer->iter_flags |= trace_file_annotate;\n\n\t\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\titer->iter_flags |= trace_file_time_in_ns;\n\n\t\n\tif (!iter->snapshot)\n\t\ttracing_stop_tr(tr);\n\n\tif (iter->cpu_file == ring_buffer_all_cpus) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\titer->buffer_iter[cpu] =\n\t\t\t\tring_buffer_read_prepare(iter->trace_buffer->buffer, cpu);\n\t\t}\n\t\tring_buffer_read_prepare_sync();\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tring_buffer_read_start(iter->buffer_iter[cpu]);\n\t\t\ttracing_iter_reset(iter, cpu);\n\t\t}\n\t} else {\n\t\tcpu = iter->cpu_file;\n\t\titer->buffer_iter[cpu] =\n\t\t\tring_buffer_read_prepare(iter->trace_buffer->buffer, cpu);\n\t\tring_buffer_read_prepare_sync();\n\t\tring_buffer_read_start(iter->buffer_iter[cpu]);\n\t\ttracing_iter_reset(iter, cpu);\n\t}\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn iter;\n\n fail:\n\tmutex_unlock(&trace_types_lock);\n\tkfree(iter->trace);\n\tkfree(iter->buffer_iter);\nrelease:\n\tseq_release_private(inode, file);\n\treturn err_ptr(-enomem);\n}\n\nint tracing_open_generic(struct inode *inode, struct file *filp)\n{\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tfilp->private_data = inode->i_private;\n\treturn 0;\n}\n\nbool tracing_is_disabled(void)\n{\n\treturn (tracing_disabled) ? true: false;\n}\n\n\nstatic int tracing_open_generic_tr(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tfilp->private_data = inode->i_private;\n\n\treturn 0;\n}\n\nstatic int tracing_release(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m = file->private_data;\n\tstruct trace_iterator *iter;\n\tint cpu;\n\n\tif (!(file->f_mode & fmode_read)) {\n\t\ttrace_array_put(tr);\n\t\treturn 0;\n\t}\n\n\t\n\titer = m->private;\n\tmutex_lock(&trace_types_lock);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tif (iter->buffer_iter[cpu])\n\t\t\tring_buffer_read_finish(iter->buffer_iter[cpu]);\n\t}\n\n\tif (iter->trace && iter->trace->close)\n\t\titer->trace->close(iter);\n\n\tif (!iter->snapshot)\n\t\t\n\t\ttracing_start_tr(tr);\n\n\t__trace_array_put(tr);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tmutex_destroy(&iter->mutex);\n\tfree_cpumask_var(iter->started);\n\tkfree(iter->trace);\n\tkfree(iter->buffer_iter);\n\tseq_release_private(inode, file);\n\n\treturn 0;\n}\n\nstatic int tracing_release_generic_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\treturn 0;\n}\n\nstatic int tracing_single_release_tr(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\ttrace_array_put(tr);\n\n\treturn single_release(inode, file);\n}\n\nstatic int tracing_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint ret = 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\t\n\tif ((file->f_mode & fmode_write) && (file->f_flags & o_trunc)) {\n\t\tint cpu = tracing_get_cpu(inode);\n\n\t\tif (cpu == ring_buffer_all_cpus)\n\t\t\ttracing_reset_online_cpus(&tr->trace_buffer);\n\t\telse\n\t\t\ttracing_reset(&tr->trace_buffer, cpu);\n\t}\n\n\tif (file->f_mode & fmode_read) {\n\t\titer = __tracing_open(inode, file, false);\n\t\tif (is_err(iter))\n\t\t\tret = ptr_err(iter);\n\t\telse if (trace_flags & trace_iter_latency_fmt)\n\t\t\titer->iter_flags |= trace_file_lat_fmt;\n\t}\n\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\n\nstatic bool\ntrace_ok_for_array(struct tracer *t, struct trace_array *tr)\n{\n\treturn (tr->flags & trace_array_fl_global) || t->allow_instances;\n}\n\n\nstatic struct tracer *\nget_tracer_for_array(struct trace_array *tr, struct tracer *t)\n{\n\twhile (t && !trace_ok_for_array(t, tr))\n\t\tt = t->next;\n\n\treturn t;\n}\n\nstatic void *\nt_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t = v;\n\n\t(*pos)++;\n\n\tif (t)\n\t\tt = get_tracer_for_array(tr, t->next);\n\n\treturn t;\n}\n\nstatic void *t_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_array *tr = m->private;\n\tstruct tracer *t;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tt = get_tracer_for_array(tr, trace_types);\n\tfor (; t && l < *pos; t = t_next(m, t, &l))\n\t\t\t;\n\n\treturn t;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&trace_types_lock);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct tracer *t = v;\n\n\tif (!t)\n\t\treturn 0;\n\n\tseq_puts(m, t->name);\n\tif (t->next)\n\t\tseq_putc(m, ' ');\n\telse\n\t\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations show_traces_seq_ops = {\n\t.start\t\t= t_start,\n\t.next\t\t= t_next,\n\t.stop\t\t= t_stop,\n\t.show\t\t= t_show,\n};\n\nstatic int show_traces_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct seq_file *m;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tret = seq_open(file, &show_traces_seq_ops);\n\tif (ret)\n\t\treturn ret;\n\n\tm = file->private_data;\n\tm->private = tr;\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_write_stub(struct file *filp, const char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\treturn count;\n}\n\nloff_t tracing_lseek(struct file *file, loff_t offset, int whence)\n{\n\tint ret;\n\n\tif (file->f_mode & fmode_read)\n\t\tret = seq_lseek(file, offset, whence);\n\telse\n\t\tfile->f_pos = ret = 0;\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_fops = {\n\t.open\t\t= tracing_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tracing_write_stub,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= tracing_release,\n};\n\nstatic const struct file_operations show_traces_fops = {\n\t.open\t\t= show_traces_open,\n\t.read\t\t= seq_read,\n\t.release\t= seq_release,\n\t.llseek\t\t= seq_lseek,\n};\n\n\nstatic define_mutex(tracing_cpumask_update_lock);\n\n\nstatic char mask_str[nr_cpus + 1];\n\nstatic ssize_t\ntracing_cpumask_read(struct file *filp, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct trace_array *tr = file_inode(filp)->i_private;\n\tint len;\n\n\tmutex_lock(&tracing_cpumask_update_lock);\n\n\tlen = snprintf(mask_str, count, \"", "720": "\");\n\t\t\n\t\tret = ftrace_set_func(table, count, ftrace_graph_max_funcs, func);\n\t\tif (ret)\n\t\t\tprintk(kern_debug \"", "721": "\");\n\t\t\n\t\ttsk->flags |= pf_exitpidone;\n\t\tset_current_state(task_uninterruptible);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  \n\t\n\tsmp_mb();\n\traw_spin_unlock_wait(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic()))\n\t\tpr_info(\"", "722": "\");\n\t\t__print_lock_name(middle_class);\n\t\tprintk(\"", "723": "\");\n\t\t__print_lock_name(parent);\n\t\tprintk(\"", "724": "\");\n\t\t__print_lock_name(safe_class);\n\t\tprintk(\"", "725": "\");\n\t\t__print_lock_name(source);\n\t\tprintk(\"", "726": "\");\n\t\t__print_lock_name(target);\n\t\tprintk(\"", "727": "\");\n\t\t__print_lock_name(unsafe_class);\n\t\tprintk(\"", "728": "\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}\n\n\nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se,\n\t\t\t       struct sched_dl_entity *pi_se, u64 t)\n{\n\tu64 left, right;\n\n\t\n\tleft = (pi_se->dl_period >> dl_scale) * (dl_se->runtime >> dl_scale);\n\tright = ((dl_se->deadline - t) >> dl_scale) *\n\t\t(pi_se->dl_runtime >> dl_scale);\n\n\treturn dl_time_before(right, left);\n}\n\n\nstatic void update_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t     struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t\n\tif (dl_se->dl_new) {\n\t\tsetup_new_dl_entity(dl_se, pi_se);\n\t\treturn;\n\t}\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n}\n\n\nstatic int start_dl_timer(struct sched_dl_entity *dl_se, bool boosted)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\tktime_t now, act;\n\tktime_t soft, hard;\n\tunsigned long range;\n\ts64 delta;\n\n\tif (boosted)\n\t\treturn 0;\n\t\n\tact = ns_to_ktime(dl_se->deadline);\n\tnow = hrtimer_cb_get_time(&dl_se->dl_timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\thrtimer_set_expires(&dl_se->dl_timer, act);\n\n\tsoft = hrtimer_get_softexpires(&dl_se->dl_timer);\n\thard = hrtimer_get_expires(&dl_se->dl_timer);\n\trange = ktime_to_ns(ktime_sub(hard, soft));\n\t__hrtimer_start_range_ns(&dl_se->dl_timer, soft,\n\t\t\t\t range, hrtimer_mode_abs, 0);\n\n\treturn hrtimer_active(&dl_se->dl_timer);\n}\n\n\nstatic enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tunsigned long flags;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &flags);\n\n\t\n\tif (!dl_task(p) || dl_se->dl_new ||\n\t    dl_se->dl_boosted || !dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n#ifdef config_smp\n\t\n\tif (unlikely(!rq->online)) {\n\t\tdl_task_offline_migration(rq, p);\n\t\tgoto unlock;\n\t}\n#endif\n\n\t\n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se, dl_se);\n\t\tgoto unlock;\n\t}\n\n\tenqueue_task_dl(rq, p, enqueue_replenish);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n#ifdef config_smp\n\t\n\tif (has_pushable_dl_tasks(rq))\n\t\tpush_dl_task(rq);\n#endif\nunlock:\n\ttask_rq_unlock(rq, p, &flags);\n\n\treturn hrtimer_norestart;\n}\n\nvoid init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, clock_monotonic, hrtimer_mode_rel);\n\ttimer->function = dl_task_timer;\n}\n\nstatic\nint dl_runtime_exceeded(struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}\n\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t\n\tdelta_exec = rq_clock_task(rq) - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0))\n\t\treturn;\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = rq_clock_task(rq);\n\tcpuacct_charge(curr, delta_exec);\n\n\tsched_rt_avg_update(rq, delta_exec);\n\n\tdl_se->runtime -= dl_se->dl_yielded ? 0 : delta_exec;\n\tif (dl_runtime_exceeded(rq, dl_se)) {\n\t\tdl_se->dl_throttled = 1;\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(!start_dl_timer(dl_se, curr->dl.dl_boosted)))\n\t\t\tenqueue_task_dl(rq, curr, enqueue_replenish);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}\n\n#ifdef config_smp\n\nstatic struct task_struct *pick_next_earliest_dl_task(struct rq *rq, int cpu);\n\nstatic inline u64 next_deadline(struct rq *rq)\n{\n\tstruct task_struct *next = pick_next_earliest_dl_task(rq, rq->cpu);\n\n\tif (next && dl_prio(next->prio))\n\t\treturn next->dl.deadline;\n\telse\n\t\treturn 0;\n}\n\nstatic void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\t\n\t\tdl_rq->earliest_dl.next = dl_rq->earliest_dl.curr;\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline, 1);\n\t} else if (dl_rq->earliest_dl.next == 0 ||\n\t\t   dl_time_before(deadline, dl_rq->earliest_dl.next)) {\n\t\t\n\t\tdl_rq->earliest_dl.next = next_deadline(rq);\n\t}\n}\n\nstatic void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t\n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, 0, 0);\n\t} else {\n\t\tstruct rb_node *leftmost = dl_rq->rb_leftmost;\n\t\tstruct sched_dl_entity *entry;\n\n\t\tentry = rb_entry(leftmost, struct sched_dl_entity, rb_node);\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tdl_rq->earliest_dl.next = next_deadline(rq);\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline, 1);\n\t}\n}\n\n#else\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}\n\n#endif \n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\twarn_on(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\twarn_on(!dl_prio(prio));\n\twarn_on(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rb_node **link = &dl_rq->rb_root.rb_node;\n\tstruct rb_node *parent = null;\n\tstruct sched_dl_entity *entry;\n\tint leftmost = 1;\n\n\tbug_on(!rb_empty_node(&dl_se->rb_node));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_dl_entity, rb_node);\n\t\tif (dl_time_before(dl_se->deadline, entry->deadline))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tdl_rq->rb_leftmost = &dl_se->rb_node;\n\n\trb_link_node(&dl_se->rb_node, parent, link);\n\trb_insert_color(&dl_se->rb_node, &dl_rq->rb_root);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (rb_empty_node(&dl_se->rb_node))\n\t\treturn;\n\n\tif (dl_rq->rb_leftmost == &dl_se->rb_node) {\n\t\tstruct rb_node *next_node;\n\n\t\tnext_node = rb_next(&dl_se->rb_node);\n\t\tdl_rq->rb_leftmost = next_node;\n\t}\n\n\trb_erase(&dl_se->rb_node, &dl_rq->rb_root);\n\trb_clear_node(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se,\n\t\t  struct sched_dl_entity *pi_se, int flags)\n{\n\tbug_on(on_dl_rq(dl_se));\n\n\t\n\tif (dl_se->dl_new || flags & enqueue_wakeup)\n\t\tupdate_dl_entity(dl_se, pi_se);\n\telse if (flags & enqueue_replenish)\n\t\treplenish_dl_entity(dl_se, pi_se);\n\n\t__enqueue_dl_entity(dl_se);\n}\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t\n\tif (pi_task && p->dl.dl_boosted && dl_prio(pi_task->normal_prio)) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t\n\t\tbug_on(!p->dl.dl_boosted || flags != enqueue_replenish);\n\t\treturn;\n\t}\n\n\t\n\tif (p->dl.dl_throttled && !(flags & enqueue_replenish))\n\t\treturn;\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}\n\nstatic void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n}\n\n\nstatic void yield_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\t\n\tif (p->dl.runtime > 0) {\n\t\trq->curr->dl.dl_yielded = 1;\n\t\tp->dl.runtime = 0;\n\t}\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t\n\trq_clock_skip_update(rq, true);\n}\n\n#ifdef config_smp\n\nstatic int find_later_rq(struct task_struct *task);\n\nstatic int\nselect_task_rq_dl(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\tstruct task_struct *curr;\n\tstruct rq *rq;\n\n\tif (sd_flag != sd_balance_wake)\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = access_once(rq->curr); \n\n\t\n\tif (unlikely(dl_task(curr)) &&\n\t    (curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t    (p->nr_cpus_allowed > 1)) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1)\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    cpudl_find(&rq->rd->cpudl, rq->curr, null) == -1)\n\t\treturn;\n\n\t\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, null) != -1)\n\t\treturn;\n\n\tresched_curr(rq);\n}\n\nstatic int pull_dl_task(struct rq *this_rq);\n\n#endif \n\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef config_smp\n\t\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif \n}\n\n#ifdef config_sched_hrtick\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}\n#else \nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}\n#endif\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = dl_rq->rb_leftmost;\n\n\tif (!left)\n\t\treturn null;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}\n\nstruct task_struct *pick_next_task_dl(struct rq *rq, struct task_struct *prev)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct task_struct *p;\n\tstruct dl_rq *dl_rq;\n\n\tdl_rq = &rq->dl;\n\n\tif (need_pull_dl_task(rq, prev)) {\n\t\tpull_dl_task(rq);\n\t\t\n\t\tif (rq->stop && task_on_rq_queued(rq->stop))\n\t\t\treturn retry_task;\n\t}\n\n\t\n\tif (prev->sched_class == &dl_sched_class)\n\t\tupdate_curr_dl(rq);\n\n\tif (unlikely(!dl_rq->dl_nr_running))\n\t\treturn null;\n\n\tput_prev_task(rq, prev);\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tbug_on(!dl_se);\n\n\tp = dl_task_of(dl_se);\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t\n       dequeue_pushable_dl_task(rq, p);\n\n\tif (hrtick_enabled(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tset_post_schedule(rq);\n\n\treturn p;\n}\n\nstatic void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tupdate_curr_dl(rq);\n\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}\n\nstatic void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\t\n\tif (hrtick_enabled(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}\n\nstatic void task_fork_dl(struct task_struct *p)\n{\n\t\n}\n\nstatic void task_dead_dl(struct task_struct *p)\n{\n\tstruct hrtimer *timer = &p->dl.dl_timer;\n\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\n\traw_spin_lock_irq(&dl_b->lock);\n\t\n\tdl_b->total_bw -= p->dl.dl_bw;\n\traw_spin_unlock_irq(&dl_b->lock);\n\n\thrtimer_cancel(timer);\n}\n\nstatic void set_curr_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t\n\tdequeue_pushable_dl_task(rq, p);\n}\n\n#ifdef config_smp\n\n\n#define dl_max_tries 3\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, tsk_cpus_allowed(p)))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic struct task_struct *pick_next_earliest_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.rb_leftmost;\n\tstruct sched_dl_entity *dl_se;\n\tstruct task_struct *p = null;\n\nnext_node:\n\tnext_node = rb_next(next_node);\n\tif (next_node) {\n\t\tdl_se = rb_entry(next_node, struct sched_dl_entity, rb_node);\n\t\tp = dl_task_of(dl_se);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tgoto next_node;\n\t}\n\n\treturn null;\n}\n\nstatic define_per_cpu(cpumask_var_t, local_cpu_mask_dl);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint best_cpu, cpu = task_cpu(task);\n\n\t\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t\n\tbest_cpu = cpudl_find(&task_rq(task)->rd->cpudl,\n\t\t\ttask, later_mask);\n\tif (best_cpu == -1)\n\t\treturn -1;\n\n\t\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & sd_wake_affine) {\n\n\t\t\t\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (best_cpu < nr_cpu_ids &&\n\t\t\t    cpumask_test_cpu(best_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}\n\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = null;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < dl_max_tries; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\t\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu,\n\t\t\t\t                       &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = null;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = null;\n\t}\n\n\treturn later_rq;\n}\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn null;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tbug_on(rq->cpu != task_cpu(p));\n\tbug_on(task_current(rq, p));\n\tbug_on(p->nr_cpus_allowed <= 1);\n\n\tbug_on(!task_on_rq_queued(p));\n\tbug_on(!dl_task(p));\n\n\treturn p;\n}\n\n\nstatic int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\tif (unlikely(next_task == rq->curr)) {\n\t\twarn_on(1);\n\t\treturn 0;\n\t}\n\n\t\n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\t\n\tget_task_struct(next_task);\n\n\t\n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t\n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task_cpu(next_task) == rq->cpu && task == next_task) {\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t\n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tset_task_cpu(next_task, later_rq->cpu);\n\tactivate_task(later_rq, next_task, 0);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t\n\twhile (push_dl_task(rq))\n\t\t;\n}\n\nstatic int pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, ret = 0, cpu;\n\tstruct task_struct *p;\n\tstruct rq *src_rq;\n\tu64 dmin = long_max;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn 0;\n\n\t\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_next_earliest_dl_task(src_rq, this_cpu);\n\n\t\t\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\twarn_on(p == src_rq->curr);\n\t\t\twarn_on(!task_on_rq_queued(p));\n\n\t\t\t\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tret = 1;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\treturn ret;\n}\n\nstatic void post_schedule_dl(struct rq *rq)\n{\n\tpush_dl_tasks(rq);\n}\n\n\nstatic void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_running(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    has_pushable_dl_tasks(rq) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}\n\nstatic void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tconst struct cpumask *new_mask)\n{\n\tstruct rq *rq;\n\tstruct root_domain *src_rd;\n\tint weight;\n\n\tbug_on(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t\n\tif (!cpumask_intersects(src_rd->span, new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t\n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_clear(src_dl_b, p->dl.dl_bw);\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\t\n\tif (!on_dl_rq(&p->dl))\n\t\treturn;\n\n\tweight = cpumask_weight(new_mask);\n\n\t\n\tif ((p->nr_cpus_allowed > 1) == (weight > 1))\n\t\treturn;\n\n\t\n\tif (weight <= 1) {\n\t\tif (!task_current(rq, p))\n\t\t\tdequeue_pushable_dl_task(rq, p);\n\t\tbug_on(!rq->dl.dl_nr_migratory);\n\t\trq->dl.dl_nr_migratory--;\n\t} else {\n\t\tif (!task_current(rq, p))\n\t\t\tenqueue_pushable_dl_task(rq, p);\n\t\trq->dl.dl_nr_migratory++;\n\t}\n\n\tupdate_dl_migration(&rq->dl);\n}\n\n\nstatic void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr, 1);\n}\n\n\nstatic void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_set(&rq->rd->cpudl, rq->cpu, 0, 0);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}\n\nvoid init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tgfp_kernel, cpu_to_node(i));\n}\n\n#endif \n\n\nstatic void cancel_dl_timer(struct rq *rq, struct task_struct *p)\n{\n\tstruct hrtimer *dl_timer = &p->dl.dl_timer;\n\n\t\n\tlockdep_assert_held(&p->pi_lock);\n\n\tif (hrtimer_active(dl_timer)) {\n\t\tint ret = hrtimer_try_to_cancel(dl_timer);\n\n\t\tif (unlikely(ret == -1)) {\n\t\t\t\n\t\t\traw_spin_unlock(&rq->lock);\n\t\t\thrtimer_cancel(dl_timer);\n\t\t\traw_spin_lock(&rq->lock);\n\t\t}\n\t}\n}\n\nstatic void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t\n\tcancel_dl_timer(rq, p);\n\t__dl_clear_params(p);\n\n\t\n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tif (pull_dl_task(rq))\n\t\tresched_curr(rq);\n}\n\n\nstatic void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tint check_resched = 1;\n\n\tif (task_on_rq_queued(p) && rq->curr != p) {\n#ifdef config_smp\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded &&\n\t\t\tpush_dl_task(rq) && rq != task_rq(p))\n\t\t\t\n\t\t\tcheck_resched = 0;\n#endif \n\t\tif (check_resched) {\n\t\t\tif (dl_task(rq->curr))\n\t\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\t\telse\n\t\t\t\tresched_curr(rq);\n\t\t}\n\t}\n}\n\n\nstatic void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (task_on_rq_queued(p) || rq->curr == p) {\n#ifdef config_smp\n\t\t\n\t\tif (!rq->dl.overloaded)\n\t\t\tpull_dl_task(rq);\n\n\t\t\n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline) &&\n\t\t    rq->curr == p)\n\t\t\tresched_curr(rq);\n#else\n\t\t\n\t\tresched_curr(rq);\n#endif \n\t} else\n\t\tswitched_to_dl(rq, p);\n}\n\nconst struct sched_class dl_sched_class = {\n\t.next\t\t\t= &rt_sched_class,\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\n#ifdef config_smp\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.post_schedule\t\t= post_schedule_dl,\n\t.task_woken\t\t= task_woken_dl,\n#endif\n\n\t.set_curr_task\t\t= set_curr_task_dl,\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\t.task_dead\t\t= task_dead_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\n#ifdef config_sched_debug\nextern void print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq);\n\nvoid print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}\n#endif \n\n\n#include <linux/latencytop.h>\n#include <linux/sched.h>\n#include <linux/cpumask.h>\n#include <linux/cpuidle.h>\n#include <linux/slab.h>\n#include <linux/profile.h>\n#include <linux/interrupt.h>\n#include <linux/mempolicy.h>\n#include <linux/migrate.h>\n#include <linux/task_work.h>\n\n#include <trace/events/sched.h>\n\n#include \"", "729": "\");\n\t\telse\n\t\t\tseq_puts(m, \"", "730": "\");\n\t\tftrace_set_regex(ops, func, strlen(func), 0, enable);\n\t}\n}\n\nstatic void __init set_ftrace_early_filters(void)\n{\n\tif (ftrace_filter_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_filter_buf, 1);\n\tif (ftrace_notrace_buf[0])\n\t\tftrace_set_early_filter(&global_ops, ftrace_notrace_buf, 0);\n#ifdef config_function_graph_tracer\n\tif (ftrace_graph_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_buf, 1);\n\tif (ftrace_graph_notrace_buf[0])\n\t\tset_ftrace_early_graph(ftrace_graph_notrace_buf, 0);\n#endif \n}\n\nint ftrace_regex_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = (struct seq_file *)file->private_data;\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct trace_parser *parser;\n\tint filter_hash;\n\tint ret;\n\n\tif (file->f_mode & fmode_read) {\n\t\titer = m->private;\n\t\tseq_release(inode, file);\n\t} else\n\t\titer = file->private_data;\n\n\tparser = &iter->parser;\n\tif (trace_parser_loaded(parser)) {\n\t\tparser->buffer[parser->idx] = 0;\n\t\tftrace_match_records(iter->hash, parser->buffer, parser->idx);\n\t}\n\n\ttrace_parser_put(parser);\n\n\tmutex_lock(&iter->ops->func_hash->regex_lock);\n\n\tif (file->f_mode & fmode_write) {\n\t\tfilter_hash = !!(iter->flags & ftrace_iter_filter);\n\n\t\tif (filter_hash)\n\t\t\torig_hash = &iter->ops->func_hash->filter_hash;\n\t\telse\n\t\t\torig_hash = &iter->ops->func_hash->notrace_hash;\n\n\t\tmutex_lock(&ftrace_lock);\n\t\told_hash = *orig_hash;\n\t\told_hash_ops.filter_hash = iter->ops->func_hash->filter_hash;\n\t\told_hash_ops.notrace_hash = iter->ops->func_hash->notrace_hash;\n\t\tret = ftrace_hash_move(iter->ops, filter_hash,\n\t\t\t\t       orig_hash, iter->hash);\n\t\tif (!ret) {\n\t\t\tftrace_ops_update_code(iter->ops, &old_hash_ops);\n\t\t\tfree_ftrace_hash_rcu(old_hash);\n\t\t}\n\t\tmutex_unlock(&ftrace_lock);\n\t}\n\n\tmutex_unlock(&iter->ops->func_hash->regex_lock);\n\tfree_ftrace_hash(iter->hash);\n\tkfree(iter);\n\n\treturn 0;\n}\n\nstatic const struct file_operations ftrace_avail_fops = {\n\t.open = ftrace_avail_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic const struct file_operations ftrace_enabled_fops = {\n\t.open = ftrace_enabled_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release_private,\n};\n\nstatic const struct file_operations ftrace_filter_fops = {\n\t.open = ftrace_filter_open,\n\t.read = seq_read,\n\t.write = ftrace_filter_write,\n\t.llseek = tracing_lseek,\n\t.release = ftrace_regex_release,\n};\n\nstatic const struct file_operations ftrace_notrace_fops = {\n\t.open = ftrace_notrace_open,\n\t.read = seq_read,\n\t.write = ftrace_notrace_write,\n\t.llseek = tracing_lseek,\n\t.release = ftrace_regex_release,\n};\n\n#ifdef config_function_graph_tracer\n\nstatic define_mutex(graph_lock);\n\nint ftrace_graph_count;\nint ftrace_graph_notrace_count;\nunsigned long ftrace_graph_funcs[ftrace_graph_max_funcs] __read_mostly;\nunsigned long ftrace_graph_notrace_funcs[ftrace_graph_max_funcs] __read_mostly;\n\nstruct ftrace_graph_data {\n\tunsigned long *table;\n\tsize_t size;\n\tint *count;\n\tconst struct seq_operations *seq_ops;\n};\n\nstatic void *\n__g_next(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tif (*pos >= *fgd->count)\n\t\treturn null;\n\treturn &fgd->table[*pos];\n}\n\nstatic void *\ng_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn __g_next(m, pos);\n}\n\nstatic void *g_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct ftrace_graph_data *fgd = m->private;\n\n\tmutex_lock(&graph_lock);\n\n\t\n\tif (!*fgd->count && !*pos)\n\t\treturn (void *)1;\n\n\treturn __g_next(m, pos);\n}\n\nstatic void g_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&graph_lock);\n}\n\nstatic int g_show(struct seq_file *m, void *v)\n{\n\tunsigned long *ptr = v;\n\n\tif (!ptr)\n\t\treturn 0;\n\n\tif (ptr == (unsigned long *)1) {\n\t\tstruct ftrace_graph_data *fgd = m->private;\n\n\t\tif (fgd->table == ftrace_graph_funcs)\n\t\t\tseq_puts(m, \"", "731": "\");\n\t\tgoto failed;\n\t}\n\n\tpr_info(\"", "732": "\");\n\t\tgoto platform_early_resume;\n\t}\n\terror = platform_suspend_prepare_noirq(state);\n\tif (error)\n\t\tgoto platform_wake;\n\n\tif (suspend_test(test_platform))\n\t\tgoto platform_wake;\n\n\t\n\tif (state == pm_suspend_freeze) {\n\t\ttrace_suspend_resume(tps(\"", "733": "\");\n\t\tgoto platform_finish;\n\t}\n\terror = platform_suspend_prepare_late(state);\n\tif (error)\n\t\tgoto devices_early_resume;\n\n\terror = dpm_suspend_noirq(pmsg_suspend);\n\tif (error) {\n\t\tprintk(kern_err \"", "734": "\");\n\t\tgoto recover_platform;\n\t}\n\tsuspend_test_finish(\"", "735": "\");\n\t\tif (moreprompt == null)\n\t\t\tmoreprompt = \"", "736": "\");\n\t\tif (rec->flags & ftrace_fl_tramp_en) {\n\t\t\tops = ftrace_find_tramp_ops_any(rec);\n\t\t\tif (ops)\n\t\t\t\tseq_printf(m, \"", "737": "\");\n\t\titer.cpu_file = ring_buffer_all_cpus;\n\t}\n\n\tprintk(kern_trace \"", "738": "\");\n\t\tkdb_defcmd2(\"", "739": "\");\n\t\tprint_name_offset(m, (unsigned long)entry->expire_func);\n\t\tseq_puts(m, \"", "740": "\");\n\t\tprint_name_offset(m, dev->set_mode);\n\t\tseq_printf(m, \"", "741": "\");\n\t\tprint_stack_trace(&entry->trace, 2);\n\t\tprintk(\"", "742": "\");\n\t\tprintk(\"", "743": "\");\n\t\treturn -enosys;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"", "744": "\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"", "745": "\");\n\t\treturn 0;\n\t}\n\n\trec = iter->func;\n\n\tif (!rec)\n\t\treturn 0;\n\n\tseq_printf(m, \"", "746": "\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"", "747": "\");\n\t\treturn boot_override_clocksource(\"", "748": "\");\n\t\treturn buffer;\n\tcase 4: \n\t\tif (cp < lastchar) {\n\t\t\tmemcpy(tmpbuffer, cp+1, lastchar - cp - 1);\n\t\t\tmemcpy(cp, tmpbuffer, lastchar - cp - 1);\n\t\t\t*(--lastchar) = '\\0';\n\t\t\tkdb_printf(\"", "749": "\");\n\t\treturn err_ptr(-enomem);\n\t}\n\n\treturn null;\n}\n\nextern struct trace_enum_map *__start_ftrace_enum_maps[];\nextern struct trace_enum_map *__stop_ftrace_enum_maps[];\n\nstatic void __init trace_enum_init(void)\n{\n\tint len;\n\n\tlen = __stop_ftrace_enum_maps - __start_ftrace_enum_maps;\n\ttrace_insert_enum_map(null, __start_ftrace_enum_maps, len);\n}\n\n#ifdef config_modules\nstatic void trace_module_add_enums(struct module *mod)\n{\n\tif (!mod->num_trace_enums)\n\t\treturn;\n\n\t\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn;\n\n\ttrace_insert_enum_map(mod, mod->trace_enums, mod->num_trace_enums);\n}\n\n#ifdef config_trace_enum_map_file\nstatic void trace_module_remove_enums(struct module *mod)\n{\n\tunion trace_enum_map_item *map;\n\tunion trace_enum_map_item **last = &trace_enum_maps;\n\n\tif (!mod->num_trace_enums)\n\t\treturn;\n\n\tmutex_lock(&trace_enum_mutex);\n\n\tmap = trace_enum_maps;\n\n\twhile (map) {\n\t\tif (map->head.mod == mod)\n\t\t\tbreak;\n\t\tmap = trace_enum_jmp_to_tail(map);\n\t\tlast = &map->tail.next;\n\t\tmap = map->tail.next;\n\t}\n\tif (!map)\n\t\tgoto out;\n\n\t*last = trace_enum_jmp_to_tail(map)->tail.next;\n\tkfree(map);\n out:\n\tmutex_unlock(&trace_enum_mutex);\n}\n#else\nstatic inline void trace_module_remove_enums(struct module *mod) { }\n#endif \n\nstatic int trace_module_notify(struct notifier_block *self,\n\t\t\t       unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tswitch (val) {\n\tcase module_state_coming:\n\t\ttrace_module_add_enums(mod);\n\t\tbreak;\n\tcase module_state_going:\n\t\ttrace_module_remove_enums(mod);\n\t\tbreak;\n\t}\n\n\treturn 0;\n}\n\nstatic struct notifier_block trace_module_nb = {\n\t.notifier_call = trace_module_notify,\n\t.priority = 0,\n};\n#endif \n\nstatic __init int tracer_init_tracefs(void)\n{\n\tstruct dentry *d_tracer;\n\n\ttrace_access_lock_init();\n\n\td_tracer = tracing_init_dentry();\n\tif (is_err(d_tracer))\n\t\treturn 0;\n\n\tinit_tracer_tracefs(&global_trace, d_tracer);\n\n\ttrace_create_file(\"", "750": "\");\n\t\treturn kdb_badreg;\n\t}\n\treturn 0;\n}\n\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t\n\tif (!kdb_check_flags(kdb_enable_mem_read | kdb_enable_flow_ctrl,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn kdb_noperm;\n\n\t\n\n\tif (*nextarg > argc)\n\t\treturn kdb_argcount;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t\n\tcp = strpbrk(symname, \"", "751": "\");\n\t\treturn null;\n\t}\n\n\treturn tr->options;\n}\n\nstatic void\ncreate_trace_option_file(struct trace_array *tr,\n\t\t\t struct trace_option_dentry *topt,\n\t\t\t struct tracer_flags *flags,\n\t\t\t struct tracer_opt *opt)\n{\n\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn;\n\n\ttopt->flags = flags;\n\ttopt->opt = opt;\n\ttopt->tr = tr;\n\n\ttopt->entry = trace_create_file(opt->name, 0644, t_options, topt,\n\t\t\t\t    &trace_options_fops);\n\n}\n\nstatic struct trace_option_dentry *\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer)\n{\n\tstruct trace_option_dentry *topts;\n\tstruct tracer_flags *flags;\n\tstruct tracer_opt *opts;\n\tint cnt;\n\n\tif (!tracer)\n\t\treturn null;\n\n\tflags = tracer->flags;\n\n\tif (!flags || !flags->opts)\n\t\treturn null;\n\n\topts = flags->opts;\n\n\tfor (cnt = 0; opts[cnt].name; cnt++)\n\t\t;\n\n\ttopts = kcalloc(cnt + 1, sizeof(*topts), gfp_kernel);\n\tif (!topts)\n\t\treturn null;\n\n\tfor (cnt = 0; opts[cnt].name; cnt++)\n\t\tcreate_trace_option_file(tr, &topts[cnt], flags,\n\t\t\t\t\t &opts[cnt]);\n\n\treturn topts;\n}\n\nstatic void\ndestroy_trace_option_files(struct trace_option_dentry *topts)\n{\n\tint cnt;\n\n\tif (!topts)\n\t\treturn;\n\n\tfor (cnt = 0; topts[cnt].opt; cnt++)\n\t\ttracefs_remove(topts[cnt].entry);\n\n\tkfree(topts);\n}\n\nstatic struct dentry *\ncreate_trace_option_core_file(struct trace_array *tr,\n\t\t\t      const char *option, long index)\n{\n\tstruct dentry *t_options;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn null;\n\n\treturn trace_create_file(option, 0644, t_options, (void *)index,\n\t\t\t\t    &trace_options_core_fops);\n}\n\nstatic __init void create_trace_options_dir(struct trace_array *tr)\n{\n\tstruct dentry *t_options;\n\tint i;\n\n\tt_options = trace_options_init_dentry(tr);\n\tif (!t_options)\n\t\treturn;\n\n\tfor (i = 0; trace_options[i]; i++)\n\t\tcreate_trace_option_core_file(tr, trace_options[i], i);\n}\n\nstatic ssize_t\nrb_simple_read(struct file *filp, char __user *ubuf,\n\t       size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r;\n\n\tr = tracer_tracing_is_on(tr);\n\tr = sprintf(buf, \"", "752": "\");\n\t\treturn;\n\t}\n\tseq_printf(m, \"", "753": "\");\n\t\treturn;\n\t}\n\n\tif (pid > pid_max_default) {\n\t\tstrcpy(comm, \"", "754": "\");\n\t\treturn;\n\t}\n\n\tmap = savedcmd->map_pid_to_cmdline[pid];\n\tif (map != no_cmdline_map)\n\t\tstrcpy(comm, get_saved_cmdlines(map));\n\telse\n\t\tstrcpy(comm, \"", "755": "\");\n\t\treturn;\n\t}\n\n\tmutex_lock(&trace_enum_mutex);\n\n\tif (!trace_enum_maps)\n\t\ttrace_enum_maps = map_array;\n\telse {\n\t\tptr = trace_enum_maps;\n\t\tfor (;;) {\n\t\t\tptr = trace_enum_jmp_to_tail(ptr);\n\t\t\tif (!ptr->tail.next)\n\t\t\t\tbreak;\n\t\t\tptr = ptr->tail.next;\n\n\t\t}\n\t\tptr->tail.next = map_array;\n\t}\n\tmap_array->head.mod = mod;\n\tmap_array->head.length = len;\n\tmap_array++;\n\n\tfor (map = start; (unsigned long)map < (unsigned long)stop; map++) {\n\t\tmap_array->map = **map;\n\t\tmap_array++;\n\t}\n\tmemset(map_array, 0, sizeof(*map_array));\n\n\tmutex_unlock(&trace_enum_mutex);\n}\n\nstatic void trace_create_enum_file(struct dentry *d_tracer)\n{\n\ttrace_create_file(\"", "756": "\");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_end, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"", "757": "\");\n\t\tseq_print_ip_sym(&iter->seq, data->critical_start, sym_flags);\n\t\ttrace_print_seq(m, &iter->seq);\n\t\tseq_puts(m, \"", "758": "\");\n\t\tseq_print_ip_sym(s, *p, flags);\n\t\ttrace_seq_putc(s, '\\n');\n\t}\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_stack_funcs = {\n\t.trace\t\t= trace_stack_print,\n};\n\nstatic struct trace_event trace_stack_event = {\n\t.type\t\t= trace_stack,\n\t.funcs\t\t= &trace_stack_funcs,\n};\n\n\nstatic enum print_line_t trace_user_stack_print(struct trace_iterator *iter,\n\t\t\t\t\t\tint flags, struct trace_event *event)\n{\n\tstruct userstack_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_puts(s, \"", "759": "\");\n\t\tstrncpy(buf + 4, str, sizeof(buf) - 5);\n\t} else {\n\t\tstrncpy(buf, str, sizeof(buf) - 1);\n\t}\n\tbuf[sizeof(buf) - 1] = 0;\n\toptions = strchr(str, ',');\n\tif (options)\n\t\t*(options++) = 0;\n#ifdef __sparc__\n\tif (!strcmp(str, \"", "760": "\");\n\t\ttrace_set_options(&global_trace, option);\n\t}\n\n\tregister_snapshot_cmd();\n\n\treturn 0;\n\nout_free_savedcmd:\n\tfree_saved_cmdlines_buffer(savedcmd);\nout_free_temp_buffer:\n\tring_buffer_free(temp_buffer);\nout_free_cpumask:\n\tfree_cpumask_var(global_trace.tracing_cpumask);\nout_free_buffer_mask:\n\tfree_cpumask_var(tracing_buffer_mask);\nout:\n\treturn ret;\n}\n\nvoid __init trace_init(void)\n{\n\tif (tracepoint_printk) {\n\t\ttracepoint_print_iter =\n\t\t\tkmalloc(sizeof(*tracepoint_print_iter), gfp_kernel);\n\t\tif (warn_on(!tracepoint_print_iter))\n\t\t\ttracepoint_printk = 0;\n\t}\n\ttracer_alloc_buffers();\n\ttrace_event_init();\n}\n\n__init static int clear_boot_tracer(void)\n{\n\t\n\tif (!default_bootup_tracer)\n\t\treturn 0;\n\n\tprintk(kern_info \"", "761": "\");\n\t\twarn_on(1);\n\t\tgoto out_free_savedcmd;\n\t}\n\n\tif (global_trace.buffer_disabled)\n\t\ttracing_off();\n\n\tif (trace_boot_clock) {\n\t\tret = tracing_set_clock(&global_trace, trace_boot_clock);\n\t\tif (ret < 0)\n\t\t\tpr_warning(\"", "762": "\");\n\t\t}\n\t\tkdb_input_flush();\n\t}\n\n\t\n\tif (kdb_grepping_flag && !suspend_grep) {\n\t\t*cphold = replaced_byte;\n\t\tstrcpy(kdb_buffer, cphold);\n\t\tlen = strlen(kdb_buffer);\n\t\tnext_avail = kdb_buffer + len;\n\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t}\n\nkdb_print_out:\n\tsuspend_grep = 0; \n\tif (logging)\n\t\tconsole_loglevel = saved_loglevel;\n\tif (kdb_state(printf_lock) && got_printf_lock) {\n\t\tgot_printf_lock = 0;\n\t\tspin_unlock_irqrestore(&kdb_printf_lock, flags);\n\t\tkdb_state_clear(printf_lock);\n\t\tatomic_dec(&kdb_event);\n\t} else {\n\t\t__release(kdb_printf_lock);\n\t}\n\tkdb_trap_printk = saved_trap_printk;\n\tpreempt_enable();\n\treturn retlen;\n}\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(kdb_msgsrc_internal, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}\nexport_symbol_gpl(kdb_printf);\n\n#include <linux/ftrace_event.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_clock.h>\n#include <linux/trace_seq.h>\n#include <linux/spinlock.h>\n#include <linux/irq_work.h>\n#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\t\n#include <linux/kmemcheck.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n\n#include <asm/local.h>\n\nstatic void update_pages_handler(struct work_struct *work);\n\n\nint ring_buffer_print_entry_header(struct trace_seq *s)\n{\n\ttrace_seq_puts(s, \"", "763": "\");\n\t\t}\n\t}\n\n\tseq_printf(m, \"", "764": "\");\n\t\t}\n\n\t\tif (dev->set_state_oneshot) {\n\t\t\tseq_printf(m, \"", "765": "\");\n\t\t}\n\n\t\tif (dev->set_state_periodic) {\n\t\t\tseq_printf(m, \"", "766": "\");\n\t\t}\n\n\t\tif (dev->tick_resume) {\n\t\t\tseq_printf(m, \"", "767": "\");\n\t\t} else if (buf1[0] == ' ') {\n\t\t\tkdb_printf(\"", "768": "\");\n\t\t} else if (kdb_grepping_flag) {\n\t\t\t\n\t\t\tsuspend_grep = 1; \n\t\t\tkdb_printf(\"", "769": "\");\n\t\n\twait_event(suspend_freeze_wait_head,\n\t\t   suspend_freeze_state == freeze_state_wake);\n\tpr_debug(\"", "770": "\");\n\t__print_lock_name(middle_class);\n\tprintk(\"", "771": "\");\n\t__print_lock_name(parent);\n\tprintk(\"", "772": "\");\n\t__print_lock_name(safe_class);\n\tprintk(\"", "773": "\");\n\t__print_lock_name(source);\n\tprintk(\"", "774": "\");\n\t__print_lock_name(target);\n\tprintk(\"", "775": "\");\n\t__print_lock_name(unsafe_class);\n\tprintk(\"", "776": "\");\n\tbug();\n}\nexport_symbol(__validate_process_creds);\n\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"", "777": "\");\n\tconsole_lock();\n\tconsole_suspended = 1;\n\tup_console_sem();\n}\n\nvoid resume_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tdown_console_sem();\n\tconsole_suspended = 0;\n\tconsole_unlock();\n}\n\n\nstatic int console_cpu_notify(struct notifier_block *self,\n\tunsigned long action, void *hcpu)\n{\n\tswitch (action) {\n\tcase cpu_online:\n\tcase cpu_dead:\n\tcase cpu_down_failed:\n\tcase cpu_up_canceled:\n\t\tconsole_lock();\n\t\tconsole_unlock();\n\t}\n\treturn notify_ok;\n}\n\n\nvoid console_lock(void)\n{\n\tmight_sleep();\n\n\tdown_console_sem();\n\tif (console_suspended)\n\t\treturn;\n\tconsole_locked = 1;\n\tconsole_may_schedule = 1;\n}\nexport_symbol(console_lock);\n\n\nint console_trylock(void)\n{\n\tif (down_trylock_console_sem())\n\t\treturn 0;\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\treturn 1;\n}\nexport_symbol(console_trylock);\n\nint is_console_locked(void)\n{\n\treturn console_locked;\n}\n\nstatic void console_cont_flush(char *text, size_t size)\n{\n\tunsigned long flags;\n\tsize_t len;\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\n\tif (!cont.len)\n\t\tgoto out;\n\n\t\n\tif (console_seq < log_next_seq && !cont.cons)\n\t\tgoto out;\n\n\tlen = cont_print_text(text, size);\n\traw_spin_unlock(&logbuf_lock);\n\tstop_critical_timings();\n\tcall_console_drivers(cont.level, text, len);\n\tstart_critical_timings();\n\tlocal_irq_restore(flags);\n\treturn;\nout:\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n}\n\n\nvoid console_unlock(void)\n{\n\tstatic char text[log_line_max + prefix_max];\n\tstatic u64 seen_seq;\n\tunsigned long flags;\n\tbool wake_klogd = false;\n\tbool retry;\n\n\tif (console_suspended) {\n\t\tup_console_sem();\n\t\treturn;\n\t}\n\n\tconsole_may_schedule = 0;\n\n\t\n\tconsole_cont_flush(text, sizeof(text));\nagain:\n\tfor (;;) {\n\t\tstruct printk_log *msg;\n\t\tsize_t len;\n\t\tint level;\n\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tif (seen_seq != log_next_seq) {\n\t\t\twake_klogd = true;\n\t\t\tseen_seq = log_next_seq;\n\t\t}\n\n\t\tif (console_seq < log_first_seq) {\n\t\t\tlen = sprintf(text, \"", "778": "\");\n\tdump_stack();\n\n\treturn 0;\n}\n\nstatic noinline int print_bfs_bug(int ret)\n{\n\tif (!debug_locks_off_graph_unlock())\n\t\treturn 0;\n\n\t\n\twarn(1, \"", "779": "\");\n\telse\n\t\tprintk(kern_trace \"", "780": "\");\n\telse\n\t\tseq_printf(m, \"", "781": "\");\n\telse\n\t\tseq_puts(m, \"", "782": "\");\n\tif (!save_trace(&prev_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(backwards_entry, prev_root);\n\n\tprintk(\"", "783": "\");\n\tif (!strcmp(str, \"", "784": "\");\n\tif (!strlen(mod))\n\t\treturn ret;\n\n\tret = ftrace_match_module_records(hash, func, mod);\n\tif (!ret)\n\t\tret = -einval;\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn 0;\n}\n\nstatic struct ftrace_func_command ftrace_mod_cmd = {\n\t.name\t\t\t= \"", "785": "\");\n\tif (!type)\n\t\treturn null;\n\tmnt = vfs_kern_mount(type, 0, \"", "786": "\");\n\tif (cp != null) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t\n\t\treturn kdb_notimp;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn kdb_invaddrfmt;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"", "787": "\");\n\tif (iter->cpu_file == ring_buffer_all_cpus)\n\t\tshow_snapshot_main_help(m);\n\telse\n\t\tshow_snapshot_percpu_help(m);\n}\n#else\n\nstatic inline void print_snapshot_help(struct seq_file *m, struct trace_iterator *iter) { }\n#endif\n\nstatic int s_show(struct seq_file *m, void *v)\n{\n\tstruct trace_iterator *iter = v;\n\tint ret;\n\n\tif (iter->ent == null) {\n\t\tif (iter->tr) {\n\t\t\tseq_printf(m, \"", "788": "\");\n\tif (suspend_test(test_devices))\n\t\tgoto recover_platform;\n\n\tdo {\n\t\terror = suspend_enter(state, &wakeup);\n\t} while (!error && !wakeup && platform_suspend_again(state));\n\n resume_devices:\n\tsuspend_test_start();\n\tdpm_resume_end(pmsg_resume);\n\tsuspend_test_finish(\"", "789": "\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"", "790": "\");\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(domain, &irq_domain_list, link) {\n\t\tint count = 0;\n\t\tradix_tree_for_each_slot(slot, &domain->revmap_tree, &iter, 0)\n\t\t\tcount++;\n\t\tseq_printf(m, \"", "791": "\");\n\tpr_warning(\"", "792": "\");\n\tprint_active_timers(m, base, now);\n}\n\nstatic void print_cpu(struct seq_file *m, int cpu, u64 now)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tseq_printf(m, \"", "793": "\");\n\tprint_circular_lock_scenario(check_src, check_tgt,\n\t\t\t\t     first_parent);\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"", "794": "\");\n\tprint_ip_sym((unsigned long)class->key);\n}\n\n\nstatic void __used\nprint_shortest_lock_dependencies(struct lock_list *leaf,\n\t\t\t\tstruct lock_list *root)\n{\n\tstruct lock_list *entry = leaf;\n\tint depth;\n\n\t\n\tdepth = get_lock_depth(leaf);\n\n\tdo {\n\t\tprint_lock_class_header(entry->class, depth);\n\t\tprintk(\"", "795": "\");\n\tprint_irq_lock_scenario(backwards_entry, forwards_entry,\n\t\t\t\thlock_class(prev), hlock_class(next));\n\n\tlockdep_print_held_locks(curr);\n\n\tprintk(\"", "796": "\");\n\tprint_kernel_ident();\n\tprintk(\"", "797": "\");\n\tprint_lock(check_tgt);\n\tprintk(\"", "798": "\");\n\tprint_lock(prev);\n\tprintk(\"", "799": "\");\n\tprint_lock_name(class);\n\tprintk(\"", "800": "\");\n\tprint_lock_name(hlock_class(next));\n\tprintk(\"", "801": "\");\n\tprint_lock_name(hlock_class(prev));\n\tprintk(\"", "802": "\");\n\tprint_name_offset(m, base->get_time);\n\tseq_printf(m,   \"", "803": "\");\n\tprint_name_offset(m, dev->event_handler);\n\tseq_printf(m, \"", "804": "\");\n\tprint_name_offset(m, dev->set_next_event);\n\tseq_printf(m, \"", "805": "\");\n\tprint_name_offset(m, timer->function);\n\tseq_printf(m, \"", "806": "\");\n\tprint_name_offset(m, timer->start_site);\n\tmemcpy(tmp, timer->start_comm, task_comm_len);\n\ttmp[task_comm_len] = 0;\n\tseq_printf(m, \"", "807": "\");\n\tprint_stack_trace(&target->trace, 6);\n\n\treturn 0;\n}\n\nstatic void\nprint_circular_lock_scenario(struct held_lock *src,\n\t\t\t     struct held_lock *tgt,\n\t\t\t     struct lock_list *prt)\n{\n\tstruct lock_class *source = hlock_class(src);\n\tstruct lock_class *target = hlock_class(tgt);\n\tstruct lock_class *parent = prt->class;\n\n\t\n\tif (parent != source) {\n\t\tprintk(\"", "808": "\");\n\tprintk(\"", "809": "\");\n\tprintk(kern_err \"", "810": "\");\n\treturn -enomem;\n}\n\nstatic int buffers_allocated;\n\nvoid trace_printk_init_buffers(void)\n{\n\tif (buffers_allocated)\n\t\treturn;\n\n\tif (alloc_percpu_trace_buffer())\n\t\treturn;\n\n\t\n\n\tpr_warning(\"", "811": "\");\n\treturn boot_override_clocksource(str);\n}\n\n__setup(\"", "812": "\");\n\tseq_print_userip_objs(field, s, flags);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_user_stack_funcs = {\n\t.trace\t\t= trace_user_stack_print,\n};\n\nstatic struct trace_event trace_user_stack_event = {\n\t.type\t\t= trace_user_stack,\n\t.funcs\t\t= &trace_user_stack_funcs,\n};\n\n\nstatic enum print_line_t\ntrace_bputs_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bputs_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \"", "813": "\");\n\tseq_printf(m, \"", "814": "\");\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic int tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < array_size(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == array_size(trace_clocks))\n\t\treturn -einval;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->trace_buffer.buffer, trace_clocks[i].func);\n\n\t\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n#ifdef config_tracer_max_trace\n\tif (tr->flags & trace_array_fl_global && tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic ssize_t tracing_clock_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t   size_t cnt, loff_t *fpos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tchar buf[64];\n\tconst char *clockstr;\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -einval;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -efault;\n\n\tbuf[cnt] = 0;\n\n\tclockstr = strstrip(buf);\n\n\tret = tracing_set_clock(tr, clockstr);\n\tif (ret)\n\t\treturn ret;\n\n\t*fpos += cnt;\n\n\treturn cnt;\n}\n\nstatic int tracing_clock_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr))\n\t\treturn -enodev;\n\n\tret = single_open(file, tracing_clock_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstruct ftrace_buffer_info {\n\tstruct trace_iterator\titer;\n\tvoid\t\t\t*spare;\n\tunsigned int\t\tread;\n};\n\n#ifdef config_tracer_snapshot\nstatic int tracing_snapshot_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tstruct seq_file *m;\n\tint ret = 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tif (file->f_mode & fmode_read) {\n\t\titer = __tracing_open(inode, file, true);\n\t\tif (is_err(iter))\n\t\t\tret = ptr_err(iter);\n\t} else {\n\t\t\n\t\tret = -enomem;\n\t\tm = kzalloc(sizeof(*m), gfp_kernel);\n\t\tif (!m)\n\t\t\tgoto out;\n\t\titer = kzalloc(sizeof(*iter), gfp_kernel);\n\t\tif (!iter) {\n\t\t\tkfree(m);\n\t\t\tgoto out;\n\t\t}\n\t\tret = 0;\n\n\t\titer->tr = tr;\n\t\titer->trace_buffer = &tr->max_buffer;\n\t\titer->cpu_file = tracing_get_cpu(inode);\n\t\tm->private = iter;\n\t\tfile->private_data = m;\n\t}\nout:\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_snapshot_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t       loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tunsigned long val;\n\tint ret;\n\n\tret = tracing_update_buffers();\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (tr->current_trace->use_max_tr) {\n\t\tret = -ebusy;\n\t\tgoto out;\n\t}\n\n\tswitch (val) {\n\tcase 0:\n\t\tif (iter->cpu_file != ring_buffer_all_cpus) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n\t\tif (tr->allocated_snapshot)\n\t\t\tfree_snapshot(tr);\n\t\tbreak;\n\tcase 1:\n\n#ifndef config_ring_buffer_allow_swap\n\t\tif (iter->cpu_file != ring_buffer_all_cpus) {\n\t\t\tret = -einval;\n\t\t\tbreak;\n\t\t}\n#endif\n\t\tif (!tr->allocated_snapshot) {\n\t\t\tret = alloc_snapshot(tr);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tlocal_irq_disable();\n\t\t\n\t\tif (iter->cpu_file == ring_buffer_all_cpus)\n\t\t\tupdate_max_tr(tr, current, smp_processor_id());\n\t\telse\n\t\t\tupdate_max_tr_single(tr, current, iter->cpu_file);\n\t\tlocal_irq_enable();\n\t\tbreak;\n\tdefault:\n\t\tif (tr->allocated_snapshot) {\n\t\t\tif (iter->cpu_file == ring_buffer_all_cpus)\n\t\t\t\ttracing_reset_online_cpus(&tr->max_buffer);\n\t\t\telse\n\t\t\t\ttracing_reset(&tr->max_buffer, iter->cpu_file);\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (ret >= 0) {\n\t\t*ppos += cnt;\n\t\tret = cnt;\n\t}\nout:\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}\n\nstatic int tracing_snapshot_release(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m = file->private_data;\n\tint ret;\n\n\tret = tracing_release(inode, file);\n\n\tif (file->f_mode & fmode_read)\n\t\treturn ret;\n\n\t\n\tif (m)\n\t\tkfree(m->private);\n\tkfree(m);\n\n\treturn 0;\n}\n\nstatic int tracing_buffers_open(struct inode *inode, struct file *filp);\nstatic ssize_t tracing_buffers_read(struct file *filp, char __user *ubuf,\n\t\t\t\t    size_t count, loff_t *ppos);\nstatic int tracing_buffers_release(struct inode *inode, struct file *file);\nstatic ssize_t tracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t   struct pipe_inode_info *pipe, size_t len, unsigned int flags);\n\nstatic int snapshot_raw_open(struct inode *inode, struct file *filp)\n{\n\tstruct ftrace_buffer_info *info;\n\tint ret;\n\n\tret = tracing_buffers_open(inode, filp);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tinfo = filp->private_data;\n\n\tif (info->iter.trace->use_max_tr) {\n\t\ttracing_buffers_release(inode, filp);\n\t\treturn -ebusy;\n\t}\n\n\tinfo->iter.snapshot = true;\n\tinfo->iter.trace_buffer = &info->iter.tr->max_buffer;\n\n\treturn ret;\n}\n\n#endif \n\n\nstatic const struct file_operations tracing_thresh_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_thresh_read,\n\t.write\t\t= tracing_thresh_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations tracing_max_lat_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_max_lat_read,\n\t.write\t\t= tracing_max_lat_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations set_tracer_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_set_trace_read,\n\t.write\t\t= tracing_set_trace_write,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic const struct file_operations tracing_pipe_fops = {\n\t.open\t\t= tracing_open_pipe,\n\t.poll\t\t= tracing_poll_pipe,\n\t.read\t\t= tracing_read_pipe,\n\t.splice_read\t= tracing_splice_read_pipe,\n\t.release\t= tracing_release_pipe,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic const struct file_operations tracing_entries_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_entries_read,\n\t.write\t\t= tracing_entries_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_total_entries_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_total_entries_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations tracing_free_buffer_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_free_buffer_write,\n\t.release\t= tracing_free_buffer_release,\n};\n\nstatic const struct file_operations tracing_mark_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.write\t\t= tracing_mark_write,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\nstatic const struct file_operations trace_clock_fops = {\n\t.open\t\t= tracing_clock_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n\t.write\t\t= tracing_clock_write,\n};\n\n#ifdef config_tracer_snapshot\nstatic const struct file_operations snapshot_fops = {\n\t.open\t\t= tracing_snapshot_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tracing_snapshot_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= tracing_snapshot_release,\n};\n\nstatic const struct file_operations snapshot_raw_fops = {\n\t.open\t\t= snapshot_raw_open,\n\t.read\t\t= tracing_buffers_read,\n\t.release\t= tracing_buffers_release,\n\t.splice_read\t= tracing_buffers_splice_read,\n\t.llseek\t\t= no_llseek,\n};\n\n#endif \n\nstatic int tracing_buffers_open(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct ftrace_buffer_info *info;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tinfo = kzalloc(sizeof(*info), gfp_kernel);\n\tif (!info) {\n\t\ttrace_array_put(tr);\n\t\treturn -enomem;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\tinfo->iter.tr\t\t= tr;\n\tinfo->iter.cpu_file\t= tracing_get_cpu(inode);\n\tinfo->iter.trace\t= tr->current_trace;\n\tinfo->iter.trace_buffer = &tr->trace_buffer;\n\tinfo->spare\t\t= null;\n\t\n\tinfo->read\t\t= (unsigned int)-1;\n\n\tfilp->private_data = info;\n\n\ttr->current_trace->ref++;\n\n\tmutex_unlock(&trace_types_lock);\n\n\tret = nonseekable_open(inode, filp);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic unsigned int\ntracing_buffers_poll(struct file *filp, poll_table *poll_table)\n{\n\tstruct ftrace_buffer_info *info = filp->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\n\treturn trace_poll(iter, filp, poll_table);\n}\n\nstatic ssize_t\ntracing_buffers_read(struct file *filp, char __user *ubuf,\n\t\t     size_t count, loff_t *ppos)\n{\n\tstruct ftrace_buffer_info *info = filp->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tssize_t ret;\n\tssize_t size;\n\n\tif (!count)\n\t\treturn 0;\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -ebusy;\n#endif\n\n\tif (!info->spare)\n\t\tinfo->spare = ring_buffer_alloc_read_page(iter->trace_buffer->buffer,\n\t\t\t\t\t\t\t  iter->cpu_file);\n\tif (!info->spare)\n\t\treturn -enomem;\n\n\t\n\tif (info->read < page_size)\n\t\tgoto read;\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tret = ring_buffer_read_page(iter->trace_buffer->buffer,\n\t\t\t\t    &info->spare,\n\t\t\t\t    count,\n\t\t\t\t    iter->cpu_file, 0);\n\ttrace_access_unlock(iter->cpu_file);\n\n\tif (ret < 0) {\n\t\tif (trace_empty(iter)) {\n\t\t\tif ((filp->f_flags & o_nonblock))\n\t\t\t\treturn -eagain;\n\n\t\t\tret = wait_on_pipe(iter, false);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\n\t\t\tgoto again;\n\t\t}\n\t\treturn 0;\n\t}\n\n\tinfo->read = 0;\n read:\n\tsize = page_size - info->read;\n\tif (size > count)\n\t\tsize = count;\n\n\tret = copy_to_user(ubuf, info->spare + info->read, size);\n\tif (ret == size)\n\t\treturn -efault;\n\n\tsize -= ret;\n\n\t*ppos += size;\n\tinfo->read += size;\n\n\treturn size;\n}\n\nstatic int tracing_buffers_release(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\n\tmutex_lock(&trace_types_lock);\n\n\titer->tr->current_trace->ref--;\n\n\t__trace_array_put(iter->tr);\n\n\tif (info->spare)\n\t\tring_buffer_free_read_page(iter->trace_buffer->buffer, info->spare);\n\tkfree(info);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstruct buffer_ref {\n\tstruct ring_buffer\t*buffer;\n\tvoid\t\t\t*page;\n\tint\t\t\tref;\n};\n\nstatic void buffer_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t    struct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tif (--ref->ref)\n\t\treturn;\n\n\tring_buffer_free_read_page(ref->buffer, ref->page);\n\tkfree(ref);\n\tbuf->private = 0;\n}\n\nstatic void buffer_pipe_buf_get(struct pipe_inode_info *pipe,\n\t\t\t\tstruct pipe_buffer *buf)\n{\n\tstruct buffer_ref *ref = (struct buffer_ref *)buf->private;\n\n\tref->ref++;\n}\n\n\nstatic const struct pipe_buf_operations buffer_pipe_buf_ops = {\n\t.can_merge\t\t= 0,\n\t.confirm\t\t= generic_pipe_buf_confirm,\n\t.release\t\t= buffer_pipe_buf_release,\n\t.steal\t\t\t= generic_pipe_buf_steal,\n\t.get\t\t\t= buffer_pipe_buf_get,\n};\n\n\nstatic void buffer_spd_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n\tstruct buffer_ref *ref =\n\t\t(struct buffer_ref *)spd->partial[i].private;\n\n\tif (--ref->ref)\n\t\treturn;\n\n\tring_buffer_free_read_page(ref->buffer, ref->page);\n\tkfree(ref);\n\tspd->partial[i].private = 0;\n}\n\nstatic ssize_t\ntracing_buffers_splice_read(struct file *file, loff_t *ppos,\n\t\t\t    struct pipe_inode_info *pipe, size_t len,\n\t\t\t    unsigned int flags)\n{\n\tstruct ftrace_buffer_info *info = file->private_data;\n\tstruct trace_iterator *iter = &info->iter;\n\tstruct partial_page partial_def[pipe_def_buffers];\n\tstruct page *pages_def[pipe_def_buffers];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages_max\t= pipe_def_buffers,\n\t\t.flags\t\t= flags,\n\t\t.ops\t\t= &buffer_pipe_buf_ops,\n\t\t.spd_release\t= buffer_spd_release,\n\t};\n\tstruct buffer_ref *ref;\n\tint entries, size, i;\n\tssize_t ret = 0;\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->tr->current_trace->use_max_tr)\n\t\treturn -ebusy;\n#endif\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -enomem;\n\n\tif (*ppos & (page_size - 1))\n\t\treturn -einval;\n\n\tif (len & (page_size - 1)) {\n\t\tif (len < page_size)\n\t\t\treturn -einval;\n\t\tlen &= page_mask;\n\t}\n\n again:\n\ttrace_access_lock(iter->cpu_file);\n\tentries = ring_buffer_entries_cpu(iter->trace_buffer->buffer, iter->cpu_file);\n\n\tfor (i = 0; i < spd.nr_pages_max && len && entries; i++, len -= page_size) {\n\t\tstruct page *page;\n\t\tint r;\n\n\t\tref = kzalloc(sizeof(*ref), gfp_kernel);\n\t\tif (!ref) {\n\t\t\tret = -enomem;\n\t\t\tbreak;\n\t\t}\n\n\t\tref->ref = 1;\n\t\tref->buffer = iter->trace_buffer->buffer;\n\t\tref->page = ring_buffer_alloc_read_page(ref->buffer, iter->cpu_file);\n\t\tif (!ref->page) {\n\t\t\tret = -enomem;\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\n\t\tr = ring_buffer_read_page(ref->buffer, &ref->page,\n\t\t\t\t\t  len, iter->cpu_file, 1);\n\t\tif (r < 0) {\n\t\t\tring_buffer_free_read_page(ref->buffer, ref->page);\n\t\t\tkfree(ref);\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tsize = ring_buffer_page_len(ref->page);\n\t\tif (size < page_size)\n\t\t\tmemset(ref->page + size, 0, page_size - size);\n\n\t\tpage = virt_to_page(ref->page);\n\n\t\tspd.pages[i] = page;\n\t\tspd.partial[i].len = page_size;\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].private = (unsigned long)ref;\n\t\tspd.nr_pages++;\n\t\t*ppos += page_size;\n\n\t\tentries = ring_buffer_entries_cpu(iter->trace_buffer->buffer, iter->cpu_file);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\tspd.nr_pages = i;\n\n\t\n\tif (!spd.nr_pages) {\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tif ((file->f_flags & o_nonblock) || (flags & splice_f_nonblock))\n\t\t\treturn -eagain;\n\n\t\tret = wait_on_pipe(iter, true);\n\t\tif (ret)\n\t\t\treturn ret;\n\n\t\tgoto again;\n\t}\n\n\tret = splice_to_pipe(pipe, &spd);\n\tsplice_shrink_spd(&spd);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_buffers_fops = {\n\t.open\t\t= tracing_buffers_open,\n\t.read\t\t= tracing_buffers_read,\n\t.poll\t\t= tracing_buffers_poll,\n\t.release\t= tracing_buffers_release,\n\t.splice_read\t= tracing_buffers_splice_read,\n\t.llseek\t\t= no_llseek,\n};\n\nstatic ssize_t\ntracing_stats_read(struct file *filp, char __user *ubuf,\n\t\t   size_t count, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_buffer *trace_buf = &tr->trace_buffer;\n\tint cpu = tracing_get_cpu(inode);\n\tstruct trace_seq *s;\n\tunsigned long cnt;\n\tunsigned long long t;\n\tunsigned long usec_rem;\n\n\ts = kmalloc(sizeof(*s), gfp_kernel);\n\tif (!s)\n\t\treturn -enomem;\n\n\ttrace_seq_init(s);\n\n\tcnt = ring_buffer_entries_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"", "815": "\");\n\tsuspend_finish();\n unlock:\n\tmutex_unlock(&pm_mutex);\n\treturn error;\n}\n\n\nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= pm_suspend_on || state >= pm_suspend_max)\n\t\treturn -einval;\n\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\treturn error;\n}\nexport_symbol(pm_suspend);\n\n\n\n\n#include <linux/time.h>\n#include <linux/module.h>\n\n\nstatic int __isleap(long year)\n{\n\treturn (year) % 4 == 0 && ((year) % 100 != 0 || (year) % 400 == 0);\n}\n\n\nstatic long math_div(long a, long b)\n{\n\treturn a / b - (a % b < 0);\n}\n\n\nstatic long leaps_between(long y1, long y2)\n{\n\tlong leaps1 = math_div(y1 - 1, 4) - math_div(y1 - 1, 100)\n\t\t+ math_div(y1 - 1, 400);\n\tlong leaps2 = math_div(y2 - 1, 4) - math_div(y2 - 1, 100)\n\t\t+ math_div(y2 - 1, 400);\n\treturn leaps2 - leaps1;\n}\n\n\nstatic const unsigned short __mon_yday[2][13] = {\n\t\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\n#define secs_per_hour\t(60 * 60)\n#define secs_per_day\t(secs_per_hour * 24)\n\n\nvoid time_to_tm(time_t totalsecs, int offset, struct tm *result)\n{\n\tlong days, rem, y;\n\tconst unsigned short *ip;\n\n\tdays = totalsecs / secs_per_day;\n\trem = totalsecs % secs_per_day;\n\trem += offset;\n\twhile (rem < 0) {\n\t\trem += secs_per_day;\n\t\t--days;\n\t}\n\twhile (rem >= secs_per_day) {\n\t\trem -= secs_per_day;\n\t\t++days;\n\t}\n\n\tresult->tm_hour = rem / secs_per_hour;\n\trem %= secs_per_hour;\n\tresult->tm_min = rem / 60;\n\tresult->tm_sec = rem % 60;\n\n\t\n\tresult->tm_wday = (4 + days) % 7;\n\tif (result->tm_wday < 0)\n\t\tresult->tm_wday += 7;\n\n\ty = 1970;\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\t\n\t\tlong yg = y + math_div(days, 365);\n\n\t\t\n\t\tdays -= (yg - y) * 365 + leaps_between(y, yg);\n\t\ty = yg;\n\t}\n\n\tresult->tm_year = y - 1900;\n\n\tresult->tm_yday = days;\n\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < ip[y]; y--)\n\t\tcontinue;\n\tdays -= ip[y];\n\n\tresult->tm_mon = y;\n\tresult->tm_mday = days + 1;\n}\nexport_symbol(time_to_tm);\n#ifndef _linux_cpupri_h\n#define _linux_cpupri_h\n\n#include <linux/sched.h>\n\n#define cpupri_nr_priorities\t(max_rt_prio + 2)\n\n#define cpupri_invalid -1\n#define cpupri_idle     0\n#define cpupri_normal   1\n\n\nstruct cpupri_vec {\n\tatomic_t\tcount;\n\tcpumask_var_t\tmask;\n};\n\nstruct cpupri {\n\tstruct cpupri_vec pri_to_cpu[cpupri_nr_priorities];\n\tint *cpu_to_pri;\n};\n\n#ifdef config_smp\nint  cpupri_find(struct cpupri *cp,\n\t\t struct task_struct *p, struct cpumask *lowest_mask);\nvoid cpupri_set(struct cpupri *cp, int cpu, int pri);\nint cpupri_init(struct cpupri *cp);\nvoid cpupri_cleanup(struct cpupri *cp);\n#endif\n\n#endif \n#include \"", "816": "\");\n\tsys_sync();\n\tprintk(\"", "817": "\");\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\n\nstatic enum print_line_t\ntrace_bprint_raw(struct trace_iterator *iter, int flags,\n\t\t struct trace_event *event)\n{\n\tstruct bprint_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"", "818": "\");\n\ttrace_seq_putc(s, '\\n');\n\ttrace_seq_printf(s, \"", "819": "\");\n\ttrace_seq_puts(s, \"", "820": "\");\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\n\nstatic enum print_line_t\ntrace_bputs_raw(struct trace_iterator *iter, int flags,\n\t\tstruct trace_event *event)\n{\n\tstruct bputs_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(s, \"", "821": "\");\n\ttrace_suspend_resume(tps(\"", "822": "\");\n\twarn(!perf_wq, \"", "823": "\");\n\t}\n\tif (argc == 0) {\n\t\tint i;\n\t\tfor (s = defcmd_set; s < defcmd_set + defcmd_set_count; ++s) {\n\t\t\tkdb_printf(\"", "824": "\");\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\n\tseq_printf(m, \"", "825": "\");\n\t}\n\tprintk(\"", "826": "\");\n\t}\n\n\t\n\n\twhile (!trace_empty(&iter)) {\n\n\t\tif (!cnt)\n\t\t\tprintk(kern_trace \"", "827": "\");\n\t}\n\n\tprintk(\"", "828": "\");\n\t}\n\n\tseq_puts(m, \"", "829": "\");\n\t} else\n\t\tr = sprintf(buf, \"", "830": "\");\n\t} else {\n\t\tif (dev->set_state_shutdown) {\n\t\t\tseq_printf(m, \"", "831": "\");\n\n\t\t\tdata = irq_desc_get_chip_data(desc);\n\t\t\tseq_printf(m, data ? \"", "832": "\");\n\n\t\tcnt++;\n\n\t\t\n\t\tmemset(&iter.seq, 0,\n\t\t       sizeof(struct trace_iterator) -\n\t\t       offsetof(struct trace_iterator, seq));\n\t\titer.iter_flags |= trace_file_lat_fmt;\n\t\titer.pos = -1;\n\n\t\tif (trace_find_next_entry_inc(&iter) != null) {\n\t\t\tint ret;\n\n\t\t\tret = print_trace_line(&iter);\n\t\t\tif (ret != trace_type_no_consume)\n\t\t\t\ttrace_consume(&iter);\n\t\t}\n\t\ttouch_nmi_watchdog();\n\n\t\ttrace_printk_seq(&iter.seq);\n\t}\n\n\tif (!cnt)\n\t\tprintk(kern_trace \"", "833": "\");\n\n\t\tevents += entry->count;\n\t}\n\n\tms += period.tv_sec * 1000;\n\tif (!ms)\n\t\tms = 1;\n\n\tif (events && period.tv_sec)\n\t\tseq_printf(m, \"", "834": "\");\n\n\t\tif (depth == 0 && (entry != root)) {\n\t\t\tprintk(\"", "835": "\");\n\n\t\t}\n\t\tadd_trampoline_func(m, ops, rec);\n\t}\t\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}\n\nstatic const struct seq_operations show_ftrace_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.stop = t_stop,\n\t.show = t_show,\n};\n\nstatic int\nftrace_avail_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (iter) {\n\t\titer->pg = ftrace_pages_start;\n\t\titer->ops = &global_ops;\n\t}\n\n\treturn iter ? 0 : -enomem;\n}\n\nstatic int\nftrace_enabled_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\n\titer = __seq_open_private(file, &show_ftrace_seq_ops, sizeof(*iter));\n\tif (iter) {\n\t\titer->pg = ftrace_pages_start;\n\t\titer->flags = ftrace_iter_enabled;\n\t\titer->ops = &global_ops;\n\t}\n\n\treturn iter ? 0 : -enomem;\n}\n\n\nint\nftrace_regex_open(struct ftrace_ops *ops, int flag,\n\t\t  struct inode *inode, struct file *file)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct ftrace_hash *hash;\n\tint ret = 0;\n\n\tftrace_ops_init(ops);\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\titer = kzalloc(sizeof(*iter), gfp_kernel);\n\tif (!iter)\n\t\treturn -enomem;\n\n\tif (trace_parser_get_init(&iter->parser, ftrace_buff_max)) {\n\t\tkfree(iter);\n\t\treturn -enomem;\n\t}\n\n\titer->ops = ops;\n\titer->flags = flag;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (flag & ftrace_iter_notrace)\n\t\thash = ops->func_hash->notrace_hash;\n\telse\n\t\thash = ops->func_hash->filter_hash;\n\n\tif (file->f_mode & fmode_write) {\n\t\tconst int size_bits = ftrace_hash_default_bits;\n\n\t\tif (file->f_flags & o_trunc)\n\t\t\titer->hash = alloc_ftrace_hash(size_bits);\n\t\telse\n\t\t\titer->hash = alloc_and_copy_ftrace_hash(size_bits, hash);\n\n\t\tif (!iter->hash) {\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t\tret = -enomem;\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n\n\tif (file->f_mode & fmode_read) {\n\t\titer->pg = ftrace_pages_start;\n\n\t\tret = seq_open(file, &show_ftrace_seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = iter;\n\t\t} else {\n\t\t\t\n\t\t\tfree_ftrace_hash(iter->hash);\n\t\t\ttrace_parser_put(&iter->parser);\n\t\t\tkfree(iter);\n\t\t}\n\t} else\n\t\tfile->private_data = iter;\n\n out_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\treturn ret;\n}\n\nstatic int\nftrace_filter_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops,\n\t\t\tftrace_iter_filter | ftrace_iter_do_hash,\n\t\t\tinode, file);\n}\n\nstatic int\nftrace_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_ops *ops = inode->i_private;\n\n\treturn ftrace_regex_open(ops, ftrace_iter_notrace,\n\t\t\t\t inode, file);\n}\n\nstatic int ftrace_match(char *str, char *regex, int len, int type)\n{\n\tint matched = 0;\n\tint slen;\n\n\tswitch (type) {\n\tcase match_full:\n\t\tif (strcmp(str, regex) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase match_front_only:\n\t\tif (strncmp(str, regex, len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase match_middle_only:\n\t\tif (strstr(str, regex))\n\t\t\tmatched = 1;\n\t\tbreak;\n\tcase match_end_only:\n\t\tslen = strlen(str);\n\t\tif (slen >= len && memcmp(str + slen - len, regex, len) == 0)\n\t\t\tmatched = 1;\n\t\tbreak;\n\t}\n\n\treturn matched;\n}\n\nstatic int\nenter_record(struct ftrace_hash *hash, struct dyn_ftrace *rec, int not)\n{\n\tstruct ftrace_func_entry *entry;\n\tint ret = 0;\n\n\tentry = ftrace_lookup_ip(hash, rec->ip);\n\tif (not) {\n\t\t\n\t\tif (!entry)\n\t\t\treturn 0;\n\n\t\tfree_hash_entry(hash, entry);\n\t} else {\n\t\t\n\t\tif (entry)\n\t\t\treturn 0;\n\n\t\tret = add_hash_entry(hash, rec->ip);\n\t}\n\treturn ret;\n}\n\nstatic int\nftrace_match_record(struct dyn_ftrace *rec, char *mod,\n\t\t    char *regex, int len, int type)\n{\n\tchar str[ksym_symbol_len];\n\tchar *modname;\n\n\tkallsyms_lookup(rec->ip, null, null, &modname, str);\n\n\tif (mod) {\n\t\t\n\t\tif (!modname || strcmp(modname, mod))\n\t\t\treturn 0;\n\n\t\t\n\t\tif (!len)\n\t\t\treturn 1;\n\t}\n\n\treturn ftrace_match(str, regex, len, type);\n}\n\nstatic int\nmatch_records(struct ftrace_hash *hash, char *buff,\n\t      int len, char *mod, int not)\n{\n\tunsigned search_len = 0;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tint type = match_full;\n\tchar *search = buff;\n\tint found = 0;\n\tint ret;\n\n\tif (len) {\n\t\ttype = filter_parse_regex(buff, len, &search, &not);\n\t\tsearch_len = strlen(search);\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled))\n\t\tgoto out_unlock;\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\t\tif (ftrace_match_record(rec, mod, search, search_len, type)) {\n\t\t\tret = enter_record(hash, rec, not);\n\t\t\tif (ret < 0) {\n\t\t\t\tfound = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t\tfound = 1;\n\t\t}\n\t} while_for_each_ftrace_rec();\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn found;\n}\n\nstatic int\nftrace_match_records(struct ftrace_hash *hash, char *buff, int len)\n{\n\treturn match_records(hash, buff, len, null, 0);\n}\n\nstatic int\nftrace_match_module_records(struct ftrace_hash *hash, char *buff, char *mod)\n{\n\tint not = 0;\n\n\t\n\tif (strcmp(buff, \"", "836": "\");\n\n\t\n\tif (ftrace_is_dead()) {\n\t\tprintk(\"", "837": "\");\n\n\t\n\tretrigger_next_event(null);\n\t\n\tclock_was_set_delayed();\n}\n\nstatic inline void timer_stats_hrtimer_set_start_info(struct hrtimer *timer)\n{\n#ifdef config_timer_stats\n\tif (timer->start_site)\n\t\treturn;\n\ttimer->start_site = __builtin_return_address(0);\n\tmemcpy(timer->start_comm, current->comm, task_comm_len);\n\ttimer->start_pid = current->pid;\n#endif\n}\n\nstatic inline void timer_stats_hrtimer_clear_start_info(struct hrtimer *timer)\n{\n#ifdef config_timer_stats\n\ttimer->start_site = null;\n#endif\n}\n\nstatic inline void timer_stats_account_hrtimer(struct hrtimer *timer)\n{\n#ifdef config_timer_stats\n\tif (likely(!timer_stats_active))\n\t\treturn;\n\ttimer_stats_update_stats(timer, timer->start_pid, timer->start_site,\n\t\t\t\t timer->function, timer->start_comm, 0);\n#endif\n}\n\n\nstatic inline\nvoid unlock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)\n{\n\traw_spin_unlock_irqrestore(&timer->base->cpu_base->lock, *flags);\n}\n\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta.tv64 < 0)\n\t\treturn 0;\n\n\tif (interval.tv64 < timer->base->resolution.tv64)\n\t\tinterval.tv64 = timer->base->resolution.tv64;\n\n\tif (unlikely(delta.tv64 >= interval.tv64)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now.tv64)\n\t\t\treturn orun;\n\t\t\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}\nexport_symbol_gpl(hrtimer_forward);\n\n\nstatic int enqueue_hrtimer(struct hrtimer *timer,\n\t\t\t   struct hrtimer_clock_base *base)\n{\n\tdebug_activate(timer);\n\n\ttimerqueue_add(&base->active, &timer->node);\n\tbase->cpu_base->active_bases |= 1 << base->index;\n\n\t\n\ttimer->state |= hrtimer_state_enqueued;\n\n\treturn (&timer->node == base->active.next);\n}\n\n\nstatic void __remove_hrtimer(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base,\n\t\t\t     unsigned long newstate, int reprogram)\n{\n\tstruct timerqueue_node *next_timer;\n\tif (!(timer->state & hrtimer_state_enqueued))\n\t\tgoto out;\n\n\tnext_timer = timerqueue_getnext(&base->active);\n\ttimerqueue_del(&base->active, &timer->node);\n\tif (&timer->node == next_timer) {\n#ifdef config_high_res_timers\n\t\t\n\t\tif (reprogram && hrtimer_hres_active()) {\n\t\t\tktime_t expires;\n\n\t\t\texpires = ktime_sub(hrtimer_get_expires(timer),\n\t\t\t\t\t    base->offset);\n\t\t\tif (base->cpu_base->expires_next.tv64 == expires.tv64)\n\t\t\t\thrtimer_force_reprogram(base->cpu_base, 1);\n\t\t}\n#endif\n\t}\n\tif (!timerqueue_getnext(&base->active))\n\t\tbase->cpu_base->active_bases &= ~(1 << base->index);\nout:\n\ttimer->state = newstate;\n}\n\n\nstatic inline int\nremove_hrtimer(struct hrtimer *timer, struct hrtimer_clock_base *base)\n{\n\tif (hrtimer_is_queued(timer)) {\n\t\tunsigned long state;\n\t\tint reprogram;\n\n\t\t\n\t\tdebug_deactivate(timer);\n\t\ttimer_stats_hrtimer_clear_start_info(timer);\n\t\treprogram = base->cpu_base == this_cpu_ptr(&hrtimer_bases);\n\t\t\n\t\tstate = timer->state & hrtimer_state_callback;\n\t\t__remove_hrtimer(timer, base, state, reprogram);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint __hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\tunsigned long delta_ns, const enum hrtimer_mode mode,\n\t\tint wakeup)\n{\n\tstruct hrtimer_clock_base *base, *new_base;\n\tunsigned long flags;\n\tint ret, leftmost;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\t\n\tret = remove_hrtimer(timer, base);\n\n\tif (mode & hrtimer_mode_rel) {\n\t\ttim = ktime_add_safe(tim, base->get_time());\n\t\t\n#ifdef config_time_low_res\n\t\ttim = ktime_add_safe(tim, base->resolution);\n#endif\n\t}\n\n\thrtimer_set_expires_range_ns(timer, tim, delta_ns);\n\n\t\n\tnew_base = switch_hrtimer_base(timer, base, mode & hrtimer_mode_pinned);\n\n\ttimer_stats_hrtimer_set_start_info(timer);\n\n\tleftmost = enqueue_hrtimer(timer, new_base);\n\n\tif (!leftmost) {\n\t\tunlock_hrtimer_base(timer, &flags);\n\t\treturn ret;\n\t}\n\n\tif (!hrtimer_is_hres_active(timer)) {\n\t\t\n\t\twake_up_nohz_cpu(new_base->cpu_base->cpu);\n\t} else if (new_base->cpu_base == this_cpu_ptr(&hrtimer_bases) &&\n\t\t\thrtimer_reprogram(timer, new_base)) {\n\t\t\n\t\tif (wakeup) {\n\t\t\t\n\t\t\traw_spin_unlock(&new_base->cpu_base->lock);\n\t\t\traise_softirq_irqoff(hrtimer_softirq);\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn ret;\n\t\t} else {\n\t\t\t__raise_softirq_irqoff(hrtimer_softirq);\n\t\t}\n\t}\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n}\nexport_symbol_gpl(__hrtimer_start_range_ns);\n\n\nint hrtimer_start_range_ns(struct hrtimer *timer, ktime_t tim,\n\t\tunsigned long delta_ns, const enum hrtimer_mode mode)\n{\n\treturn __hrtimer_start_range_ns(timer, tim, delta_ns, mode, 1);\n}\nexport_symbol_gpl(hrtimer_start_range_ns);\n\n\nint\nhrtimer_start(struct hrtimer *timer, ktime_t tim, const enum hrtimer_mode mode)\n{\n\treturn __hrtimer_start_range_ns(timer, tim, 0, mode, 1);\n}\nexport_symbol_gpl(hrtimer_start);\n\n\n\nint hrtimer_try_to_cancel(struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\tbase = lock_hrtimer_base(timer, &flags);\n\n\tif (!hrtimer_callback_running(timer))\n\t\tret = remove_hrtimer(timer, base);\n\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn ret;\n\n}\nexport_symbol_gpl(hrtimer_try_to_cancel);\n\n\nint hrtimer_cancel(struct hrtimer *timer)\n{\n\tfor (;;) {\n\t\tint ret = hrtimer_try_to_cancel(timer);\n\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}\nexport_symbol_gpl(hrtimer_cancel);\n\n\nktime_t hrtimer_get_remaining(const struct hrtimer *timer)\n{\n\tunsigned long flags;\n\tktime_t rem;\n\n\tlock_hrtimer_base(timer, &flags);\n\trem = hrtimer_expires_remaining(timer);\n\tunlock_hrtimer_base(timer, &flags);\n\n\treturn rem;\n}\nexport_symbol_gpl(hrtimer_get_remaining);\n\n#ifdef config_no_hz_common\n\nktime_t hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t mindelta = { .tv64 = ktime_max };\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!hrtimer_hres_active())\n\t\tmindelta = ktime_sub(__hrtimer_get_next_event(cpu_base),\n\t\t\t\t     ktime_get());\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\tif (mindelta.tv64 < 0)\n\t\tmindelta.tv64 = 0;\n\treturn mindelta;\n}\n#endif\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base;\n\n\tmemset(timer, 0, sizeof(struct hrtimer));\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\n\tif (clock_id == clock_realtime && mode != hrtimer_mode_abs)\n\t\tclock_id = clock_monotonic;\n\n\tbase = hrtimer_clockid_to_base(clock_id);\n\ttimer->base = &cpu_base->clock_base[base];\n\ttimerqueue_init(&timer->node);\n\n#ifdef config_timer_stats\n\ttimer->start_site = null;\n\ttimer->start_pid = -1;\n\tmemset(timer->start_comm, 0, task_comm_len);\n#endif\n}\n\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}\nexport_symbol_gpl(hrtimer_init);\n\n\nint hrtimer_get_res(const clockid_t which_clock, struct timespec *tp)\n{\n\tstruct hrtimer_cpu_base *cpu_base;\n\tint base = hrtimer_clockid_to_base(which_clock);\n\n\tcpu_base = raw_cpu_ptr(&hrtimer_bases);\n\t*tp = ktime_to_timespec(cpu_base->clock_base[base].resolution);\n\n\treturn 0;\n}\nexport_symbol_gpl(hrtimer_get_res);\n\nstatic void __run_hrtimer(struct hrtimer *timer, ktime_t *now)\n{\n\tstruct hrtimer_clock_base *base = timer->base;\n\tstruct hrtimer_cpu_base *cpu_base = base->cpu_base;\n\tenum hrtimer_restart (*fn)(struct hrtimer *);\n\tint restart;\n\n\twarn_on(!irqs_disabled());\n\n\tdebug_deactivate(timer);\n\t__remove_hrtimer(timer, base, hrtimer_state_callback, 0);\n\ttimer_stats_account_hrtimer(timer);\n\tfn = timer->function;\n\n\t\n\traw_spin_unlock(&cpu_base->lock);\n\ttrace_hrtimer_expire_entry(timer, now);\n\trestart = fn(timer);\n\ttrace_hrtimer_expire_exit(timer);\n\traw_spin_lock(&cpu_base->lock);\n\n\t\n\tif (restart != hrtimer_norestart) {\n\t\tbug_on(timer->state != hrtimer_state_callback);\n\t\tenqueue_hrtimer(timer, base);\n\t}\n\n\twarn_on_once(!(timer->state & hrtimer_state_callback));\n\n\ttimer->state &= ~hrtimer_state_callback;\n}\n\n#ifdef config_high_res_timers\n\n\nvoid hrtimer_interrupt(struct clock_event_device *dev)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires_next, now, entry_time, delta;\n\tint i, retries = 0;\n\n\tbug_on(!cpu_base->hres_active);\n\tcpu_base->nr_events++;\n\tdev->next_event.tv64 = ktime_max;\n\n\traw_spin_lock(&cpu_base->lock);\n\tentry_time = now = hrtimer_update_base(cpu_base);\nretry:\n\tcpu_base->in_hrtirq = 1;\n\t\n\tcpu_base->expires_next.tv64 = ktime_max;\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tstruct hrtimer_clock_base *base;\n\t\tstruct timerqueue_node *node;\n\t\tktime_t basenow;\n\n\t\tif (!(cpu_base->active_bases & (1 << i)))\n\t\t\tcontinue;\n\n\t\tbase = cpu_base->clock_base + i;\n\t\tbasenow = ktime_add(now, base->offset);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\n\t\t\t\n\t\t\tif (basenow.tv64 < hrtimer_get_softexpires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(timer, &basenow);\n\t\t}\n\t}\n\t\n\texpires_next = __hrtimer_get_next_event(cpu_base);\n\t\n\tcpu_base->expires_next = expires_next;\n\tcpu_base->in_hrtirq = 0;\n\traw_spin_unlock(&cpu_base->lock);\n\n\t\n\tif (expires_next.tv64 == ktime_max ||\n\t    !tick_program_event(expires_next, 0)) {\n\t\tcpu_base->hang_detected = 0;\n\t\treturn;\n\t}\n\n\t\n\traw_spin_lock(&cpu_base->lock);\n\tnow = hrtimer_update_base(cpu_base);\n\tcpu_base->nr_retries++;\n\tif (++retries < 3)\n\t\tgoto retry;\n\t\n\tcpu_base->nr_hangs++;\n\tcpu_base->hang_detected = 1;\n\traw_spin_unlock(&cpu_base->lock);\n\tdelta = ktime_sub(now, entry_time);\n\tif (delta.tv64 > cpu_base->max_hang_time.tv64)\n\t\tcpu_base->max_hang_time = delta;\n\t\n\tif (delta.tv64 > 100 * nsec_per_msec)\n\t\texpires_next = ktime_add_ns(now, 100 * nsec_per_msec);\n\telse\n\t\texpires_next = ktime_add(now, delta);\n\ttick_program_event(expires_next, 1);\n\tprintk_once(kern_warning \"", "838": "\");\n\n\t\n\tset_fs(user_ds);\n\n\tptrace_event(ptrace_event_exit, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t\n\tif (unlikely(tsk->flags & pf_exiting)) {\n\t\tpr_alert(\"", "839": "\");\n\n\t\n\ttracing_update_buffers();\n\n\tbuffers_allocated = 1;\n\n\t\n\tif (global_trace.trace_buffer.buffer)\n\t\ttracing_start_cmdline_record();\n}\n\nvoid trace_printk_start_comm(void)\n{\n\t\n\tif (!buffers_allocated)\n\t\treturn;\n\ttracing_start_cmdline_record();\n}\n\nstatic void trace_printk_start_stop_comm(int enabled)\n{\n\tif (!buffers_allocated)\n\t\treturn;\n\n\tif (enabled)\n\t\ttracing_start_cmdline_record();\n\telse\n\t\ttracing_stop_cmdline_record();\n}\n\n\nint trace_vbprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct ftrace_event_call *call = &event_bprint;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct trace_array *tr = &global_trace;\n\tstruct bprint_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\tint len = 0, size, pc;\n\n\tif (unlikely(tracing_selftest_running || tracing_disabled))\n\t\treturn 0;\n\n\t\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out;\n\t}\n\n\tlen = vbin_printf((u32 *)tbuffer, trace_buf_size/sizeof(int), fmt, args);\n\n\tif (len > trace_buf_size/sizeof(int) || len < 0)\n\t\tgoto out;\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + sizeof(u32) * len;\n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, trace_bprint, size,\n\t\t\t\t\t  flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->fmt\t\t\t= fmt;\n\n\tmemcpy(entry->buf, tbuffer, sizeof(u32) * len);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(buffer, flags, 6, pc);\n\t}\n\nout:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\nexport_symbol_gpl(trace_vbprintk);\n\nstatic int\n__trace_array_vprintk(struct ring_buffer *buffer,\n\t\t      unsigned long ip, const char *fmt, va_list args)\n{\n\tstruct ftrace_event_call *call = &event_print;\n\tstruct ring_buffer_event *event;\n\tint len = 0, size, pc;\n\tstruct print_entry *entry;\n\tunsigned long flags;\n\tchar *tbuffer;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn 0;\n\n\t\n\tpause_graph_tracing();\n\n\tpc = preempt_count();\n\tpreempt_disable_notrace();\n\n\n\ttbuffer = get_trace_buf();\n\tif (!tbuffer) {\n\t\tlen = 0;\n\t\tgoto out;\n\t}\n\n\tlen = vscnprintf(tbuffer, trace_buf_size, fmt, args);\n\n\tlocal_save_flags(flags);\n\tsize = sizeof(*entry) + len + 1;\n\tevent = trace_buffer_lock_reserve(buffer, trace_print, size,\n\t\t\t\t\t  flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = ip;\n\n\tmemcpy(&entry->buf, tbuffer, len + 1);\n\tif (!call_filter_check_discard(call, entry, buffer, event)) {\n\t\t__buffer_unlock_commit(buffer, event);\n\t\tftrace_trace_stack(buffer, flags, 6, pc);\n\t}\n out:\n\tpreempt_enable_notrace();\n\tunpause_graph_tracing();\n\n\treturn len;\n}\n\nint trace_array_vprintk(struct trace_array *tr,\n\t\t\tunsigned long ip, const char *fmt, va_list args)\n{\n\treturn __trace_array_vprintk(tr->trace_buffer.buffer, ip, fmt, args);\n}\n\nint trace_array_printk(struct trace_array *tr,\n\t\t       unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(trace_flags & trace_iter_printk))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = trace_array_vprintk(tr, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nint trace_array_printk_buf(struct ring_buffer *buffer,\n\t\t\t   unsigned long ip, const char *fmt, ...)\n{\n\tint ret;\n\tva_list ap;\n\n\tif (!(trace_flags & trace_iter_printk))\n\t\treturn 0;\n\n\tva_start(ap, fmt);\n\tret = __trace_array_vprintk(buffer, ip, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\nint trace_vprintk(unsigned long ip, const char *fmt, va_list args)\n{\n\treturn trace_array_vprintk(&global_trace, ip, fmt, args);\n}\nexport_symbol_gpl(trace_vprintk);\n\nstatic void trace_iterator_increment(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, iter->cpu);\n\n\titer->idx++;\n\tif (buf_iter)\n\t\tring_buffer_read(buf_iter, null);\n}\n\nstatic struct trace_entry *\npeek_next_entry(struct trace_iterator *iter, int cpu, u64 *ts,\n\t\tunsigned long *lost_events)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_iter *buf_iter = trace_buffer_iter(iter, cpu);\n\n\tif (buf_iter)\n\t\tevent = ring_buffer_iter_peek(buf_iter, ts);\n\telse\n\t\tevent = ring_buffer_peek(iter->trace_buffer->buffer, cpu, ts,\n\t\t\t\t\t lost_events);\n\n\tif (event) {\n\t\titer->ent_size = ring_buffer_event_length(event);\n\t\treturn ring_buffer_event_data(event);\n\t}\n\titer->ent_size = 0;\n\treturn null;\n}\n\nstatic struct trace_entry *\n__find_next_entry(struct trace_iterator *iter, int *ent_cpu,\n\t\t  unsigned long *missing_events, u64 *ent_ts)\n{\n\tstruct ring_buffer *buffer = iter->trace_buffer->buffer;\n\tstruct trace_entry *ent, *next = null;\n\tunsigned long lost_events = 0, next_lost = 0;\n\tint cpu_file = iter->cpu_file;\n\tu64 next_ts = 0, ts;\n\tint next_cpu = -1;\n\tint next_size = 0;\n\tint cpu;\n\n\t\n\tif (cpu_file > ring_buffer_all_cpus) {\n\t\tif (ring_buffer_empty_cpu(buffer, cpu_file))\n\t\t\treturn null;\n\t\tent = peek_next_entry(iter, cpu_file, ent_ts, missing_events);\n\t\tif (ent_cpu)\n\t\t\t*ent_cpu = cpu_file;\n\n\t\treturn ent;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\n\t\tif (ring_buffer_empty_cpu(buffer, cpu))\n\t\t\tcontinue;\n\n\t\tent = peek_next_entry(iter, cpu, &ts, &lost_events);\n\n\t\t\n\t\tif (ent && (!next || ts < next_ts)) {\n\t\t\tnext = ent;\n\t\t\tnext_cpu = cpu;\n\t\t\tnext_ts = ts;\n\t\t\tnext_lost = lost_events;\n\t\t\tnext_size = iter->ent_size;\n\t\t}\n\t}\n\n\titer->ent_size = next_size;\n\n\tif (ent_cpu)\n\t\t*ent_cpu = next_cpu;\n\n\tif (ent_ts)\n\t\t*ent_ts = next_ts;\n\n\tif (missing_events)\n\t\t*missing_events = next_lost;\n\n\treturn next;\n}\n\n\nstruct trace_entry *trace_find_next_entry(struct trace_iterator *iter,\n\t\t\t\t\t  int *ent_cpu, u64 *ent_ts)\n{\n\treturn __find_next_entry(iter, ent_cpu, null, ent_ts);\n}\n\n\nvoid *trace_find_next_entry_inc(struct trace_iterator *iter)\n{\n\titer->ent = __find_next_entry(iter, &iter->cpu,\n\t\t\t\t      &iter->lost_events, &iter->ts);\n\n\tif (iter->ent)\n\t\ttrace_iterator_increment(iter);\n\n\treturn iter->ent ? iter : null;\n}\n\nstatic void trace_consume(struct trace_iterator *iter)\n{\n\tring_buffer_consume(iter->trace_buffer->buffer, iter->cpu, &iter->ts,\n\t\t\t    &iter->lost_events);\n}\n\nstatic void *s_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tint i = (int)*pos;\n\tvoid *ent;\n\n\twarn_on_once(iter->leftover);\n\n\t(*pos)++;\n\n\t\n\tif (iter->idx > i)\n\t\treturn null;\n\n\tif (iter->idx < 0)\n\t\tent = trace_find_next_entry_inc(iter);\n\telse\n\t\tent = iter;\n\n\twhile (ent && iter->idx < i)\n\t\tent = trace_find_next_entry_inc(iter);\n\n\titer->pos = *pos;\n\n\treturn ent;\n}\n\nvoid tracing_iter_reset(struct trace_iterator *iter, int cpu)\n{\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer_iter *buf_iter;\n\tunsigned long entries = 0;\n\tu64 ts;\n\n\tper_cpu_ptr(iter->trace_buffer->data, cpu)->skipped_entries = 0;\n\n\tbuf_iter = trace_buffer_iter(iter, cpu);\n\tif (!buf_iter)\n\t\treturn;\n\n\tring_buffer_iter_reset(buf_iter);\n\n\t\n\twhile ((event = ring_buffer_iter_peek(buf_iter, &ts))) {\n\t\tif (ts >= iter->trace_buffer->time_start)\n\t\t\tbreak;\n\t\tentries++;\n\t\tring_buffer_read(buf_iter, null);\n\t}\n\n\tper_cpu_ptr(iter->trace_buffer->data, cpu)->skipped_entries = entries;\n}\n\n\nstatic void *s_start(struct seq_file *m, loff_t *pos)\n{\n\tstruct trace_iterator *iter = m->private;\n\tstruct trace_array *tr = iter->tr;\n\tint cpu_file = iter->cpu_file;\n\tvoid *p = null;\n\tloff_t l = 0;\n\tint cpu;\n\n\t\n\tmutex_lock(&trace_types_lock);\n\tif (unlikely(tr->current_trace && iter->trace->name != tr->current_trace->name))\n\t\t*iter->trace = *tr->current_trace;\n\tmutex_unlock(&trace_types_lock);\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->trace->use_max_tr)\n\t\treturn err_ptr(-ebusy);\n#endif\n\n\tif (!iter->snapshot)\n\t\tatomic_inc(&trace_record_cmdline_disabled);\n\n\tif (*pos != iter->pos) {\n\t\titer->ent = null;\n\t\titer->cpu = 0;\n\t\titer->idx = -1;\n\n\t\tif (cpu_file == ring_buffer_all_cpus) {\n\t\t\tfor_each_tracing_cpu(cpu)\n\t\t\t\ttracing_iter_reset(iter, cpu);\n\t\t} else\n\t\t\ttracing_iter_reset(iter, cpu_file);\n\n\t\titer->leftover = 0;\n\t\tfor (p = iter; p && l < *pos; p = s_next(m, p, &l))\n\t\t\t;\n\n\t} else {\n\t\t\n\t\tif (iter->leftover)\n\t\t\tp = iter;\n\t\telse {\n\t\t\tl = *pos - 1;\n\t\t\tp = s_next(m, p, &l);\n\t\t}\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(cpu_file);\n\treturn p;\n}\n\nstatic void s_stop(struct seq_file *m, void *p)\n{\n\tstruct trace_iterator *iter = m->private;\n\n#ifdef config_tracer_max_trace\n\tif (iter->snapshot && iter->trace->use_max_tr)\n\t\treturn;\n#endif\n\n\tif (!iter->snapshot)\n\t\tatomic_dec(&trace_record_cmdline_disabled);\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n}\n\nstatic void\nget_total_entries(struct trace_buffer *buf,\n\t\t  unsigned long *total, unsigned long *entries)\n{\n\tunsigned long count;\n\tint cpu;\n\n\t*total = 0;\n\t*entries = 0;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tcount = ring_buffer_entries_cpu(buf->buffer, cpu);\n\t\t\n\t\tif (per_cpu_ptr(buf->data, cpu)->skipped_entries) {\n\t\t\tcount -= per_cpu_ptr(buf->data, cpu)->skipped_entries;\n\t\t\t\n\t\t\t*total += count;\n\t\t} else\n\t\t\t*total += count +\n\t\t\t\tring_buffer_overrun_cpu(buf->buffer, cpu);\n\t\t*entries += count;\n\t}\n}\n\nstatic void print_lat_help_header(struct seq_file *m)\n{\n\tseq_puts(m, \"", "840": "\");\n\n\tcpuidle_pause();\n\tput_online_cpus();\n\n\tspin_lock_irq(&suspend_freeze_lock);\n\n out:\n\tsuspend_freeze_state = freeze_state_none;\n\tspin_unlock_irq(&suspend_freeze_lock);\n}\n\nvoid freeze_wake(void)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&suspend_freeze_lock, flags);\n\tif (suspend_freeze_state > freeze_state_none) {\n\t\tsuspend_freeze_state = freeze_state_wake;\n\t\twake_up(&suspend_freeze_wait_head);\n\t}\n\tspin_unlock_irqrestore(&suspend_freeze_lock, flags);\n}\nexport_symbol_gpl(freeze_wake);\n\nstatic bool valid_state(suspend_state_t state)\n{\n\t\n\treturn suspend_ops && suspend_ops->valid && suspend_ops->valid(state);\n}\n\n\nstatic bool relative_states;\n\nstatic int __init sleep_states_setup(char *str)\n{\n\trelative_states = !strncmp(str, \"", "841": "\");\n\n\tfor (bit = 0; bit < lock_usage_states; bit++) {\n\t\tif (class->usage_mask & (1 << bit)) {\n\t\t\tint len = depth;\n\n\t\t\tlen += printk(\"", "842": "\");\n\n\tfor (i = 0; i < nr_entries; i++) {\n\t\tentry = entries + i;\n\t\tif (entry->timer_flag & timer_stats_flag_deferrable) {\n\t\t\tseq_printf(m, \"", "843": "\");\n\n\tfor (i = 1; i < nr_irqs; i++) {\n\t\tdesc = irq_to_desc(i);\n\t\tif (!desc)\n\t\t\tcontinue;\n\n\t\traw_spin_lock_irqsave(&desc->lock, flags);\n\t\tdomain = desc->irq_data.domain;\n\n\t\tif (domain) {\n\t\t\tstruct irq_chip *chip;\n\t\t\tint hwirq = desc->irq_data.hwirq;\n\t\t\tbool direct;\n\n\t\t\tseq_printf(m, \"", "844": "\");\n\n\tif (!next) {\n\t\tret = ftrace_match_records(hash, func, len);\n\t\tif (!ret)\n\t\t\tret = -einval;\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\treturn 0;\n\t}\n\n\t\n\n\tcommand = strsep(&next, \"", "845": "\");\n\n\tif (!strlen(number))\n\t\tgoto out_reg;\n\n\t\n\tret = kstrtoul(number, 0, (unsigned long *)&count);\n\tif (ret)\n\t\treturn ret;\n\n out_reg:\n\tret = register_ftrace_function_probe(glob, ops, count);\n\n\tif (ret >= 0)\n\t\talloc_snapshot(&global_trace);\n\n\treturn ret < 0 ? ret : 0;\n}\n\nstatic struct ftrace_func_command ftrace_snapshot_cmd = {\n\t.name\t\t\t= \"", "846": "\");\n\n\tif (count == -1)\n\t\tseq_puts(m, \"", "847": "\");\n\n\tif (data->critical_start) {\n\t\tseq_puts(m, \"", "848": "\");\n\n\tif (dev->set_mode) {\n\t\tseq_printf(m, \"", "849": "\");\n\n\tmutex_lock(&ftrace_cmd_mutex);\n\tlist_for_each_entry(p, &ftrace_commands, list) {\n\t\tif (strcmp(p->name, command) == 0) {\n\t\t\tret = p->func(hash, func, command, next, enable);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_cmd_mutex);\n\n\treturn ret;\n}\n\nstatic ssize_t\nftrace_regex_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos, int enable)\n{\n\tstruct ftrace_iterator *iter;\n\tstruct trace_parser *parser;\n\tssize_t ret, read;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (file->f_mode & fmode_read) {\n\t\tstruct seq_file *m = file->private_data;\n\t\titer = m->private;\n\t} else\n\t\titer = file->private_data;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\t\n\n\tparser = &iter->parser;\n\tread = trace_get_user(parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded(parser) &&\n\t    !trace_parser_cont(parser)) {\n\t\tret = ftrace_process_regex(iter->hash, parser->buffer,\n\t\t\t\t\t   parser->idx, enable);\n\t\ttrace_parser_clear(parser);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = read;\n out:\n\treturn ret;\n}\n\nssize_t\nftrace_filter_write(struct file *file, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 1);\n}\n\nssize_t\nftrace_notrace_write(struct file *file, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn ftrace_regex_write(file, ubuf, cnt, ppos, 0);\n}\n\nstatic int\nftrace_match_addr(struct ftrace_hash *hash, unsigned long ip, int remove)\n{\n\tstruct ftrace_func_entry *entry;\n\n\tif (!ftrace_location(ip))\n\t\treturn -einval;\n\n\tif (remove) {\n\t\tentry = ftrace_lookup_ip(hash, ip);\n\t\tif (!entry)\n\t\t\treturn -enoent;\n\t\tfree_hash_entry(hash, entry);\n\t\treturn 0;\n\t}\n\n\treturn add_hash_entry(hash, ip);\n}\n\nstatic void ftrace_ops_update_code(struct ftrace_ops *ops,\n\t\t\t\t   struct ftrace_ops_hash *old_hash)\n{\n\tstruct ftrace_ops *op;\n\n\tif (!ftrace_enabled)\n\t\treturn;\n\n\tif (ops->flags & ftrace_ops_fl_enabled) {\n\t\tftrace_run_modify_code(ops, ftrace_update_calls, old_hash);\n\t\treturn;\n\t}\n\n\t\n\tif (ops->func_hash != &global_ops.local_hash)\n\t\treturn;\n\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (op->func_hash == &global_ops.local_hash &&\n\t\t    op->flags & ftrace_ops_fl_enabled) {\n\t\t\tftrace_run_modify_code(op, ftrace_update_calls, old_hash);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t} while_for_each_ftrace_op(op);\n}\n\nstatic int\nftrace_set_hash(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\tunsigned long ip, int remove, int reset, int enable)\n{\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash;\n\tint ret;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\tmutex_lock(&ops->func_hash->regex_lock);\n\n\tif (enable)\n\t\torig_hash = &ops->func_hash->filter_hash;\n\telse\n\t\torig_hash = &ops->func_hash->notrace_hash;\n\n\tif (reset)\n\t\thash = alloc_ftrace_hash(ftrace_hash_default_bits);\n\telse\n\t\thash = alloc_and_copy_ftrace_hash(ftrace_hash_default_bits, *orig_hash);\n\n\tif (!hash) {\n\t\tret = -enomem;\n\t\tgoto out_regex_unlock;\n\t}\n\n\tif (buf && !ftrace_match_records(hash, buf, len)) {\n\t\tret = -einval;\n\t\tgoto out_regex_unlock;\n\t}\n\tif (ip) {\n\t\tret = ftrace_match_addr(hash, ip, remove);\n\t\tif (ret < 0)\n\t\t\tgoto out_regex_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\told_hash = *orig_hash;\n\told_hash_ops.filter_hash = ops->func_hash->filter_hash;\n\told_hash_ops.notrace_hash = ops->func_hash->notrace_hash;\n\tret = ftrace_hash_move(ops, enable, orig_hash, hash);\n\tif (!ret) {\n\t\tftrace_ops_update_code(ops, &old_hash_ops);\n\t\tfree_ftrace_hash_rcu(old_hash);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_regex_unlock:\n\tmutex_unlock(&ops->func_hash->regex_lock);\n\n\tfree_ftrace_hash(hash);\n\treturn ret;\n}\n\nstatic int\nftrace_set_addr(struct ftrace_ops *ops, unsigned long ip, int remove,\n\t\tint reset, int enable)\n{\n\treturn ftrace_set_hash(ops, 0, 0, ip, remove, reset, enable);\n}\n\n\nint ftrace_set_filter_ip(struct ftrace_ops *ops, unsigned long ip,\n\t\t\t int remove, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_addr(ops, ip, remove, reset, 1);\n}\nexport_symbol_gpl(ftrace_set_filter_ip);\n\nstatic int\nftrace_set_regex(struct ftrace_ops *ops, unsigned char *buf, int len,\n\t\t int reset, int enable)\n{\n\treturn ftrace_set_hash(ops, buf, len, 0, 0, reset, enable);\n}\n\n\nint ftrace_set_filter(struct ftrace_ops *ops, unsigned char *buf,\n\t\t       int len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 1);\n}\nexport_symbol_gpl(ftrace_set_filter);\n\n\nint ftrace_set_notrace(struct ftrace_ops *ops, unsigned char *buf,\n\t\t\tint len, int reset)\n{\n\tftrace_ops_init(ops);\n\treturn ftrace_set_regex(ops, buf, len, reset, 0);\n}\nexport_symbol_gpl(ftrace_set_notrace);\n\nvoid ftrace_set_global_filter(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 1);\n}\nexport_symbol_gpl(ftrace_set_global_filter);\n\n\nvoid ftrace_set_global_notrace(unsigned char *buf, int len, int reset)\n{\n\tftrace_set_regex(&global_ops, buf, len, reset, 0);\n}\nexport_symbol_gpl(ftrace_set_global_notrace);\n\n\n#define ftrace_filter_size\t\tcommand_line_size\nstatic char ftrace_notrace_buf[ftrace_filter_size] __initdata;\nstatic char ftrace_filter_buf[ftrace_filter_size] __initdata;\n\n\nbool ftrace_filter_param __initdata;\n\nstatic int __init set_ftrace_notrace(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_notrace_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"", "850": "\");\n\n\tprint_circular_bug_entry(entry, depth);\n\n\treturn 0;\n}\n\nstatic inline int class_equal(struct lock_list *entry, void *data)\n{\n\treturn entry->class == data;\n}\n\nstatic noinline int print_circular_bug(struct lock_list *this,\n\t\t\t\tstruct lock_list *target,\n\t\t\t\tstruct held_lock *check_src,\n\t\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\tstruct lock_list *parent;\n\tstruct lock_list *first_parent;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tif (!save_trace(&this->trace))\n\t\treturn 0;\n\n\tdepth = get_lock_depth(target);\n\n\tprint_circular_bug_header(target, depth, check_src, check_tgt);\n\n\tparent = get_lock_parent(target);\n\tfirst_parent = parent;\n\n\twhile (parent) {\n\t\tprint_circular_bug_entry(parent, --depth);\n\t\tparent = get_lock_parent(parent);\n\t}\n\n\tprintk(\"", "851": "\");\n\n\tprint_stack_trace(forwards_entry->class->usage_traces + bit2, 1);\n\n\tprintk(\"", "852": "\");\n\n\tprintk(\"", "853": "\");\n\n\treturn 0;\n}\n\nearly_param(\"", "854": "\");\n\n\treturn count;\n}\n\n\nstatic device_attr(current_clocksource, 0644, sysfs_show_current_clocksources,\n\t\t   sysfs_override_clocksource);\n\nstatic device_attr(unbind_clocksource, 0200, null, sysfs_unbind_clocksource);\n\nstatic device_attr(available_clocksource, 0444,\n\t\t   sysfs_show_available_clocksources, null);\n\nstatic struct bus_type clocksource_subsys = {\n\t.name = \"", "855": "\");\n\n\treturn ret;\n}\n__initcall(init_tracepoints);\n#endif \n\nstatic void for_each_tracepoint_range(struct tracepoint * const *begin,\n\t\tstruct tracepoint * const *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tstruct tracepoint * const *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(*iter, priv);\n}\n\n\nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}\nexport_symbol_gpl(for_each_kernel_tracepoint);\n\n#ifdef config_have_syscall_tracepoints\n\n\nstatic int sys_tracepoint_refcount;\n\nvoid syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_tsk_thread_flag(t, tif_syscall_tracepoint);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n}\n\nvoid syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_tsk_thread_flag(t, tif_syscall_tracepoint);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}\n#endif\n\n#include <linux/cred.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <asm/uaccess.h>\n\nstruct group_info *groups_alloc(int gidsetsize)\n{\n\tstruct group_info *group_info;\n\tint nblocks;\n\tint i;\n\n\tnblocks = (gidsetsize + ngroups_per_block - 1) / ngroups_per_block;\n\t\n\tnblocks = nblocks ? : 1;\n\tgroup_info = kmalloc(sizeof(*group_info) + nblocks*sizeof(gid_t *), gfp_user);\n\tif (!group_info)\n\t\treturn null;\n\tgroup_info->ngroups = gidsetsize;\n\tgroup_info->nblocks = nblocks;\n\tatomic_set(&group_info->usage, 1);\n\n\tif (gidsetsize <= ngroups_small)\n\t\tgroup_info->blocks[0] = group_info->small_block;\n\telse {\n\t\tfor (i = 0; i < nblocks; i++) {\n\t\t\tkgid_t *b;\n\t\t\tb = (void *)__get_free_page(gfp_user);\n\t\t\tif (!b)\n\t\t\t\tgoto out_undo_partial_alloc;\n\t\t\tgroup_info->blocks[i] = b;\n\t\t}\n\t}\n\treturn group_info;\n\nout_undo_partial_alloc:\n\twhile (--i >= 0) {\n\t\tfree_page((unsigned long)group_info->blocks[i]);\n\t}\n\tkfree(group_info);\n\treturn null;\n}\n\nexport_symbol(groups_alloc);\n\nvoid groups_free(struct group_info *group_info)\n{\n\tif (group_info->blocks[0] != group_info->small_block) {\n\t\tint i;\n\t\tfor (i = 0; i < group_info->nblocks; i++)\n\t\t\tfree_page((unsigned long)group_info->blocks[i]);\n\t}\n\tkfree(group_info);\n}\n\nexport_symbol(groups_free);\n\n\nstatic int groups_to_user(gid_t __user *grouplist,\n\t\t\t  const struct group_info *group_info)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tgid = from_kgid_munged(user_ns, group_at(group_info, i));\n\t\tif (put_user(gid, grouplist+i))\n\t\t\treturn -efault;\n\t}\n\treturn 0;\n}\n\n\nstatic int groups_from_user(struct group_info *group_info,\n    gid_t __user *grouplist)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tint i;\n\tunsigned int count = group_info->ngroups;\n\n\tfor (i = 0; i < count; i++) {\n\t\tgid_t gid;\n\t\tkgid_t kgid;\n\t\tif (get_user(gid, grouplist+i))\n\t\t\treturn -efault;\n\n\t\tkgid = make_kgid(user_ns, gid);\n\t\tif (!gid_valid(kgid))\n\t\t\treturn -einval;\n\n\t\tgroup_at(group_info, i) = kgid;\n\t}\n\treturn 0;\n}\n\n\nstatic void groups_sort(struct group_info *group_info)\n{\n\tint base, max, stride;\n\tint gidsetsize = group_info->ngroups;\n\n\tfor (stride = 1; stride < gidsetsize; stride = 3 * stride + 1)\n\t\t; \n\tstride /= 3;\n\n\twhile (stride) {\n\t\tmax = gidsetsize - stride;\n\t\tfor (base = 0; base < max; base++) {\n\t\t\tint left = base;\n\t\t\tint right = left + stride;\n\t\t\tkgid_t tmp = group_at(group_info, right);\n\n\t\t\twhile (left >= 0 && gid_gt(group_at(group_info, left), tmp)) {\n\t\t\t\tgroup_at(group_info, right) =\n\t\t\t\t    group_at(group_info, left);\n\t\t\t\tright = left;\n\t\t\t\tleft -= stride;\n\t\t\t}\n\t\t\tgroup_at(group_info, right) = tmp;\n\t\t}\n\t\tstride /= 3;\n\t}\n}\n\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_at(group_info, mid)))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_at(group_info, mid)))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nvoid set_groups(struct cred *new, struct group_info *group_info)\n{\n\tput_group_info(new->group_info);\n\tgroups_sort(group_info);\n\tget_group_info(group_info);\n\tnew->group_info = group_info;\n}\n\nexport_symbol(set_groups);\n\n\nint set_current_groups(struct group_info *group_info)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\n\tset_groups(new, group_info);\n\treturn commit_creds(new);\n}\n\nexport_symbol(set_current_groups);\n\nsyscall_define2(getgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif (gidsetsize < 0)\n\t\treturn -einval;\n\n\t\n\ti = cred->group_info->ngroups;\n\tif (gidsetsize) {\n\t\tif (i > gidsetsize) {\n\t\t\ti = -einval;\n\t\t\tgoto out;\n\t\t}\n\t\tif (groups_to_user(grouplist, cred->group_info)) {\n\t\t\ti = -efault;\n\t\t\tgoto out;\n\t\t}\n\t}\nout:\n\treturn i;\n}\n\nbool may_setgroups(void)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\n\treturn ns_capable(user_ns, cap_setgid) &&\n\t\tuserns_may_setgroups(user_ns);\n}\n\n\n\nsyscall_define2(setgroups, int, gidsetsize, gid_t __user *, grouplist)\n{\n\tstruct group_info *group_info;\n\tint retval;\n\n\tif (!may_setgroups())\n\t\treturn -eperm;\n\tif ((unsigned)gidsetsize > ngroups_max)\n\t\treturn -einval;\n\n\tgroup_info = groups_alloc(gidsetsize);\n\tif (!group_info)\n\t\treturn -enomem;\n\tretval = groups_from_user(group_info, grouplist);\n\tif (retval) {\n\t\tput_group_info(group_info);\n\t\treturn retval;\n\t}\n\n\tretval = set_current_groups(group_info);\n\tput_group_info(group_info);\n\n\treturn retval;\n}\n\n\nint in_group_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->fsgid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n\nexport_symbol(in_group_p);\n\nint in_egroup_p(kgid_t grp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval = 1;\n\n\tif (!gid_eq(grp, cred->egid))\n\t\tretval = groups_search(cred->group_info, grp);\n\treturn retval;\n}\n\nexport_symbol(in_egroup_p);\n\n\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#include \"", "856": "\");\n\n\tseq_puts(m, \"", "857": "\");\n\n\n\n\n#include <linux/irqflags.h>\n#include <linux/kallsyms.h>\n#include <linux/notifier.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n#include <linux/kernel.h>\n#include <linux/module.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/cpu.h>\n#include <linux/smp.h>\n\n#include <linux/hw_breakpoint.h>\n\nstruct bp_cpuinfo {\n\t\n\tunsigned int\tcpu_pinned;\n\t\n\tunsigned int\t*tsk_pinned;\n\t\n\tunsigned int\tflexible; \n};\n\nstatic define_per_cpu(struct bp_cpuinfo, bp_cpuinfo[type_max]);\nstatic int nr_slots[type_max];\n\nstatic struct bp_cpuinfo *get_bp_info(int cpu, enum bp_type_idx type)\n{\n\treturn per_cpu_ptr(bp_cpuinfo + type, cpu);\n}\n\n\nstatic list_head(bp_task_head);\n\nstatic int constraints_initialized;\n\n\nstruct bp_busy_slots {\n\tunsigned int pinned;\n\tunsigned int flexible;\n};\n\n\nstatic define_mutex(nr_bp_mutex);\n\n__weak int hw_breakpoint_weight(struct perf_event *bp)\n{\n\treturn 1;\n}\n\nstatic inline enum bp_type_idx find_slot_idx(struct perf_event *bp)\n{\n\tif (bp->attr.bp_type & hw_breakpoint_rw)\n\t\treturn type_data;\n\n\treturn type_inst;\n}\n\n\nstatic unsigned int max_task_bp_pinned(int cpu, enum bp_type_idx type)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint i;\n\n\tfor (i = nr_slots[type] - 1; i >= 0; i--) {\n\t\tif (tsk_pinned[i] > 0)\n\t\t\treturn i + 1;\n\t}\n\n\treturn 0;\n}\n\n\nstatic int task_bp_pinned(int cpu, struct perf_event *bp, enum bp_type_idx type)\n{\n\tstruct task_struct *tsk = bp->hw.target;\n\tstruct perf_event *iter;\n\tint count = 0;\n\n\tlist_for_each_entry(iter, &bp_task_head, hw.bp_list) {\n\t\tif (iter->hw.target == tsk &&\n\t\t    find_slot_idx(iter) == type &&\n\t\t    (iter->cpu < 0 || cpu == iter->cpu))\n\t\t\tcount += hw_breakpoint_weight(iter);\n\t}\n\n\treturn count;\n}\n\nstatic const struct cpumask *cpumask_of_bp(struct perf_event *bp)\n{\n\tif (bp->cpu >= 0)\n\t\treturn cpumask_of(bp->cpu);\n\treturn cpu_possible_mask;\n}\n\n\nstatic void\nfetch_bp_busy_slots(struct bp_busy_slots *slots, struct perf_event *bp,\n\t\t    enum bp_type_idx type)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tfor_each_cpu(cpu, cpumask) {\n\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, type);\n\t\tint nr;\n\n\t\tnr = info->cpu_pinned;\n\t\tif (!bp->hw.target)\n\t\t\tnr += max_task_bp_pinned(cpu, type);\n\t\telse\n\t\t\tnr += task_bp_pinned(cpu, bp, type);\n\n\t\tif (nr > slots->pinned)\n\t\t\tslots->pinned = nr;\n\n\t\tnr = info->flexible;\n\t\tif (nr > slots->flexible)\n\t\t\tslots->flexible = nr;\n\t}\n}\n\n\nstatic void\nfetch_this_slot(struct bp_busy_slots *slots, int weight)\n{\n\tslots->pinned += weight;\n}\n\n\nstatic void toggle_bp_task_slot(struct perf_event *bp, int cpu,\n\t\t\t\tenum bp_type_idx type, int weight)\n{\n\tunsigned int *tsk_pinned = get_bp_info(cpu, type)->tsk_pinned;\n\tint old_idx, new_idx;\n\n\told_idx = task_bp_pinned(cpu, bp, type) - 1;\n\tnew_idx = old_idx + weight;\n\n\tif (old_idx >= 0)\n\t\ttsk_pinned[old_idx]--;\n\tif (new_idx >= 0)\n\t\ttsk_pinned[new_idx]++;\n}\n\n\nstatic void\ntoggle_bp_slot(struct perf_event *bp, bool enable, enum bp_type_idx type,\n\t       int weight)\n{\n\tconst struct cpumask *cpumask = cpumask_of_bp(bp);\n\tint cpu;\n\n\tif (!enable)\n\t\tweight = -weight;\n\n\t\n\tif (!bp->hw.target) {\n\t\tget_bp_info(bp->cpu, type)->cpu_pinned += weight;\n\t\treturn;\n\t}\n\n\t\n\tfor_each_cpu(cpu, cpumask)\n\t\ttoggle_bp_task_slot(bp, cpu, type, weight);\n\n\tif (enable)\n\t\tlist_add_tail(&bp->hw.bp_list, &bp_task_head);\n\telse\n\t\tlist_del(&bp->hw.bp_list);\n}\n\n\n__weak void arch_unregister_hw_breakpoint(struct perf_event *bp)\n{\n\t\n}\n\n\nstatic int __reserve_bp_slot(struct perf_event *bp)\n{\n\tstruct bp_busy_slots slots = {0};\n\tenum bp_type_idx type;\n\tint weight;\n\n\t\n\tif (!constraints_initialized)\n\t\treturn -enomem;\n\n\t\n\tif (bp->attr.bp_type == hw_breakpoint_empty ||\n\t    bp->attr.bp_type == hw_breakpoint_invalid)\n\t\treturn -einval;\n\n\ttype = find_slot_idx(bp);\n\tweight = hw_breakpoint_weight(bp);\n\n\tfetch_bp_busy_slots(&slots, bp, type);\n\t\n\tfetch_this_slot(&slots, weight);\n\n\t\n\tif (slots.pinned + (!!slots.flexible) > nr_slots[type])\n\t\treturn -enospc;\n\n\ttoggle_bp_slot(bp, true, type, weight);\n\n\treturn 0;\n}\n\nint reserve_bp_slot(struct perf_event *bp)\n{\n\tint ret;\n\n\tmutex_lock(&nr_bp_mutex);\n\n\tret = __reserve_bp_slot(bp);\n\n\tmutex_unlock(&nr_bp_mutex);\n\n\treturn ret;\n}\n\nstatic void __release_bp_slot(struct perf_event *bp)\n{\n\tenum bp_type_idx type;\n\tint weight;\n\n\ttype = find_slot_idx(bp);\n\tweight = hw_breakpoint_weight(bp);\n\ttoggle_bp_slot(bp, false, type, weight);\n}\n\nvoid release_bp_slot(struct perf_event *bp)\n{\n\tmutex_lock(&nr_bp_mutex);\n\n\tarch_unregister_hw_breakpoint(bp);\n\t__release_bp_slot(bp);\n\n\tmutex_unlock(&nr_bp_mutex);\n}\n\n\nint dbg_reserve_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\treturn __reserve_bp_slot(bp);\n}\n\nint dbg_release_bp_slot(struct perf_event *bp)\n{\n\tif (mutex_is_locked(&nr_bp_mutex))\n\t\treturn -1;\n\n\t__release_bp_slot(bp);\n\n\treturn 0;\n}\n\nstatic int validate_hw_breakpoint(struct perf_event *bp)\n{\n\tint ret;\n\n\tret = arch_validate_hwbkpt_settings(bp);\n\tif (ret)\n\t\treturn ret;\n\n\tif (arch_check_bp_in_kernelspace(bp)) {\n\t\tif (bp->attr.exclude_kernel)\n\t\t\treturn -einval;\n\t\t\n\t\tif (!capable(cap_sys_admin))\n\t\t\treturn -eperm;\n\t}\n\n\treturn 0;\n}\n\nint register_perf_hw_breakpoint(struct perf_event *bp)\n{\n\tint ret;\n\n\tret = reserve_bp_slot(bp);\n\tif (ret)\n\t\treturn ret;\n\n\tret = validate_hw_breakpoint(bp);\n\n\t\n\tif (ret)\n\t\trelease_bp_slot(bp);\n\n\treturn ret;\n}\n\n\nstruct perf_event *\nregister_user_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context,\n\t\t\t    struct task_struct *tsk)\n{\n\treturn perf_event_create_kernel_counter(attr, -1, tsk, triggered,\n\t\t\t\t\t\tcontext);\n}\nexport_symbol_gpl(register_user_hw_breakpoint);\n\n\nint modify_user_hw_breakpoint(struct perf_event *bp, struct perf_event_attr *attr)\n{\n\tu64 old_addr = bp->attr.bp_addr;\n\tu64 old_len = bp->attr.bp_len;\n\tint old_type = bp->attr.bp_type;\n\tint err = 0;\n\n\t\n\tif (irqs_disabled() && bp->ctx && bp->ctx->task == current)\n\t\t__perf_event_disable(bp);\n\telse\n\t\tperf_event_disable(bp);\n\n\tbp->attr.bp_addr = attr->bp_addr;\n\tbp->attr.bp_type = attr->bp_type;\n\tbp->attr.bp_len = attr->bp_len;\n\n\tif (attr->disabled)\n\t\tgoto end;\n\n\terr = validate_hw_breakpoint(bp);\n\tif (!err)\n\t\tperf_event_enable(bp);\n\n\tif (err) {\n\t\tbp->attr.bp_addr = old_addr;\n\t\tbp->attr.bp_type = old_type;\n\t\tbp->attr.bp_len = old_len;\n\t\tif (!bp->attr.disabled)\n\t\t\tperf_event_enable(bp);\n\n\t\treturn err;\n\t}\n\nend:\n\tbp->attr.disabled = attr->disabled;\n\n\treturn 0;\n}\nexport_symbol_gpl(modify_user_hw_breakpoint);\n\n\nvoid unregister_hw_breakpoint(struct perf_event *bp)\n{\n\tif (!bp)\n\t\treturn;\n\tperf_event_release_kernel(bp);\n}\nexport_symbol_gpl(unregister_hw_breakpoint);\n\n\nstruct perf_event * __percpu *\nregister_wide_hw_breakpoint(struct perf_event_attr *attr,\n\t\t\t    perf_overflow_handler_t triggered,\n\t\t\t    void *context)\n{\n\tstruct perf_event * __percpu *cpu_events, *bp;\n\tlong err = 0;\n\tint cpu;\n\n\tcpu_events = alloc_percpu(typeof(*cpu_events));\n\tif (!cpu_events)\n\t\treturn (void __percpu __force *)err_ptr(-enomem);\n\n\tget_online_cpus();\n\tfor_each_online_cpu(cpu) {\n\t\tbp = perf_event_create_kernel_counter(attr, cpu, null,\n\t\t\t\t\t\t      triggered, context);\n\t\tif (is_err(bp)) {\n\t\t\terr = ptr_err(bp);\n\t\t\tbreak;\n\t\t}\n\n\t\tper_cpu(*cpu_events, cpu) = bp;\n\t}\n\tput_online_cpus();\n\n\tif (likely(!err))\n\t\treturn cpu_events;\n\n\tunregister_wide_hw_breakpoint(cpu_events);\n\treturn (void __percpu __force *)err_ptr(err);\n}\nexport_symbol_gpl(register_wide_hw_breakpoint);\n\n\nvoid unregister_wide_hw_breakpoint(struct perf_event * __percpu *cpu_events)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tunregister_hw_breakpoint(per_cpu(*cpu_events, cpu));\n\n\tfree_percpu(cpu_events);\n}\nexport_symbol_gpl(unregister_wide_hw_breakpoint);\n\nstatic struct notifier_block hw_breakpoint_exceptions_nb = {\n\t.notifier_call = hw_breakpoint_exceptions_notify,\n\t\n\t.priority = 0x7fffffff\n};\n\nstatic void bp_perf_event_destroy(struct perf_event *event)\n{\n\trelease_bp_slot(event);\n}\n\nstatic int hw_breakpoint_event_init(struct perf_event *bp)\n{\n\tint err;\n\n\tif (bp->attr.type != perf_type_breakpoint)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(bp))\n\t\treturn -eopnotsupp;\n\n\terr = register_perf_hw_breakpoint(bp);\n\tif (err)\n\t\treturn err;\n\n\tbp->destroy = bp_perf_event_destroy;\n\n\treturn 0;\n}\n\nstatic int hw_breakpoint_add(struct perf_event *bp, int flags)\n{\n\tif (!(flags & perf_ef_start))\n\t\tbp->hw.state = perf_hes_stopped;\n\n\tif (is_sampling_event(bp)) {\n\t\tbp->hw.last_period = bp->hw.sample_period;\n\t\tperf_swevent_set_period(bp);\n\t}\n\n\treturn arch_install_hw_breakpoint(bp);\n}\n\nstatic void hw_breakpoint_del(struct perf_event *bp, int flags)\n{\n\tarch_uninstall_hw_breakpoint(bp);\n}\n\nstatic void hw_breakpoint_start(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = 0;\n}\n\nstatic void hw_breakpoint_stop(struct perf_event *bp, int flags)\n{\n\tbp->hw.state = perf_hes_stopped;\n}\n\nstatic struct pmu perf_breakpoint = {\n\t.task_ctx_nr\t= perf_sw_context, \n\n\t.event_init\t= hw_breakpoint_event_init,\n\t.add\t\t= hw_breakpoint_add,\n\t.del\t\t= hw_breakpoint_del,\n\t.start\t\t= hw_breakpoint_start,\n\t.stop\t\t= hw_breakpoint_stop,\n\t.read\t\t= hw_breakpoint_pmu_read,\n};\n\nint __init init_hw_breakpoint(void)\n{\n\tint cpu, err_cpu;\n\tint i;\n\n\tfor (i = 0; i < type_max; i++)\n\t\tnr_slots[i] = hw_breakpoint_slots(i);\n\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < type_max; i++) {\n\t\t\tstruct bp_cpuinfo *info = get_bp_info(cpu, i);\n\n\t\t\tinfo->tsk_pinned = kcalloc(nr_slots[i], sizeof(int),\n\t\t\t\t\t\t\tgfp_kernel);\n\t\t\tif (!info->tsk_pinned)\n\t\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\tconstraints_initialized = 1;\n\n\tperf_pmu_register(&perf_breakpoint, \"", "858": "\");\n\n\nvoid suspend_console(void)\n{\n\tif (!console_suspend_enabled)\n\t\treturn;\n\tprintk(\"", "859": "\");\n\n out_enable:\n\ttrace_flags |= old_userobj;\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_dec(&per_cpu_ptr(iter.trace_buffer->data, cpu)->disabled);\n\t}\n \tatomic_dec(&dump_running);\n\tlocal_irq_restore(flags);\n}\nexport_symbol_gpl(ftrace_dump);\n\n__init static int tracer_alloc_buffers(void)\n{\n\tint ring_buf_size;\n\tint ret = -enomem;\n\n\tif (!alloc_cpumask_var(&tracing_buffer_mask, gfp_kernel))\n\t\tgoto out;\n\n\tif (!alloc_cpumask_var(&global_trace.tracing_cpumask, gfp_kernel))\n\t\tgoto out_free_buffer_mask;\n\n\t\n\tif (__stop___trace_bprintk_fmt != __start___trace_bprintk_fmt)\n\t\t\n\t\ttrace_printk_init_buffers();\n\n\t\n\tif (ring_buffer_expanded)\n\t\tring_buf_size = trace_buf_size;\n\telse\n\t\tring_buf_size = 1;\n\n\tcpumask_copy(tracing_buffer_mask, cpu_possible_mask);\n\tcpumask_copy(global_trace.tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&global_trace.start_lock);\n\n\t\n\ttemp_buffer = ring_buffer_alloc(page_size, rb_fl_overwrite);\n\tif (!temp_buffer)\n\t\tgoto out_free_cpumask;\n\n\tif (trace_create_savedcmd() < 0)\n\t\tgoto out_free_temp_buffer;\n\n\t\n\tif (allocate_trace_buffers(&global_trace, ring_buf_size) < 0) {\n\t\tprintk(kern_err \"", "860": "\");\n\n#ifdef config_boot_printk_delay\n\nstatic int boot_delay; \nstatic unsigned long long loops_per_msec;\t\n\nstatic int __init boot_delay_setup(char *str)\n{\n\tunsigned long lpj;\n\n\tlpj = preset_lpj ? preset_lpj : 1000000;\t\n\tloops_per_msec = (unsigned long long)lpj / 1000 * hz;\n\n\tget_option(&str, &boot_delay);\n\tif (boot_delay > 10 * 1000)\n\t\tboot_delay = 0;\n\n\tpr_debug(\"", "861": "\");\n\n#ifdef config_tracer_snapshot\n\ttrace_create_file(\"", "862": "\");\n\nstatic void check_cpu_stall(struct rcu_ctrlblk *rcp)\n{\n\tunsigned long j;\n\tunsigned long js;\n\n\tif (rcu_cpu_stall_suppress)\n\t\treturn;\n\trcp->ticks_this_gp++;\n\tj = jiffies;\n\tjs = access_once(rcp->jiffies_stall);\n\tif (rcp->rcucblist && ulong_cmp_ge(j, js)) {\n\t\tpr_err(\"", "863": "\");\n#else\n\tseq_puts(m, \"", "864": "\");\n#endif\n\tfor (s = buf; *s; s++)\n\t\tif (isdigit(*s) || *s == ',')\n\t\t\tbreak;\n\tidx = simple_strtoul(s, null, 10);\n\t*s = 0;\n\n\t__add_preferred_console(buf, idx, options, brl_options);\n\tconsole_set_on_cmdline = 1;\n\treturn 1;\n}\n__setup(\"", "865": "\");\n#endif\n\tseq_puts(m, \"", "866": "\");\n#endif\n\nstatic int suspend_test(int level)\n{\n#ifdef config_pm_debug\n\tif (pm_test_level == level) {\n\t\tprintk(kern_info \"", "867": "\");\n#endif\n}\n#endif\n\nstatic inline void timer_list_header(struct seq_file *m, u64 now)\n{\n\tseq_printf(m, \"", "868": "\");\n#ifdef config_high_res_timers\n\tseq_printf(m, \"", "869": "\");\n#ifdef config_ring_buffer_allow_swap\n\tseq_puts(m, \"", "870": "\");\nmodule_description(\"", "871": "\");\nmodule_license(\"", "872": "\");\n}\n\n\nstatic noinline int\nprint_circular_bug_header(struct lock_list *entry, unsigned int depth,\n\t\t\tstruct held_lock *check_src,\n\t\t\tstruct held_lock *check_tgt)\n{\n\tstruct task_struct *curr = current;\n\n\tif (debug_locks_silent)\n\t\treturn 0;\n\n\tprintk(\"", "873": "\");\n}\n\n#ifdef config_tracer_max_trace\nstatic void show_snapshot_main_help(struct seq_file *m)\n{\n\tseq_puts(m, \"", "874": "\");\n}\n\nstatic int\nprint_bad_irq_dependency(struct task_struct *curr,\n\t\t\t struct lock_list *prev_root,\n\t\t\t struct lock_list *next_root,\n\t\t\t struct lock_list *backwards_entry,\n\t\t\t struct lock_list *forwards_entry,\n\t\t\t struct held_lock *prev,\n\t\t\t struct held_lock *next,\n\t\t\t enum lock_usage_bit bit1,\n\t\t\t enum lock_usage_bit bit2,\n\t\t\t const char *irqclass)\n{\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tprintk(\"", "875": "\");\n}\n\nstatic int timer_list_show(struct seq_file *m, void *v)\n{\n\tstruct timer_list_iter *iter = v;\n\n\tif (iter->cpu == -1 && !iter->second_pass)\n\t\ttimer_list_header(m, iter->now);\n\telse if (!iter->second_pass)\n\t\tprint_cpu(m, iter->cpu, iter->now);\n#ifdef config_generic_clockevents\n\telse if (iter->cpu == -1 && iter->second_pass)\n\t\ttimer_list_show_tickdevices_header(m);\n\telse\n\t\tprint_tickdevice(m, tick_get_device(iter->cpu), iter->cpu);\n#endif\n\treturn 0;\n}\n\nvoid sysrq_timer_list_show(void)\n{\n\tu64 now = ktime_to_ns(ktime_get());\n\tint cpu;\n\n\ttimer_list_header(null, now);\n\n\tfor_each_online_cpu(cpu)\n\t\tprint_cpu(null, cpu, now);\n\n#ifdef config_generic_clockevents\n\ttimer_list_show_tickdevices_header(null);\n\tfor_each_online_cpu(cpu)\n\t\tprint_tickdevice(null, tick_get_device(cpu), cpu);\n#endif\n\treturn;\n}\n\nstatic void *move_iter(struct timer_list_iter *iter, loff_t offset)\n{\n\tfor (; offset; offset--) {\n\t\titer->cpu = cpumask_next(iter->cpu, cpu_online_mask);\n\t\tif (iter->cpu >= nr_cpu_ids) {\n#ifdef config_generic_clockevents\n\t\t\tif (!iter->second_pass) {\n\t\t\t\titer->cpu = -1;\n\t\t\t\titer->second_pass = true;\n\t\t\t} else\n\t\t\t\treturn null;\n#else\n\t\t\treturn null;\n#endif\n\t\t}\n\t}\n\treturn iter;\n}\n\nstatic void *timer_list_start(struct seq_file *file, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\n\tif (!*offset)\n\t\titer->now = ktime_to_ns(ktime_get());\n\titer->cpu = -1;\n\titer->second_pass = false;\n\treturn move_iter(iter, *offset);\n}\n\nstatic void *timer_list_next(struct seq_file *file, void *v, loff_t *offset)\n{\n\tstruct timer_list_iter *iter = file->private;\n\t++*offset;\n\treturn move_iter(iter, 1);\n}\n\nstatic void timer_list_stop(struct seq_file *seq, void *v)\n{\n}\n\nstatic const struct seq_operations timer_list_sops = {\n\t.start = timer_list_start,\n\t.next = timer_list_next,\n\t.stop = timer_list_stop,\n\t.show = timer_list_show,\n};\n\nstatic int timer_list_open(struct inode *inode, struct file *filp)\n{\n\treturn seq_open_private(filp, &timer_list_sops,\n\t\t\tsizeof(struct timer_list_iter));\n}\n\nstatic const struct file_operations timer_list_fops = {\n\t.open\t\t= timer_list_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release_private,\n};\n\nstatic int __init init_timer_list_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create(\"", "876": "\");\n}\n\nstatic void __clocksource_unstable(struct clocksource *cs)\n{\n\tcs->flags &= ~(clock_source_valid_for_hres | clock_source_watchdog);\n\tcs->flags |= clock_source_unstable;\n\tif (finished_booting)\n\t\tschedule_work(&watchdog_work);\n}\n\n\nvoid clocksource_mark_unstable(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (!(cs->flags & clock_source_unstable)) {\n\t\tif (list_empty(&cs->wd_list))\n\t\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\t__clocksource_unstable(cs);\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}\n\nstatic void clocksource_watchdog(unsigned long data)\n{\n\tstruct clocksource *cs;\n\tcycle_t csnow, wdnow, cslast, wdlast, delta;\n\tint64_t wd_nsec, cs_nsec;\n\tint next_cpu, reset_pending;\n\n\tspin_lock(&watchdog_lock);\n\tif (!watchdog_running)\n\t\tgoto out;\n\n\treset_pending = atomic_read(&watchdog_reset_pending);\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list) {\n\n\t\t\n\t\tif (cs->flags & clock_source_unstable) {\n\t\t\tif (finished_booting)\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\tcontinue;\n\t\t}\n\n\t\tlocal_irq_disable();\n\t\tcsnow = cs->read(cs);\n\t\twdnow = watchdog->read(watchdog);\n\t\tlocal_irq_enable();\n\n\t\t\n\t\tif (!(cs->flags & clock_source_watchdog) ||\n\t\t    atomic_read(&watchdog_reset_pending)) {\n\t\t\tcs->flags |= clock_source_watchdog;\n\t\t\tcs->wd_last = wdnow;\n\t\t\tcs->cs_last = csnow;\n\t\t\tcontinue;\n\t\t}\n\n\t\tdelta = clocksource_delta(wdnow, cs->wd_last, watchdog->mask);\n\t\twd_nsec = clocksource_cyc2ns(delta, watchdog->mult,\n\t\t\t\t\t     watchdog->shift);\n\n\t\tdelta = clocksource_delta(csnow, cs->cs_last, cs->mask);\n\t\tcs_nsec = clocksource_cyc2ns(delta, cs->mult, cs->shift);\n\t\twdlast = cs->wd_last; \n\t\tcslast = cs->cs_last;\n\t\tcs->cs_last = csnow;\n\t\tcs->wd_last = wdnow;\n\n\t\tif (atomic_read(&watchdog_reset_pending))\n\t\t\tcontinue;\n\n\t\t\n\t\tif ((abs(cs_nsec - wd_nsec) > watchdog_threshold)) {\n\t\t\tpr_warn(\"", "877": "\");\n}\n\nstatic void print_event_info(struct trace_buffer *buf, struct seq_file *m)\n{\n\tunsigned long total;\n\tunsigned long entries;\n\n\tget_total_entries(buf, &total, &entries);\n\tseq_printf(m, \"", "878": "\");\n}\n\nstatic void print_func_help_header(struct trace_buffer *buf, struct seq_file *m)\n{\n\tprint_event_info(buf, m);\n\tseq_puts(m, \"", "879": "\");\n}\n\nstatic void print_func_help_header_irq(struct trace_buffer *buf, struct seq_file *m)\n{\n\tprint_event_info(buf, m);\n\tseq_puts(m, \"", "880": "\");\n}\n\nstatic void print_snapshot_help(struct seq_file *m, struct trace_iterator *iter)\n{\n\tif (iter->tr->allocated_snapshot)\n\t\tseq_puts(m, \"", "881": "\");\n}\n\nstatic void show_snapshot_percpu_help(struct seq_file *m)\n{\n\tseq_puts(m, \"", "882": "\");\n}\n\nstatic void test_cpu_buff_start(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\n\tif (!(trace_flags & trace_iter_annotate))\n\t\treturn;\n\n\tif (!(iter->iter_flags & trace_file_annotate))\n\t\treturn;\n\n\tif (cpumask_test_cpu(iter->cpu, iter->started))\n\t\treturn;\n\n\tif (per_cpu_ptr(iter->trace_buffer->data, iter->cpu)->skipped_entries)\n\t\treturn;\n\n\tcpumask_set_cpu(iter->cpu, iter->started);\n\n\t\n\tif (iter->idx > 1)\n\t\ttrace_seq_printf(s, \"", "883": "\");\n}\n\nstatic void timer_list_show_tickdevices_header(struct seq_file *m)\n{\n#ifdef config_generic_clockevents_broadcast\n\tprint_tickdevice(m, tick_get_broadcast_device(), -1);\n\tseq_printf(m, \"", "884": "\");\n}\n\nvoid\nprint_trace_header(struct seq_file *m, struct trace_iterator *iter)\n{\n\tunsigned long sym_flags = (trace_flags & trace_iter_sym_mask);\n\tstruct trace_buffer *buf = iter->trace_buffer;\n\tstruct trace_array_cpu *data = per_cpu_ptr(buf->data, buf->cpu);\n\tstruct tracer *type = iter->trace;\n\tunsigned long entries;\n\tunsigned long total;\n\tconst char *name = \"", "885": "\");\n}\n\nvoid trace_find_cmdline(int pid, char comm[])\n{\n\tpreempt_disable();\n\tarch_spin_lock(&trace_cmdline_lock);\n\n\t__trace_find_cmdline(pid, comm);\n\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tpreempt_enable();\n}\n\nvoid tracing_record_cmdline(struct task_struct *tsk)\n{\n\tif (atomic_read(&trace_record_cmdline_disabled) || !tracing_is_on())\n\t\treturn;\n\n\tif (!__this_cpu_read(trace_cmdline_save))\n\t\treturn;\n\n\tif (trace_save_cmdline(tsk))\n\t\t__this_cpu_write(trace_cmdline_save, false);\n}\n\nvoid\ntracing_generic_entry_update(struct trace_entry *entry, unsigned long flags,\n\t\t\t     int pc)\n{\n\tstruct task_struct *tsk = current;\n\n\tentry->preempt_count\t\t= pc & 0xff;\n\tentry->pid\t\t\t= (tsk) ? tsk->pid : 0;\n\tentry->flags =\n#ifdef config_trace_irqflags_support\n\t\t(irqs_disabled_flags(flags) ? trace_flag_irqs_off : 0) |\n#else\n\t\ttrace_flag_irqs_nosupport |\n#endif\n\t\t((pc & hardirq_mask) ? trace_flag_hardirq : 0) |\n\t\t((pc & softirq_mask) ? trace_flag_softirq : 0) |\n\t\t(tif_need_resched() ? trace_flag_need_resched : 0) |\n\t\t(test_preempt_need_resched() ? trace_flag_preempt_resched : 0);\n}\nexport_symbol_gpl(tracing_generic_entry_update);\n\nstruct ring_buffer_event *\ntrace_buffer_lock_reserve(struct ring_buffer *buffer,\n\t\t\t  int type,\n\t\t\t  unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *event;\n\n\tevent = ring_buffer_lock_reserve(buffer, len);\n\tif (event != null) {\n\t\tstruct trace_entry *ent = ring_buffer_event_data(event);\n\n\t\ttracing_generic_entry_update(ent, flags, pc);\n\t\tent->type = type;\n\t}\n\n\treturn event;\n}\n\nvoid\n__buffer_unlock_commit(struct ring_buffer *buffer, struct ring_buffer_event *event)\n{\n\t__this_cpu_write(trace_cmdline_save, true);\n\tring_buffer_unlock_commit(buffer, event);\n}\n\nstatic inline void\n__trace_buffer_unlock_commit(struct ring_buffer *buffer,\n\t\t\t     struct ring_buffer_event *event,\n\t\t\t     unsigned long flags, int pc)\n{\n\t__buffer_unlock_commit(buffer, event);\n\n\tftrace_trace_stack(buffer, flags, 6, pc);\n\tftrace_trace_userstack(buffer, flags, pc);\n}\n\nvoid trace_buffer_unlock_commit(struct ring_buffer *buffer,\n\t\t\t\tstruct ring_buffer_event *event,\n\t\t\t\tunsigned long flags, int pc)\n{\n\t__trace_buffer_unlock_commit(buffer, event, flags, pc);\n}\nexport_symbol_gpl(trace_buffer_unlock_commit);\n\nstatic struct ring_buffer *temp_buffer;\n\nstruct ring_buffer_event *\ntrace_event_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t  struct ftrace_event_file *ftrace_file,\n\t\t\t  int type, unsigned long len,\n\t\t\t  unsigned long flags, int pc)\n{\n\tstruct ring_buffer_event *entry;\n\n\t*current_rb = ftrace_file->tr->trace_buffer.buffer;\n\tentry = trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t type, len, flags, pc);\n\t\n\tif (!entry && ftrace_file->flags & ftrace_event_fl_trigger_cond) {\n\t\t*current_rb = temp_buffer;\n\t\tentry = trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t\t  type, len, flags, pc);\n\t}\n\treturn entry;\n}\nexport_symbol_gpl(trace_event_buffer_lock_reserve);\n\nstruct ring_buffer_event *\ntrace_current_buffer_lock_reserve(struct ring_buffer **current_rb,\n\t\t\t\t  int type, unsigned long len,\n\t\t\t\t  unsigned long flags, int pc)\n{\n\t*current_rb = global_trace.trace_buffer.buffer;\n\treturn trace_buffer_lock_reserve(*current_rb,\n\t\t\t\t\t type, len, flags, pc);\n}\nexport_symbol_gpl(trace_current_buffer_lock_reserve);\n\nvoid trace_current_buffer_unlock_commit(struct ring_buffer *buffer,\n\t\t\t\t\tstruct ring_buffer_event *event,\n\t\t\t\t\tunsigned long flags, int pc)\n{\n\t__trace_buffer_unlock_commit(buffer, event, flags, pc);\n}\nexport_symbol_gpl(trace_current_buffer_unlock_commit);\n\nvoid trace_buffer_unlock_commit_regs(struct ring_buffer *buffer,\n\t\t\t\t     struct ring_buffer_event *event,\n\t\t\t\t     unsigned long flags, int pc,\n\t\t\t\t     struct pt_regs *regs)\n{\n\t__buffer_unlock_commit(buffer, event);\n\n\tftrace_trace_stack_regs(buffer, flags, 0, pc, regs);\n\tftrace_trace_userstack(buffer, flags, pc);\n}\nexport_symbol_gpl(trace_buffer_unlock_commit_regs);\n\nvoid trace_current_buffer_discard_commit(struct ring_buffer *buffer,\n\t\t\t\t\t struct ring_buffer_event *event)\n{\n\tring_buffer_discard_commit(buffer, event);\n}\nexport_symbol_gpl(trace_current_buffer_discard_commit);\n\nvoid\ntrace_function(struct trace_array *tr,\n\t       unsigned long ip, unsigned long parent_ip, unsigned long flags,\n\t       int pc)\n{\n\tstruct ftrace_event_call *call = &event_function;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tstruct ring_buffer_event *event;\n\tstruct ftrace_entry *entry;\n\n\t\n\tif (unlikely(__this_cpu_read(ftrace_cpu_disabled)))\n\t\treturn;\n\n\tevent = trace_buffer_lock_reserve(buffer, trace_fn, sizeof(*entry),\n\t\t\t\t\t  flags, pc);\n\tif (!event)\n\t\treturn;\n\tentry\t= ring_buffer_event_data(event);\n\tentry->ip\t\t\t= ip;\n\tentry->parent_ip\t\t= parent_ip;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n}\n\n#ifdef config_stacktrace\n\n#define ftrace_stack_max_entries (page_size / sizeof(unsigned long))\nstruct ftrace_stack {\n\tunsigned long\t\tcalls[ftrace_stack_max_entries];\n};\n\nstatic define_per_cpu(struct ftrace_stack, ftrace_stack);\nstatic define_per_cpu(int, ftrace_stack_reserve);\n\nstatic void __ftrace_trace_stack(struct ring_buffer *buffer,\n\t\t\t\t unsigned long flags,\n\t\t\t\t int skip, int pc, struct pt_regs *regs)\n{\n\tstruct ftrace_event_call *call = &event_kernel_stack;\n\tstruct ring_buffer_event *event;\n\tstruct stack_entry *entry;\n\tstruct stack_trace trace;\n\tint use_stack;\n\tint size = ftrace_stack_entries;\n\n\ttrace.nr_entries\t= 0;\n\ttrace.skip\t\t= skip;\n\n\t\n\tpreempt_disable_notrace();\n\n\tuse_stack = __this_cpu_inc_return(ftrace_stack_reserve);\n\t\n\tbarrier();\n\tif (use_stack == 1) {\n\t\ttrace.entries\t\t= this_cpu_ptr(ftrace_stack.calls);\n\t\ttrace.max_entries\t= ftrace_stack_max_entries;\n\n\t\tif (regs)\n\t\t\tsave_stack_trace_regs(regs, &trace);\n\t\telse\n\t\t\tsave_stack_trace(&trace);\n\n\t\tif (trace.nr_entries > size)\n\t\t\tsize = trace.nr_entries;\n\t} else\n\t\t\n\t\tuse_stack = 0;\n\n\tsize *= sizeof(unsigned long);\n\n\tevent = trace_buffer_lock_reserve(buffer, trace_stack,\n\t\t\t\t\t  sizeof(*entry) + size, flags, pc);\n\tif (!event)\n\t\tgoto out;\n\tentry = ring_buffer_event_data(event);\n\n\tmemset(&entry->caller, 0, size);\n\n\tif (use_stack)\n\t\tmemcpy(&entry->caller, trace.entries,\n\t\t       trace.nr_entries * sizeof(unsigned long));\n\telse {\n\t\ttrace.max_entries\t= ftrace_stack_entries;\n\t\ttrace.entries\t\t= entry->caller;\n\t\tif (regs)\n\t\t\tsave_stack_trace_regs(regs, &trace);\n\t\telse\n\t\t\tsave_stack_trace(&trace);\n\t}\n\n\tentry->size = trace.nr_entries;\n\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n\n out:\n\t\n\tbarrier();\n\t__this_cpu_dec(ftrace_stack_reserve);\n\tpreempt_enable_notrace();\n\n}\n\nvoid ftrace_trace_stack_regs(struct ring_buffer *buffer, unsigned long flags,\n\t\t\t     int skip, int pc, struct pt_regs *regs)\n{\n\tif (!(trace_flags & trace_iter_stacktrace))\n\t\treturn;\n\n\t__ftrace_trace_stack(buffer, flags, skip, pc, regs);\n}\n\nvoid ftrace_trace_stack(struct ring_buffer *buffer, unsigned long flags,\n\t\t\tint skip, int pc)\n{\n\tif (!(trace_flags & trace_iter_stacktrace))\n\t\treturn;\n\n\t__ftrace_trace_stack(buffer, flags, skip, pc, null);\n}\n\nvoid __trace_stack(struct trace_array *tr, unsigned long flags, int skip,\n\t\t   int pc)\n{\n\t__ftrace_trace_stack(tr->trace_buffer.buffer, flags, skip, pc, null);\n}\n\n\nvoid trace_dump_stack(int skip)\n{\n\tunsigned long flags;\n\n\tif (tracing_disabled || tracing_selftest_running)\n\t\treturn;\n\n\tlocal_save_flags(flags);\n\n\t\n\tskip += 3;\n\t__ftrace_trace_stack(global_trace.trace_buffer.buffer,\n\t\t\t     flags, skip, preempt_count(), null);\n}\n\nstatic define_per_cpu(int, user_stack_count);\n\nvoid\nftrace_trace_userstack(struct ring_buffer *buffer, unsigned long flags, int pc)\n{\n\tstruct ftrace_event_call *call = &event_user_stack;\n\tstruct ring_buffer_event *event;\n\tstruct userstack_entry *entry;\n\tstruct stack_trace trace;\n\n\tif (!(trace_flags & trace_iter_userstacktrace))\n\t\treturn;\n\n\t\n\tif (unlikely(in_nmi()))\n\t\treturn;\n\n\t\n\tpreempt_disable();\n\tif (__this_cpu_read(user_stack_count))\n\t\tgoto out;\n\n\t__this_cpu_inc(user_stack_count);\n\n\tevent = trace_buffer_lock_reserve(buffer, trace_user_stack,\n\t\t\t\t\t  sizeof(*entry), flags, pc);\n\tif (!event)\n\t\tgoto out_drop_count;\n\tentry\t= ring_buffer_event_data(event);\n\n\tentry->tgid\t\t= current->tgid;\n\tmemset(&entry->caller, 0, sizeof(entry->caller));\n\n\ttrace.nr_entries\t= 0;\n\ttrace.max_entries\t= ftrace_stack_entries;\n\ttrace.skip\t\t= 0;\n\ttrace.entries\t\t= entry->caller;\n\n\tsave_stack_trace_user(&trace);\n\tif (!call_filter_check_discard(call, entry, buffer, event))\n\t\t__buffer_unlock_commit(buffer, event);\n\n out_drop_count:\n\t__this_cpu_dec(user_stack_count);\n out:\n\tpreempt_enable();\n}\n\n#ifdef unused\nstatic void __trace_userstack(struct trace_array *tr, unsigned long flags)\n{\n\tftrace_trace_userstack(tr, flags, preempt_count());\n}\n#endif \n\n#endif \n\n\nstruct trace_buffer_struct {\n\tchar buffer[trace_buf_size];\n};\n\nstatic struct trace_buffer_struct *trace_percpu_buffer;\nstatic struct trace_buffer_struct *trace_percpu_sirq_buffer;\nstatic struct trace_buffer_struct *trace_percpu_irq_buffer;\nstatic struct trace_buffer_struct *trace_percpu_nmi_buffer;\n\n\nstatic char *get_trace_buf(void)\n{\n\tstruct trace_buffer_struct *percpu_buffer;\n\n\t\n\tif (in_nmi())\n\t\tpercpu_buffer = trace_percpu_nmi_buffer;\n\telse if (in_irq())\n\t\tpercpu_buffer = trace_percpu_irq_buffer;\n\telse if (in_softirq())\n\t\tpercpu_buffer = trace_percpu_sirq_buffer;\n\telse\n\t\tpercpu_buffer = trace_percpu_buffer;\n\n\tif (!percpu_buffer)\n\t\treturn null;\n\n\treturn this_cpu_ptr(&percpu_buffer->buffer[0]);\n}\n\nstatic int alloc_percpu_trace_buffer(void)\n{\n\tstruct trace_buffer_struct *buffers;\n\tstruct trace_buffer_struct *sirq_buffers;\n\tstruct trace_buffer_struct *irq_buffers;\n\tstruct trace_buffer_struct *nmi_buffers;\n\n\tbuffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!buffers)\n\t\tgoto err_warn;\n\n\tsirq_buffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!sirq_buffers)\n\t\tgoto err_sirq;\n\n\tirq_buffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!irq_buffers)\n\t\tgoto err_irq;\n\n\tnmi_buffers = alloc_percpu(struct trace_buffer_struct);\n\tif (!nmi_buffers)\n\t\tgoto err_nmi;\n\n\ttrace_percpu_buffer = buffers;\n\ttrace_percpu_sirq_buffer = sirq_buffers;\n\ttrace_percpu_irq_buffer = irq_buffers;\n\ttrace_percpu_nmi_buffer = nmi_buffers;\n\n\treturn 0;\n\n err_nmi:\n\tfree_percpu(irq_buffers);\n err_irq:\n\tfree_percpu(sirq_buffers);\n err_sirq:\n\tfree_percpu(buffers);\n err_warn:\n\twarn(1, \"", "886": "\");\\n\"", "887": "\")\\n\"", "888": "\")\\n\\t=> (\"", "889": "\"){%s}\"", "890": "\"*\"", "891": "\"*** can not use snapshot (sorry) ***\\n\"", "892": "\"*** latency tracer active ***\\n\"", "893": "\"*** snapshot called from nmi context ***\\n\"", "894": "\"*** snapshot is being ignored        ***\\n\"", "895": "\"*** snapshot not allocated ***\\n\"", "896": "\"*** stopping trace here!   ***\\n\"", "897": "\"*=\"", "898": "\"*callback never called* \"", "899": "\"*callback not called expected 2 times (%d)* \"", "900": "\"*callback not called once (%d)* \"", "901": "\"*callback received null regs* \"", "902": "\"*callback received regs without arch support* \"", "903": "\"*could not register callback* \"", "904": "\"*could not set filter* \"", "905": "\"*registered save-regs without arch support* \"", "906": "\"*warning* lock debugging disabled!! - possibly due to a lockdep warning\\n\"", "907": "\"+%#lx/%#lx\"", "908": "\"++=\"", "909": "\"+0x%lx\"", "910": "\"+=\"", "911": "\"+rm\"", "912": "\",\t\t\t\n kdb_platform_env,\n \"", "913": "\",\n\t\t\t\t\t\t\t\tt, usec_rem);\n\n\t\tt = ns2usecs(ring_buffer_time_stamp(trace_buf->buffer, cpu));\n\t\tusec_rem = do_div(t, usec_per_sec);\n\t\ttrace_seq_printf(s, \"", "914": "\",\n\t\t\t\t\t    size >> 10,\n\t\t\t\t\t    trace_buf_size >> 10);\n\t\t\telse\n\t\t\t\tr = sprintf(buf, \"", "915": "\",\n\t\t\t\t\t   (void *)ops->trampoline);\n\t\t\telse\n\t\t\t\tseq_puts(m, \"", "916": "\",\n\t\t\t\t\t   count);\n\t\t\t}\n\t\t\tkdb_printf(\"", "917": "\",\n\t\t\t\t\tbcon->name, bcon->index))\n\t\t\t\treturn;\n\n\t\n\tif (console_drivers && newcon->flags & con_boot) {\n\t\t\n\t\tfor_each_console(bcon) {\n\t\t\tif (!(bcon->flags & con_boot)) {\n\t\t\t\tpr_info(\"", "918": "\",\n\t\t\t\t\tnewcon->name, newcon->index);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (console_drivers && console_drivers->flags & con_boot)\n\t\tbcon = console_drivers;\n\n\tif (preferred_console < 0 || bcon || !console_drivers)\n\t\tpreferred_console = selected_console;\n\n\t\n\tif (preferred_console < 0) {\n\t\tif (newcon->index < 0)\n\t\t\tnewcon->index = 0;\n\t\tif (newcon->setup == null ||\n\t\t    newcon->setup(newcon, null) == 0) {\n\t\t\tnewcon->flags |= con_enabled;\n\t\t\tif (newcon->device) {\n\t\t\t\tnewcon->flags |= con_consdev;\n\t\t\t\tpreferred_console = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tfor (i = 0, c = console_cmdline;\n\t     i < max_cmdlineconsoles && c->name[0];\n\t     i++, c++) {\n\t\tif (!newcon->match ||\n\t\t    newcon->match(newcon, c->name, c->index, c->options) != 0) {\n\t\t\t\n\t\t\tbuild_bug_on(sizeof(c->name) != sizeof(newcon->name));\n\t\t\tif (strcmp(c->name, newcon->name) != 0)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index >= 0 &&\n\t\t\t    newcon->index != c->index)\n\t\t\t\tcontinue;\n\t\t\tif (newcon->index < 0)\n\t\t\t\tnewcon->index = c->index;\n\n\t\t\tif (_braille_register_console(newcon, c))\n\t\t\t\treturn;\n\n\t\t\tif (newcon->setup &&\n\t\t\t    newcon->setup(newcon, c->options) != 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\tnewcon->flags |= con_enabled;\n\t\tif (i == selected_console) {\n\t\t\tnewcon->flags |= con_consdev;\n\t\t\tpreferred_console = selected_console;\n\t\t}\n\t\tbreak;\n\t}\n\n\tif (!(newcon->flags & con_enabled))\n\t\treturn;\n\n\t\n\tif (bcon && ((newcon->flags & (con_consdev | con_boot)) == con_consdev))\n\t\tnewcon->flags &= ~con_printbuffer;\n\n\t\n\tconsole_lock();\n\tif ((newcon->flags & con_consdev) || console_drivers == null) {\n\t\tnewcon->next = console_drivers;\n\t\tconsole_drivers = newcon;\n\t\tif (newcon->next)\n\t\t\tnewcon->next->flags &= ~con_consdev;\n\t} else {\n\t\tnewcon->next = console_drivers->next;\n\t\tconsole_drivers->next = newcon;\n\t}\n\tif (newcon->flags & con_printbuffer) {\n\t\t\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tconsole_seq = syslog_seq;\n\t\tconsole_idx = syslog_idx;\n\t\tconsole_prev = syslog_prev;\n\t\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\t\t\n\t\texclusive_console = newcon;\n\t}\n\tconsole_unlock();\n\tconsole_sysfs_notify();\n\n\t\n\tpr_info(\"", "919": "\",\n\t\t\t\t      (unsigned)(log_first_seq - console_seq));\n\n\t\t\t\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t\tconsole_prev = 0;\n\t\t} else {\n\t\t\tlen = 0;\n\t\t}\nskip:\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\n\t\tmsg = log_from_idx(console_idx);\n\t\tif (msg->flags & log_nocons) {\n\t\t\t\n\t\t\tconsole_idx = log_next(console_idx);\n\t\t\tconsole_seq++;\n\t\t\t\n\t\t\tmsg->flags &= ~log_nocons;\n\t\t\tconsole_prev = msg->flags;\n\t\t\tgoto skip;\n\t\t}\n\n\t\tlevel = msg->level;\n\t\tlen += msg_print_text(msg, console_prev, false,\n\t\t\t\t      text + len, sizeof(text) - len);\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\tconsole_prev = msg->flags;\n\t\traw_spin_unlock(&logbuf_lock);\n\n\t\tstop_critical_timings();\t\n\t\tcall_console_drivers(level, text, len);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\n\t\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = null;\n\n\traw_spin_unlock(&logbuf_lock);\n\n\tup_console_sem();\n\n\t\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tif (retry && console_trylock())\n\t\tgoto again;\n\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}\nexport_symbol(console_unlock);\n\n\nvoid __sched console_conditional_schedule(void)\n{\n\tif (console_may_schedule)\n\t\tcond_resched();\n}\nexport_symbol(console_conditional_schedule);\n\nvoid console_unblank(void)\n{\n\tstruct console *c;\n\n\t\n\tif (oops_in_progress) {\n\t\tif (down_trylock_console_sem() != 0)\n\t\t\treturn;\n\t} else\n\t\tconsole_lock();\n\n\tconsole_locked = 1;\n\tconsole_may_schedule = 0;\n\tfor_each_console(c)\n\t\tif ((c->flags & con_enabled) && c->unblank)\n\t\t\tc->unblank();\n\tconsole_unlock();\n}\n\n\nstruct tty_driver *console_device(int *index)\n{\n\tstruct console *c;\n\tstruct tty_driver *driver = null;\n\n\tconsole_lock();\n\tfor_each_console(c) {\n\t\tif (!c->device)\n\t\t\tcontinue;\n\t\tdriver = c->device(c, index);\n\t\tif (driver)\n\t\t\tbreak;\n\t}\n\tconsole_unlock();\n\treturn driver;\n}\n\n\nvoid console_stop(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags &= ~con_enabled;\n\tconsole_unlock();\n}\nexport_symbol(console_stop);\n\nvoid console_start(struct console *console)\n{\n\tconsole_lock();\n\tconsole->flags |= con_enabled;\n\tconsole_unlock();\n}\nexport_symbol(console_start);\n\nstatic int __read_mostly keep_bootcon;\n\nstatic int __init keep_bootcon_setup(char *str)\n{\n\tkeep_bootcon = 1;\n\tpr_info(\"", "920": "\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags &\n\t\t\t     ~(kdb_debug_flag_mask << kdb_debug_flag_shift))\n\t\t\t| (debugflags << kdb_debug_flag_shift);\n\n\t\treturn 0;\n\t}\n\n\t\n\tvarlen = strlen(argv[1]);\n\tvallen = strlen(argv[2]);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn kdb_envbuffull;\n\n\tsprintf(ep, \"", "921": "\",\n\t\t\t\t   (hwirq < domain->revmap_size) ? \"", "922": "\",\n\t\t\t\t   direct ? \"", "923": "\",\n\t\t\t\t   trace_boot_clock);\n\t}\n\n\t\n\tglobal_trace.current_trace = &nop_trace;\n\n\tglobal_trace.max_lock = (arch_spinlock_t)__arch_spin_lock_unlocked;\n\n\tftrace_init_global_array_ops(&global_trace);\n\n\tregister_tracer(&nop_trace);\n\n\t\n\ttracing_disabled = 0;\n\n\tatomic_notifier_chain_register(&panic_notifier_list,\n\t\t\t\t       &trace_panic_notifier);\n\n\tregister_die_notifier(&trace_die_notifier);\n\n\tglobal_trace.flags = trace_array_fl_global;\n\n\tinit_list_head(&global_trace.systems);\n\tinit_list_head(&global_trace.events);\n\tlist_add(&global_trace.list, &ftrace_trace_arrays);\n\n\twhile (trace_boot_options) {\n\t\tchar *option;\n\n\t\toption = strsep(&trace_boot_options, \"", "924": "\",\n\t\t\t\t current->comm, task_pid_nr(current));\n\t\t\treturn 0;\n\t\t}\n\t\treturn -eperm;\n\t}\n\treturn security_syslog(type);\n}\n\n\n\nstruct devkmsg_user {\n\tu64 seq;\n\tu32 idx;\n\tenum log_flags prev;\n\tstruct mutex lock;\n\tchar buf[8192];\n};\n\nstatic ssize_t devkmsg_write(struct kiocb *iocb, struct iov_iter *from)\n{\n\tchar *buf, *line;\n\tint i;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t\n\tsize_t len = iov_iter_count(from);\n\tssize_t ret = len;\n\n\tif (len > log_line_max)\n\t\treturn -einval;\n\tbuf = kmalloc(len+1, gfp_kernel);\n\tif (buf == null)\n\t\treturn -enomem;\n\n\tbuf[len] = '\\0';\n\tif (copy_from_iter(buf, len, from) != len) {\n\t\tkfree(buf);\n\t\treturn -efault;\n\t}\n\n\t\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = null;\n\n\t\ti = simple_strtoul(line+1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = i & 7;\n\t\t\tif (i >> 3)\n\t\t\t\tfacility = i >> 3;\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\n\tprintk_emit(facility, level, null, 0, \"", "925": "\",\n\t\t\t\t entry->pid, iter->cpu, iter->ts);\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn trace_type_partial_line;\n\n\tevent = ftrace_find_event(entry->type);\n\tif (event)\n\t\treturn event->funcs->raw(iter, 0, event);\n\n\ttrace_seq_printf(s, \"", "926": "\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"", "927": "\",\n\t\t\t\t iter->cpu, iter->lost_events);\n\t\tif (trace_seq_has_overflowed(&iter->seq))\n\t\t\treturn trace_type_partial_line;\n\t}\n\n\tif (iter->trace && iter->trace->print_line) {\n\t\tret = iter->trace->print_line(iter);\n\t\tif (ret != trace_type_unhandled)\n\t\t\treturn ret;\n\t}\n\n\tif (iter->ent->type == trace_bputs &&\n\t\t\ttrace_flags & trace_iter_printk &&\n\t\t\ttrace_flags & trace_iter_printk_msgonly)\n\t\treturn trace_print_bputs_msg_only(iter);\n\n\tif (iter->ent->type == trace_bprint &&\n\t\t\ttrace_flags & trace_iter_printk &&\n\t\t\ttrace_flags & trace_iter_printk_msgonly)\n\t\treturn trace_print_bprintk_msg_only(iter);\n\n\tif (iter->ent->type == trace_print &&\n\t\t\ttrace_flags & trace_iter_printk &&\n\t\t\ttrace_flags & trace_iter_printk_msgonly)\n\t\treturn trace_print_printk_msg_only(iter);\n\n\tif (trace_flags & trace_iter_bin)\n\t\treturn print_bin_fmt(iter);\n\n\tif (trace_flags & trace_iter_hex)\n\t\treturn print_hex_fmt(iter);\n\n\tif (trace_flags & trace_iter_raw)\n\t\treturn print_raw_fmt(iter);\n\n\treturn print_trace_fmt(iter);\n}\n\nvoid trace_latency_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\n\t\n\tif (trace_empty(iter))\n\t\treturn;\n\n\tif (iter->iter_flags & trace_file_lat_fmt)\n\t\tprint_trace_header(m, iter);\n\n\tif (!(trace_flags & trace_iter_verbose))\n\t\tprint_lat_help_header(m);\n}\n\nvoid trace_default_header(struct seq_file *m)\n{\n\tstruct trace_iterator *iter = m->private;\n\n\tif (!(trace_flags & trace_iter_context_info))\n\t\treturn;\n\n\tif (iter->iter_flags & trace_file_lat_fmt) {\n\t\t\n\t\tif (trace_empty(iter))\n\t\t\treturn;\n\t\tprint_trace_header(m, iter);\n\t\tif (!(trace_flags & trace_iter_verbose))\n\t\t\tprint_lat_help_header(m);\n\t} else {\n\t\tif (!(trace_flags & trace_iter_verbose)) {\n\t\t\tif (trace_flags & trace_iter_irq_info)\n\t\t\t\tprint_func_help_header_irq(iter->trace_buffer, m);\n\t\t\telse\n\t\t\t\tprint_func_help_header(iter->trace_buffer, m);\n\t\t}\n\t}\n}\n\nstatic void test_ftrace_alive(struct seq_file *m)\n{\n\tif (!ftrace_is_dead())\n\t\treturn;\n\tseq_puts(m, \"", "928": "\",\n\t\t\t\tcs->name, csnow, cslast, cs->mask);\n\t\t\t__clocksource_unstable(cs);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!(cs->flags & clock_source_valid_for_hres) &&\n\t\t    (cs->flags & clock_source_is_continuous) &&\n\t\t    (watchdog->flags & clock_source_is_continuous)) {\n\t\t\t\n\t\t\tcs->flags |= clock_source_valid_for_hres;\n\n\t\t\t\n\t\t\tif (!finished_booting)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tif (cs != curr_clocksource) {\n\t\t\t\tcs->flags |= clock_source_reselect;\n\t\t\t\tschedule_work(&watchdog_work);\n\t\t\t} else {\n\t\t\t\ttick_clock_notify();\n\t\t\t}\n\t\t}\n\t}\n\n\t\n\tif (reset_pending)\n\t\tatomic_dec(&watchdog_reset_pending);\n\n\t\n\tnext_cpu = cpumask_next(raw_smp_processor_id(), cpu_online_mask);\n\tif (next_cpu >= nr_cpu_ids)\n\t\tnext_cpu = cpumask_first(cpu_online_mask);\n\twatchdog_timer.expires += watchdog_interval;\n\tadd_timer_on(&watchdog_timer, next_cpu);\nout:\n\tspin_unlock(&watchdog_lock);\n}\n\nstatic inline void clocksource_start_watchdog(void)\n{\n\tif (watchdog_running || !watchdog || list_empty(&watchdog_list))\n\t\treturn;\n\tinit_timer(&watchdog_timer);\n\twatchdog_timer.function = clocksource_watchdog;\n\twatchdog_timer.expires = jiffies + watchdog_interval;\n\tadd_timer_on(&watchdog_timer, cpumask_first(cpu_online_mask));\n\twatchdog_running = 1;\n}\n\nstatic inline void clocksource_stop_watchdog(void)\n{\n\tif (!watchdog_running || (watchdog && !list_empty(&watchdog_list)))\n\t\treturn;\n\tdel_timer(&watchdog_timer);\n\twatchdog_running = 0;\n}\n\nstatic inline void clocksource_reset_watchdog(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &watchdog_list, wd_list)\n\t\tcs->flags &= ~clock_source_watchdog;\n}\n\nstatic void clocksource_resume_watchdog(void)\n{\n\tatomic_inc(&watchdog_reset_pending);\n}\n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (cs->flags & clock_source_must_verify) {\n\t\t\n\t\tlist_add(&cs->wd_list, &watchdog_list);\n\t\tcs->flags &= ~clock_source_watchdog;\n\t} else {\n\t\t\n\t\tif (cs->flags & clock_source_is_continuous)\n\t\t\tcs->flags |= clock_source_valid_for_hres;\n\t\t\n\t\tif (!watchdog || cs->rating > watchdog->rating) {\n\t\t\twatchdog = cs;\n\t\t\t\n\t\t\tclocksource_reset_watchdog();\n\t\t}\n\t}\n\t\n\tclocksource_start_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}\n\nstatic void clocksource_dequeue_watchdog(struct clocksource *cs)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tif (cs != watchdog) {\n\t\tif (cs->flags & clock_source_must_verify) {\n\t\t\t\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\t\n\t\t\tclocksource_stop_watchdog();\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n}\n\nstatic int __clocksource_watchdog_kthread(void)\n{\n\tstruct clocksource *cs, *tmp;\n\tunsigned long flags;\n\tlist_head(unstable);\n\tint select = 0;\n\n\tspin_lock_irqsave(&watchdog_lock, flags);\n\tlist_for_each_entry_safe(cs, tmp, &watchdog_list, wd_list) {\n\t\tif (cs->flags & clock_source_unstable) {\n\t\t\tlist_del_init(&cs->wd_list);\n\t\t\tlist_add(&cs->wd_list, &unstable);\n\t\t\tselect = 1;\n\t\t}\n\t\tif (cs->flags & clock_source_reselect) {\n\t\t\tcs->flags &= ~clock_source_reselect;\n\t\t\tselect = 1;\n\t\t}\n\t}\n\t\n\tclocksource_stop_watchdog();\n\tspin_unlock_irqrestore(&watchdog_lock, flags);\n\n\t\n\tlist_for_each_entry_safe(cs, tmp, &unstable, wd_list) {\n\t\tlist_del_init(&cs->wd_list);\n\t\t__clocksource_change_rating(cs, 0);\n\t}\n\treturn select;\n}\n\nstatic int clocksource_watchdog_kthread(void *data)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (__clocksource_watchdog_kthread())\n\t\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}\n\nstatic bool clocksource_is_watchdog(struct clocksource *cs)\n{\n\treturn cs == watchdog;\n}\n\n#else \n\nstatic void clocksource_enqueue_watchdog(struct clocksource *cs)\n{\n\tif (cs->flags & clock_source_is_continuous)\n\t\tcs->flags |= clock_source_valid_for_hres;\n}\n\nstatic inline void clocksource_dequeue_watchdog(struct clocksource *cs) { }\nstatic inline void clocksource_resume_watchdog(void) { }\nstatic inline int __clocksource_watchdog_kthread(void) { return 0; }\nstatic bool clocksource_is_watchdog(struct clocksource *cs) { return false; }\nvoid clocksource_mark_unstable(struct clocksource *cs) { }\n\n#endif \n\n\nvoid clocksource_suspend(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry_reverse(cs, &clocksource_list, list)\n\t\tif (cs->suspend)\n\t\t\tcs->suspend(cs);\n}\n\n\nvoid clocksource_resume(void)\n{\n\tstruct clocksource *cs;\n\n\tlist_for_each_entry(cs, &clocksource_list, list)\n\t\tif (cs->resume)\n\t\t\tcs->resume(cs);\n\n\tclocksource_resume_watchdog();\n}\n\n\nvoid clocksource_touch_watchdog(void)\n{\n\tclocksource_resume_watchdog();\n}\n\n\nstatic u32 clocksource_max_adjustment(struct clocksource *cs)\n{\n\tu64 ret;\n\t\n\tret = (u64)cs->mult * 11;\n\tdo_div(ret,100);\n\treturn (u32)ret;\n}\n\n\nu64 clocks_calc_max_nsecs(u32 mult, u32 shift, u32 maxadj, u64 mask, u64 *max_cyc)\n{\n\tu64 max_nsecs, max_cycles;\n\n\t\n\tmax_cycles = ullong_max;\n\tdo_div(max_cycles, mult+maxadj);\n\n\t\n\tmax_cycles = min(max_cycles, mask);\n\tmax_nsecs = clocksource_cyc2ns(max_cycles, mult - maxadj, shift);\n\n\t\n\tif (max_cyc)\n\t\t*max_cyc = max_cycles;\n\n\t\n\tmax_nsecs >>= 1;\n\n\treturn max_nsecs;\n}\n\n\nstatic inline void clocksource_update_max_deferment(struct clocksource *cs)\n{\n\tcs->max_idle_ns = clocks_calc_max_nsecs(cs->mult, cs->shift,\n\t\t\t\t\t\tcs->maxadj, cs->mask,\n\t\t\t\t\t\t&cs->max_cycles);\n}\n\n#ifndef config_arch_uses_gettimeoffset\n\nstatic struct clocksource *clocksource_find_best(bool oneshot, bool skipcur)\n{\n\tstruct clocksource *cs;\n\n\tif (!finished_booting || list_empty(&clocksource_list))\n\t\treturn null;\n\n\t\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (oneshot && !(cs->flags & clock_source_valid_for_hres))\n\t\t\tcontinue;\n\t\treturn cs;\n\t}\n\treturn null;\n}\n\nstatic void __clocksource_select(bool skipcur)\n{\n\tbool oneshot = tick_oneshot_mode_active();\n\tstruct clocksource *best, *cs;\n\n\t\n\tbest = clocksource_find_best(oneshot, skipcur);\n\tif (!best)\n\t\treturn;\n\n\t\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (skipcur && cs == curr_clocksource)\n\t\t\tcontinue;\n\t\tif (strcmp(cs->name, override_name) != 0)\n\t\t\tcontinue;\n\t\t\n\t\tif (!(cs->flags & clock_source_valid_for_hres) && oneshot) {\n\t\t\t\n\t\t\tprintk(kern_warning \"", "929": "\",\n\t\t\t\tentry->count, entry->pid, entry->comm);\n\t\t}\n\n\t\tprint_name_offset(m, (unsigned long)entry->start_func);\n\t\tseq_puts(m, \"", "930": "\",\n\t\t\t\tentry->count, entry->pid, entry->comm);\n\t\t} else {\n\t\t\tseq_printf(m, \"", "931": "\",\n\t\t\t\titer->cpu);\n}\n\nstatic enum print_line_t print_trace_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned long sym_flags = (trace_flags & trace_iter_sym_mask);\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\ttest_cpu_buff_start(iter);\n\n\tevent = ftrace_find_event(entry->type);\n\n\tif (trace_flags & trace_iter_context_info) {\n\t\tif (iter->iter_flags & trace_file_lat_fmt)\n\t\t\ttrace_print_lat_context(iter);\n\t\telse\n\t\t\ttrace_print_context(iter);\n\t}\n\n\tif (trace_seq_has_overflowed(s))\n\t\treturn trace_type_partial_line;\n\n\tif (event)\n\t\treturn event->funcs->trace(iter, sym_flags, event);\n\n\ttrace_seq_printf(s, \"", "932": "\",\n\t\t\t\tpm_test_delay);\n\t\tmdelay(pm_test_delay * 1000);\n\t\treturn 1;\n\t}\n#endif \n\treturn 0;\n}\n\n\nstatic int suspend_prepare(suspend_state_t state)\n{\n\tint error;\n\n\tif (!sleep_state_supported(state))\n\t\treturn -eperm;\n\n\tpm_prepare_console();\n\n\terror = pm_notifier_call_chain(pm_suspend_prepare);\n\tif (error)\n\t\tgoto finish;\n\n\ttrace_suspend_resume(tps(\"", "933": "\",\n\t\t\t\tring_buffer_oldest_event_ts(trace_buf->buffer, cpu));\n\n\t\ttrace_seq_printf(s, \"", "934": "\",\n\t\t\t\tring_buffer_time_stamp(trace_buf->buffer, cpu));\n\t}\n\n\tcnt = ring_buffer_dropped_events_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"", "935": "\",\n\t\t\t\ttsk->comm, task_pid_nr(tsk));\n\t\t\t__group_send_sig_info(sigxcpu, send_sig_priv, tsk);\n\t\t}\n\t}\n}\n\nstatic void stop_process_timers(struct signal_struct *sig)\n{\n\tstruct thread_group_cputimer *cputimer = &sig->cputimer;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cputimer->lock, flags);\n\tcputimer->running = 0;\n\traw_spin_unlock_irqrestore(&cputimer->lock, flags);\n}\n\nstatic u32 onecputick;\n\nstatic void check_cpu_itimer(struct task_struct *tsk, struct cpu_itimer *it,\n\t\t\t     unsigned long long *expires,\n\t\t\t     unsigned long long cur_time, int signo)\n{\n\tif (!it->expires)\n\t\treturn;\n\n\tif (cur_time >= it->expires) {\n\t\tif (it->incr) {\n\t\t\tit->expires += it->incr;\n\t\t\tit->error += it->incr_error;\n\t\t\tif (it->error >= onecputick) {\n\t\t\t\tit->expires -= cputime_one_jiffy;\n\t\t\t\tit->error -= onecputick;\n\t\t\t}\n\t\t} else {\n\t\t\tit->expires = 0;\n\t\t}\n\n\t\ttrace_itimer_expire(signo == sigprof ?\n\t\t\t\t    itimer_prof : itimer_virtual,\n\t\t\t\t    tsk->signal->leader_pid, cur_time);\n\t\t__group_send_sig_info(signo, send_sig_priv, tsk);\n\t}\n\n\tif (it->expires && (!*expires || it->expires < *expires)) {\n\t\t*expires = it->expires;\n\t}\n}\n\n\nstatic void check_process_timers(struct task_struct *tsk,\n\t\t\t\t struct list_head *firing)\n{\n\tstruct signal_struct *const sig = tsk->signal;\n\tunsigned long long utime, ptime, virt_expires, prof_expires;\n\tunsigned long long sum_sched_runtime, sched_expires;\n\tstruct list_head *timers = sig->cpu_timers;\n\tstruct task_cputime cputime;\n\tunsigned long soft;\n\n\t\n\tthread_group_cputimer(tsk, &cputime);\n\tutime = cputime_to_expires(cputime.utime);\n\tptime = utime + cputime_to_expires(cputime.stime);\n\tsum_sched_runtime = cputime.sum_exec_runtime;\n\n\tprof_expires = check_timers_list(timers, firing, ptime);\n\tvirt_expires = check_timers_list(++timers, firing, utime);\n\tsched_expires = check_timers_list(++timers, firing, sum_sched_runtime);\n\n\t\n\tcheck_cpu_itimer(tsk, &sig->it[cpuclock_prof], &prof_expires, ptime,\n\t\t\t sigprof);\n\tcheck_cpu_itimer(tsk, &sig->it[cpuclock_virt], &virt_expires, utime,\n\t\t\t sigvtalrm);\n\tsoft = access_once(sig->rlim[rlimit_cpu].rlim_cur);\n\tif (soft != rlim_infinity) {\n\t\tunsigned long psecs = cputime_to_secs(ptime);\n\t\tunsigned long hard =\n\t\t\taccess_once(sig->rlim[rlimit_cpu].rlim_max);\n\t\tcputime_t x;\n\t\tif (psecs >= hard) {\n\t\t\t\n\t\t\t__group_send_sig_info(sigkill, send_sig_priv, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (psecs >= soft) {\n\t\t\t\n\t\t\t__group_send_sig_info(sigxcpu, send_sig_priv, tsk);\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft++;\n\t\t\t\tsig->rlim[rlimit_cpu].rlim_cur = soft;\n\t\t\t}\n\t\t}\n\t\tx = secs_to_cputime(soft);\n\t\tif (!prof_expires || x < prof_expires) {\n\t\t\tprof_expires = x;\n\t\t}\n\t}\n\n\tsig->cputime_expires.prof_exp = expires_to_cputime(prof_expires);\n\tsig->cputime_expires.virt_exp = expires_to_cputime(virt_expires);\n\tsig->cputime_expires.sched_exp = sched_expires;\n\tif (task_cputime_zero(&sig->cputime_expires))\n\t\tstop_process_timers(sig);\n}\n\n\nvoid posix_cpu_timer_schedule(struct k_itimer *timer)\n{\n\tstruct sighand_struct *sighand;\n\tunsigned long flags;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tunsigned long long now;\n\n\twarn_on_once(p == null);\n\n\t\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\tif (unlikely(p->exit_state))\n\t\t\tgoto out;\n\n\t\t\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (!sighand)\n\t\t\tgoto out;\n\t} else {\n\t\t\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == null)) {\n\t\t\t\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\tgoto out;\n\t\t} else if (unlikely(p->exit_state) && thread_group_empty(p)) {\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t\t\n\t\t\tgoto out;\n\t\t}\n\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\tbump_cpu_timer(timer, now);\n\t\t\n\t}\n\n\t\n\twarn_on_once(!irqs_disabled());\n\tarm_timer(timer);\n\tunlock_task_sighand(p, &flags);\n\n\t\n\tposix_cpu_timer_kick_nohz();\nout:\n\ttimer->it_overrun_last = timer->it_overrun;\n\ttimer->it_overrun = -1;\n\t++timer->it_requeue_pending;\n}\n\n\nstatic inline int task_cputime_expired(const struct task_cputime *sample,\n\t\t\t\t\tconst struct task_cputime *expires)\n{\n\tif (expires->utime && sample->utime >= expires->utime)\n\t\treturn 1;\n\tif (expires->stime && sample->utime + sample->stime >= expires->stime)\n\t\treturn 1;\n\tif (expires->sum_exec_runtime != 0 &&\n\t    sample->sum_exec_runtime >= expires->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}\n\n\nstatic inline int fastpath_timer_check(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig;\n\tcputime_t utime, stime;\n\n\ttask_cputime(tsk, &utime, &stime);\n\n\tif (!task_cputime_zero(&tsk->cputime_expires)) {\n\t\tstruct task_cputime task_sample = {\n\t\t\t.utime = utime,\n\t\t\t.stime = stime,\n\t\t\t.sum_exec_runtime = tsk->se.sum_exec_runtime\n\t\t};\n\n\t\tif (task_cputime_expired(&task_sample, &tsk->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\tsig = tsk->signal;\n\tif (sig->cputimer.running) {\n\t\tstruct task_cputime group_sample;\n\n\t\traw_spin_lock(&sig->cputimer.lock);\n\t\tgroup_sample = sig->cputimer.cputime;\n\t\traw_spin_unlock(&sig->cputimer.lock);\n\n\t\tif (task_cputime_expired(&group_sample, &sig->cputime_expires))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\n\nvoid run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tlist_head(firing);\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags;\n\n\twarn_on_once(!irqs_disabled());\n\n\t\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\t\n\tcheck_thread_timers(tsk, &firing);\n\t\n\tif (tsk->signal->cputimer.running)\n\t\tcheck_process_timers(tsk, &firing);\n\n\t\n\tunlock_task_sighand(tsk, &flags);\n\n\t\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint cpu_firing;\n\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}\n\n\nvoid set_process_cpu_timer(struct task_struct *tsk, unsigned int clock_idx,\n\t\t\t   cputime_t *newval, cputime_t *oldval)\n{\n\tunsigned long long now;\n\n\twarn_on_once(clock_idx == cpuclock_sched);\n\tcpu_timer_sample_group(clock_idx, tsk, &now);\n\n\tif (oldval) {\n\t\t\n\t\tif (*oldval) {\n\t\t\tif (*oldval <= now) {\n\t\t\t\t\n\t\t\t\t*oldval = cputime_one_jiffy;\n\t\t\t} else {\n\t\t\t\t*oldval -= now;\n\t\t\t}\n\t\t}\n\n\t\tif (!*newval)\n\t\t\tgoto out;\n\t\t*newval += now;\n\t}\n\n\t\n\tswitch (clock_idx) {\n\tcase cpuclock_prof:\n\t\tif (expires_gt(tsk->signal->cputime_expires.prof_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.prof_exp = *newval;\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\tif (expires_gt(tsk->signal->cputime_expires.virt_exp, *newval))\n\t\t\ttsk->signal->cputime_expires.virt_exp = *newval;\n\t\tbreak;\n\t}\nout:\n\tposix_cpu_timer_kick_nohz();\n}\n\nstatic int do_cpu_nanosleep(const clockid_t which_clock, int flags,\n\t\t\t    struct timespec *rqtp, struct itimerspec *it)\n{\n\tstruct k_itimer timer;\n\tint error;\n\n\t\n\tmemset(&timer, 0, sizeof timer);\n\tspin_lock_init(&timer.it_lock);\n\ttimer.it_clock = which_clock;\n\ttimer.it_overrun = -1;\n\terror = posix_cpu_timer_create(&timer);\n\ttimer.it_process = current;\n\tif (!error) {\n\t\tstatic struct itimerspec zero_it;\n\n\t\tmemset(it, 0, sizeof *it);\n\t\tit->it_value = *rqtp;\n\n\t\tspin_lock_irq(&timer.it_lock);\n\t\terror = posix_cpu_timer_set(&timer, flags, it, null);\n\t\tif (error) {\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\treturn error;\n\t\t}\n\n\t\twhile (!signal_pending(current)) {\n\t\t\tif (timer.it.cpu.expires == 0) {\n\t\t\t\t\n\t\t\t\tposix_cpu_timer_del(&timer);\n\t\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t\n\t\t\t__set_current_state(task_interruptible);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t\tschedule();\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t}\n\n\t\t\n\t\tsample_to_timespec(which_clock, timer.it.cpu.expires, rqtp);\n\t\terror = posix_cpu_timer_set(&timer, 0, &zero_it, it);\n\t\tif (!error) {\n\t\t\t\n\t\t\tposix_cpu_timer_del(&timer);\n\t\t}\n\t\tspin_unlock_irq(&timer.it_lock);\n\n\t\twhile (error == timer_retry) {\n\t\t\t\n\t\t\tspin_lock_irq(&timer.it_lock);\n\t\t\terror = posix_cpu_timer_del(&timer);\n\t\t\tspin_unlock_irq(&timer.it_lock);\n\t\t}\n\n\t\tif ((it->it_value.tv_sec | it->it_value.tv_nsec) == 0) {\n\t\t\t\n\t\t\treturn 0;\n\t\t}\n\n\t\terror = -erestart_restartblock;\n\t}\n\n\treturn error;\n}\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block);\n\nstatic int posix_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t    struct timespec *rqtp, struct timespec __user *rmtp)\n{\n\tstruct restart_block *restart_block = &current->restart_block;\n\tstruct itimerspec it;\n\tint error;\n\n\t\n\tif (cpuclock_perthread(which_clock) &&\n\t    (cpuclock_pid(which_clock) == 0 ||\n\t     cpuclock_pid(which_clock) == current->pid))\n\t\treturn -einval;\n\n\terror = do_cpu_nanosleep(which_clock, flags, rqtp, &it);\n\n\tif (error == -erestart_restartblock) {\n\n\t\tif (flags & timer_abstime)\n\t\t\treturn -erestartnohand;\n\t\t\n\t\tif (rmtp && copy_to_user(rmtp, &it.it_value, sizeof *rmtp))\n\t\t\treturn -efault;\n\n\t\trestart_block->fn = posix_cpu_nsleep_restart;\n\t\trestart_block->nanosleep.clockid = which_clock;\n\t\trestart_block->nanosleep.rmtp = rmtp;\n\t\trestart_block->nanosleep.expires = timespec_to_ns(rqtp);\n\t}\n\treturn error;\n}\n\nstatic long posix_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\tclockid_t which_clock = restart_block->nanosleep.clockid;\n\tstruct timespec t;\n\tstruct itimerspec it;\n\tint error;\n\n\tt = ns_to_timespec(restart_block->nanosleep.expires);\n\n\terror = do_cpu_nanosleep(which_clock, timer_abstime, &t, &it);\n\n\tif (error == -erestart_restartblock) {\n\t\tstruct timespec __user *rmtp = restart_block->nanosleep.rmtp;\n\t\t\n\t\tif (rmtp && copy_to_user(rmtp, &it.it_value, sizeof *rmtp))\n\t\t\treturn -efault;\n\n\t\trestart_block->nanosleep.expires = timespec_to_ns(&t);\n\t}\n\treturn error;\n\n}\n\n#define process_clock\tmake_process_cpuclock(0, cpuclock_sched)\n#define thread_clock\tmake_thread_cpuclock(0, cpuclock_sched)\n\nstatic int process_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t    struct timespec *tp)\n{\n\treturn posix_cpu_clock_getres(process_clock, tp);\n}\nstatic int process_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\t struct timespec *tp)\n{\n\treturn posix_cpu_clock_get(process_clock, tp);\n}\nstatic int process_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = process_clock;\n\treturn posix_cpu_timer_create(timer);\n}\nstatic int process_cpu_nsleep(const clockid_t which_clock, int flags,\n\t\t\t      struct timespec *rqtp,\n\t\t\t      struct timespec __user *rmtp)\n{\n\treturn posix_cpu_nsleep(process_clock, flags, rqtp, rmtp);\n}\nstatic long process_cpu_nsleep_restart(struct restart_block *restart_block)\n{\n\treturn -einval;\n}\nstatic int thread_cpu_clock_getres(const clockid_t which_clock,\n\t\t\t\t   struct timespec *tp)\n{\n\treturn posix_cpu_clock_getres(thread_clock, tp);\n}\nstatic int thread_cpu_clock_get(const clockid_t which_clock,\n\t\t\t\tstruct timespec *tp)\n{\n\treturn posix_cpu_clock_get(thread_clock, tp);\n}\nstatic int thread_cpu_timer_create(struct k_itimer *timer)\n{\n\ttimer->it_clock = thread_clock;\n\treturn posix_cpu_timer_create(timer);\n}\n\nstruct k_clock clock_posix_cpu = {\n\t.clock_getres\t= posix_cpu_clock_getres,\n\t.clock_set\t= posix_cpu_clock_set,\n\t.clock_get\t= posix_cpu_clock_get,\n\t.timer_create\t= posix_cpu_timer_create,\n\t.nsleep\t\t= posix_cpu_nsleep,\n\t.nsleep_restart\t= posix_cpu_nsleep_restart,\n\t.timer_set\t= posix_cpu_timer_set,\n\t.timer_del\t= posix_cpu_timer_del,\n\t.timer_get\t= posix_cpu_timer_get,\n};\n\nstatic __init int init_posix_cpu_timers(void)\n{\n\tstruct k_clock process = {\n\t\t.clock_getres\t= process_cpu_clock_getres,\n\t\t.clock_get\t= process_cpu_clock_get,\n\t\t.timer_create\t= process_cpu_timer_create,\n\t\t.nsleep\t\t= process_cpu_nsleep,\n\t\t.nsleep_restart\t= process_cpu_nsleep_restart,\n\t};\n\tstruct k_clock thread = {\n\t\t.clock_getres\t= thread_cpu_clock_getres,\n\t\t.clock_get\t= thread_cpu_clock_get,\n\t\t.timer_create\t= thread_cpu_timer_create,\n\t};\n\tstruct timespec ts;\n\n\tposix_timers_register_clock(clock_process_cputime_id, &process);\n\tposix_timers_register_clock(clock_thread_cputime_id, &thread);\n\n\tcputime_to_timespec(cputime_one_jiffy, &ts);\n\tonecputick = ts.tv_nsec;\n\twarn_on(ts.tv_sec != 0);\n\n\treturn 0;\n}\n__initcall(init_posix_cpu_timers);\n\n\n#include <linux/export.h>\n#include <linux/uts.h>\n#include <linux/utsname.h>\n#include <linux/sysctl.h>\n#include <linux/wait.h>\n\n#ifdef config_proc_sysctl\n\nstatic void *get_uts(struct ctl_table *table, int write)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\tif (!write)\n\t\tdown_read(&uts_sem);\n\telse\n\t\tdown_write(&uts_sem);\n\treturn which;\n}\n\nstatic void put_uts(struct ctl_table *table, int write, void *which)\n{\n\tif (!write)\n\t\tup_read(&uts_sem);\n\telse\n\t\tup_write(&uts_sem);\n}\n\n\nstatic int proc_do_uts_string(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table uts_table;\n\tint r;\n\tmemcpy(&uts_table, table, sizeof(uts_table));\n\tuts_table.data = get_uts(table, write);\n\tr = proc_dostring(&uts_table, write, buffer, lenp, ppos);\n\tput_uts(table, write, uts_table.data);\n\n\tif (write)\n\t\tproc_sys_poll_notify(table->poll);\n\n\treturn r;\n}\n#else\n#define proc_do_uts_string null\n#endif\n\nstatic define_ctl_table_poll(hostname_poll);\nstatic define_ctl_table_poll(domainname_poll);\n\nstatic struct ctl_table uts_kern_table[] = {\n\t{\n\t\t.procname\t= \"", "936": "\",\n\t\t\t\twatchdog->name, wdnow, wdlast, watchdog->mask);\n\t\t\tpr_warn(\"", "937": "\",\n\t\t\t       event->type);\n\t\t\twarn_on_once(1);\n\t\t}\n\t}\n\n\treturn 0;\n}\nearly_initcall(init_events);\n\n#ifndef _kernel_workqueue_internal_h\n#define _kernel_workqueue_internal_h\n\n#include <linux/workqueue.h>\n#include <linux/kthread.h>\n\nstruct worker_pool;\n\n\nstruct worker {\n\t\n\tunion {\n\t\tstruct list_head\tentry;\t\n\t\tstruct hlist_node\thentry;\t\n\t};\n\n\tstruct work_struct\t*current_work;\t\n\twork_func_t\t\tcurrent_func;\t\n\tstruct pool_workqueue\t*current_pwq; \n\tbool\t\t\tdesc_valid;\t\n\tstruct list_head\tscheduled;\t\n\n\t\n\n\tstruct task_struct\t*task;\t\t\n\tstruct worker_pool\t*pool;\t\t\n\t\t\t\t\t\t\n\tstruct list_head\tnode;\t\t\n\t\t\t\t\t\t\n\n\tunsigned long\t\tlast_active;\t\n\tunsigned int\t\tflags;\t\t\n\tint\t\t\tid;\t\t\n\n\t\n\tchar\t\t\tdesc[worker_desc_len];\n\n\t\n\tstruct workqueue_struct\t*rescue_wq;\t\n};\n\n\nstatic inline struct worker *current_wq_worker(void)\n{\n\tif (current->flags & pf_wq_worker)\n\t\treturn kthread_data(current);\n\treturn null;\n}\n\n\nvoid wq_worker_waking_up(struct task_struct *task, int cpu);\nstruct task_struct *wq_worker_sleeping(struct task_struct *task, int cpu);\n\n#endif \n\n#include <linux/cpu.h>\n#include <linux/err.h>\n#include <linux/hrtimer.h>\n#include <linux/interrupt.h>\n#include <linux/percpu.h>\n#include <linux/profile.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#include <asm/irq_regs.h>\n\n#include \"", "938": "\",\n\t\t\t     avg_local_sample_len, allowed_ns >> 1,\n\t\t\t     sysctl_perf_event_sample_rate);\n\t}\n}\n\nstatic atomic64_t perf_event_id;\n\nstatic void cpu_ctx_sched_out(struct perf_cpu_context *cpuctx,\n\t\t\t      enum event_type_t event_type);\n\nstatic void cpu_ctx_sched_in(struct perf_cpu_context *cpuctx,\n\t\t\t     enum event_type_t event_type,\n\t\t\t     struct task_struct *task);\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\n\nvoid __weak perf_event_print_debug(void)\t{ }\n\nextern __weak const char *perf_pmu_name(void)\n{\n\treturn \"", "939": "\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn kdb_notimp;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, gfp_kdb);\n\tkfree(save_command);\n\treturn 0;\n}\n\nstatic int kdb_defcmd(int argc, const char **argv)\n{\n\tstruct defcmd_set *save_defcmd_set = defcmd_set, *s;\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"", "940": "\",\n\t\t\t   domain == irq_default_domain ? '*' : ' ', domain->name,\n\t\t\t   domain->revmap_size + count, domain->revmap_size,\n\t\t\t   domain->revmap_direct_max_irq,\n\t\t\t   domain->of_node ? of_node_full_name(domain->of_node) : \"", "941": "\",\n\t\t\t   events, events * 1000 / ms,\n\t\t\t   (events * 1000000 / ms) % 1000);\n\telse\n\t\tseq_printf(m, \"", "942": "\",\n\t\t\t   ftrace_rec_count(rec),\n\t\t\t   rec->flags & ftrace_fl_regs ? \"", "943": "\",\n\t\t\t   rec->flags & ftrace_fl_ipmodify ? \"", "944": "\",\n\t\t\t  iter->ent->type);\n\t}\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\n\t\n\tsret = trace_seq_to_user(&iter->seq, ubuf, cnt);\n\tif (iter->seq.seq.readpos >= trace_seq_used(&iter->seq))\n\t\ttrace_seq_init(&iter->seq);\n\n\t\n\tif (sret == -ebusy)\n\t\tgoto waitagain;\n\nout:\n\tmutex_unlock(&iter->mutex);\n\n\treturn sret;\n}\n\nstatic void tracing_spd_release_pipe(struct splice_pipe_desc *spd,\n\t\t\t\t     unsigned int idx)\n{\n\t__free_page(spd->pages[idx]);\n}\n\nstatic const struct pipe_buf_operations tracing_pipe_buf_ops = {\n\t.can_merge\t\t= 0,\n\t.confirm\t\t= generic_pipe_buf_confirm,\n\t.release\t\t= generic_pipe_buf_release,\n\t.steal\t\t\t= generic_pipe_buf_steal,\n\t.get\t\t\t= generic_pipe_buf_get,\n};\n\nstatic size_t\ntracing_fill_pipe_page(size_t rem, struct trace_iterator *iter)\n{\n\tsize_t count;\n\tint save_len;\n\tint ret;\n\n\t\n\tfor (;;) {\n\t\tsave_len = iter->seq.seq.len;\n\t\tret = print_trace_line(iter);\n\n\t\tif (trace_seq_has_overflowed(&iter->seq)) {\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\t\tif (ret == trace_type_partial_line) {\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tcount = trace_seq_used(&iter->seq) - save_len;\n\t\tif (rem < count) {\n\t\t\trem = 0;\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (ret != trace_type_no_consume)\n\t\t\ttrace_consume(iter);\n\t\trem -= count;\n\t\tif (!trace_find_next_entry_inc(iter))\t{\n\t\t\trem = 0;\n\t\t\titer->ent = null;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn rem;\n}\n\nstatic ssize_t tracing_splice_read_pipe(struct file *filp,\n\t\t\t\t\tloff_t *ppos,\n\t\t\t\t\tstruct pipe_inode_info *pipe,\n\t\t\t\t\tsize_t len,\n\t\t\t\t\tunsigned int flags)\n{\n\tstruct page *pages_def[pipe_def_buffers];\n\tstruct partial_page partial_def[pipe_def_buffers];\n\tstruct trace_iterator *iter = filp->private_data;\n\tstruct splice_pipe_desc spd = {\n\t\t.pages\t\t= pages_def,\n\t\t.partial\t= partial_def,\n\t\t.nr_pages\t= 0, \n\t\t.nr_pages_max\t= pipe_def_buffers,\n\t\t.flags\t\t= flags,\n\t\t.ops\t\t= &tracing_pipe_buf_ops,\n\t\t.spd_release\t= tracing_spd_release_pipe,\n\t};\n\tssize_t ret;\n\tsize_t rem;\n\tunsigned int i;\n\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -enomem;\n\n\tmutex_lock(&iter->mutex);\n\n\tif (iter->trace->splice_read) {\n\t\tret = iter->trace->splice_read(iter, filp,\n\t\t\t\t\t       ppos, pipe, len, flags);\n\t\tif (ret)\n\t\t\tgoto out_err;\n\t}\n\n\tret = tracing_wait_pipe(filp);\n\tif (ret <= 0)\n\t\tgoto out_err;\n\n\tif (!iter->ent && !trace_find_next_entry_inc(iter)) {\n\t\tret = -efault;\n\t\tgoto out_err;\n\t}\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\n\t\n\tfor (i = 0, rem = len; i < spd.nr_pages_max && rem; i++) {\n\t\tspd.pages[i] = alloc_page(gfp_kernel);\n\t\tif (!spd.pages[i])\n\t\t\tbreak;\n\n\t\trem = tracing_fill_pipe_page(rem, iter);\n\n\t\t\n\t\tret = trace_seq_to_buffer(&iter->seq,\n\t\t\t\t\t  page_address(spd.pages[i]),\n\t\t\t\t\t  trace_seq_used(&iter->seq));\n\t\tif (ret < 0) {\n\t\t\t__free_page(spd.pages[i]);\n\t\t\tbreak;\n\t\t}\n\t\tspd.partial[i].offset = 0;\n\t\tspd.partial[i].len = trace_seq_used(&iter->seq);\n\n\t\ttrace_seq_init(&iter->seq);\n\t}\n\n\ttrace_access_unlock(iter->cpu_file);\n\ttrace_event_read_unlock();\n\tmutex_unlock(&iter->mutex);\n\n\tspd.nr_pages = i;\n\n\tret = splice_to_pipe(pipe, &spd);\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n\nout_err:\n\tmutex_unlock(&iter->mutex);\n\tgoto out;\n}\n\nstatic ssize_t\ntracing_entries_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tint cpu = tracing_get_cpu(inode);\n\tchar buf[64];\n\tint r = 0;\n\tssize_t ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu == ring_buffer_all_cpus) {\n\t\tint cpu, buf_size_same;\n\t\tunsigned long size;\n\n\t\tsize = 0;\n\t\tbuf_size_same = 1;\n\t\t\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\t\n\t\t\tif (size == 0)\n\t\t\t\tsize = per_cpu_ptr(tr->trace_buffer.data, cpu)->entries;\n\t\t\tif (size != per_cpu_ptr(tr->trace_buffer.data, cpu)->entries) {\n\t\t\t\tbuf_size_same = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (buf_size_same) {\n\t\t\tif (!ring_buffer_expanded)\n\t\t\t\tr = sprintf(buf, \"", "945": "\",\n\t\t\t ringbuf_type_padding);\n\ttrace_seq_printf(s, \"", "946": "\",\n\t\t\t ringbuf_type_time_extend);\n\ttrace_seq_printf(s, \"", "947": "\",\n\t\t\t(unsigned long long)ktime_to_ns(base->resolution));\n\tseq_printf(m,   \"", "948": "\",\n\t\t\tbase->index);\n\tseq_printf(m, \"", "949": "\",\n\t\t\tcs->name, cs->mask, cs->max_cycles, cs->max_idle_ns);\n}\nexport_symbol_gpl(__clocksource_update_freq_scale);\n\n\nint __clocksource_register_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\n\t\n\t__clocksource_update_freq_scale(cs, scale, freq);\n\n\t\n\tmutex_lock(&clocksource_mutex);\n\tclocksource_enqueue(cs);\n\tclocksource_enqueue_watchdog(cs);\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}\nexport_symbol_gpl(__clocksource_register_scale);\n\nstatic void __clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tlist_del(&cs->list);\n\tcs->rating = rating;\n\tclocksource_enqueue(cs);\n}\n\n\nvoid clocksource_change_rating(struct clocksource *cs, int rating)\n{\n\tmutex_lock(&clocksource_mutex);\n\t__clocksource_change_rating(cs, rating);\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n}\nexport_symbol(clocksource_change_rating);\n\n\nstatic int clocksource_unbind(struct clocksource *cs)\n{\n\t\n\tif (clocksource_is_watchdog(cs))\n\t\treturn -ebusy;\n\n\tif (cs == curr_clocksource) {\n\t\t\n\t\tclocksource_select_fallback();\n\t\tif (curr_clocksource == cs)\n\t\t\treturn -ebusy;\n\t}\n\tclocksource_dequeue_watchdog(cs);\n\tlist_del_init(&cs->list);\n\treturn 0;\n}\n\n\nint clocksource_unregister(struct clocksource *cs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tif (!list_empty(&cs->list))\n\t\tret = clocksource_unbind(cs);\n\tmutex_unlock(&clocksource_mutex);\n\treturn ret;\n}\nexport_symbol(clocksource_unregister);\n\n#ifdef config_sysfs\n\nstatic ssize_t\nsysfs_show_current_clocksources(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tcount = snprintf(buf, page_size, \"", "950": "\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\n\tacct_update_integrals(tsk);\n\t\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm(tsk);\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread();\n\n\t\n\tperf_event_exit_task(tsk);\n\n\tcgroup_exit(tsk);\n\n\t\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\ttasks_rcu(tasks_rcu_i = __srcu_read_lock(&tasks_rcu_exit_srcu));\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n#ifdef config_numa\n\ttask_lock(tsk);\n\tmpol_put(tsk->mempolicy);\n\ttsk->mempolicy = null;\n\ttask_unlock(tsk);\n#endif\n#ifdef config_futex\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t\n\tdebug_check_no_locks_held();\n\t\n\ttsk->flags |= pf_exitpidone;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\ttasks_rcu(__srcu_read_unlock(&tasks_rcu_exit_srcu, tasks_rcu_i));\n\n\t\n\tsmp_mb();\n\traw_spin_unlock_wait(&tsk->pi_lock);\n\n\t\n\ttsk->state = task_dead;\n\ttsk->flags |= pf_nofreeze;\t\n\tschedule();\n\tbug();\n\t\n\tfor (;;)\n\t\tcpu_relax();\t\n}\nexport_symbol_gpl(do_exit);\n\nvoid complete_and_exit(struct completion *comp, long code)\n{\n\tif (comp)\n\t\tcomplete(comp);\n\n\tdo_exit(code);\n}\nexport_symbol(complete_and_exit);\n\nsyscall_define1(exit, int, error_code)\n{\n\tdo_exit((error_code&0xff)<<8);\n}\n\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tbug_on(exit_code & 0x80); \n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = signal_group_exit;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t\n}\n\n\nsyscall_define1(exit_group, int, error_code)\n{\n\tdo_group_exit((error_code & 0xff) << 8);\n\t\n\treturn 0;\n}\n\nstruct wait_opts {\n\tenum pid_type\t\two_type;\n\tint\t\t\two_flags;\n\tstruct pid\t\t*wo_pid;\n\n\tstruct siginfo __user\t*wo_info;\n\tint __user\t\t*wo_stat;\n\tstruct rusage __user\t*wo_rusage;\n\n\twait_queue_t\t\tchild_wait;\n\tint\t\t\tnotask_error;\n};\n\nstatic inline\nstruct pid *task_pid_type(struct task_struct *task, enum pid_type type)\n{\n\tif (type != pidtype_pid)\n\t\ttask = task->group_leader;\n\treturn task->pids[type].pid;\n}\n\nstatic int eligible_pid(struct wait_opts *wo, struct task_struct *p)\n{\n\treturn\two->wo_type == pidtype_max ||\n\t\ttask_pid_type(p, wo->wo_type) == wo->wo_pid;\n}\n\nstatic int eligible_child(struct wait_opts *wo, struct task_struct *p)\n{\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\t\n\tif (((p->exit_signal != sigchld) ^ !!(wo->wo_flags & __wclone))\n\t    && !(wo->wo_flags & __wall))\n\t\treturn 0;\n\n\treturn 1;\n}\n\nstatic int wait_noreap_copyout(struct wait_opts *wo, struct task_struct *p,\n\t\t\t\tpid_t pid, uid_t uid, int why, int status)\n{\n\tstruct siginfo __user *infop;\n\tint retval = wo->wo_rusage\n\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\n\tput_task_struct(p);\n\tinfop = wo->wo_info;\n\tif (infop) {\n\t\tif (!retval)\n\t\t\tretval = put_user(sigchld, &infop->si_signo);\n\t\tif (!retval)\n\t\t\tretval = put_user(0, &infop->si_errno);\n\t\tif (!retval)\n\t\t\tretval = put_user((short)why, &infop->si_code);\n\t\tif (!retval)\n\t\t\tretval = put_user(pid, &infop->si_pid);\n\t\tif (!retval)\n\t\t\tretval = put_user(uid, &infop->si_uid);\n\t\tif (!retval)\n\t\t\tretval = put_user(status, &infop->si_status);\n\t}\n\tif (!retval)\n\t\tretval = pid;\n\treturn retval;\n}\n\n\nstatic int wait_task_zombie(struct wait_opts *wo, struct task_struct *p)\n{\n\tint state, retval, status;\n\tpid_t pid = task_pid_vnr(p);\n\tuid_t uid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tstruct siginfo __user *infop;\n\n\tif (!likely(wo->wo_flags & wexited))\n\t\treturn 0;\n\n\tif (unlikely(wo->wo_flags & wnowait)) {\n\t\tint exit_code = p->exit_code;\n\t\tint why;\n\n\t\tget_task_struct(p);\n\t\tread_unlock(&tasklist_lock);\n\t\tsched_annotate_sleep();\n\n\t\tif ((exit_code & 0x7f) == 0) {\n\t\t\twhy = cld_exited;\n\t\t\tstatus = exit_code >> 8;\n\t\t} else {\n\t\t\twhy = (exit_code & 0x80) ? cld_dumped : cld_killed;\n\t\t\tstatus = exit_code & 0x7f;\n\t\t}\n\t\treturn wait_noreap_copyout(wo, p, pid, uid, why, status);\n\t}\n\t\n\tstate = (ptrace_reparented(p) && thread_group_leader(p)) ?\n\t\texit_trace : exit_dead;\n\tif (cmpxchg(&p->exit_state, exit_zombie, state) != exit_zombie)\n\t\treturn 0;\n\t\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\t\n\tif (state == exit_dead && thread_group_leader(p)) {\n\t\tstruct signal_struct *sig = p->signal;\n\t\tstruct signal_struct *psig = current->signal;\n\t\tunsigned long maxrss;\n\t\tcputime_t tgutime, tgstime;\n\n\t\t\n\t\tthread_group_cputime_adjusted(p, &tgutime, &tgstime);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\twrite_seqlock(&psig->stats_lock);\n\t\tpsig->cutime += tgutime + sig->cutime;\n\t\tpsig->cstime += tgstime + sig->cstime;\n\t\tpsig->cgtime += task_gtime(p) + sig->gtime + sig->cgtime;\n\t\tpsig->cmin_flt +=\n\t\t\tp->min_flt + sig->min_flt + sig->cmin_flt;\n\t\tpsig->cmaj_flt +=\n\t\t\tp->maj_flt + sig->maj_flt + sig->cmaj_flt;\n\t\tpsig->cnvcsw +=\n\t\t\tp->nvcsw + sig->nvcsw + sig->cnvcsw;\n\t\tpsig->cnivcsw +=\n\t\t\tp->nivcsw + sig->nivcsw + sig->cnivcsw;\n\t\tpsig->cinblock +=\n\t\t\ttask_io_get_inblock(p) +\n\t\t\tsig->inblock + sig->cinblock;\n\t\tpsig->coublock +=\n\t\t\ttask_io_get_oublock(p) +\n\t\t\tsig->oublock + sig->coublock;\n\t\tmaxrss = max(sig->maxrss, sig->cmaxrss);\n\t\tif (psig->cmaxrss < maxrss)\n\t\t\tpsig->cmaxrss = maxrss;\n\t\ttask_io_accounting_add(&psig->ioac, &p->ioac);\n\t\ttask_io_accounting_add(&psig->ioac, &sig->ioac);\n\t\twrite_sequnlock(&psig->stats_lock);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t}\n\n\tretval = wo->wo_rusage\n\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\tstatus = (p->signal->flags & signal_group_exit)\n\t\t? p->signal->group_exit_code : p->exit_code;\n\tif (!retval && wo->wo_stat)\n\t\tretval = put_user(status, wo->wo_stat);\n\n\tinfop = wo->wo_info;\n\tif (!retval && infop)\n\t\tretval = put_user(sigchld, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop) {\n\t\tint why;\n\n\t\tif ((status & 0x7f) == 0) {\n\t\t\twhy = cld_exited;\n\t\t\tstatus >>= 8;\n\t\t} else {\n\t\t\twhy = (status & 0x80) ? cld_dumped : cld_killed;\n\t\t\tstatus &= 0x7f;\n\t\t}\n\t\tretval = put_user((short)why, &infop->si_code);\n\t\tif (!retval)\n\t\t\tretval = put_user(status, &infop->si_status);\n\t}\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\n\tif (state == exit_trace) {\n\t\twrite_lock_irq(&tasklist_lock);\n\t\t\n\t\tptrace_unlink(p);\n\n\t\t\n\t\tstate = exit_zombie;\n\t\tif (do_notify_parent(p, p->exit_signal))\n\t\t\tstate = exit_dead;\n\t\tp->exit_state = state;\n\t\twrite_unlock_irq(&tasklist_lock);\n\t}\n\tif (state == exit_dead)\n\t\trelease_task(p);\n\n\treturn retval;\n}\n\nstatic int *task_stopped_code(struct task_struct *p, bool ptrace)\n{\n\tif (ptrace) {\n\t\tif (task_is_stopped_or_traced(p) &&\n\t\t    !(p->jobctl & jobctl_listening))\n\t\t\treturn &p->exit_code;\n\t} else {\n\t\tif (p->signal->flags & signal_stop_stopped)\n\t\t\treturn &p->signal->group_exit_code;\n\t}\n\treturn null;\n}\n\n\nstatic int wait_task_stopped(struct wait_opts *wo,\n\t\t\t\tint ptrace, struct task_struct *p)\n{\n\tstruct siginfo __user *infop;\n\tint retval, exit_code, *p_code, why;\n\tuid_t uid = 0; \n\tpid_t pid;\n\n\t\n\tif (!ptrace && !(wo->wo_flags & wuntraced))\n\t\treturn 0;\n\n\tif (!task_stopped_code(p, ptrace))\n\t\treturn 0;\n\n\texit_code = 0;\n\tspin_lock_irq(&p->sighand->siglock);\n\n\tp_code = task_stopped_code(p, ptrace);\n\tif (unlikely(!p_code))\n\t\tgoto unlock_sig;\n\n\texit_code = *p_code;\n\tif (!exit_code)\n\t\tgoto unlock_sig;\n\n\tif (!unlikely(wo->wo_flags & wnowait))\n\t\t*p_code = 0;\n\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\nunlock_sig:\n\tspin_unlock_irq(&p->sighand->siglock);\n\tif (!exit_code)\n\t\treturn 0;\n\n\t\n\tget_task_struct(p);\n\tpid = task_pid_vnr(p);\n\twhy = ptrace ? cld_trapped : cld_stopped;\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\tif (unlikely(wo->wo_flags & wnowait))\n\t\treturn wait_noreap_copyout(wo, p, pid, uid, why, exit_code);\n\n\tretval = wo->wo_rusage\n\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\tif (!retval && wo->wo_stat)\n\t\tretval = put_user((exit_code << 8) | 0x7f, wo->wo_stat);\n\n\tinfop = wo->wo_info;\n\tif (!retval && infop)\n\t\tretval = put_user(sigchld, &infop->si_signo);\n\tif (!retval && infop)\n\t\tretval = put_user(0, &infop->si_errno);\n\tif (!retval && infop)\n\t\tretval = put_user((short)why, &infop->si_code);\n\tif (!retval && infop)\n\t\tretval = put_user(exit_code, &infop->si_status);\n\tif (!retval && infop)\n\t\tretval = put_user(pid, &infop->si_pid);\n\tif (!retval && infop)\n\t\tretval = put_user(uid, &infop->si_uid);\n\tif (!retval)\n\t\tretval = pid;\n\tput_task_struct(p);\n\n\tbug_on(!retval);\n\treturn retval;\n}\n\n\nstatic int wait_task_continued(struct wait_opts *wo, struct task_struct *p)\n{\n\tint retval;\n\tpid_t pid;\n\tuid_t uid;\n\n\tif (!unlikely(wo->wo_flags & wcontinued))\n\t\treturn 0;\n\n\tif (!(p->signal->flags & signal_stop_continued))\n\t\treturn 0;\n\n\tspin_lock_irq(&p->sighand->siglock);\n\t\n\tif (!(p->signal->flags & signal_stop_continued)) {\n\t\tspin_unlock_irq(&p->sighand->siglock);\n\t\treturn 0;\n\t}\n\tif (!unlikely(wo->wo_flags & wnowait))\n\t\tp->signal->flags &= ~signal_stop_continued;\n\tuid = from_kuid_munged(current_user_ns(), task_uid(p));\n\tspin_unlock_irq(&p->sighand->siglock);\n\n\tpid = task_pid_vnr(p);\n\tget_task_struct(p);\n\tread_unlock(&tasklist_lock);\n\tsched_annotate_sleep();\n\n\tif (!wo->wo_info) {\n\t\tretval = wo->wo_rusage\n\t\t\t? getrusage(p, rusage_both, wo->wo_rusage) : 0;\n\t\tput_task_struct(p);\n\t\tif (!retval && wo->wo_stat)\n\t\t\tretval = put_user(0xffff, wo->wo_stat);\n\t\tif (!retval)\n\t\t\tretval = pid;\n\t} else {\n\t\tretval = wait_noreap_copyout(wo, p, pid, uid,\n\t\t\t\t\t     cld_continued, sigcont);\n\t\tbug_on(retval == 0);\n\t}\n\n\treturn retval;\n}\n\n\nstatic int wait_consider_task(struct wait_opts *wo, int ptrace,\n\t\t\t\tstruct task_struct *p)\n{\n\t\n\tint exit_state = access_once(p->exit_state);\n\tint ret;\n\n\tif (unlikely(exit_state == exit_dead))\n\t\treturn 0;\n\n\tret = eligible_child(wo, p);\n\tif (!ret)\n\t\treturn ret;\n\n\tret = security_task_wait(p);\n\tif (unlikely(ret < 0)) {\n\t\t\n\t\tif (wo->notask_error)\n\t\t\two->notask_error = ret;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(exit_state == exit_trace)) {\n\t\t\n\t\tif (likely(!ptrace))\n\t\t\two->notask_error = 0;\n\t\treturn 0;\n\t}\n\n\tif (likely(!ptrace) && unlikely(p->ptrace)) {\n\t\t\n\t\tif (!ptrace_reparented(p))\n\t\t\tptrace = 1;\n\t}\n\n\t\n\tif (exit_state == exit_zombie) {\n\t\t\n\t\tif (!delay_group_leader(p)) {\n\t\t\t\n\t\t\tif (unlikely(ptrace) || likely(!p->ptrace))\n\t\t\t\treturn wait_task_zombie(wo, p);\n\t\t}\n\n\t\t\n\t\tif (likely(!ptrace) || (wo->wo_flags & (wcontinued | wexited)))\n\t\t\two->notask_error = 0;\n\t} else {\n\t\t\n\t\two->notask_error = 0;\n\t}\n\n\t\n\tret = wait_task_stopped(wo, ptrace, p);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\treturn wait_task_continued(wo, p);\n}\n\n\nstatic int do_wait_thread(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->children, sibling) {\n\t\tint ret = wait_consider_task(wo, 0, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int ptrace_do_wait(struct wait_opts *wo, struct task_struct *tsk)\n{\n\tstruct task_struct *p;\n\n\tlist_for_each_entry(p, &tsk->ptraced, ptrace_entry) {\n\t\tint ret = wait_consider_task(wo, 1, p);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nstatic int child_wait_callback(wait_queue_t *wait, unsigned mode,\n\t\t\t\tint sync, void *key)\n{\n\tstruct wait_opts *wo = container_of(wait, struct wait_opts,\n\t\t\t\t\t\tchild_wait);\n\tstruct task_struct *p = key;\n\n\tif (!eligible_pid(wo, p))\n\t\treturn 0;\n\n\tif ((wo->wo_flags & __wnothread) && wait->private != p->parent)\n\t\treturn 0;\n\n\treturn default_wake_function(wait, mode, sync, key);\n}\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\ttask_interruptible, 1, p);\n}\n\nstatic long do_wait(struct wait_opts *wo)\n{\n\tstruct task_struct *tsk;\n\tint retval;\n\n\ttrace_sched_process_wait(wo->wo_pid);\n\n\tinit_waitqueue_func_entry(&wo->child_wait, child_wait_callback);\n\two->child_wait.private = current;\n\tadd_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);\nrepeat:\n\t\n\two->notask_error = -echild;\n\tif ((wo->wo_type < pidtype_max) &&\n\t   (!wo->wo_pid || hlist_empty(&wo->wo_pid->tasks[wo->wo_type])))\n\t\tgoto notask;\n\n\tset_current_state(task_interruptible);\n\tread_lock(&tasklist_lock);\n\ttsk = current;\n\tdo {\n\t\tretval = do_wait_thread(wo, tsk);\n\t\tif (retval)\n\t\t\tgoto end;\n\n\t\tretval = ptrace_do_wait(wo, tsk);\n\t\tif (retval)\n\t\t\tgoto end;\n\n\t\tif (wo->wo_flags & __wnothread)\n\t\t\tbreak;\n\t} while_each_thread(current, tsk);\n\tread_unlock(&tasklist_lock);\n\nnotask:\n\tretval = wo->notask_error;\n\tif (!retval && !(wo->wo_flags & wnohang)) {\n\t\tretval = -erestartsys;\n\t\tif (!signal_pending(current)) {\n\t\t\tschedule();\n\t\t\tgoto repeat;\n\t\t}\n\t}\nend:\n\t__set_current_state(task_running);\n\tremove_wait_queue(&current->signal->wait_chldexit, &wo->child_wait);\n\treturn retval;\n}\n\nsyscall_define5(waitid, int, which, pid_t, upid, struct siginfo __user *,\n\t\tinfop, int, options, struct rusage __user *, ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = null;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(wnohang|wnowait|wexited|wstopped|wcontinued))\n\t\treturn -einval;\n\tif (!(options & (wexited|wstopped|wcontinued)))\n\t\treturn -einval;\n\n\tswitch (which) {\n\tcase p_all:\n\t\ttype = pidtype_max;\n\t\tbreak;\n\tcase p_pid:\n\t\ttype = pidtype_pid;\n\t\tif (upid <= 0)\n\t\t\treturn -einval;\n\t\tbreak;\n\tcase p_pgid:\n\t\ttype = pidtype_pgid;\n\t\tif (upid <= 0)\n\t\t\treturn -einval;\n\t\tbreak;\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\tif (type < pidtype_max)\n\t\tpid = find_get_pid(upid);\n\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options;\n\two.wo_info\t= infop;\n\two.wo_stat\t= null;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\n\tif (ret > 0) {\n\t\tret = 0;\n\t} else if (infop) {\n\t\t\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_signo);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_errno);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_code);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_pid);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_uid);\n\t\tif (!ret)\n\t\t\tret = put_user(0, &infop->si_status);\n\t}\n\n\tput_pid(pid);\n\treturn ret;\n}\n\nsyscall_define4(wait4, pid_t, upid, int __user *, stat_addr,\n\t\tint, options, struct rusage __user *, ru)\n{\n\tstruct wait_opts wo;\n\tstruct pid *pid = null;\n\tenum pid_type type;\n\tlong ret;\n\n\tif (options & ~(wnohang|wuntraced|wcontinued|\n\t\t\t__wnothread|__wclone|__wall))\n\t\treturn -einval;\n\n\tif (upid == -1)\n\t\ttype = pidtype_max;\n\telse if (upid < 0) {\n\t\ttype = pidtype_pgid;\n\t\tpid = find_get_pid(-upid);\n\t} else if (upid == 0) {\n\t\ttype = pidtype_pgid;\n\t\tpid = get_task_pid(current, pidtype_pgid);\n\t} else  {\n\t\ttype = pidtype_pid;\n\t\tpid = find_get_pid(upid);\n\t}\n\n\two.wo_type\t= type;\n\two.wo_pid\t= pid;\n\two.wo_flags\t= options | wexited;\n\two.wo_info\t= null;\n\two.wo_stat\t= stat_addr;\n\two.wo_rusage\t= ru;\n\tret = do_wait(&wo);\n\tput_pid(pid);\n\n\treturn ret;\n}\n\n#ifdef __arch_want_sys_waitpid\n\n\nsyscall_define3(waitpid, pid_t, pid, int __user *, stat_addr, int, options)\n{\n\treturn sys_wait4(pid, stat_addr, options, null);\n}\n\n#endif\n\n\n#include <linux/cpu.h>\n#include <linux/export.h>\n#include <linux/percpu.h>\n#include <linux/hrtimer.h>\n#include <linux/notifier.h>\n#include <linux/syscalls.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/tick.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/debugobjects.h>\n#include <linux/sched.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/deadline.h>\n#include <linux/timer.h>\n#include <linux/freezer.h>\n\n#include <asm/uaccess.h>\n\n#include <trace/events/timer.h>\n\n#include \"", "951": "\",\n\t\t\tcurrent->comm, task_pid_nr(current), free);\n\t\tlowest_to_date = free;\n\t}\n\tspin_unlock(&low_water_lock);\n}\n#else\nstatic inline void check_stack_usage(void) {}\n#endif\n\nvoid do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\ttasks_rcu(int tasks_rcu_i);\n\n\tprofile_task_exit(tsk);\n\n\twarn_on(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"", "952": "\",\n\t\t\tfather->signal->group_exit_code ?: father->exit_code);\n\t}\n\tzap_pid_ns_processes(pid_ns);\n\twrite_lock_irq(&tasklist_lock);\n\n\treturn father;\n}\n\n\nstatic struct task_struct *find_new_reaper(struct task_struct *father,\n\t\t\t\t\t   struct task_struct *child_reaper)\n{\n\tstruct task_struct *thread, *reaper;\n\n\tthread = find_alive_thread(father);\n\tif (thread)\n\t\treturn thread;\n\n\tif (father->signal->has_child_subreaper) {\n\t\t\n\t\tfor (reaper = father;\n\t\t     !same_thread_group(reaper, child_reaper);\n\t\t     reaper = reaper->real_parent) {\n\t\t\t\n\t\t\tif (reaper == &init_task)\n\t\t\t\tbreak;\n\t\t\tif (!reaper->signal->is_child_subreaper)\n\t\t\t\tcontinue;\n\t\t\tthread = find_alive_thread(reaper);\n\t\t\tif (thread)\n\t\t\t\treturn thread;\n\t\t}\n\t}\n\n\treturn child_reaper;\n}\n\n\nstatic void reparent_leader(struct task_struct *father, struct task_struct *p,\n\t\t\t\tstruct list_head *dead)\n{\n\tif (unlikely(p->exit_state == exit_dead))\n\t\treturn;\n\n\t\n\tp->exit_signal = sigchld;\n\n\t\n\tif (!p->ptrace &&\n\t    p->exit_state == exit_zombie && thread_group_empty(p)) {\n\t\tif (do_notify_parent(p, p->exit_signal)) {\n\t\t\tp->exit_state = exit_dead;\n\t\t\tlist_add(&p->ptrace_entry, dead);\n\t\t}\n\t}\n\n\tkill_orphaned_pgrp(p, father);\n}\n\n\nstatic void forget_original_parent(struct task_struct *father,\n\t\t\t\t\tstruct list_head *dead)\n{\n\tstruct task_struct *p, *t, *reaper;\n\n\tif (unlikely(!list_empty(&father->ptraced)))\n\t\texit_ptrace(father, dead);\n\n\t\n\treaper = find_child_reaper(father);\n\tif (list_empty(&father->children))\n\t\treturn;\n\n\treaper = find_new_reaper(father, reaper);\n\tlist_for_each_entry(p, &father->children, sibling) {\n\t\tfor_each_thread(p, t) {\n\t\t\tt->real_parent = reaper;\n\t\t\tbug_on((!t->ptrace) != (t->parent == father));\n\t\t\tif (likely(!t->ptrace))\n\t\t\t\tt->parent = t->real_parent;\n\t\t\tif (t->pdeath_signal)\n\t\t\t\tgroup_send_sig_info(t->pdeath_signal,\n\t\t\t\t\t\t    send_sig_noinfo, t);\n\t\t}\n\t\t\n\t\tif (!same_thread_group(reaper, father))\n\t\t\treparent_leader(father, p, dead);\n\t}\n\tlist_splice_tail_init(&father->children, &reaper->children);\n}\n\n\nstatic void exit_notify(struct task_struct *tsk, int group_dead)\n{\n\tbool autoreap;\n\tstruct task_struct *p, *n;\n\tlist_head(dead);\n\n\twrite_lock_irq(&tasklist_lock);\n\tforget_original_parent(tsk, &dead);\n\n\tif (group_dead)\n\t\tkill_orphaned_pgrp(tsk->group_leader, null);\n\n\tif (unlikely(tsk->ptrace)) {\n\t\tint sig = thread_group_leader(tsk) &&\n\t\t\t\tthread_group_empty(tsk) &&\n\t\t\t\t!ptrace_reparented(tsk) ?\n\t\t\ttsk->exit_signal : sigchld;\n\t\tautoreap = do_notify_parent(tsk, sig);\n\t} else if (thread_group_leader(tsk)) {\n\t\tautoreap = thread_group_empty(tsk) &&\n\t\t\tdo_notify_parent(tsk, tsk->exit_signal);\n\t} else {\n\t\tautoreap = true;\n\t}\n\n\ttsk->exit_state = autoreap ? exit_dead : exit_zombie;\n\tif (tsk->exit_state == exit_dead)\n\t\tlist_add(&tsk->ptrace_entry, &dead);\n\n\t\n\tif (unlikely(tsk->signal->notify_count < 0))\n\t\twake_up_process(tsk->signal->group_exit_task);\n\twrite_unlock_irq(&tasklist_lock);\n\n\tlist_for_each_entry_safe(p, n, &dead, ptrace_entry) {\n\t\tlist_del_init(&p->ptrace_entry);\n\t\trelease_task(p);\n\t}\n}\n\n#ifdef config_debug_stack_usage\nstatic void check_stack_usage(void)\n{\n\tstatic define_spinlock(low_water_lock);\n\tstatic int lowest_to_date = thread_size;\n\tunsigned long free;\n\n\tfree = stack_not_used(current);\n\n\tif (free >= lowest_to_date)\n\t\treturn;\n\n\tspin_lock(&low_water_lock);\n\tif (free < lowest_to_date) {\n\t\tpr_warn(\"", "953": "\",\n\t\t\ti == tr->clock_id ? \"", "954": "\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __log_buf_len - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __log_buf_len);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\n\tpr_info(\"", "955": "\",\n\t\t\tof_node_full_name(irq_data->np));\n\t\treturn 0;\n\t}\n\n\t\n\tif (domain->ops->xlate == null)\n\t\thwirq = irq_data->args[0];\n\telse {\n\t\tif (domain->ops->xlate(domain, irq_data->np, irq_data->args,\n\t\t\t\t\tirq_data->args_count, &hwirq, &type))\n\t\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\t\n\t\tvirq = irq_find_mapping(domain, hwirq);\n\t\tif (virq)\n\t\t\treturn virq;\n\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, numa_no_node, irq_data);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\t\n\tif (type != irq_type_none &&\n\t    type != irq_get_trigger_type(virq))\n\t\tirq_set_irq_type(virq, type);\n\treturn virq;\n}\nexport_symbol_gpl(irq_create_of_mapping);\n\n\nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (warn_on(domain == null))\n\t\treturn;\n\n\tirq_domain_disassociate(domain, virq);\n\tirq_free_desc(virq);\n}\nexport_symbol_gpl(irq_dispose_mapping);\n\n\nunsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t\n\tif (domain == null)\n\t\tdomain = irq_default_domain;\n\tif (domain == null)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}\nexport_symbol_gpl(irq_find_mapping);\n\n#ifdef config_irq_domain_debug\nstatic int virq_debug_show(struct seq_file *m, void *private)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc;\n\tstruct irq_domain *domain;\n\tstruct radix_tree_iter iter;\n\tvoid *data, **slot;\n\tint i;\n\n\tseq_printf(m, \"", "956": "\",\n\t\t\tset);\n\t\treturn -einval;\n\t}\n\n\treturn 0;\n}\n\n\nstruct tracer nop_trace __read_mostly =\n{\n\t.name\t\t= \"", "957": "\",\n\t\t\tset);\n\t\treturn 0;\n\t}\n\n\tif (bit == trace_nop_opt_refuse) {\n\t\tprintk(kern_debug \"", "958": "\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}\n\n\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(kern_err \"", "959": "\",\n\t\t       (unsigned long)ts, rem_nsec / 1000);\n}\n\nstatic size_t print_prefix(const struct printk_log *msg, bool syslog, char *buf)\n{\n\tsize_t len = 0;\n\tunsigned int prefix = (msg->facility << 3) | msg->level;\n\n\tif (syslog) {\n\t\tif (buf) {\n\t\t\tlen += sprintf(buf, \"", "960": "\",\n\t\t       chan->last_toobig, chan->subbuf_size);\n\n\tlist_del(&chan->list);\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n}\nexport_symbol_gpl(relay_close);\n\n\nvoid relay_flush(struct rchan *chan)\n{\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && chan->buf[0]) {\n\t\trelay_switch_subbuf(chan->buf[0], 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif (chan->buf[i])\n\t\t\trelay_switch_subbuf(chan->buf[i], 0);\n\tmutex_unlock(&relay_channels_mutex);\n}\nexport_symbol_gpl(relay_flush);\n\n\nstatic int relay_file_open(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = inode->i_private;\n\tkref_get(&buf->kref);\n\tfilp->private_data = buf;\n\n\treturn nonseekable_open(inode, filp);\n}\n\n\nstatic int relay_file_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\treturn relay_mmap_buf(buf, vma);\n}\n\n\nstatic unsigned int relay_file_poll(struct file *filp, poll_table *wait)\n{\n\tunsigned int mask = 0;\n\tstruct rchan_buf *buf = filp->private_data;\n\n\tif (buf->finalized)\n\t\treturn pollerr;\n\n\tif (filp->f_mode & fmode_read) {\n\t\tpoll_wait(filp, &buf->read_wait, wait);\n\t\tif (!relay_buf_empty(buf))\n\t\t\tmask |= pollin | pollrdnorm;\n\t}\n\n\treturn mask;\n}\n\n\nstatic int relay_file_release(struct inode *inode, struct file *filp)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tkref_put(&buf->kref, relay_remove_buf);\n\n\treturn 0;\n}\n\n\nstatic void relay_file_read_consume(struct rchan_buf *buf,\n\t\t\t\t    size_t read_pos,\n\t\t\t\t    size_t bytes_consumed)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t read_subbuf;\n\n\tif (buf->subbufs_produced == buf->subbufs_consumed &&\n\t    buf->offset == buf->bytes_consumed)\n\t\treturn;\n\n\tif (buf->bytes_consumed + bytes_consumed > subbuf_size) {\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tbuf->bytes_consumed += bytes_consumed;\n\tif (!read_pos)\n\t\tread_subbuf = buf->subbufs_consumed % n_subbufs;\n\telse\n\t\tread_subbuf = read_pos / buf->chan->subbuf_size;\n\tif (buf->bytes_consumed + buf->padding[read_subbuf] == subbuf_size) {\n\t\tif ((read_subbuf == buf->subbufs_produced % n_subbufs) &&\n\t\t    (buf->offset == subbuf_size))\n\t\t\treturn;\n\t\trelay_subbufs_consumed(buf->chan, buf->cpu, 1);\n\t\tbuf->bytes_consumed = 0;\n\t}\n}\n\n\nstatic int relay_file_read_avail(struct rchan_buf *buf, size_t read_pos)\n{\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t produced = buf->subbufs_produced;\n\tsize_t consumed = buf->subbufs_consumed;\n\n\trelay_file_read_consume(buf, read_pos, 0);\n\n\tconsumed = buf->subbufs_consumed;\n\n\tif (unlikely(buf->offset > subbuf_size)) {\n\t\tif (produced == consumed)\n\t\t\treturn 0;\n\t\treturn 1;\n\t}\n\n\tif (unlikely(produced - consumed >= n_subbufs)) {\n\t\tconsumed = produced - n_subbufs + 1;\n\t\tbuf->subbufs_consumed = consumed;\n\t\tbuf->bytes_consumed = 0;\n\t}\n\n\tproduced = (produced % n_subbufs) * subbuf_size + buf->offset;\n\tconsumed = (consumed % n_subbufs) * subbuf_size + buf->bytes_consumed;\n\n\tif (consumed > produced)\n\t\tproduced += n_subbufs * subbuf_size;\n\n\tif (consumed == produced) {\n\t\tif (buf->offset == subbuf_size &&\n\t\t    buf->subbufs_produced > buf->subbufs_consumed)\n\t\t\treturn 1;\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\n\nstatic size_t relay_file_read_subbuf_avail(size_t read_pos,\n\t\t\t\t\t   struct rchan_buf *buf)\n{\n\tsize_t padding, avail = 0;\n\tsize_t read_subbuf, read_offset, write_subbuf, write_offset;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\n\twrite_subbuf = (buf->data - buf->start) / subbuf_size;\n\twrite_offset = buf->offset > subbuf_size ? subbuf_size : buf->offset;\n\tread_subbuf = read_pos / subbuf_size;\n\tread_offset = read_pos % subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\n\tif (read_subbuf == write_subbuf) {\n\t\tif (read_offset + padding < write_offset)\n\t\t\tavail = write_offset - (read_offset + padding);\n\t} else\n\t\tavail = (subbuf_size - padding) - read_offset;\n\n\treturn avail;\n}\n\n\nstatic size_t relay_file_read_start_pos(size_t read_pos,\n\t\t\t\t\tstruct rchan_buf *buf)\n{\n\tsize_t read_subbuf, padding, padding_start, padding_end;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\tsize_t consumed = buf->subbufs_consumed % n_subbufs;\n\n\tif (!read_pos)\n\t\tread_pos = consumed * subbuf_size + buf->bytes_consumed;\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tpadding_start = (read_subbuf + 1) * subbuf_size - padding;\n\tpadding_end = (read_subbuf + 1) * subbuf_size;\n\tif (read_pos >= padding_start && read_pos < padding_end) {\n\t\tread_subbuf = (read_subbuf + 1) % n_subbufs;\n\t\tread_pos = read_subbuf * subbuf_size;\n\t}\n\n\treturn read_pos;\n}\n\n\nstatic size_t relay_file_read_end_pos(struct rchan_buf *buf,\n\t\t\t\t      size_t read_pos,\n\t\t\t\t      size_t count)\n{\n\tsize_t read_subbuf, padding, end_pos;\n\tsize_t subbuf_size = buf->chan->subbuf_size;\n\tsize_t n_subbufs = buf->chan->n_subbufs;\n\n\tread_subbuf = read_pos / subbuf_size;\n\tpadding = buf->padding[read_subbuf];\n\tif (read_pos % subbuf_size + count + padding == subbuf_size)\n\t\tend_pos = (read_subbuf + 1) * subbuf_size;\n\telse\n\t\tend_pos = read_pos + count;\n\tif (end_pos >= subbuf_size * n_subbufs)\n\t\tend_pos = 0;\n\n\treturn end_pos;\n}\n\n\nstatic int subbuf_read_actor(size_t read_start,\n\t\t\t     struct rchan_buf *buf,\n\t\t\t     size_t avail,\n\t\t\t     read_descriptor_t *desc)\n{\n\tvoid *from;\n\tint ret = 0;\n\n\tfrom = buf->start + read_start;\n\tret = avail;\n\tif (copy_to_user(desc->arg.buf, from, avail)) {\n\t\tdesc->error = -efault;\n\t\tret = 0;\n\t}\n\tdesc->arg.data += ret;\n\tdesc->written += ret;\n\tdesc->count -= ret;\n\n\treturn ret;\n}\n\ntypedef int (*subbuf_actor_t) (size_t read_start,\n\t\t\t       struct rchan_buf *buf,\n\t\t\t       size_t avail,\n\t\t\t       read_descriptor_t *desc);\n\n\nstatic ssize_t relay_file_read_subbufs(struct file *filp, loff_t *ppos,\n\t\t\t\t\tsubbuf_actor_t subbuf_actor,\n\t\t\t\t\tread_descriptor_t *desc)\n{\n\tstruct rchan_buf *buf = filp->private_data;\n\tsize_t read_start, avail;\n\tint ret;\n\n\tif (!desc->count)\n\t\treturn 0;\n\n\tmutex_lock(&file_inode(filp)->i_mutex);\n\tdo {\n\t\tif (!relay_file_read_avail(buf, *ppos))\n\t\t\tbreak;\n\n\t\tread_start = relay_file_read_start_pos(*ppos, buf);\n\t\tavail = relay_file_read_subbuf_avail(read_start, buf);\n\t\tif (!avail)\n\t\t\tbreak;\n\n\t\tavail = min(desc->count, avail);\n\t\tret = subbuf_actor(read_start, buf, avail, desc);\n\t\tif (desc->error < 0)\n\t\t\tbreak;\n\n\t\tif (ret) {\n\t\t\trelay_file_read_consume(buf, read_start, ret);\n\t\t\t*ppos = relay_file_read_end_pos(buf, read_start, ret);\n\t\t}\n\t} while (desc->count && ret);\n\tmutex_unlock(&file_inode(filp)->i_mutex);\n\n\treturn desc->written;\n}\n\nstatic ssize_t relay_file_read(struct file *filp,\n\t\t\t       char __user *buffer,\n\t\t\t       size_t count,\n\t\t\t       loff_t *ppos)\n{\n\tread_descriptor_t desc;\n\tdesc.written = 0;\n\tdesc.count = count;\n\tdesc.arg.buf = buffer;\n\tdesc.error = 0;\n\treturn relay_file_read_subbufs(filp, ppos, subbuf_read_actor, &desc);\n}\n\nstatic void relay_consume_bytes(struct rchan_buf *rbuf, int bytes_consumed)\n{\n\trbuf->bytes_consumed += bytes_consumed;\n\n\tif (rbuf->bytes_consumed >= rbuf->chan->subbuf_size) {\n\t\trelay_subbufs_consumed(rbuf->chan, rbuf->cpu, 1);\n\t\trbuf->bytes_consumed %= rbuf->chan->subbuf_size;\n\t}\n}\n\nstatic void relay_pipe_buf_release(struct pipe_inode_info *pipe,\n\t\t\t\t   struct pipe_buffer *buf)\n{\n\tstruct rchan_buf *rbuf;\n\n\trbuf = (struct rchan_buf *)page_private(buf->page);\n\trelay_consume_bytes(rbuf, buf->private);\n}\n\nstatic const struct pipe_buf_operations relay_pipe_buf_ops = {\n\t.can_merge = 0,\n\t.confirm = generic_pipe_buf_confirm,\n\t.release = relay_pipe_buf_release,\n\t.steal = generic_pipe_buf_steal,\n\t.get = generic_pipe_buf_get,\n};\n\nstatic void relay_page_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n}\n\n\nstatic ssize_t subbuf_splice_actor(struct file *in,\n\t\t\t       loff_t *ppos,\n\t\t\t       struct pipe_inode_info *pipe,\n\t\t\t       size_t len,\n\t\t\t       unsigned int flags,\n\t\t\t       int *nonpad_ret)\n{\n\tunsigned int pidx, poff, total_len, subbuf_pages, nr_pages;\n\tstruct rchan_buf *rbuf = in->private_data;\n\tunsigned int subbuf_size = rbuf->chan->subbuf_size;\n\tuint64_t pos = (uint64_t) *ppos;\n\tuint32_t alloc_size = (uint32_t) rbuf->chan->alloc_size;\n\tsize_t read_start = (size_t) do_div(pos, alloc_size);\n\tsize_t read_subbuf = read_start / subbuf_size;\n\tsize_t padding = rbuf->padding[read_subbuf];\n\tsize_t nonpad_end = read_subbuf * subbuf_size + subbuf_size - padding;\n\tstruct page *pages[pipe_def_buffers];\n\tstruct partial_page partial[pipe_def_buffers];\n\tstruct splice_pipe_desc spd = {\n\t\t.pages = pages,\n\t\t.nr_pages = 0,\n\t\t.nr_pages_max = pipe_def_buffers,\n\t\t.partial = partial,\n\t\t.flags = flags,\n\t\t.ops = &relay_pipe_buf_ops,\n\t\t.spd_release = relay_page_release,\n\t};\n\tssize_t ret;\n\n\tif (rbuf->subbufs_produced == rbuf->subbufs_consumed)\n\t\treturn 0;\n\tif (splice_grow_spd(pipe, &spd))\n\t\treturn -enomem;\n\n\t\n\tif (len > (subbuf_size - read_start % subbuf_size))\n\t\tlen = subbuf_size - read_start % subbuf_size;\n\n\tsubbuf_pages = rbuf->chan->alloc_size >> page_shift;\n\tpidx = (read_start / page_size) % subbuf_pages;\n\tpoff = read_start & ~page_mask;\n\tnr_pages = min_t(unsigned int, subbuf_pages, spd.nr_pages_max);\n\n\tfor (total_len = 0; spd.nr_pages < nr_pages; spd.nr_pages++) {\n\t\tunsigned int this_len, this_end, private;\n\t\tunsigned int cur_pos = read_start + total_len;\n\n\t\tif (!len)\n\t\t\tbreak;\n\n\t\tthis_len = min_t(unsigned long, len, page_size - poff);\n\t\tprivate = this_len;\n\n\t\tspd.pages[spd.nr_pages] = rbuf->page_array[pidx];\n\t\tspd.partial[spd.nr_pages].offset = poff;\n\n\t\tthis_end = cur_pos + this_len;\n\t\tif (this_end >= nonpad_end) {\n\t\t\tthis_len = nonpad_end - cur_pos;\n\t\t\tprivate = this_len + padding;\n\t\t}\n\t\tspd.partial[spd.nr_pages].len = this_len;\n\t\tspd.partial[spd.nr_pages].private = private;\n\n\t\tlen -= this_len;\n\t\ttotal_len += this_len;\n\t\tpoff = 0;\n\t\tpidx = (pidx + 1) % subbuf_pages;\n\n\t\tif (this_end >= nonpad_end) {\n\t\t\tspd.nr_pages++;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (!spd.nr_pages)\n\t\tgoto out;\n\n\tret = *nonpad_ret = splice_to_pipe(pipe, &spd);\n\tif (ret < 0 || ret < total_len)\n\t\tgoto out;\n\n        if (read_start + ret == nonpad_end)\n                ret += padding;\n\nout:\n\tsplice_shrink_spd(&spd);\n\treturn ret;\n}\n\nstatic ssize_t relay_file_splice_read(struct file *in,\n\t\t\t\t      loff_t *ppos,\n\t\t\t\t      struct pipe_inode_info *pipe,\n\t\t\t\t      size_t len,\n\t\t\t\t      unsigned int flags)\n{\n\tssize_t spliced;\n\tint ret;\n\tint nonpad_ret = 0;\n\n\tret = 0;\n\tspliced = 0;\n\n\twhile (len && !spliced) {\n\t\tret = subbuf_splice_actor(in, ppos, pipe, len, flags, &nonpad_ret);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\telse if (!ret) {\n\t\t\tif (flags & splice_f_nonblock)\n\t\t\t\tret = -eagain;\n\t\t\tbreak;\n\t\t}\n\n\t\t*ppos += ret;\n\t\tif (ret > len)\n\t\t\tlen = 0;\n\t\telse\n\t\t\tlen -= ret;\n\t\tspliced += nonpad_ret;\n\t\tnonpad_ret = 0;\n\t}\n\n\tif (spliced)\n\t\treturn spliced;\n\n\treturn ret;\n}\n\nconst struct file_operations relay_file_operations = {\n\t.open\t\t= relay_file_open,\n\t.poll\t\t= relay_file_poll,\n\t.mmap\t\t= relay_file_mmap,\n\t.read\t\t= relay_file_read,\n\t.llseek\t\t= no_llseek,\n\t.release\t= relay_file_release,\n\t.splice_read\t= relay_file_splice_read,\n};\nexport_symbol_gpl(relay_file_operations);\n\nstatic __init int relay_init(void)\n{\n\n\thotcpu_notifier(relay_hotcpu_callback, 0);\n\treturn 0;\n}\n\nearly_initcall(relay_init);\n\n\n#include <linux/sched.h>\n#include <linux/completion.h>\n\n\nvoid complete(struct completion *x)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tx->done++;\n\t__wake_up_locked(&x->wait, task_normal, 1);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n}\nexport_symbol(complete);\n\n\nvoid complete_all(struct completion *x)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tx->done += uint_max/2;\n\t__wake_up_locked(&x->wait, task_normal, 0);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n}\nexport_symbol(complete_all);\n\nstatic inline long __sched\ndo_wait_for_common(struct completion *x,\n\t\t   long (*action)(long), long timeout, int state)\n{\n\tif (!x->done) {\n\t\tdeclare_waitqueue(wait, current);\n\n\t\t__add_wait_queue_tail_exclusive(&x->wait, &wait);\n\t\tdo {\n\t\t\tif (signal_pending_state(state, current)) {\n\t\t\t\ttimeout = -erestartsys;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t__set_current_state(state);\n\t\t\tspin_unlock_irq(&x->wait.lock);\n\t\t\ttimeout = action(timeout);\n\t\t\tspin_lock_irq(&x->wait.lock);\n\t\t} while (!x->done && timeout);\n\t\t__remove_wait_queue(&x->wait, &wait);\n\t\tif (!x->done)\n\t\t\treturn timeout;\n\t}\n\tx->done--;\n\treturn timeout ?: 1;\n}\n\nstatic inline long __sched\n__wait_for_common(struct completion *x,\n\t\t  long (*action)(long), long timeout, int state)\n{\n\tmight_sleep();\n\n\tspin_lock_irq(&x->wait.lock);\n\ttimeout = do_wait_for_common(x, action, timeout, state);\n\tspin_unlock_irq(&x->wait.lock);\n\treturn timeout;\n}\n\nstatic long __sched\nwait_for_common(struct completion *x, long timeout, int state)\n{\n\treturn __wait_for_common(x, schedule_timeout, timeout, state);\n}\n\nstatic long __sched\nwait_for_common_io(struct completion *x, long timeout, int state)\n{\n\treturn __wait_for_common(x, io_schedule_timeout, timeout, state);\n}\n\n\nvoid __sched wait_for_completion(struct completion *x)\n{\n\twait_for_common(x, max_schedule_timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion);\n\n\nunsigned long __sched\nwait_for_completion_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion_timeout);\n\n\nvoid __sched wait_for_completion_io(struct completion *x)\n{\n\twait_for_common_io(x, max_schedule_timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion_io);\n\n\nunsigned long __sched\nwait_for_completion_io_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common_io(x, timeout, task_uninterruptible);\n}\nexport_symbol(wait_for_completion_io_timeout);\n\n\nint __sched wait_for_completion_interruptible(struct completion *x)\n{\n\tlong t = wait_for_common(x, max_schedule_timeout, task_interruptible);\n\tif (t == -erestartsys)\n\t\treturn t;\n\treturn 0;\n}\nexport_symbol(wait_for_completion_interruptible);\n\n\nlong __sched\nwait_for_completion_interruptible_timeout(struct completion *x,\n\t\t\t\t\t  unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, task_interruptible);\n}\nexport_symbol(wait_for_completion_interruptible_timeout);\n\n\nint __sched wait_for_completion_killable(struct completion *x)\n{\n\tlong t = wait_for_common(x, max_schedule_timeout, task_killable);\n\tif (t == -erestartsys)\n\t\treturn t;\n\treturn 0;\n}\nexport_symbol(wait_for_completion_killable);\n\n\nlong __sched\nwait_for_completion_killable_timeout(struct completion *x,\n\t\t\t\t     unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, task_killable);\n}\nexport_symbol(wait_for_completion_killable_timeout);\n\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tint ret = 1;\n\n\t\n\tif (!read_once(x->done))\n\t\treturn 0;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = 0;\n\telse\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}\nexport_symbol(try_wait_for_completion);\n\n\nbool completion_done(struct completion *x)\n{\n\tif (!read_once(x->done))\n\t\treturn false;\n\n\t\n\tsmp_rmb();\n\tspin_unlock_wait(&x->wait.lock);\n\treturn true;\n}\nexport_symbol(completion_done);\n\n\n#include <linux/kdb.h>\n#include <linux/keyboard.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/io.h>\n\n\n\n#define kbd_status_reg\t\t0x64\t\n#define kbd_data_reg\t\t0x60\t\n\n\n\n#define kbd_stat_obf \t\t0x01\t\n#define kbd_stat_mouse_obf\t0x20\t\n\nstatic int kbd_exists;\nstatic int kbd_last_ret;\n\n\nint kdb_get_kbd_char(void)\n{\n\tint scancode, scanstatus;\n\tstatic int shift_lock;\t\n\tstatic int shift_key;\t\n\tstatic int ctrl_key;\n\tu_short keychar;\n\n\tif (kdb_flag(no_i8042) || kdb_flag(no_vt_console) ||\n\t    (inb(kbd_status_reg) == 0xff && inb(kbd_data_reg) == 0xff)) {\n\t\tkbd_exists = 0;\n\t\treturn -1;\n\t}\n\tkbd_exists = 1;\n\n\tif ((inb(kbd_status_reg) & kbd_stat_obf) == 0)\n\t\treturn -1;\n\n\t\n\tscancode = inb(kbd_data_reg);\n\tscanstatus = inb(kbd_status_reg);\n\n\t\n\tif (scanstatus & kbd_stat_mouse_obf)\n\t\treturn -1;\n\n\t\n\n\tif (((scancode&0x7f) == 0x2a) || ((scancode&0x7f) == 0x36)) {\n\t\t\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tshift_key = 1;\n\t\telse\n\t\t\tshift_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode&0x7f) == 0x1d) {\n\t\t\n\t\tif ((scancode & 0x80) == 0)\n\t\t\tctrl_key = 1;\n\t\telse\n\t\t\tctrl_key = 0;\n\t\treturn -1;\n\t}\n\n\tif ((scancode & 0x80) != 0) {\n\t\tif (scancode == 0x9c)\n\t\t\tkbd_last_ret = 0;\n\t\treturn -1;\n\t}\n\n\tscancode &= 0x7f;\n\n\t\n\n\tif (scancode == 0x3a) {\n\t\t\n\t\tshift_lock ^= 1;\n\n#ifdef\tkdb_blink_led\n\t\tkdb_toggleled(0x4);\n#endif\n\t\treturn -1;\n\t}\n\n\tif (scancode == 0x0e) {\n\t\t\n\t\treturn 8;\n\t}\n\n\t\n\tswitch (scancode) {\n\tcase 0xf: \n\t\treturn 9;\n\tcase 0x53: \n\t\treturn 4;\n\tcase 0x47: \n\t\treturn 1;\n\tcase 0x4f: \n\t\treturn 5;\n\tcase 0x4b: \n\t\treturn 2;\n\tcase 0x48: \n\t\treturn 16;\n\tcase 0x50: \n\t\treturn 14;\n\tcase 0x4d: \n\t\treturn 6;\n\t}\n\n\tif (scancode == 0xe0)\n\t\treturn -1;\n\n\t\n\tif (scancode == 0x73)\n\t\tscancode = 0x59;\n\telse if (scancode == 0x7d)\n\t\tscancode = 0x7c;\n\n\tif (!shift_lock && !shift_key && !ctrl_key) {\n\t\tkeychar = plain_map[scancode];\n\t} else if ((shift_lock || shift_key) && key_maps[1]) {\n\t\tkeychar = key_maps[1][scancode];\n\t} else if (ctrl_key && key_maps[4]) {\n\t\tkeychar = key_maps[4][scancode];\n\t} else {\n\t\tkeychar = 0x0020;\n\t\tkdb_printf(\"", "961": "\",\n\t\t       cpumask_pr_args(tr->tracing_cpumask));\n\tif (len >= count) {\n\t\tcount = -einval;\n\t\tgoto out_err;\n\t}\n\tcount = simple_read_from_buffer(ubuf, count, ppos, mask_str, nr_cpus+1);\n\nout_err:\n\tmutex_unlock(&tracing_cpumask_update_lock);\n\n\treturn count;\n}\n\nstatic ssize_t\ntracing_cpumask_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t count, loff_t *ppos)\n{\n\tstruct trace_array *tr = file_inode(filp)->i_private;\n\tcpumask_var_t tracing_cpumask_new;\n\tint err, cpu;\n\n\tif (!alloc_cpumask_var(&tracing_cpumask_new, gfp_kernel))\n\t\treturn -enomem;\n\n\terr = cpumask_parse_user(ubuf, count, tracing_cpumask_new);\n\tif (err)\n\t\tgoto err_unlock;\n\n\tmutex_lock(&tracing_cpumask_update_lock);\n\n\tlocal_irq_disable();\n\tarch_spin_lock(&tr->max_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\t\n\t\tif (cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\t!cpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_inc(&per_cpu_ptr(tr->trace_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_disable_cpu(tr->trace_buffer.buffer, cpu);\n\t\t}\n\t\tif (!cpumask_test_cpu(cpu, tr->tracing_cpumask) &&\n\t\t\t\tcpumask_test_cpu(cpu, tracing_cpumask_new)) {\n\t\t\tatomic_dec(&per_cpu_ptr(tr->trace_buffer.data, cpu)->disabled);\n\t\t\tring_buffer_record_enable_cpu(tr->trace_buffer.buffer, cpu);\n\t\t}\n\t}\n\tarch_spin_unlock(&tr->max_lock);\n\tlocal_irq_enable();\n\n\tcpumask_copy(tr->tracing_cpumask, tracing_cpumask_new);\n\n\tmutex_unlock(&tracing_cpumask_update_lock);\n\tfree_cpumask_var(tracing_cpumask_new);\n\n\treturn count;\n\nerr_unlock:\n\tfree_cpumask_var(tracing_cpumask_new);\n\n\treturn err;\n}\n\nstatic const struct file_operations tracing_cpumask_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_cpumask_read,\n\t.write\t\t= tracing_cpumask_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= generic_file_llseek,\n};\n\nstatic int tracing_trace_options_show(struct seq_file *m, void *v)\n{\n\tstruct tracer_opt *trace_opts;\n\tstruct trace_array *tr = m->private;\n\tu32 tracer_flags;\n\tint i;\n\n\tmutex_lock(&trace_types_lock);\n\ttracer_flags = tr->current_trace->flags->val;\n\ttrace_opts = tr->current_trace->flags->opts;\n\n\tfor (i = 0; trace_options[i]; i++) {\n\t\tif (trace_flags & (1 << i))\n\t\t\tseq_printf(m, \"", "962": "\",\n\t\t       log_lvl, dump_stack_arch_desc_str);\n\n\tprint_worker_info(log_lvl, current);\n}\n\n\nvoid show_regs_print_info(const char *log_lvl)\n{\n\tdump_stack_print_info(log_lvl);\n\n\tprintk(\"", "963": "\",\n\t\t       rcp->name, rcp->ticks_this_gp, dyntick_task_exit_idle,\n\t\t       jiffies - rcp->gp_start, rcp->qlen);\n\t\tdump_stack();\n\t\taccess_once(rcp->jiffies_stall) = jiffies +\n\t\t\t3 * rcu_jiffies_till_stall_check() + 3;\n\t} else if (ulong_cmp_ge(j, js)) {\n\t\taccess_once(rcp->jiffies_stall) = jiffies + rcu_jiffies_till_stall_check();\n\t}\n}\n\nstatic void reset_cpu_stall_ticks(struct rcu_ctrlblk *rcp)\n{\n\trcp->ticks_this_gp = 0;\n\trcp->gp_start = jiffies;\n\taccess_once(rcp->jiffies_stall) = jiffies + rcu_jiffies_till_stall_check();\n}\n\nstatic void check_cpu_stalls(void)\n{\n\trcu_trace(check_cpu_stall(&rcu_bh_ctrlblk));\n\trcu_trace(check_cpu_stall(&rcu_sched_ctrlblk));\n}\n\n#endif \n\n\n#include <linux/gfp.h>\n#include <linux/sched.h>\n#include <linux/sched/rt.h>\n#include <linux/slab.h>\n#include \"", "964": "\",\n\t\t      \"", "965": "\",\n\t\t      (msg->facility << 3) | msg->level,\n\t\t      user->seq, ts_usec, cont);\n\tuser->prev = msg->flags;\n\n\t\n\tfor (i = 0; i < msg->text_len; i++) {\n\t\tunsigned char c = log_text(msg)[i];\n\n\t\tif (c < ' ' || c >= 127 || c == '\\\\')\n\t\t\tlen += sprintf(user->buf + len, \"", "966": "\",\n\t\t     *ptr == (unsigned long)-1 ? -1 : nsecs_to_usecs(*ptr));\n\tif (r > sizeof(buf))\n\t\tr = sizeof(buf);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\ntracing_nsecs_write(unsigned long *ptr, const char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t*ptr = val * 1000;\n\n\treturn cnt;\n}\n\nstatic ssize_t\ntracing_thresh_read(struct file *filp, char __user *ubuf,\n\t\t    size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(&tracing_thresh, ubuf, cnt, ppos);\n}\n\nstatic ssize_t\ntracing_thresh_write(struct file *filp, const char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\tret = tracing_nsecs_write(&tracing_thresh, ubuf, cnt, ppos);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (tr->current_trace->update_thresh) {\n\t\tret = tr->current_trace->update_thresh(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tret = cnt;\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_max_lat_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_read(filp->private_data, ubuf, cnt, ppos);\n}\n\nstatic ssize_t\ntracing_max_lat_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t cnt, loff_t *ppos)\n{\n\treturn tracing_nsecs_write(filp->private_data, ubuf, cnt, ppos);\n}\n\nstatic int tracing_open_pipe(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tstruct trace_iterator *iter;\n\tint ret = 0;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tmutex_lock(&trace_types_lock);\n\n\t\n\titer = kzalloc(sizeof(*iter), gfp_kernel);\n\tif (!iter) {\n\t\tret = -enomem;\n\t\t__trace_array_put(tr);\n\t\tgoto out;\n\t}\n\n\ttrace_seq_init(&iter->seq);\n\titer->trace = tr->current_trace;\n\n\tif (!alloc_cpumask_var(&iter->started, gfp_kernel)) {\n\t\tret = -enomem;\n\t\tgoto fail;\n\t}\n\n\t\n\tcpumask_setall(iter->started);\n\n\tif (trace_flags & trace_iter_latency_fmt)\n\t\titer->iter_flags |= trace_file_lat_fmt;\n\n\t\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\titer->iter_flags |= trace_file_time_in_ns;\n\n\titer->tr = tr;\n\titer->trace_buffer = &tr->trace_buffer;\n\titer->cpu_file = tracing_get_cpu(inode);\n\tmutex_init(&iter->mutex);\n\tfilp->private_data = iter;\n\n\tif (iter->trace->pipe_open)\n\t\titer->trace->pipe_open(iter);\n\n\tnonseekable_open(inode, filp);\n\n\ttr->current_trace->ref++;\nout:\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n\nfail:\n\tkfree(iter->trace);\n\tkfree(iter);\n\t__trace_array_put(tr);\n\tmutex_unlock(&trace_types_lock);\n\treturn ret;\n}\n\nstatic int tracing_release_pipe(struct inode *inode, struct file *file)\n{\n\tstruct trace_iterator *iter = file->private_data;\n\tstruct trace_array *tr = inode->i_private;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->current_trace->ref--;\n\n\tif (iter->trace->pipe_close)\n\t\titer->trace->pipe_close(iter);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tfree_cpumask_var(iter->started);\n\tmutex_destroy(&iter->mutex);\n\tkfree(iter);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n\nstatic unsigned int\ntrace_poll(struct trace_iterator *iter, struct file *filp, poll_table *poll_table)\n{\n\t\n\tif (trace_buffer_iter(iter, iter->cpu_file))\n\t\treturn pollin | pollrdnorm;\n\n\tif (trace_flags & trace_iter_block)\n\t\t\n\t\treturn pollin | pollrdnorm;\n\telse\n\t\treturn ring_buffer_poll_wait(iter->trace_buffer->buffer, iter->cpu_file,\n\t\t\t\t\t     filp, poll_table);\n}\n\nstatic unsigned int\ntracing_poll_pipe(struct file *filp, poll_table *poll_table)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\n\treturn trace_poll(iter, filp, poll_table);\n}\n\n\nstatic int tracing_wait_pipe(struct file *filp)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\tint ret;\n\n\twhile (trace_empty(iter)) {\n\n\t\tif ((filp->f_flags & o_nonblock)) {\n\t\t\treturn -eagain;\n\t\t}\n\n\t\t\n\t\tif (!tracing_is_on() && iter->pos)\n\t\t\tbreak;\n\n\t\tmutex_unlock(&iter->mutex);\n\n\t\tret = wait_on_pipe(iter, false);\n\n\t\tmutex_lock(&iter->mutex);\n\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 1;\n}\n\n\nstatic ssize_t\ntracing_read_pipe(struct file *filp, char __user *ubuf,\n\t\t  size_t cnt, loff_t *ppos)\n{\n\tstruct trace_iterator *iter = filp->private_data;\n\tssize_t sret;\n\n\t\n\tsret = trace_seq_to_user(&iter->seq, ubuf, cnt);\n\tif (sret != -ebusy)\n\t\treturn sret;\n\n\ttrace_seq_init(&iter->seq);\n\n\t\n\tmutex_lock(&iter->mutex);\n\tif (iter->trace->read) {\n\t\tsret = iter->trace->read(iter, filp, ubuf, cnt, ppos);\n\t\tif (sret)\n\t\t\tgoto out;\n\t}\n\nwaitagain:\n\tsret = tracing_wait_pipe(filp);\n\tif (sret <= 0)\n\t\tgoto out;\n\n\t\n\tif (trace_empty(iter)) {\n\t\tsret = 0;\n\t\tgoto out;\n\t}\n\n\tif (cnt >= page_size)\n\t\tcnt = page_size - 1;\n\n\t\n\tmemset(&iter->seq, 0,\n\t       sizeof(struct trace_iterator) -\n\t       offsetof(struct trace_iterator, seq));\n\tcpumask_clear(iter->started);\n\titer->pos = -1;\n\n\ttrace_event_read_lock();\n\ttrace_access_lock(iter->cpu_file);\n\twhile (trace_find_next_entry_inc(iter) != null) {\n\t\tenum print_line_t ret;\n\t\tint save_len = iter->seq.seq.len;\n\n\t\tret = print_trace_line(iter);\n\t\tif (ret == trace_type_partial_line) {\n\t\t\t\n\t\t\titer->seq.seq.len = save_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (ret != trace_type_no_consume)\n\t\t\ttrace_consume(iter);\n\n\t\tif (trace_seq_used(&iter->seq) >= cnt)\n\t\t\tbreak;\n\n\t\t\n\t\twarn_once(iter->seq.full, \"", "967": "\",\n\t\t    ktime_to_ns(delta));\n}\n\n\nstatic void __hrtimer_peek_ahead_timers(void)\n{\n\tstruct tick_device *td;\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\ttd = this_cpu_ptr(&tick_cpu_device);\n\tif (td && td->evtdev)\n\t\thrtimer_interrupt(td->evtdev);\n}\n\n\nvoid hrtimer_peek_ahead_timers(void)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_restore(flags);\n}\n\nstatic void run_hrtimer_softirq(struct softirq_action *h)\n{\n\thrtimer_peek_ahead_timers();\n}\n\n#else \n\nstatic inline void __hrtimer_peek_ahead_timers(void) { }\n\n#endif\t\n\n\nvoid hrtimer_run_pending(void)\n{\n\tif (hrtimer_hres_active())\n\t\treturn;\n\n\t\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled()))\n\t\thrtimer_switch_to_hres();\n}\n\n\nvoid hrtimer_run_queues(void)\n{\n\tstruct timerqueue_node *node;\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tstruct hrtimer_clock_base *base;\n\tint index, gettime = 1;\n\n\tif (hrtimer_hres_active())\n\t\treturn;\n\n\tfor (index = 0; index < hrtimer_max_clock_bases; index++) {\n\t\tbase = &cpu_base->clock_base[index];\n\t\tif (!timerqueue_getnext(&base->active))\n\t\t\tcontinue;\n\n\t\tif (gettime) {\n\t\t\thrtimer_get_softirq_time(cpu_base);\n\t\t\tgettime = 0;\n\t\t}\n\n\t\traw_spin_lock(&cpu_base->lock);\n\n\t\twhile ((node = timerqueue_getnext(&base->active))) {\n\t\t\tstruct hrtimer *timer;\n\n\t\t\ttimer = container_of(node, struct hrtimer, node);\n\t\t\tif (base->softirq_time.tv64 <=\n\t\t\t\t\thrtimer_get_expires_tv64(timer))\n\t\t\t\tbreak;\n\n\t\t\t__run_hrtimer(timer, &base->softirq_time);\n\t\t}\n\t\traw_spin_unlock(&cpu_base->lock);\n\t}\n}\n\n\nstatic enum hrtimer_restart hrtimer_wakeup(struct hrtimer *timer)\n{\n\tstruct hrtimer_sleeper *t =\n\t\tcontainer_of(timer, struct hrtimer_sleeper, timer);\n\tstruct task_struct *task = t->task;\n\n\tt->task = null;\n\tif (task)\n\t\twake_up_process(task);\n\n\treturn hrtimer_norestart;\n}\n\nvoid hrtimer_init_sleeper(struct hrtimer_sleeper *sl, struct task_struct *task)\n{\n\tsl->timer.function = hrtimer_wakeup;\n\tsl->task = task;\n}\nexport_symbol_gpl(hrtimer_init_sleeper);\n\nstatic int __sched do_nanosleep(struct hrtimer_sleeper *t, enum hrtimer_mode mode)\n{\n\thrtimer_init_sleeper(t, current);\n\n\tdo {\n\t\tset_current_state(task_interruptible);\n\t\thrtimer_start_expires(&t->timer, mode);\n\t\tif (!hrtimer_active(&t->timer))\n\t\t\tt->task = null;\n\n\t\tif (likely(t->task))\n\t\t\tfreezable_schedule();\n\n\t\thrtimer_cancel(&t->timer);\n\t\tmode = hrtimer_mode_abs;\n\n\t} while (t->task && !signal_pending(current));\n\n\t__set_current_state(task_running);\n\n\treturn t->task == null;\n}\n\nstatic int update_rmtp(struct hrtimer *timer, struct timespec __user *rmtp)\n{\n\tstruct timespec rmt;\n\tktime_t rem;\n\n\trem = hrtimer_expires_remaining(timer);\n\tif (rem.tv64 <= 0)\n\t\treturn 0;\n\trmt = ktime_to_timespec(rem);\n\n\tif (copy_to_user(rmtp, &rmt, sizeof(*rmtp)))\n\t\treturn -efault;\n\n\treturn 1;\n}\n\nlong __sched hrtimer_nanosleep_restart(struct restart_block *restart)\n{\n\tstruct hrtimer_sleeper t;\n\tstruct timespec __user  *rmtp;\n\tint ret = 0;\n\n\thrtimer_init_on_stack(&t.timer, restart->nanosleep.clockid,\n\t\t\t\thrtimer_mode_abs);\n\thrtimer_set_expires_tv64(&t.timer, restart->nanosleep.expires);\n\n\tif (do_nanosleep(&t, hrtimer_mode_abs))\n\t\tgoto out;\n\n\trmtp = restart->nanosleep.rmtp;\n\tif (rmtp) {\n\t\tret = update_rmtp(&t.timer, rmtp);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\t\n\tret = -erestart_restartblock;\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}\n\nlong hrtimer_nanosleep(struct timespec *rqtp, struct timespec __user *rmtp,\n\t\t       const enum hrtimer_mode mode, const clockid_t clockid)\n{\n\tstruct restart_block *restart;\n\tstruct hrtimer_sleeper t;\n\tint ret = 0;\n\tunsigned long slack;\n\n\tslack = current->timer_slack_ns;\n\tif (dl_task(current) || rt_task(current))\n\t\tslack = 0;\n\n\thrtimer_init_on_stack(&t.timer, clockid, mode);\n\thrtimer_set_expires_range_ns(&t.timer, timespec_to_ktime(*rqtp), slack);\n\tif (do_nanosleep(&t, mode))\n\t\tgoto out;\n\n\t\n\tif (mode == hrtimer_mode_abs) {\n\t\tret = -erestartnohand;\n\t\tgoto out;\n\t}\n\n\tif (rmtp) {\n\t\tret = update_rmtp(&t.timer, rmtp);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\trestart = &current->restart_block;\n\trestart->fn = hrtimer_nanosleep_restart;\n\trestart->nanosleep.clockid = t.timer.base->clockid;\n\trestart->nanosleep.rmtp = rmtp;\n\trestart->nanosleep.expires = hrtimer_get_expires_tv64(&t.timer);\n\n\tret = -erestart_restartblock;\nout:\n\tdestroy_hrtimer_on_stack(&t.timer);\n\treturn ret;\n}\n\nsyscall_define2(nanosleep, struct timespec __user *, rqtp,\n\t\tstruct timespec __user *, rmtp)\n{\n\tstruct timespec tu;\n\n\tif (copy_from_user(&tu, rqtp, sizeof(tu)))\n\t\treturn -efault;\n\n\tif (!timespec_valid(&tu))\n\t\treturn -einval;\n\n\treturn hrtimer_nanosleep(&tu, rmtp, hrtimer_mode_rel, clock_monotonic);\n}\n\n\nstatic void init_hrtimers_cpu(int cpu)\n{\n\tstruct hrtimer_cpu_base *cpu_base = &per_cpu(hrtimer_bases, cpu);\n\tint i;\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tcpu_base->clock_base[i].cpu_base = cpu_base;\n\t\ttimerqueue_init_head(&cpu_base->clock_base[i].active);\n\t}\n\n\tcpu_base->cpu = cpu;\n\thrtimer_init_hres(cpu_base);\n}\n\n#ifdef config_hotplug_cpu\n\nstatic void migrate_hrtimer_list(struct hrtimer_clock_base *old_base,\n\t\t\t\tstruct hrtimer_clock_base *new_base)\n{\n\tstruct hrtimer *timer;\n\tstruct timerqueue_node *node;\n\n\twhile ((node = timerqueue_getnext(&old_base->active))) {\n\t\ttimer = container_of(node, struct hrtimer, node);\n\t\tbug_on(hrtimer_callback_running(timer));\n\t\tdebug_deactivate(timer);\n\n\t\t\n\t\t__remove_hrtimer(timer, old_base, hrtimer_state_migrate, 0);\n\t\ttimer->base = new_base;\n\t\t\n\t\tenqueue_hrtimer(timer, new_base);\n\n\t\t\n\t\ttimer->state &= ~hrtimer_state_migrate;\n\t}\n}\n\nstatic void migrate_hrtimers(int scpu)\n{\n\tstruct hrtimer_cpu_base *old_base, *new_base;\n\tint i;\n\n\tbug_on(cpu_online(scpu));\n\ttick_cancel_sched_timer(scpu);\n\n\tlocal_irq_disable();\n\told_base = &per_cpu(hrtimer_bases, scpu);\n\tnew_base = this_cpu_ptr(&hrtimer_bases);\n\t\n\traw_spin_lock(&new_base->lock);\n\traw_spin_lock_nested(&old_base->lock, single_depth_nesting);\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tmigrate_hrtimer_list(&old_base->clock_base[i],\n\t\t\t\t     &new_base->clock_base[i]);\n\t}\n\n\traw_spin_unlock(&old_base->lock);\n\traw_spin_unlock(&new_base->lock);\n\n\t\n\t__hrtimer_peek_ahead_timers();\n\tlocal_irq_enable();\n}\n\n#endif \n\nstatic int hrtimer_cpu_notify(struct notifier_block *self,\n\t\t\t\t\tunsigned long action, void *hcpu)\n{\n\tint scpu = (long)hcpu;\n\n\tswitch (action) {\n\n\tcase cpu_up_prepare:\n\tcase cpu_up_prepare_frozen:\n\t\tinit_hrtimers_cpu(scpu);\n\t\tbreak;\n\n#ifdef config_hotplug_cpu\n\tcase cpu_dead:\n\tcase cpu_dead_frozen:\n\t\tmigrate_hrtimers(scpu);\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notify_ok;\n}\n\nstatic struct notifier_block hrtimers_nb = {\n\t.notifier_call = hrtimer_cpu_notify,\n};\n\nvoid __init hrtimers_init(void)\n{\n\thrtimer_cpu_notify(&hrtimers_nb, (unsigned long)cpu_up_prepare,\n\t\t\t  (void *)(long)smp_processor_id());\n\tregister_cpu_notifier(&hrtimers_nb);\n#ifdef config_high_res_timers\n\topen_softirq(hrtimer_softirq, run_hrtimer_softirq);\n#endif\n}\n\n\nint __sched\nschedule_hrtimeout_range_clock(ktime_t *expires, unsigned long delta,\n\t\t\t       const enum hrtimer_mode mode, int clock)\n{\n\tstruct hrtimer_sleeper t;\n\n\t\n\tif (expires && !expires->tv64) {\n\t\t__set_current_state(task_running);\n\t\treturn 0;\n\t}\n\n\t\n\tif (!expires) {\n\t\tschedule();\n\t\treturn -eintr;\n\t}\n\n\thrtimer_init_on_stack(&t.timer, clock, mode);\n\thrtimer_set_expires_range_ns(&t.timer, *expires, delta);\n\n\thrtimer_init_sleeper(&t, current);\n\n\thrtimer_start_expires(&t.timer, mode);\n\tif (!hrtimer_active(&t.timer))\n\t\tt.task = null;\n\n\tif (likely(t.task))\n\t\tschedule();\n\n\thrtimer_cancel(&t.timer);\n\tdestroy_hrtimer_on_stack(&t.timer);\n\n\t__set_current_state(task_running);\n\n\treturn !t.task ? 0 : -eintr;\n}\n\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, unsigned long delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      clock_monotonic);\n}\nexport_symbol_gpl(schedule_hrtimeout_range);\n\n\nint __sched schedule_hrtimeout(ktime_t *expires,\n\t\t\t       const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range(expires, 0, mode);\n}\nexport_symbol_gpl(schedule_hrtimeout);\n\n#include <linux/user-return-notifier.h>\n#include <linux/percpu.h>\n#include <linux/sched.h>\n#include <linux/export.h>\n\nstatic define_per_cpu(struct hlist_head, return_notifier_list);\n\n\nvoid user_return_notifier_register(struct user_return_notifier *urn)\n{\n\tset_tsk_thread_flag(current, tif_user_return_notify);\n\thlist_add_head(&urn->link, this_cpu_ptr(&return_notifier_list));\n}\nexport_symbol_gpl(user_return_notifier_register);\n\n\nvoid user_return_notifier_unregister(struct user_return_notifier *urn)\n{\n\thlist_del(&urn->link);\n\tif (hlist_empty(this_cpu_ptr(&return_notifier_list)))\n\t\tclear_tsk_thread_flag(current, tif_user_return_notify);\n}\nexport_symbol_gpl(user_return_notifier_unregister);\n\n\nvoid fire_user_return_notifiers(void)\n{\n\tstruct user_return_notifier *urn;\n\tstruct hlist_node *tmp2;\n\tstruct hlist_head *head;\n\n\thead = &get_cpu_var(return_notifier_list);\n\thlist_for_each_entry_safe(urn, tmp2, head, link)\n\t\turn->on_user_return(urn);\n\tput_cpu_var(return_notifier_list);\n}\n#define pr_fmt(fmt) kbuild_modname \"", "968": "\",\n\t\t   \"", "969": "\",\n\t\t   (unsigned long long) dev->max_delta_ns);\n\tseq_printf(m, \"", "970": "\",\n\t\t   (unsigned long long) dev->min_delta_ns);\n\tseq_printf(m, \"", "971": "\",\n\t\t   (unsigned long long) ktime_to_ns(base->offset));\n#endif\n\tseq_printf(m,   \"", "972": "\",\n\t\t   (unsigned long long) ktime_to_ns(dev->next_event));\n\n\tseq_printf(m, \"", "973": "\",\n\t\t   cpumask_bits(tick_get_broadcast_mask())[0]);\n#ifdef config_tick_oneshot\n\tseq_printf(m, \"", "974": "\",\n\t\t   cpumask_bits(tick_get_broadcast_oneshot_mask())[0]);\n#endif\n\tseq_printf(m, \"", "975": "\",\n\t\t   data->comm, data->pid,\n\t\t   from_kuid_munged(seq_user_ns(m), data->uid), data->nice,\n\t\t   data->policy, data->rt_priority);\n\tseq_puts(m, \"", "976": "\",\n\t\t   entries, total, num_online_cpus());\n\tseq_puts(m, \"", "977": "\",\n\t\t   name, uts_release);\n\tseq_puts(m, \"", "978": "\",\n\t\t   nsecs_to_usecs(data->saved_latency),\n\t\t   entries,\n\t\t   total,\n\t\t   buf->cpu,\n#if defined(config_preempt_none)\n\t\t   \"", "979": "\",\n\t\t   ptr->map.enum_string, ptr->map.enum_value,\n\t\t   ptr->map.system);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_enum_map_seq_ops = {\n\t.start\t\t= enum_map_start,\n\t.next\t\t= enum_map_next,\n\t.stop\t\t= enum_map_stop,\n\t.show\t\t= enum_map_show,\n};\n\nstatic int tracing_enum_map_open(struct inode *inode, struct file *filp)\n{\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\treturn seq_open(filp, &tracing_enum_map_seq_ops);\n}\n\nstatic const struct file_operations tracing_enum_map_fops = {\n\t.open\t\t= tracing_enum_map_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic inline union trace_enum_map_item *\ntrace_enum_jmp_to_tail(union trace_enum_map_item *ptr)\n{\n\t\n\treturn ptr + ptr->head.length + 1;\n}\n\nstatic void\ntrace_insert_enum_map_file(struct module *mod, struct trace_enum_map **start,\n\t\t\t   int len)\n{\n\tstruct trace_enum_map **stop;\n\tstruct trace_enum_map **map;\n\tunion trace_enum_map_item *map_array;\n\tunion trace_enum_map_item *ptr;\n\n\tstop = start + len;\n\n\t\n\tmap_array = kmalloc(sizeof(*map_array) * (len + 2), gfp_kernel);\n\tif (!map_array) {\n\t\tpr_warning(\"", "980": "\",\n\t\t(console->flags & con_boot) ? \"", "981": "\",\n\t\t(newcon->flags & con_boot) ? \"", "982": "\",\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_softexpires(timer)),\n\t\t(unsigned long long)ktime_to_ns(hrtimer_get_expires(timer)),\n\t\t(long long)(ktime_to_ns(hrtimer_get_softexpires(timer)) - now),\n\t\t(long long)(ktime_to_ns(hrtimer_get_expires(timer)) - now));\n}\n\nstatic void\nprint_active_timers(struct seq_file *m, struct hrtimer_clock_base *base,\n\t\t    u64 now)\n{\n\tstruct hrtimer *timer, tmp;\n\tunsigned long next = 0, i;\n\tstruct timerqueue_node *curr;\n\tunsigned long flags;\n\nnext_one:\n\ti = 0;\n\traw_spin_lock_irqsave(&base->cpu_base->lock, flags);\n\n\tcurr = timerqueue_getnext(&base->active);\n\t\n\twhile (curr && i < next) {\n\t\tcurr = timerqueue_iterate_next(curr);\n\t\ti++;\n\t}\n\n\tif (curr) {\n\n\t\ttimer = container_of(curr, struct hrtimer, node);\n\t\ttmp = *timer;\n\t\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n\n\t\tprint_timer(m, timer, &tmp, i, now);\n\t\tnext++;\n\t\tgoto next_one;\n\t}\n\traw_spin_unlock_irqrestore(&base->cpu_base->lock, flags);\n}\n\nstatic void\nprint_base(struct seq_file *m, struct hrtimer_clock_base *base, u64 now)\n{\n\tseq_printf(m, \"", "983": "\",\n\t\t.data\t\t= init_uts_ns.name.domainname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.domainname),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &domainname_poll,\n\t},\n\t{}\n};\n\nstatic struct ctl_table uts_root_table[] = {\n\t{\n\t\t.procname\t= \"", "984": "\",\n\t\t.data\t\t= init_uts_ns.name.nodename,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.nodename),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &hostname_poll,\n\t},\n\t{\n\t\t.procname\t= \"", "985": "\",\n\t\t.data\t\t= init_uts_ns.name.release,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.release),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"", "986": "\",\n\t\t.data\t\t= init_uts_ns.name.sysname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.sysname),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"", "987": "\",\n\t\t.data\t\t= init_uts_ns.name.version,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.version),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"", "988": "\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= uts_kern_table,\n\t},\n\t{}\n};\n\n#ifdef config_proc_sysctl\n\nvoid uts_proc_notify(enum uts_proc proc)\n{\n\tstruct ctl_table *table = &uts_kern_table[proc];\n\n\tproc_sys_poll_notify(table->poll);\n}\n#endif\n\nstatic int __init utsname_sysctl_init(void)\n{\n\tregister_sysctl_table(uts_root_table);\n\treturn 0;\n}\n\ndevice_initcall(utsname_sysctl_init);\n\n#include <linux/errno.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/string.h>\n#include <linux/relay.h>\n#include <linux/vmalloc.h>\n#include <linux/mm.h>\n#include <linux/cpu.h>\n#include <linux/splice.h>\n\n\nstatic define_mutex(relay_channels_mutex);\nstatic list_head(relay_channels);\n\n\nstatic void relay_file_mmap_close(struct vm_area_struct *vma)\n{\n\tstruct rchan_buf *buf = vma->vm_private_data;\n\tbuf->chan->cb->buf_unmapped(buf, vma->vm_file);\n}\n\n\nstatic int relay_buf_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page;\n\tstruct rchan_buf *buf = vma->vm_private_data;\n\tpgoff_t pgoff = vmf->pgoff;\n\n\tif (!buf)\n\t\treturn vm_fault_oom;\n\n\tpage = vmalloc_to_page(buf->start + (pgoff << page_shift));\n\tif (!page)\n\t\treturn vm_fault_sigbus;\n\tget_page(page);\n\tvmf->page = page;\n\n\treturn 0;\n}\n\n\nstatic const struct vm_operations_struct relay_file_mmap_ops = {\n\t.fault = relay_buf_fault,\n\t.close = relay_file_mmap_close,\n};\n\n\nstatic struct page **relay_alloc_page_array(unsigned int n_pages)\n{\n\tconst size_t pa_size = n_pages * sizeof(struct page *);\n\tif (pa_size > page_size)\n\t\treturn vzalloc(pa_size);\n\treturn kzalloc(pa_size, gfp_kernel);\n}\n\n\nstatic void relay_free_page_array(struct page **array)\n{\n\tif (is_vmalloc_addr(array))\n\t\tvfree(array);\n\telse\n\t\tkfree(array);\n}\n\n\nstatic int relay_mmap_buf(struct rchan_buf *buf, struct vm_area_struct *vma)\n{\n\tunsigned long length = vma->vm_end - vma->vm_start;\n\tstruct file *filp = vma->vm_file;\n\n\tif (!buf)\n\t\treturn -ebadf;\n\n\tif (length != (unsigned long)buf->chan->alloc_size)\n\t\treturn -einval;\n\n\tvma->vm_ops = &relay_file_mmap_ops;\n\tvma->vm_flags |= vm_dontexpand;\n\tvma->vm_private_data = buf;\n\tbuf->chan->cb->buf_mapped(buf, filp);\n\n\treturn 0;\n}\n\n\nstatic void *relay_alloc_buf(struct rchan_buf *buf, size_t *size)\n{\n\tvoid *mem;\n\tunsigned int i, j, n_pages;\n\n\t*size = page_align(*size);\n\tn_pages = *size >> page_shift;\n\n\tbuf->page_array = relay_alloc_page_array(n_pages);\n\tif (!buf->page_array)\n\t\treturn null;\n\n\tfor (i = 0; i < n_pages; i++) {\n\t\tbuf->page_array[i] = alloc_page(gfp_kernel);\n\t\tif (unlikely(!buf->page_array[i]))\n\t\t\tgoto depopulate;\n\t\tset_page_private(buf->page_array[i], (unsigned long)buf);\n\t}\n\tmem = vmap(buf->page_array, n_pages, vm_map, page_kernel);\n\tif (!mem)\n\t\tgoto depopulate;\n\n\tmemset(mem, 0, *size);\n\tbuf->page_count = n_pages;\n\treturn mem;\n\ndepopulate:\n\tfor (j = 0; j < i; j++)\n\t\t__free_page(buf->page_array[j]);\n\trelay_free_page_array(buf->page_array);\n\treturn null;\n}\n\n\nstatic struct rchan_buf *relay_create_buf(struct rchan *chan)\n{\n\tstruct rchan_buf *buf;\n\n\tif (chan->n_subbufs > uint_max / sizeof(size_t *))\n\t\treturn null;\n\n\tbuf = kzalloc(sizeof(struct rchan_buf), gfp_kernel);\n\tif (!buf)\n\t\treturn null;\n\tbuf->padding = kmalloc(chan->n_subbufs * sizeof(size_t *), gfp_kernel);\n\tif (!buf->padding)\n\t\tgoto free_buf;\n\n\tbuf->start = relay_alloc_buf(buf, &chan->alloc_size);\n\tif (!buf->start)\n\t\tgoto free_buf;\n\n\tbuf->chan = chan;\n\tkref_get(&buf->chan->kref);\n\treturn buf;\n\nfree_buf:\n\tkfree(buf->padding);\n\tkfree(buf);\n\treturn null;\n}\n\n\nstatic void relay_destroy_channel(struct kref *kref)\n{\n\tstruct rchan *chan = container_of(kref, struct rchan, kref);\n\tkfree(chan);\n}\n\n\nstatic void relay_destroy_buf(struct rchan_buf *buf)\n{\n\tstruct rchan *chan = buf->chan;\n\tunsigned int i;\n\n\tif (likely(buf->start)) {\n\t\tvunmap(buf->start);\n\t\tfor (i = 0; i < buf->page_count; i++)\n\t\t\t__free_page(buf->page_array[i]);\n\t\trelay_free_page_array(buf->page_array);\n\t}\n\tchan->buf[buf->cpu] = null;\n\tkfree(buf->padding);\n\tkfree(buf);\n\tkref_put(&chan->kref, relay_destroy_channel);\n}\n\n\nstatic void relay_remove_buf(struct kref *kref)\n{\n\tstruct rchan_buf *buf = container_of(kref, struct rchan_buf, kref);\n\trelay_destroy_buf(buf);\n}\n\n\nstatic int relay_buf_empty(struct rchan_buf *buf)\n{\n\treturn (buf->subbufs_produced - buf->subbufs_consumed) ? 0 : 1;\n}\n\n\nint relay_buf_full(struct rchan_buf *buf)\n{\n\tsize_t ready = buf->subbufs_produced - buf->subbufs_consumed;\n\treturn (ready >= buf->chan->n_subbufs) ? 1 : 0;\n}\nexport_symbol_gpl(relay_buf_full);\n\n\n\n\n\n\nstatic int subbuf_start_default_callback (struct rchan_buf *buf,\n\t\t\t\t\t  void *subbuf,\n\t\t\t\t\t  void *prev_subbuf,\n\t\t\t\t\t  size_t prev_padding)\n{\n\tif (relay_buf_full(buf))\n\t\treturn 0;\n\n\treturn 1;\n}\n\n\nstatic void buf_mapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\tstruct file *filp)\n{\n}\n\n\nstatic void buf_unmapped_default_callback(struct rchan_buf *buf,\n\t\t\t\t\t  struct file *filp)\n{\n}\n\n\nstatic struct dentry *create_buf_file_default_callback(const char *filename,\n\t\t\t\t\t\t       struct dentry *parent,\n\t\t\t\t\t\t       umode_t mode,\n\t\t\t\t\t\t       struct rchan_buf *buf,\n\t\t\t\t\t\t       int *is_global)\n{\n\treturn null;\n}\n\n\nstatic int remove_buf_file_default_callback(struct dentry *dentry)\n{\n\treturn -einval;\n}\n\n\nstatic struct rchan_callbacks default_channel_callbacks = {\n\t.subbuf_start = subbuf_start_default_callback,\n\t.buf_mapped = buf_mapped_default_callback,\n\t.buf_unmapped = buf_unmapped_default_callback,\n\t.create_buf_file = create_buf_file_default_callback,\n\t.remove_buf_file = remove_buf_file_default_callback,\n};\n\n\nstatic void wakeup_readers(unsigned long data)\n{\n\tstruct rchan_buf *buf = (struct rchan_buf *)data;\n\twake_up_interruptible(&buf->read_wait);\n}\n\n\nstatic void __relay_reset(struct rchan_buf *buf, unsigned int init)\n{\n\tsize_t i;\n\n\tif (init) {\n\t\tinit_waitqueue_head(&buf->read_wait);\n\t\tkref_init(&buf->kref);\n\t\tsetup_timer(&buf->timer, wakeup_readers, (unsigned long)buf);\n\t} else\n\t\tdel_timer_sync(&buf->timer);\n\n\tbuf->subbufs_produced = 0;\n\tbuf->subbufs_consumed = 0;\n\tbuf->bytes_consumed = 0;\n\tbuf->finalized = 0;\n\tbuf->data = buf->start;\n\tbuf->offset = 0;\n\n\tfor (i = 0; i < buf->chan->n_subbufs; i++)\n\t\tbuf->padding[i] = 0;\n\n\tbuf->chan->cb->subbuf_start(buf, buf->data, null, 0);\n}\n\n\nvoid relay_reset(struct rchan *chan)\n{\n\tunsigned int i;\n\n\tif (!chan)\n\t\treturn;\n\n\tif (chan->is_global && chan->buf[0]) {\n\t\t__relay_reset(chan->buf[0], 0);\n\t\treturn;\n\t}\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_possible_cpu(i)\n\t\tif (chan->buf[i])\n\t\t\t__relay_reset(chan->buf[i], 0);\n\tmutex_unlock(&relay_channels_mutex);\n}\nexport_symbol_gpl(relay_reset);\n\nstatic inline void relay_set_buf_dentry(struct rchan_buf *buf,\n\t\t\t\t\tstruct dentry *dentry)\n{\n\tbuf->dentry = dentry;\n\td_inode(buf->dentry)->i_size = buf->early_bytes;\n}\n\nstatic struct dentry *relay_create_buf_file(struct rchan *chan,\n\t\t\t\t\t    struct rchan_buf *buf,\n\t\t\t\t\t    unsigned int cpu)\n{\n\tstruct dentry *dentry;\n\tchar *tmpname;\n\n\ttmpname = kzalloc(name_max + 1, gfp_kernel);\n\tif (!tmpname)\n\t\treturn null;\n\tsnprintf(tmpname, name_max, \"", "989": "\",\n\t\t__log_cpu_max_buf_len);\n\tpr_info(\"", "990": "\",\n\t\tbits, r, r_unit, res, wrap);\n\n\t\n\tif (irqtime > 0 || (irqtime == -1 && rate >= 1000000))\n\t\tenable_sched_clock_irqtime();\n\n\tpr_debug(\"", "991": "\",\n\t\tboot_delay, preset_lpj, lpj, hz, loops_per_msec);\n\treturn 0;\n}\nearly_param(\"", "992": "\",\n\t\tcount, count / entries_per_page + 1);\n\n\tlast_ftrace_enabled = ftrace_enabled = 1;\n\n\tret = ftrace_process_locs(null,\n\t\t\t\t  __start_mcount_loc,\n\t\t\t\t  __stop_mcount_loc);\n\n\tret = register_module_notifier(&ftrace_module_exit_nb);\n\tif (ret)\n\t\tpr_warning(\"", "993": "\",\n\t\tcpu_extra);\n\tpr_info(\"", "994": "\",\n\t\tcs->name);\n\n\tclocksource_update_max_deferment(cs);\n\n\tpr_info(\"", "995": "\",\n\t\tcurr->comm, task_pid_nr(curr));\n\tprint_lock(check_src);\n\tprintk(\"", "996": "\",\n\t\tcurr->comm, task_pid_nr(curr),\n\t\tcurr->hardirq_context, hardirq_count() >> hardirq_shift,\n\t\tcurr->softirq_context, softirq_count() >> softirq_shift,\n\t\tcurr->hardirqs_enabled,\n\t\tcurr->softirqs_enabled);\n\tprint_lock(next);\n\n\tprintk(\"", "997": "\",\n\t\tfree, (free * 100) / __log_buf_len);\n}\n\nstatic bool __read_mostly ignore_loglevel;\n\nstatic int __init ignore_loglevel_setup(char *str)\n{\n\tignore_loglevel = true;\n\tpr_info(\"", "998": "\",\n\t\thwirq, of_node_full_name(domain->of_node), virq);\n\n\treturn virq;\n}\nexport_symbol_gpl(irq_create_mapping);\n\n\nint irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tint ret;\n\n\tret = irq_alloc_descs(irq_base, irq_base, count,\n\t\t\t      of_node_to_nid(domain->of_node));\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tirq_domain_associate_many(domain, irq_base, hwirq_base, count);\n\treturn 0;\n}\nexport_symbol_gpl(irq_create_strict_mappings);\n\nunsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_domain *domain;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = irq_type_none;\n\tint virq;\n\n\tdomain = irq_data->np ? irq_find_host(irq_data->np) : irq_default_domain;\n\tif (!domain) {\n\t\tpr_warn(\"", "999": "\",\n\t\tirqclass);\n\tprint_lock_name(backwards_entry->class);\n\tprintk(\"", "1000": "\",\n\t\tirqclass, irqclass);\n\tprint_kernel_ident();\n\tprintk(\"", "1001": "\",\n\t       default_bootup_tracer);\n\tdefault_bootup_tracer = null;\n\n\treturn 0;\n}\n\nfs_initcall(tracer_init_tracefs);\nlate_initcall(clear_boot_tracer);\n\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/deadline.h>\n#include <linux/timer.h>\n\n#include \"", "1002": "\",\n\t       log_lvl, current, current_thread_info(),\n\t       task_thread_info(current));\n}\n\n#endif\n\n\n#include <linux/sched.h>\n#include <linux/posix-timers.h>\n#include <linux/errno.h>\n#include <linux/math64.h>\n#include <asm/uaccess.h>\n#include <linux/kernel_stat.h>\n#include <trace/events/timer.h>\n#include <linux/random.h>\n#include <linux/tick.h>\n#include <linux/workqueue.h>\n\n\nvoid update_rlimit_cpu(struct task_struct *task, unsigned long rlim_new)\n{\n\tcputime_t cputime = secs_to_cputime(rlim_new);\n\n\tspin_lock_irq(&task->sighand->siglock);\n\tset_process_cpu_timer(task, cpuclock_prof, &cputime, null);\n\tspin_unlock_irq(&task->sighand->siglock);\n}\n\nstatic int check_clock(const clockid_t which_clock)\n{\n\tint error = 0;\n\tstruct task_struct *p;\n\tconst pid_t pid = cpuclock_pid(which_clock);\n\n\tif (cpuclock_which(which_clock) >= cpuclock_max)\n\t\treturn -einval;\n\n\tif (pid == 0)\n\t\treturn 0;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (!p || !(cpuclock_perthread(which_clock) ?\n\t\t   same_thread_group(p, current) : has_group_leader_pid(p))) {\n\t\terror = -einval;\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nstatic inline unsigned long long\ntimespec_to_sample(const clockid_t which_clock, const struct timespec *tp)\n{\n\tunsigned long long ret;\n\n\tret = 0;\t\t\n\tif (cpuclock_which(which_clock) == cpuclock_sched) {\n\t\tret = (unsigned long long)tp->tv_sec * nsec_per_sec + tp->tv_nsec;\n\t} else {\n\t\tret = cputime_to_expires(timespec_to_cputime(tp));\n\t}\n\treturn ret;\n}\n\nstatic void sample_to_timespec(const clockid_t which_clock,\n\t\t\t       unsigned long long expires,\n\t\t\t       struct timespec *tp)\n{\n\tif (cpuclock_which(which_clock) == cpuclock_sched)\n\t\t*tp = ns_to_timespec(expires);\n\telse\n\t\tcputime_to_timespec((__force cputime_t)expires, tp);\n}\n\n\nstatic void bump_cpu_timer(struct k_itimer *timer,\n\t\t\t   unsigned long long now)\n{\n\tint i;\n\tunsigned long long delta, incr;\n\n\tif (timer->it.cpu.incr == 0)\n\t\treturn;\n\n\tif (now < timer->it.cpu.expires)\n\t\treturn;\n\n\tincr = timer->it.cpu.incr;\n\tdelta = now + incr - timer->it.cpu.expires;\n\n\t\n\tfor (i = 0; incr < delta - incr; i++)\n\t\tincr = incr << 1;\n\n\tfor (; i >= 0; incr >>= 1, i--) {\n\t\tif (delta < incr)\n\t\t\tcontinue;\n\n\t\ttimer->it.cpu.expires += incr;\n\t\ttimer->it_overrun += 1 << i;\n\t\tdelta -= incr;\n\t}\n}\n\n\nstatic inline int task_cputime_zero(const struct task_cputime *cputime)\n{\n\tif (!cputime->utime && !cputime->stime && !cputime->sum_exec_runtime)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline unsigned long long prof_ticks(struct task_struct *p)\n{\n\tcputime_t utime, stime;\n\n\ttask_cputime(p, &utime, &stime);\n\n\treturn cputime_to_expires(utime + stime);\n}\nstatic inline unsigned long long virt_ticks(struct task_struct *p)\n{\n\tcputime_t utime;\n\n\ttask_cputime(p, &utime, null);\n\n\treturn cputime_to_expires(utime);\n}\n\nstatic int\nposix_cpu_clock_getres(const clockid_t which_clock, struct timespec *tp)\n{\n\tint error = check_clock(which_clock);\n\tif (!error) {\n\t\ttp->tv_sec = 0;\n\t\ttp->tv_nsec = ((nsec_per_sec + hz - 1) / hz);\n\t\tif (cpuclock_which(which_clock) == cpuclock_sched) {\n\t\t\t\n\t\t\ttp->tv_nsec = 1;\n\t\t}\n\t}\n\treturn error;\n}\n\nstatic int\nposix_cpu_clock_set(const clockid_t which_clock, const struct timespec *tp)\n{\n\t\n\tint error = check_clock(which_clock);\n\tif (error == 0) {\n\t\terror = -eperm;\n\t}\n\treturn error;\n}\n\n\n\nstatic int cpu_clock_sample(const clockid_t which_clock, struct task_struct *p,\n\t\t\t    unsigned long long *sample)\n{\n\tswitch (cpuclock_which(which_clock)) {\n\tdefault:\n\t\treturn -einval;\n\tcase cpuclock_prof:\n\t\t*sample = prof_ticks(p);\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\t*sample = virt_ticks(p);\n\t\tbreak;\n\tcase cpuclock_sched:\n\t\t*sample = task_sched_runtime(p);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic void update_gt_cputime(struct task_cputime *a, struct task_cputime *b)\n{\n\tif (b->utime > a->utime)\n\t\ta->utime = b->utime;\n\n\tif (b->stime > a->stime)\n\t\ta->stime = b->stime;\n\n\tif (b->sum_exec_runtime > a->sum_exec_runtime)\n\t\ta->sum_exec_runtime = b->sum_exec_runtime;\n}\n\nvoid thread_group_cputimer(struct task_struct *tsk, struct task_cputime *times)\n{\n\tstruct thread_group_cputimer *cputimer = &tsk->signal->cputimer;\n\tstruct task_cputime sum;\n\tunsigned long flags;\n\n\tif (!cputimer->running) {\n\t\t\n\t\tthread_group_cputime(tsk, &sum);\n\t\traw_spin_lock_irqsave(&cputimer->lock, flags);\n\t\tcputimer->running = 1;\n\t\tupdate_gt_cputime(&cputimer->cputime, &sum);\n\t} else\n\t\traw_spin_lock_irqsave(&cputimer->lock, flags);\n\t*times = cputimer->cputime;\n\traw_spin_unlock_irqrestore(&cputimer->lock, flags);\n}\n\n\nstatic int cpu_clock_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  unsigned long long *sample)\n{\n\tstruct task_cputime cputime;\n\n\tswitch (cpuclock_which(which_clock)) {\n\tdefault:\n\t\treturn -einval;\n\tcase cpuclock_prof:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime_to_expires(cputime.utime + cputime.stime);\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime_to_expires(cputime.utime);\n\t\tbreak;\n\tcase cpuclock_sched:\n\t\tthread_group_cputime(p, &cputime);\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int posix_cpu_clock_get_task(struct task_struct *tsk,\n\t\t\t\t    const clockid_t which_clock,\n\t\t\t\t    struct timespec *tp)\n{\n\tint err = -einval;\n\tunsigned long long rtn;\n\n\tif (cpuclock_perthread(which_clock)) {\n\t\tif (same_thread_group(tsk, current))\n\t\t\terr = cpu_clock_sample(which_clock, tsk, &rtn);\n\t} else {\n\t\tif (tsk == current || thread_group_leader(tsk))\n\t\t\terr = cpu_clock_sample_group(which_clock, tsk, &rtn);\n\t}\n\n\tif (!err)\n\t\tsample_to_timespec(which_clock, rtn, tp);\n\n\treturn err;\n}\n\n\nstatic int posix_cpu_clock_get(const clockid_t which_clock, struct timespec *tp)\n{\n\tconst pid_t pid = cpuclock_pid(which_clock);\n\tint err = -einval;\n\n\tif (pid == 0) {\n\t\t\n\t\terr = posix_cpu_clock_get_task(current, which_clock, tp);\n\t} else {\n\t\t\n\t\tstruct task_struct *p;\n\t\trcu_read_lock();\n\t\tp = find_task_by_vpid(pid);\n\t\tif (p)\n\t\t\terr = posix_cpu_clock_get_task(p, which_clock, tp);\n\t\trcu_read_unlock();\n\t}\n\n\treturn err;\n}\n\n\n\nstatic int posix_cpu_timer_create(struct k_itimer *new_timer)\n{\n\tint ret = 0;\n\tconst pid_t pid = cpuclock_pid(new_timer->it_clock);\n\tstruct task_struct *p;\n\n\tif (cpuclock_which(new_timer->it_clock) >= cpuclock_max)\n\t\treturn -einval;\n\n\tinit_list_head(&new_timer->it.cpu.entry);\n\n\trcu_read_lock();\n\tif (cpuclock_perthread(new_timer->it_clock)) {\n\t\tif (pid == 0) {\n\t\t\tp = current;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !same_thread_group(p, current))\n\t\t\t\tp = null;\n\t\t}\n\t} else {\n\t\tif (pid == 0) {\n\t\t\tp = current->group_leader;\n\t\t} else {\n\t\t\tp = find_task_by_vpid(pid);\n\t\t\tif (p && !has_group_leader_pid(p))\n\t\t\t\tp = null;\n\t\t}\n\t}\n\tnew_timer->it.cpu.task = p;\n\tif (p) {\n\t\tget_task_struct(p);\n\t} else {\n\t\tret = -einval;\n\t}\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n\nstatic int posix_cpu_timer_del(struct k_itimer *timer)\n{\n\tint ret = 0;\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\twarn_on_once(p == null);\n\n\t\n\tsighand = lock_task_sighand(p, &flags);\n\tif (unlikely(sighand == null)) {\n\t\t\n\t\twarn_on_once(!list_empty(&timer->it.cpu.entry));\n\t} else {\n\t\tif (timer->it.cpu.firing)\n\t\t\tret = timer_retry;\n\t\telse\n\t\t\tlist_del(&timer->it.cpu.entry);\n\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\tif (!ret)\n\t\tput_task_struct(p);\n\n\treturn ret;\n}\n\nstatic void cleanup_timers_list(struct list_head *head)\n{\n\tstruct cpu_timer_list *timer, *next;\n\n\tlist_for_each_entry_safe(timer, next, head, entry)\n\t\tlist_del_init(&timer->entry);\n}\n\n\nstatic void cleanup_timers(struct list_head *head)\n{\n\tcleanup_timers_list(head);\n\tcleanup_timers_list(++head);\n\tcleanup_timers_list(++head);\n}\n\n\nvoid posix_cpu_timers_exit(struct task_struct *tsk)\n{\n\tadd_device_randomness((const void*) &tsk->se.sum_exec_runtime,\n\t\t\t\t\t\tsizeof(unsigned long long));\n\tcleanup_timers(tsk->cpu_timers);\n\n}\nvoid posix_cpu_timers_exit_group(struct task_struct *tsk)\n{\n\tcleanup_timers(tsk->signal->cpu_timers);\n}\n\nstatic inline int expires_gt(cputime_t expires, cputime_t new_exp)\n{\n\treturn expires == 0 || expires > new_exp;\n}\n\n\nstatic void arm_timer(struct k_itimer *timer)\n{\n\tstruct task_struct *p = timer->it.cpu.task;\n\tstruct list_head *head, *listpos;\n\tstruct task_cputime *cputime_expires;\n\tstruct cpu_timer_list *const nt = &timer->it.cpu;\n\tstruct cpu_timer_list *next;\n\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\thead = p->cpu_timers;\n\t\tcputime_expires = &p->cputime_expires;\n\t} else {\n\t\thead = p->signal->cpu_timers;\n\t\tcputime_expires = &p->signal->cputime_expires;\n\t}\n\thead += cpuclock_which(timer->it_clock);\n\n\tlistpos = head;\n\tlist_for_each_entry(next, head, entry) {\n\t\tif (nt->expires < next->expires)\n\t\t\tbreak;\n\t\tlistpos = &next->entry;\n\t}\n\tlist_add(&nt->entry, listpos);\n\n\tif (listpos == head) {\n\t\tunsigned long long exp = nt->expires;\n\n\t\t\n\n\t\tswitch (cpuclock_which(timer->it_clock)) {\n\t\tcase cpuclock_prof:\n\t\t\tif (expires_gt(cputime_expires->prof_exp, expires_to_cputime(exp)))\n\t\t\t\tcputime_expires->prof_exp = expires_to_cputime(exp);\n\t\t\tbreak;\n\t\tcase cpuclock_virt:\n\t\t\tif (expires_gt(cputime_expires->virt_exp, expires_to_cputime(exp)))\n\t\t\t\tcputime_expires->virt_exp = expires_to_cputime(exp);\n\t\t\tbreak;\n\t\tcase cpuclock_sched:\n\t\t\tif (cputime_expires->sched_exp == 0 ||\n\t\t\t    cputime_expires->sched_exp > exp)\n\t\t\t\tcputime_expires->sched_exp = exp;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n\nstatic void cpu_timer_fire(struct k_itimer *timer)\n{\n\tif ((timer->it_sigev_notify & ~sigev_thread_id) == sigev_none) {\n\t\t\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (unlikely(timer->sigq == null)) {\n\t\t\n\t\twake_up_process(timer->it_process);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (timer->it.cpu.incr == 0) {\n\t\t\n\t\tposix_timer_event(timer, 0);\n\t\ttimer->it.cpu.expires = 0;\n\t} else if (posix_timer_event(timer, ++timer->it_requeue_pending)) {\n\t\t\n\t\tposix_cpu_timer_schedule(timer);\n\t}\n}\n\n\nstatic int cpu_timer_sample_group(const clockid_t which_clock,\n\t\t\t\t  struct task_struct *p,\n\t\t\t\t  unsigned long long *sample)\n{\n\tstruct task_cputime cputime;\n\n\tthread_group_cputimer(p, &cputime);\n\tswitch (cpuclock_which(which_clock)) {\n\tdefault:\n\t\treturn -einval;\n\tcase cpuclock_prof:\n\t\t*sample = cputime_to_expires(cputime.utime + cputime.stime);\n\t\tbreak;\n\tcase cpuclock_virt:\n\t\t*sample = cputime_to_expires(cputime.utime);\n\t\tbreak;\n\tcase cpuclock_sched:\n\t\t*sample = cputime.sum_exec_runtime;\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\n#ifdef config_no_hz_full\nstatic void nohz_kick_work_fn(struct work_struct *work)\n{\n\ttick_nohz_full_kick_all();\n}\n\nstatic declare_work(nohz_kick_work, nohz_kick_work_fn);\n\n\nstatic void posix_cpu_timer_kick_nohz(void)\n{\n\tif (context_tracking_is_enabled())\n\t\tschedule_work(&nohz_kick_work);\n}\n\nbool posix_cpu_timers_can_stop_tick(struct task_struct *tsk)\n{\n\tif (!task_cputime_zero(&tsk->cputime_expires))\n\t\treturn false;\n\n\tif (tsk->signal->cputimer.running)\n\t\treturn false;\n\n\treturn true;\n}\n#else\nstatic inline void posix_cpu_timer_kick_nohz(void) { }\n#endif\n\n\nstatic int posix_cpu_timer_set(struct k_itimer *timer, int timer_flags,\n\t\t\t       struct itimerspec *new, struct itimerspec *old)\n{\n\tunsigned long flags;\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *p = timer->it.cpu.task;\n\tunsigned long long old_expires, new_expires, old_incr, val;\n\tint ret;\n\n\twarn_on_once(p == null);\n\n\tnew_expires = timespec_to_sample(timer->it_clock, &new->it_value);\n\n\t\n\tsighand = lock_task_sighand(p, &flags);\n\t\n\tif (unlikely(sighand == null)) {\n\t\treturn -esrch;\n\t}\n\n\t\n\twarn_on_once(!irqs_disabled());\n\n\tret = 0;\n\told_incr = timer->it.cpu.incr;\n\told_expires = timer->it.cpu.expires;\n\tif (unlikely(timer->it.cpu.firing)) {\n\t\ttimer->it.cpu.firing = -1;\n\t\tret = timer_retry;\n\t} else\n\t\tlist_del_init(&timer->it.cpu.entry);\n\n\t\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &val);\n\t} else {\n\t\tcpu_timer_sample_group(timer->it_clock, p, &val);\n\t}\n\n\tif (old) {\n\t\tif (old_expires == 0) {\n\t\t\told->it_value.tv_sec = 0;\n\t\t\told->it_value.tv_nsec = 0;\n\t\t} else {\n\t\t\t\n\t\t\tbump_cpu_timer(timer, val);\n\t\t\tif (val < timer->it.cpu.expires) {\n\t\t\t\told_expires = timer->it.cpu.expires - val;\n\t\t\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t\t\t   old_expires,\n\t\t\t\t\t\t   &old->it_value);\n\t\t\t} else {\n\t\t\t\told->it_value.tv_nsec = 1;\n\t\t\t\told->it_value.tv_sec = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (unlikely(ret)) {\n\t\t\n\t\tunlock_task_sighand(p, &flags);\n\t\tgoto out;\n\t}\n\n\tif (new_expires != 0 && !(timer_flags & timer_abstime)) {\n\t\tnew_expires += val;\n\t}\n\n\t\n\ttimer->it.cpu.expires = new_expires;\n\tif (new_expires != 0 && val < new_expires) {\n\t\tarm_timer(timer);\n\t}\n\n\tunlock_task_sighand(p, &flags);\n\t\n\ttimer->it.cpu.incr = timespec_to_sample(timer->it_clock,\n\t\t\t\t\t\t&new->it_interval);\n\n\t\n\ttimer->it_requeue_pending = (timer->it_requeue_pending + 2) &\n\t\t~requeue_pending;\n\ttimer->it_overrun_last = 0;\n\ttimer->it_overrun = -1;\n\n\tif (new_expires != 0 && !(val < new_expires)) {\n\t\t\n\t\tcpu_timer_fire(timer);\n\t}\n\n\tret = 0;\n out:\n\tif (old) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   old_incr, &old->it_interval);\n\t}\n\tif (!ret)\n\t\tposix_cpu_timer_kick_nohz();\n\treturn ret;\n}\n\nstatic void posix_cpu_timer_get(struct k_itimer *timer, struct itimerspec *itp)\n{\n\tunsigned long long now;\n\tstruct task_struct *p = timer->it.cpu.task;\n\n\twarn_on_once(p == null);\n\n\t\n\tsample_to_timespec(timer->it_clock,\n\t\t\t   timer->it.cpu.incr, &itp->it_interval);\n\n\tif (timer->it.cpu.expires == 0) {\t\n\t\titp->it_value.tv_sec = itp->it_value.tv_nsec = 0;\n\t\treturn;\n\t}\n\n\t\n\tif (cpuclock_perthread(timer->it_clock)) {\n\t\tcpu_clock_sample(timer->it_clock, p, &now);\n\t} else {\n\t\tstruct sighand_struct *sighand;\n\t\tunsigned long flags;\n\n\t\t\n\t\tsighand = lock_task_sighand(p, &flags);\n\t\tif (unlikely(sighand == null)) {\n\t\t\t\n\t\t\ttimer->it.cpu.expires = 0;\n\t\t\tsample_to_timespec(timer->it_clock, timer->it.cpu.expires,\n\t\t\t\t\t   &itp->it_value);\n\t\t} else {\n\t\t\tcpu_timer_sample_group(timer->it_clock, p, &now);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t}\n\t}\n\n\tif (now < timer->it.cpu.expires) {\n\t\tsample_to_timespec(timer->it_clock,\n\t\t\t\t   timer->it.cpu.expires - now,\n\t\t\t\t   &itp->it_value);\n\t} else {\n\t\t\n\t\titp->it_value.tv_nsec = 1;\n\t\titp->it_value.tv_sec = 0;\n\t}\n}\n\nstatic unsigned long long\ncheck_timers_list(struct list_head *timers,\n\t\t  struct list_head *firing,\n\t\t  unsigned long long curr)\n{\n\tint maxfire = 20;\n\n\twhile (!list_empty(timers)) {\n\t\tstruct cpu_timer_list *t;\n\n\t\tt = list_first_entry(timers, struct cpu_timer_list, entry);\n\n\t\tif (!--maxfire || curr < t->expires)\n\t\t\treturn t->expires;\n\n\t\tt->firing = 1;\n\t\tlist_move_tail(&t->entry, firing);\n\t}\n\n\treturn 0;\n}\n\n\nstatic void check_thread_timers(struct task_struct *tsk,\n\t\t\t\tstruct list_head *firing)\n{\n\tstruct list_head *timers = tsk->cpu_timers;\n\tstruct signal_struct *const sig = tsk->signal;\n\tstruct task_cputime *tsk_expires = &tsk->cputime_expires;\n\tunsigned long long expires;\n\tunsigned long soft;\n\n\texpires = check_timers_list(timers, firing, prof_ticks(tsk));\n\ttsk_expires->prof_exp = expires_to_cputime(expires);\n\n\texpires = check_timers_list(++timers, firing, virt_ticks(tsk));\n\ttsk_expires->virt_exp = expires_to_cputime(expires);\n\n\ttsk_expires->sched_exp = check_timers_list(++timers, firing,\n\t\t\t\t\t\t   tsk->se.sum_exec_runtime);\n\n\t\n\tsoft = access_once(sig->rlim[rlimit_rttime].rlim_cur);\n\tif (soft != rlim_infinity) {\n\t\tunsigned long hard =\n\t\t\taccess_once(sig->rlim[rlimit_rttime].rlim_max);\n\n\t\tif (hard != rlim_infinity &&\n\t\t    tsk->rt.timeout > div_round_up(hard, usec_per_sec/hz)) {\n\t\t\t\n\t\t\t__group_send_sig_info(sigkill, send_sig_priv, tsk);\n\t\t\treturn;\n\t\t}\n\t\tif (tsk->rt.timeout > div_round_up(soft, usec_per_sec/hz)) {\n\t\t\t\n\t\t\tif (soft < hard) {\n\t\t\t\tsoft += usec_per_sec;\n\t\t\t\tsig->rlim[rlimit_rttime].rlim_cur = soft;\n\t\t\t}\n\t\t\tprintk(kern_info\n\t\t\t\t\"", "1003": "\",\n\t       log_lvl, raw_smp_processor_id(), current->pid, current->comm,\n\t       print_tainted(), init_utsname()->release,\n\t       (int)strcspn(init_utsname()->version, \"", "1004": "\",\n\t.debug_hint\t= hrtimer_debug_hint,\n\t.fixup_init\t= hrtimer_fixup_init,\n\t.fixup_activate\t= hrtimer_fixup_activate,\n\t.fixup_free\t= hrtimer_fixup_free,\n};\n\nstatic inline void debug_hrtimer_init(struct hrtimer *timer)\n{\n\tdebug_object_init(timer, &hrtimer_debug_descr);\n}\n\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer)\n{\n\tdebug_object_activate(timer, &hrtimer_debug_descr);\n}\n\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer)\n{\n\tdebug_object_deactivate(timer, &hrtimer_debug_descr);\n}\n\nstatic inline void debug_hrtimer_free(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}\n\nstatic void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode);\n\nvoid hrtimer_init_on_stack(struct hrtimer *timer, clockid_t clock_id,\n\t\t\t   enum hrtimer_mode mode)\n{\n\tdebug_object_init_on_stack(timer, &hrtimer_debug_descr);\n\t__hrtimer_init(timer, clock_id, mode);\n}\nexport_symbol_gpl(hrtimer_init_on_stack);\n\nvoid destroy_hrtimer_on_stack(struct hrtimer *timer)\n{\n\tdebug_object_free(timer, &hrtimer_debug_descr);\n}\n\n#else\nstatic inline void debug_hrtimer_init(struct hrtimer *timer) { }\nstatic inline void debug_hrtimer_activate(struct hrtimer *timer) { }\nstatic inline void debug_hrtimer_deactivate(struct hrtimer *timer) { }\n#endif\n\nstatic inline void\ndebug_init(struct hrtimer *timer, clockid_t clockid,\n\t   enum hrtimer_mode mode)\n{\n\tdebug_hrtimer_init(timer);\n\ttrace_hrtimer_init(timer, clockid, mode);\n}\n\nstatic inline void debug_activate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_activate(timer);\n\ttrace_hrtimer_start(timer);\n}\n\nstatic inline void debug_deactivate(struct hrtimer *timer)\n{\n\tdebug_hrtimer_deactivate(timer);\n\ttrace_hrtimer_cancel(timer);\n}\n\n#if defined(config_no_hz_common) || defined(config_high_res_timers)\nstatic ktime_t __hrtimer_get_next_event(struct hrtimer_cpu_base *cpu_base)\n{\n\tstruct hrtimer_clock_base *base = cpu_base->clock_base;\n\tktime_t expires, expires_next = { .tv64 = ktime_max };\n\tint i;\n\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++, base++) {\n\t\tstruct timerqueue_node *next;\n\t\tstruct hrtimer *timer;\n\n\t\tnext = timerqueue_getnext(&base->active);\n\t\tif (!next)\n\t\t\tcontinue;\n\n\t\ttimer = container_of(next, struct hrtimer, node);\n\t\texpires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\t\tif (expires.tv64 < expires_next.tv64)\n\t\t\texpires_next = expires;\n\t}\n\t\n\tif (expires_next.tv64 < 0)\n\t\texpires_next.tv64 = 0;\n\treturn expires_next;\n}\n#endif\n\n\n#ifdef config_high_res_timers\n\n\nstatic int hrtimer_hres_enabled __read_mostly  = 1;\n\n\nstatic int __init setup_hrtimer_hres(char *str)\n{\n\tif (!strcmp(str, \"", "1005": "\",\n\t.dev_groups\t= pmu_dev_groups,\n};\n\nstatic void pmu_dev_release(struct device *dev)\n{\n\tkfree(dev);\n}\n\nstatic int pmu_dev_alloc(struct pmu *pmu)\n{\n\tint ret = -enomem;\n\n\tpmu->dev = kzalloc(sizeof(struct device), gfp_kernel);\n\tif (!pmu->dev)\n\t\tgoto out;\n\n\tpmu->dev->groups = pmu->attr_groups;\n\tdevice_initialize(pmu->dev);\n\tret = dev_set_name(pmu->dev, \"", "1006": "\",\n\t.dev_name = \"", "1007": "\",\n\t.func\t\t\t= ftrace_mod_callback,\n};\n\nstatic int __init ftrace_mod_cmd_init(void)\n{\n\treturn register_ftrace_command(&ftrace_mod_cmd);\n}\ncore_initcall(ftrace_mod_cmd_init);\n\nstatic void function_trace_probe_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t      struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tstruct ftrace_func_probe *entry;\n\tstruct hlist_head *hhd;\n\tunsigned long key;\n\n\tkey = hash_long(ip, ftrace_hash_bits);\n\n\thhd = &ftrace_func_hash[key];\n\n\tif (hlist_empty(hhd))\n\t\treturn;\n\n\t\n\tpreempt_disable_notrace();\n\thlist_for_each_entry_rcu_notrace(entry, hhd, node) {\n\t\tif (entry->ip == ip)\n\t\t\tentry->ops->func(ip, parent_ip, &entry->data);\n\t}\n\tpreempt_enable_notrace();\n}\n\nstatic struct ftrace_ops trace_probe_ops __read_mostly =\n{\n\t.func\t\t= function_trace_probe_call,\n\t.flags\t\t= ftrace_ops_fl_initialized,\n\tinit_ops_hash(trace_probe_ops)\n};\n\nstatic int ftrace_probe_registered;\n\nstatic void __enable_ftrace_function_probe(struct ftrace_ops_hash *old_hash)\n{\n\tint ret;\n\tint i;\n\n\tif (ftrace_probe_registered) {\n\t\t\n\t\tif (ftrace_enabled)\n\t\t\tftrace_run_modify_code(&trace_probe_ops, ftrace_update_calls,\n\t\t\t\t\t       old_hash);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < ftrace_func_hashsize; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\t\tif (hhd->first)\n\t\t\tbreak;\n\t}\n\t\n\tif (i == ftrace_func_hashsize)\n\t\treturn;\n\n\tret = ftrace_startup(&trace_probe_ops, 0);\n\n\tftrace_probe_registered = 1;\n}\n\nstatic void __disable_ftrace_function_probe(void)\n{\n\tint i;\n\n\tif (!ftrace_probe_registered)\n\t\treturn;\n\n\tfor (i = 0; i < ftrace_func_hashsize; i++) {\n\t\tstruct hlist_head *hhd = &ftrace_func_hash[i];\n\t\tif (hhd->first)\n\t\t\treturn;\n\t}\n\n\t\n\tftrace_shutdown(&trace_probe_ops, 0);\n\n\tftrace_probe_registered = 0;\n}\n\n\nstatic void ftrace_free_entry(struct ftrace_func_probe *entry)\n{\n\tif (entry->ops->free)\n\t\tentry->ops->free(entry->ops, entry->ip, &entry->data);\n\tkfree(entry);\n}\n\nint\nregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,\n\t\t\t      void *data)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_probe *entry;\n\tstruct ftrace_hash **orig_hash = &trace_probe_ops.func_hash->filter_hash;\n\tstruct ftrace_hash *old_hash = *orig_hash;\n\tstruct ftrace_hash *hash;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tint type, len, not;\n\tunsigned long key;\n\tint count = 0;\n\tchar *search;\n\tint ret;\n\n\ttype = filter_parse_regex(glob, strlen(glob), &search, &not);\n\tlen = strlen(search);\n\n\t\n\tif (warn_on(not))\n\t\treturn -einval;\n\n\tmutex_lock(&trace_probe_ops.func_hash->regex_lock);\n\n\told_hash_ops.filter_hash = old_hash;\n\t\n\told_hash_ops.notrace_hash = null;\n\n\thash = alloc_and_copy_ftrace_hash(ftrace_hash_default_bits, old_hash);\n\tif (!hash) {\n\t\tcount = -enomem;\n\t\tgoto out;\n\t}\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tcount = -enodev;\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (!ftrace_match_record(rec, null, search, len, type))\n\t\t\tcontinue;\n\n\t\tentry = kmalloc(sizeof(*entry), gfp_kernel);\n\t\tif (!entry) {\n\t\t\t\n\t\t\tif (!count)\n\t\t\t\tcount = -enomem;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tcount++;\n\n\t\tentry->data = data;\n\n\t\t\n\t\tif (ops->init) {\n\t\t\tif (ops->init(ops, rec->ip, &entry->data) < 0) {\n\t\t\t\t\n\t\t\t\tkfree(entry);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tret = enter_record(hash, rec, 0);\n\t\tif (ret < 0) {\n\t\t\tkfree(entry);\n\t\t\tcount = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tentry->ops = ops;\n\t\tentry->ip = rec->ip;\n\n\t\tkey = hash_long(entry->ip, ftrace_hash_bits);\n\t\thlist_add_head_rcu(&entry->node, &ftrace_func_hash[key]);\n\n\t} while_for_each_ftrace_rec();\n\n\tret = ftrace_hash_move(&trace_probe_ops, 1, orig_hash, hash);\n\n\t__enable_ftrace_function_probe(&old_hash_ops);\n\n\tif (!ret)\n\t\tfree_ftrace_hash_rcu(old_hash);\n\telse\n\t\tcount = ret;\n\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n out:\n\tmutex_unlock(&trace_probe_ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\treturn count;\n}\n\nenum {\n\tprobe_test_func\t\t= 1,\n\tprobe_test_data\t\t= 2\n};\n\nstatic void\n__unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,\n\t\t\t\t  void *data, int flags)\n{\n\tstruct ftrace_func_entry *rec_entry;\n\tstruct ftrace_func_probe *entry;\n\tstruct ftrace_func_probe *p;\n\tstruct ftrace_hash **orig_hash = &trace_probe_ops.func_hash->filter_hash;\n\tstruct ftrace_hash *old_hash = *orig_hash;\n\tstruct list_head free_list;\n\tstruct ftrace_hash *hash;\n\tstruct hlist_node *tmp;\n\tchar str[ksym_symbol_len];\n\tint type = match_full;\n\tint i, len = 0;\n\tchar *search;\n\tint ret;\n\n\tif (glob && (strcmp(glob, \"", "1008": "\",\n\t.func\t\t\t= ftrace_trace_snapshot_callback,\n};\n\nstatic __init int register_snapshot_cmd(void)\n{\n\treturn register_ftrace_command(&ftrace_snapshot_cmd);\n}\n#else\nstatic inline __init int register_snapshot_cmd(void) { return 0; }\n#endif \n\nstatic struct dentry *tracing_get_dentry(struct trace_array *tr)\n{\n\tif (warn_on(!tr->dir))\n\t\treturn err_ptr(-enodev);\n\n\t\n\tif (tr->flags & trace_array_fl_global)\n\t\treturn null;\n\n\t\n\treturn tr->dir;\n}\n\nstatic struct dentry *tracing_dentry_percpu(struct trace_array *tr, int cpu)\n{\n\tstruct dentry *d_tracer;\n\n\tif (tr->percpu_dir)\n\t\treturn tr->percpu_dir;\n\n\td_tracer = tracing_get_dentry(tr);\n\tif (is_err(d_tracer))\n\t\treturn null;\n\n\ttr->percpu_dir = tracefs_create_dir(\"", "1009": "\",\n\t.init\t\t= nop_trace_init,\n\t.reset\t\t= nop_trace_reset,\n#ifdef config_ftrace_selftest\n\t.selftest\t= trace_selftest_startup_nop,\n#endif\n\t.flags\t\t= &nop_flags,\n\t.set_flag\t= nop_set_flag,\n\t.allow_instances = true,\n};\n\n#ifdef config_rwsem_spin_on_owner\nstatic inline void rwsem_set_owner(struct rw_semaphore *sem)\n{\n\tsem->owner = current;\n}\n\nstatic inline void rwsem_clear_owner(struct rw_semaphore *sem)\n{\n\tsem->owner = null;\n}\n\n#else\nstatic inline void rwsem_set_owner(struct rw_semaphore *sem)\n{\n}\n\nstatic inline void rwsem_clear_owner(struct rw_semaphore *sem)\n{\n}\n#endif\n\n\n#include <linux/device.h>\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/sched.h> \n#include <linux/tick.h>\n#include <linux/kthread.h>\n\n#include \"", "1010": "\",\n \"", "1011": "\",\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n (char *)0,\n};\n\nstatic const int __nenv = array_size(__env);\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_tif_mca_init\n\tif ((task_thread_info(p)->flags & _tif_mca_init) && kdb_tsk(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}\n\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t\n\tpermissions &= kdb_enable_mask;\n\tpermissions |= kdb_enable_always_safe;\n\n\t\n\tif (no_args)\n\t\tpermissions |= permissions << kdb_enable_no_args_shift;\n\n\tflags |= kdb_enable_all;\n\n\treturn permissions & flags;\n}\n\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"", "1012": "\",\n#elif defined(config_preempt)\n\t\t   \"", "1013": "\",\n#elif defined(config_preempt_voluntary)\n\t\t   \"", "1014": "\",\n#else\n\t\t   \"", "1015": "\",\n#else\n \"", "1016": "\",\n#endif\n\t\t   \n\t\t   0, 0, 0, 0);\n#ifdef config_smp\n\tseq_printf(m, \"", "1017": "\",\n#endif\n \"", "1018": "\",\n};\n\nstatic struct device device_clocksource = {\n\t.id\t= 0,\n\t.bus\t= &clocksource_subsys,\n};\n\nstatic int __init init_clocksource_sysfs(void)\n{\n\tint error = subsys_system_register(&clocksource_subsys, null);\n\n\tif (!error)\n\t\terror = device_register(&device_clocksource);\n\tif (!error)\n\t\terror = device_create_file(\n\t\t\t\t&device_clocksource,\n\t\t\t\t&dev_attr_current_clocksource);\n\tif (!error)\n\t\terror = device_create_file(&device_clocksource,\n\t\t\t\t\t   &dev_attr_unbind_clocksource);\n\tif (!error)\n\t\terror = device_create_file(\n\t\t\t\t&device_clocksource,\n\t\t\t\t&dev_attr_available_clocksource);\n\treturn error;\n}\n\ndevice_initcall(init_clocksource_sysfs);\n#endif \n\n\nstatic int __init boot_override_clocksource(char* str)\n{\n\tmutex_lock(&clocksource_mutex);\n\tif (str)\n\t\tstrlcpy(override_name, str, sizeof(override_name));\n\tmutex_unlock(&clocksource_mutex);\n\treturn 1;\n}\n\n__setup(\"", "1019": "\", \"", "1020": "\", %s\"", "1021": "\", &colcount);\n\tif (diag || colcount <= 1)\n\t\tcolcount = 80;\n\n\tdiag = kdbgetintenv(\"", "1022": "\", &dtab_count);\n\tif (diag)\n\t\tdtab_count = 30;\n\n\tif (len > 0) {\n\t\tcp += len;\n\t\tif (*(buffer+len-1) == '\\n')\n\t\t\tcp--;\n\t}\n\n\tlastchar = cp;\n\t*cp = '\\0';\n\tkdb_printf(\"", "1023": "\", &linecount);\n\tif (diag || linecount <= 1)\n\t\tlinecount = 24;\n\n\tdiag = kdbgetintenv(\"", "1024": "\", &logging);\n\tif (diag)\n\t\tlogging = 0;\n\n\tif (!kdb_grepping_flag || suspend_grep) {\n\t\t\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t}\n\tvsnprintf(next_avail, size_avail, fmt, ap);\n\n\t\n\n\t\n\tif (!suspend_grep && kdb_grepping_flag) {\n\t\tcp = strchr(kdb_buffer, '\\n');\n\t\tif (!cp) {\n\t\t\t\n\t\t\tif (next_avail == kdb_buffer) {\n\t\t\t\t\n\t\t\t\tcp2 = kdb_buffer;\n\t\t\t\tlen = strlen(kdb_prompt_str);\n\t\t\t\tif (!strncmp(cp2, kdb_prompt_str, len)) {\n\t\t\t\t\t\n\t\t\t\t\tkdb_grepping_flag = 0;\n\t\t\t\t\tgoto kdb_printit;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\n\t\t\n\t\tcp++;\t \t     \n\t\treplaced_byte = *cp; \n\t\tcphold = cp;\n\t\t*cp = '\\0';\t     \n\n\t\t\n\t\tfnd = kdb_search_string(kdb_buffer, kdb_grep_string);\n\t\tif (!fnd) {\n\t\t\t\n\t\t\t*cphold = replaced_byte;\n\t\t\tstrcpy(kdb_buffer, cphold);\n\t\t\tlen = strlen(kdb_buffer);\n\t\t\tnext_avail = kdb_buffer + len;\n\t\t\tsize_avail = sizeof(kdb_buffer) - len;\n\t\t\tgoto kdb_print_out;\n\t\t}\n\t\tif (kdb_grepping_flag >= kdb_grepping_flag_search)\n\t\t\t\n\t\t\tkdb_grepping_flag = 0;\n\t\t\n\t}\nkdb_printit:\n\n\t\n\tretlen = strlen(kdb_buffer);\n\tcp = (char *) printk_skip_level(kdb_buffer);\n\tif (!dbg_kdb_mode && kgdb_connected) {\n\t\tgdbstub_msg_write(cp, retlen - (cp - kdb_buffer));\n\t} else {\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = retlen - (cp - kdb_buffer);\n\t\t\tcp2 = cp;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp2);\n\t\t\t\tcp2++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, cp, retlen - (cp - kdb_buffer));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\t}\n\tif (logging) {\n\t\tsaved_loglevel = console_loglevel;\n\t\tconsole_loglevel = console_loglevel_silent;\n\t\tif (printk_get_level(kdb_buffer) || src == kdb_msgsrc_printk)\n\t\t\tprintk(\"", "1025": "\", &perf_fops, event,\n\t\t\t\t\tf_flags);\n\tif (is_err(event_file)) {\n\t\terr = ptr_err(event_file);\n\t\tgoto err_context;\n\t}\n\n\tif (move_group) {\n\t\tgctx = group_leader->ctx;\n\n\t\t\n\t\tmutex_lock_double(&gctx->mutex, &ctx->mutex);\n\n\t\tperf_remove_from_context(group_leader, false);\n\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_remove_from_context(sibling, false);\n\t\t\tput_ctx(gctx);\n\t\t}\n\t} else {\n\t\tmutex_lock(&ctx->mutex);\n\t}\n\n\twarn_on_once(ctx->parent_ctx);\n\n\tif (move_group) {\n\t\t\n\t\tsynchronize_rcu();\n\n\t\t\n\t\tlist_for_each_entry(sibling, &group_leader->sibling_list,\n\t\t\t\t    group_entry) {\n\t\t\tperf_event__state_init(sibling);\n\t\t\tperf_install_in_context(ctx, sibling, sibling->cpu);\n\t\t\tget_ctx(ctx);\n\t\t}\n\n\t\t\n\t\tperf_event__state_init(group_leader);\n\t\tperf_install_in_context(ctx, group_leader, group_leader->cpu);\n\t\tget_ctx(ctx);\n\t}\n\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\terr = -ebusy;\n\t\tmutex_unlock(&ctx->mutex);\n\t\tfput(event_file);\n\t\tgoto err_context;\n\t}\n\n\tperf_install_in_context(ctx, event, event->cpu);\n\tperf_unpin_context(ctx);\n\n\tif (move_group) {\n\t\tmutex_unlock(&gctx->mutex);\n\t\tput_ctx(gctx);\n\t}\n\tmutex_unlock(&ctx->mutex);\n\n\tput_online_cpus();\n\n\tevent->owner = current;\n\n\tmutex_lock(&current->perf_event_mutex);\n\tlist_add_tail(&event->owner_entry, &current->perf_event_list);\n\tmutex_unlock(&current->perf_event_mutex);\n\n\t\n\tperf_event__header_size(event);\n\tperf_event__id_header_size(event);\n\n\t\n\tfdput(group);\n\tfd_install(event_fd, event_file);\n\treturn event_fd;\n\nerr_context:\n\tperf_unpin_context(ctx);\n\tput_ctx(ctx);\nerr_alloc:\n\tfree_event(event);\nerr_cpus:\n\tput_online_cpus();\nerr_task:\n\tif (task)\n\t\tput_task_struct(task);\nerr_group_fd:\n\tfdput(group);\nerr_fd:\n\tput_unused_fd(event_fd);\n\treturn err;\n}\n\n\nstruct perf_event *\nperf_event_create_kernel_counter(struct perf_event_attr *attr, int cpu,\n\t\t\t\t struct task_struct *task,\n\t\t\t\t perf_overflow_handler_t overflow_handler,\n\t\t\t\t void *context)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\tint err;\n\n\t\n\n\tevent = perf_event_alloc(attr, cpu, task, null, null,\n\t\t\t\t overflow_handler, context, -1);\n\tif (is_err(event)) {\n\t\terr = ptr_err(event);\n\t\tgoto err;\n\t}\n\n\t\n\tevent->owner = event_owner_kernel;\n\n\taccount_event(event);\n\n\tctx = find_get_context(event->pmu, task, event);\n\tif (is_err(ctx)) {\n\t\terr = ptr_err(ctx);\n\t\tgoto err_free;\n\t}\n\n\twarn_on_once(ctx->parent_ctx);\n\tmutex_lock(&ctx->mutex);\n\tif (!exclusive_event_installable(event, ctx)) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tperf_unpin_context(ctx);\n\t\tput_ctx(ctx);\n\t\terr = -ebusy;\n\t\tgoto err_free;\n\t}\n\n\tperf_install_in_context(ctx, event, cpu);\n\tperf_unpin_context(ctx);\n\tmutex_unlock(&ctx->mutex);\n\n\treturn event;\n\nerr_free:\n\tfree_event(event);\nerr:\n\treturn err_ptr(err);\n}\nexport_symbol_gpl(perf_event_create_kernel_counter);\n\nvoid perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)\n{\n\tstruct perf_event_context *src_ctx;\n\tstruct perf_event_context *dst_ctx;\n\tstruct perf_event *event, *tmp;\n\tlist_head(events);\n\n\tsrc_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, src_cpu)->ctx;\n\tdst_ctx = &per_cpu_ptr(pmu->pmu_cpu_context, dst_cpu)->ctx;\n\n\t\n\tmutex_lock_double(&src_ctx->mutex, &dst_ctx->mutex);\n\tlist_for_each_entry_safe(event, tmp, &src_ctx->event_list,\n\t\t\t\t event_entry) {\n\t\tperf_remove_from_context(event, false);\n\t\tunaccount_event_cpu(event, src_cpu);\n\t\tput_ctx(src_ctx);\n\t\tlist_add(&event->migrate_entry, &events);\n\t}\n\n\t\n\tsynchronize_rcu();\n\n\t\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tif (event->group_leader == event)\n\t\t\tcontinue;\n\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= perf_event_state_off)\n\t\t\tevent->state = perf_event_state_inactive;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\n\t\n\tlist_for_each_entry_safe(event, tmp, &events, migrate_entry) {\n\t\tlist_del(&event->migrate_entry);\n\t\tif (event->state >= perf_event_state_off)\n\t\t\tevent->state = perf_event_state_inactive;\n\t\taccount_event_cpu(event, dst_cpu);\n\t\tperf_install_in_context(dst_ctx, event, dst_cpu);\n\t\tget_ctx(dst_ctx);\n\t}\n\tmutex_unlock(&dst_ctx->mutex);\n\tmutex_unlock(&src_ctx->mutex);\n}\nexport_symbol_gpl(perf_pmu_migrate_context);\n\nstatic void sync_child_event(struct perf_event *child_event,\n\t\t\t       struct task_struct *child)\n{\n\tstruct perf_event *parent_event = child_event->parent;\n\tu64 child_val;\n\n\tif (child_event->attr.inherit_stat)\n\t\tperf_event_read_event(child_event, child);\n\n\tchild_val = perf_event_count(child_event);\n\n\t\n\tatomic64_add(child_val, &parent_event->child_count);\n\tatomic64_add(child_event->total_time_enabled,\n\t\t     &parent_event->child_total_time_enabled);\n\tatomic64_add(child_event->total_time_running,\n\t\t     &parent_event->child_total_time_running);\n\n\t\n\twarn_on_once(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_del_init(&child_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\t\n\tperf_event_wakeup(parent_event);\n\n\t\n\tput_event(parent_event);\n}\n\nstatic void\n__perf_event_exit_task(struct perf_event *child_event,\n\t\t\t struct perf_event_context *child_ctx,\n\t\t\t struct task_struct *child)\n{\n\t\n\tperf_remove_from_context(child_event, !!child_event->parent);\n\n\t\n\tif (child_event->parent) {\n\t\tsync_child_event(child_event, child);\n\t\tfree_event(child_event);\n\t} else {\n\t\tchild_event->state = perf_event_state_exit;\n\t\tperf_event_wakeup(child_event);\n\t}\n}\n\nstatic void perf_event_exit_task_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event *child_event, *next;\n\tstruct perf_event_context *child_ctx, *clone_ctx = null;\n\tunsigned long flags;\n\n\tif (likely(!child->perf_event_ctxp[ctxn])) {\n\t\tperf_event_task(child, null, 0);\n\t\treturn;\n\t}\n\n\tlocal_irq_save(flags);\n\t\n\tchild_ctx = rcu_dereference_raw(child->perf_event_ctxp[ctxn]);\n\n\t\n\traw_spin_lock(&child_ctx->lock);\n\ttask_ctx_sched_out(child_ctx);\n\tchild->perf_event_ctxp[ctxn] = null;\n\n\t\n\tclone_ctx = unclone_ctx(child_ctx);\n\tupdate_context_time(child_ctx);\n\traw_spin_unlock_irqrestore(&child_ctx->lock, flags);\n\n\tif (clone_ctx)\n\t\tput_ctx(clone_ctx);\n\n\t\n\tperf_event_task(child, child_ctx, 0);\n\n\t\n\tmutex_lock(&child_ctx->mutex);\n\n\tlist_for_each_entry_safe(child_event, next, &child_ctx->event_list, event_entry)\n\t\t__perf_event_exit_task(child_event, child_ctx, child);\n\n\tmutex_unlock(&child_ctx->mutex);\n\n\tput_ctx(child_ctx);\n}\n\n\nvoid perf_event_exit_task(struct task_struct *child)\n{\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tmutex_lock(&child->perf_event_mutex);\n\tlist_for_each_entry_safe(event, tmp, &child->perf_event_list,\n\t\t\t\t owner_entry) {\n\t\tlist_del_init(&event->owner_entry);\n\n\t\t\n\t\tsmp_wmb();\n\t\tevent->owner = null;\n\t}\n\tmutex_unlock(&child->perf_event_mutex);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_exit_task_context(child, ctxn);\n}\n\nstatic void perf_free_event(struct perf_event *event,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tstruct perf_event *parent = event->parent;\n\n\tif (warn_on_once(!parent))\n\t\treturn;\n\n\tmutex_lock(&parent->child_mutex);\n\tlist_del_init(&event->child_list);\n\tmutex_unlock(&parent->child_mutex);\n\n\tput_event(parent);\n\n\traw_spin_lock_irq(&ctx->lock);\n\tperf_group_detach(event);\n\tlist_del_event(event, ctx);\n\traw_spin_unlock_irq(&ctx->lock);\n\tfree_event(event);\n}\n\n\nvoid perf_event_free_task(struct task_struct *task)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event, *tmp;\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tctx = task->perf_event_ctxp[ctxn];\n\t\tif (!ctx)\n\t\t\tcontinue;\n\n\t\tmutex_lock(&ctx->mutex);\nagain:\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->pinned_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tlist_for_each_entry_safe(event, tmp, &ctx->flexible_groups,\n\t\t\t\tgroup_entry)\n\t\t\tperf_free_event(event, ctx);\n\n\t\tif (!list_empty(&ctx->pinned_groups) ||\n\t\t\t\t!list_empty(&ctx->flexible_groups))\n\t\t\tgoto again;\n\n\t\tmutex_unlock(&ctx->mutex);\n\n\t\tput_ctx(ctx);\n\t}\n}\n\nvoid perf_event_delayed_put(struct task_struct *task)\n{\n\tint ctxn;\n\n\tfor_each_task_context_nr(ctxn)\n\t\twarn_on_once(task->perf_event_ctxp[ctxn]);\n}\n\n\nstatic struct perf_event *\ninherit_event(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event *group_leader,\n\t      struct perf_event_context *child_ctx)\n{\n\tenum perf_event_active_state parent_state = parent_event->state;\n\tstruct perf_event *child_event;\n\tunsigned long flags;\n\n\t\n\tif (parent_event->parent)\n\t\tparent_event = parent_event->parent;\n\n\tchild_event = perf_event_alloc(&parent_event->attr,\n\t\t\t\t\t   parent_event->cpu,\n\t\t\t\t\t   child,\n\t\t\t\t\t   group_leader, parent_event,\n\t\t\t\t\t   null, null, -1);\n\tif (is_err(child_event))\n\t\treturn child_event;\n\n\tif (is_orphaned_event(parent_event) ||\n\t    !atomic_long_inc_not_zero(&parent_event->refcount)) {\n\t\tfree_event(child_event);\n\t\treturn null;\n\t}\n\n\tget_ctx(child_ctx);\n\n\t\n\tif (parent_state >= perf_event_state_inactive)\n\t\tchild_event->state = perf_event_state_inactive;\n\telse\n\t\tchild_event->state = perf_event_state_off;\n\n\tif (parent_event->attr.freq) {\n\t\tu64 sample_period = parent_event->hw.sample_period;\n\t\tstruct hw_perf_event *hwc = &child_event->hw;\n\n\t\thwc->sample_period = sample_period;\n\t\thwc->last_period   = sample_period;\n\n\t\tlocal64_set(&hwc->period_left, sample_period);\n\t}\n\n\tchild_event->ctx = child_ctx;\n\tchild_event->overflow_handler = parent_event->overflow_handler;\n\tchild_event->overflow_handler_context\n\t\t= parent_event->overflow_handler_context;\n\n\t\n\tperf_event__header_size(child_event);\n\tperf_event__id_header_size(child_event);\n\n\t\n\traw_spin_lock_irqsave(&child_ctx->lock, flags);\n\tadd_event_to_ctx(child_event, child_ctx);\n\traw_spin_unlock_irqrestore(&child_ctx->lock, flags);\n\n\t\n\twarn_on_once(parent_event->ctx->parent_ctx);\n\tmutex_lock(&parent_event->child_mutex);\n\tlist_add_tail(&child_event->child_list, &parent_event->child_list);\n\tmutex_unlock(&parent_event->child_mutex);\n\n\treturn child_event;\n}\n\nstatic int inherit_group(struct perf_event *parent_event,\n\t      struct task_struct *parent,\n\t      struct perf_event_context *parent_ctx,\n\t      struct task_struct *child,\n\t      struct perf_event_context *child_ctx)\n{\n\tstruct perf_event *leader;\n\tstruct perf_event *sub;\n\tstruct perf_event *child_ctr;\n\n\tleader = inherit_event(parent_event, parent, parent_ctx,\n\t\t\t\t child, null, child_ctx);\n\tif (is_err(leader))\n\t\treturn ptr_err(leader);\n\tlist_for_each_entry(sub, &parent_event->sibling_list, group_entry) {\n\t\tchild_ctr = inherit_event(sub, parent, parent_ctx,\n\t\t\t\t\t    child, leader, child_ctx);\n\t\tif (is_err(child_ctr))\n\t\t\treturn ptr_err(child_ctr);\n\t}\n\treturn 0;\n}\n\nstatic int\ninherit_task_group(struct perf_event *event, struct task_struct *parent,\n\t\t   struct perf_event_context *parent_ctx,\n\t\t   struct task_struct *child, int ctxn,\n\t\t   int *inherited_all)\n{\n\tint ret;\n\tstruct perf_event_context *child_ctx;\n\n\tif (!event->attr.inherit) {\n\t\t*inherited_all = 0;\n\t\treturn 0;\n\t}\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\tif (!child_ctx) {\n\t\t\n\n\t\tchild_ctx = alloc_perf_context(parent_ctx->pmu, child);\n\t\tif (!child_ctx)\n\t\t\treturn -enomem;\n\n\t\tchild->perf_event_ctxp[ctxn] = child_ctx;\n\t}\n\n\tret = inherit_group(event, parent, parent_ctx,\n\t\t\t    child, child_ctx);\n\n\tif (ret)\n\t\t*inherited_all = 0;\n\n\treturn ret;\n}\n\n\nstatic int perf_event_init_context(struct task_struct *child, int ctxn)\n{\n\tstruct perf_event_context *child_ctx, *parent_ctx;\n\tstruct perf_event_context *cloned_ctx;\n\tstruct perf_event *event;\n\tstruct task_struct *parent = current;\n\tint inherited_all = 1;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tif (likely(!parent->perf_event_ctxp[ctxn]))\n\t\treturn 0;\n\n\t\n\tparent_ctx = perf_pin_task_context(parent, ctxn);\n\tif (!parent_ctx)\n\t\treturn 0;\n\n\t\n\n\t\n\tmutex_lock(&parent_ctx->mutex);\n\n\t\n\tlist_for_each_entry(event, &parent_ctx->pinned_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\t\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 1;\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\n\tlist_for_each_entry(event, &parent_ctx->flexible_groups, group_entry) {\n\t\tret = inherit_task_group(event, parent, parent_ctx,\n\t\t\t\t\t child, ctxn, &inherited_all);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\traw_spin_lock_irqsave(&parent_ctx->lock, flags);\n\tparent_ctx->rotate_disable = 0;\n\n\tchild_ctx = child->perf_event_ctxp[ctxn];\n\n\tif (child_ctx && inherited_all) {\n\t\t\n\t\tcloned_ctx = parent_ctx->parent_ctx;\n\t\tif (cloned_ctx) {\n\t\t\tchild_ctx->parent_ctx = cloned_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->parent_gen;\n\t\t} else {\n\t\t\tchild_ctx->parent_ctx = parent_ctx;\n\t\t\tchild_ctx->parent_gen = parent_ctx->generation;\n\t\t}\n\t\tget_ctx(child_ctx->parent_ctx);\n\t}\n\n\traw_spin_unlock_irqrestore(&parent_ctx->lock, flags);\n\tmutex_unlock(&parent_ctx->mutex);\n\n\tperf_unpin_context(parent_ctx);\n\tput_ctx(parent_ctx);\n\n\treturn ret;\n}\n\n\nint perf_event_init_task(struct task_struct *child)\n{\n\tint ctxn, ret;\n\n\tmemset(child->perf_event_ctxp, 0, sizeof(child->perf_event_ctxp));\n\tmutex_init(&child->perf_event_mutex);\n\tinit_list_head(&child->perf_event_list);\n\n\tfor_each_task_context_nr(ctxn) {\n\t\tret = perf_event_init_context(child, ctxn);\n\t\tif (ret) {\n\t\t\tperf_event_free_task(child);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic void __init perf_event_init_all_cpus(void)\n{\n\tstruct swevent_htable *swhash;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tswhash = &per_cpu(swevent_htable, cpu);\n\t\tmutex_init(&swhash->hlist_mutex);\n\t\tinit_list_head(&per_cpu(active_ctx_list, cpu));\n\t}\n}\n\nstatic void perf_event_init_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = true;\n\tif (swhash->hlist_refcount > 0) {\n\t\tstruct swevent_hlist *hlist;\n\n\t\thlist = kzalloc_node(sizeof(*hlist), gfp_kernel, cpu_to_node(cpu));\n\t\twarn_on(!hlist);\n\t\trcu_assign_pointer(swhash->swevent_hlist, hlist);\n\t}\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n\n#if defined config_hotplug_cpu || defined config_kexec\nstatic void __perf_event_exit_context(void *__info)\n{\n\tstruct remove_event re = { .detach_group = true };\n\tstruct perf_event_context *ctx = __info;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(re.event, &ctx->event_list, event_entry)\n\t\t__perf_remove_from_context(&re);\n\trcu_read_unlock();\n}\n\nstatic void perf_event_exit_cpu_context(int cpu)\n{\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint idx;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tctx = &per_cpu_ptr(pmu->pmu_cpu_context, cpu)->ctx;\n\n\t\tmutex_lock(&ctx->mutex);\n\t\tsmp_call_function_single(cpu, __perf_event_exit_context, ctx, 1);\n\t\tmutex_unlock(&ctx->mutex);\n\t}\n\tsrcu_read_unlock(&pmus_srcu, idx);\n}\n\nstatic void perf_event_exit_cpu(int cpu)\n{\n\tstruct swevent_htable *swhash = &per_cpu(swevent_htable, cpu);\n\n\tperf_event_exit_cpu_context(cpu);\n\n\tmutex_lock(&swhash->hlist_mutex);\n\tswhash->online = false;\n\tswevent_hlist_release(swhash);\n\tmutex_unlock(&swhash->hlist_mutex);\n}\n#else\nstatic inline void perf_event_exit_cpu(int cpu) { }\n#endif\n\nstatic int\nperf_reboot(struct notifier_block *notifier, unsigned long val, void *v)\n{\n\tint cpu;\n\n\tfor_each_online_cpu(cpu)\n\t\tperf_event_exit_cpu(cpu);\n\n\treturn notify_ok;\n}\n\n\nstatic struct notifier_block perf_reboot_notifier = {\n\t.notifier_call = perf_reboot,\n\t.priority = int_min,\n};\n\nstatic int\nperf_cpu_notify(struct notifier_block *self, unsigned long action, void *hcpu)\n{\n\tunsigned int cpu = (long)hcpu;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\n\tcase cpu_up_prepare:\n\tcase cpu_down_failed:\n\t\tperf_event_init_cpu(cpu);\n\t\tbreak;\n\n\tcase cpu_up_canceled:\n\tcase cpu_down_prepare:\n\t\tperf_event_exit_cpu(cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn notify_ok;\n}\n\nvoid __init perf_event_init(void)\n{\n\tint ret;\n\n\tidr_init(&pmu_idr);\n\n\tperf_event_init_all_cpus();\n\tinit_srcu_struct(&pmus_srcu);\n\tperf_pmu_register(&perf_swevent, \"", "1026": "\", ((unsigned long)(rec->%s))\"", "1027": "\", (chip && chip->name) ? chip->name : \"", "1028": "\", (desc->action && desc->action->handler) ? '*' : ' ');\n\t\t\tdirect = (i == hwirq) && (i < domain->revmap_direct_max_irq);\n\t\t\tseq_printf(m, \"", "1029": "\", (int)(2 * sizeof(void *) + 2), \"", "1030": "\", (unsigned long long)now);\n\tseq_printf(m, \"", "1031": "\", (unsigned long)ts);\n\n\treturn sprintf(buf, \"", "1032": "\", (void *)*ptr);\n\n\treturn 0;\n}\n\nstatic const struct seq_operations ftrace_graph_seq_ops = {\n\t.start = g_start,\n\t.next = g_next,\n\t.stop = g_stop,\n\t.show = g_show,\n};\n\nstatic int\n__ftrace_graph_open(struct inode *inode, struct file *file,\n\t\t    struct ftrace_graph_data *fgd)\n{\n\tint ret = 0;\n\n\tmutex_lock(&graph_lock);\n\tif ((file->f_mode & fmode_write) &&\n\t    (file->f_flags & o_trunc)) {\n\t\t*fgd->count = 0;\n\t\tmemset(fgd->table, 0, fgd->size * sizeof(*fgd->table));\n\t}\n\tmutex_unlock(&graph_lock);\n\n\tif (file->f_mode & fmode_read) {\n\t\tret = seq_open(file, fgd->seq_ops);\n\t\tif (!ret) {\n\t\t\tstruct seq_file *m = file->private_data;\n\t\t\tm->private = fgd;\n\t\t}\n\t} else\n\t\tfile->private_data = fgd;\n\n\treturn ret;\n}\n\nstatic int\nftrace_graph_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\tfgd = kmalloc(sizeof(*fgd), gfp_kernel);\n\tif (fgd == null)\n\t\treturn -enomem;\n\n\tfgd->table = ftrace_graph_funcs;\n\tfgd->size = ftrace_graph_max_funcs;\n\tfgd->count = &ftrace_graph_count;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\treturn __ftrace_graph_open(inode, file, fgd);\n}\n\nstatic int\nftrace_graph_notrace_open(struct inode *inode, struct file *file)\n{\n\tstruct ftrace_graph_data *fgd;\n\n\tif (unlikely(ftrace_disabled))\n\t\treturn -enodev;\n\n\tfgd = kmalloc(sizeof(*fgd), gfp_kernel);\n\tif (fgd == null)\n\t\treturn -enomem;\n\n\tfgd->table = ftrace_graph_notrace_funcs;\n\tfgd->size = ftrace_graph_max_funcs;\n\tfgd->count = &ftrace_graph_notrace_count;\n\tfgd->seq_ops = &ftrace_graph_seq_ops;\n\n\treturn __ftrace_graph_open(inode, file, fgd);\n}\n\nstatic int\nftrace_graph_release(struct inode *inode, struct file *file)\n{\n\tif (file->f_mode & fmode_read) {\n\t\tstruct seq_file *m = file->private_data;\n\n\t\tkfree(m->private);\n\t\tseq_release(inode, file);\n\t} else {\n\t\tkfree(file->private_data);\n\t}\n\n\treturn 0;\n}\n\nstatic int\nftrace_set_func(unsigned long *array, int *idx, int size, char *buffer)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page *pg;\n\tint search_len;\n\tint fail = 1;\n\tint type, not;\n\tchar *search;\n\tbool exists;\n\tint i;\n\n\t\n\ttype = filter_parse_regex(buffer, strlen(buffer), &search, &not);\n\tif (!not && *idx >= size)\n\t\treturn -ebusy;\n\n\tsearch_len = strlen(search);\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (unlikely(ftrace_disabled)) {\n\t\tmutex_unlock(&ftrace_lock);\n\t\treturn -enodev;\n\t}\n\n\tdo_for_each_ftrace_rec(pg, rec) {\n\n\t\tif (ftrace_match_record(rec, null, search, search_len, type)) {\n\t\t\t\n\t\t\texists = false;\n\t\t\tfor (i = 0; i < *idx; i++) {\n\t\t\t\tif (array[i] == rec->ip) {\n\t\t\t\t\texists = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!not) {\n\t\t\t\tfail = 0;\n\t\t\t\tif (!exists) {\n\t\t\t\t\tarray[(*idx)++] = rec->ip;\n\t\t\t\t\tif (*idx >= size)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (exists) {\n\t\t\t\t\tarray[i] = array[--(*idx)];\n\t\t\t\t\tarray[*idx] = 0;\n\t\t\t\t\tfail = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} while_for_each_ftrace_rec();\nout:\n\tmutex_unlock(&ftrace_lock);\n\n\tif (fail)\n\t\treturn -einval;\n\n\treturn 0;\n}\n\nstatic ssize_t\nftrace_graph_write(struct file *file, const char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tstruct trace_parser parser;\n\tssize_t read, ret = 0;\n\tstruct ftrace_graph_data *fgd = file->private_data;\n\n\tif (!cnt)\n\t\treturn 0;\n\n\tif (trace_parser_get_init(&parser, ftrace_buff_max))\n\t\treturn -enomem;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >= 0 && trace_parser_loaded((&parser))) {\n\t\tparser.buffer[parser.idx] = 0;\n\n\t\tmutex_lock(&graph_lock);\n\n\t\t\n\t\tret = ftrace_set_func(fgd->table, fgd->count, fgd->size,\n\t\t\t\t      parser.buffer);\n\n\t\tmutex_unlock(&graph_lock);\n\t}\n\n\tif (!ret)\n\t\tret = read;\n\n\ttrace_parser_put(&parser);\n\n\treturn ret;\n}\n\nstatic const struct file_operations ftrace_graph_fops = {\n\t.open\t\t= ftrace_graph_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= ftrace_graph_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_graph_release,\n};\n\nstatic const struct file_operations ftrace_graph_notrace_fops = {\n\t.open\t\t= ftrace_graph_notrace_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= ftrace_graph_write,\n\t.llseek\t\t= tracing_lseek,\n\t.release\t= ftrace_graph_release,\n};\n#endif \n\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent)\n{\n\n\ttrace_create_file(\"", "1033": "\", (void *)addr);\n\telse\n\t\tseq_printf(m, \"", "1034": "\", (void *)ip);\n\n\tseq_puts(m, \"", "1035": "\", (void *)rec->ip);\n\tif (iter->flags & ftrace_iter_enabled) {\n\t\tstruct ftrace_ops *ops = null;\n\n\t\tseq_printf(m, \"", "1036": "\", *cp);\n\t\t\t++cp;\n\t\t}\n\t\tbreak;\n\tcase 16: \n\t\tmemset(tmpbuffer, ' ',\n\t\t       strlen(kdb_prompt_str) + (lastchar-buffer));\n\t\t*(tmpbuffer+strlen(kdb_prompt_str) +\n\t\t  (lastchar-buffer)) = '\\0';\n\t\tkdb_printf(\"", "1037": "\", *p);\n\n\tr += ftrace_arch_read_dyn_info(buf+r, (size-1)-r);\n\tbuf[r++] = '\\n';\n\n\tr = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n\n\tmutex_unlock(&dyn_info_mutex);\n\n\treturn r;\n}\n\nstatic const struct file_operations tracing_dyn_info_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_read_dyn_info,\n\t.llseek\t\t= generic_file_llseek,\n};\n#endif \n\n#if defined(config_tracer_snapshot) && defined(config_dynamic_ftrace)\nstatic void\nftrace_snapshot(unsigned long ip, unsigned long parent_ip, void **data)\n{\n\ttracing_snapshot();\n}\n\nstatic void\nftrace_count_snapshot(unsigned long ip, unsigned long parent_ip, void **data)\n{\n\tunsigned long *count = (long *)data;\n\n\tif (!*count)\n\t\treturn;\n\n\tif (*count != -1)\n\t\t(*count)--;\n\n\ttracing_snapshot();\n}\n\nstatic int\nftrace_snapshot_print(struct seq_file *m, unsigned long ip,\n\t\t      struct ftrace_probe_ops *ops, void *data)\n{\n\tlong count = (long)data;\n\n\tseq_printf(m, \"", "1038": "\", *pid, buf);\n\treturn 0;\n}\n\nstatic const struct seq_operations tracing_saved_cmdlines_seq_ops = {\n\t.start\t\t= saved_cmdlines_start,\n\t.next\t\t= saved_cmdlines_next,\n\t.stop\t\t= saved_cmdlines_stop,\n\t.show\t\t= saved_cmdlines_show,\n};\n\nstatic int tracing_saved_cmdlines_open(struct inode *inode, struct file *filp)\n{\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\treturn seq_open(filp, &tracing_saved_cmdlines_seq_ops);\n}\n\nstatic const struct file_operations tracing_saved_cmdlines_fops = {\n\t.open\t\t= tracing_saved_cmdlines_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic ssize_t\ntracing_saved_cmdlines_size_read(struct file *filp, char __user *ubuf,\n\t\t\t\t size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint r;\n\n\tarch_spin_lock(&trace_cmdline_lock);\n\tr = scnprintf(buf, sizeof(buf), \"", "1039": "\", -diag);\n}\n\n\nstruct defcmd_set {\n\tint count;\n\tint usable;\n\tchar *name;\n\tchar *usage;\n\tchar *help;\n\tchar **command;\n};\nstatic struct defcmd_set *defcmd_set;\nstatic int defcmd_set_count;\nstatic int defcmd_in_progress;\n\n\nstatic int kdb_exec_defcmd(int argc, const char **argv);\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"", "1040": "\", 0200, d_tracer,\n\t\t\t  tr, &tracing_free_buffer_fops);\n\n\ttrace_create_file(\"", "1041": "\", 0220, d_tracer,\n\t\t\t  tr, &tracing_mark_fops);\n\n\ttrace_create_file(\"", "1042": "\", 0444,\n\t\t\td_tracer, null, &ftrace_avail_fops);\n\n\ttrace_create_file(\"", "1043": "\", 0444,\n\t\t\td_tracer, null, &ftrace_enabled_fops);\n\n\tftrace_create_filter_files(&global_ops, d_tracer);\n\n#ifdef config_function_graph_tracer\n\ttrace_create_file(\"", "1044": "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &snapshot_raw_fops);\n#endif\n}\n\n#ifdef config_ftrace_selftest\n\n#include \"", "1045": "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_buffers_fops);\n\n\ttrace_create_cpu_file(\"", "1046": "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_entries_fops);\n\n#ifdef config_tracer_snapshot\n\ttrace_create_cpu_file(\"", "1047": "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_pipe_fops);\n\n\t\n\ttrace_create_cpu_file(\"", "1048": "\", 0444, d_cpu,\n\t\t\t\ttr, cpu, &tracing_stats_fops);\n\n\ttrace_create_cpu_file(\"", "1049": "\", 0444, d_tracer,\n\t\t\t\t    null,\n\t\t\t\t    &ftrace_graph_fops);\n\ttrace_create_file(\"", "1050": "\", 0444, d_tracer,\n\t\t\t\t    null,\n\t\t\t\t    &ftrace_graph_notrace_fops);\n#endif \n\n\treturn 0;\n}\n\nstatic int ftrace_cmp_ips(const void *a, const void *b)\n{\n\tconst unsigned long *ipa = a;\n\tconst unsigned long *ipb = b;\n\n\tif (*ipa > *ipb)\n\t\treturn 1;\n\tif (*ipa < *ipb)\n\t\treturn -1;\n\treturn 0;\n}\n\nstatic void ftrace_swap_ips(void *a, void *b, int size)\n{\n\tunsigned long *ipa = a;\n\tunsigned long *ipb = b;\n\tunsigned long t;\n\n\tt = *ipa;\n\t*ipa = *ipb;\n\t*ipb = t;\n}\n\nstatic int ftrace_process_locs(struct module *mod,\n\t\t\t       unsigned long *start,\n\t\t\t       unsigned long *end)\n{\n\tstruct ftrace_page *start_pg;\n\tstruct ftrace_page *pg;\n\tstruct dyn_ftrace *rec;\n\tunsigned long count;\n\tunsigned long *p;\n\tunsigned long addr;\n\tunsigned long flags = 0; \n\tint ret = -enomem;\n\n\tcount = end - start;\n\n\tif (!count)\n\t\treturn 0;\n\n\tsort(start, count, sizeof(*start),\n\t     ftrace_cmp_ips, ftrace_swap_ips);\n\n\tstart_pg = ftrace_allocate_pages(count);\n\tif (!start_pg)\n\t\treturn -enomem;\n\n\tmutex_lock(&ftrace_lock);\n\n\t\n\tif (!mod) {\n\t\twarn_on(ftrace_pages || ftrace_pages_start);\n\t\t\n\t\tftrace_pages = ftrace_pages_start = start_pg;\n\t} else {\n\t\tif (!ftrace_pages)\n\t\t\tgoto out;\n\n\t\tif (warn_on(ftrace_pages->next)) {\n\t\t\t\n\t\t\twhile (ftrace_pages->next)\n\t\t\t\tftrace_pages = ftrace_pages->next;\n\t\t}\n\n\t\tftrace_pages->next = start_pg;\n\t}\n\n\tp = start;\n\tpg = start_pg;\n\twhile (p < end) {\n\t\taddr = ftrace_call_adjust(*p++);\n\t\t\n\t\tif (!addr)\n\t\t\tcontinue;\n\n\t\tif (pg->index == pg->size) {\n\t\t\t\n\t\t\tif (warn_on(!pg->next))\n\t\t\t\tbreak;\n\t\t\tpg = pg->next;\n\t\t}\n\n\t\trec = &pg->records[pg->index++];\n\t\trec->ip = addr;\n\t}\n\n\t\n\twarn_on(pg->next);\n\n\t\n\tftrace_pages = pg;\n\n\t\n\tif (!mod)\n\t\tlocal_irq_save(flags);\n\tftrace_update_code(mod, start_pg);\n\tif (!mod)\n\t\tlocal_irq_restore(flags);\n\tret = 0;\n out:\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}\n\n#ifdef config_modules\n\n#define next_to_ftrace_page(p) container_of(p, struct ftrace_page, next)\n\nvoid ftrace_release_mod(struct module *mod)\n{\n\tstruct dyn_ftrace *rec;\n\tstruct ftrace_page **last_pg;\n\tstruct ftrace_page *pg;\n\tint order;\n\n\tmutex_lock(&ftrace_lock);\n\n\tif (ftrace_disabled)\n\t\tgoto out_unlock;\n\n\t\n\tlast_pg = &ftrace_pages_start;\n\tfor (pg = ftrace_pages_start; pg; pg = *last_pg) {\n\t\trec = &pg->records[0];\n\t\tif (within_module_core(rec->ip, mod)) {\n\t\t\t\n\t\t\tif (warn_on(pg == ftrace_pages_start))\n\t\t\t\tgoto out_unlock;\n\n\t\t\t\n\t\t\tif (pg == ftrace_pages)\n\t\t\t\tftrace_pages = next_to_ftrace_page(last_pg);\n\n\t\t\t*last_pg = pg->next;\n\t\t\torder = get_count_order(pg->size / entries_per_page);\n\t\t\tfree_pages((unsigned long)pg->records, order);\n\t\t\tkfree(pg);\n\t\t} else\n\t\t\tlast_pg = &pg->next;\n\t}\n out_unlock:\n\tmutex_unlock(&ftrace_lock);\n}\n\nstatic void ftrace_init_module(struct module *mod,\n\t\t\t       unsigned long *start, unsigned long *end)\n{\n\tif (ftrace_disabled || start == end)\n\t\treturn;\n\tftrace_process_locs(mod, start, end);\n}\n\nvoid ftrace_module_init(struct module *mod)\n{\n\tftrace_init_module(mod, mod->ftrace_callsites,\n\t\t\t   mod->ftrace_callsites +\n\t\t\t   mod->num_ftrace_callsites);\n}\n\nstatic int ftrace_module_notify_exit(struct notifier_block *self,\n\t\t\t\t     unsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\n\tif (val == module_state_going)\n\t\tftrace_release_mod(mod);\n\n\treturn 0;\n}\n#else\nstatic int ftrace_module_notify_exit(struct notifier_block *self,\n\t\t\t\t     unsigned long val, void *data)\n{\n\treturn 0;\n}\n#endif \n\nstruct notifier_block ftrace_module_exit_nb = {\n\t.notifier_call = ftrace_module_notify_exit,\n\t.priority = int_min,\t\n};\n\nvoid __init ftrace_init(void)\n{\n\textern unsigned long __start_mcount_loc[];\n\textern unsigned long __stop_mcount_loc[];\n\tunsigned long count, flags;\n\tint ret;\n\n\tlocal_irq_save(flags);\n\tret = ftrace_dyn_arch_init();\n\tlocal_irq_restore(flags);\n\tif (ret)\n\t\tgoto failed;\n\n\tcount = __stop_mcount_loc - __start_mcount_loc;\n\tif (!count) {\n\t\tpr_info(\"", "1051": "\", 0444, d_tracer,\n\t\t\t  null, &tracing_enum_map_fops);\n}\n\n#else \nstatic inline void trace_create_enum_file(struct dentry *d_tracer) { }\nstatic inline void trace_insert_enum_map_file(struct module *mod,\n\t\t\t      struct trace_enum_map **start, int len) { }\n#endif \n\nstatic void trace_insert_enum_map(struct module *mod,\n\t\t\t\t  struct trace_enum_map **start, int len)\n{\n\tstruct trace_enum_map **map;\n\n\tif (len <= 0)\n\t\treturn;\n\n\tmap = start;\n\n\ttrace_event_enum_update(map, len);\n\n\ttrace_insert_enum_map_file(mod, start, len);\n}\n\nstatic ssize_t\ntracing_set_trace_read(struct file *filp, char __user *ubuf,\n\t\t       size_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[max_tracer_size+2];\n\tint r;\n\n\tmutex_lock(&trace_types_lock);\n\tr = sprintf(buf, \"", "1052": "\", 0444, d_tracer,\n\t\t\t  tr, &tracing_pipe_fops);\n\n\ttrace_create_file(\"", "1053": "\", 0444, d_tracer,\n\t\t\t  tr, &tracing_total_entries_fops);\n\n\ttrace_create_file(\"", "1054": "\", 0444, d_tracer,\n\t\t\t&ftrace_update_tot_cnt, &tracing_dyn_info_fops);\n#endif\n\n\tcreate_trace_instances(d_tracer);\n\n\tcreate_trace_options_dir(&global_trace);\n\n\t\n\tif (global_trace.current_trace != &nop_trace)\n\t\tupdate_tracer_options(&global_trace, global_trace.current_trace);\n\n\treturn 0;\n}\n\nstatic int trace_panic_handler(struct notifier_block *this,\n\t\t\t       unsigned long event, void *unused)\n{\n\tif (ftrace_dump_on_oops)\n\t\tftrace_dump(ftrace_dump_on_oops);\n\treturn notify_ok;\n}\n\nstatic struct notifier_block trace_panic_notifier = {\n\t.notifier_call  = trace_panic_handler,\n\t.next           = null,\n\t.priority       = 150   \n};\n\nstatic int trace_die_handler(struct notifier_block *self,\n\t\t\t     unsigned long val,\n\t\t\t     void *data)\n{\n\tswitch (val) {\n\tcase die_oops:\n\t\tif (ftrace_dump_on_oops)\n\t\t\tftrace_dump(ftrace_dump_on_oops);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\nstatic struct notifier_block trace_die_notifier = {\n\t.notifier_call = trace_die_handler,\n\t.priority = 200\n};\n\n\n#define trace_max_print\t\t1000\n\n\n#define kern_trace\t\tkern_emerg\n\nvoid\ntrace_printk_seq(struct trace_seq *s)\n{\n\t\n\tif (s->seq.len >= trace_max_print)\n\t\ts->seq.len = trace_max_print;\n\n\t\n\tif (warn_on_once(s->seq.len >= s->seq.size))\n\t\ts->seq.len = s->seq.size - 1;\n\n\t\n\ts->buffer[s->seq.len] = 0;\n\n\tprintk(kern_trace \"", "1055": "\", 0444, d_tracer,\n\t\t\tnull, &tracing_readme_fops);\n\n\ttrace_create_file(\"", "1056": "\", 0444, d_tracer,\n\t\t\tnull, &tracing_saved_cmdlines_fops);\n\n\ttrace_create_file(\"", "1057": "\", 0444, d_tracer,\n\t\t\ttr, &show_traces_fops);\n\n\ttrace_create_file(\"", "1058": "\", 0444, null, &timer_list_fops);\n\tif (!pe)\n\t\treturn -enomem;\n\treturn 0;\n}\n__initcall(init_timer_list_procfs);\n\n\n#include <linux/console.h>\n#include <linux/vt_kern.h>\n#include <linux/kbd_kern.h>\n#include <linux/vt.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include \"", "1059": "\", 0444, rcudir,\n\t\t\t\t     null, &show_tiny_stats_fops);\n\tif (!retval)\n\t\tgoto free_out;\n\treturn 0;\nfree_out:\n\tdebugfs_remove_recursive(rcudir);\n\treturn 1;\n}\n\nstatic void __exit rcutiny_trace_cleanup(void)\n{\n\tdebugfs_remove_recursive(rcudir);\n}\n\nmodule_init(rcutiny_trace_init);\nmodule_exit(rcutiny_trace_cleanup);\n\nmodule_author(\"", "1060": "\", 0644, d_cpu,\n\t\t\t\ttr, cpu, &snapshot_fops);\n\n\ttrace_create_cpu_file(\"", "1061": "\", 0644, d_cpu,\n\t\t\t\ttr, cpu, &tracing_fops);\n\n\ttrace_create_cpu_file(\"", "1062": "\", 0644, d_tracer,\n\t\t\t  null, &tracing_saved_cmdlines_size_fops);\n\n\ttrace_enum_init();\n\n\ttrace_create_enum_file(d_tracer);\n\n#ifdef config_modules\n\tregister_module_notifier(&trace_module_nb);\n#endif\n\n#ifdef config_dynamic_ftrace\n\ttrace_create_file(\"", "1063": "\", 0644, d_tracer,\n\t\t\t  tr, &rb_simple_fops);\n\n#ifdef config_tracer_max_trace\n\ttrace_create_file(\"", "1064": "\", 0644, d_tracer,\n\t\t\t  tr, &snapshot_fops);\n#endif\n\n\tfor_each_tracing_cpu(cpu)\n\t\ttracing_init_tracefs_percpu(tr, cpu);\n\n}\n\nstatic struct vfsmount *trace_automount(void *ingore)\n{\n\tstruct vfsmount *mnt;\n\tstruct file_system_type *type;\n\n\t\n\ttype = get_fs_type(\"", "1065": "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_cpumask_fops);\n\n\ttrace_create_file(\"", "1066": "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_entries_fops);\n\n\ttrace_create_file(\"", "1067": "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_fops);\n\n\ttrace_create_file(\"", "1068": "\", 0644, d_tracer,\n\t\t\t  tr, &tracing_iter_fops);\n\n\ttrace_create_file(\"", "1069": "\", 0644, d_tracer,\n\t\t\t&global_trace, &tracing_thresh_fops);\n\n\ttrace_create_file(\"", "1070": "\", 0644, d_tracer,\n\t\t\t&tr->max_latency, &tracing_max_lat_fops);\n#endif\n\n\tif (ftrace_create_function_files(tr, d_tracer))\n\t\twarn(1, \"", "1071": "\", 0644, d_tracer,\n\t\t\ttr, &set_tracer_fops);\n\n\ttrace_create_file(\"", "1072": "\", 0644, d_tracer, tr,\n\t\t\t  &trace_clock_fops);\n\n\ttrace_create_file(\"", "1073": "\", 0644, null, &tstats_fops);\n\tif (!pe)\n\t\treturn -enomem;\n\treturn 0;\n}\n__initcall(init_tstats_procfs);\n\n\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/debugfs.h>\n#include <linux/seq_file.h>\n\n\nstruct rcu_ctrlblk {\n\tstruct rcu_head *rcucblist;\t\n\tstruct rcu_head **donetail;\t\n\tstruct rcu_head **curtail;\t\n\trcu_trace(long qlen);\t\t\n\trcu_trace(unsigned long gp_start); \n\trcu_trace(unsigned long ticks_this_gp); \n\trcu_trace(unsigned long jiffies_stall); \n\trcu_trace(const char *name);\t\n};\n\n\nstatic struct rcu_ctrlblk rcu_sched_ctrlblk = {\n\t.donetail\t= &rcu_sched_ctrlblk.rcucblist,\n\t.curtail\t= &rcu_sched_ctrlblk.rcucblist,\n\trcu_trace(.name = \"", "1074": "\", 0644, parent,\n\t\t\t  ops, &ftrace_filter_fops);\n\n\ttrace_create_file(\"", "1075": "\", 0644, parent,\n\t\t\t  ops, &ftrace_notrace_fops);\n}\n\n\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops)\n{\n\tmutex_lock(&ftrace_lock);\n\tif (ops->flags & ftrace_ops_fl_enabled)\n\t\tftrace_shutdown(ops, 0);\n\tops->flags |= ftrace_ops_fl_deleted;\n\tmutex_unlock(&ftrace_lock);\n}\n\nstatic __init int ftrace_init_dyn_tracefs(struct dentry *d_tracer)\n{\n\n\ttrace_create_file(\"", "1076": "\", 1);\n\tpm_states[pm_suspend_freeze] = pm_labels[relative_states ? 0 : 2];\n\treturn 1;\n}\n\n__setup(\"", "1077": "\", 2) == 0) {\n\t\tneg = 1;\n\t\tcmp += 2;\n\t}\n\n\tmutex_lock(&trace_types_lock);\n\n\tfor (i = 0; trace_options[i]; i++) {\n\t\tif (strcmp(cmp, trace_options[i]) == 0) {\n\t\t\tret = set_tracer_flag(tr, 1 << i, !neg);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tif (!trace_options[i])\n\t\tret = set_tracer_option(tr, cmp, neg);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_trace_options_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct seq_file *m = filp->private_data;\n\tstruct trace_array *tr = m->private;\n\tchar buf[64];\n\tint ret;\n\n\tif (cnt >= sizeof(buf))\n\t\treturn -einval;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -efault;\n\n\tbuf[cnt] = 0;\n\n\tret = trace_set_options(tr, buf);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic int tracing_trace_options_open(struct inode *inode, struct file *file)\n{\n\tstruct trace_array *tr = inode->i_private;\n\tint ret;\n\n\tif (tracing_disabled)\n\t\treturn -enodev;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -enodev;\n\n\tret = single_open(file, tracing_trace_options_show, inode->i_private);\n\tif (ret < 0)\n\t\ttrace_array_put(tr);\n\n\treturn ret;\n}\n\nstatic const struct file_operations tracing_iter_fops = {\n\t.open\t\t= tracing_trace_options_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= tracing_single_release_tr,\n\t.write\t\t= tracing_trace_options_write,\n};\n\nstatic const char readme_msg[] =\n\t\"", "1078": "\", 4)) {\n\t\t*brl_options = \"", "1079": "\", 4)) {\n\t\t*brl_options = *str + 4;\n\t\t*str = strchr(*brl_options, ',');\n\t\tif (!*str)\n\t\t\tpr_err(\"", "1080": "\", __func__);\n\t\t\tbreak;\n\t\t}\n\n\t\tentry = get_lock_parent(entry);\n\t\tdepth--;\n\t} while (entry && (depth >= 0));\n\n\treturn;\n}\n\nstatic void\nprint_irq_lock_scenario(struct lock_list *safe_entry,\n\t\t\tstruct lock_list *unsafe_entry,\n\t\t\tstruct lock_class *prev_class,\n\t\t\tstruct lock_class *next_class)\n{\n\tstruct lock_class *safe_class = safe_entry->class;\n\tstruct lock_class *unsafe_class = unsafe_entry->class;\n\tstruct lock_class *middle_class = prev_class;\n\n\tif (middle_class == safe_class)\n\t\tmiddle_class = next_class;\n\n\t\n\tif (middle_class != unsafe_class) {\n\t\tprintk(\"", "1081": "\", __func__);\n\t\n\t\n\ttfm = crypto_alloc_shash(hash_algo_name[hash], 0, 0);\n\tif (is_err(tfm))\n\t\treturn (ptr_err(tfm) == -enoent) ? err_ptr(-enopkg) : err_cast(tfm);\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdigest_size = crypto_shash_digestsize(tfm);\n\n\t\n\tret = -enomem;\n\tpks = kzalloc(digest_size + sizeof(*pks) + desc_size, gfp_kernel);\n\tif (!pks)\n\t\tgoto error_no_pks;\n\n\tpks->pkey_hash_algo\t= hash;\n\tpks->digest\t\t= (u8 *)pks + sizeof(*pks) + desc_size;\n\tpks->digest_size\t= digest_size;\n\n\tdesc = (void *)pks + sizeof(*pks);\n\tdesc->tfm   = tfm;\n\tdesc->flags = crypto_tfm_req_may_sleep;\n\n\tret = crypto_shash_init(desc);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tret = crypto_shash_finup(desc, mod, modlen, pks->digest);\n\tif (ret < 0)\n\t\tgoto error;\n\n\tcrypto_free_shash(tfm);\n\tpr_devel(\"", "1082": "\", __get_str(%s)\"", "1083": "\", __log_buf_len);\n\n\tlog_buf_len_update(cpu_extra + __log_buf_len);\n}\n#else \nstatic inline void log_buf_add_cpu(void) {}\n#endif \n\nvoid __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tint free;\n\n\tif (log_buf != __log_buf)\n\t\treturn;\n\n\tif (!early && !new_log_buf_len)\n\t\tlog_buf_add_cpu();\n\n\tif (!new_log_buf_len)\n\t\treturn;\n\n\tif (early) {\n\t\tnew_log_buf =\n\t\t\tmemblock_virt_alloc(new_log_buf_len, log_align);\n\t} else {\n\t\tnew_log_buf = memblock_virt_alloc_nopanic(new_log_buf_len,\n\t\t\t\t\t\t\t  log_align);\n\t}\n\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"", "1084": "\", argv[1], argv[2]);\n\n\tep[varlen+vallen+1] = '\\0';\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], argv[1], varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn kdb_envfull;\n}\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"", "1085": "\", at: \"", "1086": "\", atomic_read(&overflow_count));\n\tseq_printf(m, \"", "1087": "\", base);\n\tseq_printf(m, \"", "1088": "\", best->name);\n\t\tcurr_clocksource = best;\n\t}\n}\n\n\nstatic void clocksource_select(void)\n{\n\treturn __clocksource_select(false);\n}\n\nstatic void clocksource_select_fallback(void)\n{\n\treturn __clocksource_select(true);\n}\n\n#else \n\nstatic inline void clocksource_select(void) { }\nstatic inline void clocksource_select_fallback(void) { }\n\n#endif\n\n\nstatic int __init clocksource_done_booting(void)\n{\n\tmutex_lock(&clocksource_mutex);\n\tcurr_clocksource = clocksource_default_clock();\n\tfinished_booting = 1;\n\t\n\t__clocksource_watchdog_kthread();\n\tclocksource_select();\n\tmutex_unlock(&clocksource_mutex);\n\treturn 0;\n}\nfs_initcall(clocksource_done_booting);\n\n\nstatic void clocksource_enqueue(struct clocksource *cs)\n{\n\tstruct list_head *entry = &clocksource_list;\n\tstruct clocksource *tmp;\n\n\tlist_for_each_entry(tmp, &clocksource_list, list)\n\t\t\n\t\tif (tmp->rating >= cs->rating)\n\t\t\tentry = &tmp->list;\n\tlist_add(&cs->list, entry);\n}\n\n\nvoid __clocksource_update_freq_scale(struct clocksource *cs, u32 scale, u32 freq)\n{\n\tu64 sec;\n\n\t\n\tif (freq) {\n\t\t\n\t\tsec = cs->mask;\n\t\tdo_div(sec, freq);\n\t\tdo_div(sec, scale);\n\t\tif (!sec)\n\t\t\tsec = 1;\n\t\telse if (sec > 600 && cs->mask > uint_max)\n\t\t\tsec = 600;\n\n\t\tclocks_calc_mult_shift(&cs->mult, &cs->shift, freq,\n\t\t\t\t       nsec_per_sec / scale, sec * scale);\n\t}\n\t\n\tcs->maxadj = clocksource_max_adjustment(cs);\n\twhile (freq && ((cs->mult + cs->maxadj < cs->mult)\n\t\t|| (cs->mult - cs->maxadj > cs->mult))) {\n\t\tcs->mult >>= 1;\n\t\tcs->shift--;\n\t\tcs->maxadj = clocksource_max_adjustment(cs);\n\t}\n\n\t\n\twarn_once(cs->mult + cs->maxadj < cs->mult,\n\t\t\"", "1089": "\", boot_delay_setup);\n\nstatic void boot_delay_msec(int level)\n{\n\tunsigned long long k;\n\tunsigned long timeout;\n\n\tif ((boot_delay == 0 || system_state != system_booting)\n\t\t|| (level >= console_loglevel && !ignore_loglevel)) {\n\t\treturn;\n\t}\n\n\tk = (unsigned long long)loops_per_msec * boot_delay;\n\n\ttimeout = jiffies + msecs_to_jiffies(boot_delay);\n\twhile (k) {\n\t\tk--;\n\t\tcpu_relax();\n\t\t\n\t\tif (time_after(jiffies, timeout))\n\t\t\tbreak;\n\t\ttouch_nmi_watchdog();\n\t}\n}\n#else\nstatic inline void boot_delay_msec(int level)\n{\n}\n#endif\n\nstatic bool printk_time = is_enabled(config_printk_time);\nmodule_param_named(time, printk_time, bool, s_irugo | s_iwusr);\n\nstatic size_t print_time(u64 ts, char *buf)\n{\n\tunsigned long rem_nsec;\n\n\tif (!printk_time)\n\t\treturn 0;\n\n\trem_nsec = do_div(ts, 1000000000);\n\n\tif (!buf)\n\t\treturn snprintf(null, 0, \"", "1090": "\", boot_override_clock);\n\n\n#include <linux/module.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/kdev_t.h>\n#include <linux/console.h>\n#include <linux/string.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/kallsyms.h>\n#include \"", "1091": "\", boot_override_clocksource);\n\n\nstatic int __init boot_override_clock(char* str)\n{\n\tif (!strcmp(str, \"", "1092": "\", buffer);\n\t\t\t\t*cp = tmp;\n\t\t\t} else {\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp++ = key;\n\t\t\t\t\n\t\t\t\tif (!kdb_state(kgdb_trans)) {\n\t\t\t\t\tif (kgdb_transition_check(buffer))\n\t\t\t\t\t\treturn buffer;\n\t\t\t\t} else {\n\t\t\t\t\tkdb_printf(\"", "1093": "\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 13: \n\t\t*lastchar++ = '\\n';\n\t\t*lastchar++ = '\\0';\n\t\tif (!kdb_state(kgdb_trans)) {\n\t\t\tkdb_state_set(kgdb_trans);\n\t\t\tkdb_printf(\"", "1094": "\", buffer);\n\t\t\t*cp = tmp;\n\t\t}\n\t\tbreak;\n\tcase 1: \n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"", "1095": "\", buffer);\n\t\t}\n\t\tkdb_printf(\"", "1096": "\", buffer);\n\t\t} else if (tab != 2 && count > 0) {\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(p_tmp+len_tmp, cp, lastchar-cp+1);\n\t\t\tlen_tmp = strlen(p_tmp);\n\t\t\tstrncpy(cp, p_tmp+len, len_tmp-len + 1);\n\t\t\tlen = len_tmp - len;\n\t\t\tkdb_printf(\"", "1097": "\", buffer);\n\t} else {\n\t\tint slen = strlen(buffer);\n\t\tif (slen > 3 && buffer[slen - 3] == '#') {\n\t\t\tkdb_gdb_state_pass(buffer);\n\t\t\tstrcpy(buffer, \"", "1098": "\", buffer);\npoll_again:\n\tkey = kdb_read_get_key(buffer, bufsize);\n\tif (key == -1)\n\t\treturn buffer;\n\tif (key != 9)\n\t\ttab = 0;\n\tswitch (key) {\n\tcase 8: \n\t\tif (cp > buffer) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp-1, tmpbuffer, lastchar - cp);\n\t\t\t}\n\t\t\t*(--lastchar) = '\\0';\n\t\t\t--cp;\n\t\t\tkdb_printf(\"", "1099": "\", c);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuser->buf[len++] = c;\n\t\t}\n\t\tuser->buf[len++] = '\\n';\n\t}\n\n\tuser->idx = log_next(user->idx);\n\tuser->seq++;\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\tif (len > count) {\n\t\tret = -einval;\n\t\tgoto out;\n\t}\n\n\tif (copy_to_user(buf, user->buf, len)) {\n\t\tret = -efault;\n\t\tgoto out;\n\t}\n\tret = len;\nout:\n\tmutex_unlock(&user->lock);\n\treturn ret;\n}\n\nstatic loff_t devkmsg_llseek(struct file *file, loff_t offset, int whence)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tloff_t ret = 0;\n\n\tif (!user)\n\t\treturn -ebadf;\n\tif (offset)\n\t\treturn -espipe;\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tswitch (whence) {\n\tcase seek_set:\n\t\t\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tbreak;\n\tcase seek_data:\n\t\t\n\t\tuser->idx = clear_idx;\n\t\tuser->seq = clear_seq;\n\t\tbreak;\n\tcase seek_end:\n\t\t\n\t\tuser->idx = log_next_idx;\n\t\tuser->seq = log_next_seq;\n\t\tbreak;\n\tdefault:\n\t\tret = -einval;\n\t}\n\traw_spin_unlock_irq(&logbuf_lock);\n\treturn ret;\n}\n\nstatic unsigned int devkmsg_poll(struct file *file, poll_table *wait)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tint ret = 0;\n\n\tif (!user)\n\t\treturn pollerr|pollnval;\n\n\tpoll_wait(file, &log_wait, wait);\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tif (user->seq < log_next_seq) {\n\t\t\n\t\tif (user->seq < log_first_seq)\n\t\t\tret = pollin|pollrdnorm|pollerr|pollpri;\n\t\telse\n\t\t\tret = pollin|pollrdnorm;\n\t}\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\treturn ret;\n}\n\nstatic int devkmsg_open(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user;\n\tint err;\n\n\t\n\tif ((file->f_flags & o_accmode) == o_wronly)\n\t\treturn 0;\n\n\terr = check_syslog_permissions(syslog_action_read_all,\n\t\t\t\t       syslog_from_reader);\n\tif (err)\n\t\treturn err;\n\n\tuser = kmalloc(sizeof(struct devkmsg_user), gfp_kernel);\n\tif (!user)\n\t\treturn -enomem;\n\n\tmutex_init(&user->lock);\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tuser->idx = log_first_idx;\n\tuser->seq = log_first_seq;\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\tfile->private_data = user;\n\treturn 0;\n}\n\nstatic int devkmsg_release(struct inode *inode, struct file *file)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\n\tif (!user)\n\t\treturn 0;\n\n\tmutex_destroy(&user->lock);\n\tkfree(user);\n\treturn 0;\n}\n\nconst struct file_operations kmsg_fops = {\n\t.open = devkmsg_open,\n\t.read = devkmsg_read,\n\t.write_iter = devkmsg_write,\n\t.llseek = devkmsg_llseek,\n\t.poll = devkmsg_poll,\n\t.release = devkmsg_release,\n};\n\n#ifdef config_kexec\n\nvoid log_buf_kexec_setup(void)\n{\n\tvmcoreinfo_symbol(log_buf);\n\tvmcoreinfo_symbol(log_buf_len);\n\tvmcoreinfo_symbol(log_first_idx);\n\tvmcoreinfo_symbol(log_next_idx);\n\t\n\tvmcoreinfo_struct_size(printk_log);\n\tvmcoreinfo_offset(printk_log, ts_nsec);\n\tvmcoreinfo_offset(printk_log, len);\n\tvmcoreinfo_offset(printk_log, text_len);\n\tvmcoreinfo_offset(printk_log, dict_len);\n}\n#endif\n\n\nstatic unsigned long __initdata new_log_buf_len;\n\n\nstatic void __init log_buf_len_update(unsigned size)\n{\n\tif (size)\n\t\tsize = roundup_pow_of_two(size);\n\tif (size > log_buf_len)\n\t\tnew_log_buf_len = size;\n}\n\n\nstatic int __init log_buf_len_setup(char *str)\n{\n\tunsigned size = memparse(str, &str);\n\n\tlog_buf_len_update(size);\n\n\treturn 0;\n}\nearly_param(\"", "1100": "\", c);\n\t\telse\n\t\t\tuser->buf[len++] = c;\n\t}\n\tuser->buf[len++] = '\\n';\n\n\tif (msg->dict_len) {\n\t\tbool line = true;\n\n\t\tfor (i = 0; i < msg->dict_len; i++) {\n\t\t\tunsigned char c = log_dict(msg)[i];\n\n\t\t\tif (line) {\n\t\t\t\tuser->buf[len++] = ' ';\n\t\t\t\tline = false;\n\t\t\t}\n\n\t\t\tif (c == '\\0') {\n\t\t\t\tuser->buf[len++] = '\\n';\n\t\t\t\tline = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (c < ' ' || c >= 127 || c == '\\\\') {\n\t\t\t\tlen += sprintf(user->buf + len, \"", "1101": "\", chan->base_filename, cpu);\n\n\t\n\tdentry = chan->cb->create_buf_file(tmpname, chan->parent,\n\t\t\t\t\t   s_irusr, buf,\n\t\t\t\t\t   &chan->is_global);\n\n\tkfree(tmpname);\n\n\treturn dentry;\n}\n\n\nstatic struct rchan_buf *relay_open_buf(struct rchan *chan, unsigned int cpu)\n{\n \tstruct rchan_buf *buf = null;\n\tstruct dentry *dentry;\n\n \tif (chan->is_global)\n\t\treturn chan->buf[0];\n\n\tbuf = relay_create_buf(chan);\n\tif (!buf)\n\t\treturn null;\n\n\tif (chan->has_base_filename) {\n\t\tdentry = relay_create_buf_file(chan, buf, cpu);\n\t\tif (!dentry)\n\t\t\tgoto free_buf;\n\t\trelay_set_buf_dentry(buf, dentry);\n\t}\n\n \tbuf->cpu = cpu;\n \t__relay_reset(buf, 1);\n\n \tif(chan->is_global) {\n \t\tchan->buf[0] = buf;\n \t\tbuf->cpu = 0;\n  \t}\n\n\treturn buf;\n\nfree_buf:\n \trelay_destroy_buf(buf);\n\treturn null;\n}\n\n\nstatic void relay_close_buf(struct rchan_buf *buf)\n{\n\tbuf->finalized = 1;\n\tdel_timer_sync(&buf->timer);\n\tbuf->chan->cb->remove_buf_file(buf->dentry);\n\tkref_put(&buf->kref, relay_remove_buf);\n}\n\nstatic void setup_callbacks(struct rchan *chan,\n\t\t\t\t   struct rchan_callbacks *cb)\n{\n\tif (!cb) {\n\t\tchan->cb = &default_channel_callbacks;\n\t\treturn;\n\t}\n\n\tif (!cb->subbuf_start)\n\t\tcb->subbuf_start = subbuf_start_default_callback;\n\tif (!cb->buf_mapped)\n\t\tcb->buf_mapped = buf_mapped_default_callback;\n\tif (!cb->buf_unmapped)\n\t\tcb->buf_unmapped = buf_unmapped_default_callback;\n\tif (!cb->create_buf_file)\n\t\tcb->create_buf_file = create_buf_file_default_callback;\n\tif (!cb->remove_buf_file)\n\t\tcb->remove_buf_file = remove_buf_file_default_callback;\n\tchan->cb = cb;\n}\n\n\nstatic int relay_hotcpu_callback(struct notifier_block *nb,\n\t\t\t\tunsigned long action,\n\t\t\t\tvoid *hcpu)\n{\n\tunsigned int hotcpu = (unsigned long)hcpu;\n\tstruct rchan *chan;\n\n\tswitch(action) {\n\tcase cpu_up_prepare:\n\tcase cpu_up_prepare_frozen:\n\t\tmutex_lock(&relay_channels_mutex);\n\t\tlist_for_each_entry(chan, &relay_channels, list) {\n\t\t\tif (chan->buf[hotcpu])\n\t\t\t\tcontinue;\n\t\t\tchan->buf[hotcpu] = relay_open_buf(chan, hotcpu);\n\t\t\tif(!chan->buf[hotcpu]) {\n\t\t\t\tprintk(kern_err\n\t\t\t\t\t\"", "1102": "\", class->ops);\n\tprintk(\"", "1103": "\", cnt);\n\n\tcnt = ring_buffer_bytes_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"", "1104": "\", cnt);\n\n\tcnt = ring_buffer_commit_overrun_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"", "1105": "\", cnt);\n\n\tcnt = ring_buffer_overrun_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"", "1106": "\", cnt);\n\n\tcnt = ring_buffer_read_events_cpu(trace_buf->buffer, cpu);\n\ttrace_seq_printf(s, \"", "1107": "\", cnt);\n\n\tcount = simple_read_from_buffer(ubuf, count, ppos,\n\t\t\t\t\ts->buffer, trace_seq_used(s));\n\n\tkfree(s);\n\n\treturn count;\n}\n\nstatic const struct file_operations tracing_stats_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= tracing_stats_read,\n\t.llseek\t\t= generic_file_llseek,\n\t.release\t= tracing_release_generic_tr,\n};\n\n#ifdef config_dynamic_ftrace\n\nint __weak ftrace_arch_read_dyn_info(char *buf, int size)\n{\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_read_dyn_info(struct file *filp, char __user *ubuf,\n\t\t  size_t cnt, loff_t *ppos)\n{\n\tstatic char ftrace_dyn_info_buffer[1024];\n\tstatic define_mutex(dyn_info_mutex);\n\tunsigned long *p = filp->private_data;\n\tchar *buf = ftrace_dyn_info_buffer;\n\tint size = array_size(ftrace_dyn_info_buffer);\n\tint r;\n\n\tmutex_lock(&dyn_info_mutex);\n\tr = sprintf(buf, \"", "1108": "\", cnt);\n\n\tif (trace_clocks[tr->clock_id].in_ns) {\n\t\t\n\t\tt = ns2usecs(ring_buffer_oldest_event_ts(trace_buf->buffer, cpu));\n\t\tusec_rem = do_div(t, usec_per_sec);\n\t\ttrace_seq_printf(s, \"", "1109": "\", console_setup);\n\n\nint add_preferred_console(char *name, int idx, char *options)\n{\n\treturn __add_preferred_console(name, idx, options, null);\n}\n\nbool console_suspend_enabled = true;\nexport_symbol(console_suspend_enabled);\n\nstatic int __init console_suspend_disable(char *str)\n{\n\tconsole_suspend_enabled = false;\n\treturn 1;\n}\n__setup(\"", "1110": "\", console_suspend_disable);\nmodule_param_named(console_suspend, console_suspend_enabled,\n\t\tbool, s_irugo | s_iwusr);\nmodule_parm_desc(console_suspend, \"", "1111": "\", count);\n\t\t\tif (count > dtab_count) {\n\t\t\t\tcount = dtab_count;\n\t\t\t\tkdb_printf(\"", "1112": "\", count);\n\n\treturn 0;\n}\n\nstatic struct ftrace_probe_ops snapshot_probe_ops = {\n\t.func\t\t\t= ftrace_snapshot,\n\t.print\t\t\t= ftrace_snapshot_print,\n};\n\nstatic struct ftrace_probe_ops snapshot_count_probe_ops = {\n\t.func\t\t\t= ftrace_count_snapshot,\n\t.print\t\t\t= ftrace_snapshot_print,\n};\n\nstatic int\nftrace_trace_snapshot_callback(struct ftrace_hash *hash,\n\t\t\t       char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\tvoid *count = (void *)-1;\n\tchar *number;\n\tint ret;\n\n\t\n\tif (!enable)\n\t\treturn -einval;\n\n\tops = param ? &snapshot_count_probe_ops :  &snapshot_probe_ops;\n\n\tif (glob[0] == '!') {\n\t\tunregister_ftrace_function_probe_func(glob+1, ops);\n\t\treturn 0;\n\t}\n\n\tif (!param)\n\t\tgoto out_reg;\n\n\tnumber = strsep(&param, \"", "1113": "\", cp);\n\t\t\t\t++cp;\n\t\t\t\ttmp = *cp;\n\t\t\t\t*cp = '\\0';\n\t\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\t\tkdb_printf(\"", "1114": "\", cp);\n\t\t\tcp += len;\n\t\t\tlastchar += len;\n\t\t}\n\t\tkdb_nextline = 1; \n\t\tbreak;\n\tdefault:\n\t\tif (key >= 32 && lastchar < bufend) {\n\t\t\tif (cp < lastchar) {\n\t\t\t\tmemcpy(tmpbuffer, cp, lastchar - cp);\n\t\t\t\tmemcpy(cp+1, tmpbuffer, lastchar - cp);\n\t\t\t\t*++lastchar = '\\0';\n\t\t\t\t*cp = key;\n\t\t\t\tkdb_printf(\"", "1115": "\", cp);\n\t\t\tcp = lastchar;\n\t\t}\n\t\tbreak;\n\tcase 2: \n\t\tif (cp > buffer) {\n\t\t\tkdb_printf(\"", "1116": "\", cp);\n\t\t\ttmp = *cp;\n\t\t\t*cp = '\\0';\n\t\t\tkdb_printf(kdb_prompt_str);\n\t\t\tkdb_printf(\"", "1117": "\", cpu);\n\t\treturn 0;\n\t}\n\tbase->hres_active = 1;\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++)\n\t\tbase->clock_base[i].resolution = ktime_high_res;\n\n\ttick_setup_sched_timer();\n\t\n\tretrigger_next_event(null);\n\tlocal_irq_restore(flags);\n\treturn 1;\n}\n\nstatic void clock_was_set_work(struct work_struct *work)\n{\n\tclock_was_set();\n}\n\nstatic declare_work(hrtimer_work, clock_was_set_work);\n\n\nvoid clock_was_set_delayed(void)\n{\n\tschedule_work(&hrtimer_work);\n}\n\n#else\n\nstatic inline int hrtimer_hres_active(void) { return 0; }\nstatic inline int hrtimer_is_hres_enabled(void) { return 0; }\nstatic inline int hrtimer_switch_to_hres(void) { return 0; }\nstatic inline void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *base, int skip_equal) { }\nstatic inline int hrtimer_reprogram(struct hrtimer *timer,\n\t\t\t\t    struct hrtimer_clock_base *base)\n{\n\treturn 0;\n}\nstatic inline void hrtimer_init_hres(struct hrtimer_cpu_base *base) { }\nstatic inline void retrigger_next_event(void *arg) { }\n\n#endif \n\n\nvoid clock_was_set(void)\n{\n#ifdef config_high_res_timers\n\t\n\ton_each_cpu(retrigger_next_event, null, 1);\n#endif\n\ttimerfd_clock_was_set();\n}\n\n\nvoid hrtimers_resume(void)\n{\n\twarn_once(!irqs_disabled(),\n\t\t  kern_info \"", "1118": "\", cpu);\n\td_cpu = tracefs_create_dir(cpu_dir, d_percpu);\n\tif (!d_cpu) {\n\t\tpr_warning(\"", "1119": "\", cpu);\n\tfor (i = 0; i < hrtimer_max_clock_bases; i++) {\n\t\tseq_printf(m, \"", "1120": "\", cpu);\n\n\treturn tr->percpu_dir;\n}\n\nstatic struct dentry *\ntrace_create_cpu_file(const char *name, umode_t mode, struct dentry *parent,\n\t\t      void *data, long cpu, const struct file_operations *fops)\n{\n\tstruct dentry *ret = trace_create_file(name, mode, parent, data, fops);\n\n\tif (ret) \n\t\td_inode(ret)->i_cdev = (void *)(cpu + 1);\n\treturn ret;\n}\n\nstatic void\ntracing_init_tracefs_percpu(struct trace_array *tr, long cpu)\n{\n\tstruct dentry *d_percpu = tracing_dentry_percpu(tr, cpu);\n\tstruct dentry *d_cpu;\n\tchar cpu_dir[30]; \n\n\tif (!d_percpu)\n\t\treturn;\n\n\tsnprintf(cpu_dir, 30, \"", "1121": "\", cpu_dir);\n\t\treturn;\n\t}\n\n\t\n\ttrace_create_cpu_file(\"", "1122": "\", cs->name);\n\t\t\toverride_name[0] = 0;\n\t\t} else\n\t\t\t\n\t\t\tbest = cs;\n\t\tbreak;\n\t}\n\n\tif (curr_clocksource != best && !timekeeping_notify(best)) {\n\t\tpr_info(\"", "1123": "\", cs->name);\n\t\t\tpr_warn(\"", "1124": "\", curr_clocksource->name);\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn count;\n}\n\nssize_t sysfs_get_uname(const char *buf, char *dst, size_t cnt)\n{\n\tsize_t ret = cnt;\n\n\t\n\tif (!cnt || cnt >= cs_name_len)\n\t\treturn -einval;\n\n\t\n\tif (buf[cnt-1] == '\\n')\n\t\tcnt--;\n\tif (cnt > 0)\n\t\tmemcpy(dst, buf, cnt);\n\tdst[cnt] = 0;\n\treturn ret;\n}\n\n\nstatic ssize_t sysfs_override_clocksource(struct device *dev,\n\t\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t\t  const char *buf, size_t count)\n{\n\tssize_t ret;\n\n\tmutex_lock(&clocksource_mutex);\n\n\tret = sysfs_get_uname(buf, override_name, count);\n\tif (ret >= 0)\n\t\tclocksource_select();\n\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret;\n}\n\n\nstatic ssize_t sysfs_unbind_clocksource(struct device *dev,\n\t\t\t\t\tstruct device_attribute *attr,\n\t\t\t\t\tconst char *buf, size_t count)\n{\n\tstruct clocksource *cs;\n\tchar name[cs_name_len];\n\tssize_t ret;\n\n\tret = sysfs_get_uname(buf, name, count);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tret = -enodev;\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(cs, &clocksource_list, list) {\n\t\tif (strcmp(cs->name, name))\n\t\t\tcontinue;\n\t\tret = clocksource_unbind(cs);\n\t\tbreak;\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\treturn ret ? ret : count;\n}\n\n\nstatic ssize_t\nsysfs_show_available_clocksources(struct device *dev,\n\t\t\t\t  struct device_attribute *attr,\n\t\t\t\t  char *buf)\n{\n\tstruct clocksource *src;\n\tssize_t count = 0;\n\n\tmutex_lock(&clocksource_mutex);\n\tlist_for_each_entry(src, &clocksource_list, list) {\n\t\t\n\t\tif (!tick_oneshot_mode_active() ||\n\t\t    (src->flags & clock_source_valid_for_hres))\n\t\t\tcount += snprintf(buf + count,\n\t\t\t\t  max((ssize_t)page_size - count, (ssize_t)0),\n\t\t\t\t  \"", "1125": "\", current);\n\tbug();\n}\nexport_symbol(__invalid_creds);\n\n\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(kern_err \"", "1126": "\", d_tracer);\n\tif (!tr->options) {\n\t\tpr_warning(\"", "1127": "\", d_tracer);\n\n\twarn_once(!tr->percpu_dir,\n\t\t  \"", "1128": "\", d_tracer,\n\t\t\t\t\t\t\t instance_mkdir,\n\t\t\t\t\t\t\t instance_rmdir);\n\tif (warn_on(!trace_instance_dir))\n\t\treturn;\n}\n\nstatic void\ninit_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer)\n{\n\tint cpu;\n\n\ttrace_create_file(\"", "1129": "\", data);\n\n\t\t\tseq_printf(m, \"", "1130": "\", depth);\n\tprint_lock_name(target->class);\n\tprintk(\"", "1131": "\", depth, \"", "1132": "\", desc->irq_data.domain->name);\n\t\t}\n\n\t\traw_spin_unlock_irqrestore(&desc->lock, flags);\n\t}\n\n\treturn 0;\n}\n\nstatic int virq_debug_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, virq_debug_show, inode->i_private);\n}\n\nstatic const struct file_operations virq_debug_fops = {\n\t.open = virq_debug_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int __init irq_debugfs_init(void)\n{\n\tif (debugfs_create_file(\"", "1133": "\", dev->mode);\n\tseq_printf(m, \"", "1134": "\", dev->mult);\n\tseq_printf(m, \"", "1135": "\", dev->name);\n\tseq_printf(m, \"", "1136": "\", dev->retries);\n\tseq_printf(m, \"", "1137": "\", dev->shift);\n\tseq_printf(m, \"", "1138": "\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"", "1139": "\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"", "1140": "\", entry->type);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_hex_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tunsigned char newline = '\\n';\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (trace_flags & trace_iter_context_info) {\n\t\tseq_put_hex_field(s, entry->pid);\n\t\tseq_put_hex_field(s, iter->cpu);\n\t\tseq_put_hex_field(s, iter->ts);\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\treturn trace_type_partial_line;\n\t}\n\n\tevent = ftrace_find_event(entry->type);\n\tif (event) {\n\t\tenum print_line_t ret = event->funcs->hex(iter, 0, event);\n\t\tif (ret != trace_type_handled)\n\t\t\treturn ret;\n\t}\n\n\tseq_put_field(s, newline);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_bin_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (trace_flags & trace_iter_context_info) {\n\t\tseq_put_field(s, entry->pid);\n\t\tseq_put_field(s, iter->cpu);\n\t\tseq_put_field(s, iter->ts);\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\treturn trace_type_partial_line;\n\t}\n\n\tevent = ftrace_find_event(entry->type);\n\treturn event ? event->funcs->binary(iter, 0, event) :\n\t\ttrace_type_handled;\n}\n\nint trace_empty(struct trace_iterator *iter)\n{\n\tstruct ring_buffer_iter *buf_iter;\n\tint cpu;\n\n\t\n\tif (iter->cpu_file != ring_buffer_all_cpus) {\n\t\tcpu = iter->cpu_file;\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tbuf_iter = trace_buffer_iter(iter, cpu);\n\t\tif (buf_iter) {\n\t\t\tif (!ring_buffer_iter_empty(buf_iter))\n\t\t\t\treturn 0;\n\t\t} else {\n\t\t\tif (!ring_buffer_empty_cpu(iter->trace_buffer->buffer, cpu))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn 1;\n}\n\n\nenum print_line_t print_trace_line(struct trace_iterator *iter)\n{\n\tenum print_line_t ret;\n\n\tif (iter->lost_events) {\n\t\ttrace_seq_printf(&iter->seq, \"", "1141": "\", entry->type);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t print_raw_fmt(struct trace_iterator *iter)\n{\n\tstruct trace_seq *s = &iter->seq;\n\tstruct trace_entry *entry;\n\tstruct trace_event *event;\n\n\tentry = iter->ent;\n\n\tif (trace_flags & trace_iter_context_info)\n\t\ttrace_seq_printf(s, \"", "1142": "\", events);\n\n\tmutex_unlock(&show_mutex);\n\n\treturn 0;\n}\n\n\nstatic void sync_access(void)\n{\n\tunsigned long flags;\n\tint cpu;\n\n\tfor_each_online_cpu(cpu) {\n\t\traw_spinlock_t *lock = &per_cpu(tstats_lookup_lock, cpu);\n\n\t\traw_spin_lock_irqsave(lock, flags);\n\t\t\n\t\traw_spin_unlock_irqrestore(lock, flags);\n\t}\n}\n\nstatic ssize_t tstats_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *offs)\n{\n\tchar ctl[2];\n\n\tif (count != 2 || *offs)\n\t\treturn -einval;\n\n\tif (copy_from_user(ctl, buf, count))\n\t\treturn -efault;\n\n\tmutex_lock(&show_mutex);\n\tswitch (ctl[0]) {\n\tcase '0':\n\t\tif (timer_stats_active) {\n\t\t\ttimer_stats_active = 0;\n\t\t\ttime_stop = ktime_get();\n\t\t\tsync_access();\n\t\t}\n\t\tbreak;\n\tcase '1':\n\t\tif (!timer_stats_active) {\n\t\t\treset_entries();\n\t\t\ttime_start = ktime_get();\n\t\t\tsmp_mb();\n\t\t\ttimer_stats_active = 1;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tcount = -einval;\n\t}\n\tmutex_unlock(&show_mutex);\n\n\treturn count;\n}\n\nstatic int tstats_open(struct inode *inode, struct file *filp)\n{\n\treturn single_open(filp, tstats_show, null);\n}\n\nstatic const struct file_operations tstats_fops = {\n\t.open\t\t= tstats_open,\n\t.read\t\t= seq_read,\n\t.write\t\t= tstats_write,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nvoid __init init_timer_stats(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\traw_spin_lock_init(&per_cpu(tstats_lookup_lock, cpu));\n}\n\nstatic int __init init_tstats_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create(\"", "1143": "\", field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nstatic enum print_line_t trace_print_raw(struct trace_iterator *iter, int flags,\n\t\t\t\t\t struct trace_event *event)\n{\n\tstruct print_entry *field;\n\n\ttrace_assign_type(field, iter->ent);\n\n\ttrace_seq_printf(&iter->seq, \"", "1144": "\", field->ip);\n\ttrace_seq_bprintf(s, field->fmt, field->buf);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_bprint_funcs = {\n\t.trace\t\t= trace_bprint_print,\n\t.raw\t\t= trace_bprint_raw,\n};\n\nstatic struct trace_event trace_bprint_event = {\n\t.type\t\t= trace_bprint,\n\t.funcs\t\t= &trace_bprint_funcs,\n};\n\n\nstatic enum print_line_t trace_print_print(struct trace_iterator *iter,\n\t\t\t\t\t   int flags, struct trace_event *event)\n{\n\tstruct print_entry *field;\n\tstruct trace_seq *s = &iter->seq;\n\n\ttrace_assign_type(field, iter->ent);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_printf(s, \"", "1145": "\", field->ip);\n\ttrace_seq_puts(s, field->str);\n\n\treturn trace_handle_return(s);\n}\n\nstatic struct trace_event_functions trace_bputs_funcs = {\n\t.trace\t\t= trace_bputs_print,\n\t.raw\t\t= trace_bputs_raw,\n};\n\nstatic struct trace_event trace_bputs_event = {\n\t.type\t\t= trace_bputs,\n\t.funcs\t\t= &trace_bputs_funcs,\n};\n\n\nstatic enum print_line_t\ntrace_bprint_print(struct trace_iterator *iter, int flags,\n\t\t   struct trace_event *event)\n{\n\tstruct trace_entry *entry = iter->ent;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct bprint_entry *field;\n\n\ttrace_assign_type(field, entry);\n\n\tseq_print_ip_sym(s, field->ip, flags);\n\ttrace_seq_puts(s, \"", "1146": "\", field->ip, field->buf);\n\n\treturn trace_handle_return(&iter->seq);\n}\n\nstatic struct trace_event_functions trace_print_funcs = {\n\t.trace\t\t= trace_print_print,\n\t.raw\t\t= trace_print_raw,\n};\n\nstatic struct trace_event trace_print_event = {\n\t.type\t \t= trace_print,\n\t.funcs\t\t= &trace_print_funcs,\n};\n\n\nstatic struct trace_event *events[] __initdata = {\n\t&trace_fn_event,\n\t&trace_ctx_event,\n\t&trace_wake_event,\n\t&trace_stack_event,\n\t&trace_user_stack_event,\n\t&trace_bputs_event,\n\t&trace_bprint_event,\n\t&trace_print_event,\n\tnull\n};\n\n__init static int init_events(void)\n{\n\tstruct trace_event *event;\n\tint i, ret;\n\n\tfor (i = 0; events[i]; i++) {\n\t\tevent = events[i];\n\n\t\tret = register_ftrace_event(event);\n\t\tif (!ret) {\n\t\t\tprintk(kern_warning \"", "1147": "\", file, line);\n\tdump_invalid_creds(cred, \"", "1148": "\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"", "1149": "\", func);\n\t}\n}\n#endif \n\nvoid __init\nftrace_set_early_filter(struct ftrace_ops *ops, char *buf, int enable)\n{\n\tchar *func;\n\n\tftrace_ops_init(ops);\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \"", "1150": "\", hotcpu);\n\t\t\t\tmutex_unlock(&relay_channels_mutex);\n\t\t\t\treturn notifier_from_errno(-enomem);\n\t\t\t}\n\t\t}\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\tbreak;\n\tcase cpu_dead:\n\tcase cpu_dead_frozen:\n\t\t\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\n\nstruct rchan *relay_open(const char *base_filename,\n\t\t\t struct dentry *parent,\n\t\t\t size_t subbuf_size,\n\t\t\t size_t n_subbufs,\n\t\t\t struct rchan_callbacks *cb,\n\t\t\t void *private_data)\n{\n\tunsigned int i;\n\tstruct rchan *chan;\n\n\tif (!(subbuf_size && n_subbufs))\n\t\treturn null;\n\tif (subbuf_size > uint_max / n_subbufs)\n\t\treturn null;\n\n\tchan = kzalloc(sizeof(struct rchan), gfp_kernel);\n\tif (!chan)\n\t\treturn null;\n\n\tchan->version = relayfs_channel_version;\n\tchan->n_subbufs = n_subbufs;\n\tchan->subbuf_size = subbuf_size;\n\tchan->alloc_size = page_align(subbuf_size * n_subbufs);\n\tchan->parent = parent;\n\tchan->private_data = private_data;\n\tif (base_filename) {\n\t\tchan->has_base_filename = 1;\n\t\tstrlcpy(chan->base_filename, base_filename, name_max);\n\t}\n\tsetup_callbacks(chan, cb);\n\tkref_init(&chan->kref);\n\n\tmutex_lock(&relay_channels_mutex);\n\tfor_each_online_cpu(i) {\n\t\tchan->buf[i] = relay_open_buf(chan, i);\n\t\tif (!chan->buf[i])\n\t\t\tgoto free_bufs;\n\t}\n\tlist_add(&chan->list, &relay_channels);\n\tmutex_unlock(&relay_channels_mutex);\n\n\treturn chan;\n\nfree_bufs:\n\tfor_each_possible_cpu(i) {\n\t\tif (chan->buf[i])\n\t\t\trelay_close_buf(chan->buf[i]);\n\t}\n\n\tkref_put(&chan->kref, relay_destroy_channel);\n\tmutex_unlock(&relay_channels_mutex);\n\treturn null;\n}\nexport_symbol_gpl(relay_open);\n\nstruct rchan_percpu_buf_dispatcher {\n\tstruct rchan_buf *buf;\n\tstruct dentry *dentry;\n};\n\n\nstatic void __relay_set_buf_dentry(void *info)\n{\n\tstruct rchan_percpu_buf_dispatcher *p = info;\n\n\trelay_set_buf_dentry(p->buf, p->dentry);\n}\n\n\nint relay_late_setup_files(struct rchan *chan,\n\t\t\t   const char *base_filename,\n\t\t\t   struct dentry *parent)\n{\n\tint err = 0;\n\tunsigned int i, curr_cpu;\n\tunsigned long flags;\n\tstruct dentry *dentry;\n\tstruct rchan_percpu_buf_dispatcher disp;\n\n\tif (!chan || !base_filename)\n\t\treturn -einval;\n\n\tstrlcpy(chan->base_filename, base_filename, name_max);\n\n\tmutex_lock(&relay_channels_mutex);\n\t\n\tif (unlikely(chan->has_base_filename)) {\n\t\tmutex_unlock(&relay_channels_mutex);\n\t\treturn -eexist;\n\t}\n\tchan->has_base_filename = 1;\n\tchan->parent = parent;\n\tcurr_cpu = get_cpu();\n\t\n\tfor_each_online_cpu(i) {\n\t\tif (unlikely(!chan->buf[i])) {\n\t\t\twarn_once(1, kern_err \"", "1151": "\", hrtimer_max_clock_bases);\n\tseq_printf(m, \"", "1152": "\", hwirq);\n\n\t\t\tchip = irq_desc_get_chip(desc);\n\t\t\tseq_printf(m, \"", "1153": "\", i ? \"", "1154": "\", i);\n\t\t\tseq_printf(m, \"", "1155": "\", i, funcs[i].func);\n}\n\nstatic struct tracepoint_func *func_add(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0;\n\tstruct tracepoint_func *old, *new;\n\n\tif (warn_on(!tp_func->func))\n\t\treturn err_ptr(-einval);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++)\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t    old[nr_probes].data == tp_func->data)\n\t\t\t\treturn err_ptr(-eexist);\n\t}\n\t\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == null)\n\t\treturn err_ptr(-enomem);\n\tif (old)\n\t\tmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\n\tnew[nr_probes] = *tp_func;\n\tnew[nr_probes + 1].func = null;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn err_ptr(-enoent);\n\n\tdebug_print_probes(*funcs);\n\t\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t\n\tif (nr_probes - nr_del == 0) {\n\t\t\n\t\t*funcs = null;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t\n\t\t\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new == null)\n\t\t\treturn err_ptr(-enomem);\n\t\tfor (i = 0; old[i].func; i++)\n\t\t\tif (old[i].func != tp_func->func\n\t\t\t\t\t|| old[i].data != tp_func->data)\n\t\t\t\tnew[j++] = old[i];\n\t\tnew[nr_probes - nr_del].func = null;\n\t\t*funcs = new;\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}\n\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key))\n\t\ttp->regfunc();\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func);\n\tif (is_err(old)) {\n\t\twarn_on_once(1);\n\t\treturn ptr_err(old);\n\t}\n\n\t\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}\n\n\nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (is_err(old)) {\n\t\twarn_on_once(1);\n\t\treturn ptr_err(old);\n\t}\n\n\tif (!tp_funcs) {\n\t\t\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tif (static_key_enabled(&tp->key))\n\t\t\tstatic_key_slow_dec(&tp->key);\n\t}\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\trelease_probes(old);\n\treturn 0;\n}\n\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_add_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nexport_symbol_gpl(tracepoint_probe_register);\n\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}\nexport_symbol_gpl(tracepoint_probe_unregister);\n\n#ifdef config_modules\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << taint_oot_module) | (1 << taint_crap) |\n\t\t\t       (1 << taint_unsigned_module));\n}\n\nstatic blocking_notifier_head(tracepoint_notify_list);\n\n\nint register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, module_state_coming, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}\nexport_symbol_gpl(register_tracepoint_module_notifier);\n\n\nint unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, module_state_going, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}\nexport_symbol_gpl(unregister_tracepoint_module_notifier);\n\n\nstatic void tp_module_going_check_quiescent(struct tracepoint * const *begin,\n\t\tstruct tracepoint * const *end)\n{\n\tstruct tracepoint * const *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\twarn_on_once((*iter)->funcs);\n}\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), gfp_kernel);\n\tif (!tp_mod) {\n\t\tret = -enomem;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tmodule_state_coming, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tmodule_state_going, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t\n\t\t\ttp_module_going_check_quiescent(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints);\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}\n\nstatic int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase module_state_coming:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase module_state_live:\n\t\tbreak;\n\tcase module_state_going:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase module_state_unformed:\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\nstatic struct notifier_block tracepoint_module_nb = {\n\t.notifier_call = tracepoint_module_notify,\n\t.priority = 0,\n};\n\nstatic __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warning(\"", "1156": "\", idx);\n\tprint_name_offset(m, taddr);\n\tseq_printf(m, \"", "1157": "\", ignore_loglevel_setup);\nmodule_param(ignore_loglevel, bool, s_irugo | s_iwusr);\nmodule_parm_desc(ignore_loglevel,\n\t\t \"", "1158": "\", irqclass);\n\tif (!save_trace(&next_root->trace))\n\t\treturn 0;\n\tprint_shortest_lock_dependencies(forwards_entry, next_root);\n\n\tprintk(\"", "1159": "\", irqclass);\n\tprint_lock_name(forwards_entry->class);\n\tprintk(\"", "1160": "\", irqclass);\n\tprintk(\"", "1161": "\", irqclass);\n\n\tprint_stack_trace(backwards_entry->class->usage_traces + bit1, 1);\n\n\tprintk(\"", "1162": "\", iter->trace->name);\n\t\t\tseq_puts(m, \"", "1163": "\", kdb_buffer);\n\t\telse\n\t\t\tpr_info(\"", "1164": "\", kdb_buffer);\n\t}\n\n\tif (kdb_state(pager)) {\n\t\t\n\t\tint got = 0;\n\t\tlen = retlen;\n\t\twhile (len--) {\n\t\t\tif (kdb_buffer[len] == '\\n') {\n\t\t\t\tkdb_nextline++;\n\t\t\t\tgot = 0;\n\t\t\t} else if (kdb_buffer[len] == '\\r') {\n\t\t\t\tgot = 0;\n\t\t\t} else {\n\t\t\t\tgot++;\n\t\t\t}\n\t\t}\n\t\tkdb_nextline += got / (colcount + 1);\n\t}\n\n\t\n\tif (kdb_nextline >= linecount) {\n\t\tchar buf1[16] = \"", "1165": "\", keep_bootcon_setup);\n\n\nvoid register_console(struct console *newcon)\n{\n\tint i;\n\tunsigned long flags;\n\tstruct console *bcon = null;\n\tstruct console_cmdline *c;\n\n\tif (console_drivers)\n\t\tfor_each_console(bcon)\n\t\t\tif (warn(bcon == newcon,\n\t\t\t\t\t\"", "1166": "\", key);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (lastchar - buffer >= 5 &&\n\t\t\t    strcmp(lastchar - 5, \"", "1167": "\", line);\n\tkfree(buf);\n\treturn ret;\n}\n\nstatic ssize_t devkmsg_read(struct file *file, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tstruct devkmsg_user *user = file->private_data;\n\tstruct printk_log *msg;\n\tu64 ts_usec;\n\tsize_t i;\n\tchar cont = '-';\n\tsize_t len;\n\tssize_t ret;\n\n\tif (!user)\n\t\treturn -ebadf;\n\n\tret = mutex_lock_interruptible(&user->lock);\n\tif (ret)\n\t\treturn ret;\n\traw_spin_lock_irq(&logbuf_lock);\n\twhile (user->seq == log_next_seq) {\n\t\tif (file->f_flags & o_nonblock) {\n\t\t\tret = -eagain;\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\tgoto out;\n\t\t}\n\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tret = wait_event_interruptible(log_wait,\n\t\t\t\t\t       user->seq != log_next_seq);\n\t\tif (ret)\n\t\t\tgoto out;\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t}\n\n\tif (user->seq < log_first_seq) {\n\t\t\n\t\tuser->idx = log_first_idx;\n\t\tuser->seq = log_first_seq;\n\t\tret = -epipe;\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tgoto out;\n\t}\n\n\tmsg = log_from_idx(user->idx);\n\tts_usec = msg->ts_nsec;\n\tdo_div(ts_usec, 1000);\n\n\t\n\tif (msg->flags & log_cont && !(user->prev & log_cont))\n\t\tcont = 'c';\n\telse if ((msg->flags & log_cont) ||\n\t\t ((user->prev & log_cont) && !(msg->flags & log_prefix)))\n\t\tcont = '+';\n\n\tlen = sprintf(user->buf, \"", "1168": "\", log_buf_len);\n\tpr_info(\"", "1169": "\", log_buf_len_setup);\n\n#ifdef config_smp\n#define __log_cpu_max_buf_len (1 << config_log_cpu_max_buf_shift)\n\nstatic void __init log_buf_add_cpu(void)\n{\n\tunsigned int cpu_extra;\n\n\t\n\tif (num_possible_cpus() == 1)\n\t\treturn;\n\n\tcpu_extra = (num_possible_cpus() - 1) * __log_cpu_max_buf_len;\n\n\t\n\tif (cpu_extra <= __log_buf_len / 2)\n\t\treturn;\n\n\tpr_info(\"", "1170": "\", max_lock_depth,\n\t\t\t       top_task->comm, task_pid_nr(top_task));\n\t\t}\n\t\tput_task_struct(task);\n\n\t\treturn -edeadlk;\n\t}\n\n\t\n retry:\n\t\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\t\n\twaiter = task->pi_blocked_on;\n\n\t\n\n\t\n\tif (!waiter)\n\t\tgoto out_unlock_pi;\n\n\t\n\tif (orig_waiter && !rt_mutex_owner(orig_lock))\n\t\tgoto out_unlock_pi;\n\n\t\n\tif (next_lock != waiter->lock)\n\t\tgoto out_unlock_pi;\n\n\t\n\tif (top_waiter) {\n\t\tif (!task_has_pi_waiters(task))\n\t\t\tgoto out_unlock_pi;\n\t\t\n\t\tif (top_waiter != task_top_pi_waiter(task)) {\n\t\t\tif (!detect_deadlock)\n\t\t\t\tgoto out_unlock_pi;\n\t\t\telse\n\t\t\t\trequeue = false;\n\t\t}\n\t}\n\n\t\n\tif (waiter->prio == task->prio) {\n\t\tif (!detect_deadlock)\n\t\t\tgoto out_unlock_pi;\n\t\telse\n\t\t\trequeue = false;\n\t}\n\n\t\n\tlock = waiter->lock;\n\t\n\tif (!raw_spin_trylock(&lock->wait_lock)) {\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\tcpu_relax();\n\t\tgoto retry;\n\t}\n\n\t\n\tif (lock == orig_lock || rt_mutex_owner(lock) == top_task) {\n\t\tdebug_rt_mutex_deadlock(chwalk, orig_waiter, lock);\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\tret = -edeadlk;\n\t\tgoto out_unlock_pi;\n\t}\n\n\t\n\tif (!requeue) {\n\t\t\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\tput_task_struct(task);\n\n\t\t\n\t\tif (!rt_mutex_owner(lock)) {\n\t\t\traw_spin_unlock(&lock->wait_lock);\n\t\t\treturn 0;\n\t\t}\n\n\t\t\n\t\ttask = rt_mutex_owner(lock);\n\t\tget_task_struct(task);\n\t\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\t\t\n\t\tnext_lock = task_blocked_on_lock(task);\n\t\t\n\t\ttop_waiter = rt_mutex_top_waiter(lock);\n\n\t\t\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\traw_spin_unlock(&lock->wait_lock);\n\n\t\t\n\t\tif (!next_lock)\n\t\t\tgoto out_put_task;\n\t\tgoto again;\n\t}\n\n\t\n\tprerequeue_top_waiter = rt_mutex_top_waiter(lock);\n\n\t\n\trt_mutex_dequeue(lock, waiter);\n\twaiter->prio = task->prio;\n\trt_mutex_enqueue(lock, waiter);\n\n\t\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\tput_task_struct(task);\n\n\t\n\tif (!rt_mutex_owner(lock)) {\n\t\t\n\t\tif (prerequeue_top_waiter != rt_mutex_top_waiter(lock))\n\t\t\twake_up_process(rt_mutex_top_waiter(lock)->task);\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\treturn 0;\n\t}\n\n\t\n\ttask = rt_mutex_owner(lock);\n\tget_task_struct(task);\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\t\n\tif (waiter == rt_mutex_top_waiter(lock)) {\n\t\t\n\t\trt_mutex_dequeue_pi(task, prerequeue_top_waiter);\n\t\trt_mutex_enqueue_pi(task, waiter);\n\t\t__rt_mutex_adjust_prio(task);\n\n\t} else if (prerequeue_top_waiter == waiter) {\n\t\t\n\t\trt_mutex_dequeue_pi(task, waiter);\n\t\twaiter = rt_mutex_top_waiter(lock);\n\t\trt_mutex_enqueue_pi(task, waiter);\n\t\t__rt_mutex_adjust_prio(task);\n\t} else {\n\t\t\n\t}\n\n\t\n\tnext_lock = task_blocked_on_lock(task);\n\t\n\ttop_waiter = rt_mutex_top_waiter(lock);\n\n\t\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\traw_spin_unlock(&lock->wait_lock);\n\n\t\n\tif (!next_lock)\n\t\tgoto out_put_task;\n\n\t\n\tif (!detect_deadlock && waiter != top_waiter)\n\t\tgoto out_put_task;\n\n\tgoto again;\n\n out_unlock_pi:\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n out_put_task:\n\tput_task_struct(task);\n\n\treturn ret;\n}\n\n\nstatic int try_to_take_rt_mutex(struct rt_mutex *lock, struct task_struct *task,\n\t\t\t\tstruct rt_mutex_waiter *waiter)\n{\n\tunsigned long flags;\n\n\t\n\tmark_rt_mutex_waiters(lock);\n\n\t\n\tif (rt_mutex_owner(lock))\n\t\treturn 0;\n\n\t\n\tif (waiter) {\n\t\t\n\t\tif (waiter != rt_mutex_top_waiter(lock))\n\t\t\treturn 0;\n\n\t\t\n\t\trt_mutex_dequeue(lock, waiter);\n\n\t} else {\n\t\t\n\t\tif (rt_mutex_has_waiters(lock)) {\n\t\t\t\n\t\t\tif (task->prio >= rt_mutex_top_waiter(lock)->prio)\n\t\t\t\treturn 0;\n\n\t\t\t\n\t\t} else {\n\t\t\t\n\t\t\tgoto takeit;\n\t\t}\n\t}\n\n\t\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\ttask->pi_blocked_on = null;\n\t\n\tif (rt_mutex_has_waiters(lock))\n\t\trt_mutex_enqueue_pi(task, rt_mutex_top_waiter(lock));\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\ntakeit:\n\t\n\tdebug_rt_mutex_lock(lock);\n\n\t\n\trt_mutex_set_owner(lock, task);\n\n\trt_mutex_deadlock_account_lock(lock, task);\n\n\treturn 1;\n}\n\n\nstatic int task_blocks_on_rt_mutex(struct rt_mutex *lock,\n\t\t\t\t   struct rt_mutex_waiter *waiter,\n\t\t\t\t   struct task_struct *task,\n\t\t\t\t   enum rtmutex_chainwalk chwalk)\n{\n\tstruct task_struct *owner = rt_mutex_owner(lock);\n\tstruct rt_mutex_waiter *top_waiter = waiter;\n\tstruct rt_mutex *next_lock;\n\tint chain_walk = 0, res;\n\tunsigned long flags;\n\n\t\n\tif (owner == task)\n\t\treturn -edeadlk;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\t__rt_mutex_adjust_prio(task);\n\twaiter->task = task;\n\twaiter->lock = lock;\n\twaiter->prio = task->prio;\n\n\t\n\tif (rt_mutex_has_waiters(lock))\n\t\ttop_waiter = rt_mutex_top_waiter(lock);\n\trt_mutex_enqueue(lock, waiter);\n\n\ttask->pi_blocked_on = waiter;\n\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\tif (!owner)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&owner->pi_lock, flags);\n\tif (waiter == rt_mutex_top_waiter(lock)) {\n\t\trt_mutex_dequeue_pi(owner, top_waiter);\n\t\trt_mutex_enqueue_pi(owner, waiter);\n\n\t\t__rt_mutex_adjust_prio(owner);\n\t\tif (owner->pi_blocked_on)\n\t\t\tchain_walk = 1;\n\t} else if (rt_mutex_cond_detect_deadlock(waiter, chwalk)) {\n\t\tchain_walk = 1;\n\t}\n\n\t\n\tnext_lock = task_blocked_on_lock(owner);\n\n\traw_spin_unlock_irqrestore(&owner->pi_lock, flags);\n\t\n\tif (!chain_walk || !next_lock)\n\t\treturn 0;\n\n\t\n\tget_task_struct(owner);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\tres = rt_mutex_adjust_prio_chain(owner, chwalk, lock,\n\t\t\t\t\t next_lock, waiter, task);\n\n\traw_spin_lock(&lock->wait_lock);\n\n\treturn res;\n}\n\n\nstatic void wakeup_next_waiter(struct rt_mutex *lock)\n{\n\tstruct rt_mutex_waiter *waiter;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\n\twaiter = rt_mutex_top_waiter(lock);\n\n\t\n\trt_mutex_dequeue_pi(current, waiter);\n\n\t\n\tlock->owner = (void *) rt_mutex_has_waiters;\n\n\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\n\t\n\twake_up_process(waiter->task);\n}\n\n\nstatic void remove_waiter(struct rt_mutex *lock,\n\t\t\t  struct rt_mutex_waiter *waiter)\n{\n\tbool is_top_waiter = (waiter == rt_mutex_top_waiter(lock));\n\tstruct task_struct *owner = rt_mutex_owner(lock);\n\tstruct rt_mutex *next_lock;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&current->pi_lock, flags);\n\trt_mutex_dequeue(lock, waiter);\n\tcurrent->pi_blocked_on = null;\n\traw_spin_unlock_irqrestore(&current->pi_lock, flags);\n\n\t\n\tif (!owner || !is_top_waiter)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&owner->pi_lock, flags);\n\n\trt_mutex_dequeue_pi(owner, waiter);\n\n\tif (rt_mutex_has_waiters(lock))\n\t\trt_mutex_enqueue_pi(owner, rt_mutex_top_waiter(lock));\n\n\t__rt_mutex_adjust_prio(owner);\n\n\t\n\tnext_lock = task_blocked_on_lock(owner);\n\n\traw_spin_unlock_irqrestore(&owner->pi_lock, flags);\n\n\t\n\tif (!next_lock)\n\t\treturn;\n\n\t\n\tget_task_struct(owner);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\trt_mutex_adjust_prio_chain(owner, rt_mutex_min_chainwalk, lock,\n\t\t\t\t   next_lock, null, current);\n\n\traw_spin_lock(&lock->wait_lock);\n}\n\n\nvoid rt_mutex_adjust_pi(struct task_struct *task)\n{\n\tstruct rt_mutex_waiter *waiter;\n\tstruct rt_mutex *next_lock;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&task->pi_lock, flags);\n\n\twaiter = task->pi_blocked_on;\n\tif (!waiter || (waiter->prio == task->prio &&\n\t\t\t!dl_prio(task->prio))) {\n\t\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\t\treturn;\n\t}\n\tnext_lock = waiter->lock;\n\traw_spin_unlock_irqrestore(&task->pi_lock, flags);\n\n\t\n\tget_task_struct(task);\n\n\trt_mutex_adjust_prio_chain(task, rt_mutex_min_chainwalk, null,\n\t\t\t\t   next_lock, null, task);\n}\n\n\nstatic int __sched\n__rt_mutex_slowlock(struct rt_mutex *lock, int state,\n\t\t    struct hrtimer_sleeper *timeout,\n\t\t    struct rt_mutex_waiter *waiter)\n{\n\tint ret = 0;\n\n\tfor (;;) {\n\t\t\n\t\tif (try_to_take_rt_mutex(lock, current, waiter))\n\t\t\tbreak;\n\n\t\t\n\t\tif (unlikely(state == task_interruptible)) {\n\t\t\t\n\t\t\tif (signal_pending(current))\n\t\t\t\tret = -eintr;\n\t\t\tif (timeout && !timeout->task)\n\t\t\t\tret = -etimedout;\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\t}\n\n\t\traw_spin_unlock(&lock->wait_lock);\n\n\t\tdebug_rt_mutex_print_deadlock(waiter);\n\n\t\tschedule_rt_mutex(lock);\n\n\t\traw_spin_lock(&lock->wait_lock);\n\t\tset_current_state(state);\n\t}\n\n\t__set_current_state(task_running);\n\treturn ret;\n}\n\nstatic void rt_mutex_handle_deadlock(int res, int detect_deadlock,\n\t\t\t\t     struct rt_mutex_waiter *w)\n{\n\t\n\tif (res != -edeadlock || detect_deadlock)\n\t\treturn;\n\n\t\n\trt_mutex_print_deadlock(w);\n\twhile (1) {\n\t\tset_current_state(task_interruptible);\n\t\tschedule();\n\t}\n}\n\n\nstatic int __sched\nrt_mutex_slowlock(struct rt_mutex *lock, int state,\n\t\t  struct hrtimer_sleeper *timeout,\n\t\t  enum rtmutex_chainwalk chwalk)\n{\n\tstruct rt_mutex_waiter waiter;\n\tint ret = 0;\n\n\tdebug_rt_mutex_init_waiter(&waiter);\n\trb_clear_node(&waiter.pi_tree_entry);\n\trb_clear_node(&waiter.tree_entry);\n\n\traw_spin_lock(&lock->wait_lock);\n\n\t\n\tif (try_to_take_rt_mutex(lock, current, null)) {\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\treturn 0;\n\t}\n\n\tset_current_state(state);\n\n\t\n\tif (unlikely(timeout)) {\n\t\thrtimer_start_expires(&timeout->timer, hrtimer_mode_abs);\n\t\tif (!hrtimer_active(&timeout->timer))\n\t\t\ttimeout->task = null;\n\t}\n\n\tret = task_blocks_on_rt_mutex(lock, &waiter, current, chwalk);\n\n\tif (likely(!ret))\n\t\t\n\t\tret = __rt_mutex_slowlock(lock, state, timeout, &waiter);\n\n\tif (unlikely(ret)) {\n\t\t__set_current_state(task_running);\n\t\tif (rt_mutex_has_waiters(lock))\n\t\t\tremove_waiter(lock, &waiter);\n\t\trt_mutex_handle_deadlock(ret, chwalk, &waiter);\n\t}\n\n\t\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\t\n\tif (unlikely(timeout))\n\t\thrtimer_cancel(&timeout->timer);\n\n\tdebug_rt_mutex_free_waiter(&waiter);\n\n\treturn ret;\n}\n\n\nstatic inline int rt_mutex_slowtrylock(struct rt_mutex *lock)\n{\n\tint ret;\n\n\t\n\tif (rt_mutex_owner(lock))\n\t\treturn 0;\n\n\t\n\traw_spin_lock(&lock->wait_lock);\n\n\tret = try_to_take_rt_mutex(lock, current, null);\n\n\t\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\treturn ret;\n}\n\n\nstatic void __sched\nrt_mutex_slowunlock(struct rt_mutex *lock)\n{\n\traw_spin_lock(&lock->wait_lock);\n\n\tdebug_rt_mutex_unlock(lock);\n\n\trt_mutex_deadlock_account_unlock(current);\n\n\t\n\twhile (!rt_mutex_has_waiters(lock)) {\n\t\t\n\t\tif (unlock_rt_mutex_safe(lock) == true)\n\t\t\treturn;\n\t\t\n\t\traw_spin_lock(&lock->wait_lock);\n\t}\n\n\t\n\twakeup_next_waiter(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\t\n\trt_mutex_adjust_prio(current);\n}\n\n\nstatic inline int\nrt_mutex_fastlock(struct rt_mutex *lock, int state,\n\t\t  int (*slowfn)(struct rt_mutex *lock, int state,\n\t\t\t\tstruct hrtimer_sleeper *timeout,\n\t\t\t\tenum rtmutex_chainwalk chwalk))\n{\n\tif (likely(rt_mutex_cmpxchg(lock, null, current))) {\n\t\trt_mutex_deadlock_account_lock(lock, current);\n\t\treturn 0;\n\t} else\n\t\treturn slowfn(lock, state, null, rt_mutex_min_chainwalk);\n}\n\nstatic inline int\nrt_mutex_timed_fastlock(struct rt_mutex *lock, int state,\n\t\t\tstruct hrtimer_sleeper *timeout,\n\t\t\tenum rtmutex_chainwalk chwalk,\n\t\t\tint (*slowfn)(struct rt_mutex *lock, int state,\n\t\t\t\t      struct hrtimer_sleeper *timeout,\n\t\t\t\t      enum rtmutex_chainwalk chwalk))\n{\n\tif (chwalk == rt_mutex_min_chainwalk &&\n\t    likely(rt_mutex_cmpxchg(lock, null, current))) {\n\t\trt_mutex_deadlock_account_lock(lock, current);\n\t\treturn 0;\n\t} else\n\t\treturn slowfn(lock, state, timeout, chwalk);\n}\n\nstatic inline int\nrt_mutex_fasttrylock(struct rt_mutex *lock,\n\t\t     int (*slowfn)(struct rt_mutex *lock))\n{\n\tif (likely(rt_mutex_cmpxchg(lock, null, current))) {\n\t\trt_mutex_deadlock_account_lock(lock, current);\n\t\treturn 1;\n\t}\n\treturn slowfn(lock);\n}\n\nstatic inline void\nrt_mutex_fastunlock(struct rt_mutex *lock,\n\t\t    void (*slowfn)(struct rt_mutex *lock))\n{\n\tif (likely(rt_mutex_cmpxchg(lock, current, null)))\n\t\trt_mutex_deadlock_account_unlock(current);\n\telse\n\t\tslowfn(lock);\n}\n\n\nvoid __sched rt_mutex_lock(struct rt_mutex *lock)\n{\n\tmight_sleep();\n\n\trt_mutex_fastlock(lock, task_uninterruptible, rt_mutex_slowlock);\n}\nexport_symbol_gpl(rt_mutex_lock);\n\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tmight_sleep();\n\n\treturn rt_mutex_fastlock(lock, task_interruptible, rt_mutex_slowlock);\n}\nexport_symbol_gpl(rt_mutex_lock_interruptible);\n\n\nint rt_mutex_timed_futex_lock(struct rt_mutex *lock,\n\t\t\t      struct hrtimer_sleeper *timeout)\n{\n\tmight_sleep();\n\n\treturn rt_mutex_timed_fastlock(lock, task_interruptible, timeout,\n\t\t\t\t       rt_mutex_full_chainwalk,\n\t\t\t\t       rt_mutex_slowlock);\n}\n\n\nint\nrt_mutex_timed_lock(struct rt_mutex *lock, struct hrtimer_sleeper *timeout)\n{\n\tmight_sleep();\n\n\treturn rt_mutex_timed_fastlock(lock, task_interruptible, timeout,\n\t\t\t\t       rt_mutex_min_chainwalk,\n\t\t\t\t       rt_mutex_slowlock);\n}\nexport_symbol_gpl(rt_mutex_timed_lock);\n\n\nint __sched rt_mutex_trylock(struct rt_mutex *lock)\n{\n\treturn rt_mutex_fasttrylock(lock, rt_mutex_slowtrylock);\n}\nexport_symbol_gpl(rt_mutex_trylock);\n\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}\nexport_symbol_gpl(rt_mutex_unlock);\n\n\nvoid rt_mutex_destroy(struct rt_mutex *lock)\n{\n\twarn_on(rt_mutex_is_locked(lock));\n#ifdef config_debug_rt_mutexes\n\tlock->magic = null;\n#endif\n}\n\nexport_symbol_gpl(rt_mutex_destroy);\n\n\nvoid __rt_mutex_init(struct rt_mutex *lock, const char *name)\n{\n\tlock->owner = null;\n\traw_spin_lock_init(&lock->wait_lock);\n\tlock->waiters = rb_root;\n\tlock->waiters_leftmost = null;\n\n\tdebug_rt_mutex_init(lock, name);\n}\nexport_symbol_gpl(__rt_mutex_init);\n\n\nvoid rt_mutex_init_proxy_locked(struct rt_mutex *lock,\n\t\t\t\tstruct task_struct *proxy_owner)\n{\n\t__rt_mutex_init(lock, null);\n\tdebug_rt_mutex_proxy_lock(lock, proxy_owner);\n\trt_mutex_set_owner(lock, proxy_owner);\n\trt_mutex_deadlock_account_lock(lock, proxy_owner);\n}\n\n\nvoid rt_mutex_proxy_unlock(struct rt_mutex *lock,\n\t\t\t   struct task_struct *proxy_owner)\n{\n\tdebug_rt_mutex_proxy_unlock(lock);\n\trt_mutex_set_owner(lock, null);\n\trt_mutex_deadlock_account_unlock(proxy_owner);\n}\n\n\nint rt_mutex_start_proxy_lock(struct rt_mutex *lock,\n\t\t\t      struct rt_mutex_waiter *waiter,\n\t\t\t      struct task_struct *task)\n{\n\tint ret;\n\n\traw_spin_lock(&lock->wait_lock);\n\n\tif (try_to_take_rt_mutex(lock, task, null)) {\n\t\traw_spin_unlock(&lock->wait_lock);\n\t\treturn 1;\n\t}\n\n\t\n\tret = task_blocks_on_rt_mutex(lock, waiter, task,\n\t\t\t\t      rt_mutex_full_chainwalk);\n\n\tif (ret && !rt_mutex_owner(lock)) {\n\t\t\n\t\tret = 0;\n\t}\n\n\tif (unlikely(ret))\n\t\tremove_waiter(lock, waiter);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\tdebug_rt_mutex_print_deadlock(waiter);\n\n\treturn ret;\n}\n\n\nstruct task_struct *rt_mutex_next_owner(struct rt_mutex *lock)\n{\n\tif (!rt_mutex_has_waiters(lock))\n\t\treturn null;\n\n\treturn rt_mutex_top_waiter(lock)->task;\n}\n\n\nint rt_mutex_finish_proxy_lock(struct rt_mutex *lock,\n\t\t\t       struct hrtimer_sleeper *to,\n\t\t\t       struct rt_mutex_waiter *waiter)\n{\n\tint ret;\n\n\traw_spin_lock(&lock->wait_lock);\n\n\tset_current_state(task_interruptible);\n\n\t\n\tret = __rt_mutex_slowlock(lock, task_interruptible, to, waiter);\n\n\tif (unlikely(ret))\n\t\tremove_waiter(lock, waiter);\n\n\t\n\tfixup_rt_mutex_waiters(lock);\n\n\traw_spin_unlock(&lock->wait_lock);\n\n\treturn ret;\n}\n\n#include <linux/clocksource.h>\n#include <linux/init.h>\n#include <linux/jiffies.h>\n#include <linux/ktime.h>\n#include <linux/kernel.h>\n#include <linux/moduleparam.h>\n#include <linux/sched.h>\n#include <linux/syscore_ops.h>\n#include <linux/hrtimer.h>\n#include <linux/sched_clock.h>\n#include <linux/seqlock.h>\n#include <linux/bitops.h>\n\n\nstruct clock_read_data {\n\tu64 epoch_ns;\n\tu64 epoch_cyc;\n\tu64 sched_clock_mask;\n\tu64 (*read_sched_clock)(void);\n\tu32 mult;\n\tu32 shift;\n};\n\n\nstruct clock_data {\n\tseqcount_t\t\tseq;\n\tstruct clock_read_data\tread_data[2];\n\tktime_t\t\t\twrap_kt;\n\tunsigned long\t\trate;\n\n\tu64 (*actual_read_sched_clock)(void);\n};\n\nstatic struct hrtimer sched_clock_timer;\nstatic int irqtime = -1;\n\ncore_param(irqtime, irqtime, int, 0400);\n\nstatic u64 notrace jiffy_sched_clock_read(void)\n{\n\t\n\treturn (u64)(jiffies - initial_jiffies);\n}\n\nstatic struct clock_data cd ____cacheline_aligned = {\n\t.read_data[0] = { .mult = nsec_per_sec / hz,\n\t\t\t  .read_sched_clock = jiffy_sched_clock_read, },\n\t.actual_read_sched_clock = jiffy_sched_clock_read,\n};\n\nstatic inline u64 notrace cyc_to_ns(u64 cyc, u32 mult, u32 shift)\n{\n\treturn (cyc * mult) >> shift;\n}\n\nunsigned long long notrace sched_clock(void)\n{\n\tu64 cyc, res;\n\tunsigned long seq;\n\tstruct clock_read_data *rd;\n\n\tdo {\n\t\tseq = raw_read_seqcount(&cd.seq);\n\t\trd = cd.read_data + (seq & 1);\n\n\t\tcyc = (rd->read_sched_clock() - rd->epoch_cyc) &\n\t\t      rd->sched_clock_mask;\n\t\tres = rd->epoch_ns + cyc_to_ns(cyc, rd->mult, rd->shift);\n\t} while (read_seqcount_retry(&cd.seq, seq));\n\n\treturn res;\n}\n\n\nstatic void update_clock_read_data(struct clock_read_data *rd)\n{\n\t\n\tcd.read_data[1] = *rd;\n\n\t\n\traw_write_seqcount_latch(&cd.seq);\n\n\t\n\tcd.read_data[0] = *rd;\n\n\t\n\traw_write_seqcount_latch(&cd.seq);\n}\n\n\nstatic void update_sched_clock(void)\n{\n\tu64 cyc;\n\tu64 ns;\n\tstruct clock_read_data rd;\n\n\trd = cd.read_data[0];\n\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\n\trd.epoch_ns = ns;\n\trd.epoch_cyc = cyc;\n\n\tupdate_clock_read_data(&rd);\n}\n\nstatic enum hrtimer_restart sched_clock_poll(struct hrtimer *hrt)\n{\n\tupdate_sched_clock();\n\thrtimer_forward_now(hrt, cd.wrap_kt);\n\n\treturn hrtimer_restart;\n}\n\nvoid __init\nsched_clock_register(u64 (*read)(void), int bits, unsigned long rate)\n{\n\tu64 res, wrap, new_mask, new_epoch, cyc, ns;\n\tu32 new_mult, new_shift;\n\tunsigned long r;\n\tchar r_unit;\n\tstruct clock_read_data rd;\n\n\tif (cd.rate > rate)\n\t\treturn;\n\n\twarn_on(!irqs_disabled());\n\n\t\n\tclocks_calc_mult_shift(&new_mult, &new_shift, rate, nsec_per_sec, 3600);\n\n\tnew_mask = clocksource_mask(bits);\n\tcd.rate = rate;\n\n\t\n\twrap = clocks_calc_max_nsecs(new_mult, new_shift, 0, new_mask, null);\n\tcd.wrap_kt = ns_to_ktime(wrap);\n\n\trd = cd.read_data[0];\n\n\t\n\tnew_epoch = read();\n\tcyc = cd.actual_read_sched_clock();\n\tns = rd.epoch_ns + cyc_to_ns((cyc - rd.epoch_cyc) & rd.sched_clock_mask, rd.mult, rd.shift);\n\tcd.actual_read_sched_clock = read;\n\n\trd.read_sched_clock\t= read;\n\trd.sched_clock_mask\t= new_mask;\n\trd.mult\t\t\t= new_mult;\n\trd.shift\t\t= new_shift;\n\trd.epoch_cyc\t\t= new_epoch;\n\trd.epoch_ns\t\t= ns;\n\n\tupdate_clock_read_data(&rd);\n\n\tr = rate;\n\tif (r >= 4000000) {\n\t\tr /= 1000000;\n\t\tr_unit = 'm';\n\t} else {\n\t\tif (r >= 1000) {\n\t\t\tr /= 1000;\n\t\t\tr_unit = 'k';\n\t\t} else {\n\t\t\tr_unit = ' ';\n\t\t}\n\t}\n\n\t\n\tres = cyc_to_ns(1ull, new_mult, new_shift);\n\n\tpr_info(\"", "1171": "\", moreprompt);\n\n\t\tkdb_read(buf1, 2); \n\t\tkdb_nextline = 1;\t\n\n\t\t\n\t\tkdb_buffer[0] = '\\0';\n\t\tnext_avail = kdb_buffer;\n\t\tsize_avail = sizeof(kdb_buffer);\n\t\tif ((buf1[0] == 'q') || (buf1[0] == 'q')) {\n\t\t\t\n\t\t\tkdb_flag_set(cmd_interrupt); \n\t\t\tkdb_state_clear(pager);\n\t\t\t\n\t\t\tkdb_grepping_flag = 0;\n\t\t\tkdb_printf(\"", "1172": "\", name);\n\n\treturn ret;\n}\n\n\nstatic struct dentry *trace_options_init_dentry(struct trace_array *tr)\n{\n\tstruct dentry *d_tracer;\n\n\tif (tr->options)\n\t\treturn tr->options;\n\n\td_tracer = tracing_get_dentry(tr);\n\tif (is_err(d_tracer))\n\t\treturn null;\n\n\ttr->options = tracefs_create_dir(\"", "1173": "\", null };\nconst char *pm_states[pm_suspend_max];\n\nstatic const struct platform_suspend_ops *suspend_ops;\nstatic const struct platform_freeze_ops *freeze_ops;\nstatic declare_wait_queue_head(suspend_freeze_wait_head);\n\nenum freeze_state __read_mostly suspend_freeze_state;\nstatic define_spinlock(suspend_freeze_lock);\n\nvoid freeze_set_ops(const struct platform_freeze_ops *ops)\n{\n\tlock_system_sleep();\n\tfreeze_ops = ops;\n\tunlock_system_sleep();\n}\n\nstatic void freeze_begin(void)\n{\n\tsuspend_freeze_state = freeze_state_none;\n}\n\nstatic void freeze_enter(void)\n{\n\tspin_lock_irq(&suspend_freeze_lock);\n\tif (pm_wakeup_pending())\n\t\tgoto out;\n\n\tsuspend_freeze_state = freeze_state_enter;\n\tspin_unlock_irq(&suspend_freeze_lock);\n\n\tget_online_cpus();\n\tcpuidle_resume();\n\n\t\n\twake_up_all_idle_cpus();\n\tpr_debug(\"", "1174": "\", null);\n\tif (!rcudir)\n\t\tgoto free_out;\n\tretval = debugfs_create_file(\"", "1175": "\", null);\n\tput_filesystem(type);\n\tif (is_err(mnt))\n\t\treturn null;\n\tmntget(mnt);\n\n\treturn mnt;\n}\n\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t\n\tif (tr->dir)\n\t\treturn null;\n\n\tif (warn_on(!debugfs_initialized()))\n\t\treturn err_ptr(-enodev);\n\n\t\n\ttr->dir = debugfs_create_automount(\"", "1176": "\", null,\n\t\t\t\t\t   trace_automount, null);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"", "1177": "\", num_online_cpus());\n#else\n\tseq_puts(m, \"", "1178": "\", p_tmp);\n\t\t\t\t*(p_tmp + len) = '\\0';\n\t\t\t}\n\t\t\tif (i >= dtab_count)\n\t\t\t\tkdb_printf(\"", "1179": "\", per_cpu_ptr(tr->trace_buffer.data, cpu)->entries >> 10);\n\n\tmutex_unlock(&trace_types_lock);\n\n\tret = simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_entries_write(struct file *filp, const char __user *ubuf,\n\t\t      size_t cnt, loff_t *ppos)\n{\n\tstruct inode *inode = file_inode(filp);\n\tstruct trace_array *tr = inode->i_private;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\tif (!val)\n\t\treturn -einval;\n\n\t\n\tval <<= 10;\n\tret = tracing_resize_ring_buffer(tr, val, tracing_get_cpu(inode));\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\ntracing_total_entries_read(struct file *filp, char __user *ubuf,\n\t\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[64];\n\tint r, cpu;\n\tunsigned long size = 0, expanded_size = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tfor_each_tracing_cpu(cpu) {\n\t\tsize += per_cpu_ptr(tr->trace_buffer.data, cpu)->entries >> 10;\n\t\tif (!ring_buffer_expanded)\n\t\t\texpanded_size += trace_buf_size >> 10;\n\t}\n\tif (ring_buffer_expanded)\n\t\tr = sprintf(buf, \"", "1180": "\", perf_type_breakpoint);\n\n\treturn register_die_notifier(&hw_breakpoint_exceptions_nb);\n\n err_alloc:\n\tfor_each_possible_cpu(err_cpu) {\n\t\tfor (i = 0; i < type_max; i++)\n\t\t\tkfree(get_bp_info(err_cpu, i)->tsk_pinned);\n\t\tif (err_cpu == cpu)\n\t\t\tbreak;\n\t}\n\n\treturn -enomem;\n}\n\n\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/device.h>\n#include <linux/gfp.h>\n\n\nstruct irq_devres {\n\tunsigned int irq;\n\tvoid *dev_id;\n};\n\nstatic void devm_irq_release(struct device *dev, void *res)\n{\n\tstruct irq_devres *this = res;\n\n\tfree_irq(this->irq, this->dev_id);\n}\n\nstatic int devm_irq_match(struct device *dev, void *res, void *data)\n{\n\tstruct irq_devres *this = res, *match = data;\n\n\treturn this->irq == match->irq && this->dev_id == match->dev_id;\n}\n\n\nint devm_request_threaded_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, irq_handler_t thread_fn,\n\t\t\t      unsigned long irqflags, const char *devname,\n\t\t\t      void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  gfp_kernel);\n\tif (!dr)\n\t\treturn -enomem;\n\n\trc = request_threaded_irq(irq, handler, thread_fn, irqflags, devname,\n\t\t\t\t  dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nexport_symbol(devm_request_threaded_irq);\n\n\nint devm_request_any_context_irq(struct device *dev, unsigned int irq,\n\t\t\t      irq_handler_t handler, unsigned long irqflags,\n\t\t\t      const char *devname, void *dev_id)\n{\n\tstruct irq_devres *dr;\n\tint rc;\n\n\tdr = devres_alloc(devm_irq_release, sizeof(struct irq_devres),\n\t\t\t  gfp_kernel);\n\tif (!dr)\n\t\treturn -enomem;\n\n\trc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);\n\tif (rc) {\n\t\tdevres_free(dr);\n\t\treturn rc;\n\t}\n\n\tdr->irq = irq;\n\tdr->dev_id = dev_id;\n\tdevres_add(dev, dr);\n\n\treturn 0;\n}\nexport_symbol(devm_request_any_context_irq);\n\n\nvoid devm_free_irq(struct device *dev, unsigned int irq, void *dev_id)\n{\n\tstruct irq_devres match_data = { irq, dev_id };\n\n\twarn_on(devres_destroy(dev, devm_irq_release, devm_irq_match,\n\t\t\t       &match_data));\n\tfree_irq(irq, dev_id);\n}\nexport_symbol(devm_free_irq);\n\n#include \"", "1181": "\", perf_type_software);\n\tperf_pmu_register(&perf_cpu_clock, null, -1);\n\tperf_pmu_register(&perf_task_clock, null, -1);\n\tperf_tp_register();\n\tperf_cpu_notifier(perf_cpu_notify);\n\tregister_reboot_notifier(&perf_reboot_notifier);\n\n\tret = init_hw_breakpoint();\n\twarn(ret, \"", "1182": "\", perf_type_tracepoint);\n}\n\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg)\n{\n\tchar *filter_str;\n\tint ret;\n\n\tif (event->attr.type != perf_type_tracepoint)\n\t\treturn -einval;\n\n\tfilter_str = strndup_user(arg, page_size);\n\tif (is_err(filter_str))\n\t\treturn ptr_err(filter_str);\n\n\tret = ftrace_profile_set_filter(event, event->attr.config, filter_str);\n\n\tkfree(filter_str);\n\treturn ret;\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n\tftrace_profile_free_filter(event);\n}\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\tstruct bpf_prog *prog;\n\n\tif (event->attr.type != perf_type_tracepoint)\n\t\treturn -einval;\n\n\tif (event->tp_event->prog)\n\t\treturn -eexist;\n\n\tif (!(event->tp_event->flags & trace_event_fl_kprobe))\n\t\t\n\t\treturn -einval;\n\n\tprog = bpf_prog_get(prog_fd);\n\tif (is_err(prog))\n\t\treturn ptr_err(prog);\n\n\tif (prog->type != bpf_prog_type_kprobe) {\n\t\t\n\t\tbpf_prog_put(prog);\n\t\treturn -einval;\n\t}\n\n\tevent->tp_event->prog = prog;\n\n\treturn 0;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n\tstruct bpf_prog *prog;\n\n\tif (!event->tp_event)\n\t\treturn;\n\n\tprog = event->tp_event->prog;\n\tif (prog) {\n\t\tevent->tp_event->prog = null;\n\t\tbpf_prog_put(prog);\n\t}\n}\n\n#else\n\nstatic inline void perf_tp_register(void)\n{\n}\n\nstatic int perf_event_set_filter(struct perf_event *event, void __user *arg)\n{\n\treturn -enoent;\n}\n\nstatic void perf_event_free_filter(struct perf_event *event)\n{\n}\n\nstatic int perf_event_set_bpf_prog(struct perf_event *event, u32 prog_fd)\n{\n\treturn -enoent;\n}\n\nstatic void perf_event_free_bpf_prog(struct perf_event *event)\n{\n}\n#endif \n\n#ifdef config_have_hw_breakpoint\nvoid perf_bp_event(struct perf_event *bp, void *data)\n{\n\tstruct perf_sample_data sample;\n\tstruct pt_regs *regs = data;\n\n\tperf_sample_data_init(&sample, bp->attr.bp_addr, 0);\n\n\tif (!bp->hw.state && !perf_exclude_event(bp, regs))\n\t\tperf_swevent_event(bp, 1, &sample, regs);\n}\n#endif\n\n\n\nstatic enum hrtimer_restart perf_swevent_hrtimer(struct hrtimer *hrtimer)\n{\n\tenum hrtimer_restart ret = hrtimer_restart;\n\tstruct perf_sample_data data;\n\tstruct pt_regs *regs;\n\tstruct perf_event *event;\n\tu64 period;\n\n\tevent = container_of(hrtimer, struct perf_event, hw.hrtimer);\n\n\tif (event->state != perf_event_state_active)\n\t\treturn hrtimer_norestart;\n\n\tevent->pmu->read(event);\n\n\tperf_sample_data_init(&data, 0, event->hw.last_period);\n\tregs = get_irq_regs();\n\n\tif (regs && !perf_exclude_event(event, regs)) {\n\t\tif (!(event->attr.exclude_idle && is_idle_task(current)))\n\t\t\tif (__perf_event_overflow(event, 1, &data, regs))\n\t\t\t\tret = hrtimer_norestart;\n\t}\n\n\tperiod = max_t(u64, 10000, event->hw.sample_period);\n\thrtimer_forward_now(hrtimer, ns_to_ktime(period));\n\n\treturn ret;\n}\n\nstatic void perf_swevent_start_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\ts64 period;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\tperiod = local64_read(&hwc->period_left);\n\tif (period) {\n\t\tif (period < 0)\n\t\t\tperiod = 10000;\n\n\t\tlocal64_set(&hwc->period_left, 0);\n\t} else {\n\t\tperiod = max_t(u64, 10000, hwc->sample_period);\n\t}\n\t__hrtimer_start_range_ns(&hwc->hrtimer,\n\t\t\t\tns_to_ktime(period), 0,\n\t\t\t\thrtimer_mode_rel_pinned, 0);\n}\n\nstatic void perf_swevent_cancel_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (is_sampling_event(event)) {\n\t\tktime_t remaining = hrtimer_get_remaining(&hwc->hrtimer);\n\t\tlocal64_set(&hwc->period_left, ktime_to_ns(remaining));\n\n\t\thrtimer_cancel(&hwc->hrtimer);\n\t}\n}\n\nstatic void perf_swevent_init_hrtimer(struct perf_event *event)\n{\n\tstruct hw_perf_event *hwc = &event->hw;\n\n\tif (!is_sampling_event(event))\n\t\treturn;\n\n\thrtimer_init(&hwc->hrtimer, clock_monotonic, hrtimer_mode_rel);\n\thwc->hrtimer.function = perf_swevent_hrtimer;\n\n\t\n\tif (event->attr.freq) {\n\t\tlong freq = event->attr.sample_freq;\n\n\t\tevent->attr.sample_period = nsec_per_sec / freq;\n\t\thwc->sample_period = event->attr.sample_period;\n\t\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\t\thwc->last_period = hwc->sample_period;\n\t\tevent->attr.freq = 0;\n\t}\n}\n\n\n\nstatic void cpu_clock_event_update(struct perf_event *event)\n{\n\ts64 prev;\n\tu64 now;\n\n\tnow = local_clock();\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tlocal64_add(now - prev, &event->count);\n}\n\nstatic void cpu_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, local_clock());\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void cpu_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & perf_ef_start)\n\t\tcpu_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void cpu_clock_event_del(struct perf_event *event, int flags)\n{\n\tcpu_clock_event_stop(event, flags);\n}\n\nstatic void cpu_clock_event_read(struct perf_event *event)\n{\n\tcpu_clock_event_update(event);\n}\n\nstatic int cpu_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != perf_type_software)\n\t\treturn -enoent;\n\n\tif (event->attr.config != perf_count_sw_cpu_clock)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_cpu_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= perf_pmu_cap_no_nmi,\n\n\t.event_init\t= cpu_clock_event_init,\n\t.add\t\t= cpu_clock_event_add,\n\t.del\t\t= cpu_clock_event_del,\n\t.start\t\t= cpu_clock_event_start,\n\t.stop\t\t= cpu_clock_event_stop,\n\t.read\t\t= cpu_clock_event_read,\n};\n\n\n\nstatic void task_clock_event_update(struct perf_event *event, u64 now)\n{\n\tu64 prev;\n\ts64 delta;\n\n\tprev = local64_xchg(&event->hw.prev_count, now);\n\tdelta = now - prev;\n\tlocal64_add(delta, &event->count);\n}\n\nstatic void task_clock_event_start(struct perf_event *event, int flags)\n{\n\tlocal64_set(&event->hw.prev_count, event->ctx->time);\n\tperf_swevent_start_hrtimer(event);\n}\n\nstatic void task_clock_event_stop(struct perf_event *event, int flags)\n{\n\tperf_swevent_cancel_hrtimer(event);\n\ttask_clock_event_update(event, event->ctx->time);\n}\n\nstatic int task_clock_event_add(struct perf_event *event, int flags)\n{\n\tif (flags & perf_ef_start)\n\t\ttask_clock_event_start(event, flags);\n\tperf_event_update_userpage(event);\n\n\treturn 0;\n}\n\nstatic void task_clock_event_del(struct perf_event *event, int flags)\n{\n\ttask_clock_event_stop(event, perf_ef_update);\n}\n\nstatic void task_clock_event_read(struct perf_event *event)\n{\n\tu64 now = perf_clock();\n\tu64 delta = now - event->ctx->timestamp;\n\tu64 time = event->ctx->time + delta;\n\n\ttask_clock_event_update(event, time);\n}\n\nstatic int task_clock_event_init(struct perf_event *event)\n{\n\tif (event->attr.type != perf_type_software)\n\t\treturn -enoent;\n\n\tif (event->attr.config != perf_count_sw_task_clock)\n\t\treturn -enoent;\n\n\t\n\tif (has_branch_stack(event))\n\t\treturn -eopnotsupp;\n\n\tperf_swevent_init_hrtimer(event);\n\n\treturn 0;\n}\n\nstatic struct pmu perf_task_clock = {\n\t.task_ctx_nr\t= perf_sw_context,\n\n\t.capabilities\t= perf_pmu_cap_no_nmi,\n\n\t.event_init\t= task_clock_event_init,\n\t.add\t\t= task_clock_event_add,\n\t.del\t\t= task_clock_event_del,\n\t.start\t\t= task_clock_event_start,\n\t.stop\t\t= task_clock_event_stop,\n\t.read\t\t= task_clock_event_read,\n};\n\nstatic void perf_pmu_nop_void(struct pmu *pmu)\n{\n}\n\nstatic int perf_pmu_nop_int(struct pmu *pmu)\n{\n\treturn 0;\n}\n\nstatic void perf_pmu_start_txn(struct pmu *pmu)\n{\n\tperf_pmu_disable(pmu);\n}\n\nstatic int perf_pmu_commit_txn(struct pmu *pmu)\n{\n\tperf_pmu_enable(pmu);\n\treturn 0;\n}\n\nstatic void perf_pmu_cancel_txn(struct pmu *pmu)\n{\n\tperf_pmu_enable(pmu);\n}\n\nstatic int perf_event_idx_default(struct perf_event *event)\n{\n\treturn 0;\n}\n\n\nstatic struct perf_cpu_context __percpu *find_pmu_context(int ctxn)\n{\n\tstruct pmu *pmu;\n\n\tif (ctxn < 0)\n\t\treturn null;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (pmu->task_ctx_nr == ctxn)\n\t\t\treturn pmu->pmu_cpu_context;\n\t}\n\n\treturn null;\n}\n\nstatic void update_pmu_context(struct pmu *pmu, struct pmu *old_pmu)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\n\t\tif (cpuctx->unique_pmu == old_pmu)\n\t\t\tcpuctx->unique_pmu = pmu;\n\t}\n}\n\nstatic void free_pmu_context(struct pmu *pmu)\n{\n\tstruct pmu *i;\n\n\tmutex_lock(&pmus_lock);\n\t\n\tlist_for_each_entry(i, &pmus, entry) {\n\t\tif (i->pmu_cpu_context == pmu->pmu_cpu_context) {\n\t\t\tupdate_pmu_context(i, pmu);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tfree_percpu(pmu->pmu_cpu_context);\nout:\n\tmutex_unlock(&pmus_lock);\n}\nstatic struct idr pmu_idr;\n\nstatic ssize_t\ntype_show(struct device *dev, struct device_attribute *attr, char *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, page_size-1, \"", "1183": "\", period.tv_sec, ms);\n\tif (atomic_read(&overflow_count))\n\t\tseq_printf(m, \"", "1184": "\", pm_states[state]);\n\terror = suspend_prepare(state);\n\tif (error)\n\t\tgoto unlock;\n\n\tif (suspend_test(test_freezer))\n\t\tgoto finish;\n\n\ttrace_suspend_resume(tps(\"", "1185": "\", pm_states[state]);\n\tpm_restrict_gfp_mask();\n\terror = suspend_devices_and_enter(state);\n\tpm_restore_gfp_mask();\n\n finish:\n\tpr_debug(\"", "1186": "\", pmu->hrtimer_interval_ms);\n}\n\nstatic ssize_t\nperf_event_mux_interval_ms_store(struct device *dev,\n\t\t\t\t struct device_attribute *attr,\n\t\t\t\t const char *buf, size_t count)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\tint timer, cpu, ret;\n\n\tret = kstrtoint(buf, 0, &timer);\n\tif (ret)\n\t\treturn ret;\n\n\tif (timer < 1)\n\t\treturn -einval;\n\n\t\n\tif (timer == pmu->hrtimer_interval_ms)\n\t\treturn count;\n\n\tpmu->hrtimer_interval_ms = timer;\n\n\t\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\tcpuctx->hrtimer_interval = ns_to_ktime(nsec_per_msec * timer);\n\n\t\tif (hrtimer_active(&cpuctx->hrtimer))\n\t\t\thrtimer_forward_now(&cpuctx->hrtimer, cpuctx->hrtimer_interval);\n\t}\n\n\treturn count;\n}\nstatic device_attr_rw(perf_event_mux_interval_ms);\n\nstatic struct attribute *pmu_dev_attrs[] = {\n\t&dev_attr_type.attr,\n\t&dev_attr_perf_event_mux_interval_ms.attr,\n\tnull,\n};\nattribute_groups(pmu_dev);\n\nstatic int pmu_bus_running;\nstatic struct bus_type pmu_bus = {\n\t.name\t\t= \"", "1187": "\", pmu->name);\n\tif (ret)\n\t\tgoto free_dev;\n\n\tdev_set_drvdata(pmu->dev, pmu);\n\tpmu->dev->bus = &pmu_bus;\n\tpmu->dev->release = pmu_dev_release;\n\tret = device_add(pmu->dev);\n\tif (ret)\n\t\tgoto free_dev;\n\nout:\n\treturn ret;\n\nfree_dev:\n\tput_device(pmu->dev);\n\tgoto out;\n}\n\nstatic struct lock_class_key cpuctx_mutex;\nstatic struct lock_class_key cpuctx_lock;\n\nint perf_pmu_register(struct pmu *pmu, const char *name, int type)\n{\n\tint cpu, ret;\n\n\tmutex_lock(&pmus_lock);\n\tret = -enomem;\n\tpmu->pmu_disable_count = alloc_percpu(int);\n\tif (!pmu->pmu_disable_count)\n\t\tgoto unlock;\n\n\tpmu->type = -1;\n\tif (!name)\n\t\tgoto skip_type;\n\tpmu->name = name;\n\n\tif (type < 0) {\n\t\ttype = idr_alloc(&pmu_idr, pmu, perf_type_max, 0, gfp_kernel);\n\t\tif (type < 0) {\n\t\t\tret = type;\n\t\t\tgoto free_pdc;\n\t\t}\n\t}\n\tpmu->type = type;\n\n\tif (pmu_bus_running) {\n\t\tret = pmu_dev_alloc(pmu);\n\t\tif (ret)\n\t\t\tgoto free_idr;\n\t}\n\nskip_type:\n\tpmu->pmu_cpu_context = find_pmu_context(pmu->task_ctx_nr);\n\tif (pmu->pmu_cpu_context)\n\t\tgoto got_cpu_context;\n\n\tret = -enomem;\n\tpmu->pmu_cpu_context = alloc_percpu(struct perf_cpu_context);\n\tif (!pmu->pmu_cpu_context)\n\t\tgoto free_dev;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct perf_cpu_context *cpuctx;\n\n\t\tcpuctx = per_cpu_ptr(pmu->pmu_cpu_context, cpu);\n\t\t__perf_event_init_context(&cpuctx->ctx);\n\t\tlockdep_set_class(&cpuctx->ctx.mutex, &cpuctx_mutex);\n\t\tlockdep_set_class(&cpuctx->ctx.lock, &cpuctx_lock);\n\t\tcpuctx->ctx.pmu = pmu;\n\n\t\t__perf_cpu_hrtimer_init(cpuctx, cpu);\n\n\t\tcpuctx->unique_pmu = pmu;\n\t}\n\ngot_cpu_context:\n\tif (!pmu->start_txn) {\n\t\tif (pmu->pmu_enable) {\n\t\t\t\n\t\t\tpmu->start_txn  = perf_pmu_start_txn;\n\t\t\tpmu->commit_txn = perf_pmu_commit_txn;\n\t\t\tpmu->cancel_txn = perf_pmu_cancel_txn;\n\t\t} else {\n\t\t\tpmu->start_txn  = perf_pmu_nop_void;\n\t\t\tpmu->commit_txn = perf_pmu_nop_int;\n\t\t\tpmu->cancel_txn = perf_pmu_nop_void;\n\t\t}\n\t}\n\n\tif (!pmu->pmu_enable) {\n\t\tpmu->pmu_enable  = perf_pmu_nop_void;\n\t\tpmu->pmu_disable = perf_pmu_nop_void;\n\t}\n\n\tif (!pmu->event_idx)\n\t\tpmu->event_idx = perf_event_idx_default;\n\n\tlist_add_rcu(&pmu->entry, &pmus);\n\tatomic_set(&pmu->exclusive_cnt, 0);\n\tret = 0;\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n\nfree_dev:\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\nfree_idr:\n\tif (pmu->type >= perf_type_max)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\nfree_pdc:\n\tfree_percpu(pmu->pmu_disable_count);\n\tgoto unlock;\n}\nexport_symbol_gpl(perf_pmu_register);\n\nvoid perf_pmu_unregister(struct pmu *pmu)\n{\n\tmutex_lock(&pmus_lock);\n\tlist_del_rcu(&pmu->entry);\n\tmutex_unlock(&pmus_lock);\n\n\t\n\tsynchronize_srcu(&pmus_srcu);\n\tsynchronize_rcu();\n\n\tfree_percpu(pmu->pmu_disable_count);\n\tif (pmu->type >= perf_type_max)\n\t\tidr_remove(&pmu_idr, pmu->type);\n\tdevice_del(pmu->dev);\n\tput_device(pmu->dev);\n\tfree_pmu_context(pmu);\n}\nexport_symbol_gpl(perf_pmu_unregister);\n\nstatic int perf_try_init_event(struct pmu *pmu, struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = null;\n\tint ret;\n\n\tif (!try_module_get(pmu->module))\n\t\treturn -enodev;\n\n\tif (event->group_leader != event) {\n\t\tctx = perf_event_ctx_lock(event->group_leader);\n\t\tbug_on(!ctx);\n\t}\n\n\tevent->pmu = pmu;\n\tret = pmu->event_init(event);\n\n\tif (ctx)\n\t\tperf_event_ctx_unlock(event->group_leader, ctx);\n\n\tif (ret)\n\t\tmodule_put(pmu->module);\n\n\treturn ret;\n}\n\nstruct pmu *perf_init_event(struct perf_event *event)\n{\n\tstruct pmu *pmu = null;\n\tint idx;\n\tint ret;\n\n\tidx = srcu_read_lock(&pmus_srcu);\n\n\trcu_read_lock();\n\tpmu = idr_find(&pmu_idr, event->attr.type);\n\trcu_read_unlock();\n\tif (pmu) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (ret)\n\t\t\tpmu = err_ptr(ret);\n\t\tgoto unlock;\n\t}\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tret = perf_try_init_event(pmu, event);\n\t\tif (!ret)\n\t\t\tgoto unlock;\n\n\t\tif (ret != -enoent) {\n\t\t\tpmu = err_ptr(ret);\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\tpmu = err_ptr(-enoent);\nunlock:\n\tsrcu_read_unlock(&pmus_srcu, idx);\n\n\treturn pmu;\n}\n\nstatic void account_event_cpu(struct perf_event *event, int cpu)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (is_cgroup_event(event))\n\t\tatomic_inc(&per_cpu(perf_cgroup_events, cpu));\n}\n\nstatic void account_event(struct perf_event *event)\n{\n\tif (event->parent)\n\t\treturn;\n\n\tif (event->attach_state & perf_attach_task)\n\t\tstatic_key_slow_inc(&perf_sched_events.key);\n\tif (event->attr.mmap || event->attr.mmap_data)\n\t\tatomic_inc(&nr_mmap_events);\n\tif (event->attr.comm)\n\t\tatomic_inc(&nr_comm_events);\n\tif (event->attr.task)\n\t\tatomic_inc(&nr_task_events);\n\tif (event->attr.freq) {\n\t\tif (atomic_inc_return(&nr_freq_events) == 1)\n\t\t\ttick_nohz_full_kick_all();\n\t}\n\tif (has_branch_stack(event))\n\t\tstatic_key_slow_inc(&perf_sched_events.key);\n\tif (is_cgroup_event(event))\n\t\tstatic_key_slow_inc(&perf_sched_events.key);\n\n\taccount_event_cpu(event, event->cpu);\n}\n\n\nstatic struct perf_event *\nperf_event_alloc(struct perf_event_attr *attr, int cpu,\n\t\t struct task_struct *task,\n\t\t struct perf_event *group_leader,\n\t\t struct perf_event *parent_event,\n\t\t perf_overflow_handler_t overflow_handler,\n\t\t void *context, int cgroup_fd)\n{\n\tstruct pmu *pmu;\n\tstruct perf_event *event;\n\tstruct hw_perf_event *hwc;\n\tlong err = -einval;\n\n\tif ((unsigned)cpu >= nr_cpu_ids) {\n\t\tif (!task || cpu != -1)\n\t\t\treturn err_ptr(-einval);\n\t}\n\n\tevent = kzalloc(sizeof(*event), gfp_kernel);\n\tif (!event)\n\t\treturn err_ptr(-enomem);\n\n\t\n\tif (!group_leader)\n\t\tgroup_leader = event;\n\n\tmutex_init(&event->child_mutex);\n\tinit_list_head(&event->child_list);\n\n\tinit_list_head(&event->group_entry);\n\tinit_list_head(&event->event_entry);\n\tinit_list_head(&event->sibling_list);\n\tinit_list_head(&event->rb_entry);\n\tinit_list_head(&event->active_entry);\n\tinit_hlist_node(&event->hlist_entry);\n\n\n\tinit_waitqueue_head(&event->waitq);\n\tinit_irq_work(&event->pending, perf_pending_event);\n\n\tmutex_init(&event->mmap_mutex);\n\n\tatomic_long_set(&event->refcount, 1);\n\tevent->cpu\t\t= cpu;\n\tevent->attr\t\t= *attr;\n\tevent->group_leader\t= group_leader;\n\tevent->pmu\t\t= null;\n\tevent->oncpu\t\t= -1;\n\n\tevent->parent\t\t= parent_event;\n\n\tevent->ns\t\t= get_pid_ns(task_active_pid_ns(current));\n\tevent->id\t\t= atomic64_inc_return(&perf_event_id);\n\n\tevent->state\t\t= perf_event_state_inactive;\n\n\tif (task) {\n\t\tevent->attach_state = perf_attach_task;\n\t\t\n\t\tevent->hw.target = task;\n\t}\n\n\tevent->clock = &local_clock;\n\tif (parent_event)\n\t\tevent->clock = parent_event->clock;\n\n\tif (!overflow_handler && parent_event) {\n\t\toverflow_handler = parent_event->overflow_handler;\n\t\tcontext = parent_event->overflow_handler_context;\n\t}\n\n\tevent->overflow_handler\t= overflow_handler;\n\tevent->overflow_handler_context = context;\n\n\tperf_event__state_init(event);\n\n\tpmu = null;\n\n\thwc = &event->hw;\n\thwc->sample_period = attr->sample_period;\n\tif (attr->freq && attr->sample_freq)\n\t\thwc->sample_period = 1;\n\thwc->last_period = hwc->sample_period;\n\n\tlocal64_set(&hwc->period_left, hwc->sample_period);\n\n\t\n\tif (attr->inherit && (attr->read_format & perf_format_group))\n\t\tgoto err_ns;\n\n\tif (!has_branch_stack(event))\n\t\tevent->attr.branch_sample_type = 0;\n\n\tif (cgroup_fd != -1) {\n\t\terr = perf_cgroup_connect(cgroup_fd, event, attr, group_leader);\n\t\tif (err)\n\t\t\tgoto err_ns;\n\t}\n\n\tpmu = perf_init_event(event);\n\tif (!pmu)\n\t\tgoto err_ns;\n\telse if (is_err(pmu)) {\n\t\terr = ptr_err(pmu);\n\t\tgoto err_ns;\n\t}\n\n\terr = exclusive_event_init(event);\n\tif (err)\n\t\tgoto err_pmu;\n\n\tif (!event->parent) {\n\t\tif (event->attr.sample_type & perf_sample_callchain) {\n\t\t\terr = get_callchain_buffers();\n\t\t\tif (err)\n\t\t\t\tgoto err_per_task;\n\t\t}\n\t}\n\n\treturn event;\n\nerr_per_task:\n\texclusive_event_destroy(event);\n\nerr_pmu:\n\tif (event->destroy)\n\t\tevent->destroy(event);\n\tmodule_put(pmu->module);\nerr_ns:\n\tif (is_cgroup_event(event))\n\t\tperf_detach_cgroup(event);\n\tif (event->ns)\n\t\tput_pid_ns(event->ns);\n\tkfree(event);\n\n\treturn err_ptr(err);\n}\n\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(verify_write, uattr, perf_attr_size_ver0))\n\t\treturn -efault;\n\n\t\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->size);\n\tif (ret)\n\t\treturn ret;\n\n\tif (size > page_size)\t\n\t\tgoto err_size;\n\n\tif (!size)\t\t\n\t\tsize = perf_attr_size_ver0;\n\n\tif (size < perf_attr_size_ver0)\n\t\tgoto err_size;\n\n\t\n\tif (size > sizeof(*attr)) {\n\t\tunsigned char __user *addr;\n\t\tunsigned char __user *end;\n\t\tunsigned char val;\n\n\t\taddr = (void __user *)uattr + sizeof(*attr);\n\t\tend  = (void __user *)uattr + size;\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -efault;\n\n\tif (attr->__reserved_1)\n\t\treturn -einval;\n\n\tif (attr->sample_type & ~(perf_sample_max-1))\n\t\treturn -einval;\n\n\tif (attr->read_format & ~(perf_format_max-1))\n\t\treturn -einval;\n\n\tif (attr->sample_type & perf_sample_branch_stack) {\n\t\tu64 mask = attr->branch_sample_type;\n\n\t\t\n\t\tif (mask & ~(perf_sample_branch_max-1))\n\t\t\treturn -einval;\n\n\t\t\n\t\tif (!(mask & ~perf_sample_branch_plm_all))\n\t\t\treturn -einval;\n\n\t\t\n\t\tif (!(mask & perf_sample_branch_plm_all)) {\n\n\t\t\t\n\t\t\tif (!attr->exclude_kernel)\n\t\t\t\tmask |= perf_sample_branch_kernel;\n\n\t\t\tif (!attr->exclude_user)\n\t\t\t\tmask |= perf_sample_branch_user;\n\n\t\t\tif (!attr->exclude_hv)\n\t\t\t\tmask |= perf_sample_branch_hv;\n\t\t\t\n\t\t\tattr->branch_sample_type = mask;\n\t\t}\n\t\t\n\t\tif ((mask & perf_sample_branch_perm_plm)\n\t\t    && perf_paranoid_kernel() && !capable(cap_sys_admin))\n\t\t\treturn -eacces;\n\t}\n\n\tif (attr->sample_type & perf_sample_regs_user) {\n\t\tret = perf_reg_validate(attr->sample_regs_user);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (attr->sample_type & perf_sample_stack_user) {\n\t\tif (!arch_perf_have_user_stack_dump())\n\t\t\treturn -enosys;\n\n\t\t\n\t\tif (attr->sample_stack_user >= ushrt_max)\n\t\t\tret = -einval;\n\t\telse if (!is_aligned(attr->sample_stack_user, sizeof(u64)))\n\t\t\tret = -einval;\n\t}\n\n\tif (attr->sample_type & perf_sample_regs_intr)\n\t\tret = perf_reg_validate(attr->sample_regs_intr);\nout:\n\treturn ret;\n\nerr_size:\n\tput_user(sizeof(*attr), &uattr->size);\n\tret = -e2big;\n\tgoto out;\n}\n\nstatic int\nperf_event_set_output(struct perf_event *event, struct perf_event *output_event)\n{\n\tstruct ring_buffer *rb = null;\n\tint ret = -einval;\n\n\tif (!output_event)\n\t\tgoto set;\n\n\t\n\tif (event == output_event)\n\t\tgoto out;\n\n\t\n\tif (output_event->cpu != event->cpu)\n\t\tgoto out;\n\n\t\n\tif (output_event->cpu == -1 && output_event->ctx != event->ctx)\n\t\tgoto out;\n\n\t\n\tif (output_event->clock != event->clock)\n\t\tgoto out;\n\n\t\n\tif (has_aux(event) && has_aux(output_event) &&\n\t    event->pmu != output_event->pmu)\n\t\tgoto out;\n\nset:\n\tmutex_lock(&event->mmap_mutex);\n\t\n\tif (atomic_read(&event->mmap_count))\n\t\tgoto unlock;\n\n\tif (output_event) {\n\t\t\n\t\trb = ring_buffer_get(output_event);\n\t\tif (!rb)\n\t\t\tgoto unlock;\n\t}\n\n\tring_buffer_attach(event, rb);\n\n\tret = 0;\nunlock:\n\tmutex_unlock(&event->mmap_mutex);\n\nout:\n\treturn ret;\n}\n\nstatic void mutex_lock_double(struct mutex *a, struct mutex *b)\n{\n\tif (b < a)\n\t\tswap(a, b);\n\n\tmutex_lock(a);\n\tmutex_lock_nested(b, single_depth_nesting);\n}\n\nstatic int perf_event_set_clock(struct perf_event *event, clockid_t clk_id)\n{\n\tbool nmi_safe = false;\n\n\tswitch (clk_id) {\n\tcase clock_monotonic:\n\t\tevent->clock = &ktime_get_mono_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase clock_monotonic_raw:\n\t\tevent->clock = &ktime_get_raw_fast_ns;\n\t\tnmi_safe = true;\n\t\tbreak;\n\n\tcase clock_realtime:\n\t\tevent->clock = &ktime_get_real_ns;\n\t\tbreak;\n\n\tcase clock_boottime:\n\t\tevent->clock = &ktime_get_boot_ns;\n\t\tbreak;\n\n\tcase clock_tai:\n\t\tevent->clock = &ktime_get_tai_ns;\n\t\tbreak;\n\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\tif (!nmi_safe && !(event->pmu->capabilities & perf_pmu_cap_no_nmi))\n\t\treturn -einval;\n\n\treturn 0;\n}\n\n\nsyscall_define5(perf_event_open,\n\t\tstruct perf_event_attr __user *, attr_uptr,\n\t\tpid_t, pid, int, cpu, int, group_fd, unsigned long, flags)\n{\n\tstruct perf_event *group_leader = null, *output_event = null;\n\tstruct perf_event *event, *sibling;\n\tstruct perf_event_attr attr;\n\tstruct perf_event_context *ctx, *uninitialized_var(gctx);\n\tstruct file *event_file = null;\n\tstruct fd group = {null, 0};\n\tstruct task_struct *task = null;\n\tstruct pmu *pmu;\n\tint event_fd;\n\tint move_group = 0;\n\tint err;\n\tint f_flags = o_rdwr;\n\tint cgroup_fd = -1;\n\n\t\n\tif (flags & ~perf_flag_all)\n\t\treturn -einval;\n\n\terr = perf_copy_attr(attr_uptr, &attr);\n\tif (err)\n\t\treturn err;\n\n\tif (!attr.exclude_kernel) {\n\t\tif (perf_paranoid_kernel() && !capable(cap_sys_admin))\n\t\t\treturn -eacces;\n\t}\n\n\tif (attr.freq) {\n\t\tif (attr.sample_freq > sysctl_perf_event_sample_rate)\n\t\t\treturn -einval;\n\t} else {\n\t\tif (attr.sample_period & (1ull << 63))\n\t\t\treturn -einval;\n\t}\n\n\t\n\tif ((flags & perf_flag_pid_cgroup) && (pid == -1 || cpu == -1))\n\t\treturn -einval;\n\n\tif (flags & perf_flag_fd_cloexec)\n\t\tf_flags |= o_cloexec;\n\n\tevent_fd = get_unused_fd_flags(f_flags);\n\tif (event_fd < 0)\n\t\treturn event_fd;\n\n\tif (group_fd != -1) {\n\t\terr = perf_fget_light(group_fd, &group);\n\t\tif (err)\n\t\t\tgoto err_fd;\n\t\tgroup_leader = group.file->private_data;\n\t\tif (flags & perf_flag_fd_output)\n\t\t\toutput_event = group_leader;\n\t\tif (flags & perf_flag_fd_no_group)\n\t\t\tgroup_leader = null;\n\t}\n\n\tif (pid != -1 && !(flags & perf_flag_pid_cgroup)) {\n\t\ttask = find_lively_task_by_vpid(pid);\n\t\tif (is_err(task)) {\n\t\t\terr = ptr_err(task);\n\t\t\tgoto err_group_fd;\n\t\t}\n\t}\n\n\tif (task && group_leader &&\n\t    group_leader->attr.inherit != attr.inherit) {\n\t\terr = -einval;\n\t\tgoto err_task;\n\t}\n\n\tget_online_cpus();\n\n\tif (flags & perf_flag_pid_cgroup)\n\t\tcgroup_fd = pid;\n\n\tevent = perf_event_alloc(&attr, cpu, task, group_leader, null,\n\t\t\t\t null, null, cgroup_fd);\n\tif (is_err(event)) {\n\t\terr = ptr_err(event);\n\t\tgoto err_cpus;\n\t}\n\n\tif (is_sampling_event(event)) {\n\t\tif (event->pmu->capabilities & perf_pmu_cap_no_interrupt) {\n\t\t\terr = -enotsupp;\n\t\t\tgoto err_alloc;\n\t\t}\n\t}\n\n\taccount_event(event);\n\n\t\n\tpmu = event->pmu;\n\n\tif (attr.use_clockid) {\n\t\terr = perf_event_set_clock(event, attr.clockid);\n\t\tif (err)\n\t\t\tgoto err_alloc;\n\t}\n\n\tif (group_leader &&\n\t    (is_software_event(event) != is_software_event(group_leader))) {\n\t\tif (is_software_event(event)) {\n\t\t\t\n\t\t\tpmu = group_leader->pmu;\n\t\t} else if (is_software_event(group_leader) &&\n\t\t\t   (group_leader->group_flags & perf_group_software)) {\n\t\t\t\n\t\t\tmove_group = 1;\n\t\t}\n\t}\n\n\t\n\tctx = find_get_context(pmu, task, event);\n\tif (is_err(ctx)) {\n\t\terr = ptr_err(ctx);\n\t\tgoto err_alloc;\n\t}\n\n\tif ((pmu->capabilities & perf_pmu_cap_exclusive) && group_leader) {\n\t\terr = -ebusy;\n\t\tgoto err_context;\n\t}\n\n\tif (task) {\n\t\tput_task_struct(task);\n\t\ttask = null;\n\t}\n\n\t\n\tif (group_leader) {\n\t\terr = -einval;\n\n\t\t\n\t\tif (group_leader->group_leader != group_leader)\n\t\t\tgoto err_context;\n\n\t\t\n\t\tif (group_leader->clock != event->clock)\n\t\t\tgoto err_context;\n\n\t\t\n\t\tif (move_group) {\n\t\t\t\n\t\t\tif (group_leader->ctx->task != ctx->task)\n\t\t\t\tgoto err_context;\n\n\t\t\t\n\t\t\tif (group_leader->cpu != event->cpu)\n\t\t\t\tgoto err_context;\n\t\t} else {\n\t\t\tif (group_leader->ctx != ctx)\n\t\t\t\tgoto err_context;\n\t\t}\n\n\t\t\n\t\tif (attr.exclusive || attr.pinned)\n\t\t\tgoto err_context;\n\t}\n\n\tif (output_event) {\n\t\terr = perf_event_set_output(event, output_event);\n\t\tif (err)\n\t\t\tgoto err_context;\n\t}\n\n\tevent_file = anon_inode_getfile(\"", "1188": "\", pmu->name, ret);\n\t}\n\tpmu_bus_running = 1;\n\tret = 0;\n\nunlock:\n\tmutex_unlock(&pmus_lock);\n\n\treturn ret;\n}\ndevice_initcall(perf_event_sysfs_init);\n\n#ifdef config_cgroup_perf\nstatic struct cgroup_subsys_state *\nperf_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct perf_cgroup *jc;\n\n\tjc = kzalloc(sizeof(*jc), gfp_kernel);\n\tif (!jc)\n\t\treturn err_ptr(-enomem);\n\n\tjc->info = alloc_percpu(struct perf_cgroup_info);\n\tif (!jc->info) {\n\t\tkfree(jc);\n\t\treturn err_ptr(-enomem);\n\t}\n\n\treturn &jc->css;\n}\n\nstatic void perf_cgroup_css_free(struct cgroup_subsys_state *css)\n{\n\tstruct perf_cgroup *jc = container_of(css, struct perf_cgroup, css);\n\n\tfree_percpu(jc->info);\n\tkfree(jc);\n}\n\nstatic int __perf_cgroup_move(void *info)\n{\n\tstruct task_struct *task = info;\n\tperf_cgroup_switch(task, perf_cgroup_swout | perf_cgroup_swin);\n\treturn 0;\n}\n\nstatic void perf_cgroup_attach(struct cgroup_subsys_state *css,\n\t\t\t       struct cgroup_taskset *tset)\n{\n\tstruct task_struct *task;\n\n\tcgroup_taskset_for_each(task, tset)\n\t\ttask_function_call(task, __perf_cgroup_move, task);\n}\n\nstatic void perf_cgroup_exit(struct cgroup_subsys_state *css,\n\t\t\t     struct cgroup_subsys_state *old_css,\n\t\t\t     struct task_struct *task)\n{\n\t\n\tif (!(task->flags & pf_exiting))\n\t\treturn;\n\n\ttask_function_call(task, __perf_cgroup_move, task);\n}\n\nstruct cgroup_subsys perf_event_cgrp_subsys = {\n\t.css_alloc\t= perf_cgroup_css_alloc,\n\t.css_free\t= perf_cgroup_css_free,\n\t.exit\t\t= perf_cgroup_exit,\n\t.attach\t\t= perf_cgroup_attach,\n};\n#endif \n\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/jhash.h>\n#include <linux/init.h>\n#include <linux/futex.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/syscalls.h>\n#include <linux/signal.h>\n#include <linux/export.h>\n#include <linux/magic.h>\n#include <linux/pid.h>\n#include <linux/nsproxy.h>\n#include <linux/ptrace.h>\n#include <linux/sched/rt.h>\n#include <linux/hugetlb.h>\n#include <linux/freezer.h>\n#include <linux/bootmem.h>\n\n#include <asm/futex.h>\n\n#include \"", "1189": "\", pmu->type);\n}\nstatic device_attr_ro(type);\n\nstatic ssize_t\nperf_event_mux_interval_ms_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr,\n\t\t\t\tchar *page)\n{\n\tstruct pmu *pmu = dev_get_drvdata(dev);\n\n\treturn snprintf(page, page_size-1, \"", "1190": "\", pmu_attr->event_str);\n\n\treturn 0;\n}\n\nstatic int __init perf_event_sysfs_init(void)\n{\n\tstruct pmu *pmu;\n\tint ret;\n\n\tmutex_lock(&pmus_lock);\n\n\tret = bus_register(&pmu_bus);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(pmu, &pmus, entry) {\n\t\tif (!pmu->name || pmu->type < 0)\n\t\t\tcontinue;\n\n\t\tret = pmu_dev_alloc(pmu);\n\t\twarn(ret, \"", "1191": "\", prefix);\n\t\t} else {\n\t\t\tlen += 3;\n\t\t\tif (prefix > 999)\n\t\t\t\tlen += 3;\n\t\t\telse if (prefix > 99)\n\t\t\t\tlen += 2;\n\t\t\telse if (prefix > 9)\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\tlen += print_time(msg->ts_nsec, buf ? buf + len : null);\n\treturn len;\n}\n\nstatic size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,\n\t\t\t     bool syslog, char *buf, size_t size)\n{\n\tconst char *text = log_text(msg);\n\tsize_t text_size = msg->text_len;\n\tbool prefix = true;\n\tbool newline = true;\n\tsize_t len = 0;\n\n\tif ((prev & log_cont) && !(msg->flags & log_prefix))\n\t\tprefix = false;\n\n\tif (msg->flags & log_cont) {\n\t\tif ((prev & log_cont) && !(prev & log_newline))\n\t\t\tprefix = false;\n\n\t\tif (!(msg->flags & log_newline))\n\t\t\tnewline = false;\n\t}\n\n\tdo {\n\t\tconst char *next = memchr(text, '\\n', text_size);\n\t\tsize_t text_len;\n\n\t\tif (next) {\n\t\t\ttext_len = next - text;\n\t\t\tnext++;\n\t\t\ttext_size -= next - text;\n\t\t} else {\n\t\t\ttext_len = text_size;\n\t\t}\n\n\t\tif (buf) {\n\t\t\tif (print_prefix(msg, syslog, null) +\n\t\t\t    text_len + 1 >= size - len)\n\t\t\t\tbreak;\n\n\t\t\tif (prefix)\n\t\t\t\tlen += print_prefix(msg, syslog, buf + len);\n\t\t\tmemcpy(buf + len, text, text_len);\n\t\t\tlen += text_len;\n\t\t\tif (next || newline)\n\t\t\t\tbuf[len++] = '\\n';\n\t\t} else {\n\t\t\t\n\t\t\tif (prefix)\n\t\t\t\tlen += print_prefix(msg, syslog, null);\n\t\t\tlen += text_len;\n\t\t\tif (next || newline)\n\t\t\t\tlen++;\n\t\t}\n\n\t\tprefix = true;\n\t\ttext = next;\n\t} while (text);\n\n\treturn len;\n}\n\nstatic int syslog_print(char __user *buf, int size)\n{\n\tchar *text;\n\tstruct printk_log *msg;\n\tint len = 0;\n\n\ttext = kmalloc(log_line_max + prefix_max, gfp_kernel);\n\tif (!text)\n\t\treturn -enomem;\n\n\twhile (size > 0) {\n\t\tsize_t n;\n\t\tsize_t skip;\n\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_prev = 0;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (syslog_seq == log_next_seq) {\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\tbreak;\n\t\t}\n\n\t\tskip = syslog_partial;\n\t\tmsg = log_from_idx(syslog_idx);\n\t\tn = msg_print_text(msg, syslog_prev, true, text,\n\t\t\t\t   log_line_max + prefix_max);\n\t\tif (n - syslog_partial <= size) {\n\t\t\t\n\t\t\tsyslog_idx = log_next(syslog_idx);\n\t\t\tsyslog_seq++;\n\t\t\tsyslog_prev = msg->flags;\n\t\t\tn -= syslog_partial;\n\t\t\tsyslog_partial = 0;\n\t\t} else if (!len){\n\t\t\t\n\t\t\tn = size;\n\t\t\tsyslog_partial += n;\n\t\t} else\n\t\t\tn = 0;\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\n\t\tif (!n)\n\t\t\tbreak;\n\n\t\tif (copy_to_user(buf, text + skip, n)) {\n\t\t\tif (!len)\n\t\t\t\tlen = -efault;\n\t\t\tbreak;\n\t\t}\n\n\t\tlen += n;\n\t\tsize -= n;\n\t\tbuf += n;\n\t}\n\n\tkfree(text);\n\treturn len;\n}\n\nstatic int syslog_print_all(char __user *buf, int size, bool clear)\n{\n\tchar *text;\n\tint len = 0;\n\n\ttext = kmalloc(log_line_max + prefix_max, gfp_kernel);\n\tif (!text)\n\t\treturn -enomem;\n\n\traw_spin_lock_irq(&logbuf_lock);\n\tif (buf) {\n\t\tu64 next_seq;\n\t\tu64 seq;\n\t\tu32 idx;\n\t\tenum log_flags prev;\n\n\t\tif (clear_seq < log_first_seq) {\n\t\t\t\n\t\t\tclear_seq = log_first_seq;\n\t\t\tclear_idx = log_first_idx;\n\t\t}\n\n\t\t\n\t\tseq = clear_seq;\n\t\tidx = clear_idx;\n\t\tprev = 0;\n\t\twhile (seq < log_next_seq) {\n\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\tlen += msg_print_text(msg, prev, true, null, 0);\n\t\t\tprev = msg->flags;\n\t\t\tidx = log_next(idx);\n\t\t\tseq++;\n\t\t}\n\n\t\t\n\t\tseq = clear_seq;\n\t\tidx = clear_idx;\n\t\tprev = 0;\n\t\twhile (len > size && seq < log_next_seq) {\n\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\tlen -= msg_print_text(msg, prev, true, null, 0);\n\t\t\tprev = msg->flags;\n\t\t\tidx = log_next(idx);\n\t\t\tseq++;\n\t\t}\n\n\t\t\n\t\tnext_seq = log_next_seq;\n\n\t\tlen = 0;\n\t\twhile (len >= 0 && seq < next_seq) {\n\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\t\t\tint textlen;\n\n\t\t\ttextlen = msg_print_text(msg, prev, true, text,\n\t\t\t\t\t\t log_line_max + prefix_max);\n\t\t\tif (textlen < 0) {\n\t\t\t\tlen = textlen;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tidx = log_next(idx);\n\t\t\tseq++;\n\t\t\tprev = msg->flags;\n\n\t\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\t\tif (copy_to_user(buf + len, text, textlen))\n\t\t\t\tlen = -efault;\n\t\t\telse\n\t\t\t\tlen += textlen;\n\t\t\traw_spin_lock_irq(&logbuf_lock);\n\n\t\t\tif (seq < log_first_seq) {\n\t\t\t\t\n\t\t\t\tseq = log_first_seq;\n\t\t\t\tidx = log_first_idx;\n\t\t\t\tprev = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (clear) {\n\t\tclear_seq = log_next_seq;\n\t\tclear_idx = log_next_idx;\n\t}\n\traw_spin_unlock_irq(&logbuf_lock);\n\n\tkfree(text);\n\treturn len;\n}\n\nint do_syslog(int type, char __user *buf, int len, bool from_file)\n{\n\tbool clear = false;\n\tstatic int saved_console_loglevel = loglevel_default;\n\tint error;\n\n\terror = check_syslog_permissions(type, from_file);\n\tif (error)\n\t\tgoto out;\n\n\terror = security_syslog(type);\n\tif (error)\n\t\treturn error;\n\n\tswitch (type) {\n\tcase syslog_action_close:\t\n\t\tbreak;\n\tcase syslog_action_open:\t\n\t\tbreak;\n\tcase syslog_action_read:\t\n\t\terror = -einval;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(verify_write, buf, len)) {\n\t\t\terror = -efault;\n\t\t\tgoto out;\n\t\t}\n\t\terror = wait_event_interruptible(log_wait,\n\t\t\t\t\t\t syslog_seq != log_next_seq);\n\t\tif (error)\n\t\t\tgoto out;\n\t\terror = syslog_print(buf, len);\n\t\tbreak;\n\t\n\tcase syslog_action_read_clear:\n\t\tclear = true;\n\t\t\n\t\n\tcase syslog_action_read_all:\n\t\terror = -einval;\n\t\tif (!buf || len < 0)\n\t\t\tgoto out;\n\t\terror = 0;\n\t\tif (!len)\n\t\t\tgoto out;\n\t\tif (!access_ok(verify_write, buf, len)) {\n\t\t\terror = -efault;\n\t\t\tgoto out;\n\t\t}\n\t\terror = syslog_print_all(buf, len, clear);\n\t\tbreak;\n\t\n\tcase syslog_action_clear:\n\t\tsyslog_print_all(null, 0, true);\n\t\tbreak;\n\t\n\tcase syslog_action_console_off:\n\t\tif (saved_console_loglevel == loglevel_default)\n\t\t\tsaved_console_loglevel = console_loglevel;\n\t\tconsole_loglevel = minimum_console_loglevel;\n\t\tbreak;\n\t\n\tcase syslog_action_console_on:\n\t\tif (saved_console_loglevel != loglevel_default) {\n\t\t\tconsole_loglevel = saved_console_loglevel;\n\t\t\tsaved_console_loglevel = loglevel_default;\n\t\t}\n\t\tbreak;\n\t\n\tcase syslog_action_console_level:\n\t\terror = -einval;\n\t\tif (len < 1 || len > 8)\n\t\t\tgoto out;\n\t\tif (len < minimum_console_loglevel)\n\t\t\tlen = minimum_console_loglevel;\n\t\tconsole_loglevel = len;\n\t\t\n\t\tsaved_console_loglevel = loglevel_default;\n\t\terror = 0;\n\t\tbreak;\n\t\n\tcase syslog_action_size_unread:\n\t\traw_spin_lock_irq(&logbuf_lock);\n\t\tif (syslog_seq < log_first_seq) {\n\t\t\t\n\t\t\tsyslog_seq = log_first_seq;\n\t\t\tsyslog_idx = log_first_idx;\n\t\t\tsyslog_prev = 0;\n\t\t\tsyslog_partial = 0;\n\t\t}\n\t\tif (from_file) {\n\t\t\t\n\t\t\terror = log_next_seq - syslog_seq;\n\t\t} else {\n\t\t\tu64 seq = syslog_seq;\n\t\t\tu32 idx = syslog_idx;\n\t\t\tenum log_flags prev = syslog_prev;\n\n\t\t\terror = 0;\n\t\t\twhile (seq < log_next_seq) {\n\t\t\t\tstruct printk_log *msg = log_from_idx(idx);\n\n\t\t\t\terror += msg_print_text(msg, prev, true, null, 0);\n\t\t\t\tidx = log_next(idx);\n\t\t\t\tseq++;\n\t\t\t\tprev = msg->flags;\n\t\t\t}\n\t\t\terror -= syslog_partial;\n\t\t}\n\t\traw_spin_unlock_irq(&logbuf_lock);\n\t\tbreak;\n\t\n\tcase syslog_action_size_buffer:\n\t\terror = log_buf_len;\n\t\tbreak;\n\tdefault:\n\t\terror = -einval;\n\t\tbreak;\n\t}\nout:\n\treturn error;\n}\n\nsyscall_define3(syslog, int, type, char __user *, buf, int, len)\n{\n\treturn do_syslog(type, buf, len, syslog_from_reader);\n}\n\n\nstatic void call_console_drivers(int level, const char *text, size_t len)\n{\n\tstruct console *con;\n\n\ttrace_console(text, len);\n\n\tif (level >= console_loglevel && !ignore_loglevel)\n\t\treturn;\n\tif (!console_drivers)\n\t\treturn;\n\n\tfor_each_console(con) {\n\t\tif (exclusive_console && con != exclusive_console)\n\t\t\tcontinue;\n\t\tif (!(con->flags & con_enabled))\n\t\t\tcontinue;\n\t\tif (!con->write)\n\t\t\tcontinue;\n\t\tif (!cpu_online(smp_processor_id()) &&\n\t\t    !(con->flags & con_anytime))\n\t\t\tcontinue;\n\t\tcon->write(con, text, len);\n\t}\n}\n\n\nstatic void zap_locks(void)\n{\n\tstatic unsigned long oops_timestamp;\n\n\tif (time_after_eq(jiffies, oops_timestamp) &&\n\t    !time_after(jiffies, oops_timestamp + 30 * hz))\n\t\treturn;\n\n\toops_timestamp = jiffies;\n\n\tdebug_locks_off();\n\t\n\traw_spin_lock_init(&logbuf_lock);\n\t\n\tsema_init(&console_sem, 1);\n}\n\n\nstatic int have_callable_console(void)\n{\n\tstruct console *con;\n\n\tfor_each_console(con)\n\t\tif (con->flags & con_anytime)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\n\nstatic inline int can_use_console(unsigned int cpu)\n{\n\treturn cpu_online(cpu) || have_callable_console();\n}\n\n\nstatic int console_trylock_for_printk(void)\n{\n\tunsigned int cpu = smp_processor_id();\n\n\tif (!console_trylock())\n\t\treturn 0;\n\t\n\tif (!can_use_console(cpu)) {\n\t\tconsole_locked = 0;\n\t\tup_console_sem();\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nint printk_delay_msec __read_mostly;\n\nstatic inline void printk_delay(void)\n{\n\tif (unlikely(printk_delay_msec)) {\n\t\tint m = printk_delay_msec;\n\n\t\twhile (m--) {\n\t\t\tmdelay(1);\n\t\t\ttouch_nmi_watchdog();\n\t\t}\n\t}\n}\n\n\nstatic struct cont {\n\tchar buf[log_line_max];\n\tsize_t len;\t\t\t\n\tsize_t cons;\t\t\t\n\tstruct task_struct *owner;\t\n\tu64 ts_nsec;\t\t\t\n\tu8 level;\t\t\t\n\tu8 facility;\t\t\t\n\tenum log_flags flags;\t\t\n\tbool flushed:1;\t\t\t\n} cont;\n\nstatic void cont_flush(enum log_flags flags)\n{\n\tif (cont.flushed)\n\t\treturn;\n\tif (cont.len == 0)\n\t\treturn;\n\n\tif (cont.cons) {\n\t\t\n\t\tlog_store(cont.facility, cont.level, flags | log_nocons,\n\t\t\t  cont.ts_nsec, null, 0, cont.buf, cont.len);\n\t\tcont.flags = flags;\n\t\tcont.flushed = true;\n\t} else {\n\t\t\n\t\tlog_store(cont.facility, cont.level, flags, 0,\n\t\t\t  null, 0, cont.buf, cont.len);\n\t\tcont.len = 0;\n\t}\n}\n\nstatic bool cont_add(int facility, int level, const char *text, size_t len)\n{\n\tif (cont.len && cont.flushed)\n\t\treturn false;\n\n\tif (cont.len + len > sizeof(cont.buf)) {\n\t\t\n\t\tcont_flush(log_cont);\n\t\treturn false;\n\t}\n\n\tif (!cont.len) {\n\t\tcont.facility = facility;\n\t\tcont.level = level;\n\t\tcont.owner = current;\n\t\tcont.ts_nsec = local_clock();\n\t\tcont.flags = 0;\n\t\tcont.cons = 0;\n\t\tcont.flushed = false;\n\t}\n\n\tmemcpy(cont.buf + cont.len, text, len);\n\tcont.len += len;\n\n\tif (cont.len > (sizeof(cont.buf) * 80) / 100)\n\t\tcont_flush(log_cont);\n\n\treturn true;\n}\n\nstatic size_t cont_print_text(char *text, size_t size)\n{\n\tsize_t textlen = 0;\n\tsize_t len;\n\n\tif (cont.cons == 0 && (console_prev & log_newline)) {\n\t\ttextlen += print_time(cont.ts_nsec, text);\n\t\tsize -= textlen;\n\t}\n\n\tlen = cont.len - cont.cons;\n\tif (len > 0) {\n\t\tif (len+1 > size)\n\t\t\tlen = size-1;\n\t\tmemcpy(text + textlen, cont.buf + cont.cons, len);\n\t\ttextlen += len;\n\t\tcont.cons = cont.len;\n\t}\n\n\tif (cont.flushed) {\n\t\tif (cont.flags & log_newline)\n\t\t\ttext[textlen++] = '\\n';\n\t\t\n\t\tcont.len = 0;\n\t}\n\treturn textlen;\n}\n\nasmlinkage int vprintk_emit(int facility, int level,\n\t\t\t    const char *dict, size_t dictlen,\n\t\t\t    const char *fmt, va_list args)\n{\n\tstatic int recursion_bug;\n\tstatic char textbuf[log_line_max];\n\tchar *text = textbuf;\n\tsize_t text_len = 0;\n\tenum log_flags lflags = 0;\n\tunsigned long flags;\n\tint this_cpu;\n\tint printed_len = 0;\n\tbool in_sched = false;\n\t\n\tstatic unsigned int logbuf_cpu = uint_max;\n\n\tif (level == loglevel_sched) {\n\t\tlevel = loglevel_default;\n\t\tin_sched = true;\n\t}\n\n\tboot_delay_msec(level);\n\tprintk_delay();\n\n\t\n\tlocal_irq_save(flags);\n\tthis_cpu = smp_processor_id();\n\n\t\n\tif (unlikely(logbuf_cpu == this_cpu)) {\n\t\t\n\t\tif (!oops_in_progress && !lockdep_recursing(current)) {\n\t\t\trecursion_bug = 1;\n\t\t\tlocal_irq_restore(flags);\n\t\t\treturn 0;\n\t\t}\n\t\tzap_locks();\n\t}\n\n\tlockdep_off();\n\traw_spin_lock(&logbuf_lock);\n\tlogbuf_cpu = this_cpu;\n\n\tif (unlikely(recursion_bug)) {\n\t\tstatic const char recursion_msg[] =\n\t\t\t\"", "1192": "\", ptr);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_iterator *iter = m->private;\n\tstruct dyn_ftrace *rec;\n\n\tif (iter->flags & ftrace_iter_hash)\n\t\treturn t_hash_show(m, iter);\n\n\tif (iter->flags & ftrace_iter_printall) {\n\t\tif (iter->flags & ftrace_iter_notrace)\n\t\t\tseq_puts(m, \"", "1193": "\", r);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\nrb_simple_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tstruct ring_buffer *buffer = tr->trace_buffer.buffer;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (buffer) {\n\t\tmutex_lock(&trace_types_lock);\n\t\tif (val) {\n\t\t\ttracer_tracing_on(tr);\n\t\t\tif (tr->current_trace->start)\n\t\t\t\ttr->current_trace->start(tr);\n\t\t} else {\n\t\t\ttracer_tracing_off(tr);\n\t\t\tif (tr->current_trace->stop)\n\t\t\t\ttr->current_trace->stop(tr);\n\t\t}\n\t\tmutex_unlock(&trace_types_lock);\n\t}\n\n\t(*ppos)++;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations rb_simple_fops = {\n\t.open\t\t= tracing_open_generic_tr,\n\t.read\t\t= rb_simple_read,\n\t.write\t\t= rb_simple_write,\n\t.release\t= tracing_release_generic_tr,\n\t.llseek\t\t= default_llseek,\n};\n\nstruct dentry *trace_instance_dir;\n\nstatic void\ninit_tracer_tracefs(struct trace_array *tr, struct dentry *d_tracer);\n\nstatic int\nallocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = trace_flags & trace_iter_overwrite ? rb_fl_overwrite : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -enomem;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -enomem;\n\t}\n\n\t\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}\n\nstatic int allocate_trace_buffers(struct trace_array *tr, int size)\n{\n\tint ret;\n\n\tret = allocate_trace_buffer(tr, &tr->trace_buffer, size);\n\tif (ret)\n\t\treturn ret;\n\n#ifdef config_tracer_max_trace\n\tret = allocate_trace_buffer(tr, &tr->max_buffer,\n\t\t\t\t    allocate_snapshot ? size : 1);\n\tif (warn_on(ret)) {\n\t\tring_buffer_free(tr->trace_buffer.buffer);\n\t\tfree_percpu(tr->trace_buffer.data);\n\t\treturn -enomem;\n\t}\n\ttr->allocated_snapshot = allocate_snapshot;\n\n\t\n\tallocate_snapshot = false;\n#endif\n\treturn 0;\n}\n\nstatic void free_trace_buffer(struct trace_buffer *buf)\n{\n\tif (buf->buffer) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = null;\n\t\tfree_percpu(buf->data);\n\t\tbuf->data = null;\n\t}\n}\n\nstatic void free_trace_buffers(struct trace_array *tr)\n{\n\tif (!tr)\n\t\treturn;\n\n\tfree_trace_buffer(&tr->trace_buffer);\n\n#ifdef config_tracer_max_trace\n\tfree_trace_buffer(&tr->max_buffer);\n#endif\n}\n\nstatic int instance_mkdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = -eexist;\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0)\n\t\t\tgoto out_unlock;\n\t}\n\n\tret = -enomem;\n\ttr = kzalloc(sizeof(*tr), gfp_kernel);\n\tif (!tr)\n\t\tgoto out_unlock;\n\n\ttr->name = kstrdup(name, gfp_kernel);\n\tif (!tr->name)\n\t\tgoto out_free_tr;\n\n\tif (!alloc_cpumask_var(&tr->tracing_cpumask, gfp_kernel))\n\t\tgoto out_free_tr;\n\n\tcpumask_copy(tr->tracing_cpumask, cpu_all_mask);\n\n\traw_spin_lock_init(&tr->start_lock);\n\n\ttr->max_lock = (arch_spinlock_t)__arch_spin_lock_unlocked;\n\n\ttr->current_trace = &nop_trace;\n\n\tinit_list_head(&tr->systems);\n\tinit_list_head(&tr->events);\n\n\tif (allocate_trace_buffers(tr, trace_buf_size) < 0)\n\t\tgoto out_free_tr;\n\n\ttr->dir = tracefs_create_dir(name, trace_instance_dir);\n\tif (!tr->dir)\n\t\tgoto out_free_tr;\n\n\tret = event_trace_add_tracer(tr->dir, tr);\n\tif (ret) {\n\t\ttracefs_remove_recursive(tr->dir);\n\t\tgoto out_free_tr;\n\t}\n\n\tinit_tracer_tracefs(tr, tr->dir);\n\n\tlist_add(&tr->list, &ftrace_trace_arrays);\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n\n out_free_tr:\n\tfree_trace_buffers(tr);\n\tfree_cpumask_var(tr->tracing_cpumask);\n\tkfree(tr->name);\n\tkfree(tr);\n\n out_unlock:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n\n}\n\nstatic int instance_rmdir(const char *name)\n{\n\tstruct trace_array *tr;\n\tint found = 0;\n\tint ret;\n\n\tmutex_lock(&trace_types_lock);\n\n\tret = -enodev;\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr->name && strcmp(tr->name, name) == 0) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found)\n\t\tgoto out_unlock;\n\n\tret = -ebusy;\n\tif (tr->ref || (tr->current_trace && tr->current_trace->ref))\n\t\tgoto out_unlock;\n\n\tlist_del(&tr->list);\n\n\ttracing_set_nop(tr);\n\tevent_trace_del_tracer(tr);\n\tftrace_destroy_function_files(tr);\n\tdebugfs_remove_recursive(tr->dir);\n\tfree_trace_buffers(tr);\n\n\tkfree(tr->name);\n\tkfree(tr);\n\n\tret = 0;\n\n out_unlock:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic __init void create_trace_instances(struct dentry *d_tracer)\n{\n\ttrace_instance_dir = tracefs_create_instance_dir(\"", "1194": "\", rcu_bh_ctrlblk.qlen);\n\treturn 0;\n}\n\nstatic int show_tiny_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, show_tiny_stats, null);\n}\n\nstatic const struct file_operations show_tiny_stats_fops = {\n\t.owner = this_module,\n\t.open = show_tiny_stats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic struct dentry *rcudir;\n\nstatic int __init rcutiny_trace_init(void)\n{\n\tstruct dentry *retval;\n\n\trcudir = debugfs_create_dir(\"", "1195": "\", rcu_sched_ctrlblk.qlen);\n\tseq_printf(m, \"", "1196": "\", read);\n}\n\nvoid __init sched_clock_postinit(void)\n{\n\t\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, bits_per_long, hz);\n\n\tupdate_sched_clock();\n\n\t\n\thrtimer_init(&sched_clock_timer, clock_monotonic, hrtimer_mode_rel);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, hrtimer_mode_rel);\n}\n\n\nstatic u64 notrace suspended_sched_clock_read(void)\n{\n\tunsigned long seq = raw_read_seqcount(&cd.seq);\n\n\treturn cd.read_data[seq & 1].epoch_cyc;\n}\n\nstatic int sched_clock_suspend(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\tupdate_sched_clock();\n\thrtimer_cancel(&sched_clock_timer);\n\trd->read_sched_clock = suspended_sched_clock_read;\n\n\treturn 0;\n}\n\nstatic void sched_clock_resume(void)\n{\n\tstruct clock_read_data *rd = &cd.read_data[0];\n\n\trd->epoch_cyc = cd.actual_read_sched_clock();\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, hrtimer_mode_rel);\n\trd->read_sched_clock = cd.actual_read_sched_clock;\n}\n\nstatic struct syscore_ops sched_clock_ops = {\n\t.suspend\t= sched_clock_suspend,\n\t.resume\t\t= sched_clock_resume,\n};\n\nstatic int __init sched_clock_syscore_init(void)\n{\n\tregister_syscore_ops(&sched_clock_ops);\n\n\treturn 0;\n}\ndevice_initcall(sched_clock_syscore_init);\n#ifndef __trace_events_h\n#define __trace_events_h\n\n#include <linux/trace_seq.h>\n#include \"", "1197": "\", rec->%s\"", "1198": "\", ret);\n\n\t\n\tjump_label_rate_limit(&perf_sched_events, hz);\n\n\t\n\tbuild_bug_on((offsetof(struct perf_event_mmap_page, data_head))\n\t\t     != 1024);\n}\n\nssize_t perf_event_sysfs_show(struct device *dev, struct device_attribute *attr,\n\t\t\t      char *page)\n{\n\tstruct perf_pmu_events_attr *pmu_attr =\n\t\tcontainer_of(attr, struct perf_pmu_events_attr, attr);\n\n\tif (pmu_attr->event_str)\n\t\treturn sprintf(page, \"", "1199": "\", ret);\n\n\treturn 0;\n}\n\nstatic int noop_count(struct lock_list *entry, void *data)\n{\n\t(*(unsigned long *)data)++;\n\treturn 0;\n}\n\nstatic unsigned long __lockdep_count_forward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_forwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}\nunsigned long lockdep_count_forward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = null;\n\tthis.class = class;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_forward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\nstatic unsigned long __lockdep_count_backward_deps(struct lock_list *this)\n{\n\tunsigned long  count = 0;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\t__bfs_backwards(this, (void *)&count, noop_count, &target_entry);\n\n\treturn count;\n}\n\nunsigned long lockdep_count_backward_deps(struct lock_class *class)\n{\n\tunsigned long ret, flags;\n\tstruct lock_list this;\n\n\tthis.parent = null;\n\tthis.class = class;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&lockdep_lock);\n\tret = __lockdep_count_backward_deps(&this);\n\tarch_spin_unlock(&lockdep_lock);\n\tlocal_irq_restore(flags);\n\n\treturn ret;\n}\n\n\nstatic noinline int\ncheck_noncircular(struct lock_list *root, struct lock_class *target,\n\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_cyclic_checks);\n\n\tresult = __bfs_forwards(root, target, class_equal, target_entry);\n\n\treturn result;\n}\n\n#if defined(config_trace_irqflags) && defined(config_prove_locking)\n\n\nstatic inline int usage_match(struct lock_list *entry, void *bit)\n{\n\treturn entry->class->usage_mask & (1 << (enum lock_usage_bit)bit);\n}\n\n\n\n\nstatic int\nfind_usage_forwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_forwards_checks);\n\n\tresult = __bfs_forwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}\n\n\nstatic int\nfind_usage_backwards(struct lock_list *root, enum lock_usage_bit bit,\n\t\t\tstruct lock_list **target_entry)\n{\n\tint result;\n\n\tdebug_atomic_inc(nr_find_usage_backwards_checks);\n\n\tresult = __bfs_backwards(root, (void *)bit, usage_match, target_entry);\n\n\treturn result;\n}\n\nstatic void print_lock_class_header(struct lock_class *class, int depth)\n{\n\tint bit;\n\n\tprintk(\"", "1200": "\", ret,\n\t\t\t\tq->pi_state->pi_mutex.owner,\n\t\t\t\tq->pi_state->owner);\n\nout:\n\treturn ret ? ret : locked;\n}\n\n\nstatic void futex_wait_queue_me(struct futex_hash_bucket *hb, struct futex_q *q,\n\t\t\t\tstruct hrtimer_sleeper *timeout)\n{\n\t\n\tset_current_state(task_interruptible);\n\tqueue_me(q, hb);\n\n\t\n\tif (timeout) {\n\t\thrtimer_start_expires(&timeout->timer, hrtimer_mode_abs);\n\t\tif (!hrtimer_active(&timeout->timer))\n\t\t\ttimeout->task = null;\n\t}\n\n\t\n\tif (likely(!plist_node_empty(&q->list))) {\n\t\t\n\t\tif (!timeout || timeout->task)\n\t\t\tfreezable_schedule();\n\t}\n\t__set_current_state(task_running);\n}\n\n\nstatic int futex_wait_setup(u32 __user *uaddr, u32 val, unsigned int flags,\n\t\t\t   struct futex_q *q, struct futex_hash_bucket **hb)\n{\n\tu32 uval;\n\tint ret;\n\n\t\nretry:\n\tret = get_futex_key(uaddr, flags & flags_shared, &q->key, verify_read);\n\tif (unlikely(ret != 0))\n\t\treturn ret;\n\nretry_private:\n\t*hb = queue_lock(q);\n\n\tret = get_futex_value_locked(&uval, uaddr);\n\n\tif (ret) {\n\t\tqueue_unlock(*hb);\n\n\t\tret = get_user(uval, uaddr);\n\t\tif (ret)\n\t\t\tgoto out;\n\n\t\tif (!(flags & flags_shared))\n\t\t\tgoto retry_private;\n\n\t\tput_futex_key(&q->key);\n\t\tgoto retry;\n\t}\n\n\tif (uval != val) {\n\t\tqueue_unlock(*hb);\n\t\tret = -ewouldblock;\n\t}\n\nout:\n\tif (ret)\n\t\tput_futex_key(&q->key);\n\treturn ret;\n}\n\nstatic int futex_wait(u32 __user *uaddr, unsigned int flags, u32 val,\n\t\t      ktime_t *abs_time, u32 bitset)\n{\n\tstruct hrtimer_sleeper timeout, *to = null;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint ret;\n\n\tif (!bitset)\n\t\treturn -einval;\n\tq.bitset = bitset;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\n\t\thrtimer_init_on_stack(&to->timer, (flags & flags_clockrt) ?\n\t\t\t\t      clock_realtime : clock_monotonic,\n\t\t\t\t      hrtimer_mode_abs);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\nretry:\n\t\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\n\t\n\tfutex_wait_queue_me(hb, &q, to);\n\n\t\n\tret = 0;\n\t\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -etimedout;\n\tif (to && !to->task)\n\t\tgoto out;\n\n\t\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\n\tret = -erestartsys;\n\tif (!abs_time)\n\t\tgoto out;\n\n\trestart = &current->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = flags | flags_has_timeout;\n\n\tret = -erestart_restartblock;\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n\n\nstatic long futex_wait_restart(struct restart_block *restart)\n{\n\tu32 __user *uaddr = restart->futex.uaddr;\n\tktime_t t, *tp = null;\n\n\tif (restart->futex.flags & flags_has_timeout) {\n\t\tt.tv64 = restart->futex.time;\n\t\ttp = &t;\n\t}\n\trestart->fn = do_no_restart_syscall;\n\n\treturn (long)futex_wait(uaddr, restart->futex.flags,\n\t\t\t\trestart->futex.val, tp, restart->futex.bitset);\n}\n\n\n\nstatic int futex_lock_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t ktime_t *time, int trylock)\n{\n\tstruct hrtimer_sleeper timeout, *to = null;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (refill_pi_state_cache())\n\t\treturn -enomem;\n\n\tif (time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clock_realtime,\n\t\t\t\t      hrtimer_mode_abs);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires(&to->timer, *time);\n\t}\n\nretry:\n\tret = get_futex_key(uaddr, flags & flags_shared, &q.key, verify_write);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\nretry_private:\n\thb = queue_lock(&q);\n\n\tret = futex_lock_pi_atomic(uaddr, hb, &q.key, &q.pi_state, current, 0);\n\tif (unlikely(ret)) {\n\t\tswitch (ret) {\n\t\tcase 1:\n\t\t\t\n\t\t\tret = 0;\n\t\t\tgoto out_unlock_put_key;\n\t\tcase -efault:\n\t\t\tgoto uaddr_faulted;\n\t\tcase -eagain:\n\t\t\t\n\t\t\tqueue_unlock(hb);\n\t\t\tput_futex_key(&q.key);\n\t\t\tcond_resched();\n\t\t\tgoto retry;\n\t\tdefault:\n\t\t\tgoto out_unlock_put_key;\n\t\t}\n\t}\n\n\t\n\tqueue_me(&q, hb);\n\n\twarn_on(!q.pi_state);\n\t\n\tif (!trylock) {\n\t\tret = rt_mutex_timed_futex_lock(&q.pi_state->pi_mutex, to);\n\t} else {\n\t\tret = rt_mutex_trylock(&q.pi_state->pi_mutex);\n\t\t\n\t\tret = ret ? 0 : -ewouldblock;\n\t}\n\n\tspin_lock(q.lock_ptr);\n\t\n\tres = fixup_owner(uaddr, &q, !ret);\n\t\n\tif (res)\n\t\tret = (res < 0) ? res : 0;\n\n\t\n\tif (ret && (rt_mutex_owner(&q.pi_state->pi_mutex) == current))\n\t\trt_mutex_unlock(&q.pi_state->pi_mutex);\n\n\t\n\tunqueue_me_pi(&q);\n\n\tgoto out_put_key;\n\nout_unlock_put_key:\n\tqueue_unlock(hb);\n\nout_put_key:\n\tput_futex_key(&q.key);\nout:\n\tif (to)\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\treturn ret != -eintr ? ret : -erestartnointr;\n\nuaddr_faulted:\n\tqueue_unlock(hb);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (ret)\n\t\tgoto out_put_key;\n\n\tif (!(flags & flags_shared))\n\t\tgoto retry_private;\n\n\tput_futex_key(&q.key);\n\tgoto retry;\n}\n\n\nstatic int futex_unlock_pi(u32 __user *uaddr, unsigned int flags)\n{\n\tu32 uninitialized_var(curval), uval, vpid = task_pid_vnr(current);\n\tunion futex_key key = futex_key_init;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q *match;\n\tint ret;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -efault;\n\t\n\tif ((uval & futex_tid_mask) != vpid)\n\t\treturn -eperm;\n\n\tret = get_futex_key(uaddr, flags & flags_shared, &key, verify_write);\n\tif (ret)\n\t\treturn ret;\n\n\thb = hash_futex(&key);\n\tspin_lock(&hb->lock);\n\n\t\n\tmatch = futex_top_waiter(hb, &key);\n\tif (match) {\n\t\tret = wake_futex_pi(uaddr, uval, match);\n\t\t\n\t\tif (ret == -efault)\n\t\t\tgoto pi_faulted;\n\t\tgoto out_unlock;\n\t}\n\n\t\n\tif (cmpxchg_futex_value_locked(&curval, uaddr, uval, 0))\n\t\tgoto pi_faulted;\n\n\t\n\tret = (curval == uval) ? 0 : -eagain;\n\nout_unlock:\n\tspin_unlock(&hb->lock);\n\tput_futex_key(&key);\n\treturn ret;\n\npi_faulted:\n\tspin_unlock(&hb->lock);\n\tput_futex_key(&key);\n\n\tret = fault_in_user_writeable(uaddr);\n\tif (!ret)\n\t\tgoto retry;\n\n\treturn ret;\n}\n\n\nstatic inline\nint handle_early_requeue_pi_wakeup(struct futex_hash_bucket *hb,\n\t\t\t\t   struct futex_q *q, union futex_key *key2,\n\t\t\t\t   struct hrtimer_sleeper *timeout)\n{\n\tint ret = 0;\n\n\t\n\tif (!match_futex(&q->key, key2)) {\n\t\twarn_on(q->lock_ptr && (&hb->lock != q->lock_ptr));\n\t\t\n\t\tplist_del(&q->list, &hb->chain);\n\t\thb_waiters_dec(hb);\n\n\t\t\n\t\tret = -ewouldblock;\n\t\tif (timeout && !timeout->task)\n\t\t\tret = -etimedout;\n\t\telse if (signal_pending(current))\n\t\t\tret = -erestartnointr;\n\t}\n\treturn ret;\n}\n\n\nstatic int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,\n\t\t\t\t u32 val, ktime_t *abs_time, u32 bitset,\n\t\t\t\t u32 __user *uaddr2)\n{\n\tstruct hrtimer_sleeper timeout, *to = null;\n\tstruct rt_mutex_waiter rt_waiter;\n\tstruct rt_mutex *pi_mutex = null;\n\tstruct futex_hash_bucket *hb;\n\tunion futex_key key2 = futex_key_init;\n\tstruct futex_q q = futex_q_init;\n\tint res, ret;\n\n\tif (uaddr == uaddr2)\n\t\treturn -einval;\n\n\tif (!bitset)\n\t\treturn -einval;\n\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, (flags & flags_clockrt) ?\n\t\t\t\t      clock_realtime : clock_monotonic,\n\t\t\t\t      hrtimer_mode_abs);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\n\n\t\n\tdebug_rt_mutex_init_waiter(&rt_waiter);\n\trb_clear_node(&rt_waiter.pi_tree_entry);\n\trb_clear_node(&rt_waiter.tree_entry);\n\trt_waiter.task = null;\n\n\tret = get_futex_key(uaddr2, flags & flags_shared, &key2, verify_write);\n\tif (unlikely(ret != 0))\n\t\tgoto out;\n\n\tq.bitset = bitset;\n\tq.rt_waiter = &rt_waiter;\n\tq.requeue_pi_key = &key2;\n\n\t\n\tret = futex_wait_setup(uaddr, val, flags, &q, &hb);\n\tif (ret)\n\t\tgoto out_key2;\n\n\t\n\tif (match_futex(&q.key, &key2)) {\n\t\tqueue_unlock(hb);\n\t\tret = -einval;\n\t\tgoto out_put_keys;\n\t}\n\n\t\n\tfutex_wait_queue_me(hb, &q, to);\n\n\tspin_lock(&hb->lock);\n\tret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);\n\tspin_unlock(&hb->lock);\n\tif (ret)\n\t\tgoto out_put_keys;\n\n\t\n\n\t\n\tif (!q.rt_waiter) {\n\t\t\n\t\tif (q.pi_state && (q.pi_state->owner != current)) {\n\t\t\tspin_lock(q.lock_ptr);\n\t\t\tret = fixup_pi_state_owner(uaddr2, &q, current);\n\t\t\tspin_unlock(q.lock_ptr);\n\t\t}\n\t} else {\n\t\t\n\t\twarn_on(!q.pi_state);\n\t\tpi_mutex = &q.pi_state->pi_mutex;\n\t\tret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter);\n\t\tdebug_rt_mutex_free_waiter(&rt_waiter);\n\n\t\tspin_lock(q.lock_ptr);\n\t\t\n\t\tres = fixup_owner(uaddr2, &q, !ret);\n\t\t\n\t\tif (res)\n\t\t\tret = (res < 0) ? res : 0;\n\n\t\t\n\t\tunqueue_me_pi(&q);\n\t}\n\n\t\n\tif (ret == -efault) {\n\t\tif (pi_mutex && rt_mutex_owner(pi_mutex) == current)\n\t\t\trt_mutex_unlock(pi_mutex);\n\t} else if (ret == -eintr) {\n\t\t\n\t\tret = -ewouldblock;\n\t}\n\nout_put_keys:\n\tput_futex_key(&q.key);\nout_key2:\n\tput_futex_key(&key2);\n\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}\n\n\n\n\nsyscall_define2(set_robust_list, struct robust_list_head __user *, head,\n\t\tsize_t, len)\n{\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -enosys;\n\t\n\tif (unlikely(len != sizeof(*head)))\n\t\treturn -einval;\n\n\tcurrent->robust_list = head;\n\n\treturn 0;\n}\n\n\nsyscall_define3(get_robust_list, int, pid,\n\t\tstruct robust_list_head __user * __user *, head_ptr,\n\t\tsize_t __user *, len_ptr)\n{\n\tstruct robust_list_head __user *head;\n\tunsigned long ret;\n\tstruct task_struct *p;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn -enosys;\n\n\trcu_read_lock();\n\n\tret = -esrch;\n\tif (!pid)\n\t\tp = current;\n\telse {\n\t\tp = find_task_by_vpid(pid);\n\t\tif (!p)\n\t\t\tgoto err_unlock;\n\t}\n\n\tret = -eperm;\n\tif (!ptrace_may_access(p, ptrace_mode_read))\n\t\tgoto err_unlock;\n\n\thead = p->robust_list;\n\trcu_read_unlock();\n\n\tif (put_user(sizeof(*head), len_ptr))\n\t\treturn -efault;\n\treturn put_user(head, head_ptr);\n\nerr_unlock:\n\trcu_read_unlock();\n\n\treturn ret;\n}\n\n\nint handle_futex_death(u32 __user *uaddr, struct task_struct *curr, int pi)\n{\n\tu32 uval, uninitialized_var(nval), mval;\n\nretry:\n\tif (get_user(uval, uaddr))\n\t\treturn -1;\n\n\tif ((uval & futex_tid_mask) == task_pid_vnr(curr)) {\n\t\t\n\t\tmval = (uval & futex_waiters) | futex_owner_died;\n\t\t\n\t\tif (cmpxchg_futex_value_locked(&nval, uaddr, uval, mval)) {\n\t\t\tif (fault_in_user_writeable(uaddr))\n\t\t\t\treturn -1;\n\t\t\tgoto retry;\n\t\t}\n\t\tif (nval != uval)\n\t\t\tgoto retry;\n\n\t\t\n\t\tif (!pi && (uval & futex_waiters))\n\t\t\tfutex_wake(uaddr, 1, 1, futex_bitset_match_any);\n\t}\n\treturn 0;\n}\n\n\nstatic inline int fetch_robust_entry(struct robust_list __user **entry,\n\t\t\t\t     struct robust_list __user * __user *head,\n\t\t\t\t     unsigned int *pi)\n{\n\tunsigned long uentry;\n\n\tif (get_user(uentry, (unsigned long __user *)head))\n\t\treturn -efault;\n\n\t*entry = (void __user *)(uentry & ~1ul);\n\t*pi = uentry & 1;\n\n\treturn 0;\n}\n\n\nvoid exit_robust_list(struct task_struct *curr)\n{\n\tstruct robust_list_head __user *head = curr->robust_list;\n\tstruct robust_list __user *entry, *next_entry, *pending;\n\tunsigned int limit = robust_list_limit, pi, pip;\n\tunsigned int uninitialized_var(next_pi);\n\tunsigned long futex_offset;\n\tint rc;\n\n\tif (!futex_cmpxchg_enabled)\n\t\treturn;\n\n\t\n\tif (fetch_robust_entry(&entry, &head->list.next, &pi))\n\t\treturn;\n\t\n\tif (get_user(futex_offset, &head->futex_offset))\n\t\treturn;\n\t\n\tif (fetch_robust_entry(&pending, &head->list_op_pending, &pip))\n\t\treturn;\n\n\tnext_entry = null;\t\n\twhile (entry != &head->list) {\n\t\t\n\t\trc = fetch_robust_entry(&next_entry, &entry->next, &next_pi);\n\t\t\n\t\tif (entry != pending)\n\t\t\tif (handle_futex_death((void __user *)entry + futex_offset,\n\t\t\t\t\t\tcurr, pi))\n\t\t\t\treturn;\n\t\tif (rc)\n\t\t\treturn;\n\t\tentry = next_entry;\n\t\tpi = next_pi;\n\t\t\n\t\tif (!--limit)\n\t\t\tbreak;\n\n\t\tcond_resched();\n\t}\n\n\tif (pending)\n\t\thandle_futex_death((void __user *)pending + futex_offset,\n\t\t\t\t   curr, pip);\n}\n\nlong do_futex(u32 __user *uaddr, int op, u32 val, ktime_t *timeout,\n\t\tu32 __user *uaddr2, u32 val2, u32 val3)\n{\n\tint cmd = op & futex_cmd_mask;\n\tunsigned int flags = 0;\n\n\tif (!(op & futex_private_flag))\n\t\tflags |= flags_shared;\n\n\tif (op & futex_clock_realtime) {\n\t\tflags |= flags_clockrt;\n\t\tif (cmd != futex_wait_bitset && cmd != futex_wait_requeue_pi)\n\t\t\treturn -enosys;\n\t}\n\n\tswitch (cmd) {\n\tcase futex_lock_pi:\n\tcase futex_unlock_pi:\n\tcase futex_trylock_pi:\n\tcase futex_wait_requeue_pi:\n\tcase futex_cmp_requeue_pi:\n\t\tif (!futex_cmpxchg_enabled)\n\t\t\treturn -enosys;\n\t}\n\n\tswitch (cmd) {\n\tcase futex_wait:\n\t\tval3 = futex_bitset_match_any;\n\tcase futex_wait_bitset:\n\t\treturn futex_wait(uaddr, flags, val, timeout, val3);\n\tcase futex_wake:\n\t\tval3 = futex_bitset_match_any;\n\tcase futex_wake_bitset:\n\t\treturn futex_wake(uaddr, flags, val, val3);\n\tcase futex_requeue:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, null, 0);\n\tcase futex_cmp_requeue:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 0);\n\tcase futex_wake_op:\n\t\treturn futex_wake_op(uaddr, flags, uaddr2, val, val2, val3);\n\tcase futex_lock_pi:\n\t\treturn futex_lock_pi(uaddr, flags, timeout, 0);\n\tcase futex_unlock_pi:\n\t\treturn futex_unlock_pi(uaddr, flags);\n\tcase futex_trylock_pi:\n\t\treturn futex_lock_pi(uaddr, flags, null, 1);\n\tcase futex_wait_requeue_pi:\n\t\tval3 = futex_bitset_match_any;\n\t\treturn futex_wait_requeue_pi(uaddr, flags, val, timeout, val3,\n\t\t\t\t\t     uaddr2);\n\tcase futex_cmp_requeue_pi:\n\t\treturn futex_requeue(uaddr, flags, uaddr2, val, val2, &val3, 1);\n\t}\n\treturn -enosys;\n}\n\n\nsyscall_define6(futex, u32 __user *, uaddr, int, op, u32, val,\n\t\tstruct timespec __user *, utime, u32 __user *, uaddr2,\n\t\tu32, val3)\n{\n\tstruct timespec ts;\n\tktime_t t, *tp = null;\n\tu32 val2 = 0;\n\tint cmd = op & futex_cmd_mask;\n\n\tif (utime && (cmd == futex_wait || cmd == futex_lock_pi ||\n\t\t      cmd == futex_wait_bitset ||\n\t\t      cmd == futex_wait_requeue_pi)) {\n\t\tif (copy_from_user(&ts, utime, sizeof(ts)) != 0)\n\t\t\treturn -efault;\n\t\tif (!timespec_valid(&ts))\n\t\t\treturn -einval;\n\n\t\tt = timespec_to_ktime(ts);\n\t\tif (cmd == futex_wait)\n\t\t\tt = ktime_add_safe(ktime_get(), t);\n\t\ttp = &t;\n\t}\n\t\n\tif (cmd == futex_requeue || cmd == futex_cmp_requeue ||\n\t    cmd == futex_cmp_requeue_pi || cmd == futex_wake_op)\n\t\tval2 = (u32) (unsigned long) utime;\n\n\treturn do_futex(uaddr, op, val, tp, uaddr2, val2, val3);\n}\n\nstatic void __init futex_detect_cmpxchg(void)\n{\n#ifndef config_have_futex_cmpxchg\n\tu32 curval;\n\n\t\n\tif (cmpxchg_futex_value_locked(&curval, null, 0, 0) == -efault)\n\t\tfutex_cmpxchg_enabled = 1;\n#endif\n}\n\nstatic int __init futex_init(void)\n{\n\tunsigned int futex_shift;\n\tunsigned long i;\n\n#if config_base_small\n\tfutex_hashsize = 16;\n#else\n\tfutex_hashsize = roundup_pow_of_two(256 * num_possible_cpus());\n#endif\n\n\tfutex_queues = alloc_large_system_hash(\"", "1201": "\", s->buffer);\n\n\ttrace_seq_init(s);\n}\n\nvoid trace_init_global_iter(struct trace_iterator *iter)\n{\n\titer->tr = &global_trace;\n\titer->trace = iter->tr->current_trace;\n\titer->cpu_file = ring_buffer_all_cpus;\n\titer->trace_buffer = &global_trace.trace_buffer;\n\n\tif (iter->trace && iter->trace->open)\n\t\titer->trace->open(iter);\n\n\t\n\tif (ring_buffer_overruns(iter->trace_buffer->buffer))\n\t\titer->iter_flags |= trace_file_annotate;\n\n\t\n\tif (trace_clocks[iter->tr->clock_id].in_ns)\n\t\titer->iter_flags |= trace_file_time_in_ns;\n}\n\nvoid ftrace_dump(enum ftrace_dump_mode oops_dump_mode)\n{\n\t\n\tstatic struct trace_iterator iter;\n\tstatic atomic_t dump_running;\n\tunsigned int old_userobj;\n\tunsigned long flags;\n\tint cnt = 0, cpu;\n\n\t\n\tif (atomic_inc_return(&dump_running) != 1) {\n\t\tatomic_dec(&dump_running);\n\t\treturn;\n\t}\n\n\t\n\ttracing_off();\n\n\tlocal_irq_save(flags);\n\n\t\n\ttrace_init_global_iter(&iter);\n\n\tfor_each_tracing_cpu(cpu) {\n\t\tatomic_inc(&per_cpu_ptr(iter.tr->trace_buffer.data, cpu)->disabled);\n\t}\n\n\told_userobj = trace_flags & trace_iter_sym_userobj;\n\n\t\n\ttrace_flags &= ~trace_iter_sym_userobj;\n\n\tswitch (oops_dump_mode) {\n\tcase dump_all:\n\t\titer.cpu_file = ring_buffer_all_cpus;\n\t\tbreak;\n\tcase dump_orig:\n\t\titer.cpu_file = raw_smp_processor_id();\n\t\tbreak;\n\tcase dump_none:\n\t\tgoto out_enable;\n\tdefault:\n\t\tprintk(kern_trace \"", "1202": "\", s_irugo, null,\n\t\t\t\t null, &virq_debug_fops) == null)\n\t\treturn -enomem;\n\n\treturn 0;\n}\n__initcall(irq_debugfs_init);\n#endif \n\n\nint irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (warn_on(intsize < 1))\n\t\treturn -einval;\n\t*out_hwirq = intspec[0];\n\t*out_type = irq_type_none;\n\treturn 0;\n}\nexport_symbol_gpl(irq_domain_xlate_onecell);\n\n\nint irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tif (warn_on(intsize < 2))\n\t\treturn -einval;\n\t*out_hwirq = intspec[0];\n\t*out_type = intspec[1] & irq_type_sense_mask;\n\treturn 0;\n}\nexport_symbol_gpl(irq_domain_xlate_twocell);\n\n\nint irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (warn_on(intsize < 1))\n\t\treturn -einval;\n\t*out_hwirq = intspec[0];\n\t*out_type = (intsize > 1) ? intspec[1] : irq_type_none;\n\treturn 0;\n}\nexport_symbol_gpl(irq_domain_xlate_onetwocell);\n\nconst struct irq_domain_ops irq_domain_simple_ops = {\n\t.xlate = irq_domain_xlate_onetwocell,\n};\nexport_symbol_gpl(irq_domain_simple_ops);\n\nstatic int irq_domain_alloc_descs(int virq, unsigned int cnt,\n\t\t\t\t  irq_hw_number_t hwirq, int node)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = irq_alloc_descs(virq, virq, cnt, node);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = irq_alloc_descs_from(hint, cnt, node);\n\t\tif (virq <= 0 && hint > 1)\n\t\t\tvirq = irq_alloc_descs_from(1, cnt, node);\n\t}\n\n\treturn virq;\n}\n\n#ifdef\tconfig_irq_domain_hierarchy\n\nstruct irq_domain *irq_domain_add_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct device_node *node,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_add_linear(node, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_add_tree(node, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tif (hwirq < domain->revmap_size) {\n\t\t\tdomain->linear_revmap[hwirq] = virq;\n\t\t} else {\n\t\t\tmutex_lock(&revmap_trees_mutex);\n\t\t\tradix_tree_insert(&domain->revmap_tree, hwirq, data);\n\t\t\tmutex_unlock(&revmap_trees_mutex);\n\t\t}\n\n\t\t\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, irq_norequest);\n}\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, irq_norequest);\n\tirq_set_chip_and_handler(virq, null, null);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tif (hwirq < domain->revmap_size) {\n\t\t\tdomain->linear_revmap[hwirq] = 0;\n\t\t} else {\n\t\t\tmutex_lock(&revmap_trees_mutex);\n\t\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\t\tmutex_unlock(&revmap_trees_mutex);\n\t\t}\n\t}\n}\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), gfp_kernel, child->node);\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->node = child->node;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = null;\n\t\tirq_data->domain = null;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -enomem;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn null;\n}\n\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -enoent;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}\n\n\nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}\n\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = null;\n}\n\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}\n\n\nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, null);\n\t\tirq_set_handler(virq + i, null);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}\n\nstatic bool irq_domain_is_auto_recursive(struct irq_domain *domain)\n{\n\treturn domain->flags & irq_domain_flag_auto_recursive;\n}\n\nstatic void irq_domain_free_irqs_recursive(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tdomain->ops->free(domain, irq_base, nr_irqs);\n\tif (irq_domain_is_auto_recursive(domain)) {\n\t\tbug_on(!domain->parent);\n\t\tirq_domain_free_irqs_recursive(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs);\n\t}\n}\n\nstatic int irq_domain_alloc_irqs_recursive(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs, void *arg)\n{\n\tint ret = 0;\n\tstruct irq_domain *parent = domain->parent;\n\tbool recursive = irq_domain_is_auto_recursive(domain);\n\n\tbug_on(recursive && !parent);\n\tif (recursive)\n\t\tret = irq_domain_alloc_irqs_recursive(parent, irq_base,\n\t\t\t\t\t\t      nr_irqs, arg);\n\tif (ret >= 0)\n\t\tret = domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n\tif (ret < 0 && recursive)\n\t\tirq_domain_free_irqs_recursive(parent, irq_base, nr_irqs);\n\n\treturn ret;\n}\n\n\nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc)\n{\n\tint i, ret, virq;\n\n\tif (domain == null) {\n\t\tdomain = irq_default_domain;\n\t\tif (warn(!domain, \"", "1203": "\", savedcmd->cmdline_num);\n\tarch_spin_unlock(&trace_cmdline_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic void free_saved_cmdlines_buffer(struct saved_cmdlines_buffer *s)\n{\n\tkfree(s->saved_cmdlines);\n\tkfree(s->map_cmdline_to_pid);\n\tkfree(s);\n}\n\nstatic int tracing_resize_saved_cmdlines(unsigned int val)\n{\n\tstruct saved_cmdlines_buffer *s, *savedcmd_temp;\n\n\ts = kmalloc(sizeof(*s), gfp_kernel);\n\tif (!s)\n\t\treturn -enomem;\n\n\tif (allocate_cmdlines_buffer(val, s) < 0) {\n\t\tkfree(s);\n\t\treturn -enomem;\n\t}\n\n\tarch_spin_lock(&trace_cmdline_lock);\n\tsavedcmd_temp = savedcmd;\n\tsavedcmd = s;\n\tarch_spin_unlock(&trace_cmdline_lock);\n\tfree_saved_cmdlines_buffer(savedcmd_temp);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_saved_cmdlines_size_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t  size_t cnt, loff_t *ppos)\n{\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\t\n\tif (!val || val > pid_max_default)\n\t\treturn -einval;\n\n\tret = tracing_resize_saved_cmdlines((unsigned int)val);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations tracing_saved_cmdlines_size_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= tracing_saved_cmdlines_size_read,\n\t.write\t\t= tracing_saved_cmdlines_size_write,\n};\n\n#ifdef config_trace_enum_map_file\nstatic union trace_enum_map_item *\nupdate_enum_map(union trace_enum_map_item *ptr)\n{\n\tif (!ptr->map.enum_string) {\n\t\tif (ptr->tail.next) {\n\t\t\tptr = ptr->tail.next;\n\t\t\t\n\t\t\tptr++;\n\t\t} else\n\t\t\treturn null;\n\t}\n\treturn ptr;\n}\n\nstatic void *enum_map_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tunion trace_enum_map_item *ptr = v;\n\n\t\n\tptr = update_enum_map(ptr);\n\tif (warn_on_once(!ptr))\n\t\treturn null;\n\n\tptr++;\n\n\t(*pos)++;\n\n\tptr = update_enum_map(ptr);\n\n\treturn ptr;\n}\n\nstatic void *enum_map_start(struct seq_file *m, loff_t *pos)\n{\n\tunion trace_enum_map_item *v;\n\tloff_t l = 0;\n\n\tmutex_lock(&trace_enum_mutex);\n\n\tv = trace_enum_maps;\n\tif (v)\n\t\tv++;\n\n\twhile (v && l < *pos) {\n\t\tv = enum_map_next(m, v, &l);\n\t}\n\n\treturn v;\n}\n\nstatic void enum_map_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&trace_enum_mutex);\n}\n\nstatic int enum_map_show(struct seq_file *m, void *v)\n{\n\tunion trace_enum_map_item *ptr = v;\n\n\tseq_printf(m, \"", "1204": "\", scancode);\n\t}\n\tkeychar &= 0x0fff;\n\tif (keychar == '\\t')\n\t\tkeychar = ' ';\n\tswitch (ktyp(keychar)) {\n\tcase kt_letter:\n\tcase kt_latin:\n\t\tif (isprint(keychar))\n\t\t\tbreak;\t\t\n\t\t\n\tcase kt_spec:\n\t\tif (keychar == k_enter)\n\t\t\tbreak;\n\t\t\n\tdefault:\n\t\treturn -1;\t\n\t}\n\n\tif (scancode == 0x1c) {\n\t\tkbd_last_ret = 1;\n\t\treturn 13;\n\t}\n\n\treturn keychar & 0xff;\n}\nexport_symbol_gpl(kdb_get_kbd_char);\n\n\nvoid kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t\n\n\twhile (1) {\n\t\twhile ((inb(kbd_status_reg) & kbd_stat_obf) == 0)\n\t\t\tcpu_relax();\n\n\t\t\n\t\tscancode = inb(kbd_data_reg);\n\t\tscanstatus = inb(kbd_status_reg);\n\n\t\t\n\t\tif (scanstatus & kbd_stat_mouse_obf)\n\t\t\tcontinue;\n\n\t\t\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}\n\n\n#include <linux/string.h>\n#include <linux/delay.h>\n#include <linux/errno.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/cpu.h>\n#include <linux/cpuidle.h>\n#include <linux/syscalls.h>\n#include <linux/gfp.h>\n#include <linux/io.h>\n#include <linux/kernel.h>\n#include <linux/list.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/syscore_ops.h>\n#include <linux/ftrace.h>\n#include <trace/events/power.h>\n#include <linux/compiler.h>\n#include <linux/moduleparam.h>\n\n#include \"", "1205": "\", set_ftrace_filter);\n\n#ifdef config_function_graph_tracer\nstatic char ftrace_graph_buf[ftrace_filter_size] __initdata;\nstatic char ftrace_graph_notrace_buf[ftrace_filter_size] __initdata;\nstatic int ftrace_set_func(unsigned long *array, int *idx, int size, char *buffer);\n\nstatic unsigned long save_global_trampoline;\nstatic unsigned long save_global_flags;\n\nstatic int __init set_graph_function(char *str)\n{\n\tstrlcpy(ftrace_graph_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"", "1206": "\", set_ftrace_notrace);\n\nstatic int __init set_ftrace_filter(char *str)\n{\n\tftrace_filter_param = true;\n\tstrlcpy(ftrace_filter_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"", "1207": "\", set_graph_function);\n\nstatic int __init set_graph_notrace_function(char *str)\n{\n\tstrlcpy(ftrace_graph_notrace_buf, str, ftrace_filter_size);\n\treturn 1;\n}\n__setup(\"", "1208": "\", set_graph_notrace_function);\n\nstatic void __init set_ftrace_early_graph(char *buf, int enable)\n{\n\tint ret;\n\tchar *func;\n\tunsigned long *table = ftrace_graph_funcs;\n\tint *count = &ftrace_graph_count;\n\n\tif (!enable) {\n\t\ttable = ftrace_graph_notrace_funcs;\n\t\tcount = &ftrace_graph_notrace_count;\n\t}\n\n\twhile (buf) {\n\t\tfunc = strsep(&buf, \"", "1209": "\", setup_hrtimer_hres);\n\n\nstatic inline int hrtimer_is_hres_enabled(void)\n{\n\treturn hrtimer_hres_enabled;\n}\n\n\nstatic inline int hrtimer_hres_active(void)\n{\n\treturn __this_cpu_read(hrtimer_bases.hres_active);\n}\n\n\nstatic void\nhrtimer_force_reprogram(struct hrtimer_cpu_base *cpu_base, int skip_equal)\n{\n\tktime_t expires_next = __hrtimer_get_next_event(cpu_base);\n\n\tif (skip_equal && expires_next.tv64 == cpu_base->expires_next.tv64)\n\t\treturn;\n\n\tcpu_base->expires_next.tv64 = expires_next.tv64;\n\n\t\n\tif (cpu_base->hang_detected)\n\t\treturn;\n\n\tif (cpu_base->expires_next.tv64 != ktime_max)\n\t\ttick_program_event(cpu_base->expires_next, 1);\n}\n\n\nstatic int hrtimer_reprogram(struct hrtimer *timer,\n\t\t\t     struct hrtimer_clock_base *base)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tktime_t expires = ktime_sub(hrtimer_get_expires(timer), base->offset);\n\tint res;\n\n\twarn_on_once(hrtimer_get_expires_tv64(timer) < 0);\n\n\t\n\tif (hrtimer_callback_running(timer))\n\t\treturn 0;\n\n\t\n\tif (expires.tv64 < 0)\n\t\treturn -etime;\n\n\tif (expires.tv64 >= cpu_base->expires_next.tv64)\n\t\treturn 0;\n\n\t\n\tif (cpu_base->in_hrtirq)\n\t\treturn 0;\n\n\t\n\tif (cpu_base->hang_detected)\n\t\treturn 0;\n\n\t\n\tres = tick_program_event(expires, 0);\n\tif (!is_err_value(res))\n\t\tcpu_base->expires_next = expires;\n\treturn res;\n}\n\n\nstatic inline void hrtimer_init_hres(struct hrtimer_cpu_base *base)\n{\n\tbase->expires_next.tv64 = ktime_max;\n\tbase->hres_active = 0;\n}\n\nstatic inline ktime_t hrtimer_update_base(struct hrtimer_cpu_base *base)\n{\n\tktime_t *offs_real = &base->clock_base[hrtimer_base_realtime].offset;\n\tktime_t *offs_boot = &base->clock_base[hrtimer_base_boottime].offset;\n\tktime_t *offs_tai = &base->clock_base[hrtimer_base_tai].offset;\n\n\treturn ktime_get_update_offsets_now(offs_real, offs_boot, offs_tai);\n}\n\n\nstatic void retrigger_next_event(void *arg)\n{\n\tstruct hrtimer_cpu_base *base = this_cpu_ptr(&hrtimer_bases);\n\n\tif (!hrtimer_hres_active())\n\t\treturn;\n\n\traw_spin_lock(&base->lock);\n\thrtimer_update_base(base);\n\thrtimer_force_reprogram(base, 0);\n\traw_spin_unlock(&base->lock);\n}\n\n\nstatic int hrtimer_switch_to_hres(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct hrtimer_cpu_base *base = &per_cpu(hrtimer_bases, cpu);\n\tunsigned long flags;\n\n\tif (base->hres_active)\n\t\treturn 1;\n\n\tlocal_irq_save(flags);\n\n\tif (tick_init_highres()) {\n\t\tlocal_irq_restore(flags);\n\t\tprintk(kern_warning \"", "1210": "\", size >> 10);\n\t\t} else\n\t\t\tr = sprintf(buf, \"", "1211": "\", size);\n\telse\n\t\tr = sprintf(buf, \"", "1212": "\", size, expanded_size);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic ssize_t\ntracing_free_buffer_write(struct file *filp, const char __user *ubuf,\n\t\t\t  size_t cnt, loff_t *ppos)\n{\n\t\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic int\ntracing_free_buffer_release(struct inode *inode, struct file *filp)\n{\n\tstruct trace_array *tr = inode->i_private;\n\n\t\n\tif (trace_flags & trace_iter_stop_on_free)\n\t\ttracer_tracing_off(tr);\n\t\n\ttracing_resize_ring_buffer(tr, 0, ring_buffer_all_cpus);\n\n\ttrace_array_put(tr);\n\n\treturn 0;\n}\n\nstatic ssize_t\ntracing_mark_write(struct file *filp, const char __user *ubuf,\n\t\t\t\t\tsize_t cnt, loff_t *fpos)\n{\n\tunsigned long addr = (unsigned long)ubuf;\n\tstruct trace_array *tr = filp->private_data;\n\tstruct ring_buffer_event *event;\n\tstruct ring_buffer *buffer;\n\tstruct print_entry *entry;\n\tunsigned long irq_flags;\n\tstruct page *pages[2];\n\tvoid *map_page[2];\n\tint nr_pages = 1;\n\tssize_t written;\n\tint offset;\n\tint size;\n\tint len;\n\tint ret;\n\tint i;\n\n\tif (tracing_disabled)\n\t\treturn -einval;\n\n\tif (!(trace_flags & trace_iter_markers))\n\t\treturn -einval;\n\n\tif (cnt > trace_buf_size)\n\t\tcnt = trace_buf_size;\n\n\t\n\tbuild_bug_on(trace_buf_size >= page_size);\n\n\t\n\tif ((addr & page_mask) != ((addr + cnt) & page_mask))\n\t\tnr_pages = 2;\n\n\toffset = addr & (page_size - 1);\n\taddr &= page_mask;\n\n\tret = get_user_pages_fast(addr, nr_pages, 0, pages);\n\tif (ret < nr_pages) {\n\t\twhile (--ret >= 0)\n\t\t\tput_page(pages[ret]);\n\t\twritten = -efault;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < nr_pages; i++)\n\t\tmap_page[i] = kmap_atomic(pages[i]);\n\n\tlocal_save_flags(irq_flags);\n\tsize = sizeof(*entry) + cnt + 2; \n\tbuffer = tr->trace_buffer.buffer;\n\tevent = trace_buffer_lock_reserve(buffer, trace_print, size,\n\t\t\t\t\t  irq_flags, preempt_count());\n\tif (!event) {\n\t\t\n\t\twritten = -ebadf;\n\t\tgoto out_unlock;\n\t}\n\n\tentry = ring_buffer_event_data(event);\n\tentry->ip = _this_ip_;\n\n\tif (nr_pages == 2) {\n\t\tlen = page_size - offset;\n\t\tmemcpy(&entry->buf, map_page[0] + offset, len);\n\t\tmemcpy(&entry->buf[len], map_page[1], cnt - len);\n\t} else\n\t\tmemcpy(&entry->buf, map_page[0] + offset, cnt);\n\n\tif (entry->buf[cnt - 1] != '\\n') {\n\t\tentry->buf[cnt] = '\\n';\n\t\tentry->buf[cnt + 1] = '\\0';\n\t} else\n\t\tentry->buf[cnt] = '\\0';\n\n\t__buffer_unlock_commit(buffer, event);\n\n\twritten = cnt;\n\n\t*fpos += written;\n\n out_unlock:\n\tfor (i = nr_pages - 1; i >= 0; i--) {\n\t\tkunmap_atomic(map_page[i]);\n\t\tput_page(pages[i]);\n\t}\n out:\n\treturn written;\n}\n\nstatic int tracing_clock_show(struct seq_file *m, void *v)\n{\n\tstruct trace_array *tr = m->private;\n\tint i;\n\n\tfor (i = 0; i < array_size(trace_clocks); i++)\n\t\tseq_printf(m,\n\t\t\t\"", "1213": "\", sleep_states_setup);\n\n\nvoid suspend_set_ops(const struct platform_suspend_ops *ops)\n{\n\tsuspend_state_t i;\n\tint j = 0;\n\n\tlock_system_sleep();\n\n\tsuspend_ops = ops;\n\tfor (i = pm_suspend_mem; i >= pm_suspend_standby; i--)\n\t\tif (valid_state(i)) {\n\t\t\tpm_states[i] = pm_labels[j++];\n\t\t} else if (!relative_states) {\n\t\t\tpm_states[i] = null;\n\t\t\tj++;\n\t\t}\n\n\tpm_states[pm_suspend_freeze] = pm_labels[j];\n\n\tunlock_system_sleep();\n}\nexport_symbol_gpl(suspend_set_ops);\n\n\nint suspend_valid_only_mem(suspend_state_t state)\n{\n\treturn state == pm_suspend_mem;\n}\nexport_symbol_gpl(suspend_valid_only_mem);\n\nstatic bool sleep_state_supported(suspend_state_t state)\n{\n\treturn state == pm_suspend_freeze || (suspend_ops && suspend_ops->enter);\n}\n\nstatic int platform_suspend_prepare(suspend_state_t state)\n{\n\treturn state != pm_suspend_freeze && suspend_ops->prepare ?\n\t\tsuspend_ops->prepare() : 0;\n}\n\nstatic int platform_suspend_prepare_late(suspend_state_t state)\n{\n\treturn state == pm_suspend_freeze && freeze_ops && freeze_ops->prepare ?\n\t\tfreeze_ops->prepare() : 0;\n}\n\nstatic int platform_suspend_prepare_noirq(suspend_state_t state)\n{\n\treturn state != pm_suspend_freeze && suspend_ops->prepare_late ?\n\t\tsuspend_ops->prepare_late() : 0;\n}\n\nstatic void platform_resume_noirq(suspend_state_t state)\n{\n\tif (state != pm_suspend_freeze && suspend_ops->wake)\n\t\tsuspend_ops->wake();\n}\n\nstatic void platform_resume_early(suspend_state_t state)\n{\n\tif (state == pm_suspend_freeze && freeze_ops && freeze_ops->restore)\n\t\tfreeze_ops->restore();\n}\n\nstatic void platform_resume_finish(suspend_state_t state)\n{\n\tif (state != pm_suspend_freeze && suspend_ops->finish)\n\t\tsuspend_ops->finish();\n}\n\nstatic int platform_suspend_begin(suspend_state_t state)\n{\n\tif (state == pm_suspend_freeze && freeze_ops && freeze_ops->begin)\n\t\treturn freeze_ops->begin();\n\telse if (suspend_ops->begin)\n\t\treturn suspend_ops->begin(state);\n\telse\n\t\treturn 0;\n}\n\nstatic void platform_resume_end(suspend_state_t state)\n{\n\tif (state == pm_suspend_freeze && freeze_ops && freeze_ops->end)\n\t\tfreeze_ops->end();\n\telse if (suspend_ops->end)\n\t\tsuspend_ops->end();\n}\n\nstatic void platform_recover(suspend_state_t state)\n{\n\tif (state != pm_suspend_freeze && suspend_ops->recover)\n\t\tsuspend_ops->recover();\n}\n\nstatic bool platform_suspend_again(suspend_state_t state)\n{\n\treturn state != pm_suspend_freeze && suspend_ops->suspend_again ?\n\t\tsuspend_ops->suspend_again() : false;\n}\n\n#ifdef config_pm_debug\nstatic unsigned int pm_test_delay = 5;\nmodule_param(pm_test_delay, uint, 0644);\nmodule_parm_desc(pm_test_delay,\n\t\t \"", "1214": "\", src->name);\n\t}\n\tmutex_unlock(&clocksource_mutex);\n\n\tcount += snprintf(buf + count,\n\t\t\t  max((ssize_t)page_size - count, (ssize_t)0), \"", "1215": "\", sym);\n\telse\n\t\tseq_printf(m, \"", "1216": "\", symname);\n}\n\nstatic int tstats_show(struct seq_file *m, void *v)\n{\n\tstruct timespec period;\n\tstruct entry *entry;\n\tunsigned long ms;\n\tlong events = 0;\n\tktime_t time;\n\tint i;\n\n\tmutex_lock(&show_mutex);\n\t\n\tif (timer_stats_active)\n\t\ttime_stop = ktime_get();\n\n\ttime = ktime_sub(time_stop, time_start);\n\n\tperiod = ktime_to_timespec(time);\n\tms = period.tv_nsec / 1000000;\n\n\tseq_puts(m, \"", "1217": "\", symname);\n}\n\nstatic void\nprint_timer(struct seq_file *m, struct hrtimer *taddr, struct hrtimer *timer,\n\t    int idx, u64 now)\n{\n#ifdef config_timer_stats\n\tchar tmp[task_comm_len + 1];\n#endif\n\tseq_printf(m, \"", "1218": "\", t, usec_rem);\n\t} else {\n\t\t\n\t\ttrace_seq_printf(s, \"", "1219": "\", t: %p, r: %p\\n\"", "1220": "\", timer->state);\n#ifdef config_timer_stats\n\tseq_printf(m, \"", "1221": "\", timer_stats_active ? \"", "1222": "\", tmp, timer->start_pid);\n#endif\n\tseq_printf(m, \"", "1223": "\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 6: \n\t\tif (cp < lastchar) {\n\t\t\tkdb_printf(\"", "1224": "\", tmpbuffer);\n\t\t*lastchar = (char)key;\n\t\t*(lastchar+1) = '\\0';\n\t\treturn lastchar;\n\tcase 9: \n\t\tif (tab < 2)\n\t\t\t++tab;\n\t\tp_tmp = buffer;\n\t\twhile (*p_tmp == ' ')\n\t\t\tp_tmp++;\n\t\tif (p_tmp > cp)\n\t\t\tbreak;\n\t\tmemcpy(tmpbuffer, p_tmp, cp-p_tmp);\n\t\t*(tmpbuffer + (cp-p_tmp)) = '\\0';\n\t\tp_tmp = strrchr(tmpbuffer, ' ');\n\t\tif (p_tmp)\n\t\t\t++p_tmp;\n\t\telse\n\t\t\tp_tmp = tmpbuffer;\n\t\tlen = strlen(p_tmp);\n\t\tcount = kallsyms_symbol_complete(p_tmp,\n\t\t\t\t\t\t sizeof(tmpbuffer) -\n\t\t\t\t\t\t (p_tmp - tmpbuffer));\n\t\tif (tab == 2 && count > 0) {\n\t\t\tkdb_printf(\"", "1225": "\", tr->current_trace->name);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nint tracer_init(struct tracer *t, struct trace_array *tr)\n{\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\treturn t->init(tr);\n}\n\nstatic void set_buffer_entries(struct trace_buffer *buf, unsigned long val)\n{\n\tint cpu;\n\n\tfor_each_tracing_cpu(cpu)\n\t\tper_cpu_ptr(buf->data, cpu)->entries = val;\n}\n\n#ifdef config_tracer_max_trace\n\nstatic int resize_buffer_duplicate_size(struct trace_buffer *trace_buf,\n\t\t\t\t\tstruct trace_buffer *size_buf, int cpu_id)\n{\n\tint cpu, ret = 0;\n\n\tif (cpu_id == ring_buffer_all_cpus) {\n\t\tfor_each_tracing_cpu(cpu) {\n\t\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu)->entries, cpu);\n\t\t\tif (ret < 0)\n\t\t\t\tbreak;\n\t\t\tper_cpu_ptr(trace_buf->data, cpu)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu)->entries;\n\t\t}\n\t} else {\n\t\tret = ring_buffer_resize(trace_buf->buffer,\n\t\t\t\t per_cpu_ptr(size_buf->data, cpu_id)->entries, cpu_id);\n\t\tif (ret == 0)\n\t\t\tper_cpu_ptr(trace_buf->data, cpu_id)->entries =\n\t\t\t\tper_cpu_ptr(size_buf->data, cpu_id)->entries;\n\t}\n\n\treturn ret;\n}\n#endif \n\nstatic int __tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t\tunsigned long size, int cpu)\n{\n\tint ret;\n\n\t\n\tring_buffer_expanded = true;\n\n\t\n\tif (!tr->trace_buffer.buffer)\n\t\treturn 0;\n\n\tret = ring_buffer_resize(tr->trace_buffer.buffer, size, cpu);\n\tif (ret < 0)\n\t\treturn ret;\n\n#ifdef config_tracer_max_trace\n\tif (!(tr->flags & trace_array_fl_global) ||\n\t    !tr->current_trace->use_max_tr)\n\t\tgoto out;\n\n\tret = ring_buffer_resize(tr->max_buffer.buffer, size, cpu);\n\tif (ret < 0) {\n\t\tint r = resize_buffer_duplicate_size(&tr->trace_buffer,\n\t\t\t\t\t\t     &tr->trace_buffer, cpu);\n\t\tif (r < 0) {\n\t\t\t\n\t\t\twarn_on(1);\n\t\t\ttracing_disabled = 1;\n\t\t}\n\t\treturn ret;\n\t}\n\n\tif (cpu == ring_buffer_all_cpus)\n\t\tset_buffer_entries(&tr->max_buffer, size);\n\telse\n\t\tper_cpu_ptr(tr->max_buffer.data, cpu)->entries = size;\n\n out:\n#endif \n\n\tif (cpu == ring_buffer_all_cpus)\n\t\tset_buffer_entries(&tr->trace_buffer, size);\n\telse\n\t\tper_cpu_ptr(tr->trace_buffer.data, cpu)->entries = size;\n\n\treturn ret;\n}\n\nstatic ssize_t tracing_resize_ring_buffer(struct trace_array *tr,\n\t\t\t\t\t  unsigned long size, int cpu_id)\n{\n\tint ret = size;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (cpu_id != ring_buffer_all_cpus) {\n\t\t\n\t\tif (!cpumask_test_cpu(cpu_id, tracing_buffer_mask)) {\n\t\t\tret = -einval;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tret = __tracing_resize_ring_buffer(tr, size, cpu_id);\n\tif (ret < 0)\n\t\tret = -enomem;\n\nout:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\n\n\nint tracing_update_buffers(void)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\tif (!ring_buffer_expanded)\n\t\tret = __tracing_resize_ring_buffer(&global_trace, trace_buf_size,\n\t\t\t\t\t\tring_buffer_all_cpus);\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstruct trace_option_dentry;\n\nstatic struct trace_option_dentry *\ncreate_trace_option_files(struct trace_array *tr, struct tracer *tracer);\n\nstatic void\ndestroy_trace_option_files(struct trace_option_dentry *topts);\n\n\nstatic void tracing_set_nop(struct trace_array *tr)\n{\n\tif (tr->current_trace == &nop_trace)\n\t\treturn;\n\t\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\ttr->current_trace = &nop_trace;\n}\n\nstatic void update_tracer_options(struct trace_array *tr, struct tracer *t)\n{\n\tstatic struct trace_option_dentry *topts;\n\n\t\n\tif (!tr->dir)\n\t\treturn;\n\n\t\n\tif (!(tr->flags & trace_array_fl_global))\n\t\treturn;\n\n\tdestroy_trace_option_files(topts);\n\ttopts = create_trace_option_files(tr, t);\n}\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf)\n{\n\tstruct tracer *t;\n#ifdef config_tracer_max_trace\n\tbool had_max_tr;\n#endif\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (!ring_buffer_expanded) {\n\t\tret = __tracing_resize_ring_buffer(tr, trace_buf_size,\n\t\t\t\t\t\tring_buffer_all_cpus);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tret = 0;\n\t}\n\n\tfor (t = trace_types; t; t = t->next) {\n\t\tif (strcmp(t->name, buf) == 0)\n\t\t\tbreak;\n\t}\n\tif (!t) {\n\t\tret = -einval;\n\t\tgoto out;\n\t}\n\tif (t == tr->current_trace)\n\t\tgoto out;\n\n\t\n\tif (!trace_ok_for_array(t, tr)) {\n\t\tret = -einval;\n\t\tgoto out;\n\t}\n\n\t\n\tif (tr->current_trace->ref) {\n\t\tret = -ebusy;\n\t\tgoto out;\n\t}\n\n\ttrace_branch_disable();\n\n\ttr->current_trace->enabled--;\n\n\tif (tr->current_trace->reset)\n\t\ttr->current_trace->reset(tr);\n\n\t\n\ttr->current_trace = &nop_trace;\n\n#ifdef config_tracer_max_trace\n\thad_max_tr = tr->allocated_snapshot;\n\n\tif (had_max_tr && !t->use_max_tr) {\n\t\t\n\t\tsynchronize_sched();\n\t\tfree_snapshot(tr);\n\t}\n#endif\n\tupdate_tracer_options(tr, t);\n\n#ifdef config_tracer_max_trace\n\tif (t->use_max_tr && !had_max_tr) {\n\t\tret = alloc_snapshot(tr);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n#endif\n\n\tif (t->init) {\n\t\tret = tracer_init(t, tr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\ttr->current_trace = t;\n\ttr->current_trace->enabled++;\n\ttrace_branch_enable(tr);\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_set_trace_write(struct file *filp, const char __user *ubuf,\n\t\t\tsize_t cnt, loff_t *ppos)\n{\n\tstruct trace_array *tr = filp->private_data;\n\tchar buf[max_tracer_size+1];\n\tint i;\n\tsize_t ret;\n\tint err;\n\n\tret = cnt;\n\n\tif (cnt > max_tracer_size)\n\t\tcnt = max_tracer_size;\n\n\tif (copy_from_user(&buf, ubuf, cnt))\n\t\treturn -efault;\n\n\tbuf[cnt] = 0;\n\n\t\n\tfor (i = cnt - 1; i > 0 && isspace(buf[i]); i--)\n\t\tbuf[i] = 0;\n\n\terr = tracing_set_tracer(tr, buf);\n\tif (err)\n\t\treturn err;\n\n\t*ppos += ret;\n\n\treturn ret;\n}\n\nstatic ssize_t\ntracing_nsecs_read(unsigned long *ptr, char __user *ubuf,\n\t\t   size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tint r;\n\n\tr = snprintf(buf, sizeof(buf), \"", "1226": "\", trace_clocks[i].name,\n\t\t\ti == tr->clock_id ? \"", "1227": "\", trace_options[i]);\n\t\telse\n\t\t\tseq_printf(m, \"", "1228": "\", trace_options[i]);\n\t}\n\n\tfor (i = 0; trace_opts[i].name; i++) {\n\t\tif (tracer_flags & trace_opts[i].bit)\n\t\t\tseq_printf(m, \"", "1229": "\", trace_opts[i].name);\n\t\telse\n\t\t\tseq_printf(m, \"", "1230": "\", trace_opts[i].name);\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}\n\nstatic int __set_tracer_option(struct trace_array *tr,\n\t\t\t       struct tracer_flags *tracer_flags,\n\t\t\t       struct tracer_opt *opts, int neg)\n{\n\tstruct tracer *trace = tr->current_trace;\n\tint ret;\n\n\tret = trace->set_flag(tr, tracer_flags->val, opts->bit, !neg);\n\tif (ret)\n\t\treturn ret;\n\n\tif (neg)\n\t\ttracer_flags->val &= ~opts->bit;\n\telse\n\t\ttracer_flags->val |= opts->bit;\n\treturn 0;\n}\n\n\nstatic int set_tracer_option(struct trace_array *tr, char *cmp, int neg)\n{\n\tstruct tracer *trace = tr->current_trace;\n\tstruct tracer_flags *tracer_flags = trace->flags;\n\tstruct tracer_opt *opts = null;\n\tint i;\n\n\tfor (i = 0; tracer_flags->opts[i].name; i++) {\n\t\topts = &tracer_flags->opts[i];\n\n\t\tif (strcmp(cmp, opts->name) == 0)\n\t\t\treturn __set_tracer_option(tr, trace->flags, opts, neg);\n\t}\n\n\treturn -einval;\n}\n\n\nint trace_keep_overwrite(struct tracer *tracer, u32 mask, int set)\n{\n\tif (tracer->enabled && (mask & trace_iter_overwrite) && !set)\n\t\treturn -1;\n\n\treturn 0;\n}\n\nint set_tracer_flag(struct trace_array *tr, unsigned int mask, int enabled)\n{\n\t\n\tif (!!(trace_flags & mask) == !!enabled)\n\t\treturn 0;\n\n\t\n\tif (tr->current_trace->flag_changed)\n\t\tif (tr->current_trace->flag_changed(tr, mask, !!enabled))\n\t\t\treturn -einval;\n\n\tif (enabled)\n\t\ttrace_flags |= mask;\n\telse\n\t\ttrace_flags &= ~mask;\n\n\tif (mask == trace_iter_record_cmd)\n\t\ttrace_event_enable_cmd_record(enabled);\n\n\tif (mask == trace_iter_overwrite) {\n\t\tring_buffer_change_overwrite(tr->trace_buffer.buffer, enabled);\n#ifdef config_tracer_max_trace\n\t\tring_buffer_change_overwrite(tr->max_buffer.buffer, enabled);\n#endif\n\t}\n\n\tif (mask == trace_iter_printk)\n\t\ttrace_printk_start_stop_comm(enabled);\n\n\treturn 0;\n}\n\nstatic int trace_set_options(struct trace_array *tr, char *option)\n{\n\tchar *cmp;\n\tint neg = 0;\n\tint ret = -enodev;\n\tint i;\n\n\tcmp = strstrip(option);\n\n\tif (strncmp(cmp, \"", "1231": "\", tsk);\n\telse\n\t\tprintk(kern_err \"", "1232": "\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"", "1233": "\", usage_str[bit]);\n\t\t\tlen += printk(\"", "1234": "\", virq);\n\t\tret = -enomem;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_recursive(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}\n\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (warn(!data || !data->domain || !data->domain->ops->free,\n\t\t \"", "1235": "\",\"", "1236": "\",clone_children\"", "1237": "\",depth,\"", "1238": "\",high\"", "1239": "\",low\"", "1240": "\",name=%s\"", "1241": "\",noprefix\"", "1242": "\",release_agent=%s\"", "1243": "\",xattr\"", "1244": "\"-\"", "1245": "\"-%-8s\"", "1246": "\"--\"", "1247": "\"---    ----            ---             ---\\n\"", "1248": "\"--- %s%s: nwriters_stress=%d nreaders_stress=%d stat_interval=%d verbose=%d shuffle_interval=%d stutter=%d shutdown_secs=%d onoff_interval=%d onoff_holdoff=%d\\n\"", "1249": "\"--- %s: nreaders=%d nfakewriters=%d \"", "1250": "\"-----------------------------\"", "1251": "\"------------------------------------------------------\"", "1252": "\"---------------------------------------------------------\"", "1253": "\"----------------------------------------------------\\n\"", "1254": "\"------------------------------------------------\\n\"", "1255": "\"---------------------------------------------\\n\"", "1256": "\"--------------------------------------------\\n\"", "1257": "\"-------------------------------------\\n\"", "1258": "\"----------------------------------\\n\"", "1259": "\"---------------------------------\\n\"", "1260": "\"-------------------------------\\n\"", "1261": "\"------------------------------\\n\"", "1262": "\"-----------------------------\\n\"", "1263": "\"----------\\n\"", "1264": "\"---[ end kernel panic - not syncing: %s\\n\"", "1265": "\"--=\"", "1266": "\"--> %lx (%d)\"", "1267": "\"-:testprobe\"", "1268": "\"-:testprobe2\"", "1269": "\"-=\"", "1270": "\"-> existing mapping on virq %d\\n\"", "1271": "\"-> using domain @%p\\n\"", "1272": "\"->action(): %p\\n\"", "1273": "\"->action->handler(): %p, \"", "1274": "\"->handle_irq():  %p, \"", "1275": "\"->irq_data.chip(): %p, \"", "1276": "\"->rcu_read_unlock_special: %#x (b: %d, nq: %d)\\n\"", "1277": "\"-on-r\"", "1278": "\"-on-w\"", "1279": "\"-q\"", "1280": "\"-r\"", "1281": "\"-w\"", "1282": "\".\"", "1283": "\".-_\"", "1284": "\".. ->owner: %p\\n\"", "1285": "\".. bad ring buffer \"", "1286": "\".. corrupted trace buffer .. \"", "1287": "\".. filter did not filter .. \"", "1288": "\".. filter failed count=%ld ..\"", "1289": "\".. held by:  \"", "1290": "\".. invalid entry %d \"", "1291": "\".. no entries found ..\"", "1292": "\"..\"", "1293": "\"../../mm/internal.h\"", "1294": "\"../debug_core.h\"", "1295": "\"../fs/xfs/xfs_sysctl.h\"", "1296": "\"../locking/rtmutex_common.h\"", "1297": "\"../smpboot.h\"", "1298": "\"../time/tick-internal.h\"", "1299": "\"../workqueue_internal.h\"", "1300": "\".ctors\"", "1301": "\".d\"", "1302": "\".data..percpu\"", "1303": "\".debug\"", "1304": "\".e\"", "1305": "\".exit\"", "1306": "\".g\"", "1307": "\".gnu.linkonce.this_module\"", "1308": "\".i\"", "1309": "\".init\"", "1310": "\".init_array\"", "1311": "\".modinfo\"", "1312": "\".n\"", "1313": "\".owner_cpu: %d\\n\"", "1314": "\".r\"", "1315": "\".rodata\"", "1316": "\".system_keyring\"", "1317": "\".t\"", "1318": "\".tmp_\"", "1319": "\".w\"", "1320": "\"/\"", "1321": "\"/%d\"", "1322": "\"/0x%lx\"", "1323": "\"/=\"", "1324": "\"/autogroup\"", "1325": "\"/autogroup-%ld nice %d\\n\"", "1326": "\"/sbin/modprobe\"", "1327": "\"0\"", "1328": "\"0-0\\tlinux           \\t[kernel]\\n\"", "1329": "\"0\\n\"", "1330": "\"0x%llx\"", "1331": "\"0x%lx\"", "1332": "\"0x%lx\\n\"", "1333": "\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\"", "1334": "\"0x%p-0x%p\\t%ps\\n\"", "1335": "\"0x%pk\\n\"", "1336": "\"0x%x\"", "1337": "\"1\"", "1338": "\"2.6.%u%s\"", "1339": "\": \"", "1340": "\": \\t\"", "1341": "\":\"", "1342": "\":%p\"", "1343": "\":%s/%s\"", "1344": "\":count=%ld\"", "1345": "\":count=%ld\\n\"", "1346": "\":unlimited\"", "1347": "\":unlimited\\n\"", "1348": "\";\n\t\t*str += 4;\n\t} else if (!memcmp(str, \"", "1349": "\";\n\t\t}\n\t}\n\treturn null;\n}\n\n\nstatic char *kdballocenv(size_t bytes)\n{\n#define\tkdb_envbufsize\t512\n\tstatic char envbuffer[kdb_envbufsize];\n\tstatic int envbufsize;\n\tchar *ep = null;\n\n\tif ((kdb_envbufsize - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}\n\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn kdb_notenv;\n\tif (strlen(ep) == 0)\n\t\treturn kdb_noenvvalue;\n\n\t*value = simple_strtoul(ep, null, 0);\n\n\treturn 0;\n}\n\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}\n\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn kdb_badint;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn kdb_badint;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}\n\n\nint kdb_set(int argc, const char **argv)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\t\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn kdb_argcount;\n\n\t\n\tif (strcmp(argv[1], \"", "1350": "\";\n\telse\n\t\tbuf = \"", "1351": "\";\n\tstruct console *c = console_drivers;\n\tstatic define_spinlock(kdb_printf_lock);\n\tunsigned long uninitialized_var(flags);\n\n\tpreempt_disable();\n\tsaved_trap_printk = kdb_trap_printk;\n\tkdb_trap_printk = 0;\n\n\t\n\tif (!kdb_state(printf_lock)) {\n\t\tkdb_state_set(printf_lock);\n\t\tspin_lock_irqsave(&kdb_printf_lock, flags);\n\t\tgot_printf_lock = 1;\n\t\tatomic_inc(&kdb_event);\n\t} else {\n\t\t__acquire(kdb_printf_lock);\n\t}\n\n\tdiag = kdbgetintenv(\"", "1352": "\";\n\n\t\t\n\t\tkdb_nextline = 1;\t\n\n\t\t\n\t\tmoreprompt = kdbgetenv(\"", "1353": "\";\n\n\t\tkdb_input_flush();\n\t\tc = console_drivers;\n\n\t\tif (dbg_io_ops && !dbg_io_ops->is_console) {\n\t\t\tlen = strlen(moreprompt);\n\t\t\tcp = moreprompt;\n\t\t\twhile (len--) {\n\t\t\t\tdbg_io_ops->write_char(*cp);\n\t\t\t\tcp++;\n\t\t\t}\n\t\t}\n\t\twhile (c) {\n\t\t\tc->write(c, moreprompt, strlen(moreprompt));\n\t\t\ttouch_nmi_watchdog();\n\t\t\tc = c->next;\n\t\t}\n\n\t\tif (logging)\n\t\t\tprintk(\"", "1354": "\";\n\n\t\trecursion_bug = 0;\n\t\t\n\t\tprinted_len += log_store(0, 2, log_prefix|log_newline, 0,\n\t\t\t\t\t null, 0, recursion_msg,\n\t\t\t\t\t strlen(recursion_msg));\n\t}\n\n\t\n\ttext_len = vscnprintf(text, sizeof(textbuf), fmt, args);\n\n\t\n\tif (text_len && text[text_len-1] == '\\n') {\n\t\ttext_len--;\n\t\tlflags |= log_newline;\n\t}\n\n\t\n\tif (facility == 0) {\n\t\tint kern_level = printk_get_level(text);\n\n\t\tif (kern_level) {\n\t\t\tconst char *end_of_header = printk_skip_level(text);\n\t\t\tswitch (kern_level) {\n\t\t\tcase '0' ... '7':\n\t\t\t\tif (level == loglevel_default)\n\t\t\t\t\tlevel = kern_level - '0';\n\t\t\t\t\n\t\t\tcase 'd':\t\n\t\t\t\tlflags |= log_prefix;\n\t\t\t}\n\t\t\t\n\t\t\ttext_len -= end_of_header - text;\n\t\t\ttext = (char *)end_of_header;\n\t\t}\n\t}\n\n\tif (level == loglevel_default)\n\t\tlevel = default_message_loglevel;\n\n\tif (dict)\n\t\tlflags |= log_prefix|log_newline;\n\n\tif (!(lflags & log_newline)) {\n\t\t\n\t\tif (cont.len && (lflags & log_prefix || cont.owner != current))\n\t\t\tcont_flush(log_newline);\n\n\t\t\n\t\tif (cont_add(facility, level, text, text_len))\n\t\t\tprinted_len += text_len;\n\t\telse\n\t\t\tprinted_len += log_store(facility, level,\n\t\t\t\t\t\t lflags | log_cont, 0,\n\t\t\t\t\t\t dict, dictlen, text, text_len);\n\t} else {\n\t\tbool stored = false;\n\n\t\t\n\t\tif (cont.len) {\n\t\t\tif (cont.owner == current && !(lflags & log_prefix))\n\t\t\t\tstored = cont_add(facility, level, text,\n\t\t\t\t\t\t  text_len);\n\t\t\tcont_flush(log_newline);\n\t\t}\n\n\t\tif (stored)\n\t\t\tprinted_len += text_len;\n\t\telse\n\t\t\tprinted_len += log_store(facility, level, lflags, 0,\n\t\t\t\t\t\t dict, dictlen, text, text_len);\n\t}\n\n\tlogbuf_cpu = uint_max;\n\traw_spin_unlock(&logbuf_lock);\n\tlockdep_on();\n\tlocal_irq_restore(flags);\n\n\t\n\tif (!in_sched) {\n\t\tlockdep_off();\n\t\t\n\t\tpreempt_disable();\n\n\t\t\n\t\tif (console_trylock_for_printk())\n\t\t\tconsole_unlock();\n\t\tpreempt_enable();\n\t\tlockdep_on();\n\t}\n\n\treturn printed_len;\n}\nexport_symbol(vprintk_emit);\n\nasmlinkage int vprintk(const char *fmt, va_list args)\n{\n\treturn vprintk_emit(0, loglevel_default, null, 0, fmt, args);\n}\nexport_symbol(vprintk);\n\nasmlinkage int printk_emit(int facility, int level,\n\t\t\t   const char *dict, size_t dictlen,\n\t\t\t   const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_emit(facility, level, dict, dictlen, fmt, args);\n\tva_end(args);\n\n\treturn r;\n}\nexport_symbol(printk_emit);\n\nint vprintk_default(const char *fmt, va_list args)\n{\n\tint r;\n\n#ifdef config_kgdb_kdb\n\tif (unlikely(kdb_trap_printk)) {\n\t\tr = vkdb_printf(kdb_msgsrc_printk, fmt, args);\n\t\treturn r;\n\t}\n#endif\n\tr = vprintk_emit(0, loglevel_default, null, 0, fmt, args);\n\n\treturn r;\n}\nexport_symbol_gpl(vprintk_default);\n\n\ndefine_per_cpu(printk_func_t, printk_func) = vprintk_default;\n\n\nasmlinkage __visible int printk(const char *fmt, ...)\n{\n\tprintk_func_t vprintk_func;\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\n\t\n\tvprintk_func = this_cpu_read(printk_func);\n\tr = vprintk_func(fmt, args);\n\n\tva_end(args);\n\n\treturn r;\n}\nexport_symbol(printk);\n\n#else \n\n#define log_line_max\t\t0\n#define prefix_max\t\t0\n\nstatic u64 syslog_seq;\nstatic u32 syslog_idx;\nstatic u64 console_seq;\nstatic u32 console_idx;\nstatic enum log_flags syslog_prev;\nstatic u64 log_first_seq;\nstatic u32 log_first_idx;\nstatic u64 log_next_seq;\nstatic enum log_flags console_prev;\nstatic struct cont {\n\tsize_t len;\n\tsize_t cons;\n\tu8 level;\n\tbool flushed:1;\n} cont;\nstatic struct printk_log *log_from_idx(u32 idx) { return null; }\nstatic u32 log_next(u32 idx) { return 0; }\nstatic void call_console_drivers(int level, const char *text, size_t len) {}\nstatic size_t msg_print_text(const struct printk_log *msg, enum log_flags prev,\n\t\t\t     bool syslog, char *buf, size_t size) { return 0; }\nstatic size_t cont_print_text(char *text, size_t size) { return 0; }\n\n\ndefine_per_cpu(printk_func_t, printk_func);\n\n#endif \n\n#ifdef config_early_printk\nstruct console *early_console;\n\nasmlinkage __visible void early_printk(const char *fmt, ...)\n{\n\tva_list ap;\n\tchar buf[512];\n\tint n;\n\n\tif (!early_console)\n\t\treturn;\n\n\tva_start(ap, fmt);\n\tn = vscnprintf(buf, sizeof(buf), fmt, ap);\n\tva_end(ap);\n\n\tearly_console->write(early_console, buf, n);\n}\n#endif\n\nstatic int __add_preferred_console(char *name, int idx, char *options,\n\t\t\t\t   char *brl_options)\n{\n\tstruct console_cmdline *c;\n\tint i;\n\n\t\n\tfor (i = 0, c = console_cmdline;\n\t     i < max_cmdlineconsoles && c->name[0];\n\t     i++, c++) {\n\t\tif (strcmp(c->name, name) == 0 && c->index == idx) {\n\t\t\tif (!brl_options)\n\t\t\t\tselected_console = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (i == max_cmdlineconsoles)\n\t\treturn -e2big;\n\tif (!brl_options)\n\t\tselected_console = i;\n\tstrlcpy(c->name, name, sizeof(c->name));\n\tc->options = options;\n\tbraille_set_options(c, brl_options);\n\n\tc->index = idx;\n\treturn 0;\n}\n\nstatic int __init console_setup(char *str)\n{\n\tchar buf[sizeof(console_cmdline[0].name) + 4]; \n\tchar *s, *options, *brl_options = null;\n\tint idx;\n\n\tif (_braille_console_setup(&str, &brl_options))\n\t\treturn 1;\n\n\t\n\tif (str[0] >= '0' && str[0] <= '9') {\n\t\tstrcpy(buf, \"", "1355": "\";\n\n\tname = type->name;\n\n\tget_total_entries(buf, &total, &entries);\n\n\tseq_printf(m, \"", "1356": "\";\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n}\n\nstatic ssize_t\ntrace_options_core_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t\t loff_t *ppos)\n{\n\tstruct trace_array *tr = &global_trace;\n\tlong index = (long)filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -einval;\n\n\tmutex_lock(&trace_types_lock);\n\tret = set_tracer_flag(tr, 1 << index, val);\n\tmutex_unlock(&trace_types_lock);\n\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic const struct file_operations trace_options_core_fops = {\n\t.open = tracing_open_generic,\n\t.read = trace_options_core_read,\n\t.write = trace_options_core_write,\n\t.llseek = generic_file_llseek,\n};\n\nstruct dentry *trace_create_file(const char *name,\n\t\t\t\t umode_t mode,\n\t\t\t\t struct dentry *parent,\n\t\t\t\t void *data,\n\t\t\t\t const struct file_operations *fops)\n{\n\tstruct dentry *ret;\n\n\tret = tracefs_create_file(name, mode, parent, data, fops);\n\tif (!ret)\n\t\tpr_warning(\"", "1357": "\";\n\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, 2);\n}\n\nstatic ssize_t\ntrace_options_write(struct file *filp, const char __user *ubuf, size_t cnt,\n\t\t\t loff_t *ppos)\n{\n\tstruct trace_option_dentry *topt = filp->private_data;\n\tunsigned long val;\n\tint ret;\n\n\tret = kstrtoul_from_user(ubuf, cnt, 10, &val);\n\tif (ret)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -einval;\n\n\tif (!!(topt->flags->val & topt->opt->bit) != val) {\n\t\tmutex_lock(&trace_types_lock);\n\t\tret = __set_tracer_option(topt->tr, topt->flags,\n\t\t\t\t\t  topt->opt, !val);\n\t\tmutex_unlock(&trace_types_lock);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\n\nstatic const struct file_operations trace_options_fops = {\n\t.open = tracing_open_generic,\n\t.read = trace_options_read,\n\t.write = trace_options_write,\n\t.llseek\t= generic_file_llseek,\n};\n\nstatic ssize_t\ntrace_options_core_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t\tloff_t *ppos)\n{\n\tlong index = (long)filp->private_data;\n\tchar *buf;\n\n\tif (trace_flags & (1 << index))\n\t\tbuf = \"", "1358": "\";\n\nstatic u32 truncate_msg(u16 *text_len, u16 *trunc_msg_len,\n\t\t\tu16 *dict_len, u32 *pad_len)\n{\n\t\n\tu32 max_text_len = log_buf_len / max_log_take_part;\n\tif (*text_len > max_text_len)\n\t\t*text_len = max_text_len;\n\t\n\t*trunc_msg_len = strlen(trunc_msg);\n\t\n\t*dict_len = 0;\n\t\n\treturn msg_used_size(*text_len + *trunc_msg_len, 0, pad_len);\n}\n\n\nstatic int log_store(int facility, int level,\n\t\t     enum log_flags flags, u64 ts_nsec,\n\t\t     const char *dict, u16 dict_len,\n\t\t     const char *text, u16 text_len)\n{\n\tstruct printk_log *msg;\n\tu32 size, pad_len;\n\tu16 trunc_msg_len = 0;\n\n\t\n\tsize = msg_used_size(text_len, dict_len, &pad_len);\n\n\tif (log_make_free_space(size)) {\n\t\t\n\t\tsize = truncate_msg(&text_len, &trunc_msg_len,\n\t\t\t\t    &dict_len, &pad_len);\n\t\t\n\t\tif (log_make_free_space(size))\n\t\t\treturn 0;\n\t}\n\n\tif (log_next_idx + size + sizeof(struct printk_log) > log_buf_len) {\n\t\t\n\t\tmemset(log_buf + log_next_idx, 0, sizeof(struct printk_log));\n\t\tlog_next_idx = 0;\n\t}\n\n\t\n\tmsg = (struct printk_log *)(log_buf + log_next_idx);\n\tmemcpy(log_text(msg), text, text_len);\n\tmsg->text_len = text_len;\n\tif (trunc_msg_len) {\n\t\tmemcpy(log_text(msg) + text_len, trunc_msg, trunc_msg_len);\n\t\tmsg->text_len += trunc_msg_len;\n\t}\n\tmemcpy(log_dict(msg), dict, dict_len);\n\tmsg->dict_len = dict_len;\n\tmsg->facility = facility;\n\tmsg->level = level & 7;\n\tmsg->flags = flags & 0x1f;\n\tif (ts_nsec > 0)\n\t\tmsg->ts_nsec = ts_nsec;\n\telse\n\t\tmsg->ts_nsec = local_clock();\n\tmemset(log_dict(msg) + dict_len, 0, pad_len);\n\tmsg->len = size;\n\n\t\n\tlog_next_idx += msg->len;\n\tlog_next_seq++;\n\n\treturn msg->text_len;\n}\n\nint dmesg_restrict = is_enabled(config_security_dmesg_restrict);\n\nstatic int syslog_action_restricted(int type)\n{\n\tif (dmesg_restrict)\n\t\treturn 1;\n\t\n\treturn type != syslog_action_read_all &&\n\t       type != syslog_action_size_buffer;\n}\n\nint check_syslog_permissions(int type, bool from_file)\n{\n\t\n\tif (from_file && type != syslog_action_open)\n\t\treturn 0;\n\n\tif (syslog_action_restricted(type)) {\n\t\tif (capable(cap_syslog))\n\t\t\treturn 0;\n\t\t\n\t\tif (capable(cap_sys_admin)) {\n\t\t\tpr_warn_once(\"", "1359": "\";\n}\n\nstatic inline u64 perf_clock(void)\n{\n\treturn local_clock();\n}\n\nstatic inline u64 perf_event_clock(struct perf_event *event)\n{\n\treturn event->clock();\n}\n\nstatic inline struct perf_cpu_context *\n__get_cpu_context(struct perf_event_context *ctx)\n{\n\treturn this_cpu_ptr(ctx->pmu->pmu_cpu_context);\n}\n\nstatic void perf_ctx_lock(struct perf_cpu_context *cpuctx,\n\t\t\t  struct perf_event_context *ctx)\n{\n\traw_spin_lock(&cpuctx->ctx.lock);\n\tif (ctx)\n\t\traw_spin_lock(&ctx->lock);\n}\n\nstatic void perf_ctx_unlock(struct perf_cpu_context *cpuctx,\n\t\t\t    struct perf_event_context *ctx)\n{\n\tif (ctx)\n\t\traw_spin_unlock(&ctx->lock);\n\traw_spin_unlock(&cpuctx->ctx.lock);\n}\n\n#ifdef config_cgroup_perf\n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\n\t\n\tif (!event->cgrp)\n\t\treturn true;\n\n\t\n\tif (!cpuctx->cgrp)\n\t\treturn false;\n\n\t\n\treturn cgroup_is_descendant(cpuctx->cgrp->css.cgroup,\n\t\t\t\t    event->cgrp->css.cgroup);\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{\n\tcss_put(&event->cgrp->css);\n\tevent->cgrp = null;\n}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn event->cgrp != null;\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\tstruct perf_cgroup_info *t;\n\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\treturn t->time;\n}\n\nstatic inline void __update_cgrp_time(struct perf_cgroup *cgrp)\n{\n\tstruct perf_cgroup_info *info;\n\tu64 now;\n\n\tnow = perf_clock();\n\n\tinfo = this_cpu_ptr(cgrp->info);\n\n\tinfo->time += now - info->timestamp;\n\tinfo->timestamp = now;\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n\tstruct perf_cgroup *cgrp_out = cpuctx->cgrp;\n\tif (cgrp_out)\n\t\t__update_cgrp_time(cgrp_out);\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n\tstruct perf_cgroup *cgrp;\n\n\t\n\tif (!is_cgroup_event(event))\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(current);\n\t\n\tif (cgrp == event->cgrp)\n\t\t__update_cgrp_time(event->cgrp);\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct perf_cgroup_info *info;\n\n\t\n\tif (!task || !ctx->nr_cgroups)\n\t\treturn;\n\n\tcgrp = perf_cgroup_from_task(task);\n\tinfo = this_cpu_ptr(cgrp->info);\n\tinfo->timestamp = ctx->timestamp;\n}\n\n#define perf_cgroup_swout\t0x1 \n#define perf_cgroup_swin\t0x2 \n\n\nvoid perf_cgroup_switch(struct task_struct *task, int mode)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\t\n\tlocal_irq_save(flags);\n\n\t\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\t\tif (cpuctx->unique_pmu != pmu)\n\t\t\tcontinue; \n\n\t\t\n\t\tif (cpuctx->ctx.nr_cgroups > 0) {\n\t\t\tperf_ctx_lock(cpuctx, cpuctx->task_ctx);\n\t\t\tperf_pmu_disable(cpuctx->ctx.pmu);\n\n\t\t\tif (mode & perf_cgroup_swout) {\n\t\t\t\tcpu_ctx_sched_out(cpuctx, event_all);\n\t\t\t\t\n\t\t\t\tcpuctx->cgrp = null;\n\t\t\t}\n\n\t\t\tif (mode & perf_cgroup_swin) {\n\t\t\t\twarn_on_once(cpuctx->cgrp);\n\t\t\t\t\n\t\t\t\tcpuctx->cgrp = perf_cgroup_from_task(task);\n\t\t\t\tcpu_ctx_sched_in(cpuctx, event_all, task);\n\t\t\t}\n\t\t\tperf_pmu_enable(cpuctx->ctx.pmu);\n\t\t\tperf_ctx_unlock(cpuctx, cpuctx->task_ctx);\n\t\t}\n\t}\n\n\trcu_read_unlock();\n\n\tlocal_irq_restore(flags);\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = null;\n\n\t\n\tcgrp1 = perf_cgroup_from_task(task);\n\n\t\n\tif (next)\n\t\tcgrp2 = perf_cgroup_from_task(next);\n\n\t\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, perf_cgroup_swout);\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n\tstruct perf_cgroup *cgrp1;\n\tstruct perf_cgroup *cgrp2 = null;\n\n\t\n\tcgrp1 = perf_cgroup_from_task(task);\n\n\t\n\tcgrp2 = perf_cgroup_from_task(prev);\n\n\t\n\tif (cgrp1 != cgrp2)\n\t\tperf_cgroup_switch(task, perf_cgroup_swin);\n}\n\nstatic inline int perf_cgroup_connect(int fd, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\tstruct perf_cgroup *cgrp;\n\tstruct cgroup_subsys_state *css;\n\tstruct fd f = fdget(fd);\n\tint ret = 0;\n\n\tif (!f.file)\n\t\treturn -ebadf;\n\n\tcss = css_tryget_online_from_dir(f.file->f_path.dentry,\n\t\t\t\t\t &perf_event_cgrp_subsys);\n\tif (is_err(css)) {\n\t\tret = ptr_err(css);\n\t\tgoto out;\n\t}\n\n\tcgrp = container_of(css, struct perf_cgroup, css);\n\tevent->cgrp = cgrp;\n\n\t\n\tif (group_leader && group_leader->cgrp != cgrp) {\n\t\tperf_detach_cgroup(event);\n\t\tret = -einval;\n\t}\nout:\n\tfdput(f);\n\treturn ret;\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n\tstruct perf_cgroup_info *t;\n\tt = per_cpu_ptr(event->cgrp->info, event->cpu);\n\tevent->shadow_ctx_time = now - t->timestamp;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n\t\n\tif (is_cgroup_event(event) && !perf_cgroup_match(event))\n\t\tevent->cgrp_defer_enabled = 1;\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n\tstruct perf_event *sub;\n\tu64 tstamp = perf_event_time(event);\n\n\tif (!event->cgrp_defer_enabled)\n\t\treturn;\n\n\tevent->cgrp_defer_enabled = 0;\n\n\tevent->tstamp_enabled = tstamp - event->total_time_enabled;\n\tlist_for_each_entry(sub, &event->sibling_list, group_entry) {\n\t\tif (sub->state >= perf_event_state_inactive) {\n\t\t\tsub->tstamp_enabled = tstamp - sub->total_time_enabled;\n\t\t\tsub->cgrp_defer_enabled = 0;\n\t\t}\n\t}\n}\n#else \n\nstatic inline bool\nperf_cgroup_match(struct perf_event *event)\n{\n\treturn true;\n}\n\nstatic inline void perf_detach_cgroup(struct perf_event *event)\n{}\n\nstatic inline int is_cgroup_event(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline u64 perf_cgroup_event_cgrp_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void update_cgrp_time_from_event(struct perf_event *event)\n{\n}\n\nstatic inline void update_cgrp_time_from_cpuctx(struct perf_cpu_context *cpuctx)\n{\n}\n\nstatic inline void perf_cgroup_sched_out(struct task_struct *task,\n\t\t\t\t\t struct task_struct *next)\n{\n}\n\nstatic inline void perf_cgroup_sched_in(struct task_struct *prev,\n\t\t\t\t\tstruct task_struct *task)\n{\n}\n\nstatic inline int perf_cgroup_connect(pid_t pid, struct perf_event *event,\n\t\t\t\t      struct perf_event_attr *attr,\n\t\t\t\t      struct perf_event *group_leader)\n{\n\treturn -einval;\n}\n\nstatic inline void\nperf_cgroup_set_timestamp(struct task_struct *task,\n\t\t\t  struct perf_event_context *ctx)\n{\n}\n\nvoid\nperf_cgroup_switch(struct task_struct *task, struct task_struct *next)\n{\n}\n\nstatic inline void\nperf_cgroup_set_shadow_time(struct perf_event *event, u64 now)\n{\n}\n\nstatic inline u64 perf_cgroup_event_time(struct perf_event *event)\n{\n\treturn 0;\n}\n\nstatic inline void\nperf_cgroup_defer_enabled(struct perf_event *event)\n{\n}\n\nstatic inline void\nperf_cgroup_mark_enabled(struct perf_event *event,\n\t\t\t struct perf_event_context *ctx)\n{\n}\n#endif\n\n\n#define perf_cpu_hrtimer (1000 / hz)\n\nstatic enum hrtimer_restart perf_cpu_hrtimer_handler(struct hrtimer *hr)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tenum hrtimer_restart ret = hrtimer_norestart;\n\tint rotations = 0;\n\n\twarn_on(!irqs_disabled());\n\n\tcpuctx = container_of(hr, struct perf_cpu_context, hrtimer);\n\n\trotations = perf_rotate_context(cpuctx);\n\n\t\n\tif (rotations) {\n\t\thrtimer_forward_now(hr, cpuctx->hrtimer_interval);\n\t\tret = hrtimer_restart;\n\t}\n\n\treturn ret;\n}\n\n\nvoid perf_cpu_hrtimer_cancel(int cpu)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct pmu *pmu;\n\tunsigned long flags;\n\n\tif (warn_on(cpu != smp_processor_id()))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\n\trcu_read_lock();\n\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = this_cpu_ptr(pmu->pmu_cpu_context);\n\n\t\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\t\tcontinue;\n\n\t\thrtimer_cancel(&cpuctx->hrtimer);\n\t}\n\n\trcu_read_unlock();\n\n\tlocal_irq_restore(flags);\n}\n\nstatic void __perf_cpu_hrtimer_init(struct perf_cpu_context *cpuctx, int cpu)\n{\n\tstruct hrtimer *hr = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tint timer;\n\n\t\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn;\n\n\t\n\ttimer = pmu->hrtimer_interval_ms;\n\tif (timer < 1)\n\t\ttimer = pmu->hrtimer_interval_ms = perf_cpu_hrtimer;\n\n\tcpuctx->hrtimer_interval = ns_to_ktime(nsec_per_msec * timer);\n\n\thrtimer_init(hr, clock_monotonic, hrtimer_mode_rel_pinned);\n\thr->function = perf_cpu_hrtimer_handler;\n}\n\nstatic void perf_cpu_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *hr = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\n\t\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn;\n\n\tif (hrtimer_active(hr))\n\t\treturn;\n\n\tif (!hrtimer_callback_running(hr))\n\t\t__hrtimer_start_range_ns(hr, cpuctx->hrtimer_interval,\n\t\t\t\t\t 0, hrtimer_mode_rel_pinned, 0);\n}\n\nvoid perf_pmu_disable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!(*count)++)\n\t\tpmu->pmu_disable(pmu);\n}\n\nvoid perf_pmu_enable(struct pmu *pmu)\n{\n\tint *count = this_cpu_ptr(pmu->pmu_disable_count);\n\tif (!--(*count))\n\t\tpmu->pmu_enable(pmu);\n}\n\nstatic define_per_cpu(struct list_head, active_ctx_list);\n\n\nstatic void perf_event_ctx_activate(struct perf_event_context *ctx)\n{\n\tstruct list_head *head = this_cpu_ptr(&active_ctx_list);\n\n\twarn_on(!irqs_disabled());\n\n\twarn_on(!list_empty(&ctx->active_ctx_list));\n\n\tlist_add(&ctx->active_ctx_list, head);\n}\n\nstatic void perf_event_ctx_deactivate(struct perf_event_context *ctx)\n{\n\twarn_on(!irqs_disabled());\n\n\twarn_on(list_empty(&ctx->active_ctx_list));\n\n\tlist_del_init(&ctx->active_ctx_list);\n}\n\nstatic void get_ctx(struct perf_event_context *ctx)\n{\n\twarn_on(!atomic_inc_not_zero(&ctx->refcount));\n}\n\nstatic void free_ctx(struct rcu_head *head)\n{\n\tstruct perf_event_context *ctx;\n\n\tctx = container_of(head, struct perf_event_context, rcu_head);\n\tkfree(ctx->task_ctx_data);\n\tkfree(ctx);\n}\n\nstatic void put_ctx(struct perf_event_context *ctx)\n{\n\tif (atomic_dec_and_test(&ctx->refcount)) {\n\t\tif (ctx->parent_ctx)\n\t\t\tput_ctx(ctx->parent_ctx);\n\t\tif (ctx->task)\n\t\t\tput_task_struct(ctx->task);\n\t\tcall_rcu(&ctx->rcu_head, free_ctx);\n\t}\n}\n\n\nstatic struct perf_event_context *\nperf_event_ctx_lock_nested(struct perf_event *event, int nesting)\n{\n\tstruct perf_event_context *ctx;\n\nagain:\n\trcu_read_lock();\n\tctx = access_once(event->ctx);\n\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\trcu_read_unlock();\n\t\tgoto again;\n\t}\n\trcu_read_unlock();\n\n\tmutex_lock_nested(&ctx->mutex, nesting);\n\tif (event->ctx != ctx) {\n\t\tmutex_unlock(&ctx->mutex);\n\t\tput_ctx(ctx);\n\t\tgoto again;\n\t}\n\n\treturn ctx;\n}\n\nstatic inline struct perf_event_context *\nperf_event_ctx_lock(struct perf_event *event)\n{\n\treturn perf_event_ctx_lock_nested(event, 0);\n}\n\nstatic void perf_event_ctx_unlock(struct perf_event *event,\n\t\t\t\t  struct perf_event_context *ctx)\n{\n\tmutex_unlock(&ctx->mutex);\n\tput_ctx(ctx);\n}\n\n\nstatic __must_check struct perf_event_context *\nunclone_ctx(struct perf_event_context *ctx)\n{\n\tstruct perf_event_context *parent_ctx = ctx->parent_ctx;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\tif (parent_ctx)\n\t\tctx->parent_ctx = null;\n\tctx->generation++;\n\n\treturn parent_ctx;\n}\n\nstatic u32 perf_event_pid(struct perf_event *event, struct task_struct *p)\n{\n\t\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_tgid_nr_ns(p, event->ns);\n}\n\nstatic u32 perf_event_tid(struct perf_event *event, struct task_struct *p)\n{\n\t\n\tif (event->parent)\n\t\tevent = event->parent;\n\n\treturn task_pid_nr_ns(p, event->ns);\n}\n\n\nstatic u64 primary_event_id(struct perf_event *event)\n{\n\tu64 id = event->id;\n\n\tif (event->parent)\n\t\tid = event->parent->id;\n\n\treturn id;\n}\n\n\nstatic struct perf_event_context *\nperf_lock_task_context(struct task_struct *task, int ctxn, unsigned long *flags)\n{\n\tstruct perf_event_context *ctx;\n\nretry:\n\t\n\tpreempt_disable();\n\trcu_read_lock();\n\tctx = rcu_dereference(task->perf_event_ctxp[ctxn]);\n\tif (ctx) {\n\t\t\n\t\traw_spin_lock_irqsave(&ctx->lock, *flags);\n\t\tif (ctx != rcu_dereference(task->perf_event_ctxp[ctxn])) {\n\t\t\traw_spin_unlock_irqrestore(&ctx->lock, *flags);\n\t\t\trcu_read_unlock();\n\t\t\tpreempt_enable();\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (!atomic_inc_not_zero(&ctx->refcount)) {\n\t\t\traw_spin_unlock_irqrestore(&ctx->lock, *flags);\n\t\t\tctx = null;\n\t\t}\n\t}\n\trcu_read_unlock();\n\tpreempt_enable();\n\treturn ctx;\n}\n\n\nstatic struct perf_event_context *\nperf_pin_task_context(struct task_struct *task, int ctxn)\n{\n\tstruct perf_event_context *ctx;\n\tunsigned long flags;\n\n\tctx = perf_lock_task_context(task, ctxn, &flags);\n\tif (ctx) {\n\t\t++ctx->pin_count;\n\t\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n\t}\n\treturn ctx;\n}\n\nstatic void perf_unpin_context(struct perf_event_context *ctx)\n{\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&ctx->lock, flags);\n\t--ctx->pin_count;\n\traw_spin_unlock_irqrestore(&ctx->lock, flags);\n}\n\n\nstatic void update_context_time(struct perf_event_context *ctx)\n{\n\tu64 now = perf_clock();\n\n\tctx->time += now - ctx->timestamp;\n\tctx->timestamp = now;\n}\n\nstatic u64 perf_event_time(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tif (is_cgroup_event(event))\n\t\treturn perf_cgroup_event_time(event);\n\n\treturn ctx ? ctx->time : 0;\n}\n\n\nstatic void update_event_times(struct perf_event *event)\n{\n\tstruct perf_event_context *ctx = event->ctx;\n\tu64 run_end;\n\n\tif (event->state < perf_event_state_inactive ||\n\t    event->group_leader->state < perf_event_state_inactive)\n\t\treturn;\n\t\n\tif (is_cgroup_event(event))\n\t\trun_end = perf_cgroup_event_time(event);\n\telse if (ctx->is_active)\n\t\trun_end = ctx->time;\n\telse\n\t\trun_end = event->tstamp_stopped;\n\n\tevent->total_time_enabled = run_end - event->tstamp_enabled;\n\n\tif (event->state == perf_event_state_inactive)\n\t\trun_end = event->tstamp_stopped;\n\telse\n\t\trun_end = perf_event_time(event);\n\n\tevent->total_time_running = run_end - event->tstamp_running;\n\n}\n\n\nstatic void update_group_times(struct perf_event *leader)\n{\n\tstruct perf_event *event;\n\n\tupdate_event_times(leader);\n\tlist_for_each_entry(event, &leader->sibling_list, group_entry)\n\t\tupdate_event_times(event);\n}\n\nstatic struct list_head *\nctx_group_list(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tif (event->attr.pinned)\n\t\treturn &ctx->pinned_groups;\n\telse\n\t\treturn &ctx->flexible_groups;\n}\n\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\twarn_on_once(event->attach_state & perf_attach_context);\n\tevent->attach_state |= perf_attach_context;\n\n\t\n\tif (event->group_leader == event) {\n\t\tstruct list_head *list;\n\n\t\tif (is_software_event(event))\n\t\t\tevent->group_flags |= perf_group_software;\n\n\t\tlist = ctx_group_list(event, ctx);\n\t\tlist_add_tail(&event->group_entry, list);\n\t}\n\n\tif (is_cgroup_event(event))\n\t\tctx->nr_cgroups++;\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}\n\n\nstatic inline void perf_event__state_init(struct perf_event *event)\n{\n\tevent->state = event->attr.disabled ? perf_event_state_off :\n\t\t\t\t\t      perf_event_state_inactive;\n}\n\n\nstatic void perf_event__read_size(struct perf_event *event)\n{\n\tint entry = sizeof(u64); \n\tint size = 0;\n\tint nr = 1;\n\n\tif (event->attr.read_format & perf_format_total_time_enabled)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & perf_format_total_time_running)\n\t\tsize += sizeof(u64);\n\n\tif (event->attr.read_format & perf_format_id)\n\t\tentry += sizeof(u64);\n\n\tif (event->attr.read_format & perf_format_group) {\n\t\tnr += event->group_leader->nr_siblings;\n\t\tsize += sizeof(u64);\n\t}\n\n\tsize += entry * nr;\n\tevent->read_size = size;\n}\n\nstatic void perf_event__header_size(struct perf_event *event)\n{\n\tstruct perf_sample_data *data;\n\tu64 sample_type = event->attr.sample_type;\n\tu16 size = 0;\n\n\tperf_event__read_size(event);\n\n\tif (sample_type & perf_sample_ip)\n\t\tsize += sizeof(data->ip);\n\n\tif (sample_type & perf_sample_addr)\n\t\tsize += sizeof(data->addr);\n\n\tif (sample_type & perf_sample_period)\n\t\tsize += sizeof(data->period);\n\n\tif (sample_type & perf_sample_weight)\n\t\tsize += sizeof(data->weight);\n\n\tif (sample_type & perf_sample_read)\n\t\tsize += event->read_size;\n\n\tif (sample_type & perf_sample_data_src)\n\t\tsize += sizeof(data->data_src.val);\n\n\tif (sample_type & perf_sample_transaction)\n\t\tsize += sizeof(data->txn);\n\n\tevent->header_size = size;\n}\n\nstatic void perf_event__id_header_size(struct perf_event *event)\n{\n\tstruct perf_sample_data *data;\n\tu64 sample_type = event->attr.sample_type;\n\tu16 size = 0;\n\n\tif (sample_type & perf_sample_tid)\n\t\tsize += sizeof(data->tid_entry);\n\n\tif (sample_type & perf_sample_time)\n\t\tsize += sizeof(data->time);\n\n\tif (sample_type & perf_sample_identifier)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & perf_sample_id)\n\t\tsize += sizeof(data->id);\n\n\tif (sample_type & perf_sample_stream_id)\n\t\tsize += sizeof(data->stream_id);\n\n\tif (sample_type & perf_sample_cpu)\n\t\tsize += sizeof(data->cpu_entry);\n\n\tevent->id_header_size = size;\n}\n\nstatic void perf_group_attach(struct perf_event *event)\n{\n\tstruct perf_event *group_leader = event->group_leader, *pos;\n\n\t\n\tif (event->attach_state & perf_attach_group)\n\t\treturn;\n\n\tevent->attach_state |= perf_attach_group;\n\n\tif (group_leader == event)\n\t\treturn;\n\n\twarn_on_once(group_leader->ctx != event->ctx);\n\n\tif (group_leader->group_flags & perf_group_software &&\n\t\t\t!is_software_event(event))\n\t\tgroup_leader->group_flags &= ~perf_group_software;\n\n\tlist_add_tail(&event->group_entry, &group_leader->sibling_list);\n\tgroup_leader->nr_siblings++;\n\n\tperf_event__header_size(group_leader);\n\n\tlist_for_each_entry(pos, &group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(pos);\n}\n\n\nstatic void\nlist_del_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tstruct perf_cpu_context *cpuctx;\n\n\twarn_on_once(event->ctx != ctx);\n\tlockdep_assert_held(&ctx->lock);\n\n\t\n\tif (!(event->attach_state & perf_attach_context))\n\t\treturn;\n\n\tevent->attach_state &= ~perf_attach_context;\n\n\tif (is_cgroup_event(event)) {\n\t\tctx->nr_cgroups--;\n\t\tcpuctx = __get_cpu_context(ctx);\n\t\t\n\t\tif (!ctx->nr_cgroups)\n\t\t\tcpuctx->cgrp = null;\n\t}\n\n\tctx->nr_events--;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat--;\n\n\tlist_del_rcu(&event->event_entry);\n\n\tif (event->group_leader == event)\n\t\tlist_del_init(&event->group_entry);\n\n\tupdate_group_times(event);\n\n\t\n\tif (event->state > perf_event_state_off)\n\t\tevent->state = perf_event_state_off;\n\n\tctx->generation++;\n}\n\nstatic void perf_group_detach(struct perf_event *event)\n{\n\tstruct perf_event *sibling, *tmp;\n\tstruct list_head *list = null;\n\n\t\n\tif (!(event->attach_state & perf_attach_group))\n\t\treturn;\n\n\tevent->attach_state &= ~perf_attach_group;\n\n\t\n\tif (event->group_leader != event) {\n\t\tlist_del_init(&event->group_entry);\n\t\tevent->group_leader->nr_siblings--;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&event->group_entry))\n\t\tlist = &event->group_entry;\n\n\t\n\tlist_for_each_entry_safe(sibling, tmp, &event->sibling_list, group_entry) {\n\t\tif (list)\n\t\t\tlist_move_tail(&sibling->group_entry, list);\n\t\tsibling->group_leader = sibling;\n\n\t\t\n\t\tsibling->group_flags = event->group_flags;\n\n\t\twarn_on_once(sibling->ctx != event->ctx);\n\t}\n\nout:\n\tperf_event__header_size(event->group_leader);\n\n\tlist_for_each_entry(tmp, &event->group_leader->sibling_list, group_entry)\n\t\tperf_event__header_size(tmp);\n}\n\n\nstatic bool is_orphaned_event(struct perf_event *event)\n{\n\treturn event && !is_kernel_event(event) && !event->owner;\n}\n\n\nstatic bool is_orphaned_child(struct perf_event *event)\n{\n\treturn is_orphaned_event(event->parent);\n}\n\nstatic void orphans_remove_work(struct work_struct *work);\n\nstatic void schedule_orphans_remove(struct perf_event_context *ctx)\n{\n\tif (!ctx->task || ctx->orphans_remove_sched || !perf_wq)\n\t\treturn;\n\n\tif (queue_delayed_work(perf_wq, &ctx->orphans_remove, 1)) {\n\t\tget_ctx(ctx);\n\t\tctx->orphans_remove_sched = true;\n\t}\n}\n\nstatic int __init perf_workqueue_init(void)\n{\n\tperf_wq = create_singlethread_workqueue(\"", "1360": "\"<\"", "1361": "\"<%016llx-%016llx>\\n\"", "1362": "\"<-- %lx (%d) (start: %llx  end: %llx) over: %d\"", "1363": "\"<-signal> <pid>\"", "1364": "\"<<=\"", "1365": "\"<=\"", "1366": "\"<==%s() = %d\\n\"", "1367": "\"<==%s() = 0 [%x]\\n\"", "1368": "\"<==========\"", "1369": "\"<bad>\"", "1370": "\"<bpnum>\"", "1371": "\"<cpunum>\"", "1372": "\"<idle>\"", "1373": "\"<key>\"", "1374": "\"<no_memory>\"", "1375": "\"<none>\"", "1376": "\"<paddr> <bytes>\"", "1377": "\"<pid>\"", "1378": "\"<pidnum>\"", "1379": "\"<reg> <contents>\"", "1380": "\"<released>\\n\"", "1381": "\"<stack trace>\\n\"", "1382": "\"<sym> [<bytes>] [<cpu>]\"", "1383": "\"<too_long>\"", "1384": "\"<vaddr> <bytes>\"", "1385": "\"<vaddr> <contents>\"", "1386": "\"<vaddr>\"", "1387": "\"=\"", "1388": "\"=0\"", "1389": "\"==\"", "1390": "\"================================================\\n\"", "1391": "\"=============================================\\n\"", "1392": "\"=============================================\\n\\n\"", "1393": "\"=====================================\\n\"", "1394": "\"==================================\\n\"", "1395": "\"=================================\\n\"", "1396": "\"===============================\\n\"", "1397": "\"==========>\"", "1398": "\"====[ backtrace testing ]===========\\n\"", "1399": "\"====[ end of backtrace testing ]====\\n\"", "1400": "\"==>\"", "1401": "\"==>%s(,%zu)\\n\"", "1402": "\"==>%s(,%zu,,%zu)\\n\"", "1403": "\"=off\"", "1404": "\">\"", "1405": "\">=\"", "1406": "\">>=\"", "1407": "\"?\"", "1408": "\"?+|:';\\\",.<>/?abcdefghijklmnopqrstuvwxyz1234567890\"", "1409": "\"??\"", "1410": "\"??? writer stall state %d g%lu c%lu f%#x\\n\"", "1411": "\"???\"", "1412": "\"[ bug: %s/%d still has locks held! ]\\n\"", "1413": "\"[ bug: bad contention detected! ]\\n\"", "1414": "\"[ bug: bad unlock balance detected! ]\\n\"", "1415": "\"[ bug: circular locking deadlock detected! ]\\n\"", "1416": "\"[ bug: lock held when returning to user space! ]\\n\"", "1417": "\"[ bug: nested lock was not taken ]\\n\"", "1418": "\"[ info: inconsistent lock state ]\\n\"", "1419": "\"[ info: possible recursive locking detected ]\\n\"", "1420": "\"[ info: suspicious rcu usage. ]\\n\"", "1421": "\"[ turning off deadlock detection.\"", "1422": "\"[\"", "1423": "\"[%-5.5s%5u] \"", "1424": "\"[%016llx] %lld (+%lld): \"", "1425": "\"[%08llx] %ld.%03ldms (+%ld.%03ldms): \"", "1426": "\"[%d]\"", "1427": "\"[%d]\\n\"", "1428": "\"[%p] \"", "1429": "\"[%s] %llu\\n\"", "1430": "\"[%s] %s:%s:%d\\n\"", "1431": "\"[%s]\"", "1432": "\"[%s]\\n\"", "1433": "\"[%s]kdb> %s\\n\"", "1434": "\"[+0x%lx]\"", "1435": "\"[<%p>] %pf\"", "1436": "\"[<%p>]\"", "1437": "\"[<flags>|a]\"", "1438": "\"[<vaddr>]\"", "1439": "\"[datar [length]|dataw [length]]   set hw brk\"", "1440": "\"[defcmd]\"", "1441": "\"[disabled]\"", "1442": "\"[disabled]\\n\"", "1443": "\"[d|r|s|t|c|z|e|u|i|m|a]\"", "1444": "\"[eff]\"", "1445": "\"[ftrace]\"", "1446": "\"[gone]\"", "1447": "\"[heap]\"", "1448": "\"[lines]\"", "1449": "\"[optimized]\"", "1450": "\"[permanent],\"", "1451": "\"[real]\"", "1452": "\"[stack]\"", "1453": "\"[unknown/kretprobe'd]\"", "1454": "\"\\\"\"", "1455": "\"\\\", %s\"", "1456": "\"\\\"0x%lx\\\", rec->ret\"", "1457": "\"\\\"echo 0 > /proc/sys/kernel/hung_task_timeout_secs\\\"\"", "1458": "\"\\\"memory\\\" requires setting use_hierarchy to 1 on the root\\n\"", "1459": "\"\\\\\\\"%s\\\\\\\"\"", "1460": "\"\\n                                    \"", "1461": "\"\\n    is disabled\"", "1462": "\"\\n    is enabled\"", "1463": "\"\\n *** deadlock ***\\n\\n\"", "1464": "\"\\n ------------------------------------------\\n\\n\"", "1465": "\"\\n new dependency: \"", "1466": "\"\\n\"", "1467": "\"\\n%s/%d's [blocked] stackdump:\\n\\n\"", "1468": "\"\\n%s/%d's [current] stackdump:\\n\\n\"", "1469": "\"\\n%srcu_scheduler_active = %d, debug_locks = %d\\n\"", "1470": "\"\\n1) %s/%d is trying to acquire this lock:\\n\"", "1471": "\"\\n2) %s/%d is blocked on this lock:\\n\"", "1472": "\"\\n============================================\\n\"", "1473": "\"\\n\\nand interrupts could create inverse lock ordering between them.\\n\\n\"", "1474": "\"\\nacquire class [%p] %s\"", "1475": "\"\\nbut task is already holding lock:\\n\"", "1476": "\"\\nbut this task is not holding:\\n\"", "1477": "\"\\ncfs_rq[%d]:%s\\n\"", "1478": "\"\\ncfs_rq[%d]:\\n\"", "1479": "\"\\ndl_rq[%d]:\\n\"", "1480": "\"\\nentering kdb (0x%p, pid %d) \"", "1481": "\"\\nentering kdb (current=0x%p, pid %d) \"", "1482": "\"\\nhash chain already cached, key: \"", "1483": "\"\\nmarked lock as {%s}:\\n\"", "1484": "\"\\nnew class %p: %s\"", "1485": "\"\\nnew hash chain, key: %016lx tail class: [%p] %s\\n\"", "1486": "\"\\nother info that might help us debug this:\\n\"", "1487": "\"\\nother info that might help us debug this:\\n\\n\"", "1488": "\"\\nparse_error: %s\\n\"", "1489": "\"\\npred visited %s\\n\"", "1490": "\"\\nprint fmt: %s\\n\"", "1491": "\"\\nrt_rq[%d]:%s\\n\"", "1492": "\"\\nrt_rq[%d]:\\n\"", "1493": "\"\\nrunnable tasks:\\n\"", "1494": "\"\\nshowing all locks held in the system:\\n\"", "1495": "\"\\nstack backtrace:\\n\"", "1496": "\"\\nthe shortest dependencies between 2nd lock and 1st lock:\\n\"", "1497": "\"\\t\"", "1498": "\"\\t%d: (%lu %s) idle=%03x/%llx/%d softirq=%u/%u fqs=%ld %s\\n\"", "1499": "\"\\t%s\\n\"", "1500": "\"\\t0x%lx %s\\n\"", "1501": "\"\\t=> (\"", "1502": "\"\\tadditional per-cpu info printed with stalls.\\n\"", "1503": "\"\\taddr at %016lx, hardtype=%d installed=%d\\n\"", "1504": "\"\\tboot-time adjustment of leaf fanout to %d.\\n\"", "1505": "\"\\tbuild-time adjustment of leaf fanout to %d.\\n\"", "1506": "\"\\tconfig_rcu_fanout set to non-default value of %d\\n\"", "1507": "\"\\tfield: char data;\\t\"", "1508": "\"\\tfield: int overwrite;\\t\"", "1509": "\"\\tfield: local_t commit;\\t\"", "1510": "\"\\tfield: u64 timestamp;\\t\"", "1511": "\"\\tfield:%.*s %s%s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\"", "1512": "\"\\tfield:%s %s;\\toffset:%u;\\tsize:%u;\\tsigned:%d;\\n\"", "1513": "\"\\tfour-level hierarchy is enabled.\\n\"", "1514": "\"\\thierarchical rcu autobalancing is disabled.\\n\"", "1515": "\"\\tnote: kernel parameter 'rcu_nocbs=' contains nonexistent cpus.\\n\"", "1516": "\"\\toffload rcu callbacks from all cpus\\n\"", "1517": "\"\\toffload rcu callbacks from cpu 0\\n\"", "1518": "\"\\toffload rcu callbacks from cpus: %*pbl.\\n\"", "1519": "\"\\tpoll for callbacks from no-cbs cpus.\\n\"", "1520": "\"\\trcu debugfs-based tracing is enabled.\\n\"", "1521": "\"\\trcu dyntick-idle grace-period acceleration is enabled.\\n\"", "1522": "\"\\trcu kthread priority: %d.\\n\"", "1523": "\"\\trcu lockdep checking is enabled.\\n\"", "1524": "\"\\trcu restricting cpus from nr_cpus=%d to nr_cpu_ids=%d.\\n\"", "1525": "\"\\trcu torture testing starts during boot.\\n\"", "1526": "\"\\ttasks blocked on level-%d rcu_node (cpus %d-%d):\"", "1527": "\"\\ttramp: %ps\"", "1528": "\"\\ttramp: error!\"", "1529": "\"]\"", "1530": "\"]\\n\"", "1531": "\"^=\"", "1532": "\"__call_rcu(): leaked duplicate callback\\n\"", "1533": "\"__data_loc char[]\"", "1534": "\"__data_loc\"", "1535": "\"__devel__sane_behavior\"", "1536": "\"__ex_table\"", "1537": "\"__gnu_lto\"", "1538": "\"__jump_table\"", "1539": "\"__kcrctab\"", "1540": "\"__kcrctab_gpl\"", "1541": "\"__kcrctab_gpl_future\"", "1542": "\"__kcrctab_unused\"", "1543": "\"__kcrctab_unused_gpl\"", "1544": "\"__ksymtab\"", "1545": "\"__ksymtab_gpl\"", "1546": "\"__ksymtab_gpl_future\"", "1547": "\"__ksymtab_unused\"", "1548": "\"__ksymtab_unused_gpl\"", "1549": "\"__mcount_loc\"", "1550": "\"__obsparm\"", "1551": "\"__param\"", "1552": "\"__probe_func\"", "1553": "\"__probe_ip\"", "1554": "\"__probe_ret_ip\"", "1555": "\"__put_cred(%p{%d,%d})\"", "1556": "\"__timekeeping_inject_sleeptime: invalid \"", "1557": "\"__trace_printk_fmt\"", "1558": "\"__tracepoints_ptrs\"", "1559": "\"__verbose\"", "1560": "\"__versions\"", "1561": "\"_filter=\"", "1562": "\"_ftrace_enum_map\"", "1563": "\"_ftrace_events\"", "1564": "\"a %d, b %d, c %d, d %d, e %d, f %d, g %d, h %d\"", "1565": "\"a == 1 && b == 1 && c == 1 && d == 1 && \"", "1566": "\"a == 1 || b == 1 || c == 1 || d == 1 || \"", "1567": "\"a\"", "1568": "\"aarp-expiry-time\"", "1569": "\"aarp-resolve-time\"", "1570": "\"aarp-retransmit-limit\"", "1571": "\"aarp-tick-time\"", "1572": "\"abcdefghijklmnopqrstuvwxyz1234567890!@#$%^&*()?+\\\\\"", "1573": "\"abi\"", "1574": "\"abort_creds(%p{%d,%d})\"", "1575": "\"aborting hibernation\\n\"", "1576": "\"aborting resume\\n\"", "1577": "\"abs_timeout_sec=%ld abs_timeout_nsec=%ld\"", "1578": "\"absolute symbol: 0x%08lx\\n\"", "1579": "\"accept_ra\"", "1580": "\"accept_ra_defrtr\"", "1581": "\"accept_ra_from_local\"", "1582": "\"accept_ra_pinfo\"", "1583": "\"accept_ra_rt_info_max_plen\"", "1584": "\"accept_ra_rtr_pref\"", "1585": "\"accept_redirects\"", "1586": "\"accept_source_route\"", "1587": "\"accreadycb\"", "1588": "\"acct\"", "1589": "\"accwaitcb\"", "1590": "\"ack\"", "1591": "\"ack_timeout\"", "1592": "\"acknowledge_hold_back_timeout\"", "1593": "\"acknowledgement_hold_back_timeout\"", "1594": "\"acpi_video_flags\"", "1595": "\"acq-bounces\"", "1596": "\"acquisitions\"", "1597": "\"active\"", "1598": "\"add_rule\"", "1599": "\"added domain %s\\n\"", "1600": "\"adding module '%s' to sysfs failed (%d), the system may be unstable.\\n\"", "1601": "\"addip_enable\"", "1602": "\"adjusting %s more than 11%% (%ld vs %ld)\\n\"", "1603": "\"admin_reserve_kbytes\"", "1604": "\"affinity_hint\"", "1605": "\"age_buffer_centisecs\"", "1606": "\"aggrprobe@%p\\n\"", "1607": "\"ahead\"", "1608": "\"aio-max-nr\"", "1609": "\"aio-nr\"", "1610": "\"alarmtimer\"", "1611": "\"all branches stats\\n\"", "1612": "\"all leafs should have field defined\"", "1613": "\"all lock classes:\\n\"", "1614": "\"all qses seen, last %s kthread activity %ld (%ld-%ld), jiffies_till_next_fqs=%ld, root ->qsmask %#lx\\n\"", "1615": "\"all\"", "1616": "\"alloc_snapshot\"", "1617": "\"allocated_dquots\"", "1618": "\"allocating new usage for %s.\\n\"", "1619": "\"allow rcu readers from irq handlers\"", "1620": "\"allow\"", "1621": "\"already unlocked\"", "1622": "\"alu\"", "1623": "\"alu64\"", "1624": "\"and/or required key missing - tainting \"", "1625": "\"annotated branches stats\\n\"", "1626": "\"another field.\\n\"", "1627": "\"another i/o driver is already registered with kgdb\\n\"", "1628": "\"app_solicit\"", "1629": "\"appletalk\"", "1630": "\"applying patch '%s' to loading module '%s'\\n\"", "1631": "\"arch=%x syscall=%d\"", "1632": "\"architecture specific data\"", "1633": "\"arg%d\"", "1634": "\"arg_const_stack_size cannot be first argument\\n\"", "1635": "\"argc=%d\"", "1636": "\"argument is too long.: %s\\n\"", "1637": "\"argument[%d] name '%s' conflicts with \"", "1638": "\"arjan van de ven <arjan@linux.intel.com>\"", "1639": "\"arp_accept\"", "1640": "\"arp_announce\"", "1641": "\"arp_filter\"", "1642": "\"arp_ignore\"", "1643": "\"arp_notify\"", "1644": "\"association_max_retrans\"", "1645": "\"asymmetric\"", "1646": "\"async_continuing @ %i after %lli usec\\n\"", "1647": "\"async_waiting @ %i\\n\"", "1648": "\"at the time of bpf_ld_abs|ind r6 != pointer to skb\\n\"", "1649": "\"attempt to kill tasklet from interrupt\\n\"", "1650": "\"attempting to continue\\n\"", "1651": "\"audit rule for lsm \\'%s\\' is invalid\\n\"", "1652": "\"audit(%lu.%03lu:%u): \"", "1653": "\"audit.h\"", "1654": "\"audit: %s\\n\"", "1655": "\"audit_backlog=%d > audit_backlog_limit=%d\\n\"", "1656": "\"audit_backlog_limit\"", "1657": "\"audit_backlog_wait_time\"", "1658": "\"audit_enabled\"", "1659": "\"audit_failure\"", "1660": "\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\"", "1661": "\"audit_possible is deprecated\\n\"", "1662": "\"audit_prune_tree\"", "1663": "\"audit_rate_limit\"", "1664": "\"audit_send_list\"", "1665": "\"audit_send_reply\"", "1666": "\"auid=%u ses=%u op=\"", "1667": "\"auid=%u ses=%u\"", "1668": "\"auid=%u uid=%u gid=%u ses=%u\"", "1669": "\"auto_group.h\"", "1670": "\"autoconf\"", "1671": "\"autogroup_create: %s failure.\\n\"", "1672": "\"autosleep\"", "1673": "\"available_events\"", "1674": "\"ax25\"", "1675": "\"ax25_default_mode\"", "1676": "\"b\"", "1677": "\"b.\"", "1678": "\"back-edge from insn %d to %d\\n\"", "1679": "\"backlog limit exceeded\"", "1680": "\"backmerge\"", "1681": "\"backoff_type\"", "1682": "\"backtrace all processes matching state flag\"", "1683": "\"backtrace current process on each cpu\"", "1684": "\"backtrace process given its struct task address\"", "1685": "\"bad frame pointer: expected %lx, received %lx\\n\"", "1686": "\"bad magic\"", "1687": "\"bad rc=0x%x from %pf()\\n\"", "1688": "\"bad trampoline accounting at: %p (%ps) (%lx)\\n\"", "1689": "\"bad trampoline accounting at: %p (%ps)\\n\"", "1690": "\"bad vermagic\"", "1691": "\"bad: scheduling from the idle thread!\\n\"", "1692": "\"barrier: %ld/%ld:%ld \"", "1693": "\"barrier_cbs_invoked = %d, n_barrier_cbs = %d\\n\"", "1694": "\"base_reachable_time\"", "1695": "\"base_reachable_time_ms\"", "1696": "\"bc\"", "1697": "\"bcc: %d nbd: %lu\\n\"", "1698": "\"bcdef\"", "1699": "\"bcdefgh\"", "1700": "\"bd\"", "1701": "\"bdfh\"", "1702": "\"be\"", "1703": "\"begin\"", "1704": "\"bindv6only\"", "1705": "\"binfmt_misc\"", "1706": "\"bl\"", "1707": "\"blk\"", "1708": "\"block\"", "1709": "\"block_dump\"", "1710": "\"block_iopoll\"", "1711": "\"blocked_load_avg\"", "1712": "\"boot_id\"", "1713": "\"bootloader_type\"", "1714": "\"bootloader_version\"", "1715": "\"bootp_relay\"", "1716": "\"bounce\"", "1717": "\"bp #%d at \"", "1718": "\"bp\"", "1719": "\"bpf program is too complex\\n\"", "1720": "\"bpf program is too large. proccessed %d insn\\n\"", "1721": "\"bpf verifier is misconfigured\\n\"", "1722": "\"bpf-map\"", "1723": "\"bpf_alu uses reserved fields\\n\"", "1724": "\"bpf_call uses reserved fields\\n\"", "1725": "\"bpf_end uses reserved fields\\n\"", "1726": "\"bpf_exit uses reserved fields\\n\"", "1727": "\"bpf_ja uses reserved fields\\n\"", "1728": "\"bpf_jmp uses reserved fields\\n\"", "1729": "\"bpf_ld_abs uses reserved fields\\n\"", "1730": "\"bpf_ld_abs|ind instructions not allowed for this program type\\n\"", "1731": "\"bpf_ld_imm64 uses reserved fields\\n\"", "1732": "\"bpf_ldx uses reserved fields\\n\"", "1733": "\"bpf_mov uses reserved fields\\n\"", "1734": "\"bpf_neg uses reserved fields\\n\"", "1735": "\"bpf_st uses reserved fields\\n\"", "1736": "\"bpf_stx uses reserved fields\\n\"", "1737": "\"bpf_xadd uses reserved fields\\n\"", "1738": "\"bph\"", "1739": "\"braille.h\"", "1740": "\"branch events\\n\"", "1741": "\"branch\"", "1742": "\"branch_all\"", "1743": "\"branch_annotated\"", "1744": "\"breakpoint %d at \"", "1745": "\"breakpoint\"", "1746": "\"broadcast\"", "1747": "\"bset\"", "1748": "\"bt\"", "1749": "\"bta\"", "1750": "\"btaprompt\"", "1751": "\"btc\"", "1752": "\"btc: cpu status: \"", "1753": "\"btp\"", "1754": "\"btt 0x%p\\n\"", "1755": "\"btt\"", "1756": "\"buffer had: %.*s\\n\"", "1757": "\"buffer only contains %d lines, \"", "1758": "\"buffer only contains %d lines, last %d \"", "1759": "\"buffer only contains %d lines, nothing \"", "1760": "\"bug\"", "1761": "\"bug: arch topology borken\\n\"", "1762": "\"bug: bad rss-counter state \"", "1763": "\"bug: function graph tracer hang!\\n\"", "1764": "\"bug: key %p not in .data!\\n\"", "1765": "\"bug: looking up invalid subclass: %u\\n\"", "1766": "\"bug: max_lock_depth too low!\"", "1767": "\"bug: max_lockdep_chains too low!\"", "1768": "\"bug: max_lockdep_entries too low!\"", "1769": "\"bug: max_lockdep_keys too low!\"", "1770": "\"bug: max_stack_trace_entries too low!\"", "1771": "\"bug: non-zero nr_pmds on freeing mm: %ld\\n\"", "1772": "\"bug: non-zero nr_ptes on freeing mm: %ld\\n\"", "1773": "\"bug: read-lock lockup on cpu#%d, \"", "1774": "\"bug: rwlock %s on cpu#%d, %s/%d, %p\\n\"", "1775": "\"bug: sleeping function called from invalid context at %s:%d\\n\"", "1776": "\"bug: soft lockup - cpu#%d stuck for %us! [%s:%d]\\n\"", "1777": "\"bug: spinlock %s on cpu#%d, %s/%d\\n\"", "1778": "\"bug: workqueue leaked lock or atomic: %s/0x%08x/%d\\n\"", "1779": "\"bug: write-lock lockup on cpu#%d, \"", "1780": "\"bug_%02x\\n\"", "1781": "\"bug_ld_%02x\\n\"", "1782": "\"bug_ldx_%02x\\n\"", "1783": "\"bug_st_%02x\\n\"", "1784": "\"bus\"", "1785": "\"busy\"", "1786": "\"busy_factor\"", "1787": "\"busy_idx\"", "1788": "\"but no thread function available.\"", "1789": "\"but there are no locks held!\\n\"", "1790": "\"but there are no more locks to release!\\n\"", "1791": "\"but this lock took another, %s-unsafe lock in the past:\\n\"", "1792": "\"but this lock was taken by another, %s-safe lock in the past:\\n\"", "1793": "\"c\"", "1794": "\"c=%ld g=%ld s=%d jfq=%ld j=%x \"", "1795": "\"cache_hits\"", "1796": "\"cache_nice_tries\"", "1797": "\"cad_pid\"", "1798": "\"call\"", "1799": "\"call_request_timeout\"", "1800": "\"calling  %lli_%pf @ %i\\n\"", "1801": "\"can not test ... force \"", "1802": "\"can't allocate system trusted keyring\\n\"", "1803": "\"can't do kill command now.\\n\"", "1804": "\"can't online cpu %d because it is not configured as may-hotadd at boot time\\n\"", "1805": "\"cannot call gpl only function from proprietary program\\n\"", "1806": "\"cannot convert secid to context\"", "1807": "\"cannot create audit fsnotify group\"", "1808": "\"cannot halt\"", "1809": "\"cannot initialize netlink socket in namespace\"", "1810": "\"cannot start thread audit_prune_tree\"", "1811": "\"cap_fi\"", "1812": "\"cap_fp\"", "1813": "\"cap_last_cap\"", "1814": "\"cap_pe\"", "1815": "\"cap_pi\"", "1816": "\"cap_pp\"", "1817": "\"cascade\"", "1818": "\"cat \"", "1819": "\"catastrophic error detected\\n\"", "1820": "\"cb\"", "1821": "\"cbflood: %ld\\n\"", "1822": "\"ccversion  %s\\n\"", "1823": "\"ce: %s increased min_delta_ns to %llu nsec\\n\"", "1824": "\"ce: reprogramming failure. giving up\\n\"", "1825": "\"ceg\"", "1826": "\"cfs_period_us\"", "1827": "\"cfs_quota_us\"", "1828": "\"cgroup\"", "1829": "\"cgroup.clone_children\"", "1830": "\"cgroup.controllers\"", "1831": "\"cgroup.populated\"", "1832": "\"cgroup.procs\"", "1833": "\"cgroup.sane_behavior\"", "1834": "\"cgroup.subtree_control\"", "1835": "\"cgroup: failed to update controllers for the default hierarchy (%d), further operations may crash or hang\\n\"", "1836": "\"cgroup: update_dfl_csses failed to make progress, aborting in inconsistent state\\n\"", "1837": "\"cgroup: using legacy files on the default hierarchy\\n\"", "1838": "\"cgroup__devel__legacy_files_on_dfl\"", "1839": "\"cgroup_css_links\"", "1840": "\"cgroup_disable=\"", "1841": "\"cgroup_mutex or rcu read lock required\"", "1842": "\"cgroup_subsys_name %s too long\\n\"", "1843": "\"char\"", "1844": "\"check\"", "1845": "\"cipso_cache_bucket_size\"", "1846": "\"cipso_cache_enable\"", "1847": "\"cipso_rbm_optfmt\"", "1848": "\"cipso_rbm_strictvalid\"", "1849": "\"class name\"", "1850": "\"cleanup\"", "1851": "\"cleanupmore\"", "1852": "\"clear breakpoint\"", "1853": "\"clear_request_timeout\"", "1854": "\"clock-delta\"", "1855": "\"clockevent\"", "1856": "\"clockevents\"", "1857": "\"clockevents: \"", "1858": "\"clone_children\"", "1859": "\"cm\"", "1860": "\"cmode\"", "1861": "\"code at %08lx: \"", "1862": "\"coming\"", "1863": "\"command ignored\\n%s\\n\"", "1864": "\"command only available during kdb_init()\\n\"", "1865": "\"command\"", "1866": "\"commit_creds(%p{%d,%d})\"", "1867": "\"common symbol: %s\\n\"", "1868": "\"common_\"", "1869": "\"common_flags\"", "1870": "\"common_pid\"", "1871": "\"common_preempt_count\"", "1872": "\"common_tgid\"", "1873": "\"common_type\"", "1874": "\"compact_memory\"", "1875": "\"compact_unevictable_allowed\"", "1876": "\"compat-log\"", "1877": "\"complete\"", "1878": "\"completed=%ld  gpnum=%ld  age=%ld  max=%ld\\n\"", "1879": "\"component: %s, time: %u\\n\"", "1880": "\"con-bounces\"", "1881": "\"concurrent rmmod and shutdown illegal!\\n\"", "1882": "\"conf\"", "1883": "\"config.gz\"", "1884": "\"config_data.h\"", "1885": "\"connect_mode\"", "1886": "\"console_cmdline.h\"", "1887": "\"console_lock\"", "1888": "\"contentions\"", "1889": "\"continue execution\"", "1890": "\"cookie_preserve_enable\"", "1891": "\"core dump path required.\\n\"", "1892": "\"core section allocation order:\\n\"", "1893": "\"core\"", "1894": "\"core_pattern\"", "1895": "\"core_pipe_limit\"", "1896": "\"core_uses_pid\"", "1897": "\"could not add '%s' (incompatible \"", "1898": "\"could not add '%s' (out of memory)\\n\"", "1899": "\"could not allocate control_code_buffer\\n\"", "1900": "\"could not allocate memory for swsusp_header\\n\"", "1901": "\"could not allocate new defcmd_set entry for %s\\n\"", "1902": "\"could not allocate new kdb_command \"", "1903": "\"could not allocate swap buffer\\n\"", "1904": "\"could not create file\\n\"", "1905": "\"could not create tracefs \"", "1906": "\"could not create tracefs '%s' directory\\n\"", "1907": "\"could not create tracefs '%s/filter' entry\\n\"", "1908": "\"could not create tracefs 'available_events' entry\\n\"", "1909": "\"could not create tracefs 'events' directory\\n\"", "1910": "\"could not create tracefs 'set_event' entry\\n\"", "1911": "\"could not insert probe at %s+%lu: %d\\n\"", "1912": "\"could not register function stat for cpu %d\\n\"", "1913": "\"could not remove '%s' (not found)\\n\"", "1914": "\"could not save data for '%s' \"", "1915": "\"could not switch to one-shot mode:\"", "1916": "\"couldn't find or set field in one of a subsystem's events\"", "1917": "\"count %u\\n\"", "1918": "\"cpu %d:\\n\"", "1919": "\"cpu %ld is not online\\n\"", "1920": "\"cpu recursion\"", "1921": "\"cpu\"", "1922": "\"cpu#%d, %u.%03u mhz\\n\"", "1923": "\"cpu#%d\\n\"", "1924": "\"cpu%d %u 0 %u %u %u %u %llu %llu %lu\"", "1925": "\"cpu%d attaching null sched-domain.\\n\"", "1926": "\"cpu%d attaching sched-domain:\\n\"", "1927": "\"cpu%d is up\\n\"", "1928": "\"cpu%d\"", "1929": "\"cpu%d\\n\"", "1930": "\"cpu\\n\"", "1931": "\"cpu_dma_latency\"", "1932": "\"cpu_exclusive\"", "1933": "\"cpu_hotplug.lock\"", "1934": "\"cpu_off\"", "1935": "\"cpu_on\"", "1936": "\"cpu_stop: %s(%p) leaked preempt count\\n\"", "1937": "\"cpuacct.h\"", "1938": "\"cpudeadline.h\"", "1939": "\"cpudump\"", "1940": "\"cpuend\"", "1941": "\"cpuofl\"", "1942": "\"cpuonl\"", "1943": "\"cpupri.h\"", "1944": "\"cpuqs\"", "1945": "\"cpus\"", "1946": "\"cpuset\"", "1947": "\"cpuset,noprefix,\"", "1948": "\"cpuset: failed to transfer tasks out of empty cpuset \"", "1949": "\"cpustart\"", "1950": "\"crash kernel\"", "1951": "\"crash_kexec_post_notifiers\"", "1952": "\"crashkernel: '-' expected\\n\"", "1953": "\"crashkernel: invalid size\\n\"", "1954": "\"crashkernel: memory value expected\\n\"", "1955": "\"crashkernel: unrecognized char\\n\"", "1956": "\"create\"", "1957": "\"create_direct obtained virq %d\\n\"", "1958": "\"create_direct virq allocation failed\\n\"", "1959": "\"creating rcu_torture_boost task\"", "1960": "\"cred: ->*gid = { %d,%d,%d,%d }\\n\"", "1961": "\"cred: ->*uid = { %d,%d,%d,%d }\\n\"", "1962": "\"cred: ->magic=%x, put_addr=%p\\n\"", "1963": "\"cred: ->security is %p\\n\"", "1964": "\"cred: ->usage=%d, subscr=%d\\n\"", "1965": "\"cred: put_cred_rcu() sees %p with usage %d\\n\"", "1966": "\"cred: put_cred_rcu() sees %p with\"", "1967": "\"cred_jar\"", "1968": "\"critical breakpoint error, kernel memory destroyed at: %lx\\n\"", "1969": "\"css_set %p\\n\"", "1970": "\"ctrl-alt-del\"", "1971": "\"ctx\"", "1972": "\"curr->pid\"", "1973": "\"current pid: %d comm: %s / idle pid: %d comm: %s\"", "1974": "\"current_css_set\"", "1975": "\"current_css_set_cg_links\"", "1976": "\"current_css_set_refcount\"", "1977": "\"cxt.lwsa: out of memory\"", "1978": "\"d\"", "1979": "\"dad_transmits\"", "1980": "\"dama_slave_timeout\"", "1981": "\"data access\"", "1982": "\"data write\"", "1983": "\"datar\"", "1984": "\"dataw\"", "1985": "\"date       %04d-%02d-%02d %02d:%02d:%02d \"", "1986": "\"ddcmp\"", "1987": "\"debug\"", "1988": "\"debug(g)\"", "1989": "\"debug.h\"", "1990": "\"debug_active\"", "1991": "\"debug_core.h\"", "1992": "\"debug_stoppable\"", "1993": "\"decnet\"", "1994": "\"decnet_mem\"", "1995": "\"decnet_rmem\"", "1996": "\"decnet_wmem\"", "1997": "\"default domain set to @0x%p\\n\"", "1998": "\"default\"", "1999": "\"default_device\"", "2000": "\"default_path_quality\"", "2001": "\"defcmd\"", "2002": "\"deferredwake\"", "2003": "\"define a set of commands, down to endefcmd\"", "2004": "\"delay_first_probe_time\"", "2005": "\"delete command needs an event name.\\n\"", "2006": "\"delete\"", "2007": "\"dentry-state\"", "2008": "\"deny\"", "2009": "\"depth: %i  max: %lu!\\n\"", "2010": "\"description\"", "2011": "\"dev\"", "2012": "\"dev_weight\"", "2013": "\"devices\"", "2014": "\"devname\"", "2015": "\"dfh\"", "2016": "\"di_count\"", "2017": "\"dir-notify-enable\"", "2018": "\"dirty_background_bytes\"", "2019": "\"dirty_background_ratio\"", "2020": "\"dirty_bytes\"", "2021": "\"dirty_expire_centisecs\"", "2022": "\"dirty_ratio\"", "2023": "\"dirty_writeback_centisecs\"", "2024": "\"dirtytime_expire_seconds\"", "2025": "\"disable breakpoint\"", "2026": "\"disable irq lockup detection when true\"", "2027": "\"disable nmi entry to kdb\"", "2028": "\"disable_event\"", "2029": "\"disable_nmi\"", "2030": "\"disable_policy\"", "2031": "\"disable_xfrm\"", "2032": "\"disabled (cpu%i): hardware events not enabled\\n\"", "2033": "\"disabled (cpu%i): not supported (no lapic?)\\n\"", "2034": "\"disabled (cpu%i): unable to create perf event: %ld\\n\"", "2035": "\"disabled\"", "2036": "\"disabled\\n\"", "2037": "\"disabling %s control group\"", "2038": "\"disabling ftrace selftests due to running tracer '%s'\\n\"", "2039": "\"disabling irq #%d\\n\"", "2040": "\"disabling lock debugging due to kernel taint\\n\"", "2041": "\"disabling non-boot cpus ...\\n\"", "2042": "\"disabling patch '%s'\\n\"", "2043": "\"discard\"", "2044": "\"discarding saved data for %s \"", "2045": "\"discovery\"", "2046": "\"discovery_slots\"", "2047": "\"discovery_timeout\"", "2048": "\"display active task list\"", "2049": "\"display breakpoints\"", "2050": "\"display exception frame\"", "2051": "\"display help message\"", "2052": "\"display help on | grep\"", "2053": "\"display memory contents, also mdwcn, e.g. md8c1\"", "2054": "\"display memory symbolically\"", "2055": "\"display per_cpu variables\"", "2056": "\"display physical memory\"", "2057": "\"display raw memory\"", "2058": "\"display registers\"", "2059": "\"display stack for process <pid>\"", "2060": "\"display syslog buffer\"", "2061": "\"div by zero\\n\"", "2062": "\"dl_nr_running\"", "2063": "\"dmesg\"", "2064": "\"dmesg_restrict\"", "2065": "\"dn_count\"", "2066": "\"do not call blocking ops when !task_running; \"", "2067": "\"does not load-balance\\n\"", "2068": "\"doing %s, parsing args: '%s'\\n\"", "2069": "\"doing %s: %s='%s'\\n\"", "2070": "\"domain%d %*pb\"", "2071": "\"domain%d\"", "2072": "\"domainname %s\\n\"", "2073": "\"domainname\"", "2074": "\"done.\"", "2075": "\"done.\\n\"", "2076": "\"dr_count\"", "2077": "\"driverloader\"", "2078": "\"drop_caches\"", "2079": "\"dropped\"", "2080": "\"drops\"", "2081": "\"drv_data\"", "2082": "\"dst_gc_interval\"", "2083": "\"dti\"", "2084": "\"due to %s @ \"", "2085": "\"due to cpu switch\\n\"", "2086": "\"due to debug @ \"", "2087": "\"due to kdb_enter()\\n\"", "2088": "\"due to keyboard entry\\n\"", "2089": "\"due to nonmaskable interrupt @ \"", "2090": "\"due to oops @ \"", "2091": "\"due to recursion @ \"", "2092": "\"due to system nonmaskable interrupt\\n\"", "2093": "\"dummy\"", "2094": "\"dump\"", "2095": "\"dumping ftrace buffer:\\n\"", "2096": "\"dumping kprobe:\\n\"", "2097": "\"dup ret instances\"", "2098": "\"dup xol area\"", "2099": "\"duplicate kdb command registered: \"", "2100": "\"duration of each boost test, seconds.\"", "2101": "\"duration of fqs bursts (us), 0 to disable\"", "2102": "\"dynamic debug error adding module: %s\\n\"", "2103": "\"e == 1 && f == 1 && g == 1 && h == 1\"", "2104": "\"e == 1 || f == 1 || g == 1 || h == 1\"", "2105": "\"e\"", "2106": "\"e.\"", "2107": "\"e01\"", "2108": "\"earlyexit\"", "2109": "\"echo the kernel .config file used to build the kernel\"", "2110": "\"echo usecs [iters] > \"", "2111": "\"edge\"", "2112": "\"ef\"", "2113": "\"effective_cpus\"", "2114": "\"effective_mems\"", "2115": "\"efgh\"", "2116": "\"elfcorehdr\"", "2117": "\"empty!\\n\"", "2118": "\"emulated 'pipe'.\\n\"", "2119": "\"enable breakpoint\"", "2120": "\"enable debug-object double call_rcu() testing\"", "2121": "\"enable verbose debugging printk()s\"", "2122": "\"enable\"", "2123": "\"enable_event\"", "2124": "\"enable_irq before setup/request_irq: irq %u\\n\"", "2125": "\"enabled event during self test!\\n\"", "2126": "\"enabled on all cpus, permanently consumes one hw-pmu counter.\\n\"", "2127": "\"enabled\"", "2128": "\"enabled\\n\"", "2129": "\"enabling non-boot cpus ...\\n\"", "2130": "\"enabling patch '%s'\\n\"", "2131": "\"end boost kthread@notreached\"", "2132": "\"end boost kthread@rcu_wait\"", "2133": "\"end boost kthread@rcu_yield\"", "2134": "\"end context switch\"", "2135": "\"end of test: failure\"", "2136": "\"end of test: rcu_hotplug\"", "2137": "\"end of test: success\"", "2138": "\"end rcu core\"", "2139": "\"end scheduler-tick\"", "2140": "\"end\"", "2141": "\"endefcmd\"", "2142": "\"endefcmd\\n\"", "2143": "\"endian\"", "2144": "\"endwait\"", "2145": "\"enter <q> to end, <cr> to continue:\"", "2146": "\"enter kgdb mode\"", "2147": "\"entering kgdb\\n\"", "2148": "\"entropy_avail\"", "2149": "\"env\"", "2150": "\"epoll\"", "2151": "\"error converting sid to string\"", "2152": "\"error disabling all events\\n\"", "2153": "\"error disabling system %s\\n\"", "2154": "\"error enabling all events\\n\"", "2155": "\"error enabling system %s\\n\"", "2156": "\"error in audit_log_task_context\"", "2157": "\"error on deleting a probe.\\n\"", "2158": "\"error on entry: not idle task\"", "2159": "\"error on exit: not idle task\"", "2160": "\"error on getting 2nd new probe.\\n\"", "2161": "\"error on getting 2nd test probe.\\n\"", "2162": "\"error on getting new probe.\\n\"", "2163": "\"error on getting probe file.\\n\"", "2164": "\"error on getting test probe.\\n\"", "2165": "\"error on probing function entry.\\n\"", "2166": "\"error on probing function return.\\n\"", "2167": "\"error taking cpu%d down: %d\\n\"", "2168": "\"error taking cpu%d up: %d\\n\"", "2169": "\"error updating lsm filters\"", "2170": "\"error updating watch, removing\"", "2171": "\"error updating watch, skipping\"", "2172": "\"error: !sd_load_balance domain\"", "2173": "\"error: %s\\n\\n\"", "2174": "\"error: domain->groups does not contain\"", "2175": "\"error: domain->span does not contain \"", "2176": "\"error: empty group\\n\"", "2177": "\"error: group is null\\n\"", "2178": "\"error: groups don't span domain->span\\n\"", "2179": "\"error: hwirq 0x%x is too large for %s\\n\"", "2180": "\"error: no free irqs available below %i maximum\\n\"", "2181": "\"error: no kgdb i/o module available\\n\"", "2182": "\"error: parent span is not a superset \"", "2183": "\"error: repeated cpus\\n\"", "2184": "\"error: there should be no unused kprobe here.\\n\"", "2185": "\"error: virq%i is already associated\"", "2186": "\"error: virq%i is not allocated\"", "2187": "\"error_burst\"", "2188": "\"error_cost\"", "2189": "\"error_level\"", "2190": "\"es\"", "2191": "\"ethernet\"", "2192": "\"event %s/%s doesn't exist.\\n\"", "2193": "\"event name is not specified\\n\"", "2194": "\"event trace: could not activate\"", "2195": "\"event trace: could not enable event \"", "2196": "\"events\"", "2197": "\"events_freezable\"", "2198": "\"events_freezable_power_efficient\"", "2199": "\"events_highpri\"", "2200": "\"events_long\"", "2201": "\"events_power_efficient\"", "2202": "\"events_unbound\"", "2203": "\"exception-trace\"", "2204": "\"exec_clock\"", "2205": "\"execdomains\"", "2206": "\"execute the probed insn, sending sigill.\"", "2207": "\"executing a continue without signal passing\\n\"", "2208": "\"exit\"", "2209": "\"exit_creds(%u,%p,%p,{%d,%d})\"", "2210": "\"exiting task \\\"%s\\\" (%d) is an active irq thread (irq %d)\\n\"", "2211": "\"expanded resource %s due to conflict with %s\\n\"", "2212": "\"expected:   %.*s\\n\"", "2213": "\"extended_window_size\"", "2214": "\"extfrag_threshold\"", "2215": "\"f\"", "2216": "\"fail to deliver signal %d to process %d.\\n\"", "2217": "\"failed to alloc mask\"", "2218": "\"failed to allocate argument[%d] name.\\n\"", "2219": "\"failed to allocate filename.\\n\"", "2220": "\"failed to allocate memory for command '%s'.\\n\"", "2221": "\"failed to allocate ring buffer on cpu %ld\\n\"", "2222": "\"failed to allocate trace_uprobe.(%d)\\n\"", "2223": "\"failed to apply patch '%s' to module '%s' (%d)\\n\"", "2224": "\"failed to broadcast timer tick. some cpus may be unresponsive.\\n\"", "2225": "\"failed to create files (%d) while rebinding 0x%x to default root\\n\"", "2226": "\"failed to create ftrace wakeup test thread \"", "2227": "\"failed to create system directory %s\\n\"", "2228": "\"failed to create watchdog threads, disabled\\n\"", "2229": "\"failed to enable trace event: %s\\n\"", "2230": "\"failed to find symbol %s\\n\"", "2231": "\"failed to get filter for '%s', err %d\\n\"", "2232": "\"failed to init %s tracer, init returned %d\\n\"", "2233": "\"failed to kmalloc\\n\"", "2234": "\"failed to match filter '%s', expected %d\\n\"", "2235": "\"failed to parse address or file.\\n\"", "2236": "\"failed to re-register probe %s on\"", "2237": "\"failed to register ftrace handler for function '%s' (%d)\\n\"", "2238": "\"failed to register kprobe event: %s\\n\"", "2239": "\"failed to register probe event(%d)\\n\"", "2240": "\"failed to register trace events module notifier\\n\"", "2241": "\"failed to register uprobe event: %s\\n\"", "2242": "\"failed to request resources for %s (irq %d) on irqchip %s\\n\"", "2243": "\"failed to set ftrace filter for function '%s' (%d)\\n\"", "2244": "\"failed to set type for irq%d\\n\"", "2245": "\"failed to start irqsoff tracer\\n\"", "2246": "\"failed to start wakeup tracer\\n\"", "2247": "\"failed to swap buffers due to commit in progress\\n\"", "2248": "\"failed!\\n\"", "2249": "\"failed, unwanted pred visited for filter %s\\n\"", "2250": "\"failed\\n\"", "2251": "\"fast_poll_increase\"", "2252": "\"fd %d is not pointing to valid bpf_map\\n\"", "2253": "\"fd0=%d fd1=%d\"", "2254": "\"fd=%d flags=0x%x\"", "2255": "\"features.h\"", "2256": "\"fi\"", "2257": "\"field not found\"", "2258": "\"fifo prio for consumer\"", "2259": "\"fifo prio for producer\"", "2260": "\"file-max\"", "2261": "\"file-nr\"", "2262": "\"files_cache\"", "2263": "\"filestream_centisecs\"", "2264": "\"filter\"", "2265": "\"final section addresses:\\n\"", "2266": "\"find_task_by_pid_ns() needs rcu_read_lock()\"", "2267": "\"finished\\n\"", "2268": "\"finit_module: fd=%d, uargs=%p, flags=%i\\n\"", "2269": "\"first=%llu [cold cached]\"", "2270": "\"fixing request to [0x%llx-0x%llx]\\n\"", "2271": "\"flags mismatch irq %d. %08x (%s) vs. %08x (%s)\\n\"", "2272": "\"flags\"", "2273": "\"flush\"", "2274": "\"follow 0/-e convention\\n\"", "2275": "\"followersleep\"", "2276": "\"force_igmp_version\"", "2277": "\"force_mld_version\"", "2278": "\"forcing reboot\\n\"", "2279": "\"forkexec_idx\"", "2280": "\"format\"", "2281": "\"format:\\n\"", "2282": "\"forwarding\"", "2283": "\"fp\"", "2284": "\"fqs_duration=%d fqs_holdoff=%d fqs_stutter=%d \"", "2285": "\"fqsend\"", "2286": "\"fqsstart\"", "2287": "\"fqswait\"", "2288": "\"fqswaitsig\"", "2289": "\"frame pointer is read only\\n\"", "2290": "\"free_dquots\"", "2291": "\"freezer\"", "2292": "\"freezing remaining freezable tasks ... \"", "2293": "\"freezing user space processes ... \"", "2294": "\"freezing\"", "2295": "\"frontmerge\"", "2296": "\"frozen\"", "2297": "\"fs\"", "2298": "\"fs_cache\"", "2299": "\"ftrace failed to modify \"", "2300": "\"ftrace faulted on modifying \"", "2301": "\"ftrace faulted on unknown error \"", "2302": "\"ftrace faulted on writing \"", "2303": "\"ftrace ops had %ps for function\\n\"", "2304": "\"ftrace record flags: %lx\\n\"", "2305": "\"ftrace\"", "2306": "\"ftrace-test\"", "2307": "\"ftrace: failed to allocate memory for functions\\n\"", "2308": "\"ftrace=\"", "2309": "\"ftrace_dump_on_oops\"", "2310": "\"ftrace_enabled\"", "2311": "\"ftrace_graph: couldn't activate tracepoint\"", "2312": "\"fua\"", "2313": "\"function graph tracer: not enough memory\\n\"", "2314": "\"function\"", "2315": "\"function%d\"", "2316": "\"function_graph\"", "2317": "\"function_profile_enabled\"", "2318": "\"fver=%x\"", "2319": "\"g\"", "2320": "\"gc_elasticity\"", "2321": "\"gc_interval\"", "2322": "\"gc_min_interval\"", "2323": "\"gc_min_interval_ms\"", "2324": "\"gc_stale_time\"", "2325": "\"gc_thresh\"", "2326": "\"gc_thresh1\"", "2327": "\"gc_thresh2\"", "2328": "\"gc_thresh3\"", "2329": "\"gc_timeout\"", "2330": "\"gcno\"", "2331": "\"gcov\"", "2332": "\"gcov.h\"", "2333": "\"gcov: \"", "2334": "\"gcov_persist=\"", "2335": "\"get\"", "2336": "\"getrq\"", "2337": "\"gh\"", "2338": "\"go must execute on the entry cpu, \"", "2339": "\"go\"", "2340": "\"going\"", "2341": "\"gpc=%ld gps=%ld nn=%ld ndw%ld\\n\"", "2342": "\"gpl\"", "2343": "\"gps behind\"", "2344": "\"grep \"", "2345": "\"grephelp\"", "2346": "\"group name is not specified\\n\"", "2347": "\"h\"", "2348": "\"handling %s with %p\\n\"", "2349": "\"hardirqs last  enabled at (%u): \"", "2350": "\"hardirqs last disabled at (%u): \"", "2351": "\"hb_ctl_path\"", "2352": "\"hb_interval\"", "2353": "\"header_event\"", "2354": "\"header_page\"", "2355": "\"help\"", "2356": "\"hi\"", "2357": "\"hibernation debug: waiting for 5 seconds.\\n\"", "2358": "\"hierarchical rcu implementation.\\n\"", "2359": "\"highmem_is_dirtyable\"", "2360": "\"hit    time            avg             s^2\\n\"", "2361": "\"hm#1, depth: %u [%u], %016lx != %016lx\\n\"", "2362": "\"hm#2, depth: %u [%u], %016lx != %016lx\\n\"", "2363": "\"hm, tasklist_lock locked, retrying... \"", "2364": "\"hmm, kdb_reboot did not reboot, spinning here\\n\"", "2365": "\"holders\"", "2366": "\"holdoff between bursts (jiffies)\"", "2367": "\"holdoff between floods (jiffies)\"", "2368": "\"holdoff time within fqs bursts (us)\"", "2369": "\"holdtime-avg\"", "2370": "\"holdtime-max\"", "2371": "\"holdtime-min\"", "2372": "\"holdtime-total\"", "2373": "\"home=/\"", "2374": "\"hop_limit\"", "2375": "\"hostname\"", "2376": "\"hotplug\"", "2377": "\"hrtimer\"", "2378": "\"hugepages_treat_as_movable\"", "2379": "\"hugetlb_shm_group\"", "2380": "\"huh, entered softirq %u %s %p with preempt_count %08x, exited with %08x?\\n\"", "2381": "\"hung_task: blocked tasks\"", "2382": "\"hung_task_check_count\"", "2383": "\"hung_task_panic\"", "2384": "\"hung_task_panic=\"", "2385": "\"hung_task_timeout_secs\"", "2386": "\"hung_task_warnings\"", "2387": "\"i\"", "2388": "\"i/o\"", "2389": "\"icmp\"", "2390": "\"icmp_echo_ignore_all\"", "2391": "\"icmp_echo_ignore_broadcasts\"", "2392": "\"icmp_errors_use_inbound_ifaddr\"", "2393": "\"icmp_ignore_bogus_error_responses\"", "2394": "\"icmp_ratelimit\"", "2395": "\"icmp_ratemask\"", "2396": "\"id\"", "2397": "\"id: %d\\n\"", "2398": "\"idle: \"", "2399": "\"idle_idx\"", "2400": "\"idle_timeout\"", "2401": "\"ieee_emulation_warnings\"", "2402": "\"if it really is, submit a report to the linux kernel \"", "2403": "\"if you just came from a suspend/resume,\\n\"", "2404": "\"if\"", "2405": "\"igmp_max_memberships\"", "2406": "\"igmp_max_msf\"", "2407": "\"ignore-unaligned-usertrap\"", "2408": "\"ikcfg_ed\"", "2409": "\"ikcfg_st\"", "2410": "\"illegal idle entry in rcu read-side critical section.\"", "2411": "\"illegal idle entry in rcu-bh read-side critical section.\"", "2412": "\"illegal idle entry in rcu-sched read-side critical section.\"", "2413": "\"illegal integer value\"", "2414": "\"illegal operation for field type\"", "2415": "\"illegal synchronize_rcu() in rcu read-side critical section\"", "2416": "\"illegal synchronize_sched() in rcu read-side critical section\"", "2417": "\"illegal synchronize_srcu() in same-type srcu (or rcu) read-side critical section\"", "2418": "\"illegal use of '!'\"", "2419": "\"image_crc32\"", "2420": "\"imbalance_pct\"", "2421": "\"imm\"", "2422": "\"in %s\\n\"", "2423": "\"in-\"", "2424": "\"in_atomic(): %d, irqs_disabled(): %d, pid: %d, name: %s\\n\"", "2425": "\"inc1\"", "2426": "\"inc2\"", "2427": "\"inclusion.\\n\"", "2428": "\"incomplete 'defcmd' set, forcing endefcmd\\n\"", "2429": "\"inconsistent {%s} -> {%s} usage.\\n\"", "2430": "\"incorrect value in post_handler\\n\"", "2431": "\"inet_peer_gc_maxtime\"", "2432": "\"inet_peer_gc_mintime\"", "2433": "\"inet_peer_maxttl\"", "2434": "\"inet_peer_minttl\"", "2435": "\"inet_peer_threshold\"", "2436": "\"info: %s detected stalls on cpus/tasks:\"", "2437": "\"info: %s self-detected stall on cpu\"", "2438": "\"info: lockdep is turned off.\\n\"", "2439": "\"info: rcu_tasks detected stalls on tasks:\\n\"", "2440": "\"info: stall ended before state dump start\\n\"", "2441": "\"info: task %s:%d blocked for more than %ld seconds.\\n\"", "2442": "\"info: timekeeping: cycle offset (%lld) is larger than the the '%s' clock's 50%% safety margin (%lld)\\n\"", "2443": "\"info: trying to register non-static key.\\n\"", "2444": "\"inherit_noatime\"", "2445": "\"inherit_nodefrag\"", "2446": "\"inherit_nodump\"", "2447": "\"inherit_nosymlinks\"", "2448": "\"inherit_sync\"", "2449": "\"inheritable\"", "2450": "\"init failed\\n\"", "2451": "\"init section allocation order:\\n\"", "2452": "\"init_module: umod=%p, len=%lu, uargs=%p\\n\"", "2453": "\"initcall %lli_%pf returned 0 after %lld usecs\\n\"", "2454": "\"initial use\"", "2455": "\"initialise system trusted keyring\\n\"", "2456": "\"initialized\"", "2457": "\"initializing cgroup subsys %s\\n\"", "2458": "\"initializing netlink subsys (%s)\\n\"", "2459": "\"inode-nr\"", "2460": "\"inode-state\"", "2461": "\"inotify\"", "2462": "\"insert\"", "2463": "\"insn state internal bug\\n\"", "2464": "\"inst\"", "2465": "\"instruction boundary.\\n\"", "2466": "\"instruction(i)\"", "2467": "\"instruction(register)\"", "2468": "\"internal.h\"", "2469": "\"internals.h\"", "2470": "\"interval between boost tests, seconds.\"", "2471": "\"intree\"", "2472": "\"inv\"", "2473": "\"invalid 'pipe', see grephelp\\n\"", "2474": "\"invalid access to map value, value_size=%d off=%d size=%d\\n\"", "2475": "\"invalid argument[%d] name: %s\\n\"", "2476": "\"invalid bpf_alu opcode %x\\n\"", "2477": "\"invalid bpf_context access off=%d size=%d\\n\"", "2478": "\"invalid bpf_jmp opcode %x\\n\"", "2479": "\"invalid bpf_ld mode\\n\"", "2480": "\"invalid bpf_ld_imm insn\\n\"", "2481": "\"invalid bpf_ld_imm64 insn\\n\"", "2482": "\"invalid cgroup_subsys %d:%s css_alloc=%p css_free=%p name:id=%d:%s\\n\"", "2483": "\"invalid func %d\\n\"", "2484": "\"invalid gcov_persist parameter '%s'\\n\"", "2485": "\"invalid indirect read from stack off %d+%d size %d\\n\"", "2486": "\"invalid insn idx %d insn_cnt %d\\n\"", "2487": "\"invalid map_ptr to access map->key\\n\"", "2488": "\"invalid map_ptr to access map->value\\n\"", "2489": "\"invalid notifier called!\"", "2490": "\"invalid operator\"", "2491": "\"invalid quoted string, see grephelp\\n\"", "2492": "\"invalid signal parameter.<-signal>\\n\"", "2493": "\"invalid size of register spill\\n\"", "2494": "\"io_delay_type\"", "2495": "\"iomem\"", "2496": "\"iomem=\"", "2497": "\"ioports\"", "2498": "\"ip\"", "2499": "\"ip6_queue_maxlen\"", "2500": "\"ip6frag_high_thresh\"", "2501": "\"ip6frag_low_thresh\"", "2502": "\"ip6frag_secret_interval\"", "2503": "\"ip6frag_time\"", "2504": "\"ip_conntrack_buckets\"", "2505": "\"ip_conntrack_checksum\"", "2506": "\"ip_conntrack_count\"", "2507": "\"ip_conntrack_log_invalid\"", "2508": "\"ip_conntrack_max\"", "2509": "\"ip_conntrack_tcp_be_liberal\"", "2510": "\"ip_conntrack_tcp_loose\"", "2511": "\"ip_conntrack_tcp_max_retrans\"", "2512": "\"ip_default_mode\"", "2513": "\"ip_default_ttl\"", "2514": "\"ip_dynaddr\"", "2515": "\"ip_forward\"", "2516": "\"ip_local_port_range\"", "2517": "\"ip_no_pmtu_disc\"", "2518": "\"ip_nonlocal_bind\"", "2519": "\"ip_queue_maxlen\"", "2520": "\"ipfrag_high_thresh\"", "2521": "\"ipfrag_low_thresh\"", "2522": "\"ipfrag_secret_interval\"", "2523": "\"ipfrag_time\"", "2524": "\"ipgre\"", "2525": "\"ipi callback %ps sent to offline cpu\\n\"", "2526": "\"ipi on offline cpu %d\\n\"", "2527": "\"ipmi\"", "2528": "\"ipv4\"", "2529": "\"ipv6\"", "2530": "\"ipx\"", "2531": "\"ipx_pprop_broadcasting\"", "2532": "\"irda\"", "2533": "\"irix_sgid_inherit\"", "2534": "\"irix_symlink_mode\"", "2535": "\"irq %d device %s returned irq_wake_thread \"", "2536": "\"irq %d for msi\\n\"", "2537": "\"irq %d uses trigger mode %u; requested %u\\n\"", "2538": "\"irq %d, desc: %p, depth: %d, count: %d, unhandled: %d\\n\"", "2539": "\"irq %u handler %pf enabled interrupts\\n\"", "2540": "\"irq [%d-%d] for msi\\n\"", "2541": "\"irq lockup detection disabled\\n\"", "2542": "\"irq poll in progress on cpu %d for irq %d\\n\"", "2543": "\"irq\"", "2544": "\"irq/%d-%s\"", "2545": "\"irq/default_smp_affinity\"", "2546": "\"irq/prof_cpu_mask\"", "2547": "\"irq: \"", "2548": "\"irq_create_mapping(0x%p, 0x%lx)\\n\"", "2549": "\"irqfixup\"", "2550": "\"irqpoll\"", "2551": "\"irqsoff\"", "2552": "\"is unknown, you have been warned.\\n\"", "2553": "\"isa\"", "2554": "\"isolcpus=\"", "2555": "\"issue\"", "2556": "\"item=%d\"", "2557": "\"j\"", "2558": "\"j=%04x bt=%04x\\n\"", "2559": "\"jiffies: %lu\\n\"", "2560": "\"jmp\"", "2561": "\"jump out of range from insn %d to %d\\n\"", "2562": "\"k\"", "2563": "\"kallsyms\"", "2564": "\"kauditd\"", "2565": "\"kdb command %s failed, kdb diag %d\\n\"", "2566": "\"kdb current process is %s(pid=%d)\\n\"", "2567": "\"kdb risks deadlock\\n\"", "2568": "\"kdb.\"", "2569": "\"kdb: bad result from kdba_db_trap: %d\\n\"", "2570": "\"kdb: error return from kdba_bp_trap: %d\\n\"", "2571": "\"kdb: unexpected reason code: %d\\n\"", "2572": "\"kdb_continue_catastrophic=%d, \"", "2573": "\"kdb_exec_defcmd: could not find commands for %s\\n\"", "2574": "\"kdb_getarea: bad address 0x%lx\\n\"", "2575": "\"kdb_local 1\"", "2576": "\"kdb_local 4\"", "2577": "\"kdb_local 6\"", "2578": "\"kdb_local 8\"", "2579": "\"kdb_parse: command buffer \"", "2580": "\"kdb_parse: too many arguments, \"", "2581": "\"kdb_private.h\"", "2582": "\"kdb_putarea: bad address 0x%lx\\n\"", "2583": "\"kdbgetsymval: returns 0\\n\"", "2584": "\"kdbgetsymval: returns 1, \"", "2585": "\"kdbgetsymval: symname=%s, symtab=%p\\n\"", "2586": "\"kdbnearsym: addr=0x%lx, symtab=%p\\n\"", "2587": "\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"", "2588": "\"kernel panic - not syncing: %s\\n\"", "2589": "\"kernel release\"", "2590": "\"kernel signature verification failed.\\n\"", "2591": "\"kernel signature verification successful.\\n\"", "2592": "\"kernel subsystem misconfigured verifier\\n\"", "2593": "\"kernel version\"", "2594": "\"kernel\"", "2595": "\"kernel, try again later\\n\"", "2596": "\"kernel.perf_event_max_sample_rate to %d\\n\"", "2597": "\"kernel\\n\"", "2598": "\"kexec: \"", "2599": "\"kexec: memory allocation for saving cpu register states failed\\n\"", "2600": "\"kexec_load_disabled\"", "2601": "\"keys\"", "2602": "\"kgdb only knows signal 9 (pass)\"", "2603": "\"kgdb or $3#33 for kdb\\n\"", "2604": "\"kgdb\"", "2605": "\"kgdbcon\"", "2606": "\"kgdbwait\"", "2607": "\"khelper\"", "2608": "\"khungtaskd\"", "2609": "\"kill\"", "2610": "\"kmalloc()\"", "2611": "\"kmemcheck\"", "2612": "\"kprobe smoke test: \"", "2613": "\"kprobe_events\"", "2614": "\"kprobe_profile\"", "2615": "\"kprobe_target\"", "2616": "\"kprobes-optimization\"", "2617": "\"kptr_restrict\"", "2618": "\"kretprobe_trampoline\"", "2619": "\"ksoftirqd/%u\"", "2620": "\"kstack_depth_to_print\"", "2621": "\"kthreadd\"", "2622": "\"kworker/%s\"", "2623": "\"kworker/dying\"", "2624": "\"lap_keepalive_time\"", "2625": "\"laptop_mode\"", "2626": "\"last=%llu first=%llu max=%llu min=%llu ** avg=%u std=%d std^2=%lld\"", "2627": "\"last_accelerate: %04lx/%04lx, nonlazy_posted: %ld, %c%c\"", "2628": "\"last_unhandled %u ms\\n\"", "2629": "\"lastcb\"", "2630": "\"latency top version : v0.1\\n\"", "2631": "\"latency_stats\"", "2632": "\"latencytop\"", "2633": "\"ld\"", "2634": "\"ldx\"", "2635": "\"lease-break-time\"", "2636": "\"leases-enable\"", "2637": "\"legacy_va_layout\"", "2638": "\"level\"", "2639": "\"license\"", "2640": "\"linear\"", "2641": "\"lines printed\\n\"", "2642": "\"link_fail_timeout\"", "2643": "\"link_fails_count\"", "2644": "\"list loaded kernel modules\"", "2645": "\"live\"", "2646": "\"livepatch\"", "2647": "\"llc\"", "2648": "\"llc2\"", "2649": "\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\"", "2650": "\"load\"", "2651": "\"loaded x.509 cert '%s'\\n\"", "2652": "\"loading compiled-in x.509 certificates\\n\"", "2653": "\"loading segment %d: buf=0x%p bufsz=0x%zx mem=0x%lx memsz=0x%zx\\n\"", "2654": "\"loading\"", "2655": "\"lock-torture types:\"", "2656": "\"lock-torture: invalid torture type: \\\"%s\\\"\\n\"", "2657": "\"lock_busted\"", "2658": "\"lock_stat version 0.4\\n\"", "2659": "\"lock_stat\"", "2660": "\"lock_torture_reader task started\"", "2661": "\"lock_torture_reader\"", "2662": "\"lock_torture_stats task started\"", "2663": "\"lock_torture_stats\"", "2664": "\"lock_torture_stats_print: out of memory, need: %d\"", "2665": "\"lock_torture_writer task started\"", "2666": "\"lock_torture_writer\"", "2667": "\"lockdep\"", "2668": "\"lockdep:%s bad path found in chain graph\\n\"", "2669": "\"lockdep_chains\"", "2670": "\"lockdep_internals.h\"", "2671": "\"lockdep_states.h\"", "2672": "\"lockdep_stats\"", "2673": "\"lockname\"", "2674": "\"lockup suspected\"", "2675": "\"log_martians\"", "2676": "\"logaritmic\"", "2677": "\"logging_level\"", "2678": "\"loginuid_immutable\"", "2679": "\"look up: \\\"%s\\\"\\n\"", "2680": "\"lookups\"", "2681": "\"loopback\"", "2682": "\"lowmem_reserve_ratio\"", "2683": "\"lsmod\"", "2684": "\"lve\"", "2685": "\"m\"", "2686": "\"mac_hid\"", "2687": "\"machine    %s\\n\"", "2688": "\"machine\"", "2689": "\"machine_suspend\"", "2690": "\"magic sysrq key\"", "2691": "\"mailing list together with submitting your code for \"", "2692": "\"map %u.%06lu %d 0x%llx 0x%lx 0x%lx 0x%lx %d\\n\"", "2693": "\"map what?\\n\"", "2694": "\"map_ptr\"", "2695": "\"map_value\"", "2696": "\"map_value_or_null\"", "2697": "\"mark %u.%06lu %s\"", "2698": "\"mark 0.000000 lost %lu events.\\n\"", "2699": "\"max\"", "2700": "\"max_addresses\"", "2701": "\"max_baud_rate\"", "2702": "\"max_burst\"", "2703": "\"max_desync_factor\"", "2704": "\"max_dgram_qlen\"", "2705": "\"max_graph_depth\"", "2706": "\"max_init_retransmits\"", "2707": "\"max_interval\"", "2708": "\"max_lock_depth\"", "2709": "\"max_map_count\"", "2710": "\"max_newidle_lb_cost\"", "2711": "\"max_noreply_time\"", "2712": "\"max_queued_events\"", "2713": "\"max_resvport\"", "2714": "\"max_size\"", "2715": "\"max_tx_data_size\"", "2716": "\"max_tx_window\"", "2717": "\"max_user_instances\"", "2718": "\"max_user_watches\"", "2719": "\"max_vruntime\"", "2720": "\"maximum\"", "2721": "\"maximum_packet_length\"", "2722": "\"maximum_retry_count\"", "2723": "\"maximum_virtual_circuits\"", "2724": "\"mc_forwarding\"", "2725": "\"mcast_solicit\"", "2726": "\"md\"", "2727": "\"mdp\"", "2728": "\"mdr\"", "2729": "\"mds\"", "2730": "\"meaningless filter expression\"", "2731": "\"medium_id\"", "2732": "\"mem_exclusive\"", "2733": "\"mem_hardwall\"", "2734": "\"membase\"", "2735": "\"memory error \"", "2736": "\"memory size\"", "2737": "\"memory value expected after '@'\\n\"", "2738": "\"memory\"", "2739": "\"memory_bandwidth\"", "2740": "\"memory_failure_early_kill\"", "2741": "\"memory_failure_recovery\"", "2742": "\"memory_migrate\"", "2743": "\"memory_pressure\"", "2744": "\"memory_pressure_enabled\"", "2745": "\"memory_spread_page\"", "2746": "\"memory_spread_slab\"", "2747": "\"mems\"", "2748": "\"mems_allowed:\\t%*pb\\n\"", "2749": "\"mems_allowed_list:\\t%*pbl\\n\"", "2750": "\"message\"", "2751": "\"message_burst\"", "2752": "\"message_cost\"", "2753": "\"meta\"", "2754": "\"metacharacters:\\n\"", "2755": "\"migration/%u\"", "2756": "\"min_adv_mss\"", "2757": "\"min_free_kbytes\"", "2758": "\"min_interval\"", "2759": "\"min_pmtu\"", "2760": "\"min_resvport\"", "2761": "\"min_slab_ratio\"", "2762": "\"min_tx_turn_time\"", "2763": "\"min_unmapped_ratio\"", "2764": "\"min_vruntime\"", "2765": "\"minimum\"", "2766": "\"misrouted irq fixup and polling support \"", "2767": "\"misrouted irq fixup support enabled.\\n\"", "2768": "\"missing audit_compare define.  report as a bug\\n\"", "2769": "\"missing field name and/or value\"", "2770": "\"mld_max_msf\"", "2771": "\"mm\"", "2772": "\"mm:%p idx:%d val:%ld\\n\"", "2773": "\"mm_struct\"", "2774": "\"mmap_min_addr\"", "2775": "\"mmiotrace has lost events.\\n\"", "2776": "\"mmiotrace\"", "2777": "\"modify memory contents\"", "2778": "\"modify registers\"", "2779": "\"modprobe\"", "2780": "\"module len %lu truncated\\n\"", "2781": "\"module\"", "2782": "\"module-internal.h\"", "2783": "\"modules linked in:\"", "2784": "\"modules\"", "2785": "\"modules_disabled\"", "2786": "\"more than 1 task in runqueue\\n\"", "2787": "\"mouse_button2_keycode\"", "2788": "\"mouse_button3_keycode\"", "2789": "\"mouse_button_emulation\"", "2790": "\"mq_curmsgs=%ld \"", "2791": "\"mq_msgsize=%ld mq_curmsgs=%ld\"", "2792": "\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"", "2793": "\"mqdes=%d msg_len=%zd msg_prio=%u \"", "2794": "\"mqdes=%d sigev_signo=%d\"", "2795": "\"msg\"", "2796": "\"msgmax\"", "2797": "\"msgmnb\"", "2798": "\"msgmni\"", "2799": "\"mtu\"", "2800": "\"mtu_expires\"", "2801": "\"mutex\"", "2802": "\"mutex-debug.h\"", "2803": "\"mutex.h\"", "2804": "\"mutex_lock\"", "2805": "\"n.\"", "2806": "\"n_barrier_cbs=%d \"", "2807": "\"name \\\"usage\\\" \\\"help\\\"\"", "2808": "\"name\"", "2809": "\"name: %s\\n\"", "2810": "\"name: %s\\naddress: %p\\noffset: %x\\n\"", "2811": "\"name=\"", "2812": "\"nargs=%d\"", "2813": "\"ndiswrapper\"", "2814": "\"need to add type to trace.h\\n\"", "2815": "\"neg\"", "2816": "\"neigh\"", "2817": "\"net\"", "2818": "\"net_rx\"", "2819": "\"net_tx\"", "2820": "\"netdev_budget\"", "2821": "\"netdev_max_backlog\"", "2822": "\"netfilter\"", "2823": "\"netrom\"", "2824": "\"network_latency\"", "2825": "\"network_throughput\"", "2826": "\"network_ttl_initialiser\"", "2827": "\"new mount options do not match the existing superblock, will be ignored\\n\"", "2828": "\"new_pe\"", "2829": "\"new_pi\"", "2830": "\"new_pp\"", "2831": "\"newidle_idx\"", "2832": "\"newreq\"", "2833": "\"nf_conntrack_buckets\"", "2834": "\"nf_conntrack_checksum\"", "2835": "\"nf_conntrack_count\"", "2836": "\"nf_conntrack_frag6_high_thresh\"", "2837": "\"nf_conntrack_frag6_low_thresh\"", "2838": "\"nf_conntrack_log_invalid\"", "2839": "\"nf_conntrack_max\"", "2840": "\"nf_conntrack_tcp_be_liberal\"", "2841": "\"nf_conntrack_tcp_loose\"", "2842": "\"nf_conntrack_tcp_max_retrans\"", "2843": "\"nfqs=%lu/nfqsng=%lu(%lu) fqlh=%lu oqlen=%ld/%ld\\n\"", "2844": "\"ng: some tests are failed. please check them.\\n\"", "2845": "\"ngroups_max\"", "2846": "\"nice prio for consumer\"", "2847": "\"nice prio for producer\"", "2848": "\"nm\"", "2849": "\"nmi watchdog: \"", "2850": "\"nmi_watchdog\"", "2851": "\"no error\"", "2852": "\"no locks held by %s/%d.\\n\"", "2853": "\"no memory to create event subsystem %s\\n\"", "2854": "\"no module found in object\\n\"", "2855": "\"no pid\\n\"", "2856": "\"no process for cpu %ld\\n\"", "2857": "\"no process with pid == %ld found\\n\"", "2858": "\"no set_type function for irq %d (%s)\\n\"", "2859": "\"no task with pid=%d\\n\"", "2860": "\"no torture_shutdown_hook(), skipping.\"", "2861": "\"no versions for exported symbols\"", "2862": "\"no\"", "2863": "\"no_activity_timeout\"", "2864": "\"no_fc_max_cwnd\"", "2865": "\"no_file_caps\"", "2866": "\"no_hz full will not work with unstable sched clock\"", "2867": "\"no_numa\"", "2868": "\"noautogroup\"", "2869": "\"node\"", "2870": "\"node_address\"", "2871": "\"node_name\"", "2872": "\"nodelayacct\"", "2873": "\"nodename   %s\\n\"", "2874": "\"noirqdebug\"", "2875": "\"nokgdbroundup\"", "2876": "\"non-boot cpus are not disabled\\n\"", "2877": "\"none\"", "2878": "\"none\\n\"", "2879": "\"noprefix\"", "2880": "\"normal\"", "2881": "\"nosect\"", "2882": "\"nosmp\"", "2883": "\"not tainted\"", "2884": "\"notes\"", "2885": "\"nothing printed\\n\"", "2886": "\"notify_on_release\"", "2887": "\"nr\"", "2888": "\"nr_hugepages\"", "2889": "\"nr_hugepages_mempolicy\"", "2890": "\"nr_involuntary_switches\"", "2891": "\"nr_irqs:%d nr_irqs:%d %d\\n\"", "2892": "\"nr_irqs:%d\\n\"", "2893": "\"nr_open\"", "2894": "\"nr_overcommit_hugepages\"", "2895": "\"nr_pdflush_threads\"", "2896": "\"nr_periods %d\\n\"", "2897": "\"nr_running\"", "2898": "\"nr_spread_over\"", "2899": "\"nr_throttled %d\\n\"", "2900": "\"nr_trim_pages\"", "2901": "\"nr_voluntary_switches\"", "2902": "\"ns_last_pid\"", "2903": "\"ntp_internal.h\"", "2904": "\"null\"", "2905": "\"numa\"", "2906": "\"numa_balancing\"", "2907": "\"numa_balancing_scan_delay_ms\"", "2908": "\"numa_balancing_scan_period_max_ms\"", "2909": "\"numa_balancing_scan_period_min_ms\"", "2910": "\"numa_balancing_scan_size_mb\"", "2911": "\"numa_faults_memory, %d, %d, %d, %d, %ld\\n\"", "2912": "\"numa_migrations, %ld\\n\"", "2913": "\"numa_zonelist_order\"", "2914": "\"number of jiffies between shuffles, 0=disable\"", "2915": "\"number of jiffies to run/halt test, 0=disable\"", "2916": "\"number of rcu fake writer threads\"", "2917": "\"number of rcu reader threads\"", "2918": "\"number of read-locking stress-test threads\"", "2919": "\"number of seconds between shuffles\"", "2920": "\"number of seconds between stats printk()s\"", "2921": "\"number of seconds to run/halt test\"", "2922": "\"number of write-locking stress-test threads\"", "2923": "\"o: %4d, e:%8d, s: 0x%08lx, p: %4d, n: %4d, b: %p, m:\"", "2924": "\"obsolescence_count_initialiser\"", "2925": "\"ocfs2\"", "2926": "\"of domain->span\\n\"", "2927": "\"off\\n\"", "2928": "\"offlinenocb\"", "2929": "\"offset:%u;\\tsize:%u;\\tsigned:%u;\\n\"", "2930": "\"offset:0;\\tsize:%u;\\tsigned:%u;\\n\"", "2931": "\"ofl\"", "2932": "\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"", "2933": "\"ok\"", "2934": "\"ok\\n\"", "2935": "\"old_pe\"", "2936": "\"old_pi\"", "2937": "\"old_pp\"", "2938": "\"on processor %d \"", "2939": "\"on the run queue locks. \"", "2940": "\"onlinenocb\"", "2941": "\"onlinenq\"", "2942": "\"onlineq\"", "2943": "\"only 'ip' field is supported for function trace\"", "2944": "\"only run producer\"", "2945": "\"only_unset_loginuid\"", "2946": "\"onoff_interval=%d onoff_holdoff=%d\\n\"", "2947": "\"oom_dump_tasks\"", "2948": "\"oom_kill_allocating_task\"", "2949": "\"oops\"", "2950": "\"oops: %s\\n\"", "2951": "\"op=\"", "2952": "\"op=%p %ps\\n\"", "2953": "\"op=%s\"", "2954": "\"op_none\"", "2955": "\"operand too long\"", "2956": "\"opid=%d oauid=%d ouid=%d oses=%d\"", "2957": "\"option changes via remount are deprecated (pid=%d comm=%s)\\n\"", "2958": "\"option or name mismatch, new: 0x%x \\\"%s\\\", old: 0x%x \\\"%s\\\"\\n\"", "2959": "\"optmem_max\"", "2960": "\"ordering guarantee broken for workqueue %s\\n\"", "2961": "\"orig_cpu\"", "2962": "\"osrelease\"", "2963": "\"ostype\"", "2964": "\"ouid=%u ogid=%u mode=%#ho\"", "2965": "\"out of memory for argv string\"", "2966": "\"out of memory in audit_alloc\"", "2967": "\"out of memory in audit_log_start\"", "2968": "\"out of memory\"", "2969": "\"out of memory, audit has lost a tree reference\\n\"", "2970": "\"out of memory\\n\"", "2971": "\"overcommit_kbytes\"", "2972": "\"overcommit_memory\"", "2973": "\"overcommit_ratio\"", "2974": "\"overflow, command ignored\\n%s\\n\"", "2975": "\"overflowgid\"", "2976": "\"overflowuid\"", "2977": "\"override_creds(%p{%d,%d})\"", "2978": "\"override_creds() = %p{%d,%d}\"", "2979": "\"p\"", "2980": "\"p0\"", "2981": "\"p:testprobe kprobe_trace_selftest_target \"", "2982": "\"page-cluster\"", "2983": "\"panic\"", "2984": "\"panic: %s\\n\"", "2985": "\"panic_mask\"", "2986": "\"panic_on_io_nmi\"", "2987": "\"panic_on_oom\"", "2988": "\"panic_on_oops\"", "2989": "\"panic_on_stackoverflow\"", "2990": "\"panic_on_unrecovered_nmi\"", "2991": "\"panic_on_warn set ...\\n\"", "2992": "\"panic_on_warn\"", "2993": "\"parameters\"", "2994": "\"parent\"", "2995": "\"parent_freezing\"", "2996": "\"parse error at argument[%d]. (%d)\\n\"", "2997": "\"passed\\n\"", "2998": "\"path=/sbin:/bin:/usr/sbin:/usr/bin\"", "2999": "\"path=/sbin:/usr/sbin:/bin:/usr/bin\"", "3000": "\"path_max_retrans\"", "3001": "\"paul e. mckenney <paulmck@us.ibm.com> and josh triplett <josh@joshtriplett.org>\"", "3002": "\"paul e. mckenney <paulmck@us.ibm.com>\"", "3003": "\"paul e. mckenney\"", "3004": "\"pc\"", "3005": "\"pci io\"", "3006": "\"pci mem\"", "3007": "\"pcidev %02x%02x %04x%04x %x\"", "3008": "\"per_cpu\"", "3009": "\"percpu irq %d still enabled on cpu%d!\\n\"", "3010": "\"percpu_pagelist_fraction\"", "3011": "\"perf buffer not large enough\"", "3012": "\"perf events running\\n\"", "3013": "\"perf interrupt took too long (%lld > %lld), lowering \"", "3014": "\"perf_cpu_time_max_percent\"", "3015": "\"perf_event_max_sample_rate\"", "3016": "\"perf_event_mlock_kb\"", "3017": "\"perf_event_paranoid\"", "3018": "\"performance\\n\"", "3019": "\"pid\"", "3020": "\"pid=%d uid=%u\"", "3021": "\"pid=%d\"", "3022": "\"pid_%d\"", "3023": "\"pid_max\"", "3024": "\"pid_max: default: %u minimum: %u\\n\"", "3025": "\"pipe-max-size\"", "3026": "\"platform\"", "3027": "\"please attach the output of /proc/lock_stat to the bug report\\n\"", "3028": "\"please check additional_cpus= boot parameter\\n\"", "3029": "\"please evaluate if this is the right api to use and \"", "3030": "\"please report this trace. ]\\n\\n\"", "3031": "\"please switch to the trace global clock:\\n\"", "3032": "\"please use \\\"cpu %d\\\" and then execute go\\n\"", "3033": "\"plug\"", "3034": "\"pm\"", "3035": "\"pm: %s %u kbytes in %u.%02u seconds (%u.%02u mb/s)\\n\"", "3036": "\"pm: %s took %d.%03d seconds\\n\"", "3037": "\"pm: basic memory bitmaps created\\n\"", "3038": "\"pm: basic memory bitmaps freed\\n\"", "3039": "\"pm: can't read %s time, err %d\\n\"", "3040": "\"pm: can't set %s wakealarm, err %d\\n\"", "3041": "\"pm: can't test '%s' suspend state\\n\"", "3042": "\"pm: cannot find swap device, try \"", "3043": "\"pm: cannot find swsusp signature!\\n\"", "3044": "\"pm: cannot get swap writer\\n\"", "3045": "\"pm: cannot start crc32 thread\\n\"", "3046": "\"pm: checking hibernation image partition %s\\n\"", "3047": "\"pm: compressing and saving image data (%u pages)...\\n\"", "3048": "\"pm: creating hibernation image:\\n\"", "3049": "\"pm: error %d creating hibernation image\\n\"", "3050": "\"pm: error %d resuming\\n\"", "3051": "\"pm: failed to allocate lzo data\\n\"", "3052": "\"pm: failed to allocate lzo page\\n\"", "3053": "\"pm: failed to load hibernation image, recovering.\\n\"", "3054": "\"pm: hibernation image created (%d pages copied)\\n\"", "3055": "\"pm: hibernation image not present or could not be loaded.\\n\"", "3056": "\"pm: hibernation image partition %d:%d present\\n\"", "3057": "\"pm: hibernation not available.\\n\"", "3058": "\"pm: image device not initialised\\n\"", "3059": "\"pm: image loading done.\\n\"", "3060": "\"pm: image loading progress: %3d%%\\n\"", "3061": "\"pm: image mismatch: %s\\n\"", "3062": "\"pm: image not found (code %d)\\n\"", "3063": "\"pm: image restored successfully.\\n\"", "3064": "\"pm: image saving done.\\n\"", "3065": "\"pm: image signature found, resuming\\n\"", "3066": "\"pm: image successfully loaded\\n\"", "3067": "\"pm: invalid image crc32!\\n\"", "3068": "\"pm: invalid lzo compressed length\\n\"", "3069": "\"pm: invalid lzo uncompressed length\\n\"", "3070": "\"pm: loading hibernation image.\\n\"", "3071": "\"pm: loading image data pages (%u pages)...\\n\"", "3072": "\"pm: looking for hibernation image.\\n\"", "3073": "\"pm: memory allocation failed\\n\"", "3074": "\"pm: need to copy %u pages\\n\"", "3075": "\"pm: no wakealarm-capable rtc driver is ready\\n\"", "3076": "\"pm: normal pages needed: %u + %u, available pages: %u\\n\"", "3077": "\"pm: not enough free memory\\n\"", "3078": "\"pm: not enough free swap\\n\"", "3079": "\"pm: please power down manually\\n\"", "3080": "\"pm: preparing processes for restore.\\n\"", "3081": "\"pm: registered nosave memory: [mem %#010llx-%#010llx]\\n\"", "3082": "\"pm: s\"", "3083": "\"pm: saving image data pages (%u pages)...\\n\"", "3084": "\"pm: some devices failed to power down, \"", "3085": "\"pm: some system devices failed to power down, \"", "3086": "\"pm: suspend test failed, error %d\\n\"", "3087": "\"pm: swap header not found!\\n\"", "3088": "\"pm: swap will be unusable! \"", "3089": "\"pm: syncing filesystems ... \"", "3090": "\"pm: test rtc wakeup from '%s' suspend\\n\"", "3091": "\"pm: using %u thread(s) for compression.\\n\"", "3092": "\"pm: writing image.\\n\"", "3093": "\"pm_qos\"", "3094": "\"pm_qos_add_request() called for already added request\\n\"", "3095": "\"pm_qos_remove_request() called for unknown object\\n\"", "3096": "\"pm_qos_update_request() called for unknown object\\n\"", "3097": "\"poll\"", "3098": "\"pool %d:\"", "3099": "\"poolsize\"", "3100": "\"portbase\"", "3101": "\"portshift\"", "3102": "\"posix clock id %d lacks clock_get()\\n\"", "3103": "\"posix clock id %d lacks clock_getres()\\n\"", "3104": "\"posix clock register failed for clock_id %d\\n\"", "3105": "\"posix timers running\\n\"", "3106": "\"posix_timers_cache\"", "3107": "\"possible reason: unannotated irqs-off.\\n\"", "3108": "\"possible reason: unannotated irqs-on.\\n\"", "3109": "\"potentially unexpected fatal signal %d.\\n\"", "3110": "\"power down\\n\"", "3111": "\"power off\"", "3112": "\"power.h\"", "3113": "\"poweroff(o)\"", "3114": "\"poweroff_cmd\"", "3115": "\"poweroff_powercycle\"", "3116": "\"powersave-nap\"", "3117": "\"ppp\"", "3118": "\"preempt_rcu\"", "3119": "\"preemptible hierarchical rcu implementation.\\n\"", "3120": "\"preemption disabled at:\"", "3121": "\"preemptirqsoff\"", "3122": "\"preemptoff\"", "3123": "\"prepare_kernel_cred() alloc %p\"", "3124": "\"press stop-a (l1-a) to return to the boot prom\\n\"", "3125": "\"prestartedroot\"", "3126": "\"prestartleaf\"", "3127": "\"primary handler called for nested irq %d\\n\"", "3128": "\"print-fatal-signals\"", "3129": "\"print-fatal-signals=\"", "3130": "\"printed\\n\"", "3131": "\"printk limit exceeded\"", "3132": "\"printk\"", "3133": "\"printk_delay\"", "3134": "\"printk_ratelimit\"", "3135": "\"printk_ratelimit_burst\"", "3136": "\"priority\"", "3137": "\"probe definition must be started with 'p', 'r' or '-'.\\n\"", "3138": "\"probe definition must be started with 'p', 'r' or\"", "3139": "\"probing address(0x%p) is not an \"", "3140": "\"problem loading in-kernel x.509 certificate (%ld)\\n\"", "3141": "\"problem parsing in-kernel x.509 certificate list\\n\"", "3142": "\"process %d (%s) no longer affine to cpu%d\\n\"", "3143": "\"process accounting paused\\n\"", "3144": "\"process accounting resumed\\n\"", "3145": "\"process is not running, sending a signal from \"", "3146": "\"process table (0x%p)\\n\"", "3147": "\"process%s\"", "3148": "\"processors\"", "3149": "\"proctitle=\"", "3150": "\"profile buffer not large enough\"", "3151": "\"profile\"", "3152": "\"promote_secondaries\"", "3153": "\"prompt\"", "3154": "\"protected_hardlinks\"", "3155": "\"protected_symlinks\"", "3156": "\"protocol\"", "3157": "\"prove_locking\"", "3158": "\"proxy_arp\"", "3159": "\"proxy_ndp\"", "3160": "\"proxy_qlen\"", "3161": "\"prsctp_enable\"", "3162": "\"ps\"", "3163": "\"pty\"", "3164": "\"put_cred_rcu(%p)\"", "3165": "\"q\"", "3166": "\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\"", "3167": "\"qc\"", "3168": "\"qrcmd,\"", "3169": "\"qsp=%ld rpq=%ld cbr=%ld cng=%ld \"", "3170": "\"queue\"", "3171": "\"quota\"", "3172": "\"quote it:\\n\"", "3173": "\"r %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\"", "3174": "\"r\"", "3175": "\"r%d !read_ok\\n\"", "3176": "\"r%d is invalid\\n\"", "3177": "\"r%d type=%s expected=%s\\n\"", "3178": "\"r:testprobe2 kprobe_trace_selftest_target \"", "3179": "\"raid\"", "3180": "\"random\"", "3181": "\"randomize_va_space\"", "3182": "\"randy dunlap\"", "3183": "\"rate limit exceeded\"", "3184": "\"ratelimit\"", "3185": "\"rbhammer\"", "3186": "\"rbtester/%d\"", "3187": "\"rcu test callback executed %d\\n\"", "3188": "\"rcu used illegally from extended quiescent state!\\n\"", "3189": "\"rcu used illegally from idle cpu!\\n\"", "3190": "\"rcu used illegally from offline cpu!\\n\"", "3191": "\"rcu\"", "3192": "\"rcu-torture types:\"", "3193": "\"rcu-torture: ->fqs null and non-zero fqs_duration, fqs disabled.\\n\"", "3194": "\"rcu-torture: invalid torture type: \\\"%s\\\"\\n\"", "3195": "\"rcu.h\"", "3196": "\"rcu: adjusting geometry for rcu_fanout_leaf=%d, nr_cpu_ids=%d\\n\"", "3197": "\"rcu: never-onlined no-cbs cpu %d has cb %p\\n\"", "3198": "\"rcu_bh\"", "3199": "\"rcu_busted\"", "3200": "\"rcu_callback\"", "3201": "\"rcu_cleanup_dead_cpu: callbacks on offline cpu %d: qlen=%lu, nxtlist=%p\\n\"", "3202": "\"rcu_head\"", "3203": "\"rcu_init_one: rcu_num_lvls overflow\"", "3204": "\"rcu_nocb_mask allocation failed, callback offloading disabled.\\n\"", "3205": "\"rcu_nocb_poll\"", "3206": "\"rcu_nocbs=\"", "3207": "\"rcu_node_0\"", "3208": "\"rcu_node_1\"", "3209": "\"rcu_node_2\"", "3210": "\"rcu_node_3\"", "3211": "\"rcu_node_fqs_0\"", "3212": "\"rcu_node_fqs_1\"", "3213": "\"rcu_node_fqs_2\"", "3214": "\"rcu_node_fqs_3\"", "3215": "\"rcu_pending\"", "3216": "\"rcu_preempt\"", "3217": "\"rcu_read_lock\"", "3218": "\"rcu_read_lock_bh\"", "3219": "\"rcu_read_lock_sched\"", "3220": "\"rcu_read_unlock() from irq or softirq with blocking in critical section!!!\\n\"", "3221": "\"rcu_sched\"", "3222": "\"rcu_spawn_gp_kthread(): limited prio to %d from %d\\n\"", "3223": "\"rcu_tasks_kthread\"", "3224": "\"rcu_torture_barrier task starting\"", "3225": "\"rcu_torture_barrier\"", "3226": "\"rcu_torture_barrier_cbs\"", "3227": "\"rcu_torture_boost boosting failed\"", "3228": "\"rcu_torture_boost started\"", "3229": "\"rcu_torture_boost task create failed\"", "3230": "\"rcu_torture_boost\"", "3231": "\"rcu_torture_cbflood disabled: bad args or oom\"", "3232": "\"rcu_torture_cbflood task started\"", "3233": "\"rcu_torture_cbflood\"", "3234": "\"rcu_torture_fakewriter\"", "3235": "\"rcu_torture_fqs task started\"", "3236": "\"rcu_torture_fqs\"", "3237": "\"rcu_torture_reader task started\"", "3238": "\"rcu_torture_reader\"", "3239": "\"rcu_torture_stall begin holdoff\"", "3240": "\"rcu_torture_stall end holdoff\"", "3241": "\"rcu_torture_stall end.\\n\"", "3242": "\"rcu_torture_stall start.\\n\"", "3243": "\"rcu_torture_stall task started\"", "3244": "\"rcu_torture_stall\"", "3245": "\"rcu_torture_stats task started\"", "3246": "\"rcu_torture_stats\"", "3247": "\"rcu_torture_writer task started\"", "3248": "\"rcu_torture_writer\"", "3249": "\"rcu_torture_writer: gp_cond without primitives.\\n\"", "3250": "\"rcu_torture_writer: gp_exp without primitives.\\n\"", "3251": "\"rcu_torture_writer: gp_normal without primitives.\\n\"", "3252": "\"rcu_torture_writer: gp_sync without primitives.\\n\"", "3253": "\"rcu_torture_writer: no update-side primitives.\\n\"", "3254": "\"rcub/%d\"", "3255": "\"rcubarrier\"", "3256": "\"rcuboost\"", "3257": "\"rcuc/%u\"", "3258": "\"rcudata\"", "3259": "\"rcuexp\"", "3260": "\"rcugp\"", "3261": "\"rcuhier\"", "3262": "\"rcuo%c/%d\"", "3263": "\"rcupdate\"", "3264": "\"rcupdate.\"", "3265": "\"rcutorture test sequence: %lu %s\\n\"", "3266": "\"rcutorture update version number: %lu\\n\"", "3267": "\"rcutorture\"", "3268": "\"rcutorture: !config_debug_objects_rcu_head, not testing duplicate call_rcu()\\n\"", "3269": "\"rcutorture: duplicated callback was invoked.\\n\"", "3270": "\"rcutorture: warn: duplicate call_rcu() test complete.\\n\"", "3271": "\"rcutorture: warn: duplicate call_rcu() test starting.\\n\"", "3272": "\"rcutree\"", "3273": "\"rcutree.\"", "3274": "\"rcvbuf_policy\"", "3275": "\"rd\"", "3276": "\"re-enter error: breakpoint removed %lx\\n\"", "3277": "\"re-enter exception: all breakpoints killed\\n\"", "3278": "\"read\"", "3279": "\"read, diag=%d\\n\"", "3280": "\"read-copy update tracing for hierarchical implementation\"", "3281": "\"read_wakeup_threshold\"", "3282": "\"reader pipe: \"", "3283": "\"reader_tasks: out of memory\"", "3284": "\"reads \"", "3285": "\"reads\"", "3286": "\"real-root-dev\"", "3287": "\"reboot the machine immediately\"", "3288": "\"reboot\"", "3289": "\"reboot-cmd\"", "3290": "\"reboot: \"", "3291": "\"rebooting in %d seconds..\"", "3292": "\"recursion\"", "3293": "\"recursive entry to debugger\"", "3294": "\"redirect_load\"", "3295": "\"redirect_number\"", "3296": "\"redirect_silence\"", "3297": "\"regen_max_retry\"", "3298": "\"registered i/o driver %s\\n\"", "3299": "\"registered taskstats version %d\\n\"", "3300": "\"regs->ip = 0x%lx\\n\"", "3301": "\"reissue the kill command if you want to risk \"", "3302": "\"rej\"", "3303": "\"relax_domain_level=\"", "3304": "\"relaxed\"", "3305": "\"releasable\"", "3306": "\"release    %s\\n\"", "3307": "\"release child resource %pr\\n\"", "3308": "\"release_agent\"", "3309": "\"release_agent=\"", "3310": "\"release_agent=/sbin/cpuset_release_agent\"", "3311": "\"relocation failed for symbol '%s' at 0x%016lx (%d)\\n\"", "3312": "\"remap\"", "3313": "\"remount is not allowed\\n\"", "3314": "\"remove_rule\"", "3315": "\"removed domain %s\\n\"", "3316": "\"request for unknown module key '%s' err %ld\\n\"", "3317": "\"requeue\"", "3318": "\"reqwait\"", "3319": "\"reqwaitsig\"", "3320": "\"reserve=\"", "3321": "\"reserved\"", "3322": "\"reset\"", "3323": "\"reset_request_timeout\"", "3324": "\"resource collision: %pr conflicts with %s %pr\\n\"", "3325": "\"resource sanity check: requesting [mem %#010llx-%#010llx], which spans more than %s %pr\\n\"", "3326": "\"restart_request_timeout\"", "3327": "\"restarting kernel threads ... \"", "3328": "\"restarting system with command '%s'\\n\"", "3329": "\"restarting system\\n\"", "3330": "\"restarting tasks ... \"", "3331": "\"resumewait\"", "3332": "\"retrans_time_ms\"", "3333": "\"retval\"", "3334": "\"revert_creds(%p{%d,%d})\"", "3335": "\"reverting patch '%s' on unloading module '%s'\\n\"", "3336": "\"rif_timeout\"", "3337": "\"ring buffer passed!\\n\"", "3338": "\"ring_buffer_benchmark\"", "3339": "\"rm\"", "3340": "\"rmem_default\"", "3341": "\"rmem_max\"", "3342": "\"root %d group %s\\n\"", "3343": "\"rose\"", "3344": "\"rotorstep\"", "3345": "\"route\"", "3346": "\"router_probe_interval\"", "3347": "\"router_solicitation_delay\"", "3348": "\"router_solicitation_interval\"", "3349": "\"router_solicitations\"", "3350": "\"routing_control\"", "3351": "\"rp_filter\"", "3352": "\"rt-test-%d\"", "3353": "\"rt_period_us\"", "3354": "\"rt_runtime_us\"", "3355": "\"rtbf: %ld rtb: %ld nt: %ld \"", "3356": "\"rtc: %p ver: %lu tfle: %d rta: %d rtaf: %d rtf: %d \"", "3357": "\"rtmbe: %d rtbke: %ld rtbre: %ld \"", "3358": "\"rtmutex-debug.h\"", "3359": "\"rtmutex.h\"", "3360": "\"rtmutex_common.h\"", "3361": "\"rto_alpha_exp_divisor\"", "3362": "\"rto_beta_exp_divisor\"", "3363": "\"rto_initial\"", "3364": "\"rto_max\"", "3365": "\"rto_min\"", "3366": "\"rttest\"", "3367": "\"runnable_load_avg\"", "3368": "\"running rcu self tests\\n\"", "3369": "\"running ring buffer tests...\\n\"", "3370": "\"running tests on all trace events:\\n\"", "3371": "\"running tests on trace event systems:\\n\"", "3372": "\"running tests on trace events:\\n\"", "3373": "\"rw what?\\n\"", "3374": "\"rw_lock\"", "3375": "\"rw_lock_irq\"", "3376": "\"rwsem.h\"", "3377": "\"rwsem_lock\"", "3378": "\"s\"", "3379": "\"s1suspend\"", "3380": "\"s390dbf\"", "3381": "\"s=%lu d=%lu w=%lu tf=%lu wd1=%lu wd2=%lu n=%lu sc=%lu dt=%lu dl=%lu dx=%lu\\n\"", "3382": "\"s>\"", "3383": "\"s>=\"", "3384": "\"s>>=\"", "3385": "\"sack_timeout\"", "3386": "\"saddr=\"", "3387": "\"same insn cannot be used with different pointers\\n\"", "3388": "\"sane_behavior: no other mount options allowed\\n\"", "3389": "\"sane_behavior: this is still under development and its behaviors will change, proceed at your own risk\\n\"", "3390": "\"save_stack_trace_regs() not implemented yet.\\n\"", "3391": "\"save_stack_trace_tsk() not implemented yet.\\n\"", "3392": "\"saved backtrace test skipped.\\n\"", "3393": "\"sched debug version: v0.11, %s %.*s\\n\"", "3394": "\"sched rcu must be held\"", "3395": "\"sched rcu or wq->mutex should be held\"", "3396": "\"sched rcu or wq_pool_mutex should be held\"", "3397": "\"sched trace: couldn't activate tracepoint\"", "3398": "\"sched\"", "3399": "\"sched.h\"", "3400": "\"sched: rt throttling activated\\n\"", "3401": "\"sched_autogroup_enabled\"", "3402": "\"sched_cfs_bandwidth_slice_us\"", "3403": "\"sched_child_runs_first\"", "3404": "\"sched_create_group()\"", "3405": "\"sched_debug\"", "3406": "\"sched_domain\"", "3407": "\"sched_features\"", "3408": "\"sched_latency_ns\"", "3409": "\"sched_load_balance\"", "3410": "\"sched_migration_cost_ns\"", "3411": "\"sched_min_granularity_ns\"", "3412": "\"sched_nr_migrate\"", "3413": "\"sched_relax_domain_level\"", "3414": "\"sched_rr_timeslice_ms\"", "3415": "\"sched_rt_period_us\"", "3416": "\"sched_rt_runtime_us\"", "3417": "\"sched_shares_window_ns\"", "3418": "\"sched_time_avg_ms\"", "3419": "\"sched_tunable_scaling\"", "3420": "\"sched_wakeup_granularity_ns\"", "3421": "\"scons-poweroff\"", "3422": "\"scsi\"", "3423": "\"sctp\"", "3424": "\"search string too long\\n\"", "3425": "\"sections\"", "3426": "\"secure_redirects\"", "3427": "\"self_freezing\"", "3428": "\"sem\"", "3429": "\"send a signal to a process\"", "3430": "\"send_redirects\"", "3431": "\"serial_cpumask\"", "3432": "\"set environment variables\"", "3433": "\"set\"", "3434": "\"set/display breakpoints\"", "3435": "\"set_event\"", "3436": "\"set_ftrace_pid\"", "3437": "\"setting dangerous option %s - tainting kernel\\n\"", "3438": "\"setting gcov_persist to %d\\n\"", "3439": "\"setting trigger mode %lu for irq %u failed (%pf)\\n\"", "3440": "\"settings.h\"", "3441": "\"sg-big-buff\"", "3442": "\"sha256_digest\"", "3443": "\"sha_regions\"", "3444": "\"shadowcpu%d\"", "3445": "\"share_creds(%p{%d,%d})\"", "3446": "\"shared_media\"", "3447": "\"shares\"", "3448": "\"shmall\"", "3449": "\"shmmax\"", "3450": "\"shmmni\"", "3451": "\"show environment variables\"", "3452": "\"showing busy workqueues and worker pools:\\n\"", "3453": "\"shuffle_interval=%d stutter=%d irqreader=%d \"", "3454": "\"shutdown time (j), <= zero to disable.\"", "3455": "\"shutdown time (s), <= zero to disable.\"", "3456": "\"shutdown\"", "3457": "\"shutting down hard lockup detector on all cpus\\n\"", "3458": "\"sigev_thread_id must not share bit with other sigev values!\"", "3459": "\"sighand_cache\"", "3460": "\"signal %d is sent to process %d.\\n\"", "3461": "\"signal_cache\"", "3462": "\"single step\"", "3463": "\"skew_tick\"", "3464": "\"sleep delta value!\\n\"", "3465": "\"sleep\"", "3466": "\"sleeprq\"", "3467": "\"slot_timeout\"", "3468": "\"smp: fork_idle() failed for cpu %u\\n\"", "3469": "\"smp_affinity\"", "3470": "\"smp_affinity_list\"", "3471": "\"smpboot.h\"", "3472": "\"snapshot\"", "3473": "\"sndbuf_policy\"", "3474": "\"soft-power\"", "3475": "\"soft_watchdog\"", "3476": "\"softirqs last  enabled at (%u): \"", "3477": "\"softirqs last disabled at (%u): \"", "3478": "\"softlockup: hung tasks\"", "3479": "\"softlockup_all_cpu_backtrace\"", "3480": "\"softlockup_panic\"", "3481": "\"software breakpoints are unavailable.\\n\"", "3482": "\"somaxconn\"", "3483": "\"sorting __ex_table...\\n\"", "3484": "\"span %*pbl level %s\\n\"", "3485": "\"speed_limit_max\"", "3486": "\"speed_limit_min\"", "3487": "\"spin\"", "3488": "\"spin_lock\"", "3489": "\"spin_lock_irq\"", "3490": "\"spin_retry\"", "3491": "\"split\"", "3492": "\"spread\"", "3493": "\"spread0\"", "3494": "\"spurious\"", "3495": "\"sr\"", "3496": "\"srcu\"", "3497": "\"srwoy\"", "3498": "\"ss trap\"", "3499": "\"ss\"", "3500": "\"st\"", "3501": "\"stack traceback for pid %d\\n\"", "3502": "\"stack traceback\"", "3503": "\"stack\"", "3504": "\"stack-protector: kernel stack is corrupted in: %p\\n\"", "3505": "\"stack_max_size\"", "3506": "\"stack_trace\"", "3507": "\"stack_trace_filter\"", "3508": "\"stack_tracer_enabled\"", "3509": "\"stacktrace\"", "3510": "\"staging\"", "3511": "\"stall duration (s), zero to disable.\"", "3512": "\"stall_cpu=%d stall_cpu_holdoff=%d \"", "3513": "\"standard_window_size\"", "3514": "\"start boost kthread@init\"", "3515": "\"start boost kthread@rcu_wait\"", "3516": "\"start boost kthread@rcu_yield\"", "3517": "\"start context switch\"", "3518": "\"start locktorture at module init\"", "3519": "\"start rcu core\"", "3520": "\"start rcutorture at boot\"", "3521": "\"start scheduler-tick\"", "3522": "\"start\"", "3523": "\"startedleaf\"", "3524": "\"startedleafroot\"", "3525": "\"startedroot\"", "3526": "\"starting new kernel\\n\"", "3527": "\"starting tracer '%s'\\n\"", "3528": "\"startleaf\"", "3529": "\"startwait\"", "3530": "\"stat\"", "3531": "\"stat_interval\"", "3532": "\"stat_interval=%d verbose=%d test_no_idle_hz=%d \"", "3533": "\"state\"", "3534": "\"state=%lx set at [<%p>] %ps\\n\"", "3535": "\"station\"", "3536": "\"stats.h\"", "3537": "\"stats_clear\"", "3538": "\"steven rostedt\"", "3539": "\"stop-a\"", "3540": "\"stopping %s\"", "3541": "\"stopping torture_shuffle task\"", "3542": "\"stopping torture_shutdown task\"", "3543": "\"stopping torture_stutter task\"", "3544": "\"strict\"", "3545": "\"string\"", "3546": "\"string_size\"", "3547": "\"stx\"", "3548": "\"suid_dumpable\"", "3549": "\"suid_dumpable=2. pipe handler or fully qualified \"", "3550": "\"sum\"", "3551": "\"summarize the system\"", "3552": "\"summary\"", "3553": "\"sunrpc\"", "3554": "\"suspend\"", "3555": "\"swap-space\"", "3556": "\"swapon -a.\\n\"", "3557": "\"swapper tasks\\n\"", "3558": "\"swappiness\"", "3559": "\"swapspace2\"", "3560": "\"switch to another task\"", "3561": "\"switch to new cpu\"", "3562": "\"symbol %s is being used by a non-gpl module, \"", "3563": "\"symbol %s is in a bss section. cannot %s\\n\"", "3564": "\"symbol %s is marked as unused, however this module is \"", "3565": "\"symbol %s size mismatch: expected %lu actual %u\\n\"", "3566": "\"symbol '%s' not found at specified address 0x%016lx, kernel mismatch?\\n\"", "3567": "\"symbol '%s' not found in symbol table\\n\"", "3568": "\"symbol: %s has bad section index %d.\\n\"", "3569": "\"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\"", "3570": "\"symtab->sym_start=0x%lx\\n\"", "3571": "\"sync\"", "3572": "\"synchronize_rcu_tasks called too soon\"", "3573": "\"syncing filesystems ... \"", "3574": "\"syncs\"", "3575": "\"sys_ni_syscall\"", "3576": "\"syscall %s metadata not mapped, disabling ftrace event\\n\"", "3577": "\"syscall entry trace point\"", "3578": "\"syscall exit trace point\"", "3579": "\"syscalls\"", "3580": "\"sysctl_sched\\n\"", "3581": "\"sysctl_sched_tunable_scaling\"", "3582": "\"sysctl_writes_strict\"", "3583": "\"sysname    %s\\n\"", "3584": "\"sysrq\"", "3585": "\"system call with \"", "3586": "\"system halted\\n\"", "3587": "\"system ram\"", "3588": "\"system type\"", "3589": "\"system\"", "3590": "\"t.\"", "3591": "\"t1_timeout\"", "3592": "\"t2\"", "3593": "\"t2_timeout\"", "3594": "\"t3\"", "3595": "\"t3_timeout\"", "3596": "\"table\\n\"", "3597": "\"tag\"", "3598": "\"tainted\"", "3599": "\"tainted: \"", "3600": "\"tainting kernel with taint_livepatch\\n\"", "3601": "\"target module is loaded. continue.\\n\"", "3602": "\"task %s (pid=%d) is on cpu %d (state=%ld, flags=%x)\\n\"", "3603": "\"task addr\"", "3604": "\"task dump for cpu %d:\\n\"", "3605": "\"task_struct\"", "3606": "\"taskcount\"", "3607": "\"tasklet\"", "3608": "\"tasks\"", "3609": "\"tcp_abort_on_overflow\"", "3610": "\"tcp_adv_win_scale\"", "3611": "\"tcp_allowed_congestion_control\"", "3612": "\"tcp_app_win\"", "3613": "\"tcp_base_mss\"", "3614": "\"tcp_congestion_control\"", "3615": "\"tcp_dsack\"", "3616": "\"tcp_ecn\"", "3617": "\"tcp_fack\"", "3618": "\"tcp_fin_timeout\"", "3619": "\"tcp_frto\"", "3620": "\"tcp_frto_response\"", "3621": "\"tcp_keepalive_intvl\"", "3622": "\"tcp_keepalive_probes\"", "3623": "\"tcp_keepalive_time\"", "3624": "\"tcp_low_latency\"", "3625": "\"tcp_max_orphans\"", "3626": "\"tcp_max_ssthresh\"", "3627": "\"tcp_max_syn_backlog\"", "3628": "\"tcp_max_tw_buckets\"", "3629": "\"tcp_mem\"", "3630": "\"tcp_moderate_rcvbuf\"", "3631": "\"tcp_mtu_probing\"", "3632": "\"tcp_no_metrics_save\"", "3633": "\"tcp_orphan_retries\"", "3634": "\"tcp_reordering\"", "3635": "\"tcp_retrans_collapse\"", "3636": "\"tcp_retries1\"", "3637": "\"tcp_retries2\"", "3638": "\"tcp_rfc1337\"", "3639": "\"tcp_rmem\"", "3640": "\"tcp_sack\"", "3641": "\"tcp_slot_table_entries\"", "3642": "\"tcp_slow_start_after_idle\"", "3643": "\"tcp_stdurg\"", "3644": "\"tcp_syn_retries\"", "3645": "\"tcp_synack_retries\"", "3646": "\"tcp_syncookies\"", "3647": "\"tcp_timestamps\"", "3648": "\"tcp_tso_win_divisor\"", "3649": "\"tcp_tw_recycle\"", "3650": "\"tcp_tw_reuse\"", "3651": "\"tcp_window_scaling\"", "3652": "\"tcp_wmem\"", "3653": "\"tcp_workaround_signed_windows\"", "3654": "\"temp_prefered_lft\"", "3655": "\"temp_valid_lft\"", "3656": "\"term=linux\"", "3657": "\"test rcu prio boost: 0=no, 1=maybe, 2=yes.\"", "3658": "\"test support for tickless idle cpus\"", "3659": "\"test-events\"", "3660": "\"test_boost=%d/%d test_boost_interval=%d \"", "3661": "\"test_boost_duration=%d shutdown_secs=%d \"", "3662": "\"test_suspend\"", "3663": "\"testing a backtrace from irq context.\\n\"", "3664": "\"testing a backtrace from process context.\\n\"", "3665": "\"testing a saved backtrace.\\n\"", "3666": "\"testing all events: \"", "3667": "\"testing dynamic ftrace ops #%d: \"", "3668": "\"testing dynamic ftrace: \"", "3669": "\"testing event %s: \"", "3670": "\"testing event system %s: \"", "3671": "\"testing ftrace filter: \"", "3672": "\"testing ftrace recursion safe: \"", "3673": "\"testing ftrace recursion: \"", "3674": "\"testing ftrace regs%s: \"", "3675": "\"testing kprobe tracing: \"", "3676": "\"testing tracer %s: \"", "3677": "\"testprobe\"", "3678": "\"testprobe2\"", "3679": "\"tg->cfs_bandwidth.timer_active\"", "3680": "\"tg->runnable_avg\"", "3681": "\"tg_load_avg\"", "3682": "\"tg_load_contrib\"", "3683": "\"tg_runnable_contrib\"", "3684": "\"thaw_processes\"", "3685": "\"thawed\"", "3686": "\"the code is fine but needs lockdep annotation.\\n\"", "3687": "\"the deadlock.\\n\"", "3688": "\"the following trace is a kernel self test and not a bug!\\n\"", "3689": "\"the sigmask lock is held somewhere else in \"", "3690": "\"the signal has _not_ been sent.\\n\"", "3691": "\"this may impact system performance.\\n\"", "3692": "\"this may significantly impact system \"", "3693": "\"this probe might be able to register after\"", "3694": "\"this symbol will go away in the future.\\n\"", "3695": "\"thread overran stack, or stack corrupted\\n\"", "3696": "\"thread\"", "3697": "\"thread:\"", "3698": "\"thread_info\"", "3699": "\"threaded irq requested with handler=null and !oneshot for irq %d\\n\"", "3700": "\"threadextrainfo,\"", "3701": "\"threadirqs\"", "3702": "\"threads-max\"", "3703": "\"throttle_count\"", "3704": "\"throttled\"", "3705": "\"throttled_time %llu\\n\"", "3706": "\"tick device: mode:     %d\\n\"", "3707": "\"tick-internal.h\"", "3708": "\"tick-sched.h\"", "3709": "\"ticks this gp\"", "3710": "\"time after boot before cpu hotplugs (s)\"", "3711": "\"time between cpu hotplugs (s), 0=disable\"", "3712": "\"time to wait before starting stall (s).\"", "3713": "\"time_wait\"", "3714": "\"timeconst.h\"", "3715": "\"timed out waiting for secondary cpus.\\n\"", "3716": "\"timekeeping.h\"", "3717": "\"timekeeping_internal.h\"", "3718": "\"timeout\"", "3719": "\"timer\"", "3720": "\"timer: %pf preempt leak: %08x -> %08x\\n\"", "3721": "\"timer_list\"", "3722": "\"timer_migration\"", "3723": "\"timestamp %lu\\n\"", "3724": "\"tiny_plugin.h\"", "3725": "\"to continue\\n\"", "3726": "\"token-ring\"", "3727": "\"too many operands\"", "3728": "\"too many terms in predicate expression\"", "3729": "\"torture thread %s parking due to system shutdown\\n\"", "3730": "\"torture_init_begin: refusing %s init: %s running\"", "3731": "\"torture_onoff begin holdoff\"", "3732": "\"torture_onoff end holdoff\"", "3733": "\"torture_onoff task started\"", "3734": "\"torture_onoff task: offline %d failed: errno %d\\n\"", "3735": "\"torture_onoff task: offlined %d\\n\"", "3736": "\"torture_onoff task: offlining %d\\n\"", "3737": "\"torture_shuffle task started\"", "3738": "\"torture_shuffle\"", "3739": "\"torture_shutdown task shutting down system\"", "3740": "\"torture_shutdown task started\"", "3741": "\"torture_shutdown task: %lu jiffies remaining\\n\"", "3742": "\"torture_shutdown\"", "3743": "\"torture_stutter task started\"", "3744": "\"torture_stutter\"", "3745": "\"tp_printk\"", "3746": "\"trace\"", "3747": "\"trace.h\"", "3748": "\"trace_benchmark.h\"", "3749": "\"trace_buf_size=\"", "3750": "\"trace_clock=\"", "3751": "\"trace_entries.h\"", "3752": "\"trace_event=\"", "3753": "\"trace_events_filter_test.h\"", "3754": "\"trace_options=\"", "3755": "\"trace_output.h\"", "3756": "\"trace_probe.h\"", "3757": "\"trace_stat\"", "3758": "\"trace_stat.h\"", "3759": "\"trace_system\"", "3760": "\"traceoff\"", "3761": "\"traceoff_on_warning\"", "3762": "\"traceon\"", "3763": "\"tracepoint_printk\"", "3764": "\"tracer %s already registered\\n\"", "3765": "\"tracer has a name longer than %d\\n\"", "3766": "\"tracer must have a name\\n\"", "3767": "\"tracing: failed to allocate common fields\"", "3768": "\"transport_acknowledge_delay\"", "3769": "\"transport_busy_delay\"", "3770": "\"transport_maximum_tries\"", "3771": "\"transport_no_activity_timeout\"", "3772": "\"transport_requested_window_size\"", "3773": "\"transport_timeout\"", "3774": "\"tree.h\"", "3775": "\"trigger\"", "3776": "\"try swapon -a.\\n\"", "3777": "\"trying to free already-free irq %d\\n\"", "3778": "\"trying to free dma%d\\n\"", "3779": "\"trying to free free dma%d\\n\"", "3780": "\"trying to free irq %d from irq context!\\n\"", "3781": "\"trying to free nonexistent resource \"", "3782": "\"trylock failure on up\"", "3783": "\"tsb-ratio\"", "3784": "\"turning off the locking correctness validator.\\n\"", "3785": "\"type go a second time if you really want \"", "3786": "\"type of lock to torture (spin_lock, spin_lock_irq, mutex_lock, ...)\"", "3787": "\"type of rcu to torture (rcu, rcu_bh, ...)\"", "3788": "\"type: %d\\n\"", "3789": "\"type=%d %s\\n\"", "3790": "\"type=%s, value=%d, requests: active=%d / total=%d\\n\"", "3791": "\"tz_minuteswest %d\\n\"", "3792": "\"u\"", "3793": "\"u16\"", "3794": "\"u32\"", "3795": "\"u64\"", "3796": "\"u8\"", "3797": "\"ucast_solicit\"", "3798": "\"udelay() test (lpj=%ld kt=%ld.%09ld)\\n\"", "3799": "\"udelay_test\"", "3800": "\"udp_slot_table_entries\"", "3801": "\"uid_cache\"", "3802": "\"unable to set relax_domain_level\\n\"", "3803": "\"unaligned-dump-stack\"", "3804": "\"unaligned-trap\"", "3805": "\"unbalanced enable for irq %d\\n\"", "3806": "\"unbalanced irq %d wake disable\\n\"", "3807": "\"unbalanced parens\"", "3808": "\"unexpected event refcount: %ld; ptr=%p\\n\"", "3809": "\"unhandled %u\\n\"", "3810": "\"unix\"", "3811": "\"unknown %u.%06lu %d 0x%llx %02lx,%02lx,\"", "3812": "\"unknown action %x\\n\"", "3813": "\"unknown argument '%s'\\n\"", "3814": "\"unknown func %d\\n\"", "3815": "\"unknown insn class %d\\n\"", "3816": "\"unknown opcode %02x\\n\"", "3817": "\"unknown return type %d of func %d\\n\"", "3818": "\"unknown\"", "3819": "\"unknown_nmi_panic\"", "3820": "\"unloading\"", "3821": "\"unmap %u.%06lu %d 0x%lx %d\\n\"", "3822": "\"unplug_io\"", "3823": "\"unplug_timer\"", "3824": "\"unrecognized bpf_ld_imm64 insn\\n\"", "3825": "\"unregistered i/o driver %s, debugger disabled\\n\"", "3826": "\"unres_qlen\"", "3827": "\"unresolvable ambiguity (%lu matches) on symbol '%s' in object '%s'\\n\"", "3828": "\"unsafe core_pattern used with \"", "3829": "\"unscheduled system shutdown detected\"", "3830": "\"unspecified\"", "3831": "\"unstable sched clock\\n\"", "3832": "\"unsupported arg_type %d\\n\"", "3833": "\"unsupported type: %s\\n\"", "3834": "\"updated_rules\"", "3835": "\"uprobe: %s:%d failed to %s\\n\"", "3836": "\"uprobe: omit uretprobe due to\"", "3837": "\"uprobe: unable to handle uretprobe pid/tgid=%d/%d\\n\"", "3838": "\"uprobe: unable to set uretprobe pid/tgid=%d/%d\\n\"", "3839": "\"uprobe_events\"", "3840": "\"uprobe_profile\"", "3841": "\"uprobes\"", "3842": "\"uptime     \"", "3843": "\"usage of  cmd args | grep pattern:\\n\"", "3844": "\"usage\"", "3845": "\"usage:\\n\"", "3846": "\"usage_percpu\"", "3847": "\"use conditional/async gp wait primitives\"", "3848": "\"use expedited gp wait primitives\"", "3849": "\"use normal (non-expedited) gp wait primitives\"", "3850": "\"use synchronous gp wait primitives\"", "3851": "\"use_tempaddr\"", "3852": "\"user\"", "3853": "\"user_reserve_kbytes\"", "3854": "\"usermodehelper\"", "3855": "\"userprocess_debug\"", "3856": "\"using it.\\n\"", "3857": "\"ut\"", "3858": "\"utilization_load_avg\"", "3859": "\"uts\"", "3860": "\"uuid\"", "3861": "\"valid_cookie_life\"", "3862": "\"vdso_enabled\"", "3863": "\"vermagic\"", "3864": "\"version    %s\\n\"", "3865": "\"version %d\\n\"", "3866": "\"version 20070824\\n\"", "3867": "\"version magic: 0x%x\\n\"", "3868": "\"version\"", "3869": "\"version)\\n\"", "3870": "\"vfs_cache_pressure\"", "3871": "\"virq%i doesn't exist; cannot disassociate\\n\"", "3872": "\"vm\"", "3873": "\"vmlinux\"", "3874": "\"w %d %u.%06lu %d 0x%llx 0x%lx 0x%lx %d\\n\"", "3875": "\"wait time between fqs bursts (s)\"", "3876": "\"waiting %dsec before reading resume device...\\n\"", "3877": "\"waiting for connection from remote gdb...\\n\"", "3878": "\"waitqueue\"", "3879": "\"waittime-avg\"", "3880": "\"waittime-max\"", "3881": "\"waittime-min\"", "3882": "\"waittime-total\"", "3883": "\"wake_idx\"", "3884": "\"wakeempty\"", "3885": "\"wakeemptyisdeferred\"", "3886": "\"wakenot\"", "3887": "\"wakenotpoll\"", "3888": "\"wakeovf\"", "3889": "\"wakeovfisdeferred\"", "3890": "\"wakeup trace: couldn't activate tracepoint\"", "3891": "\"wakeup\"", "3892": "\"wakeup_dl\"", "3893": "\"wakeup_rt\"", "3894": "\"warn_noreply_time\"", "3895": "\"warning: `%s' uses 32-bit capabilities (legacy support in use)\\n\"", "3896": "\"warning: `%s' uses deprecated v2 capabilities in a way that may be insecure\\n\"", "3897": "\"warning: boot clock returned invalid value!\\n\"", "3898": "\"warning: could not register \"", "3899": "\"warning: could not register block events\\n\"", "3900": "\"warning: could not register graph trace events\\n\"", "3901": "\"warning: could not register the block tracer\\n\"", "3902": "\"warning: found a stray unused \"", "3903": "\"warning: overflow in clocksource '%s' observed, time update capped.\\n\"", "3904": "\"warning: persistent clock returned invalid value!\\n\"", "3905": "\"warning: process `%s' used the deprecated sysctl \"", "3906": "\"warning: timekeeping: cycle offset (%lld) is larger than allowed by the '%s' clock's max_cycles value (%lld): time overflow danger\\n\"", "3907": "\"warning: underflow in clocksource '%s' observed, time update ignored.\\n\"", "3908": "\"warnings\"", "3909": "\"watchdog detected hard lockup on cpu %d\"", "3910": "\"watchdog\"", "3911": "\"watchdog/%u\"", "3912": "\"watchdog_thresh\"", "3913": "\"which will not be allowed in the future\\n\"", "3914": "\"window_size\"", "3915": "\"wmem_default\"", "3916": "\"wmem_max\"", "3917": "\"wokeempty\"", "3918": "\"wokenonempty\"", "3919": "\"wokequeue\"", "3920": "\"work_struct\"", "3921": "\"workqueue %s: flags=0x%x\\n\"", "3922": "\"workqueue\"", "3923": "\"workqueue: allocation failed while updating numa affinity of \\\"%s\\\"\\n\"", "3924": "\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\"", "3925": "\"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt\"", "3926": "\"workqueue_internal.h\"", "3927": "\"write\"", "3928": "\"write_wakeup_threshold\"", "3929": "\"writer_tasks: out of memory\"", "3930": "\"writes\"", "3931": "\"wrong cpu\"", "3932": "\"wrong owner\"", "3933": "\"wrong sd_flags in topology description\\n\"", "3934": "\"wrote\"", "3935": "\"x\"", "3936": "\"x25\"", "3937": "\"x25_forward\"", "3938": "\"xattr\"", "3939": "\"xfrm_aevent_etime\"", "3940": "\"xfrm_aevent_rseqth\"", "3941": "\"xfs\"", "3942": "\"xfsbufd_centisecs\"", "3943": "\"xfssyncd_centisecs\"", "3944": "\"yes\"", "3945": "\"you already have a breakpoint at \"", "3946": "\"you may retry by moving them to a different hierarchy and unbinding\\n\"", "3947": "\"your compiler is too old; turning off.\\n\"", "3948": "\"zone_reclaim_mode\"", "3949": "\"{%s} state was registered at:\\n\"", "3950": "\"|=\"", "3951": "\"|\\n\"", "3952": "\"||\"", "3953": "\"||||\"", "3954": "\"} \"", "3955": "\"} \\n\"", "3956": "\"}\\n\"", "3957": "\"~\"", "3958": "# define", "3959": "# endif", "3960": "# ifdef", "3961": "#define", "3962": "#endif", "3963": "#ifdef", "3964": "#ifndef", "3965": "#include", "3966": "%", "3967": "&", "3968": "&&", "3969": "' '", "3970": "'!'", "3971": "'\"'", "3972": "'#'", "3973": "'$'", "3974": "'%'", "3975": "'('", "3976": "')'", "3977": "'*'", "3978": "'+'", "3979": "','", "3980": "'-'", "3981": "'.'", "3982": "'/'", "3983": "'0'", "3984": "'1'", "3985": "'2'", "3986": "'3'", "3987": "'4'", "3988": "'5'", "3989": "'9'", "3990": "':'", "3991": "';'", "3992": "'='", "3993": "'>'", "3994": "'?'", "3995": "'@'", "3996": "'['", "3997": "'\\''", "3998": "'\\0'", "3999": "'\\\\'", "4000": "'\\n'", "4001": "'\\t'", "4002": "'^'", "4003": "'_'", "4004": "'a'", "4005": "'b'", "4006": "'c'", "4007": "'d'", "4008": "'e'", "4009": "'f'", "4010": "'g'", "4011": "'h'", "4012": "'i'", "4013": "'k'", "4014": "'l'", "4015": "'m'", "4016": "'n'", "4017": "'o'", "4018": "'p'", "4019": "'q'", "4020": "'r'", "4021": "'s'", "4022": "'t'", "4023": "'u'", "4024": "'v'", "4025": "'w'", "4026": "'x'", "4027": "'y'", "4028": "'z'", "4029": "'|'", "4030": "(", "4031": ")", "4032": "*", "4033": "+", "4034": "++", "4035": ",", "4036": "-", "4037": "--", "4038": "->", "4039": ".", "4040": "/", "4041": "0", "4042": "000000", "4043": "0200", "4044": "0222", "4045": "0400", "4046": "0444", "4047": "0555", "4048": "0600", "4049": "0644", "4050": "0666", "4051": "1", "4052": "1.5", "4053": "10", "4054": "100", "4055": "1000", "4056": "10000", "4057": "100000", "4058": "1000000", "4059": "100000000", "4060": "1001", "4061": "1002", "4062": "1003", "4063": "1005", "4064": "10153587", "4065": "1023", "4066": "1024", "4067": "1048576", "4068": "10698", "4069": "1099582", "4070": "11", "4071": "110", "4072": "1100000", "4073": "112", "4074": "11470", "4075": "117", "4076": "1178", "4077": "118348", "4078": "11916", "4079": "119304647", "4080": "12", "4081": "120", "4082": "12226", "4083": "1234", "4084": "12345", "4085": "123456", "4086": "125", "4087": "127", "4088": "1277", "4089": "128", "4090": "12820798", "4091": "12966", "4092": "13", "4093": "13690", "4094": "137", "4095": "1376151", "4096": "14", "4097": "1431655765", "4098": "14398", "4099": "147320", "4100": "148102320", "4101": "14949", "4102": "15", "4103": "15091", "4104": "15769", "4105": "15790321", "4106": "1586", "4107": "16", "4108": "16433", "4109": "17", "4110": "17082", "4111": "1717300", "4112": "172", "4113": "17718", "4114": "18", "4115": "18340", "4116": "184698", "4117": "186737708", "4118": "18705", "4119": "18949", "4120": "1900", "4121": "19545", "4122": "1982", "4123": "1991", "4124": "19976592", "4125": "2", "4126": "20", "4127": "200", "4128": "2000", "4129": "20000", "4130": "20128", "4131": "20698", "4132": "2088", "4133": "2089", "4134": "21", "4135": "21256", "4136": "215", "4137": "2157191", "4138": "21802", "4139": "22", "4140": "22336", "4141": "22859", "4142": "229616", "4143": "23", "4144": "231", "4145": "23254", "4146": "23371", "4147": "238609294", "4148": "24", "4149": "24970740", "4150": "25", "4151": "250", "4152": "2501", "4153": "253", "4154": "255", "4155": "256", "4156": "2560", "4157": "27", "4158": "2708050", "4159": "272", "4160": "28", "4161": "286331153", "4162": "287308", "4163": "29", "4164": "29154", "4165": "2941", "4166": "3", "4167": "30", "4168": "300", "4169": "31", "4170": "3121", "4171": "31350126", "4172": "32", "4173": "32767", "4174": "32768", "4175": "335", "4176": "3363326", "4177": "345", "4178": "36", "4179": "3600", "4180": "360437", "4181": "36291", "4182": "365", "4183": "367", "4184": "38", "4185": "3880", "4186": "39", "4187": "39045157", "4188": "3906", "4189": "4", "4190": "40", "4191": "400", "4192": "4080", "4193": "4096", "4194": "4194304", "4195": "423", "4196": "43", "4197": "449829", "4198": "45", "4199": "46273", "4200": "47742", "4201": "4798", "4202": "48", "4203": "48388", "4204": "4904", "4205": "49367440", "4206": "5", "4207": "50", "4208": "500", "4209": "5000", "4210": "500000", "4211": "512", "4212": "5237765", "4213": "526", "4214": "56", "4215": "563644", "4216": "56483", "4217": "5678", "4218": "5679", "4219": "5697", "4220": "59856", "4221": "6", "4222": "60", "4223": "600", "4224": "60000", "4225": "6100", "4226": "61356676", "4227": "63", "4228": "64", "4229": "65", "4230": "655", "4231": "65535", "4232": "6557202", "4233": "6576", "4234": "68", "4235": "7", "4236": "70", "4237": "704093", "4238": "71755", "4239": "719499", "4240": "72", "4241": "7437", "4242": "75", "4243": "7500", "4244": "76", "4245": "76040", "4246": "7620", "4247": "76695844", "4248": "8", "4249": "80", "4250": "8165337", "4251": "8192", "4252": "8196", "4253": "820", "4254": "8279", "4255": "87", "4256": "875809", "4257": "88761", "4258": "9", "4259": "9103", "4260": "92818", "4261": "933", "4262": "950000", "4263": "95443717", "4264": "9548", "4265": "96", "4266": "98", "4267": "99", "4268": "9909", "4269": "99900", "4270": ":", "4271": ";", "4272": "<\n\t\t\t\t(rq->", "4273": "<\n\t\t\t(sgs->", "4274": "<\n\t    busiest->", "4275": "<  900000/user_hz ||\n\t\t     txc->", "4276": "<  offset ||\n\t\t    uprobe->", "4277": "< &(rsp)->", "4278": "< &per_cpu(cpu_worker_pools, cpu)[nr_std_worker_pools]; \\\n\t     (pool)++)\n\n\n#define for_each_pool(pool, pi)\t\t\t\t\t\t\\\n\tidr_for_each_entry(&worker_pool_idr, pool, pi)\t\t\t\\\n\t\tif (({ assert_rcu_or_pool_mutex(); false; })) { }\t\\\n\t\telse\n\n\n#define for_each_pool_worker(worker, pool)\t\t\t\t\\\n\tlist_for_each_entry((worker), &(pool)->", "4279": "< &pid_ns->", "4280": "< '0' || argv[0][1] >", "4281": "< ((u64)wl_gc_time_sec * nsec_per_sec))\n\t\t\tbreak;\n\n\t\tif (!active) {\n\t\t\twakeup_source_remove(&wl->", "4282": "< (1ull << dl_scale))\n\t\treturn false;\n\n\t\n\tif (attr->", "4283": "< (arr->", "4284": "< (bufmax - 1)) {\n\t\t\tch = gdbstub_read_wait();\n\t\t\tif (ch == '#')\n\t\t\t\tbreak;\n\t\t\tchecksum = checksum + ch;\n\t\t\tbuffer[count] = ch;\n\t\t\tcount = count + 1;\n\t\t}\n\n\t\tif (ch == '#') {\n\t\t\txmitcsum = hex_to_bin(gdbstub_read_wait()) << 4;\n\t\t\txmitcsum += hex_to_bin(gdbstub_read_wait());\n\n\t\t\tif (checksum != xmitcsum)\n\t\t\t\t\n\t\t\t\tdbg_io_ops->", "4285": "< (bw + bo)) ? -einval : 0;\n}\n\n\nint traceprobe_parse_probe_arg(char *arg, ssize_t *size,\n\t\tstruct probe_arg *parg, bool is_return, bool is_kprobe,\n\t\tconst struct fetch_type *ftbl)\n{\n\tconst char *t;\n\tint ret;\n\n\tif (strlen(arg) >", "4286": "< (commit - read)) ||\n\t    cpu_buffer->", "4287": "< (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p >", "4288": "< (depth + 1) * trace_graph_indent; i++)\n\t\t\ttrace_seq_putc(s, ' ');\n\n\t\n\ttrace_seq_puts(s, \"\n\tif (s->", "4289": "< (group_faults(p, src_nid) * 3 / 4);\n}\n\nstatic unsigned long weighted_cpuload(const int cpu);\nstatic unsigned long source_load(int cpu, int type);\nstatic unsigned long target_load(int cpu, int type);\nstatic unsigned long capacity_of(int cpu);\nstatic long effective_load(struct task_group *tg, int cpu, long wl, long wg);\n\n\nstruct numa_stats {\n\tunsigned long nr_running;\n\tunsigned long load;\n\n\t\n\tunsigned long compute_capacity;\n\n\t\n\tunsigned long task_capacity;\n\tint has_free_capacity;\n};\n\n\nstatic void update_numa_stats(struct numa_stats *ns, int nid)\n{\n\tint smt, cpu, cpus = 0;\n\tunsigned long capacity;\n\n\tmemset(ns, 0, sizeof(*ns));\n\tfor_each_cpu(cpu, cpumask_of_node(nid)) {\n\t\tstruct rq *rq = cpu_rq(cpu);\n\n\t\tns->", "4290": "< (mask >", "4291": "< (pos & 0xff); i++)\n\t\tname = name + (*name) + 1;\n\n\treturn name - kallsyms_names;\n}\n\n\nunsigned long kallsyms_lookup_name(const char *name)\n{\n\tchar namebuf[ksym_name_len];\n\tunsigned long i;\n\tunsigned int off;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, array_size(namebuf));\n\n\t\tif (strcmp(namebuf, name) == 0)\n\t\t\treturn kallsyms_addresses[i];\n\t}\n\treturn module_kallsyms_lookup_name(name);\n}\nexport_symbol_gpl(kallsyms_lookup_name);\n\nint kallsyms_on_each_symbol(int (*fn)(void *, const char *, struct module *,\n\t\t\t\t      unsigned long),\n\t\t\t    void *data)\n{\n\tchar namebuf[ksym_name_len];\n\tunsigned long i;\n\tunsigned int off;\n\tint ret;\n\n\tfor (i = 0, off = 0; i < kallsyms_num_syms; i++) {\n\t\toff = kallsyms_expand_symbol(off, namebuf, array_size(namebuf));\n\t\tret = fn(data, namebuf, null, kallsyms_addresses[i]);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn module_kallsyms_on_each_symbol(fn, data);\n}\nexport_symbol_gpl(kallsyms_on_each_symbol);\n\nstatic unsigned long get_symbol_pos(unsigned long addr,\n\t\t\t\t    unsigned long *symbolsize,\n\t\t\t\t    unsigned long *offset)\n{\n\tunsigned long symbol_start = 0, symbol_end = 0;\n\tunsigned long i, low, high, mid;\n\n\t\n\tbug_on(!kallsyms_addresses);\n\n\t\n\tlow = 0;\n\thigh = kallsyms_num_syms;\n\n\twhile (high - low >", "4292": "< (ret & seccomp_ret_action))\n\t\t\tret = cur_ret;\n\t}\n\treturn ret;\n}\n#endif \n\nstatic inline bool seccomp_may_assign_mode(unsigned long seccomp_mode)\n{\n\tassert_spin_locked(&current->", "4293": "< (rsp)->", "4294": "< (s64)d->", "4295": "< (s64)sysctl_sched_migration_cost;\n}\n\n#ifdef config_numa_balancing\n\nstatic bool migrate_improves_locality(struct task_struct *p, struct lb_env *env)\n{\n\tstruct numa_group *numa_group = rcu_dereference(p->", "4296": "< (unsigned long) -1l ?\n\t\t\t\t(unsigned long) elapsed : (unsigned long) -1l);\n#endif\n#if acct_version == 1 || acct_version == 2\n\t{\n\t\t\n\t\tcomp2_t etime = encode_comp2_t(elapsed);\n\n\t\tac->", "4297": "< (unsigned long)__irqentry_text_start ||\n\t\taddr >", "4298": "< (unsigned long)__irqentry_text_start) ||\n\t    (addr >", "4299": "< (unsigned long)__kprobes_text_end;\n}\n\nstatic bool within_kprobe_blacklist(unsigned long addr)\n{\n\tstruct kprobe_blacklist_entry *ent;\n\n\tif (arch_within_kprobe_blacklist(addr))\n\t\treturn true;\n\t\n\tlist_for_each_entry(ent, &kprobe_blacklist, list) {\n\t\tif (addr >", "4300": "< (unsigned long)__lock_text_end;\n}\nexport_symbol(in_lock_functions);\n\nlockdep_state(hardirq)\nlockdep_state(softirq)\nlockdep_state(reclaim_fs)\n#ifndef _linux_cpudl_h\n#define _linux_cpudl_h\n\n#include <linux/sched.h>", "4301": "< (unsigned long)__sched_text_end);\n}\n\n#ifdef config_cgroup_sched\n\nstruct task_group root_task_group;\nlist_head(task_groups);\n#endif\n\ndeclare_per_cpu(cpumask_var_t, load_balance_mask);\n\nvoid __init sched_init(void)\n{\n\tint i, j;\n\tunsigned long alloc_size = 0, ptr;\n\n#ifdef config_fair_group_sched\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n#ifdef config_rt_group_sched\n\talloc_size += 2 * nr_cpu_ids * sizeof(void **);\n#endif\n\tif (alloc_size) {\n\t\tptr = (unsigned long)kzalloc(alloc_size, gfp_nowait);\n\n#ifdef config_fair_group_sched\n\t\troot_task_group.se = (struct sched_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.cfs_rq = (struct cfs_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif \n#ifdef config_rt_group_sched\n\t\troot_task_group.rt_se = (struct sched_rt_entity **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n\t\troot_task_group.rt_rq = (struct rt_rq **)ptr;\n\t\tptr += nr_cpu_ids * sizeof(void **);\n\n#endif \n\t}\n#ifdef config_cpumask_offstack\n\tfor_each_possible_cpu(i) {\n\t\tper_cpu(load_balance_mask, i) = (cpumask_var_t)kzalloc_node(\n\t\t\tcpumask_size(), gfp_kernel, cpu_to_node(i));\n\t}\n#endif \n\n\tinit_rt_bandwidth(&def_rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n\tinit_dl_bandwidth(&def_dl_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n\n#ifdef config_smp\n\tinit_defrootdomain();\n#endif\n\n#ifdef config_rt_group_sched\n\tinit_rt_bandwidth(&root_task_group.rt_bandwidth,\n\t\t\tglobal_rt_period(), global_rt_runtime());\n#endif \n\n#ifdef config_cgroup_sched\n\tlist_add(&root_task_group.list, &task_groups);\n\tinit_list_head(&root_task_group.children);\n\tinit_list_head(&root_task_group.siblings);\n\tautogroup_init(&init_task);\n\n#endif \n\n\tfor_each_possible_cpu(i) {\n\t\tstruct rq *rq;\n\n\t\trq = cpu_rq(i);\n\t\traw_spin_lock_init(&rq->", "4302": "< (unsigned long)_edata)\n\t\treturn 1;\n\treturn 0;\n}\n\nint __kernel_text_address(unsigned long addr)\n{\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\tif (is_module_text_address(addr))\n\t\treturn 1;\n\tif (is_ftrace_trampoline(addr))\n\t\treturn 1;\n\t\n\tif (init_kernel_text(addr))\n\t\treturn 1;\n\treturn 0;\n}\n\nint kernel_text_address(unsigned long addr)\n{\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\tif (is_module_text_address(addr))\n\t\treturn 1;\n\treturn is_ftrace_trampoline(addr);\n}\n\n\nint func_ptr_is_kernel_text(void *ptr)\n{\n\tunsigned long addr;\n\taddr = (unsigned long) dereference_function_descriptor(ptr);\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\treturn is_module_text_address(addr);\n}\n\n\n#define rt_mutex_deadlock_check(l)\t\t\t(0)\n#define rt_mutex_deadlock_account_lock(m, t)\t\tdo { } while (0)\n#define rt_mutex_deadlock_account_unlock(l)\t\tdo { } while (0)\n#define debug_rt_mutex_init_waiter(w)\t\t\tdo { } while (0)\n#define debug_rt_mutex_free_waiter(w)\t\t\tdo { } while (0)\n#define debug_rt_mutex_lock(l)\t\t\t\tdo { } while (0)\n#define debug_rt_mutex_proxy_lock(l,p)\t\t\tdo { } while (0)\n#define debug_rt_mutex_proxy_unlock(l)\t\t\tdo { } while (0)\n#define debug_rt_mutex_unlock(l)\t\t\tdo { } while (0)\n#define debug_rt_mutex_init(m, n)\t\t\tdo { } while (0)\n#define debug_rt_mutex_deadlock(d, a ,l)\t\tdo { } while (0)\n#define debug_rt_mutex_print_deadlock(w)\t\tdo { } while (0)\n#define debug_rt_mutex_reset_waiter(w)\t\t\tdo { } while (0)\n\nstatic inline void rt_mutex_print_deadlock(struct rt_mutex_waiter *w)\n{\n\twarn(1, \"rtmutex deadlock detected\\n\");\n}\n\nstatic inline bool debug_rt_mutex_detect_deadlock(struct rt_mutex_waiter *w,\n\t\t\t\t\t\t  enum rtmutex_chainwalk walk)\n{\n\treturn walk == rt_mutex_full_chainwalk;\n}\n#include \"audit.h\"\n#include <linux/fsnotify_backend.h>", "4303": "< (unsigned long)_einittext)\n\t\treturn 1;\n\treturn 0;\n}\n\nint core_kernel_text(unsigned long addr)\n{\n\tif (addr >", "4304": "< (unsigned long)_etext)\n\t\treturn 1;\n\n\tif (system_state == system_booting &&\n\t    init_kernel_text(addr))\n\t\treturn 1;\n\treturn 0;\n}\n\n\nint core_kernel_data(unsigned long addr)\n{\n\tif (addr >", "4305": "< (unsigned long)end;\t\t\\\n\t     event++)\n\n#ifdef config_modules\n\nstatic void trace_module_add_events(struct module *mod)\n{\n\tstruct ftrace_event_call **call, **start, **end;\n\n\tif (!mod->", "4306": "< (unsigned)(b - base);\n}\n\n\nstatic void set_last_pid(struct pid_namespace *pid_ns, int base, int pid)\n{\n\tint prev;\n\tint last_write = base;\n\tdo {\n\t\tprev = last_write;\n\t\tlast_write = cmpxchg(&pid_ns->", "4307": "< *lenp && len < maxlen - 1) {\n\t\t\tif (get_user(c, p++))\n\t\t\t\treturn -efault;\n\t\t\tif (c == 0 || c == '\\n')\n\t\t\t\tbreak;\n\t\t\tdata[len++] = c;\n\t\t}\n\t\tdata[len] = 0;\n\t} else {\n\t\tlen = strlen(data);\n\t\tif (len >", "4308": "< *lenp) {\n\t\t\tif (put_user('\\n', buffer + len))\n\t\t\t\treturn -efault;\n\t\t\tlen++;\n\t\t}\n\t\t*lenp = len;\n\t\t*ppos += len;\n\t}\n\treturn 0;\n}\n\nstatic void warn_sysctl_write(struct ctl_table *table)\n{\n\tpr_warn_once(\"%s wrote to %s when file position was not 0!\\n\"\n\t\t\"this will not be supported in the future. to silence this\\n\"\n\t\t\"warning, set kernel.sysctl_writes_strict = -1\\n\",\n\t\tcurrent->", "4309": "< *min) || (max && val >", "4310": "< *pos && p)\n\t\tp = f_next(m, p, &l);\n\n\treturn p;\n}\n\nstatic void f_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&event_mutex);\n}\n\nstatic const struct seq_operations trace_format_seq_ops = {\n\t.start\t\t= f_start,\n\t.next\t\t= f_next,\n\t.stop\t\t= f_stop,\n\t.show\t\t= f_show,\n};\n\nstatic int trace_format_open(struct inode *inode, struct file *file)\n{\n\tstruct seq_file *m;\n\tint ret;\n\n\tret = seq_open(file, &trace_format_seq_ops);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tm = file->", "4311": "< *pos; i++) {\n\t\tif (gcov_iter_next(seq->", "4312": "< *pos; p = r_next(m, p, &l))\n\t\t;\n\treturn p;\n}\n\nstatic void r_stop(struct seq_file *m, void *v)\n\t__releases(resource_lock)\n{\n\tread_unlock(&resource_lock);\n}\n\nstatic int r_show(struct seq_file *m, void *v)\n{\n\tstruct resource *root = m->", "4313": "< *size && perm_tr_len && !memchr(perm_tr, *p, perm_tr_len))\n\t\treturn -einval;\n\n\tif (tr && (len < *size))\n\t\t*tr = *p;\n\n\t*buf += len;\n\t*size -= len;\n\n\treturn 0;\n}\n\n\nstatic int proc_put_long(void __user **buf, size_t *size, unsigned long val,\n\t\t\t  bool neg)\n{\n\tint len;\n\tchar tmp[tmpbuflen], *p = tmp;\n\n\tsprintf(p, \"%s%lu\", neg ? \"-\" : \"\", val);\n\tlen = strlen(tmp);\n\tif (len >", "4314": "< -1 || val >", "4315": "< -1)\n\t\treturn -ebusy;\n\n\tcalltime = trace_clock_local();\n\n\tindex = ++current->", "4316": "< -1) {\n\t\tcurrent->", "4317": "< -max_bpf_stack || off + access_size >", "4318": "< -max_bpf_stack) {\n\t\t\tverbose(\"invalid stack off=%d size=%d\\n\", off, size);\n\t\t\treturn -eacces;\n\t\t}\n\t\tif (t == bpf_write)\n\t\t\terr = check_stack_write(state, off, size, value_regno);\n\t\telse\n\t\t\terr = check_stack_read(state, off, size, value_regno);\n\t} else {\n\t\tverbose(\"r%d invalid mem access '%s'\\n\",\n\t\t\tregno, reg_type_str[state->", "4319": "< -max_tickadj) {\n\t\ttime_adjust += max_tickadj;\n\t\ttick_length -= max_tickadj_scaled;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * nsec_per_usec / ntp_interval_freq)\n\t\t\t\t\t\t\t << ntp_scale_shift;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}\n\n#ifdef config_generic_cmos_update\nint __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}\n#endif\n\n#if defined(config_generic_cmos_update) || defined(config_rtc_systohc)\nstatic void sync_cmos_clock(struct work_struct *work);\n\nstatic declare_delayed_work(sync_cmos_work, sync_cmos_clock);\n\nstatic void sync_cmos_clock(struct work_struct *work)\n{\n\tstruct timespec64 now;\n\tstruct timespec next;\n\tint fail = 1;\n\n\t\n\tif (!ntp_synced()) {\n\t\t\n\t\treturn;\n\t}\n\n\tgetnstimeofday64(&now);\n\tif (abs(now.tv_nsec - (nsec_per_sec / 2)) <= tick_nsec * 5) {\n\t\tstruct timespec64 adjust = now;\n\n\t\tfail = -enodev;\n\t\tif (persistent_clock_is_local)\n\t\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n#ifdef config_generic_cmos_update\n\t\tfail = update_persistent_clock64(adjust);\n#endif\n\n#ifdef config_rtc_systohc\n\t\tif (fail == -enodev)\n\t\t\tfail = rtc_set_ntp_time(adjust);\n#endif\n\t}\n\n\tnext.tv_nsec = (nsec_per_sec / 2) - now.tv_nsec - (tick_nsec / 2);\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += nsec_per_sec;\n\n\tif (!fail || fail == -enodev)\n\t\tnext.tv_sec = 659;\n\telse\n\t\tnext.tv_sec = 0;\n\n\tif (next.tv_nsec >", "4320": "< -maxfreq * freq_norm.sec)) {\n\t\ttime_status |= sta_ppsjitter;\n\t\t\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(kern_err \"hardpps: ppsjitter: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t\n\n\t\n\tif (freq_norm.sec >", "4321": "< -pps_maxwander) {\n\t\tprintk_deferred(kern_warning\n\t\t\t\t\"hardpps: ppswander: change=%ld\\n\", delta);\n\t\ttime_status |= sta_ppswander;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t\n\t\tpps_inc_freq_interval();\n\t}\n\n\t\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(ntp_scale_shift - shift_usec),\n\t\t\t\tnsec_per_usec) - pps_stabil) >", "4322": "< 0  ? \"h\" : \"\");\n\telse\n\t\tsnprintf(id_buf, sizeof(id_buf), \"u%d:%d\", pool->", "4323": "< 0 &&\n\t\t   t->", "4324": "< 0 && !can_nice(current, nice))\n\t\treturn -eperm;\n\n\t\n\tif (!capable(cap_sys_admin) && time_before(jiffies, next))\n\t\treturn -eagain;\n\n\tnext = hz / 10 + jiffies;\n\tag = autogroup_task_get(p);\n\n\tdown_write(&ag->", "4325": "< 0 && groupimp < 0)\n\t\t\t\tcontinue;\n\n\t\t\tenv.dist = dist;\n\t\t\tenv.dst_nid = nid;\n\t\t\tupdate_numa_stats(&env.dst_stats, env.dst_nid);\n\t\t\ttask_numa_find_cpu(&env, taskimp, groupimp);\n\t\t}\n\t}\n\n\t\n\tif (p->", "4326": "< 0 && ret != -enosys)\n\t\t\tpr_warn(\"could not initialize trace events/%s\\n\", name);\n\t}\n\n\treturn ret;\n}\n\nstatic int\n__register_event(struct ftrace_event_call *call, struct module *mod)\n{\n\tint ret;\n\n\tret = event_init(call);\n\tif (ret < 0)\n\t\treturn ret;\n\n\tlist_add(&call->", "4327": "< 0 && rrln >", "4328": "< 0 ? 0 : timeout;\n}\nexport_symbol(schedule_timeout);\n\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(task_interruptible);\n\treturn schedule_timeout(timeout);\n}\nexport_symbol(schedule_timeout_interruptible);\n\nsigned long __sched schedule_timeout_killable(signed long timeout)\n{\n\t__set_current_state(task_killable);\n\treturn schedule_timeout(timeout);\n}\nexport_symbol(schedule_timeout_killable);\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(task_uninterruptible);\n\treturn schedule_timeout(timeout);\n}\nexport_symbol(schedule_timeout_uninterruptible);\n\n#ifdef config_hotplug_cpu\nstatic void migrate_timer_list(struct tvec_base *new_base, struct list_head *head)\n{\n\tstruct timer_list *timer;\n\n\twhile (!list_empty(head)) {\n\t\ttimer = list_first_entry(head, struct timer_list, entry);\n\t\t\n\t\tdetach_timer(timer, false);\n\t\ttimer_set_base(timer, new_base);\n\t\tinternal_add_timer(new_base, timer);\n\t}\n}\n\nstatic void migrate_timers(int cpu)\n{\n\tstruct tvec_base *old_base;\n\tstruct tvec_base *new_base;\n\tint i;\n\n\tbug_on(cpu_online(cpu));\n\told_base = per_cpu(tvec_bases, cpu);\n\tnew_base = get_cpu_var(tvec_bases);\n\t\n\tspin_lock_irq(&new_base->", "4329": "< 0 ? err : 0;\n}\n\n\nstatic void audit_receive_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh;\n\t\n\tint len;\n\tint err;\n\n\tnlh = nlmsg_hdr(skb);\n\tlen = skb->", "4330": "< 0 ? ret : 0;\n}\n\nstatic int\nftrace_trace_onoff_callback(struct ftrace_hash *hash,\n\t\t\t    char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\t\n\tif (strcmp(cmd, \"traceon\") == 0)\n\t\tops = param ? &traceon_count_probe_ops : &traceon_probe_ops;\n\telse\n\t\tops = param ? &traceoff_count_probe_ops : &traceoff_probe_ops;\n\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}\n\nstatic int\nftrace_stacktrace_callback(struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tops = param ? &stacktrace_count_probe_ops : &stacktrace_probe_ops;\n\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   param, enable);\n}\n\nstatic int\nftrace_dump_callback(struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tops = &dump_probe_ops;\n\n\t\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}\n\nstatic int\nftrace_cpudump_callback(struct ftrace_hash *hash,\n\t\t\t   char *glob, char *cmd, char *param, int enable)\n{\n\tstruct ftrace_probe_ops *ops;\n\n\tops = &cpudump_probe_ops;\n\n\t\n\treturn ftrace_trace_probe_callback(ops, hash, glob, cmd,\n\t\t\t\t\t   \"1\", enable);\n}\n\nstatic struct ftrace_func_command ftrace_traceon_cmd = {\n\t.name\t\t\t= \"traceon\",\n\t.func\t\t\t= ftrace_trace_onoff_callback,\n};\n\nstatic struct ftrace_func_command ftrace_traceoff_cmd = {\n\t.name\t\t\t= \"traceoff\",\n\t.func\t\t\t= ftrace_trace_onoff_callback,\n};\n\nstatic struct ftrace_func_command ftrace_stacktrace_cmd = {\n\t.name\t\t\t= \"stacktrace\",\n\t.func\t\t\t= ftrace_stacktrace_callback,\n};\n\nstatic struct ftrace_func_command ftrace_dump_cmd = {\n\t.name\t\t\t= \"dump\",\n\t.func\t\t\t= ftrace_dump_callback,\n};\n\nstatic struct ftrace_func_command ftrace_cpudump_cmd = {\n\t.name\t\t\t= \"cpudump\",\n\t.func\t\t\t= ftrace_cpudump_callback,\n};\n\nstatic int __init init_func_cmd_traceon(void)\n{\n\tint ret;\n\n\tret = register_ftrace_command(&ftrace_traceoff_cmd);\n\tif (ret)\n\t\treturn ret;\n\n\tret = register_ftrace_command(&ftrace_traceon_cmd);\n\tif (ret)\n\t\tgoto out_free_traceoff;\n\n\tret = register_ftrace_command(&ftrace_stacktrace_cmd);\n\tif (ret)\n\t\tgoto out_free_traceon;\n\n\tret = register_ftrace_command(&ftrace_dump_cmd);\n\tif (ret)\n\t\tgoto out_free_stacktrace;\n\n\tret = register_ftrace_command(&ftrace_cpudump_cmd);\n\tif (ret)\n\t\tgoto out_free_dump;\n\n\treturn 0;\n\n out_free_dump:\n\tunregister_ftrace_command(&ftrace_dump_cmd);\n out_free_stacktrace:\n\tunregister_ftrace_command(&ftrace_stacktrace_cmd);\n out_free_traceon:\n\tunregister_ftrace_command(&ftrace_traceon_cmd);\n out_free_traceoff:\n\tunregister_ftrace_command(&ftrace_traceoff_cmd);\n\n\treturn ret;\n}\n#else\nstatic inline int init_func_cmd_traceon(void)\n{\n\treturn 0;\n}\n#endif \n\nstatic __init int init_function_trace(void)\n{\n\tinit_func_cmd_traceon();\n\treturn register_tracer(&function_trace);\n}\ncore_initcall(init_function_trace);\n\n\n#include <linux/kernel.h>", "4331": "< 0 ? ret : count;\n}\nkernel_attr_rw(kexec_crash_size);\n\nstatic ssize_t vmcoreinfo_show(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lx %x\\n\",\n\t\t       paddr_vmcoreinfo_note(),\n\t\t       (unsigned int)sizeof(vmcoreinfo_note));\n}\nkernel_attr_ro(vmcoreinfo);\n\n#endif \n\n\nstatic ssize_t fscaps_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", file_caps_enabled);\n}\nkernel_attr_ro(fscaps);\n\nint rcu_expedited;\nstatic ssize_t rcu_expedited_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", rcu_expedited);\n}\nstatic ssize_t rcu_expedited_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t count)\n{\n\tif (kstrtoint(buf, 0, &rcu_expedited))\n\t\treturn -einval;\n\n\treturn count;\n}\nkernel_attr_rw(rcu_expedited);\n\n\nextern const void __start_notes __weak;\nextern const void __stop_notes __weak;\n#define\tnotes_size (&__stop_notes - &__start_notes)\n\nstatic ssize_t notes_read(struct file *filp, struct kobject *kobj,\n\t\t\t  struct bin_attribute *bin_attr,\n\t\t\t  char *buf, loff_t off, size_t count)\n{\n\tmemcpy(buf, &__start_notes + off, count);\n\treturn count;\n}\n\nstatic struct bin_attribute notes_attr = {\n\t.attr = {\n\t\t.name = \"notes\",\n\t\t.mode = s_irugo,\n\t},\n\t.read = &notes_read,\n};\n\nstruct kobject *kernel_kobj;\nexport_symbol_gpl(kernel_kobj);\n\nstatic struct attribute * kernel_attrs[] = {\n\t&fscaps_attr.attr,\n\t&uevent_seqnum_attr.attr,\n#ifdef config_uevent_helper\n\t&uevent_helper_attr.attr,\n#endif\n#ifdef config_profiling\n\t&profiling_attr.attr,\n#endif\n#ifdef config_kexec\n\t&kexec_loaded_attr.attr,\n\t&kexec_crash_loaded_attr.attr,\n\t&kexec_crash_size_attr.attr,\n\t&vmcoreinfo_attr.attr,\n#endif\n\t&rcu_expedited_attr.attr,\n\tnull\n};\n\nstatic struct attribute_group kernel_attr_group = {\n\t.attrs = kernel_attrs,\n};\n\nstatic int __init ksysfs_init(void)\n{\n\tint error;\n\n\tkernel_kobj = kobject_create_and_add(\"kernel\", null);\n\tif (!kernel_kobj) {\n\t\terror = -enomem;\n\t\tgoto exit;\n\t}\n\terror = sysfs_create_group(kernel_kobj, &kernel_attr_group);\n\tif (error)\n\t\tgoto kset_exit;\n\n\tif (notes_size >", "4332": "< 0 ? x : y;\n}\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) >", "4333": "< 0 ||\n\t\t    !cpu_online(cpu_file))\n\t\t\treturn kdb_badint;\n\t} else {\n\t\tcpu_file = ring_buffer_all_cpus;\n\t}\n\n\tkdb_trap_printk++;\n\tftrace_dump_buf(skip_lines, cpu_file);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}\n\nstatic __init int kdb_ftrace_register(void)\n{\n\tkdb_register_flags(\"ftdump\", kdb_ftdump, \"[skip_#lines] [cpu]\",\n\t\t\t    \"dump ftrace log\", 0, kdb_enable_always_safe);\n\treturn 0;\n}\n\nlate_initcall(kdb_ftrace_register);\n\n\n#include <linux/types.h>", "4334": "< 0 || !tick_nohz_full_cpu(cpu)],\n\t\t t->", "4335": "< 0 || (delta >", "4336": "< 0 || bp->", "4337": "< 0 || data->", "4338": "< 0 || func_id >", "4339": "< 0 || id >", "4340": "< 0 || len >", "4341": "< 0 || num >", "4342": "< 0 || off + size >", "4343": "< 0 || off >", "4344": "< 0 || size >", "4345": "< 0 || syscall_nr >", "4346": "< 0 || w >", "4347": "< 0)\n\t\t\t\t\terror = -enodev;\n\t\t\t} else {\n\t\t\t\tdata->", "4348": "< 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t\n\tdiag = kdbgetintenv(\"logging\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"logging\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, null, 0, null))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >", "4349": "< 0)\n\t\t\t\tgoto err;\n\t\t}\n\t}\n\treturn 0;\nerr:\n\tcgroup_clear_dir(cgrp, subsys_mask);\n\treturn ret;\n}\n\n\nstatic void css_free_work_fn(struct work_struct *work)\n{\n\tstruct cgroup_subsys_state *css =\n\t\tcontainer_of(work, struct cgroup_subsys_state, destroy_work);\n\tstruct cgroup_subsys *ss = css->", "4350": "< 0)\n\t\t\t\tgoto err_free;\n\t\t} else if (opcode == bpf_ja) {\n\t\t\tif (bpf_src(insns[t].code) != bpf_k) {\n\t\t\t\tret = -einval;\n\t\t\t\tgoto err_free;\n\t\t\t}\n\t\t\t\n\t\t\tret = push_insn(t, t + insns[t].off + 1,\n\t\t\t\t\tfallthrough, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t\t\n\t\t\tif (t + 1 < insn_cnt)\n\t\t\t\tenv->", "4351": "< 0)\n\t\t\t\tgoto err_free;\n\n\t\t\tret = push_insn(t, t + insns[t].off + 1, branch, env);\n\t\t\tif (ret == 1)\n\t\t\t\tgoto peek_stack;\n\t\t\telse if (ret < 0)\n\t\t\t\tgoto err_free;\n\t\t}\n\t} else {\n\t\t\n\t\tret = push_insn(t, t + 1, fallthrough, env);\n\t\tif (ret == 1)\n\t\t\tgoto peek_stack;\n\t\telse if (ret < 0)\n\t\t\tgoto err_free;\n\t}\n\nmark_explored:\n\tinsn_state[t] = explored;\n\tif (cur_stack-- <= 0) {\n\t\tverbose(\"pop stack internal bug\\n\");\n\t\tret = -efault;\n\t\tgoto err_free;\n\t}\n\tgoto peek_stack;\n\ncheck_state:\n\tfor (i = 0; i < insn_cnt; i++) {\n\t\tif (insn_state[i] != explored) {\n\t\t\tverbose(\"unreachable insn %d\\n\", i);\n\t\t\tret = -einval;\n\t\t\tgoto err_free;\n\t\t}\n\t}\n\tret = 0; \n\nerr_free:\n\tkfree(insn_state);\n\tkfree(insn_stack);\n\treturn ret;\n}\n\n\nstatic bool states_equal(struct verifier_state *old, struct verifier_state *cur)\n{\n\tint i;\n\n\tfor (i = 0; i < max_bpf_reg; i++) {\n\t\tif (memcmp(&old->", "4352": "< 0)\n\t\t\t\tgoto error;\n\t\t}\n\t}\n\tif (euid != (uid_t) -1)\n\t\tnew->", "4353": "< 0)\n\t\t\t\tgoto error;\n\t\t}\n\t} else if (!uid_eq(kuid, old->", "4354": "< 0)\n\t\t\t\tgoto free_hash;\n\t\t}\n\t}\n\n\tftrace_warn_on(new_hash->", "4355": "< 0)\n\t\t\t\tgoto out;\n\t\t\tvalue = ret;\n\t\t}\n\t} else if (sscanf(buf, \"%llu\", &value) != 1)\n\t\tgoto out;\n\n\tret = -enxio;\n\n\tp = dev_to_part(dev);\n\tbdev = bdget(part_devt(p));\n\tif (bdev == null)\n\t\tgoto out;\n\n\tq = blk_trace_get_queue(bdev);\n\tif (q == null)\n\t\tgoto out_bdput;\n\n\tmutex_lock(&bdev->", "4356": "< 0)\n\t\t\t\tgoto out_reset;\n\t\t\tif (ret)\n\t\t\t\tgoto out_again;\n\t\t} else {\n\t\t\t\n\t\t\tif (unlikely((cpu_buffer->", "4357": "< 0)\n\t\t\t\tpr_info(\"cannot allocate irq_descs @ irq%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}\nexport_symbol_gpl(irq_domain_add_simple);\n\n\nstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(of_node, first_hwirq + size,\n\t\t\t\t  first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}\nexport_symbol_gpl(irq_domain_add_legacy);\n\n\nstruct irq_domain *irq_find_host(struct device_node *node)\n{\n\tstruct irq_domain *h, *found = null;\n\tint rc;\n\n\t\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->", "4358": "< 0)\n\t\t\t\trestore_unbound_workers_cpumask(pool, cpu);\n\n\t\t\tmutex_unlock(&pool->", "4359": "< 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tbreak;\n\t}\n\tcase audit_get_feature:\n\t\terr = audit_get_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase audit_set_feature:\n\t\terr = audit_set_feature(skb);\n\t\tif (err)\n\t\t\treturn err;\n\t\tbreak;\n\tcase audit_user:\n\tcase audit_first_user_msg ... audit_last_user_msg:\n\tcase audit_first_user_msg2 ... audit_last_user_msg2:\n\t\tif (!audit_enabled && msg_type != audit_user_avc)\n\t\t\treturn 0;\n\n\t\terr = audit_filter_user(msg_type);\n\t\tif (err == 1) { \n\t\t\terr = 0;\n\t\t\tif (msg_type == audit_user_tty) {\n\t\t\t\terr = tty_audit_push_current();\n\t\t\t\tif (err)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmutex_unlock(&audit_cmd_mutex);\n\t\t\taudit_log_common_recv_msg(&ab, msg_type);\n\t\t\tif (msg_type != audit_user_tty)\n\t\t\t\taudit_log_format(ab, \" msg='%.*s'\",\n\t\t\t\t\t\t audit_message_text_max,\n\t\t\t\t\t\t (char *)data);\n\t\t\telse {\n\t\t\t\tint size;\n\n\t\t\t\taudit_log_format(ab, \" data=\");\n\t\t\t\tsize = nlmsg_len(nlh);\n\t\t\t\tif (size >", "4360": "< 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_backlog_limit) {\n\t\t\terr = audit_set_backlog_limit(s.backlog_limit);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_backlog_wait_time) {\n\t\t\tif (sizeof(s) >", "4361": "< 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_failure) {\n\t\t\terr = audit_set_failure(s.failure);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (s.mask & audit_status_pid) {\n\t\t\tint new_pid = s.pid;\n\n\t\t\tif ((!new_pid) && (task_tgid_vnr(current) != audit_pid))\n\t\t\t\treturn -eacces;\n\t\t\tif (audit_enabled != audit_off)\n\t\t\t\taudit_log_config_change(\"audit_pid\", new_pid, audit_pid, 1);\n\t\t\taudit_pid = new_pid;\n\t\t\taudit_nlk_portid = netlink_cb(skb).portid;\n\t\t\taudit_sock = skb->", "4362": "< 0)\n\t\t\t\tset_user_nice(p, 0);\n\t\t\tcontinue;\n\t\t}\n\n\t\trq = task_rq_lock(p, &flags);\n\t\tnormalize_task(rq, p);\n\t\ttask_rq_unlock(rq, p, &flags);\n\t}\n\tread_unlock(&tasklist_lock);\n}\n\n#endif \n\n#if defined(config_ia64) || defined(config_kgdb_kdb)\n\n\n\nstruct task_struct *curr_task(int cpu)\n{\n\treturn cpu_curr(cpu);\n}\n\n#endif \n\n#ifdef config_ia64\n\nvoid set_curr_task(int cpu, struct task_struct *p)\n{\n\tcpu_curr(cpu) = p;\n}\n\n#endif\n\n#ifdef config_cgroup_sched\n\nstatic define_spinlock(task_group_lock);\n\nstatic void free_sched_group(struct task_group *tg)\n{\n\tfree_fair_sched_group(tg);\n\tfree_rt_sched_group(tg);\n\tautogroup_free(tg);\n\tkfree(tg);\n}\n\n\nstruct task_group *sched_create_group(struct task_group *parent)\n{\n\tstruct task_group *tg;\n\n\ttg = kzalloc(sizeof(*tg), gfp_kernel);\n\tif (!tg)\n\t\treturn err_ptr(-enomem);\n\n\tif (!alloc_fair_sched_group(tg, parent))\n\t\tgoto err;\n\n\tif (!alloc_rt_sched_group(tg, parent))\n\t\tgoto err;\n\n\treturn tg;\n\nerr:\n\tfree_sched_group(tg);\n\treturn err_ptr(-enomem);\n}\n\nvoid sched_online_group(struct task_group *tg, struct task_group *parent)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&task_group_lock, flags);\n\tlist_add_rcu(&tg->", "4363": "< 0)\n\t\t\tbreak;\n\t}\n\treturn err;\n}\n\n\nunsigned int __weak arch_mod_section_prepend(struct module *mod,\n\t\t\t\t\t     unsigned int section)\n{\n\t\n\treturn 0;\n}\n\n\nstatic long get_offset(struct module *mod, unsigned int *size,\n\t\t       elf_shdr *sechdr, unsigned int section)\n{\n\tlong ret;\n\n\t*size += arch_mod_section_prepend(mod, section);\n\tret = align(*size, sechdr->", "4364": "< 0)\n\t\t\tdelta = 0;\n\n\t\tif (unlikely(delta >", "4365": "< 0)\n\t\t\tgoto done;\n\n\t\tif (!nodes_subset(trialcs->", "4366": "< 0)\n\t\t\tgoto end;\n\t\tfree_trace_kprobe(old_tk);\n\t}\n\n\t\n\tret = register_kprobe_event(tk);\n\tif (ret) {\n\t\tpr_warning(\"failed to register probe event(%d)\\n\", ret);\n\t\tgoto end;\n\t}\n\n\t\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0)\n\t\tunregister_kprobe_event(tk);\n\telse\n\t\tlist_add_tail(&tk->", "4367": "< 0)\n\t\t\tgoto error;\n\t}\n\tif (ruid != (uid_t) -1 ||\n\t    (euid != (uid_t) -1 && !uid_eq(keuid, old->", "4368": "< 0)\n\t\t\tgoto error_put;\n\t}\n\n#ifdef config_keys\n\t\n\tif (new->", "4369": "< 0)\n\t\t\tgoto free_pages;\n\n\t\tnum_to_init -= cnt;\n\t\tif (!num_to_init)\n\t\t\tbreak;\n\n\t\tpg->", "4370": "< 0)\n\t\t\tgoto next;\n\t\tctx = rcu_dereference(current->", "4371": "< 0)\n\t\t\tgoto out;\n\t}\n\n\tlist_add_rcu(&data->", "4372": "< 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}\n\nstatic const struct bin_table *get_sysctl(const int *name, int nlen, char *path)\n{\n\tconst struct bin_table *table = &bin_root_table[0];\n\tint ctl_name;\n\n\t\n\tmemcpy(path, \"sys/\", 4);\n\tpath += 4;\n\nrepeat:\n\tif (!nlen)\n\t\treturn err_ptr(-enotdir);\n\tctl_name = *name;\n\tname++;\n\tnlen--;\n\tfor ( ; table->", "4373": "< 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\t\n\t\tresult = -eio;\n\t\tnodep = strchr(buf, '.');\n\t\tif (!nodep)\n\t\t\tgoto out;\n\t\t++nodep;\n\n\t\tarea = simple_strtoul(buf, null, 10);\n\t\tnode = simple_strtoul(nodep, null, 10);\n\n\t\tresult = -eio;\n\t\tif ((area >", "4374": "< 0)\n\t\t\tgoto out;\n\n\t\tcopied = result;\n\t\tlastp = oldval + copied - 1;\n\n\t\tresult = -efault;\n\t\tif (get_user(ch, lastp))\n\t\t\tgoto out;\n\n\t\t\n\t\tif (ch == '\\n') {\n\t\t\tresult = -efault;\n\t\t\tif (put_user('\\0', lastp))\n\t\t\t\tgoto out;\n\t\t\tcopied -= 1;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tloff_t pos = 0;\n\n\t\tresult = vfs_write(file, newval, newlen, &pos);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\t}\n\n\tresult = copied;\nout:\n\treturn result;\n}\n\nstatic ssize_t bin_intvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -enomem;\n\tbuffer = kmalloc(bufsz, gfp_kernel);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tresult = kernel_read(file, 0, buffer, bufsz - 1);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -efault;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tstr = buffer;\n\t\tend = str + bufsz;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -efault;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, 0);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}\n\nstatic ssize_t bin_ulongvec(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t copied = 0;\n\tchar *buffer;\n\tssize_t result;\n\n\tresult = -enomem;\n\tbuffer = kmalloc(bufsz, gfp_kernel);\n\tif (!buffer)\n\t\tgoto out;\n\n\tif (oldval && oldlen) {\n\t\tunsigned long __user *vec = oldval;\n\t\tsize_t length = oldlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tresult = kernel_read(file, 0, buffer, bufsz - 1);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\n\t\tstr = buffer;\n\t\tend = str + result;\n\t\t*end++ = '\\0';\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tvalue = simple_strtoul(str, &str, 10);\n\t\t\twhile (isspace(*str))\n\t\t\t\tstr++;\n\t\t\t\n\t\t\tresult = -efault;\n\t\t\tif (put_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tcopied += sizeof(*vec);\n\t\t\tif (!isdigit(*str))\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (newval && newlen) {\n\t\tunsigned long __user *vec = newval;\n\t\tsize_t length = newlen / sizeof(*vec);\n\t\tchar *str, *end;\n\t\tint i;\n\n\t\tstr = buffer;\n\t\tend = str + bufsz;\n\t\tfor (i = 0; i < length; i++) {\n\t\t\tunsigned long value;\n\n\t\t\tresult = -efault;\n\t\t\tif (get_user(value, vec + i))\n\t\t\t\tgoto out_kfree;\n\n\t\t\tstr += scnprintf(str, end - str, \"%lu\\t\", value);\n\t\t}\n\n\t\tresult = kernel_write(file, buffer, str - buffer, 0);\n\t\tif (result < 0)\n\t\t\tgoto out_kfree;\n\t}\n\tresult = copied;\nout_kfree:\n\tkfree(buffer);\nout:\n\treturn result;\n}\n\nstatic ssize_t bin_uuid(struct file *file,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tssize_t result, copied = 0;\n\n\t\n\tif (oldval && oldlen) {\n\t\tchar buf[40], *str = buf;\n\t\tunsigned char uuid[16];\n\t\tint i;\n\n\t\tresult = kernel_read(file, 0, buf, sizeof(buf) - 1);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tbuf[result] = '\\0';\n\n\t\t\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tresult = -eio;\n\t\t\tif (!isxdigit(str[0]) || !isxdigit(str[1]))\n\t\t\t\tgoto out;\n\n\t\t\tuuid[i] = (hex_to_bin(str[0]) << 4) |\n\t\t\t\t\thex_to_bin(str[1]);\n\t\t\tstr += 2;\n\t\t\tif (*str == '-')\n\t\t\t\tstr++;\n\t\t}\n\n\t\tif (oldlen >", "4375": "< 0)\n\t\t\tjps[i]->", "4376": "< 0)\n\t\t\tn = n->", "4377": "< 0)\n\t\t\tnode = &(*node)->", "4378": "< 0)\n\t\t\tp = &parent->", "4379": "< 0)\n\t\t\tp->", "4380": "< 0)\n\t\t\tposix_cpu_timer_schedule(timr);\n\t\telse\n\t\t\tschedule_next_timer(timr);\n\n\t\tinfo->", "4381": "< 0)\n\t\t\tpr_warn(\"could not create directory for event %s\\n\",\n\t\t\t\tftrace_event_name(call));\n\t}\n}\n\nstruct ftrace_event_file *\nfind_event_file(struct trace_array *tr, const char *system,  const char *event)\n{\n\tstruct ftrace_event_file *file;\n\tstruct ftrace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->", "4382": "< 0)\n\t\t\tpr_warn(\"could not create directory for event %s\\n\",\n\t\t\t\tftrace_event_name(file->", "4383": "< 0)\n\t\t\tpr_warn(\"could not create early event %s\\n\",\n\t\t\t\tftrace_event_name(call));\n\t}\n}\n\n\nstatic void\n__trace_remove_event_dirs(struct trace_array *tr)\n{\n\tstruct ftrace_event_file *file, *next;\n\n\tlist_for_each_entry_safe(file, next, &tr->", "4384": "< 0)\n\t\t\treturn -efault;\n\t\tset_task_comm(me, comm);\n\t\tproc_comm_connector(me);\n\t\tbreak;\n\tcase pr_get_name:\n\t\tget_task_comm(comm, me);\n\t\tif (copy_to_user((char __user *)arg2, comm, sizeof(comm)))\n\t\t\treturn -efault;\n\t\tbreak;\n\tcase pr_get_endian:\n\t\terror = get_endian(me, arg2);\n\t\tbreak;\n\tcase pr_set_endian:\n\t\terror = set_endian(me, arg2);\n\t\tbreak;\n\tcase pr_get_seccomp:\n\t\terror = prctl_get_seccomp();\n\t\tbreak;\n\tcase pr_set_seccomp:\n\t\terror = prctl_set_seccomp(arg2, (char __user *)arg3);\n\t\tbreak;\n\tcase pr_get_tsc:\n\t\terror = get_tsc_ctl(arg2);\n\t\tbreak;\n\tcase pr_set_tsc:\n\t\terror = set_tsc_ctl(arg2);\n\t\tbreak;\n\tcase pr_task_perf_events_disable:\n\t\terror = perf_event_task_disable();\n\t\tbreak;\n\tcase pr_task_perf_events_enable:\n\t\terror = perf_event_task_enable();\n\t\tbreak;\n\tcase pr_get_timerslack:\n\t\terror = current->", "4385": "< 0)\n\t\t\treturn err;\n\t\tif (err == 1) {\n\t\t\t\n\t\t\tif (log_level) {\n\t\t\t\tif (do_print_state)\n\t\t\t\t\tverbose(\"\\nfrom %d to %d: safe\\n\",\n\t\t\t\t\t\tprev_insn_idx, insn_idx);\n\t\t\t\telse\n\t\t\t\t\tverbose(\"%d: safe\\n\", insn_idx);\n\t\t\t}\n\t\t\tgoto process_bpf_exit;\n\t\t}\n\n\t\tif (log_level && do_print_state) {\n\t\t\tverbose(\"\\nfrom %d to %d:\", prev_insn_idx, insn_idx);\n\t\t\tprint_verifier_state(env);\n\t\t\tdo_print_state = false;\n\t\t}\n\n\t\tif (log_level) {\n\t\t\tverbose(\"%d: \", insn_idx);\n\t\t\tprint_bpf_insn(insn);\n\t\t}\n\n\t\tif (class == bpf_alu || class == bpf_alu64) {\n\t\t\terr = check_alu_op(regs, insn);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\n\t\t} else if (class == bpf_ldx) {\n\t\t\tenum bpf_reg_type src_reg_type;\n\n\t\t\t\n\n\t\t\t\n\t\t\terr = check_reg_arg(regs, insn->", "4386": "< 0)\n\t\t\treturn ret;\n\t\toff += ret;\n\t}\n\tbuffer[off] = '\\0';\n\treturn off;\n}\n\nstatic void param_array_free(void *arg)\n{\n\tunsigned int i;\n\tconst struct kparam_array *arr = arg;\n\n\tif (arr->", "4387": "< 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &probes_seq_op);\n}\n\nstatic ssize_t probes_write(struct file *file, const char __user *buffer,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn traceprobe_probes_write(file, buffer, count, ppos,\n\t\t\tcreate_trace_kprobe);\n}\n\nstatic const struct file_operations kprobe_events_ops = {\n\t.owner          = this_module,\n\t.open           = probes_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n\t.write\t\t= probes_write,\n};\n\n\nstatic int probes_profile_seq_show(struct seq_file *m, void *v)\n{\n\tstruct trace_kprobe *tk = v;\n\n\tseq_printf(m, \"  %-44s %15lu %15lu\\n\",\n\t\t   ftrace_event_name(&tk->", "4388": "< 0)\n\t\t\treturn ret;\n\n\t\ttr->", "4389": "< 0)\n\t\t\treturn retval;\n\n\t\tif (!cpumask_subset(trialcs->", "4390": "< 0)\n\t\t\trps[i]->", "4391": "< 0)\n\t\t\tsig->", "4392": "< 0)\n\t\t\tstate = pm_suspend_freeze;\n\t}\n\tif (state == pm_suspend_freeze) {\n\t\tprintk(info_test, pm_states[state]);\n\t\tstatus = pm_suspend(state);\n\t}\n\n\tif (status < 0)\n\t\tprintk(err_suspend, status);\n\n\ttest_repeat_count_current++;\n\tif (test_repeat_count_current < test_repeat_count_max)\n\t\tgoto repeat;\n\n\t\n\talm.enabled = false;\n\trtc_set_alarm(rtc, &alm);\n}\n\nstatic int __init has_wakealarm(struct device *dev, const void *data)\n{\n\tstruct rtc_device *candidate = to_rtc_device(dev);\n\n\tif (!candidate->", "4393": "< 0)\n\t\t\ttk->", "4394": "< 0)\n\t\t\tuprobe_buffer_refcnt--;\n\t}\n\n\treturn ret;\n}\n\nstatic void uprobe_buffer_disable(void)\n{\n\tint cpu;\n\n\tbug_on(!mutex_is_locked(&event_mutex));\n\n\tif (--uprobe_buffer_refcnt == 0) {\n\t\tfor_each_possible_cpu(cpu)\n\t\t\tfree_page((unsigned long)per_cpu_ptr(uprobe_cpu_buffer,\n\t\t\t\t\t\t\t     cpu)->", "4395": "< 0)\n\t\t\n\t\tgoto free_map;\n\n\treturn err;\n\nfree_map:\n\tmap->", "4396": "< 0)\n\t\t*jitter = -*jitter;\n\n\t\n\treturn pps_tf[0];\n}\n\n\nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}\n\n\nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -pps_intcount) {\n\t\tpps_intcnt = -pps_intcount;\n\t\tif (pps_shift >", "4397": "< 0)\n\t\tbug();\n\tnh->", "4398": "< 0)\n\t\tbug();\n\tsched_init_granularity();\n\tfree_cpumask_var(non_isolated_cpus);\n\n\tinit_sched_rt_class();\n\tinit_sched_dl_class();\n}\n#else\nvoid __init sched_init_smp(void)\n{\n\tsched_init_granularity();\n}\n#endif \n\nconst_debug unsigned int sysctl_timer_migration = 1;\n\nint in_sched_functions(unsigned long addr)\n{\n\treturn in_lock_functions(addr) ||\n\t\t(addr >", "4399": "< 0)\n\t\td = -d;\n\n\tif (d >", "4400": "< 0)\n\t\tgoto bad_fork_free;\n\n\t\n\tretval = -eagain;\n\tif (nr_threads >", "4401": "< 0)\n\t\tgoto bug_cleanup;\n\n\t\n\tfree_copy(info);\n\n\t\n\ttrace_module_load(mod);\n\n\treturn do_init_module(mod);\n\n bug_cleanup:\n\t\n\tmutex_lock(&module_mutex);\n\tmodule_bug_cleanup(mod);\n\tmutex_unlock(&module_mutex);\n\n\t\n\tunset_module_init_ro_nx(mod);\n\tunset_module_core_ro_nx(mod);\n\n ddebug_cleanup:\n\tdynamic_debug_remove(info->", "4402": "< 0)\n\t\tgoto done;\n\n\tspin_lock_irq(&callback_lock);\n\tcs->", "4403": "< 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, taskstats_cmd_new, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -einval;\n\ttgid = nla_get_u32(info->", "4404": "< 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}\n\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->", "4405": "< 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, cgroupstats_type_cgroup_stats,\n\t\t\t\tsizeof(struct cgroupstats));\n\tif (na == null) {\n\t\tnlmsg_free(rep_skb);\n\t\trc = -emsgsize;\n\t\tgoto err;\n\t}\n\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, f.file->", "4406": "< 0)\n\t\tgoto err_free_percpu_ref;\n\tcss->", "4407": "< 0)\n\t\tgoto err_free_squeue;\n\n\tpadata_init_pqueues(pd);\n\tpadata_init_squeues(pd);\n\tsetup_timer(&pd->", "4408": "< 0)\n\t\tgoto err_free_wq;\n\n\t\n\tif (flags & wq_mem_reclaim) {\n\t\tstruct worker *rescuer;\n\n\t\trescuer = alloc_worker(numa_no_node);\n\t\tif (!rescuer)\n\t\t\tgoto err_destroy;\n\n\t\trescuer->", "4409": "< 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn null;\n}\nexport_symbol(prepare_creds);\n\n\nstruct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef config_keys\n\t\n\tkey_put(new->", "4410": "< 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn null;\n}\nexport_symbol(prepare_kernel_cred);\n\n\nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}\nexport_symbol(set_security_override);\n\n\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}\nexport_symbol(set_security_override_from_ctx);\n\n\nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tnew->", "4411": "< 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n\n\nsyscall_define3(setresuid, uid_t, ruid, uid_t, euid, uid_t, suid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kruid, keuid, ksuid;\n\n\tkruid = make_kuid(ns, ruid);\n\tkeuid = make_kuid(ns, euid);\n\tksuid = make_kuid(ns, suid);\n\n\tif ((ruid != (uid_t) -1) && !uid_valid(kruid))\n\t\treturn -einval;\n\n\tif ((euid != (uid_t) -1) && !uid_valid(keuid))\n\t\treturn -einval;\n\n\tif ((suid != (uid_t) -1) && !uid_valid(ksuid))\n\t\treturn -einval;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\n\told = current_cred();\n\n\tretval = -eperm;\n\tif (!ns_capable(old->", "4412": "< 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\n\nsyscall_define1(setuid, uid_t, uid)\n{\n\tstruct user_namespace *ns = current_user_ns();\n\tconst struct cred *old;\n\tstruct cred *new;\n\tint retval;\n\tkuid_t kuid;\n\n\tkuid = make_kuid(ns, uid);\n\tif (!uid_valid(kuid))\n\t\treturn -einval;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\told = current_cred();\n\n\tretval = -eperm;\n\tif (ns_capable(old->", "4413": "< 0)\n\t\tgoto error;\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn retval;\n}\n\nsyscall_define3(getresuid, uid_t __user *, ruidp, uid_t __user *, euidp, uid_t __user *, suidp)\n{\n\tconst struct cred *cred = current_cred();\n\tint retval;\n\tuid_t ruid, euid, suid;\n\n\truid = from_kuid_munged(cred->", "4414": "< 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn null;\n}\n\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, gfp_kernel);\n\tif (!new)\n\t\treturn null;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->", "4415": "< 0)\n\t\tgoto error_free_pks;\n\n\tret = verify_signature(key, pks);\n\tpr_devel(\"verify_signature() = %d\\n\", ret);\n\nerror_free_pks:\n\tmpi_free(pks->", "4416": "< 0)\n\t\tgoto errout;\n\n\tif (event->", "4417": "< 0)\n\t\tgoto fail;\n\n\t\n\tif (!create_worker(pool))\n\t\tgoto fail;\n\n\t\n\thash_add(unbound_pool_hash, &pool->", "4418": "< 0)\n\t\tgoto fail;\n\n\tlockdep_set_subclass(&pool->", "4419": "< 0)\n\t\tgoto fail;\n\n\tworker = alloc_worker(pool->", "4420": "< 0)\n\t\tgoto fail_free_reader;\n\n\tcpu_buffer->", "4421": "< 0)\n\t\tgoto free_modinfo;\n\n\terr = apply_relocations(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\terr = post_relocation(mod, info);\n\tif (err < 0)\n\t\tgoto free_modinfo;\n\n\tflush_module_icache(mod);\n\n\t\n\tmod->", "4422": "< 0)\n\t\tgoto free_prog;\n\n\t\n\terr = bpf_check(&prog, attr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\t\n\tfixup_bpf_calls(prog);\n\n\t\n\tbpf_prog_select_runtime(prog);\n\n\terr = anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog, o_rdwr | o_cloexec);\n\tif (err < 0)\n\t\t\n\t\tgoto free_used_maps;\n\n\treturn err;\n\nfree_used_maps:\n\tfree_used_maps(prog->", "4423": "< 0)\n\t\tgoto out;\n\trc = add_del_listener(info->", "4424": "< 0)\n\t\tgoto out;\n\troot_cgrp->", "4425": "< 0)\n\t\tgoto out;\n\n\t\n\tmodule_bug_finalize(info->", "4426": "< 0)\n\t\tgoto out;\n\n\t*ppos += cnt;\n\tret = cnt;\n out:\n\treturn ret;\n}\n\nstatic int event_trigger_regex_release(struct inode *inode, struct file *file)\n{\n\tmutex_lock(&event_mutex);\n\n\tif (file->", "4427": "< 0)\n\t\tgoto out;\n\n\tbalance_flag_changed = (is_sched_load_balance(cs) !=\n\t\t\t\tis_sched_load_balance(trialcs));\n\n\tspread_flag_changed = ((is_spread_slab(cs) != is_spread_slab(trialcs))\n\t\t\t|| (is_spread_page(cs) != is_spread_page(trialcs)));\n\n\tspin_lock_irq(&callback_lock);\n\tcs->", "4428": "< 0)\n\t\tgoto out;\n\n\tcpu = smp_processor_id();\n\tdata = per_cpu_ptr(tr->", "4429": "< 0)\n\t\tgoto out;\n\n\ttype->", "4430": "< 0)\n\t\tgoto out;\n\n\twhile (mbytes) {\n\t\tstruct page *page;\n\t\tchar *ptr;\n\t\tsize_t uchunk, mchunk;\n\n\t\tpage = kimage_alloc_page(image, gfp_highuser, maddr);\n\t\tif (!page) {\n\t\t\tresult  = -enomem;\n\t\t\tgoto out;\n\t\t}\n\t\tresult = kimage_add_page(image, page_to_pfn(page)\n\t\t\t\t\t\t\t\t<< page_shift);\n\t\tif (result < 0)\n\t\t\tgoto out;\n\n\t\tptr = kmap(page);\n\t\t\n\t\tclear_page(ptr);\n\t\tptr += maddr & ~page_mask;\n\t\tmchunk = min_t(size_t, mbytes,\n\t\t\t\tpage_size - (maddr & ~page_mask));\n\t\tuchunk = min(ubytes, mchunk);\n\n\t\t\n\t\tif (image->", "4431": "< 0)\n\t\tgoto out_disable;\n\t\n\tret = 0;\n out:\n\treturn ret;\n\n out_disable:\n\ttrace_event_enable_disable(event_enable_file, 0, 1);\n out_put:\n\tmodule_put(event_enable_file->", "4432": "< 0)\n\t\tgoto out_free;\n\tret = 0;\n out:\n\treturn ret;\n\n out_free:\n\tif (cmd_ops->", "4433": "< 0)\n\t\tgoto out_free;\n\n out_reg:\n\t\n\tret = try_module_get(event_enable_file->", "4434": "< 0)\n\t\tgoto out_free;\n\n out_reg:\n\tret = cmd_ops->", "4435": "< 0)\n\t\tgoto out_free_sha_regions;\n\n\tdigest = kzalloc(sha256_digest_size, gfp_kernel);\n\tif (!digest) {\n\t\tret = -enomem;\n\t\tgoto out_free_sha_regions;\n\t}\n\n\tfor (j = i = 0; i < image->", "4436": "< 0)\n\t\tgoto out_put;\n\tret = cmd_ops->", "4437": "< 0)\n\t\tgoto out_put;\n\tret = register_ftrace_function_probe(glob, ops, data);\n\t\n\tif (!ret) {\n\t\tret = -enoent;\n\t\tgoto out_disable;\n\t} else if (ret < 0)\n\t\tgoto out_disable;\n\t\n\tret = 0;\n out:\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n\n out_disable:\n\t__ftrace_event_enable_disable(file, 0, 1);\n out_put:\n\tmodule_put(file->", "4438": "< 0)\n\t\tgoto out_put_task_struct;\n\n\tret = arch_ptrace(child, request, addr, data);\n\tif (ret || request != ptrace_detach)\n\t\tptrace_unfreeze_traced(child);\n\n out_put_task_struct:\n\tput_task_struct(child);\n out:\n\treturn ret;\n}\n\nint generic_ptrace_peekdata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tunsigned long tmp;\n\tint copied;\n\n\tcopied = access_process_vm(tsk, addr, &tmp, sizeof(tmp), 0);\n\tif (copied != sizeof(tmp))\n\t\treturn -eio;\n\treturn put_user(tmp, (unsigned long __user *)data);\n}\n\nint generic_ptrace_pokedata(struct task_struct *tsk, unsigned long addr,\n\t\t\t    unsigned long data)\n{\n\tint copied;\n\n\tcopied = access_process_vm(tsk, addr, &data, sizeof(data), 1);\n\treturn (copied == sizeof(data)) ? 0 : -eio;\n}\n\n#if defined config_compat\n\nint compat_ptrace_request(struct task_struct *child, compat_long_t request,\n\t\t\t  compat_ulong_t addr, compat_ulong_t data)\n{\n\tcompat_ulong_t __user *datap = compat_ptr(data);\n\tcompat_ulong_t word;\n\tsiginfo_t siginfo;\n\tint ret;\n\n\tswitch (request) {\n\tcase ptrace_peektext:\n\tcase ptrace_peekdata:\n\t\tret = access_process_vm(child, addr, &word, sizeof(word), 0);\n\t\tif (ret != sizeof(word))\n\t\t\tret = -eio;\n\t\telse\n\t\t\tret = put_user(word, datap);\n\t\tbreak;\n\n\tcase ptrace_poketext:\n\tcase ptrace_pokedata:\n\t\tret = access_process_vm(child, addr, &data, sizeof(data), 1);\n\t\tret = (ret != sizeof(data) ? -eio : 0);\n\t\tbreak;\n\n\tcase ptrace_geteventmsg:\n\t\tret = put_user((compat_ulong_t) child->", "4439": "< 0)\n\t\tgoto skip_full_check;\n\n\tenv->", "4440": "< 0)\n\t\tgoto skip_full_check;\n\n\tret = do_check(env);\n\nskip_full_check:\n\twhile (pop_stack(env, null) >", "4441": "< 0)\n\t\tgoto use_default;\n\n\t\n\tif (current_clr_polling_and_test()) {\n\t\tdev->", "4442": "< 0)\n\t\tindex += ftrace_notrace_depth;\n\n\tif (unlikely(index < 0 || index >", "4443": "< 0)\n\t\tmin_vruntime = vruntime;\n\n\treturn min_vruntime;\n}\n\nstatic inline int entity_before(struct sched_entity *a,\n\t\t\t\tstruct sched_entity *b)\n{\n\treturn (s64)(a->", "4444": "< 0)\n\t\tnow = trace_clock_struct.prev_time + 1;\n\n\ttrace_clock_struct.prev_time = now;\n\n\tarch_spin_unlock(&trace_clock_struct.lock);\n\n out:\n\tlocal_irq_restore(flags);\n\n\treturn now;\n}\n\nstatic atomic64_t trace_counter;\n\n\nu64 notrace trace_clock_counter(void)\n{\n\treturn atomic64_add_return(1, &trace_counter);\n}\n\n#include <linux/kernel.h>", "4445": "< 0)\n\t\tquota = runtime_inf;\n\telse\n\t\tquota = (u64)cfs_quota_us * nsec_per_usec;\n\n\treturn tg_set_cfs_bandwidth(tg, period, quota);\n}\n\nlong tg_get_cfs_quota(struct task_group *tg)\n{\n\tu64 quota_us;\n\n\tif (tg->", "4446": "< 0)\n\t\trcu_unexpedite_gp();\n\twarn_on_once(can_expedite && rcu_gp_is_expedited());\n\trcu_torture_writer_state = rtws_stopping;\n\ttorture_kthread_stopping(\"rcu_torture_writer\");\n\treturn 0;\n}\n\n\nstatic int\nrcu_torture_fakewriter(void *arg)\n{\n\tdefine_torture_random(rand);\n\n\tverbose_torout_string(\"rcu_torture_fakewriter task started\");\n\tset_user_nice(current, max_nice);\n\n\tdo {\n\t\tschedule_timeout_uninterruptible(1 + torture_random(&rand)%10);\n\t\tudelay(torture_random(&rand) & 0x3ff);\n\t\tif (cur_ops->", "4447": "< 0)\n\t\treturn (id & clockfd_mask) == clockfd ?\n\t\t\t&clock_posix_dynamic : &clock_posix_cpu;\n\n\tif (id >", "4448": "< 0)\n\t\treturn -1;  \n\n\treturn 0;\n}\n#endif \n\nlong prctl_get_seccomp(void)\n{\n\treturn current->", "4449": "< 0)\n\t\treturn -efault;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->", "4450": "< 0)\n\t\treturn -efault;\n\tname[module_name_len-1] = '\\0';\n\n\tif (mutex_lock_interruptible(&module_mutex) != 0)\n\t\treturn -eintr;\n\n\tmod = find_module(name);\n\tif (!mod) {\n\t\tret = -enoent;\n\t\tgoto out;\n\t}\n\n\tif (!list_empty(&mod->", "4451": "< 0)\n\t\treturn -einval;\n\tdown_read(&uts_sem);\n\tu = utsname();\n\ti = 1 + strlen(u->", "4452": "< 0)\n\t\treturn -einval;\n\tif (copy_from_user(&lparam, param, sizeof(struct sched_param)))\n\t\treturn -efault;\n\n\trcu_read_lock();\n\tretval = -esrch;\n\tp = find_process_by_pid(pid);\n\tif (p != null)\n\t\tretval = sched_setscheduler(p, policy, &lparam);\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n\nstatic int sched_copy_attr(struct sched_attr __user *uattr,\n\t\t\t   struct sched_attr *attr)\n{\n\tu32 size;\n\tint ret;\n\n\tif (!access_ok(verify_write, uattr, sched_attr_size_ver0))\n\t\treturn -efault;\n\n\t\n\tmemset(attr, 0, sizeof(*attr));\n\n\tret = get_user(size, &uattr->", "4453": "< 0)\n\t\treturn -einval;\n\trcu_read_lock();\n\n\t\n\twrite_lock_irq(&tasklist_lock);\n\n\terr = -esrch;\n\tp = find_task_by_vpid(pid);\n\tif (!p)\n\t\tgoto out;\n\n\terr = -einval;\n\tif (!thread_group_leader(p))\n\t\tgoto out;\n\n\tif (same_thread_group(p->", "4454": "< 0)\n\t\treturn -einval;\n\n\tcgrp = cgroup_kn_lock_live(of->", "4455": "< 0)\n\t\treturn -einval;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\ttask_uninterruptible);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}\nexport_symbol_gpl(usermodehelper_read_lock_wait);\n\nvoid usermodehelper_read_unlock(void)\n{\n\tup_read(&umhelper_sem);\n}\nexport_symbol_gpl(usermodehelper_read_unlock);\n\n\nvoid __usermodehelper_set_disable_depth(enum umh_disable_depth depth)\n{\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\twake_up(&usermodehelper_disabled_waitq);\n\tup_write(&umhelper_sem);\n}\n\n\nint __usermodehelper_disable(enum umh_disable_depth depth)\n{\n\tlong retval;\n\n\tif (!depth)\n\t\treturn -einval;\n\n\tdown_write(&umhelper_sem);\n\tusermodehelper_disabled = depth;\n\tup_write(&umhelper_sem);\n\n\t\n\tretval = wait_event_timeout(running_helpers_waitq,\n\t\t\t\t\tatomic_read(&running_helpers) == 0,\n\t\t\t\t\trunning_helpers_timeout);\n\tif (retval)\n\t\treturn 0;\n\n\t__usermodehelper_set_disable_depth(umh_enabled);\n\treturn -eagain;\n}\n\nstatic void helper_lock(void)\n{\n\tatomic_inc(&running_helpers);\n\tsmp_mb__after_atomic();\n}\n\nstatic void helper_unlock(void)\n{\n\tif (atomic_dec_and_test(&running_helpers))\n\t\twake_up(&running_helpers_waitq);\n}\n\n\nstruct subprocess_info *call_usermodehelper_setup(char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tinit_work(&sub_info->", "4456": "< 0)\n\t\treturn -einval;\n\n\ti = cred->", "4457": "< 0)\n\t\treturn -einval;\n\n\tif (arg.flags & ptrace_peeksiginfo_shared)\n\t\tpending = &child->", "4458": "< 0)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -esrch;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tif (task_has_rt_policy(p))\n\t\tlp.sched_priority = p->", "4459": "< 0)\n\t\treturn -einval;\n\n\tret = cap_get_target_pid(pid, &pe, &pi, &pp);\n\tif (!ret) {\n\t\tstruct __user_cap_data_struct kdata[_kernel_capability_u32s];\n\t\tunsigned i;\n\n\t\tfor (i = 0; i < tocopy; i++) {\n\t\t\tkdata[i].effective = pe.cap[i];\n\t\t\tkdata[i].permitted = pp.cap[i];\n\t\t\tkdata[i].inheritable = pi.cap[i];\n\t\t}\n\n\t\t\n\t\tif (copy_to_user(dataptr, kdata, tocopy\n\t\t\t\t * sizeof(struct __user_cap_data_struct))) {\n\t\t\treturn -efault;\n\t\t}\n\t}\n\n\treturn ret;\n}\n\n\nsyscall_define2(capset, cap_user_header_t, header, const cap_user_data_t, data)\n{\n\tstruct __user_cap_data_struct kdata[_kernel_capability_u32s];\n\tunsigned i, tocopy, copybytes;\n\tkernel_cap_t inheritable, permitted, effective;\n\tstruct cred *new;\n\tint ret;\n\tpid_t pid;\n\n\tret = cap_validate_magic(header, &tocopy);\n\tif (ret != 0)\n\t\treturn ret;\n\n\tif (get_user(pid, &header->", "4460": "< 0)\n\t\treturn -einval;\n\n\treturn do_sched_setscheduler(pid, policy, param);\n}\n\n\nsyscall_define2(sched_setparam, pid_t, pid, struct sched_param __user *, param)\n{\n\treturn do_sched_setscheduler(pid, setparam_policy, param);\n}\n\n\nsyscall_define3(sched_setattr, pid_t, pid, struct sched_attr __user *, uattr,\n\t\t\t       unsigned int, flags)\n{\n\tstruct sched_attr attr;\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (!uattr || pid < 0 || flags)\n\t\treturn -einval;\n\n\tretval = sched_copy_attr(uattr, &attr);\n\tif (retval)\n\t\treturn retval;\n\n\tif ((int)attr.sched_policy < 0)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tretval = -esrch;\n\tp = find_process_by_pid(pid);\n\tif (p != null)\n\t\tretval = sched_setattr(p, &attr);\n\trcu_read_unlock();\n\n\treturn retval;\n}\n\n\nsyscall_define1(sched_getscheduler, pid_t, pid)\n{\n\tstruct task_struct *p;\n\tint retval;\n\n\tif (pid < 0)\n\t\treturn -einval;\n\n\tretval = -esrch;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (p) {\n\t\tretval = security_task_getscheduler(p);\n\t\tif (!retval)\n\t\t\tretval = p->", "4461": "< 0)\n\t\treturn -einval;\n\n\tretval = -esrch;\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\trq = task_rq_lock(p, &flags);\n\ttime_slice = 0;\n\tif (p->", "4462": "< 0)\n\t\treturn -enodev;\n\n\t\n\tdir = kzalloc(sizeof(*dir), gfp_kernel);\n\tif (!dir) {\n\t\ttrace_array_put(tr);\n\t\treturn -enomem;\n\t}\n\n\tdir->", "4463": "< 0)\n\t\treturn -enodev;\n\n\tif ((file->", "4464": "< 0)\n\t\treturn -enomem;\n\tret = register_ftrace_event(&call->", "4465": "< 0)\n\t\treturn -enomem;\n\n\tid = trace_event_raw_init(call);\n\n\tif (id < 0) {\n\t\tfree_syscall_print_fmt(call);\n\t\treturn id;\n\t}\n\n\treturn id;\n}\n\nstruct trace_event_functions enter_syscall_print_funcs = {\n\t.trace\t\t= print_syscall_enter,\n};\n\nstruct trace_event_functions exit_syscall_print_funcs = {\n\t.trace\t\t= print_syscall_exit,\n};\n\nstruct ftrace_event_class __refdata event_class_syscall_enter = {\n\t.system\t\t= \"syscalls\",\n\t.reg\t\t= syscall_enter_register,\n\t.define_fields\t= syscall_enter_define_fields,\n\t.get_fields\t= syscall_get_enter_fields,\n\t.raw_init\t= init_syscall_trace,\n};\n\nstruct ftrace_event_class __refdata event_class_syscall_exit = {\n\t.system\t\t= \"syscalls\",\n\t.reg\t\t= syscall_exit_register,\n\t.define_fields\t= syscall_exit_define_fields,\n\t.fields\t\t= list_head_init(event_class_syscall_exit.fields),\n\t.raw_init\t= init_syscall_trace,\n};\n\nunsigned long __init __weak arch_syscall_addr(int nr)\n{\n\treturn (unsigned long)sys_call_table[nr];\n}\n\nvoid __init init_ftrace_syscalls(void)\n{\n\tstruct syscall_metadata *meta;\n\tunsigned long addr;\n\tint i;\n\n\tsyscalls_metadata = kcalloc(nr_syscalls, sizeof(*syscalls_metadata),\n\t\t\t\t    gfp_kernel);\n\tif (!syscalls_metadata) {\n\t\twarn_on(1);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < nr_syscalls; i++) {\n\t\taddr = arch_syscall_addr(i);\n\t\tmeta = find_syscall_meta(addr);\n\t\tif (!meta)\n\t\t\tcontinue;\n\n\t\tmeta->", "4466": "< 0)\n\t\treturn -enomem;\n\n\tret = register_ftrace_event(&call->", "4467": "< 0)\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic unsigned long get_ksymbol_core(struct kallsym_iter *iter)\n{\n\tunsigned off = iter->", "4468": "< 0)\n\t\treturn 0;\n\ttracing_thresh = threshold * 1000;\n\treturn 1;\n}\n__setup(\"tracing_thresh=\", set_tracing_thresh);\n\nunsigned long nsecs_to_usecs(unsigned long nsecs)\n{\n\treturn nsecs / 1000;\n}\n\n\nstatic const char *trace_options[] = {\n\t\"print-parent\",\n\t\"sym-offset\",\n\t\"sym-addr\",\n\t\"verbose\",\n\t\"raw\",\n\t\"hex\",\n\t\"bin\",\n\t\"block\",\n\t\"stacktrace\",\n\t\"trace_printk\",\n\t\"ftrace_preempt\",\n\t\"branch\",\n\t\"annotate\",\n\t\"userstacktrace\",\n\t\"sym-userobj\",\n\t\"printk-msg-only\",\n\t\"context-info\",\n\t\"latency-format\",\n\t\"sleep-time\",\n\t\"graph-time\",\n\t\"record-cmd\",\n\t\"overwrite\",\n\t\"disable_on_free\",\n\t\"irq-info\",\n\t\"markers\",\n\t\"function-trace\",\n\tnull\n};\n\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\tarch_trace_clocks\n};\n\n\nint trace_parser_get_init(struct trace_parser *parser, int size)\n{\n\tmemset(parser, 0, sizeof(*parser));\n\n\tparser->", "4469": "< 0)\n\t\treturn 0;\n\n\tfor (i = irq; cnt >", "4470": "< 0)\n\t\treturn 0;\n\n\tif (unlikely(delta.tv64 >", "4471": "< 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (kdb_flag(cmd_interrupt))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}\n#endif \n\n\nstatic atomic_t kdb_nmi_disabled;\n\nstatic int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}\n\nstatic int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -einval;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops kdb_param_ops_enable_nmi = {\n\t.set = kdb_param_enable_nmi,\n};\nmodule_param_cb(enable_nmi, &kdb_param_ops_enable_nmi, null, 0600);\n\n\nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < nr_cpus; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'f';\t\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'd';\t\n\t\t} else {\n\t\t\tstate = ' ';\t\n\t\t\tif (kdb_task_state_char(kdb_tsk(i)) == 'i')\n\t\t\t\tstate = 'i';\t\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t\n\tif (prev_state != 'f') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}\n\nstatic int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn kdb_argcount;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t\n\tif ((cpunum >", "4472": "< 0)\n\t\treturn __copy_to_user(to, from, sizeof(siginfo_t))\n\t\t\t? -efault : 0;\n\t\n\terr = __put_user(from->", "4473": "< 0)\n\t\treturn err;\n\tif (write)\n\t\tset_numabalancing_state(state);\n\treturn err;\n}\n#endif\n#endif\n\n\nint sched_fork(unsigned long clone_flags, struct task_struct *p)\n{\n\tunsigned long flags;\n\tint cpu = get_cpu();\n\n\t__sched_fork(clone_flags, p);\n\t\n\tp->", "4474": "< 0)\n\t\treturn err;\n\n\t\n\tfor (i = 0; i < _kernel_capability_u32s; i++)\n\t\tnew_cap.cap[i] = cap_array[i];\n\n\t\n\tspin_lock(&umh_sysctl_lock);\n\tif (write) {\n\t\tif (table->", "4475": "< 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic list_head(event_subsystems);\n\nstatic int subsystem_open(struct inode *inode, struct file *filp)\n{\n\tstruct event_subsystem *system = null;\n\tstruct ftrace_subsystem_dir *dir = null; \n\tstruct trace_array *tr;\n\tint ret;\n\n\tif (tracing_is_disabled())\n\t\treturn -enodev;\n\n\t\n\tmutex_lock(&trace_types_lock);\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tlist_for_each_entry(dir, &tr->", "4476": "< 0)\n\t\treturn err;\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\nshow_header(struct file *filp, char __user *ubuf, size_t cnt, loff_t *ppos)\n{\n\tint (*func)(struct trace_seq *s) = filp->", "4477": "< 0)\n\t\treturn err;\n\n\tcpu_notify(cpu_dying | param->", "4478": "< 0)\n\t\treturn err;\n\n\tif (!alloc_cpumask_var(&cpus_attach, gfp_kernel))\n\t\tbug();\n\n\treturn 0;\n}\n\n\nstatic void remove_tasks_in_empty_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *parent;\n\n\t\n\tparent = parent_cs(cs);\n\twhile (cpumask_empty(parent->", "4479": "< 0)\n\t\treturn err;\n\n\tif (write) {\n\t\t\n\t\tint i;\n\t\tfor (i = 0; i < bits_per_long && tmptaint >", "4480": "< 0)\n\t\treturn err_ptr(err);\n\n\t\n\tinfo->", "4481": "< 0)\n\t\treturn id;\n\n\troot->", "4482": "< 0)\n\t\treturn null;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[*rctxp]);\n\traw_data = this_cpu_ptr(perf_trace_buf[*rctxp]);\n\n\t\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\n\tentry = (struct trace_entry *)raw_data;\n\tlocal_save_flags(flags);\n\ttracing_generic_entry_update(entry, flags, pc);\n\tentry->", "4483": "< 0)\n\t\treturn null;\n\n\treturn syscalls_metadata[nr];\n}\n\nstatic enum print_line_t\nprint_syscall_enter(struct trace_iterator *iter, int flags,\n\t\t    struct trace_event *event)\n{\n\tstruct trace_seq *s = &iter->", "4484": "< 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 1, irqclass);\n}\n\n\nstatic int\ncheck_usage_backwards(struct task_struct *curr, struct held_lock *this,\n\t\t      enum lock_usage_bit bit, const char *irqclass)\n{\n\tint ret;\n\tstruct lock_list root;\n\tstruct lock_list *uninitialized_var(target_entry);\n\n\troot.parent = null;\n\troot.class = hlock_class(this);\n\tret = find_usage_backwards(&root, bit, &target_entry);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_irq_inversion_bug(curr, &root, target_entry,\n\t\t\t\t\tthis, 0, irqclass);\n}\n\nvoid print_irqtrace_events(struct task_struct *curr)\n{\n\tprintk(\"irq event stamp: %u\\n\", curr->", "4485": "< 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\tthat.parent = null;\n\tthat.class = hlock_class(next);\n\tret = find_usage_forwards(&that, bit_forwards, &target_entry1);\n\tif (ret < 0)\n\t\treturn print_bfs_bug(ret);\n\tif (ret == 1)\n\t\treturn ret;\n\n\treturn print_bad_irq_dependency(curr, &this, &that,\n\t\t\ttarget_entry, target_entry1,\n\t\t\tprev, next,\n\t\t\tbit_backwards, bit_forwards, irqclass);\n}\n\nstatic const char *state_names[] = {\n#define lockdep_state(__state) \\\n\t__stringify(__state),\n#include \"lockdep_states.h\"\n#undef lockdep_state\n};\n\nstatic const char *state_rnames[] = {\n#define lockdep_state(__state) \\\n\t__stringify(__state)\"-read\",\n#include \"lockdep_states.h\"\n#undef lockdep_state\n};\n\nstatic inline const char *state_name(enum lock_usage_bit bit)\n{\n\treturn (bit & 1) ? state_rnames[bit >", "4486": "< 0)\n\t\treturn rc;\n\n\trc = -einval;\n\tpid = nla_get_u32(info->", "4487": "< 0)\n\t\treturn res;\n\n\troot_swap = res;\n\tres = blkdev_get(hib_resume_bdev, fmode_write, null);\n\tif (res)\n\t\treturn res;\n\n\tres = set_blocksize(hib_resume_bdev, page_size);\n\tif (res < 0)\n\t\tblkdev_put(hib_resume_bdev, fmode_write);\n\n\treturn res;\n}\n\n\n\nstatic int write_page(void *buf, sector_t offset, struct bio **bio_chain)\n{\n\tvoid *src;\n\tint ret;\n\n\tif (!offset)\n\t\treturn -enospc;\n\n\tif (bio_chain) {\n\t\tsrc = (void *)__get_free_page(__gfp_wait | __gfp_nowarn |\n\t\t                              __gfp_noretry);\n\t\tif (src) {\n\t\t\tcopy_page(src, buf);\n\t\t} else {\n\t\t\tret = hib_wait_on_bio_chain(bio_chain); \n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tsrc = (void *)__get_free_page(__gfp_wait |\n\t\t\t                              __gfp_nowarn |\n\t\t\t                              __gfp_noretry);\n\t\t\tif (src) {\n\t\t\t\tcopy_page(src, buf);\n\t\t\t} else {\n\t\t\t\twarn_on_once(1);\n\t\t\t\tbio_chain = null;\t\n\t\t\t\tsrc = buf;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tsrc = buf;\n\t}\n\treturn hib_bio_write_page(offset, src, bio_chain);\n}\n\nstatic void release_swap_writer(struct swap_map_handle *handle)\n{\n\tif (handle->", "4488": "< 0)\n\t\treturn result;\n\n\tcopy_from_page(page, vaddr, &opcode, uprobe_swbp_insn_size);\n\tput_page(page);\n out:\n\t\n\treturn is_trap_insn(&opcode);\n}\n\nstatic struct uprobe *find_active_uprobe(unsigned long bp_vaddr, int *is_swbp)\n{\n\tstruct mm_struct *mm = current->", "4489": "< 0)\n\t\treturn ret;\n\tm = file->", "4490": "< 0)\n\t\treturn ret;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tret = ops->", "4491": "< 0)\n\t\treturn ret;\n\n\tif (ftrace_enabled)\n\t\tupdate_ftrace_function();\n\n\treturn 0;\n}\n\nstatic void ftrace_update_pid_func(void)\n{\n\t\n\tif (ftrace_trace_function == ftrace_stub)\n\t\treturn;\n\n\tupdate_ftrace_function();\n}\n\n#ifdef config_function_profiler\nstruct ftrace_profile {\n\tstruct hlist_node\t\tnode;\n\tunsigned long\t\t\tip;\n\tunsigned long\t\t\tcounter;\n#ifdef config_function_graph_tracer\n\tunsigned long long\t\ttime;\n\tunsigned long long\t\ttime_squared;\n#endif\n};\n\nstruct ftrace_profile_page {\n\tstruct ftrace_profile_page\t*next;\n\tunsigned long\t\t\tindex;\n\tstruct ftrace_profile\t\trecords[];\n};\n\nstruct ftrace_profile_stat {\n\tatomic_t\t\t\tdisabled;\n\tstruct hlist_head\t\t*hash;\n\tstruct ftrace_profile_page\t*pages;\n\tstruct ftrace_profile_page\t*start;\n\tstruct tracer_stat\t\tstat;\n};\n\n#define profile_records_size\t\t\t\t\t\t\\\n\t(page_size - offsetof(struct ftrace_profile_page, records))\n\n#define profiles_per_page\t\t\t\t\t\\\n\t(profile_records_size / sizeof(struct ftrace_profile))\n\nstatic int ftrace_profile_enabled __read_mostly;\n\n\nstatic define_mutex(ftrace_profile_lock);\n\nstatic define_per_cpu(struct ftrace_profile_stat, ftrace_profile_stats);\n\n#define ftrace_profile_hash_bits 10\n#define ftrace_profile_hash_size (1 << ftrace_profile_hash_bits)\n\nstatic void *\nfunction_stat_next(void *v, int idx)\n{\n\tstruct ftrace_profile *rec = v;\n\tstruct ftrace_profile_page *pg;\n\n\tpg = (struct ftrace_profile_page *)((unsigned long)rec & page_mask);\n\n again:\n\tif (idx != 0)\n\t\trec++;\n\n\tif ((void *)rec >", "4492": "< 0)\n\t\treturn ret;\n\n\tif (trace_parser_get_init(&parser, event_buf_size + 1))\n\t\treturn -enomem;\n\n\tread = trace_get_user(&parser, ubuf, cnt, ppos);\n\n\tif (read >", "4493": "< 0)\n\t\treturn ret;\n\n\tif (val != 0 && val != 1)\n\t\treturn -einval;\n\n\t\n\tif (system)\n\t\tname = system->", "4494": "< 0)\n\t\treturn ret;\n\n\tret = -enodev;\n\tmutex_lock(&clockevents_mutex);\n\traw_spin_lock_irq(&clockevents_lock);\n\tlist_for_each_entry(ce, &clockevent_devices, list) {\n\t\tif (!strcmp(ce->", "4495": "< 0)\n\t\treturn ret;\n\n\tret = ftrace_pid_add(val);\n\n\treturn ret ? ret : cnt;\n}\n\nstatic int\nftrace_pid_release(struct inode *inode, struct file *file)\n{\n\tif (file->", "4496": "< 0)\n\t\treturn ret;\n\n\tswitch (val) {\n\tcase 0:\n\tcase 1:\n\t\tret = -enodev;\n\t\tmutex_lock(&event_mutex);\n\t\tfile = event_file_data(filp);\n\t\tif (likely(file))\n\t\t\tret = ftrace_event_enable_disable(file, val);\n\t\tmutex_unlock(&event_mutex);\n\t\tbreak;\n\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\t*ppos += cnt;\n\n\treturn ret ? ret : cnt;\n}\n\nstatic ssize_t\nsystem_enable_read(struct file *filp, char __user *ubuf, size_t cnt,\n\t\t   loff_t *ppos)\n{\n\tconst char set_to_char[4] = { '?', '0', '1', 'x' };\n\tstruct ftrace_subsystem_dir *dir = filp->", "4497": "< 0)\n\t\treturn retry_task;\n\n\tif (new_tasks >", "4498": "< 0)\n\t\treturn retval;\n\n\treturn 0;\n}\n\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\n\n\nvoid perf_event_wakeup(struct perf_event *event)\n{\n\tring_buffer_wakeup(event);\n\n\tif (event->", "4499": "< 0)\n\t\treturn retval;\n\n\tspin_lock_irq(&callback_lock);\n\tcpumask_copy(cs->", "4500": "< 0)\n\t\treturn size;\n\n\tif (off % size != 0) {\n\t\tverbose(\"misaligned access off %d size %d\\n\", off, size);\n\t\treturn -eacces;\n\t}\n\n\tif (state->", "4501": "< 0)\n\t\treturn timer_retry;\n\treturn 0;\n}\n\nstatic inline int timer_delete_hook(struct k_itimer *timer)\n{\n\tstruct k_clock *kc = clockid_to_kclock(timer->", "4502": "< 0)\n\t\treturn timer_retry;\n\n\t\n\ttimr->", "4503": "< 0)\n\t\treturn timer_retry;\n\n\treturn 0;\n}\n\n\nstatic int alarm_timer_set(struct k_itimer *timr, int flags,\n\t\t\t\tstruct itimerspec *new_setting,\n\t\t\t\tstruct itimerspec *old_setting)\n{\n\tktime_t exp;\n\n\tif (!rtcdev)\n\t\treturn -enotsupp;\n\n\tif (flags & ~timer_abstime)\n\t\treturn -einval;\n\n\tif (old_setting)\n\t\talarm_timer_get(timr, old_setting);\n\n\t\n\tif (alarm_try_to_cancel(&timr->", "4504": "< 0)\n\t\treturn timer_retry;\n\n\ttimr->", "4505": "< 0)\n\t\treturn;\n\trq->", "4506": "< 0)\n\t\treturn;\n\n\t\n\tif (op->", "4507": "< 0)\n\t\treturn;\n\n\t\n\tpreempt_disable_notrace();\n\tdo_for_each_ftrace_op(op, ftrace_ops_list) {\n\t\tif (ftrace_ops_test(op, ip, regs)) {\n\t\t\tif (ftrace_warn_on(!op->", "4508": "< 0)\n\t\treturn;\n\n\t\n\n\tif (cfs_rq->", "4509": "< 0)\n\t\treturn;\n\n\tif (delta >", "4510": "< 0)\n\t\treturn;\n\n\top->", "4511": "< 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, taskstats_type_pid,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, taskstats_type_tgid,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->", "4512": "< 0)\n\t\trt_runtime = runtime_inf;\n\n\treturn tg_set_rt_bandwidth(tg, rt_period, rt_runtime);\n}\n\nstatic long sched_group_rt_runtime(struct task_group *tg)\n{\n\tu64 rt_runtime_us;\n\n\tif (tg->", "4513": "< 0)\n\t\tseq_printf(m, \"<%p>", "4514": "< 0)\n\t\tseq_printf(m, \"<%pk>", "4515": "< 0)\n\t\tseq_printf(m, \"broadcast device\\n\");\n\telse\n\t\tseq_printf(m, \"per cpu device: %d\\n\", cpu);\n\n\tseq_printf(m, \"clock event device: \");\n\tif (!dev) {\n\t\tseq_printf(m, \"<null>", "4516": "< 0)\n\t\tseq_puts(m, \"  x \");\n\telse\n\t\tseq_printf(m, \"%3ld \", percent);\n\tseq_printf(m, \"%-30.30s %-20.20s %d\\n\", p->", "4517": "< 0)\n\t\tstutter = 0;\n\tif (stutter) {\n\t\tfirsterr = torture_stutter_init(stutter * hz);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (fqs_duration < 0)\n\t\tfqs_duration = 0;\n\tif (fqs_duration) {\n\t\t\n\t\tfirsterr = torture_create_kthread(rcu_torture_fqs, null,\n\t\t\t\t\t\t  fqs_task);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (test_boost_interval < 1)\n\t\ttest_boost_interval = 1;\n\tif (test_boost_duration < 2)\n\t\ttest_boost_duration = 2;\n\tif ((test_boost == 1 && cur_ops->", "4518": "< 0)\n\t\ttrace_array_put(tr);\n\treturn ret;\n}\n\nstatic struct event_subsystem *\ncreate_new_subsystem(const char *name)\n{\n\tstruct event_subsystem *system;\n\n\t\n\tsystem = kmalloc(sizeof(*system), gfp_kernel);\n\tif (!system)\n\t\treturn null;\n\n\tsystem->", "4519": "< 0) \n\t\t\t\tcxt.nrealwriters_stress = num_online_cpus();\n\t\t\tcxt.nrealreaders_stress = cxt.nrealwriters_stress;\n\t\t}\n\n\t\tlock_is_read_held = 0;\n\t\tcxt.lrsa = kmalloc(sizeof(*cxt.lrsa) * cxt.nrealreaders_stress, gfp_kernel);\n\t\tif (cxt.lrsa == null) {\n\t\t\tverbose_torout_string(\"cxt.lrsa: out of memory\");\n\t\t\tfirsterr = -enomem;\n\t\t\tkfree(cxt.lwsa);\n\t\t\tgoto unwind;\n\t\t}\n\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++) {\n\t\t\tcxt.lrsa[i].n_lock_fail = 0;\n\t\t\tcxt.lrsa[i].n_lock_acquired = 0;\n\t\t}\n\t}\n\tlock_torture_print_module_parms(cxt.cur_ops, \"start of test\");\n\n\t\n\tif (onoff_interval >", "4520": "< 0) ? 'u' :\n\t\t(p->", "4521": "< 0) {\t\n\t\t((u8 *)get_rloc_data(dest))[0] = '\\0';\n\t\t*(u32 *)dest = make_data_rloc(0, get_rloc_offs(rloc));\n\t} else {\n\t\t*(u32 *)dest = make_data_rloc(ret, get_rloc_offs(rloc));\n\t}\n}\n\nstatic void fetch_func_name(memory, string_size)(struct pt_regs *regs,\n\t\t\t\t\t\t void *addr, void *dest)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, max_string_size);\n\n\tif (len == 0 || len >", "4522": "< 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\tdo_print_state = true;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terr = check_cond_jmp_op(env, insn, &insn_idx);\n\t\t\t\tif (err)\n\t\t\t\t\treturn err;\n\t\t\t}\n\t\t} else if (class == bpf_ld) {\n\t\t\tu8 mode = bpf_mode(insn->", "4523": "< 0) {\n\t\t\t\t\tmin_offline = delta;\n\t\t\t\t\tmax_offline = delta;\n\t\t\t\t}\n\t\t\t\tif (min_offline >", "4524": "< 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\tret = register_ftrace_profiler();\n\t\t\tif (ret < 0) {\n\t\t\t\tcnt = ret;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tftrace_profile_enabled = 1;\n\t\t} else {\n\t\t\tftrace_profile_enabled = 0;\n\t\t\t\n\t\t\tunregister_ftrace_profiler();\n\t\t}\n\t}\n out:\n\tmutex_unlock(&ftrace_profile_lock);\n\n\t*ppos += cnt;\n\n\treturn cnt;\n}\n\nstatic ssize_t\nftrace_profile_read(struct file *filp, char __user *ubuf,\n\t\t     size_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\t\t\n\tint r;\n\n\tr = sprintf(buf, \"%u\\n\", ftrace_profile_enabled);\n\treturn simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n\nstatic const struct file_operations ftrace_profile_fops = {\n\t.open\t\t= tracing_open_generic,\n\t.read\t\t= ftrace_profile_read,\n\t.write\t\t= ftrace_profile_write,\n\t.llseek\t\t= default_llseek,\n};\n\n\nstatic struct tracer_stat function_stats __initdata = {\n\t.name\t\t= \"functions\",\n\t.stat_start\t= function_stat_start,\n\t.stat_next\t= function_stat_next,\n\t.stat_cmp\t= function_stat_cmp,\n\t.stat_headers\t= function_stat_headers,\n\t.stat_show\t= function_stat_show\n};\n\nstatic __init void ftrace_profile_tracefs(struct dentry *d_tracer)\n{\n\tstruct ftrace_profile_stat *stat;\n\tstruct dentry *entry;\n\tchar *name;\n\tint ret;\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu) {\n\t\tstat = &per_cpu(ftrace_profile_stats, cpu);\n\n\t\t\n\t\tname = kmalloc(32, gfp_kernel);\n\t\tif (!name) {\n\t\t\t\n\t\t\twarn(1,\n\t\t\t     \"could not allocate stat file for cpu %d\\n\",\n\t\t\t     cpu);\n\t\t\treturn;\n\t\t}\n\t\tstat->", "4525": "< 0) {\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\n\t\tdp = doms[nslot];\n\n\t\tif (nslot == ndoms) {\n\t\t\tstatic int warnings = 10;\n\t\t\tif (warnings) {\n\t\t\t\tpr_warn(\"rebuild_sched_domains confused: nslot %d, ndoms %d, csn %d, i %d, apn %d\\n\",\n\t\t\t\t\tnslot, ndoms, csn, i, apn);\n\t\t\t\twarnings--;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpumask_clear(dp);\n\t\tif (dattr)\n\t\t\t*(dattr + nslot) = sd_attr_init;\n\t\tfor (j = i; j < csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\n\t\t\tif (apn == b->", "4526": "< 0) {\n\t\t\t\n\t\t\twarn_on_once(1);\n\t\t\ttr->", "4527": "< 0) {\n\t\t\t*len_sent = 0;\n\t\t\taudit_log_end(*ab);\n\t\t\t*ab = audit_log_start(context, gfp_kernel, audit_execve);\n\t\t\tif (!*ab)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\t\n\t\tif ((i == 0) && (too_long))\n\t\t\taudit_log_format(*ab, \" a%d_len=%zu\", arg_num,\n\t\t\t\t\t has_cntl ? 2*len : len);\n\n\t\t\n\t\tif (len >", "4528": "< 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic const char proc_wspace_sep[] = { ' ', '\\t', '\\n' };\n\nstatic int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void __user *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tunsigned long page = 0;\n\tsize_t left;\n\tchar *kbuf;\n\t\n\tif (!tbl_data || !table->", "4529": "< 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_clock_t(lval);\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_ms_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t    int *valp,\n\t\t\t\t\t    int write, void *data)\n{\n\tif (write) {\n\t\tunsigned long jif = msecs_to_jiffies(*negp ? -*lvalp : *lvalp);\n\n\t\tif (jif >", "4530": "< 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = jiffies_to_msecs(lval);\n\t}\n\treturn 0;\n}\n\n\nint proc_dointvec_jiffies(struct ctl_table *table, int write,\n\t\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_jiffies_conv,null);\n}\n\n\nint proc_dointvec_userhz_jiffies(struct ctl_table *table, int write,\n\t\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n    return do_proc_dointvec(table,write,buffer,lenp,ppos,\n\t\t    \t    do_proc_dointvec_userhz_jiffies_conv,null);\n}\n\n\nint proc_dointvec_ms_jiffies(struct ctl_table *table, int write,\n\t\t\t     void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn do_proc_dointvec(table, write, buffer, lenp, ppos,\n\t\t\t\tdo_proc_dointvec_ms_jiffies_conv, null);\n}\n\nstatic int proc_do_cad_pid(struct ctl_table *table, int write,\n\t\t\t   void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid *new_pid;\n\tpid_t tmp;\n\tint r;\n\n\ttmp = pid_vnr(cad_pid);\n\n\tr = __do_proc_dointvec(&tmp, table, write, buffer,\n\t\t\t       lenp, ppos, null, null);\n\tif (r || !write)\n\t\treturn r;\n\n\tnew_pid = find_get_pid(tmp);\n\tif (!new_pid)\n\t\treturn -esrch;\n\n\tput_pid(xchg(&cad_pid, new_pid));\n\treturn 0;\n}\n\n\nint proc_do_large_bitmap(struct ctl_table *table, int write,\n\t\t\t void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tint err = 0;\n\tbool first = 1;\n\tsize_t left = *lenp;\n\tunsigned long bitmap_len = table->", "4531": "< 0) {\n\t\t\t*negp = true;\n\t\t\tlval = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\tlval = (unsigned long)val;\n\t\t}\n\t\t*lvalp = lval / hz;\n\t}\n\treturn 0;\n}\n\nstatic int do_proc_dointvec_userhz_jiffies_conv(bool *negp, unsigned long *lvalp,\n\t\t\t\t\t\tint *valp,\n\t\t\t\t\t\tint write, void *data)\n{\n\tif (write) {\n\t\tif (user_hz < hz && *lvalp >", "4532": "< 0) {\n\t\t\terror_packet(remcom_out_buffer, error);\n\t\t} else {\n\t\t\tstrcpy(remcom_out_buffer, \"ok\");\n\t\t\tkgdb_connected = 0;\n\t\t}\n\t\tput_packet(remcom_out_buffer);\n\t} else {\n\t\t\n\t\tdbg_remove_all_break();\n\t\tkgdb_connected = 0;\n\t}\n}\n\n\nstatic int gdb_cmd_reboot(struct kgdb_state *ks)\n{\n\t\n\tif (strcmp(remcom_in_buffer, \"r0\") == 0) {\n\t\tprintk(kern_crit \"executing emergency reboot\\n\");\n\t\tstrcpy(remcom_out_buffer, \"ok\");\n\t\tput_packet(remcom_out_buffer);\n\n\t\t\n\t\tmachine_emergency_restart();\n\t\tkgdb_connected = 0;\n\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n\nstatic void gdb_cmd_query(struct kgdb_state *ks)\n{\n\tstruct task_struct *g;\n\tstruct task_struct *p;\n\tunsigned char thref[buf_thread_id_size];\n\tchar *ptr;\n\tint i;\n\tint cpu;\n\tint finished = 0;\n\n\tswitch (remcom_in_buffer[1]) {\n\tcase 's':\n\tcase 'f':\n\t\tif (memcmp(remcom_in_buffer + 2, \"threadinfo\", 10))\n\t\t\tbreak;\n\n\t\ti = 0;\n\t\tremcom_out_buffer[0] = 'm';\n\t\tptr = remcom_out_buffer + 1;\n\t\tif (remcom_in_buffer[1] == 'f') {\n\t\t\t\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tks->", "4533": "< 0) {\n\t\t\tfree_ftrace_hash(new_hash);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t\n\tftrace_hash_rec_disable_modify(ops, enable);\n\n\trcu_assign_pointer(*dst, new_hash);\n\n\tftrace_hash_rec_enable_modify(ops, enable);\n\n\treturn 0;\n}\n\nstatic bool hash_contains_ip(unsigned long ip,\n\t\t\t     struct ftrace_ops_hash *hash)\n{\n\t\n\treturn (ftrace_hash_empty(hash->", "4534": "< 0) {\n\t\t\tif (i >", "4535": "< 0) {\n\t\t\tif (ops->", "4536": "< 0) {\n\t\t\tif (rq->", "4537": "< 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >", "4538": "< 0) {\n\t\t\tpr_warn(\"could not initialize trace point events/%s\\n\",\n\t\t\t\tname);\n\t\t\treturn -1;\n\t\t}\n\t}\n\ttrace_create_file(\"filter\", 0644, file->", "4539": "< 0) {\n\t\t\tprintk(kern_err \"schedule_timeout: wrong timeout \"\n\t\t\t\t\"value %lx\\n\", timeout);\n\t\t\tdump_stack();\n\t\t\tcurrent->", "4540": "< 0) {\n\t\t\tret = -efault;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer[sizeof(buffer) - 1] = '\\0';\n\n\t\tkernel_restart(buffer);\n\t\tbreak;\n\n#ifdef config_kexec\n\tcase linux_reboot_cmd_kexec:\n\t\tret = kernel_kexec();\n\t\tbreak;\n#endif\n\n#ifdef config_hibernation\n\tcase linux_reboot_cmd_sw_suspend:\n\t\tret = hibernate();\n\t\tbreak;\n#endif\n\n\tdefault:\n\t\tret = -einval;\n\t\tbreak;\n\t}\n\tmutex_unlock(&reboot_mutex);\n\treturn ret;\n}\n\nstatic void deferred_cad(struct work_struct *dummy)\n{\n\tkernel_restart(null);\n}\n\n\nvoid ctrl_alt_del(void)\n{\n\tstatic declare_work(cad_work, deferred_cad);\n\n\tif (c_a_d)\n\t\tschedule_work(&cad_work);\n\telse\n\t\tkill_cad_pid(sigint, 1);\n}\n\nchar poweroff_cmd[poweroff_cmd_path_len] = \"/sbin/poweroff\";\nstatic const char reboot_cmd[] = \"/sbin/reboot\";\n\nstatic int run_cmd(const char *cmd)\n{\n\tchar **argv;\n\tstatic char *envp[] = {\n\t\t\"home=/\",\n\t\t\"path=/sbin:/bin:/usr/sbin:/usr/bin\",\n\t\tnull\n\t};\n\tint ret;\n\targv = argv_split(gfp_kernel, cmd, null);\n\tif (argv) {\n\t\tret = call_usermodehelper(argv[0], argv, envp, umh_wait_exec);\n\t\targv_free(argv);\n\t} else {\n\t\tret = -enomem;\n\t}\n\n\treturn ret;\n}\n\nstatic int __orderly_reboot(void)\n{\n\tint ret;\n\n\tret = run_cmd(reboot_cmd);\n\n\tif (ret) {\n\t\tpr_warn(\"failed to start orderly reboot: forcing the issue\\n\");\n\t\temergency_sync();\n\t\tkernel_restart(null);\n\t}\n\n\treturn ret;\n}\n\nstatic int __orderly_poweroff(bool force)\n{\n\tint ret;\n\n\tret = run_cmd(poweroff_cmd);\n\n\tif (ret && force) {\n\t\tpr_warn(\"failed to start orderly shutdown: forcing the issue\\n\");\n\n\t\t\n\t\temergency_sync();\n\t\tkernel_power_off();\n\t}\n\n\treturn ret;\n}\n\nstatic bool poweroff_force;\n\nstatic void poweroff_work_func(struct work_struct *work)\n{\n\t__orderly_poweroff(poweroff_force);\n}\n\nstatic declare_work(poweroff_work, poweroff_work_func);\n\n\nvoid orderly_poweroff(bool force)\n{\n\tif (force) \n\t\tpoweroff_force = true;\n\tschedule_work(&poweroff_work);\n}\nexport_symbol_gpl(orderly_poweroff);\n\nstatic void reboot_work_func(struct work_struct *work)\n{\n\t__orderly_reboot();\n}\n\nstatic declare_work(reboot_work, reboot_work_func);\n\n\nvoid orderly_reboot(void)\n{\n\tschedule_work(&reboot_work);\n}\nexport_symbol_gpl(orderly_reboot);\n\nstatic int __init reboot_setup(char *str)\n{\n\tfor (;;) {\n\t\t\n\t\treboot_default = 0;\n\n\t\tswitch (*str) {\n\t\tcase 'w':\n\t\t\treboot_mode = reboot_warm;\n\t\t\tbreak;\n\n\t\tcase 'c':\n\t\t\treboot_mode = reboot_cold;\n\t\t\tbreak;\n\n\t\tcase 'h':\n\t\t\treboot_mode = reboot_hard;\n\t\t\tbreak;\n\n\t\tcase 's':\n\t\t{\n\t\t\tint rc;\n\n\t\t\tif (isdigit(*(str+1))) {\n\t\t\t\trc = kstrtoint(str+1, 0, &reboot_cpu);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} else if (str[1] == 'm' && str[2] == 'p' &&\n\t\t\t\t   isdigit(*(str+3))) {\n\t\t\t\trc = kstrtoint(str+3, 0, &reboot_cpu);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t} else\n\t\t\t\treboot_mode = reboot_soft;\n\t\t\tbreak;\n\t\t}\n\t\tcase 'g':\n\t\t\treboot_mode = reboot_gpio;\n\t\t\tbreak;\n\n\t\tcase 'b':\n\t\tcase 'a':\n\t\tcase 'k':\n\t\tcase 't':\n\t\tcase 'e':\n\t\tcase 'p':\n\t\t\treboot_type = *str;\n\t\t\tbreak;\n\n\t\tcase 'f':\n\t\t\treboot_force = 1;\n\t\t\tbreak;\n\t\t}\n\n\t\tstr = strchr(str, ',');\n\t\tif (str)\n\t\t\tstr++;\n\t\telse\n\t\t\tbreak;\n\t}\n\treturn 1;\n}\n__setup(\"reboot=\", reboot_setup);\n\n\n#ifndef __kernel_rtmutex_common_h\n#define __kernel_rtmutex_common_h\n\n#include <linux/rtmutex.h>", "4541": "< 0) {\n\t\t\tret = -enospc;\n\t\t\tif (ops->", "4542": "< 0) {\n\t\t\tspin_unlock_irq(&tsk->", "4543": "< 0) {\n\t\t\tvfree(info->", "4544": "< 0) {\n\t\t\n\t\t__unregister_ftrace_function(ops);\n\t\tftrace_start_up--;\n\t\tops->", "4545": "< 0) {\n\t\t\n\t\traw_spin_unlock(&cfs_b->", "4546": "< 0) {\n\t\t\n\t\tstruct completion *done = xchg(&create->", "4547": "< 0) {\n\t\t\n\t\tvec = base->", "4548": "< 0) {\n\t\tasm(\"\" : \"+rm\"(nsec));\n\t\tnsec += nsec_per_sec;\n\t\t--sec;\n\t}\n\tts->", "4549": "< 0) {\n\t\taudit_free_parent(parent);\n\t\treturn err_ptr(ret);\n\t}\n\n\treturn parent;\n}\n\n\nstatic struct audit_watch *audit_init_watch(char *path)\n{\n\tstruct audit_watch *watch;\n\n\twatch = kzalloc(sizeof(*watch), gfp_kernel);\n\tif (unlikely(!watch))\n\t\treturn err_ptr(-enomem);\n\n\tinit_list_head(&watch->", "4550": "< 0) {\n\t\taudit_log_lost(\"out of memory in audit_expand\");\n\t\treturn 0;\n\t}\n\n\tskb->", "4551": "< 0) {\n\t\tbug_on(err != -econnrefused); \n\t\tif (audit_pid) {\n\t\t\tpr_err(\"*no* daemon at audit_pid=%d\\n\", audit_pid);\n\t\t\taudit_log_lost(\"auditd disappeared\");\n\t\t\taudit_pid = 0;\n\t\t\taudit_sock = null;\n\t\t}\n\t\t\n\t\taudit_hold_skb(skb);\n\t} else\n\t\t\n\t\tconsume_skb(skb);\n}\n\n\nstatic void kauditd_send_multicast_skb(struct sk_buff *skb, gfp_t gfp_mask)\n{\n\tstruct sk_buff\t\t*copy;\n\tstruct audit_net\t*aunet = net_generic(&init_net, audit_net_id);\n\tstruct sock\t\t*sock = aunet->", "4552": "< 0) {\n\t\terror = new_timer_id;\n\t\tgoto out;\n\t}\n\n\tit_id_set = it_id_set;\n\tnew_timer->", "4553": "< 0) {\n\t\tgoto fail_free_freeinit;\n\t}\n\tif (ret >", "4554": "< 0) {\n\t\tif (default_relax_domain_level < 0)\n\t\t\treturn;\n\t\telse\n\t\t\trequest = default_relax_domain_level;\n\t} else\n\t\trequest = attr->", "4555": "< 0) {\n\t\tkfree(cset);\n\t\treturn null;\n\t}\n\n\tatomic_set(&cset->", "4556": "< 0) {\n\t\tkfree(savedcmd);\n\t\tsavedcmd = null;\n\t\treturn -enomem;\n\t}\n\n\treturn 0;\n}\n\nint is_tracing_stopped(void)\n{\n\treturn global_trace.stop_count;\n}\n\n\nvoid tracing_start(void)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\traw_spin_lock_irqsave(&global_trace.start_lock, flags);\n\tif (--global_trace.stop_count) {\n\t\tif (global_trace.stop_count < 0) {\n\t\t\t\n\t\t\twarn_on_once(1);\n\t\t\tglobal_trace.stop_count = 0;\n\t\t}\n\t\tgoto out;\n\t}\n\n\t\n\tarch_spin_lock(&global_trace.max_lock);\n\n\tbuffer = global_trace.trace_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n\n#ifdef config_tracer_max_trace\n\tbuffer = global_trace.max_buffer.buffer;\n\tif (buffer)\n\t\tring_buffer_record_enable(buffer);\n#endif\n\n\tarch_spin_unlock(&global_trace.max_lock);\n\n out:\n\traw_spin_unlock_irqrestore(&global_trace.start_lock, flags);\n}\n\nstatic void tracing_start_tr(struct trace_array *tr)\n{\n\tstruct ring_buffer *buffer;\n\tunsigned long flags;\n\n\tif (tracing_disabled)\n\t\treturn;\n\n\t\n\tif (tr->", "4557": "< 0) {\n\t\tkfree(stat->", "4558": "< 0) {\n\t\tkobject_put(cgroup_kobj);\n\t\treturn err;\n\t}\n\n\tproc_create(\"cgroups\", 0, null, &proc_cgroupstats_operations);\n\treturn 0;\n}\n\nstatic int __init cgroup_wq_init(void)\n{\n\t\n\tcgroup_destroy_wq = alloc_workqueue(\"cgroup_destroy\", 0, 1);\n\tbug_on(!cgroup_destroy_wq);\n\n\t\n\tcgroup_pidlist_destroy_wq = alloc_workqueue(\"cgroup_pidlist_destroy\",\n\t\t\t\t\t\t    0, 1);\n\tbug_on(!cgroup_pidlist_destroy_wq);\n\n\treturn 0;\n}\ncore_initcall(cgroup_wq_init);\n\n\nint proc_cgroup_show(struct seq_file *m, struct pid_namespace *ns,\n\t\t     struct pid *pid, struct task_struct *tsk)\n{\n\tchar *buf, *path;\n\tint retval;\n\tstruct cgroup_root *root;\n\n\tretval = -enomem;\n\tbuf = kmalloc(path_max, gfp_kernel);\n\tif (!buf)\n\t\tgoto out;\n\n\tmutex_lock(&cgroup_mutex);\n\tdown_read(&css_set_rwsem);\n\n\tfor_each_root(root) {\n\t\tstruct cgroup_subsys *ss;\n\t\tstruct cgroup *cgrp;\n\t\tint ssid, count = 0;\n\n\t\tif (root == &cgrp_dfl_root && !cgrp_dfl_root_visible)\n\t\t\tcontinue;\n\n\t\tseq_printf(m, \"%d:\", root->", "4559": "< 0) {\n\t\tlist_del_rcu(&data->", "4560": "< 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfdput(f);\n\treturn rc;\n}\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, gfp_kernel))\n\t\treturn -enomem;\n\trc = parse(info->", "4561": "< 0) {\n\t\tnsec = -nsec;\n\t\tdo_div(nsec, 1000000);\n\t\treturn -nsec;\n\t}\n\tdo_div(nsec, 1000000);\n\n\treturn nsec;\n}\n\nstatic unsigned long nsec_low(unsigned long long nsec)\n{\n\tif ((long long)nsec < 0)\n\t\tnsec = -nsec;\n\n\treturn do_div(nsec, 1000000);\n}\n\n#define split_ns(x) nsec_high(x), nsec_low(x)\n\n#ifdef config_fair_group_sched\nstatic void print_cfs_group_stats(struct seq_file *m, int cpu, struct task_group *tg)\n{\n\tstruct sched_entity *se = tg->", "4562": "< 0) {\n\t\tpr_err(\"register_kprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = target(rand1);\n\tunregister_kprobe(&kp);\n\n\tif (preh_val == 0) {\n\t\tpr_err(\"kprobe pre_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tif (posth_val == 0) {\n\t\tpr_err(\"kprobe post_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\treturn 0;\n}\n\nstatic noinline u32 kprobe_target2(u32 value)\n{\n\treturn (value / div_factor) + 1;\n}\n\nstatic int kp_pre_handler2(struct kprobe *p, struct pt_regs *regs)\n{\n\tpreh_val = (rand1 / div_factor) + 1;\n\treturn 0;\n}\n\nstatic void kp_post_handler2(struct kprobe *p, struct pt_regs *regs,\n\t\tunsigned long flags)\n{\n\tif (preh_val != (rand1 / div_factor) + 1) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in post_handler2\\n\");\n\t}\n\tposth_val = preh_val + div_factor;\n}\n\nstatic struct kprobe kp2 = {\n\t.symbol_name = \"kprobe_target2\",\n\t.pre_handler = kp_pre_handler2,\n\t.post_handler = kp_post_handler2\n};\n\nstatic int test_kprobes(void)\n{\n\tint ret;\n\tstruct kprobe *kps[2] = {&kp, &kp2};\n\n\t\n\tkp.addr = null;\n\tkp.flags = 0;\n\tret = register_kprobes(kps, 2);\n\tif (ret < 0) {\n\t\tpr_err(\"register_kprobes returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tpreh_val = 0;\n\tposth_val = 0;\n\tret = target(rand1);\n\n\tif (preh_val == 0) {\n\t\tpr_err(\"kprobe pre_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tif (posth_val == 0) {\n\t\tpr_err(\"kprobe post_handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tpreh_val = 0;\n\tposth_val = 0;\n\tret = target2(rand1);\n\n\tif (preh_val == 0) {\n\t\tpr_err(\"kprobe pre_handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tif (posth_val == 0) {\n\t\tpr_err(\"kprobe post_handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tunregister_kprobes(kps, 2);\n\treturn 0;\n\n}\n\nstatic u32 j_kprobe_target(u32 value)\n{\n\tif (value != rand1) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in jprobe handler\\n\");\n\t}\n\n\tjph_val = rand1;\n\tjprobe_return();\n\treturn 0;\n}\n\nstatic struct jprobe jp = {\n\t.entry\t\t= j_kprobe_target,\n\t.kp.symbol_name = \"kprobe_target\"\n};\n\nstatic int test_jprobe(void)\n{\n\tint ret;\n\n\tret = register_jprobe(&jp);\n\tif (ret < 0) {\n\t\tpr_err(\"register_jprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = target(rand1);\n\tunregister_jprobe(&jp);\n\tif (jph_val == 0) {\n\t\tpr_err(\"jprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\treturn 0;\n}\n\nstatic struct jprobe jp2 = {\n\t.entry          = j_kprobe_target,\n\t.kp.symbol_name = \"kprobe_target2\"\n};\n\nstatic int test_jprobes(void)\n{\n\tint ret;\n\tstruct jprobe *jps[2] = {&jp, &jp2};\n\n\t\n\tjp.kp.addr = null;\n\tjp.kp.flags = 0;\n\tret = register_jprobes(jps, 2);\n\tif (ret < 0) {\n\t\tpr_err(\"register_jprobes returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tjph_val = 0;\n\tret = target(rand1);\n\tif (jph_val == 0) {\n\t\tpr_err(\"jprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tjph_val = 0;\n\tret = target2(rand1);\n\tif (jph_val == 0) {\n\t\tpr_err(\"jprobe handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\tunregister_jprobes(jps, 2);\n\n\treturn 0;\n}\n#ifdef config_kretprobes\nstatic u32 krph_val;\n\nstatic int entry_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tkrph_val = (rand1 / div_factor);\n\treturn 0;\n}\n\nstatic int return_handler(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tif (ret != (rand1 / div_factor)) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in kretprobe handler\\n\");\n\t}\n\tif (krph_val == 0) {\n\t\thandler_errors++;\n\t\tpr_err(\"call to kretprobe entry handler failed\\n\");\n\t}\n\n\tkrph_val = rand1;\n\treturn 0;\n}\n\nstatic struct kretprobe rp = {\n\t.handler\t= return_handler,\n\t.entry_handler  = entry_handler,\n\t.kp.symbol_name = \"kprobe_target\"\n};\n\nstatic int test_kretprobe(void)\n{\n\tint ret;\n\n\tret = register_kretprobe(&rp);\n\tif (ret < 0) {\n\t\tpr_err(\"register_kretprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tret = target(rand1);\n\tunregister_kretprobe(&rp);\n\tif (krph_val != rand1) {\n\t\tpr_err(\"kretprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\treturn 0;\n}\n\nstatic int return_handler2(struct kretprobe_instance *ri, struct pt_regs *regs)\n{\n\tunsigned long ret = regs_return_value(regs);\n\n\tif (ret != (rand1 / div_factor) + 1) {\n\t\thandler_errors++;\n\t\tpr_err(\"incorrect value in kretprobe handler2\\n\");\n\t}\n\tif (krph_val == 0) {\n\t\thandler_errors++;\n\t\tpr_err(\"call to kretprobe entry handler failed\\n\");\n\t}\n\n\tkrph_val = rand1;\n\treturn 0;\n}\n\nstatic struct kretprobe rp2 = {\n\t.handler\t= return_handler2,\n\t.entry_handler  = entry_handler,\n\t.kp.symbol_name = \"kprobe_target2\"\n};\n\nstatic int test_kretprobes(void)\n{\n\tint ret;\n\tstruct kretprobe *rps[2] = {&rp, &rp2};\n\n\t\n\trp.kp.addr = null;\n\trp.kp.flags = 0;\n\tret = register_kretprobes(rps, 2);\n\tif (ret < 0) {\n\t\tpr_err(\"register_kretprobe returned %d\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tkrph_val = 0;\n\tret = target(rand1);\n\tif (krph_val != rand1) {\n\t\tpr_err(\"kretprobe handler not called\\n\");\n\t\thandler_errors++;\n\t}\n\n\tkrph_val = 0;\n\tret = target2(rand1);\n\tif (krph_val != rand1) {\n\t\tpr_err(\"kretprobe handler2 not called\\n\");\n\t\thandler_errors++;\n\t}\n\tunregister_kretprobes(rps, 2);\n\treturn 0;\n}\n#endif \n\nint init_test_probes(void)\n{\n\tint ret;\n\n\ttarget = kprobe_target;\n\ttarget2 = kprobe_target2;\n\n\tdo {\n\t\trand1 = prandom_u32();\n\t} while (rand1 <= div_factor);\n\n\tpr_info(\"started\\n\");\n\tnum_tests++;\n\tret = test_kprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kprobes();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_jprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_jprobes();\n\tif (ret < 0)\n\t\terrors++;\n\n#ifdef config_kretprobes\n\tnum_tests++;\n\tret = test_kretprobe();\n\tif (ret < 0)\n\t\terrors++;\n\n\tnum_tests++;\n\tret = test_kretprobes();\n\tif (ret < 0)\n\t\terrors++;\n#endif \n\n\tif (errors)\n\t\tpr_err(\"bug: %d out of %d tests failed\\n\", errors, num_tests);\n\telse if (handler_errors)\n\t\tpr_err(\"bug: %d error(s) running handlers\\n\", handler_errors);\n\telse\n\t\tpr_info(\"passed successfully\\n\");\n\n\treturn 0;\n}\n\n\n#include <linux/string.h>", "4563": "< 0) {\n\t\tpr_warn(\"could not remove '%s' (not found)\\n\",\n\t\t\tgcov_info_filename(info));\n\t\treturn;\n\t}\n\tif (gcov_persist)\n\t\tsave_info(node, info);\n\t\n\tnode->", "4564": "< 0) {\n\t\tpr_warning(\"nohz: incorrect nohz_full cpumask\\n\");\n\t\tfree_bootmem_cpumask_var(tick_nohz_full_mask);\n\t\treturn 1;\n\t}\n\ttick_nohz_full_running = true;\n\n\treturn 1;\n}\n__setup(\"nohz_full=\", tick_nohz_full_setup);\n\nstatic int tick_nohz_cpu_down_callback(struct notifier_block *nfb,\n\t\t\t\t\t\t unsigned long action,\n\t\t\t\t\t\t void *hcpu)\n{\n\tunsigned int cpu = (unsigned long)hcpu;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_down_prepare:\n\t\t\n\t\tif (tick_nohz_full_running && tick_do_timer_cpu == cpu)\n\t\t\treturn notify_bad;\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\nstatic int tick_nohz_init_all(void)\n{\n\tint err = -1;\n\n#ifdef config_no_hz_full_all\n\tif (!alloc_cpumask_var(&tick_nohz_full_mask, gfp_kernel)) {\n\t\twarn(1, \"no_hz: can't allocate full dynticks cpumask\\n\");\n\t\treturn err;\n\t}\n\terr = 0;\n\tcpumask_setall(tick_nohz_full_mask);\n\ttick_nohz_full_running = true;\n#endif\n\treturn err;\n}\n\nvoid __init tick_nohz_init(void)\n{\n\tint cpu;\n\n\tif (!tick_nohz_full_running) {\n\t\tif (tick_nohz_init_all() < 0)\n\t\t\treturn;\n\t}\n\n\tif (!alloc_cpumask_var(&housekeeping_mask, gfp_kernel)) {\n\t\twarn(1, \"no_hz: can't allocate not-full dynticks cpumask\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\t\n\tif (!arch_irq_work_has_interrupt()) {\n\t\tpr_warning(\"no_hz: can't run full dynticks because arch doesn't \"\n\t\t\t   \"support irq work self-ipis\\n\");\n\t\tcpumask_clear(tick_nohz_full_mask);\n\t\tcpumask_copy(housekeeping_mask, cpu_possible_mask);\n\t\ttick_nohz_full_running = false;\n\t\treturn;\n\t}\n\n\tcpu = smp_processor_id();\n\n\tif (cpumask_test_cpu(cpu, tick_nohz_full_mask)) {\n\t\tpr_warning(\"no_hz: clearing %d from nohz_full range for timekeeping\\n\", cpu);\n\t\tcpumask_clear_cpu(cpu, tick_nohz_full_mask);\n\t}\n\n\tcpumask_andnot(housekeeping_mask,\n\t\t       cpu_possible_mask, tick_nohz_full_mask);\n\n\tfor_each_cpu(cpu, tick_nohz_full_mask)\n\t\tcontext_tracking_cpu_set(cpu);\n\n\tcpu_notifier(tick_nohz_cpu_down_callback, 0);\n\tpr_info(\"no_hz: full dynticks cpus: %*pbl.\\n\",\n\t\tcpumask_pr_args(tick_nohz_full_mask));\n}\n#endif\n\n\n#ifdef config_no_hz_common\n\nstatic int tick_nohz_enabled __read_mostly  = 1;\nint tick_nohz_active  __read_mostly;\n\nstatic int __init setup_tick_nohz(char *str)\n{\n\tif (!strcmp(str, \"off\"))\n\t\ttick_nohz_enabled = 0;\n\telse if (!strcmp(str, \"on\"))\n\t\ttick_nohz_enabled = 1;\n\telse\n\t\treturn 0;\n\treturn 1;\n}\n\n__setup(\"nohz=\", setup_tick_nohz);\n\nint tick_nohz_tick_stopped(void)\n{\n\treturn __this_cpu_read(tick_cpu_sched.tick_stopped);\n}\n\n\nstatic void tick_nohz_update_jiffies(ktime_t now)\n{\n\tunsigned long flags;\n\n\t__this_cpu_write(tick_cpu_sched.idle_waketime, now);\n\n\tlocal_irq_save(flags);\n\ttick_do_update_jiffies64(now);\n\tlocal_irq_restore(flags);\n\n\ttouch_softlockup_watchdog();\n}\n\n\nstatic void\nupdate_ts_time_stats(int cpu, struct tick_sched *ts, ktime_t now, u64 *last_update_time)\n{\n\tktime_t delta;\n\n\tif (ts->", "4565": "< 0) {\n\t\tprintk(err_readtime, dev_name(&rtc->", "4566": "< 0) {\n\t\tprintk(err_wakealarm, dev_name(&rtc->", "4567": "< 0) {\n\t\tput_system(dir);\n\t\treturn -enodev;\n\t}\n\n\tret = tracing_open_generic(inode, filp);\n\tif (ret < 0) {\n\t\ttrace_array_put(tr);\n\t\tput_system(dir);\n\t}\n\n\treturn ret;\n}\n\nstatic int system_tr_open(struct inode *inode, struct file *filp)\n{\n\tstruct ftrace_subsystem_dir *dir;\n\tstruct trace_array *tr = inode->", "4568": "< 0) {\n\t\treset_on_fork = p->", "4569": "< 0) {\n\t\tret = -enomem;\n\t\tgoto out_cancel_ref;\n\t}\n\n\tinit_cgroup_housekeeping(cgrp);\n\n\tcgrp->", "4570": "< 0) {\n\t\tsa->", "4571": "< 0) {\n\t\tsub_info->", "4572": "< 0) {\n\t\ttrace_array_put(tr);\n\t\tkfree(dir);\n\t\treturn ret;\n\t}\n\n\tfilp->", "4573": "< 0) {\n\t\ttrsp->", "4574": "< 0) {\n\t\tverbose_torout_string(\"rcu_torture_boost rt prio failed!\");\n\t\tn_rcu_torture_boost_rterror++;\n\t}\n\n\tinit_rcu_head_on_stack(&rbi.rcu);\n\t\n\tdo {\n\t\t\n\t\toldstarttime = boost_starttime;\n\t\twhile (ulong_cmp_lt(jiffies, oldstarttime)) {\n\t\t\tschedule_timeout_interruptible(oldstarttime - jiffies);\n\t\t\tstutter_wait(\"rcu_torture_boost\");\n\t\t\tif (torture_must_stop())\n\t\t\t\tgoto checkwait;\n\t\t}\n\n\t\t\n\t\tendtime = oldstarttime + test_boost_duration * hz;\n\t\tcall_rcu_time = jiffies;\n\t\twhile (ulong_cmp_lt(jiffies, endtime)) {\n\t\t\t\n\t\t\tif (!rbi.inflight) {\n\t\t\t\tsmp_mb(); \n\t\t\t\trbi.inflight = 1;\n\t\t\t\tcall_rcu(&rbi.rcu, rcu_torture_boost_cb);\n\t\t\t\tif (jiffies - call_rcu_time >", "4575": "< 0) ||\n\t    (max_depth && trace->", "4576": "< 0) || (cpu >", "4577": "< 0) || (info.si_signo == 0))\n\t\treturn ret;\n\n\tif (uru) {\n\t\t\n\t\tif (compat_use_64bit_time)\n\t\t\tret = copy_to_user(uru, &ru, sizeof(ru));\n\t\telse\n\t\t\tret = put_compat_rusage(&ru, uru);\n\t\tif (ret)\n\t\t\treturn -efault;\n\t}\n\n\tbug_on(info.si_code & __si_mask);\n\tinfo.si_code |= __si_chld;\n\treturn copy_siginfo_to_user32(uinfo, &info);\n}\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len >", "4578": "< 0))\n\t\tdelta = 0;\n\n\told_clock = scd->", "4579": "< 0))\n\t\tdelta = 0;\n\n\ttotal = sched_avg_period() + delta;\n\n\tused = div_u64(avg, total);\n\n\tif (likely(used < sched_capacity_scale))\n\t\treturn sched_capacity_scale - used;\n\n\treturn 1;\n}\n\nstatic void update_cpu_capacity(struct sched_domain *sd, int cpu)\n{\n\tunsigned long capacity = sched_capacity_scale;\n\tstruct sched_group *sdg = sd->", "4580": "< 0))\n\t\treturn false;\n\n\tset_work_pool_and_clear_pending(&dwork->", "4581": "< 0))\n\t\treturn print_bfs_bug(ret);\n\n\tif (!check_prev_add_irq(curr, prev, next))\n\t\treturn 0;\n\n\t\n\tif (next->", "4582": "< 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_disable_cmd);\n\tif (warn_on(ret < 0))\n\t\tunregister_trigger_enable_disable_cmds();\n\n\treturn ret;\n}\n\nstatic __init int register_trigger_traceon_traceoff_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_traceon_cmd);\n\tif (warn_on(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_traceoff_cmd);\n\tif (warn_on(ret < 0))\n\t\tunregister_trigger_traceon_traceoff_cmds();\n\n\treturn ret;\n}\n\n__init int register_trigger_cmds(void)\n{\n\tregister_trigger_traceon_traceoff_cmds();\n\tregister_trigger_snapshot_cmd();\n\tregister_trigger_stacktrace_cmd();\n\tregister_trigger_enable_disable_cmds();\n\n\treturn 0;\n}\n\n#include <linux/sched.h>", "4583": "< 0))\n\t\treturn ret;\n\tret = register_ftrace_command(&event_disable_cmd);\n\tif (warn_on(ret < 0))\n\t\tunregister_ftrace_command(&event_enable_cmd);\n\treturn ret;\n}\n#else\nstatic inline int register_event_cmds(void) { return 0; }\n#endif \n\n\nstatic __init void\n__trace_early_add_event_dirs(struct trace_array *tr)\n{\n\tstruct ftrace_event_file *file;\n\tint ret;\n\n\n\tlist_for_each_entry(file, &tr->", "4584": "< 0))\n\t\treturn;\n\n\tif (cfs_rq->", "4585": "< 0)) \n\t\tatomic_inc(&cpu_hotplug.refcount);\n\n\tif (refcount <= 0 && waitqueue_active(&cpu_hotplug.wq))\n\t\twake_up(&cpu_hotplug.wq);\n\n\tcpuhp_lock_release();\n\n}\nexport_symbol_gpl(put_online_cpus);\n\n\nvoid cpu_hotplug_begin(void)\n{\n\tdefine_wait(wait);\n\n\tcpu_hotplug.active_writer = current;\n\tcpuhp_lock_acquire();\n\n\tfor (;;) {\n\t\tmutex_lock(&cpu_hotplug.lock);\n\t\tprepare_to_wait(&cpu_hotplug.wq, &wait, task_uninterruptible);\n\t\tif (likely(!atomic_read(&cpu_hotplug.refcount)))\n\t\t\t\tbreak;\n\t\tmutex_unlock(&cpu_hotplug.lock);\n\t\tschedule();\n\t}\n\tfinish_wait(&cpu_hotplug.wq, &wait);\n}\n\nvoid cpu_hotplug_done(void)\n{\n\tcpu_hotplug.active_writer = null;\n\tmutex_unlock(&cpu_hotplug.lock);\n\tcpuhp_lock_release();\n}\n\n\nvoid cpu_hotplug_disable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled = 1;\n\tcpu_maps_update_done();\n}\n\nvoid cpu_hotplug_enable(void)\n{\n\tcpu_maps_update_begin();\n\tcpu_hotplug_disabled = 0;\n\tcpu_maps_update_done();\n}\n\n#endif\t\n\n\nint __ref register_cpu_notifier(struct notifier_block *nb)\n{\n\tint ret;\n\tcpu_maps_update_begin();\n\tret = raw_notifier_chain_register(&cpu_chain, nb);\n\tcpu_maps_update_done();\n\treturn ret;\n}\n\nint __ref __register_cpu_notifier(struct notifier_block *nb)\n{\n\treturn raw_notifier_chain_register(&cpu_chain, nb);\n}\n\nstatic int __cpu_notify(unsigned long val, void *v, int nr_to_call,\n\t\t\tint *nr_calls)\n{\n\tint ret;\n\n\tret = __raw_notifier_call_chain(&cpu_chain, val, v, nr_to_call,\n\t\t\t\t\tnr_calls);\n\n\treturn notifier_to_errno(ret);\n}\n\nstatic int cpu_notify(unsigned long val, void *v)\n{\n\treturn __cpu_notify(val, v, -1, null);\n}\n\n#ifdef config_hotplug_cpu\n\nstatic void cpu_notify_nofail(unsigned long val, void *v)\n{\n\tbug_on(cpu_notify(val, v));\n}\nexport_symbol(register_cpu_notifier);\nexport_symbol(__register_cpu_notifier);\n\nvoid __ref unregister_cpu_notifier(struct notifier_block *nb)\n{\n\tcpu_maps_update_begin();\n\traw_notifier_chain_unregister(&cpu_chain, nb);\n\tcpu_maps_update_done();\n}\nexport_symbol(unregister_cpu_notifier);\n\nvoid __ref __unregister_cpu_notifier(struct notifier_block *nb)\n{\n\traw_notifier_chain_unregister(&cpu_chain, nb);\n}\nexport_symbol(__unregister_cpu_notifier);\n\n\nvoid clear_tasks_mm_cpumask(int cpu)\n{\n\tstruct task_struct *p;\n\n\t\n\twarn_on(cpu_online(cpu));\n\trcu_read_lock();\n\tfor_each_process(p) {\n\t\tstruct task_struct *t;\n\n\t\t\n\t\tt = find_lock_task_mm(p);\n\t\tif (!t)\n\t\t\tcontinue;\n\t\tcpumask_clear_cpu(cpu, mm_cpumask(t->", "4586": "< 0)) {\n\t\tpr_info(\"failed to enable function tracer for event tests\\n\");\n\t\treturn;\n\t}\n\tpr_info(\"running tests again, along with the function tracer\\n\");\n\tevent_trace_self_tests();\n\tunregister_ftrace_function(&trace_ops);\n}\n#else\nstatic __init void event_trace_self_test_with_function(void)\n{\n}\n#endif\n\nstatic __init int event_trace_self_tests_init(void)\n{\n\tif (!tracing_selftest_disabled) {\n\t\tevent_trace_self_tests();\n\t\tevent_trace_self_test_with_function();\n\t}\n\n\treturn 0;\n}\n\nlate_initcall(event_trace_self_tests_init);\n\n#endif\n\n\n\n\n#include <linux/mm.h>", "4587": "< 0)) {\n\t\tptr = &scd->", "4588": "< 0)) {\n\t\ts64 neg = -(s64)tk->", "4589": "< 0)) {\n\t\tstrcpy(comm, \"<xxx>", "4590": "< 0)) {\n\t\tts.tv_sec--;\n\t\trem += nsec_per_sec;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}\nexport_symbol(ns_to_timespec);\n\n\nstruct timeval ns_to_timeval(const s64 nsec)\n{\n\tstruct timespec ts = ns_to_timespec(nsec);\n\tstruct timeval tv;\n\n\ttv.tv_sec = ts.tv_sec;\n\ttv.tv_usec = (suseconds_t) ts.tv_nsec / 1000;\n\n\treturn tv;\n}\nexport_symbol(ns_to_timeval);\n\n#if bits_per_long == 32\n\nvoid set_normalized_timespec64(struct timespec64 *ts, time64_t sec, s64 nsec)\n{\n\twhile (nsec >", "4591": "< 0)) {\n\t\tts.tv_sec--;\n\t\trem += nsec_per_sec;\n\t}\n\tts.tv_nsec = rem;\n\n\treturn ts;\n}\nexport_symbol(ns_to_timespec64);\n#endif\n\nunsigned long msecs_to_jiffies(const unsigned int m)\n{\n\t\n\tif ((int)m < 0)\n\t\treturn max_jiffy_offset;\n\n#if hz <= msec_per_sec && !(msec_per_sec % hz)\n\t\n\treturn (m + (msec_per_sec / hz) - 1) / (msec_per_sec / hz);\n#elif hz >", "4592": "< 0)) {\n\t\twarn_on_once(1);\n\t\treturn -etime;\n\t}\n\n\tdev->", "4593": "< 0)) ||\n\t    warn_on(!list_empty(&pool->", "4594": "< 0)))\n\t\treturn;\n#endif\n\t__preempt_count_add(val);\n#ifdef config_debug_preempt\n\t\n\tdebug_locks_warn_on((preempt_count() & preempt_mask) >", "4595": "< 0));\n\n\t\n\tmark_work_canceling(work);\n\tlocal_irq_restore(flags);\n\n\tflush_work(work);\n\tclear_work_data(work);\n\n\t\n\tsmp_mb();\n\tif (waitqueue_active(&cancel_waitq))\n\t\t__wake_up(&cancel_waitq, task_normal, 1, work);\n\n\treturn ret;\n}\n\n\nbool cancel_work_sync(struct work_struct *work)\n{\n\treturn __cancel_work_timer(work, false);\n}\nexport_symbol_gpl(cancel_work_sync);\n\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->", "4596": "< 0);\t\n\t\ttrace_module_put(module, _ret_ip_);\n\t\tpreempt_enable();\n\t}\n}\nexport_symbol(module_put);\n\n#else \nstatic inline void print_unload_info(struct seq_file *m, struct module *mod)\n{\n\t\n\tseq_puts(m, \" - -\");\n}\n\nstatic inline void module_unload_free(struct module *mod)\n{\n}\n\nint ref_module(struct module *a, struct module *b)\n{\n\treturn strong_try_module_get(b);\n}\nexport_symbol_gpl(ref_module);\n\nstatic inline int module_unload_init(struct module *mod)\n{\n\treturn 0;\n}\n#endif \n\nstatic size_t module_flags_taint(struct module *mod, char *buf)\n{\n\tsize_t l = 0;\n\n\tif (mod->", "4597": "< 0);\n\t\t\tif (pwq->", "4598": "< 0);\n\t\t\treturn;  \n\t\t}\n\t}\n\n\t\n\tj = jiffies;\n\taccess_once(rdtp->", "4599": "< 0);\n\t\tif (rdtp->", "4600": "< 0);\n\t\t} else {\n\t\t\tcgroup_init_subsys(ss, false);\n\t\t}\n\n\t\tlist_add_tail(&init_css_set.e_cset_node[ssid],\n\t\t\t      &cgrp_dfl_root.cgrp.e_csets[ssid]);\n\n\t\t\n\t\tif (ss->", "4601": "< 0);\n\tif (oldval & dyntick_task_nest_mask) {\n\t\trdtp->", "4602": "< 0);\n\tif (onoff_holdoff >", "4603": "< 0);\n\tif (rdtp->", "4604": "< 0);\n\tif (ret)\n\t\t\n\t\tret = atomic_add_unless(&mod->", "4605": "< 0);\n\t}\n\n\t\n\tinit_css_set.subsys[ss->", "4606": "< 0);\n\t}\n}\n\n#ifdef config_generic_idle_poll_setup\nstatic int __init cpu_idle_poll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 1;\n\treturn 1;\n}\n__setup(\"nohlt\", cpu_idle_poll_setup);\n\nstatic int __init cpu_idle_nopoll_setup(char *__unused)\n{\n\tcpu_idle_force_poll = 0;\n\treturn 1;\n}\n__setup(\"hlt\", cpu_idle_nopoll_setup);\n#endif\n\nstatic inline int cpu_idle_poll(void)\n{\n\trcu_idle_enter();\n\ttrace_cpu_idle_rcuidle(0, smp_processor_id());\n\tlocal_irq_enable();\n\twhile (!tif_need_resched() &&\n\t\t(cpu_idle_force_poll || tick_check_broadcast_expired()))\n\t\tcpu_relax();\n\ttrace_cpu_idle_rcuidle(pwr_event_exit, smp_processor_id());\n\trcu_idle_exit();\n\treturn 1;\n}\n\n\nvoid __weak arch_cpu_idle_prepare(void) { }\nvoid __weak arch_cpu_idle_enter(void) { }\nvoid __weak arch_cpu_idle_exit(void) { }\nvoid __weak arch_cpu_idle_dead(void) { }\nvoid __weak arch_cpu_idle(void)\n{\n\tcpu_idle_force_poll = 1;\n\tlocal_irq_enable();\n}\n\n\nstatic void cpuidle_idle_call(void)\n{\n\tstruct cpuidle_device *dev = __this_cpu_read(cpuidle_devices);\n\tstruct cpuidle_driver *drv = cpuidle_get_cpu_driver(dev);\n\tint next_state, entered_state;\n\tbool reflect;\n\n\t\n\tif (need_resched()) {\n\t\tlocal_irq_enable();\n\t\treturn;\n\t}\n\n\t\n\tstop_critical_timings();\n\n\t\n\trcu_idle_enter();\n\n\tif (cpuidle_not_available(drv, dev))\n\t\tgoto use_default;\n\n\t\n\tif (idle_should_freeze()) {\n\t\tentered_state = cpuidle_enter_freeze(drv, dev);\n\t\tif (entered_state >", "4607": "< 0);\n\n\t\n\tftrace_hash_ipmodify_disable(ops);\n\tftrace_hash_rec_disable(ops, 1);\n\n\tops->", "4608": "< 0);\n\n\t\n\tif (!(atomic_read(&rdtp->", "4609": "< 0);\n\n\treturn ret;\n}\n#else\nstatic __init int register_trigger_snapshot_cmd(void) { return 0; }\n#endif \n\n#ifdef config_stacktrace\n\n#define stack_skip 3\n\nstatic void\nstacktrace_trigger(struct event_trigger_data *data)\n{\n\ttrace_dump_stack(stack_skip);\n}\n\nstatic void\nstacktrace_count_trigger(struct event_trigger_data *data)\n{\n\tif (!data->", "4610": "< 0);\n\n\treturn ret;\n}\n#else\nstatic __init int register_trigger_stacktrace_cmd(void) { return 0; }\n#endif \n\nstatic __init void unregister_trigger_traceon_traceoff_cmds(void)\n{\n\tunregister_event_command(&trigger_traceon_cmd);\n\tunregister_event_command(&trigger_traceoff_cmd);\n}\n\n\n#define enable_event_str\t\"enable_event\"\n#define disable_event_str\t\"disable_event\"\n\nstruct enable_trigger_data {\n\tstruct ftrace_event_file\t*file;\n\tbool\t\t\t\tenable;\n};\n\nstatic void\nevent_enable_trigger(struct event_trigger_data *data)\n{\n\tstruct enable_trigger_data *enable_data = data->", "4611": "< 0);\n\n\treturn ret;\n}\nexport_symbol_gpl(tracing_alloc_snapshot);\n\n\nvoid tracing_snapshot_alloc(void)\n{\n\tint ret;\n\n\tret = tracing_alloc_snapshot();\n\tif (ret < 0)\n\t\treturn;\n\n\ttracing_snapshot();\n}\nexport_symbol_gpl(tracing_snapshot_alloc);\n#else\nvoid tracing_snapshot(void)\n{\n\twarn_once(1, \"snapshot feature not enabled, but internal snapshot used\");\n}\nexport_symbol_gpl(tracing_snapshot);\nint tracing_alloc_snapshot(void)\n{\n\twarn_once(1, \"snapshot feature not enabled, but snapshot allocation used\");\n\treturn -enodev;\n}\nexport_symbol_gpl(tracing_alloc_snapshot);\nvoid tracing_snapshot_alloc(void)\n{\n\t\n\ttracing_snapshot();\n}\nexport_symbol_gpl(tracing_snapshot_alloc);\n#endif \n\nstatic void tracer_tracing_off(struct trace_array *tr)\n{\n\tif (tr->", "4612": "< 0);\n\n\tspin_lock_irq(&pool->", "4613": "< 0);\n}\n\n\nstatic int workqueue_cpu_up_callback(struct notifier_block *nfb,\n\t\t\t\t\t       unsigned long action,\n\t\t\t\t\t       void *hcpu)\n{\n\tint cpu = (unsigned long)hcpu;\n\tstruct worker_pool *pool;\n\tstruct workqueue_struct *wq;\n\tint pi;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_up_prepare:\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tif (pool->", "4614": "< 0);\n}\nexport_symbol(down_trylock);\n\n\nint down_timeout(struct semaphore *sem, long timeout)\n{\n\tunsigned long flags;\n\tint result = 0;\n\n\traw_spin_lock_irqsave(&sem->", "4615": "< 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->", "4616": "< 0, \"failed to arm kprobe-ftrace at %p (%d)\\n\", p->", "4617": "< 0, \"failed to disarm kprobe-ftrace at %p (%d)\\n\", p->", "4618": "< 0, \"failed to init kprobe-ftrace (%d)\\n\", ret);\n\t}\n}\n\n\nstatic void disarm_kprobe_ftrace(struct kprobe *p)\n{\n\tint ret;\n\n\tkprobe_ftrace_enabled--;\n\tif (kprobe_ftrace_enabled == 0) {\n\t\tret = unregister_ftrace_function(&kprobe_ftrace_ops);\n\t\twarn(ret < 0, \"failed to init kprobe-ftrace (%d)\\n\", ret);\n\t}\n\tret = ftrace_set_filter_ip(&kprobe_ftrace_ops,\n\t\t\t   (unsigned long)p->", "4619": "< 0;\n}\n\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_time_before(a->", "4620": "< 0;\n}\n\nstatic void update_min_vruntime(struct cfs_rq *cfs_rq)\n{\n\tu64 vruntime = cfs_rq->", "4621": "< 0x10000 ? 4 : 8;\n\tint depth;\n\n\tfor (depth = 0, p = r; depth < max_iores_level; depth++, p = p->", "4622": "< 1 << (tvr_bits + 2 * tvn_bits)) {\n\t\tint i = (expires >", "4623": "< 1 << (tvr_bits + 3 * tvn_bits)) {\n\t\tint i = (expires >", "4624": "< 1 << (tvr_bits + tvn_bits)) {\n\t\tint i = (expires >", "4625": "< 1 || (act && sig_kernel_only(sig)))\n\t\treturn -einval;\n\n\tk = &p->", "4626": "< 1 || max_active >", "4627": "< 1)\n\t\t\tse = second;\n\t}\n\n\t\n\tif (cfs_rq->", "4628": "< 1)\n\t\tdelta = 1;\n\tnow += delta;\n\tif (time_before(now, expires))\n\t\treturn now;\n\treturn expires;\n}\n\n\nunsigned long get_next_timer_interrupt(unsigned long now)\n{\n\tstruct tvec_base *base = __this_cpu_read(tvec_bases);\n\tunsigned long expires = now + next_timer_max_delta;\n\n\t\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\tspin_lock(&base->", "4629": "< 1)\n\t\treturn -einval;\n\tdata = kmalloc(len, gfp_kernel);\n\tif (!data)\n\t\treturn -enomem;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}\n\n#if defined(config_64bit) && !defined(config_have_efficient_unaligned_access)\n#define taskstats_needs_padding 1\n#endif\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == taskstats_type_pid)\n\t\t\t? taskstats_type_aggr_pid\n\t\t\t: taskstats_type_aggr_tgid;\n\n\t\n#ifdef taskstats_needs_padding\n\tif (nla_put(skb, taskstats_type_null, 0, null) < 0)\n\t\tgoto err;\n#endif\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve(skb, taskstats_type_stats, sizeof(struct taskstats));\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn null;\n}\n\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct fd f;\n\n\tna = info->", "4630": "< 1)\n\t\treturn -einval;\n\telse if (ret < 2)\n\t\titers = default_iterations;\n\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_usecs = usecs;\n\tudelay_test_iterations = iters;\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn count;\n}\n\nstatic const struct file_operations udelay_test_debugfs_ops = {\n\t.owner = this_module,\n\t.open = udelay_test_open,\n\t.read = seq_read,\n\t.write = udelay_test_write,\n\t.llseek = seq_lseek,\n\t.release = single_release,\n};\n\nstatic int __init udelay_test_init(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tudelay_test_debugfs_file = debugfs_create_file(debugfs_filename,\n\t\t\ts_irusr, null, null, &udelay_test_debugfs_ops);\n\tmutex_unlock(&udelay_test_lock);\n\n\treturn 0;\n}\n\nmodule_init(udelay_test_init);\n\nstatic void __exit udelay_test_exit(void)\n{\n\tmutex_lock(&udelay_test_lock);\n\tdebugfs_remove(udelay_test_debugfs_file);\n\tmutex_unlock(&udelay_test_lock);\n}\n\nmodule_exit(udelay_test_exit);\n\nmodule_author(\"david riley <davidriley@chromium.org>", "4631": "< 1)\n\t\treturn -einval;\n\n\tmemcpy(cmdbuf, buf, count);\n\tcmdbuf[count] = 0;\n\n\tif (sscanf(cmdbuf, \"%d:%d\", &op, &dat) != 2)\n\t\treturn -einval;\n\n\tswitch (op) {\n\tcase rttest_schedot:\n\t\tschedpar.sched_priority = 0;\n\t\tret = sched_setscheduler(threads[tid], sched_normal, &schedpar);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tset_user_nice(current, 0);\n\t\tbreak;\n\n\tcase rttest_schedrt:\n\t\tschedpar.sched_priority = dat;\n\t\tret = sched_setscheduler(threads[tid], sched_fifo, &schedpar);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tbreak;\n\n\tcase rttest_signal:\n\t\tsend_sig(sighup, threads[tid], 0);\n\t\tbreak;\n\n\tdefault:\n\t\tif (td->", "4632": "< 1)\n\t\tse = cfs_rq->", "4633": "< 1) {\n\t\t\t\tj = 1;\n\t\t\t\tjiffies_till_next_fqs = 1;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\trcu_gp_cleanup(rsp);\n\t}\n}\n\n\nstatic bool\nrcu_start_gp_advanced(struct rcu_state *rsp, struct rcu_node *rnp,\n\t\t      struct rcu_data *rdp)\n{\n\tif (!rsp->", "4634": "< 1) {\n\t\ts->", "4635": "< 1)) {\n\t\terr = -einval;\n\t\tgoto exit;\n\t}\n\n\tif (count >", "4636": "< 1);\n\tput_cred(new);\n}\nexport_symbol(abort_creds);\n\n\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->", "4637": "< 1);\n\n\tget_cred(new); \n\n\t\n\tif (!uid_eq(old->", "4638": "< 1);\n}\n\nstatic const struct fsnotify_ops audit_tree_ops = {\n\t.handle_event = audit_tree_handle_event,\n\t.freeing_mark = audit_tree_freeing_mark,\n};\n\nstatic int __init audit_tree_init(void)\n{\n\tint i;\n\n\taudit_tree_group = fsnotify_alloc_group(&audit_tree_ops);\n\tif (is_err(audit_tree_group))\n\t\taudit_panic(\"cannot initialize fsnotify group for rectree watches\");\n\n\tfor (i = 0; i < hash_size; i++)\n\t\tinit_list_head(&chunk_hash_heads[i]);\n\n\treturn 0;\n}\n__initcall(audit_tree_init);\n\n#include <linux/bpf.h>", "4639": "< 10 &&\n\t\t    (local_softirq_pending() & softirq_stop_idle_mask)) {\n\t\t\tpr_warn(\"nohz: local_softirq_pending %02x\\n\",\n\t\t\t\t(unsigned int) local_softirq_pending());\n\t\t\tratelimit++;\n\t\t}\n\t\treturn false;\n\t}\n\n\tif (tick_nohz_full_enabled()) {\n\t\t\n\t\tif (tick_do_timer_cpu == cpu)\n\t\t\treturn false;\n\t\t\n\t\tif (tick_do_timer_cpu == tick_do_timer_none)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nstatic void __tick_nohz_idle_enter(struct tick_sched *ts)\n{\n\tktime_t now, expires;\n\tint cpu = smp_processor_id();\n\n\tnow = tick_nohz_start_idle(ts);\n\n\tif (can_stop_idle_tick(cpu, ts)) {\n\t\tint was_stopped = ts->", "4640": "< 10 && j <= nr_irqs; ++prec)\n\t\t\tj *= 10;\n\n\t\tseq_printf(p, \"%*s\", prec + 8, \"\");\n\t\tfor_each_online_cpu(j)\n\t\t\tseq_printf(p, \"cpu%-8d\", j);\n\t\tseq_putc(p, '\\n');\n\t}\n\n\tirq_lock_sparse();\n\tdesc = irq_to_desc(i);\n\tif (!desc)\n\t\tgoto outsparse;\n\n\traw_spin_lock_irqsave(&desc->", "4641": "< 10 && last_seed != seed);\n\n\t\tstd = seed;\n\t}\n\n\tscnprintf(bm_str, benchmark_event_strlen,\n\t\t  \"last=%llu first=%llu max=%llu min=%llu avg=%u std=%d std^2=%lld\",\n\t\t  bm_last, bm_first, bm_max, bm_min, avg, std, stddev);\n\n\tbm_std = std;\n\tbm_avg = avg;\n\tbm_stddev = stddev;\n}\n\nstatic int benchmark_event_kthread(void *arg)\n{\n\t\n\tmsleep(100);\n\n\twhile (!kthread_should_stop()) {\n\n\t\ttrace_do_benchmark();\n\n\t\t\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}\n\n\nvoid trace_benchmark_reg(void)\n{\n\tbm_event_thread = kthread_run(benchmark_event_kthread,\n\t\t\t\t      null, \"event_benchmark\");\n\twarn_on(!bm_event_thread);\n}\n\n\nvoid trace_benchmark_unreg(void)\n{\n\tif (!bm_event_thread)\n\t\treturn;\n\n\tkthread_stop(bm_event_thread);\n\n\tstrcpy(bm_str, \"start\");\n\tbm_total = 0;\n\tbm_totalsq = 0;\n\tbm_last = 0;\n\tbm_max = 0;\n\tbm_min = 0;\n\tbm_cnt = 0;\n\t\n\tbm_first = 0;\n\tbm_std = 0;\n\tbm_avg = 0;\n\tbm_stddev = 0;\n}\n\n#include <linux/proc_fs.h>", "4642": "< 10) {\n\t\t\tudelay(trycount * num_online_cpus());\n\t\t} else {\n\t\t\tput_online_cpus();\n\t\t\twait_rcu_gp(call_rcu);\n\t\t\treturn;\n\t\t}\n\t}\n\tif (ulong_cmp_lt(snap, access_once(sync_rcu_preempt_exp_count))) {\n\t\tput_online_cpus();\n\t\tgoto unlock_mb_ret; \n\t}\n\n\t\n\tsynchronize_sched_expedited();\n\n\t\n\trcu_for_each_leaf_node(rsp, rnp)\n\t\tsync_rcu_preempt_exp_init1(rsp, rnp);\n\trcu_for_each_leaf_node(rsp, rnp)\n\t\tsync_rcu_preempt_exp_init2(rsp, rnp);\n\n\tput_online_cpus();\n\n\t\n\trnp = rcu_get_root(rsp);\n\twait_event(sync_rcu_preempt_exp_wq,\n\t\t   sync_rcu_preempt_exp_done(rnp));\n\n\t\n\tsmp_mb(); \n\taccess_once(sync_rcu_preempt_exp_count) =\n\t\t\t\t\tsync_rcu_preempt_exp_count + 1;\nunlock_mb_ret:\n\tmutex_unlock(&sync_rcu_preempt_exp_mutex);\nmb_ret:\n\tsmp_mb(); \n}\nexport_symbol_gpl(synchronize_rcu_expedited);\n\n\nvoid rcu_barrier(void)\n{\n\t_rcu_barrier(&rcu_preempt_state);\n}\nexport_symbol_gpl(rcu_barrier);\n\n\nstatic void __init __rcu_init_preempt(void)\n{\n\trcu_init_one(&rcu_preempt_state, &rcu_preempt_data);\n}\n\n\nvoid exit_rcu(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (likely(list_empty(&current->", "4643": "< 10) {\n\t\t\tudelay(trycount * num_online_cpus());\n\t\t} else {\n\t\t\twait_rcu_gp(call_rcu_sched);\n\t\t\tatomic_long_inc(&rsp->", "4644": "< 100000))\n\t\treturn;\n\n\tdesc->", "4645": "< 10; spincnt++) {\n\t\ttrace_rcu_utilization(tps(\"start cpu kthread@rcu_wait\"));\n\t\tlocal_bh_disable();\n\t\t*statusp = rcu_kthread_running;\n\t\tthis_cpu_inc(rcu_cpu_kthread_loops);\n\t\tlocal_irq_disable();\n\t\twork = *workp;\n\t\t*workp = 0;\n\t\tlocal_irq_enable();\n\t\tif (work)\n\t\t\trcu_kthread_do_work();\n\t\tlocal_bh_enable();\n\t\tif (*workp == 0) {\n\t\t\ttrace_rcu_utilization(tps(\"end cpu kthread@rcu_wait\"));\n\t\t\t*statusp = rcu_kthread_waiting;\n\t\t\treturn;\n\t\t}\n\t}\n\t*statusp = rcu_kthread_yielding;\n\ttrace_rcu_utilization(tps(\"start cpu kthread@rcu_yield\"));\n\tschedule_timeout_interruptible(2);\n\ttrace_rcu_utilization(tps(\"end cpu kthread@rcu_yield\"));\n\t*statusp = rcu_kthread_waiting;\n}\n\n\nstatic void rcu_boost_kthread_setaffinity(struct rcu_node *rnp, int outgoingcpu)\n{\n\tstruct task_struct *t = rnp->", "4646": "< 128 || log_size >", "4647": "< 16 && !(desc->", "4648": "< 16 && !env->", "4649": "< 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->", "4650": "< 2 && rq->", "4651": "< 2 ? 2 : trycount;\n\tif (!try_check_zero(sp, idx^1, trycount))\n\t\treturn; \n\n\t\n\trcu_batch_move(&sp->", "4652": "< 2 ||\n\t     curr->", "4653": "< 2 ||\n\t     rq->", "4654": "< 2)\n\t\tnr_pages = 2;\n\n\t\n#ifdef config_hotplug_cpu\n\tcpu_notifier_register_begin();\n\tcpumask_copy(buffer->", "4655": "< 2)\n\t\treturn 0;\n\n\tif (!irq)\n\t\treturn 1;\n\n\t\n\taction = desc->", "4656": "< 2)\n\t\treturn kdb_argcount;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, null);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg >", "4657": "< 2) {\n\t\tpr_info(\"probe point is not specified.\\n\");\n\t\treturn -einval;\n\t}\n\tif (isdigit(argv[1][0])) {\n\t\tif (is_return) {\n\t\t\tpr_info(\"return probe point must be a symbol.\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t\t\n\t\tret = kstrtoul(&argv[1][0], 0, (unsigned long *)&addr);\n\t\tif (ret) {\n\t\t\tpr_info(\"failed to parse address.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t} else {\n\t\t\n\t\tsymbol = argv[1];\n\t\t\n\t\tret = traceprobe_split_symbol_offset(symbol, &offset);\n\t\tif (ret) {\n\t\t\tpr_info(\"failed to parse symbol.\\n\");\n\t\t\treturn ret;\n\t\t}\n\t\tif (offset && is_return) {\n\t\t\tpr_info(\"return probe must be used without offset.\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t}\n\targc -= 2; argv += 2;\n\n\t\n\tif (!event) {\n\t\t\n\t\tif (symbol)\n\t\t\tsnprintf(buf, max_event_name_len, \"%c_%s_%ld\",\n\t\t\t\t is_return ? 'r' : 'p', symbol, offset);\n\t\telse\n\t\t\tsnprintf(buf, max_event_name_len, \"%c_0x%p\",\n\t\t\t\t is_return ? 'r' : 'p', addr);\n\t\tevent = buf;\n\t}\n\ttk = alloc_trace_kprobe(group, event, addr, symbol, offset, argc,\n\t\t\t       is_return);\n\tif (is_err(tk)) {\n\t\tpr_info(\"failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)ptr_err(tk));\n\t\treturn ptr_err(tk);\n\t}\n\n\t\n\tret = 0;\n\tfor (i = 0; i < argc && i < max_trace_args; i++) {\n\t\tstruct probe_arg *parg = &tk->", "4658": "< 2) {\n\t\tpr_info(\"probe point is not specified.\\n\");\n\t\treturn -einval;\n\t}\n\tif (isdigit(argv[1][0])) {\n\t\tpr_info(\"probe point must be have a filename.\\n\");\n\t\treturn -einval;\n\t}\n\targ = strchr(argv[1], ':');\n\tif (!arg) {\n\t\tret = -einval;\n\t\tgoto fail_address_parse;\n\t}\n\n\t*arg++ = '\\0';\n\tfilename = argv[1];\n\tret = kern_path(filename, lookup_follow, &path);\n\tif (ret)\n\t\tgoto fail_address_parse;\n\n\tinode = igrab(d_inode(path.dentry));\n\tpath_put(&path);\n\n\tif (!inode || !s_isreg(inode->", "4659": "< 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tbug_on(atomic_read(&new->", "4660": "< 256 ? hash_small : 0,\n\t\t\t\t\t       &futex_shift, null,\n\t\t\t\t\t       futex_hashsize, futex_hashsize);\n\tfutex_hashsize = 1ul << futex_shift;\n\n\tfutex_detect_cmpxchg();\n\n\tfor (i = 0; i < futex_hashsize; i++) {\n\t\tatomic_set(&futex_queues[i].waiters, 0);\n\t\tplist_head_init(&futex_queues[i].chain);\n\t\tspin_lock_init(&futex_queues[i].lock);\n\t}\n\n\treturn 0;\n}\n__initcall(futex_init);\n\n\n\n\n#include <linux/compiler.h>", "4661": "< 256)\n\t\t\treturn expires;\n\n\t\texpires_limit = expires + delta / 256;\n\t}\n\tmask = expires ^ expires_limit;\n\tif (mask == 0)\n\t\treturn expires;\n\n\tbit = find_last_bit(&mask, bits_per_long);\n\n\tmask = (1ul << bit) - 1;\n\n\texpires_limit = expires_limit & ~(mask);\n\n\treturn expires_limit;\n}\n\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\texpires = apply_slack(timer, expires);\n\n\t\n\tif (timer_pending(timer) && timer->", "4662": "< 2; i++) {\n\t\t\tunsigned long nr_faults = -1;\n\t\t\tint cpu_current, home_node;\n\n\t\t\tif (p->", "4663": "< 3) {\n\t\taccess_once(rcu_cpu_stall_timeout) = 3;\n\t\ttill_stall_check = 3;\n\t} else if (till_stall_check >", "4664": "< 31; n++)\n\t\t\tif (audit_tree_match(p->", "4665": "< 32)\n\t\t\t\t\tmask |= 1 << i;\n\t\t}\n\t\traw_spin_unlock_irq(&desc->", "4666": "< 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tcmd_buflen);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tcmd_buflen);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % kdb_cmd_history_count;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % kdb_cmd_history_count;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == kdb_notfound) {\n\t\t\tkdb_printf(\"unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == kdb_cmd_go\n\t\t || diag == kdb_cmd_cpu\n\t\t || diag == kdb_cmd_ss\n\t\t || diag == kdb_cmd_kgdb)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tkdb_debug_state(\"kdb_local 9\", diag);\n\treturn diag;\n}\n\n\n\nvoid kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}\n\n\nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t\n\twhile (1) {\n\t\t\n\t\tkdb_debug_state(\"kdb_main_loop 1\", reason);\n\t\twhile (kdb_state(hold_cpu)) {\n\t\t\t\n\t\t\tif (!kdb_state(kdb))\n\t\t\t\tkdb_state_set(kdb);\n\t\t}\n\n\t\tkdb_state_clear(suppress);\n\t\tkdb_debug_state(\"kdb_main_loop 2\", reason);\n\t\tif (kdb_state(leaving))\n\t\t\tbreak;\t\n\t\t\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tkdb_debug_state(\"kdb_main_loop 3\", result);\n\n\t\tif (result == kdb_cmd_cpu)\n\t\t\tbreak;\n\n\t\tif (result == kdb_cmd_ss) {\n\t\t\tkdb_state_set(doing_ss);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == kdb_cmd_kgdb) {\n\t\t\tif (!kdb_state(doing_kgdb))\n\t\t\t\tkdb_printf(\"entering please attach debugger \"\n\t\t\t\t\t   \"or use $d#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != kdb_cmd_go)\n\t\t\tkdb_printf(\"\\nunexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tkdb_debug_state(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (kdb_state(doing_ss))\n\t\tkdb_state_clear(ssbpt);\n\n\t\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}\n\n\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}\n\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__big_endian\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}\n\nstatic int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = kdb_word_size, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\n\tkdbgetintenv(\"mdcount\", &mdcount);\n\tkdbgetintenv(\"radix\", &radix);\n\tkdbgetintenv(\"bytesperword\", &bytesperword);\n\n\t\n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc != 2)\n\t\t\treturn kdb_argcount;\n\t\tvalid = 1;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn kdb_notfound;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn kdb_argcount;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, null);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc >", "4667": "< 32; bin++) {\n\t\tif (sleep_time_bin[bin] == 0)\n\t\t\tcontinue;\n\t\tseq_printf(s, \"%10u - %-10u %4u\\n\",\n\t\t\tbin ? 1 << (bin - 1) : 0, 1 << bin,\n\t\t\t\tsleep_time_bin[bin]);\n\t}\n\treturn 0;\n}\n\nstatic int tk_debug_sleep_time_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, tk_debug_show_sleep_time, null);\n}\n\nstatic const struct file_operations tk_debug_sleep_time_fops = {\n\t.open\t\t= tk_debug_sleep_time_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init tk_debug_sleep_time_init(void)\n{\n\tstruct dentry *d;\n\n\td = debugfs_create_file(\"sleep_time\", 0444, null, null,\n\t\t&tk_debug_sleep_time_fops);\n\tif (!d) {\n\t\tpr_err(\"failed to create sleep_time debug file\\n\");\n\t\treturn -enomem;\n\t}\n\n\treturn 0;\n}\nlate_initcall(tk_debug_sleep_time_init);\n\nvoid tk_debug_account_sleep_time(struct timespec64 *t)\n{\n\tsleep_time_bin[fls(t->", "4668": "< 34\n#define jiffies_shift\t6\n#elif hz < 67\n#define jiffies_shift\t7\n#else\n#define jiffies_shift\t8\n#endif\n\nstatic cycle_t jiffies_read(struct clocksource *cs)\n{\n\treturn (cycle_t) jiffies;\n}\n\nstatic struct clocksource clocksource_jiffies = {\n\t.name\t\t= \"jiffies\",\n\t.rating\t\t= 1, \n\t.read\t\t= jiffies_read,\n\t.mask\t\t= 0xffffffff, \n\t.mult\t\t= nsec_per_jiffy << jiffies_shift, \n\t.shift\t\t= jiffies_shift,\n\t.max_cycles\t= 10,\n};\n\n__cacheline_aligned_in_smp define_seqlock(jiffies_lock);\n\n#if (bits_per_long < 64)\nu64 get_jiffies_64(void)\n{\n\tunsigned long seq;\n\tu64 ret;\n\n\tdo {\n\t\tseq = read_seqbegin(&jiffies_lock);\n\t\tret = jiffies_64;\n\t} while (read_seqretry(&jiffies_lock, seq));\n\treturn ret;\n}\nexport_symbol(get_jiffies_64);\n#endif\n\nexport_symbol(jiffies);\n\nstatic int __init init_jiffies_clocksource(void)\n{\n\treturn __clocksource_register(&clocksource_jiffies);\n}\n\ncore_initcall(init_jiffies_clocksource);\n\nstruct clocksource * __init __weak clocksource_default_clock(void)\n{\n\treturn &clocksource_jiffies;\n}\n\nstruct clocksource refined_jiffies;\n\nint register_refined_jiffies(long cycles_per_second)\n{\n\tu64 nsec_per_tick, shift_hz;\n\tlong cycles_per_tick;\n\n\n\n\trefined_jiffies = clocksource_jiffies;\n\trefined_jiffies.name = \"refined-jiffies\";\n\trefined_jiffies.rating++;\n\n\t\n\tcycles_per_tick = (cycles_per_second + hz/2)/hz;\n\t\n\tshift_hz = (u64)cycles_per_second << 8;\n\tshift_hz += cycles_per_tick/2;\n\tdo_div(shift_hz, cycles_per_tick);\n\t\n\tnsec_per_tick = (u64)nsec_per_sec << 8;\n\tnsec_per_tick += (u32)shift_hz/2;\n\tdo_div(nsec_per_tick, (u32)shift_hz);\n\n\trefined_jiffies.mult = ((u32)nsec_per_tick) << jiffies_shift;\n\n\t__clocksource_register(&refined_jiffies);\n\treturn 0;\n}\n\n\n#define pr_fmt(fmt) \"genirq: \" fmt\n\n#include <linux/irq.h>", "4669": "< 3; i++) {\n\t\tdo {\n\t\t\tif (rb_is_head_page(cpu_buffer, page, page->", "4670": "< 3; loop++) {\n\t\tch = buffer[loop];\n\t\tchecksum += ch;\n\t\tdbg_io_ops->", "4671": "< 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, gfp_atomic);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->", "4672": "< 4; array++) {\n\t\tstruct tvec *varp = varray[array];\n\n\t\tindex = slot = timer_jiffies & tvn_mask;\n\t\tdo {\n\t\t\tlist_for_each_entry(nte, varp->", "4673": "< 5) {\n\t\t\tprintk(kern_err\n\t\t\t       \"request_module: runaway loop modprobe %s\\n\",\n\t\t\t       module_name);\n\t\t\tkmod_loop_msg++;\n\t\t}\n\t\tatomic_dec(&kmod_concurrent);\n\t\treturn -enomem;\n\t}\n\n\ttrace_module_request(module_name, wait, _ret_ip_);\n\n\tret = call_modprobe(module_name, wait ? umh_wait_proc : umh_wait_exec);\n\n\tatomic_dec(&kmod_concurrent);\n\treturn ret;\n}\nexport_symbol(__request_module);\n#endif \n\nstatic void call_usermodehelper_freeinfo(struct subprocess_info *info)\n{\n\tif (info->", "4674": "< 5000)\n\t\tdev->", "4675": "< 64\n\tif (seconds >", "4676": "< 64\n\treturn rlim64 >", "4677": "< 7) {\n\t\tsize_t slen = min_t(size_t, sizeof(nsecs_str), 8ul - len);\n\n\t\tsnprintf(nsecs_str, slen, \"%03lu\", nsecs_rem);\n\t\ttrace_seq_printf(s, \".%s\", nsecs_str);\n\t\tlen += strlen(nsecs_str);\n\t}\n\n\ttrace_seq_puts(s, \" us \");\n\n\t\n\tfor (i = len; i < 7; i++)\n\t\ttrace_seq_putc(s, ' ');\n}\n\nstatic void\nprint_graph_duration(unsigned long long duration, struct trace_seq *s,\n\t\t     u32 flags)\n{\n\tif (!(flags & trace_graph_print_duration) ||\n\t    !(trace_flags & trace_iter_context_info))\n\t\treturn;\n\n\t\n\tswitch (flags & trace_graph_print_fill_mask) {\n\tcase flags_fill_full:\n\t\ttrace_seq_puts(s, \"              |  \");\n\t\treturn;\n\tcase flags_fill_start:\n\t\ttrace_seq_puts(s, \"  \");\n\t\treturn;\n\tcase flags_fill_end:\n\t\ttrace_seq_puts(s, \" |\");\n\t\treturn;\n\t}\n\n\t\n\tif (flags & trace_graph_print_overhead)\n\t\ttrace_seq_printf(s, \"%c \", trace_find_mark(duration));\n\telse\n\t\ttrace_seq_puts(s, \"  \");\n\n\ttrace_print_graph_duration(duration, s);\n\ttrace_seq_puts(s, \"|  \");\n}\n\n\nstatic enum print_line_t\nprint_graph_entry_leaf(struct trace_iterator *iter,\n\t\tstruct ftrace_graph_ent_entry *entry,\n\t\tstruct ftrace_graph_ret_entry *ret_entry,\n\t\tstruct trace_seq *s, u32 flags)\n{\n\tstruct fgraph_data *data = iter->", "4678": "< 7; i++) {\n\t\tpci_resource_to_user(dev, i, &dev->", "4679": "< 8 * usec_per_msec)\n\t\t\tsleep_usecs *= 2;\n\t}\n\n\tdo_gettimeofday(&end);\n\telapsed_msecs64 = timeval_to_ns(&end) - timeval_to_ns(&start);\n\tdo_div(elapsed_msecs64, nsec_per_msec);\n\telapsed_msecs = elapsed_msecs64;\n\n\tif (todo) {\n\t\tpr_cont(\"\\n\");\n\t\tpr_err(\"freezing of tasks %s after %d.%03d seconds \"\n\t\t       \"(%d tasks refusing to freeze, wq_busy=%d):\\n\",\n\t\t       wakeup ? \"aborted\" : \"failed\",\n\t\t       elapsed_msecs / 1000, elapsed_msecs % 1000,\n\t\t       todo - wq_busy, wq_busy);\n\n\t\tif (!wakeup) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tfor_each_process_thread(g, p) {\n\t\t\t\tif (p != current && !freezer_should_skip(p)\n\t\t\t\t    && freezing(p) && !frozen(p))\n\t\t\t\t\tsched_show_task(p);\n\t\t\t}\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\t} else {\n\t\tpr_cont(\"(elapsed %d.%03d seconds) \", elapsed_msecs / 1000,\n\t\t\telapsed_msecs % 1000);\n\t}\n\n\treturn todo ? -ebusy : 0;\n}\n\n\nint freeze_processes(void)\n{\n\tint error;\n\n\terror = __usermodehelper_disable(umh_freezing);\n\tif (error)\n\t\treturn error;\n\n\t\n\tcurrent->", "4680": "< __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n\n\tif (kdb_debug(mask))\n\t\tkdb_printf(\"kdbflags=0x%x\\n\", kdb_flags);\n\n\treturn 0;\n}\n\n#ifdef config_printk\n\nstatic int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dumper dumper = { .active = 1 };\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc >", "4681": "< __stop___modver; p++) {\n\t\tconst struct module_version_attribute *vattr = *p;\n\n\t\tmk = locate_module_kobject(vattr->", "4682": "< __stop___param; kp++) {\n\t\tchar *dot;\n\n\t\tif (kp->", "4683": "< _kernel_capability_u32s; i++)  {\n\t\tif (table->", "4684": "< _nsig; ++i)\n\t\tt->", "4685": "< _nsig_words; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_nsig_bpw + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _nsig_bpw + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t\n\t\tbreak;\n\t}\n\n\treturn sig;\n}\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic define_ratelimit_state(ratelimit_state, 5 * hz, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tprintk(kern_info \"%s/%d: reached rlimit_sigpending, dropped signal %d\\n\",\n\t\t\t\tcurrent->", "4686": "< a->", "4687": "< active ; i++)\n\t\tvfree(info->", "4688": "< active ; i++) {\n\t\tstruct gcov_ctr_info *ctr = &info->", "4689": "< active->", "4690": "< active; ct_idx++) {\n\n\t\t\tcv_size = sizeof(gcov_type) * sci_ptr->", "4691": "< active; ct_idx++, ci_ptr++)\n\t\t\tvfree(ci_ptr->", "4692": "< addr)\n\t\t\tcontinue;\n\t\tif (p->", "4693": "< addr)\n\t\t\tcontinue;\n\t\tif (pfn_down(p->", "4694": "< alarm_numtype; i++) {\n\t\tstruct alarm_base *base = &alarm_bases[i];\n\t\tstruct timerqueue_node *next;\n\t\tktime_t delta;\n\n\t\tspin_lock_irqsave(&base->", "4695": "< alarm_numtype; i++) {\n\t\ttimerqueue_init_head(&alarm_bases[i].timerqueue);\n\t\tspin_lock_init(&alarm_bases[i].lock);\n\t}\n\n\terror = alarmtimer_rtc_interface_setup();\n\tif (error)\n\t\treturn error;\n\n\terror = platform_driver_register(&alarmtimer_driver);\n\tif (error)\n\t\tgoto out_if;\n\n\tpdev = platform_device_register_simple(\"alarmtimer\", -1, null, 0);\n\tif (is_err(pdev)) {\n\t\terror = ptr_err(pdev);\n\t\tgoto out_drv;\n\t}\n\tws = wakeup_source_register(\"alarmtimer\");\n\treturn 0;\n\nout_drv:\n\tplatform_driver_unregister(&alarmtimer_driver);\nout_if:\n\talarmtimer_rtc_interface_remove();\n\treturn error;\n}\ndevice_initcall(alarmtimer_init);\n\n#include <linux/completion.h>", "4696": "< align)\n\t\t\t\tbuf_align = align;\n\t\t\tbuf_sz = align(buf_sz, align);\n\t\t\tbuf_sz += sechdrs[i].sh_size;\n\t\t} else {\n\t\t\t\n\t\t\tif (bss_align < align)\n\t\t\t\tbss_align = align;\n\t\t\tbss_sz = align(bss_sz, align);\n\t\t\tbss_sz += sechdrs[i].sh_size;\n\t\t}\n\t}\n\n\t\n\tbss_pad = 0;\n\tif (buf_sz & (bss_align - 1))\n\t\tbss_pad = bss_align - (buf_sz & (bss_align - 1));\n\n\tmemsz = buf_sz + bss_pad + bss_sz;\n\n\t\n\tpurgatory_buf = vzalloc(buf_sz);\n\tif (!purgatory_buf) {\n\t\tret = -enomem;\n\t\tgoto out;\n\t}\n\n\tif (buf_align < bss_align)\n\t\tbuf_align = bss_align;\n\n\t\n\tret = kexec_add_buffer(image, purgatory_buf, buf_sz, memsz,\n\t\t\t\tbuf_align, min, max, top_down,\n\t\t\t\t&pi->", "4697": "< alloc) {\n\t\t\n\t\talloc -= pages;\n\t\tpages += pages_highmem;\n\t\tpages_highmem = preallocate_image_highmem(alloc);\n\t\tif (pages_highmem < alloc)\n\t\t\tgoto err_out;\n\t\tpages += pages_highmem;\n\t\t\n\t\talloc = (count - pages) - size;\n\t\tpages += preallocate_image_highmem(alloc);\n\t} else {\n\t\t\n\t\talloc = max_size - size;\n\t\tsize = preallocate_highmem_fraction(alloc, highmem, count);\n\t\tpages_highmem += size;\n\t\talloc -= size;\n\t\tsize = preallocate_image_memory(alloc, avail_normal);\n\t\tpages_highmem += preallocate_image_highmem(alloc - size);\n\t\tpages += pages_highmem + size;\n\t}\n\n\t\n\tpages -= free_unnecessary_pages();\n\n out:\n\tstop = ktime_get();\n\tprintk(kern_cont \"done (allocated %lu pages)\\n\", pages);\n\tswsusp_show_speed(start, stop, pages, \"allocated\");\n\n\treturn 0;\n\n err_out:\n\tprintk(kern_cont \"\\n\");\n\tswsusp_free();\n\treturn -enomem;\n}\n\n#ifdef config_highmem\n\n\nstatic unsigned int count_pages_for_highmem(unsigned int nr_highmem)\n{\n\tunsigned int free_highmem = count_free_highmem_pages() + alloc_highmem;\n\n\tif (free_highmem >", "4698": "< arg.nr; ) {\n\t\tsiginfo_t info;\n\t\ts32 off = arg.off + i;\n\n\t\tspin_lock_irq(&child->", "4699": "< argc && i < max_trace_args; i++) {\n\t\tstruct probe_arg *parg = &tu->", "4700": "< array_size(arr); i++) {\n\t\tfor (s = arr[i].sym; s < arr[i].sym + arr[i].num; s++) {\n\t\t\tif (find_symbol(s->", "4701": "< array_size(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >", "4702": "< array_size(kdb_name_table); ++i) {\n\t\tif (kdb_name_table[i]) {\n\t\t\tdebug_kfree(kdb_name_table[i]);\n\t\t\tkdb_name_table[i] = null;\n\t\t}\n\t}\n}\n\nstatic char ks_namebuf[ksym_name_len+1], ks_namebuf_prev[ksym_name_len+1];\n\n\nint kallsyms_symbol_complete(char *prefix_name, int max_len)\n{\n\tloff_t pos = 0;\n\tint prefix_len = strlen(prefix_name), prev_len = 0;\n\tint i, number = 0;\n\tconst char *name;\n\n\twhile ((name = kdb_walk_kallsyms(&pos))) {\n\t\tif (strncmp(name, prefix_name, prefix_len) == 0) {\n\t\t\tstrcpy(ks_namebuf, name);\n\t\t\t\n\t\t\tif (++number == 1) {\n\t\t\t\tprev_len = min_t(int, max_len-1,\n\t\t\t\t\t\t strlen(ks_namebuf));\n\t\t\t\tmemcpy(ks_namebuf_prev, ks_namebuf, prev_len);\n\t\t\t\tks_namebuf_prev[prev_len] = '\\0';\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (i = 0; i < prev_len; i++) {\n\t\t\t\tif (ks_namebuf[i] != ks_namebuf_prev[i]) {\n\t\t\t\t\tprev_len = i;\n\t\t\t\t\tks_namebuf_prev[i] = '\\0';\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (prev_len >", "4703": "< array_size(mask_maps); i++) {\n\t\t\tif (strcasecmp(token, mask_maps[i].str) == 0) {\n\t\t\t\tmask |= mask_maps[i].mask;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == array_size(mask_maps)) {\n\t\t\tmask = -einval;\n\t\t\tbreak;\n\t\t}\n\t}\n\tkfree(buf);\n\n\treturn mask;\n}\n\nstatic ssize_t blk_trace_mask2str(char *buf, int mask)\n{\n\tint i;\n\tchar *p = buf;\n\n\tfor (i = 0; i < array_size(mask_maps); i++) {\n\t\tif (mask & mask_maps[i].mask) {\n\t\t\tp += sprintf(p, \"%s%s\",\n\t\t\t\t    (p == buf) ? \"\" : \",\", mask_maps[i].str);\n\t\t}\n\t}\n\t*p++ = '\\n';\n\n\treturn p - buf;\n}\n\nstatic struct request_queue *blk_trace_get_queue(struct block_device *bdev)\n{\n\tif (bdev->", "4704": "< array_size(masks); ++m) {\n\t\tfor (i = 0; i < info->", "4705": "< array_size(offsets); i++) {\n\t\tu64 val = *(u64 *)((char *)prctl_map + offsets[i]);\n\n\t\tif ((unsigned long)val >", "4706": "< array_size(reserved_field_names); i++)\n\t\tif (strcmp(reserved_field_names[i], name) == 0)\n\t\t\treturn 1;\n\n\tfor (i = 0; i < narg; i++)\n\t\tif (strcmp(args[i].name, name) == 0)\n\t\t\treturn 1;\n\n\treturn 0;\n}\n\nvoid traceprobe_update_arg(struct probe_arg *arg)\n{\n\tif (check_fetch_funcs(bitfield, arg->", "4707": "< array_size(stats.bounces); i++)\n\t\t\tstats.bounces[i] += pcs->", "4708": "< array_size(stats.contending_point); i++)\n\t\t\tstats.contending_point[i] += pcs->", "4709": "< array_size(stats.contention_point); i++)\n\t\t\tstats.contention_point[i] += pcs->", "4710": "< array_size(tnts); i++) {\n\t\t\tconst struct tnt *t = &tnts[i];\n\t\t\t*s++ = test_bit(t->", "4711": "< array_size(torture_ops); i++)\n\t\t\tpr_alert(\" %s\", torture_ops[i]->", "4712": "< array_size(torture_ops); i++) {\n\t\tcur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cur_ops->", "4713": "< arrsize; j++) {\n\t\tif (fn(&arr[j], owner, data))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nbool each_symbol_section(bool (*fn)(const struct symsearch *arr,\n\t\t\t\t    struct module *owner,\n\t\t\t\t    void *data),\n\t\t\t void *data)\n{\n\tstruct module *mod;\n\tstatic const struct symsearch arr[] = {\n\t\t{ __start___ksymtab, __stop___ksymtab, __start___kcrctab,\n\t\t  not_gpl_only, false },\n\t\t{ __start___ksymtab_gpl, __stop___ksymtab_gpl,\n\t\t  __start___kcrctab_gpl,\n\t\t  gpl_only, false },\n\t\t{ __start___ksymtab_gpl_future, __stop___ksymtab_gpl_future,\n\t\t  __start___kcrctab_gpl_future,\n\t\t  will_be_gpl_only, false },\n#ifdef config_unused_symbols\n\t\t{ __start___ksymtab_unused, __stop___ksymtab_unused,\n\t\t  __start___kcrctab_unused,\n\t\t  not_gpl_only, true },\n\t\t{ __start___ksymtab_unused_gpl, __stop___ksymtab_unused_gpl,\n\t\t  __start___kcrctab_unused_gpl,\n\t\t  gpl_only, true },\n#endif\n\t};\n\n\tif (each_symbol_in_section(arr, array_size(arr), null, fn, data))\n\t\treturn true;\n\n\tlist_for_each_entry_rcu(mod, &modules, list) {\n\t\tstruct symsearch arr[] = {\n\t\t\t{ mod->", "4714": "< attr->", "4715": "< audit_backlog_limit))\n\t\tskb_queue_tail(&audit_skb_hold_queue, skb);\n\telse\n\t\tkfree_skb(skb);\n}\n\n\nstatic void audit_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->", "4716": "< audit_bad && audit_ops[n] != op; n++)\n\t\t;\n\treturn n;\n}\n\n\nstatic int audit_field_valid(struct audit_entry *entry, struct audit_field *f)\n{\n\tswitch(f->", "4717": "< audit_bitmask_size; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}\n\nstatic int audit_match_signal(struct audit_entry *entry)\n{\n\tstruct audit_field *arch = entry->", "4718": "< audit_bitmask_size; i++)\n\t\tentry->", "4719": "< audit_bitmask_size; i++)\n\t\tif (a->", "4720": "< audit_bitmask_size; i++)\n\t\tnew->", "4721": "< audit_bitmask_size; i++) data->", "4722": "< audit_bitmask_size; j++)\n\t\t\t\tentry->", "4723": "< audit_inode_buckets; h++) {\n\t\t\tlist = &audit_inode_hash[h];\n\t\t\tlist_for_each_entry(e, list, list)\n\t\t\t\tif (!audit_compare_rule(&entry->", "4724": "< audit_inode_buckets; i++)\n\t\tinit_list_head(&audit_inode_hash[i]);\n\n\treturn 0;\n}\n__initcall(audit_init);\n\n\nstatic int __init audit_enable(char *str)\n{\n\taudit_default = !!simple_strtol(str, null, 0);\n\tif (!audit_default)\n\t\taudit_initialized = audit_disabled;\n\n\tpr_info(\"%s\\n\", audit_default ?\n\t\t\"enabled (after initialization)\" : \"disabled (until reboot)\");\n\n\treturn 1;\n}\n__setup(\"audit=\", audit_enable);\n\n\nstatic int __init audit_backlog_limit_set(char *str)\n{\n\tu32 audit_backlog_limit_arg;\n\n\tpr_info(\"audit_backlog_limit: \");\n\tif (kstrtouint(str, 0, &audit_backlog_limit_arg)) {\n\t\tpr_cont(\"using default of %u, unable to parse %s\\n\",\n\t\t\taudit_backlog_limit, str);\n\t\treturn 1;\n\t}\n\n\taudit_backlog_limit = audit_backlog_limit_arg;\n\tpr_cont(\"%d\\n\", audit_backlog_limit);\n\n\treturn 1;\n}\n__setup(\"audit_backlog_limit=\", audit_backlog_limit_set);\n\nstatic void audit_buffer_free(struct audit_buffer *ab)\n{\n\tunsigned long flags;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (ab->", "4725": "< audit_names) {\n\t\taname = &context->", "4726": "< audit_nr_filters; i++) {\n\t\tlist_for_each_entry_safe(r, n, &audit_rules_list[i], list) {\n\t\t\tint res = update_lsm_rule(r);\n\t\t\tif (!err)\n\t\t\t\terr = res;\n\t\t}\n\t}\n\tmutex_unlock(&audit_filter_mutex);\n\n\treturn err;\n}\n\n#include <linux/sched.h>", "4727": "< audit_rate_limit) {\n\t\tretval = 1;\n\t} else {\n\t\tnow     = jiffies;\n\t\telapsed = now - last_check;\n\t\tif (elapsed >", "4728": "< audit_syscall_classes; i++) {\n\t\tint bit = audit_bitmask_size * 32 - i - 1;\n\t\t__u32 *p = &entry->", "4729": "< aux->", "4730": "< axs->", "4731": "< az; i++) {\n\t\tif (!range[i].end) {\n\t\t\tnr_range = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t\n\tsort(range, nr_range, sizeof(struct range), cmp_range, null);\n\n\treturn nr_range;\n}\n\nvoid sort_range(struct range *range, int nr_range)\n{\n\t\n\tsort(range, nr_range, sizeof(struct range), cmp_range, null);\n}\n\n#include <linux/spinlock.h>", "4732": "< az; j++) {\n\t\tif (!range[j].end)\n\t\t\tcontinue;\n\n\t\tif (start <= range[j].start && end >", "4733": "< b->", "4734": "< bc->", "4735": "< best->", "4736": "< bits) {\n\t\t\tpfn = bm->", "4737": "< bits_per_page)\n\t\t\treturn mk_pid(pid_ns, map, offset);\n\t}\n\treturn -1;\n}\n\nvoid put_pid(struct pid *pid)\n{\n\tstruct pid_namespace *ns;\n\n\tif (!pid)\n\t\treturn;\n\n\tns = pid->", "4738": "< bits_to_longs(bitmap_size); i++) {\n\t\tm = 0;\n\n\t\tfor (j = 0; j < sizeof(m)/sizeof(um); j++) {\n\t\t\t\n\t\t\tif (nr_compat_longs-- >", "4739": "< bm_min)\n\t\tbm_min = delta;\n\n\t\n\tif (bm_cnt >", "4740": "< bpf_reg_size; i++)\n\t\t\tstate->", "4741": "< bpf_reg_size; i++) {\n\t\t\tif (slot_type[i] != stack_spill) {\n\t\t\t\tverbose(\"corrupted spill memory\\n\");\n\t\t\t\treturn -eacces;\n\t\t\t}\n\t\t}\n\n\t\tif (value_regno >", "4742": "< buf_len; i++)\n\t\ttrace_seq_printf(p, \"%s%2.2x\", i == 0 ? \"\" : \" \", buf[i]);\n\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nexport_symbol(ftrace_print_hex_seq);\n\nconst char *\nftrace_print_array_seq(struct trace_seq *p, const void *buf, int count,\n\t\t       size_t el_size)\n{\n\tconst char *ret = trace_seq_buffer_ptr(p);\n\tconst char *prefix = \"\";\n\tvoid *ptr = (void *)buf;\n\tsize_t buf_len = count * el_size;\n\n\ttrace_seq_putc(p, '{');\n\n\twhile (ptr < buf + buf_len) {\n\t\tswitch (el_size) {\n\t\tcase 1:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u16 *)ptr);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\ttrace_seq_printf(p, \"%s0x%x\", prefix,\n\t\t\t\t\t *(u32 *)ptr);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\ttrace_seq_printf(p, \"%s0x%llx\", prefix,\n\t\t\t\t\t *(u64 *)ptr);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace_seq_printf(p, \"bad size:%zu 0x%x\", el_size,\n\t\t\t\t\t *(u8 *)ptr);\n\t\t\tel_size = 1;\n\t\t}\n\t\tprefix = \",\";\n\t\tptr += el_size;\n\t}\n\n\ttrace_seq_putc(p, '}');\n\ttrace_seq_putc(p, 0);\n\n\treturn ret;\n}\nexport_symbol(ftrace_print_array_seq);\n\nint ftrace_raw_output_prep(struct trace_iterator *iter,\n\t\t\t   struct trace_event *trace_event)\n{\n\tstruct ftrace_event_call *event;\n\tstruct trace_seq *s = &iter->", "4743": "< buf_page_size * 2)\n\t\tsize = buf_page_size * 2;\n\n\tnr_pages = div_round_up(size, buf_page_size);\n\n\t\n\tif (atomic_read(&buffer->", "4744": "< buf_page_size)\n\t\tmemset(&bpage->", "4745": "< buflen)\n\t\t\tpath = buf;\n\t}\n\n\tup_read(&css_set_rwsem);\n\tmutex_unlock(&cgroup_mutex);\n\treturn path;\n}\nexport_symbol_gpl(task_cgroup_path);\n\n\nstruct cgroup_taskset {\n\t\n\tstruct list_head\tsrc_csets;\n\tstruct list_head\tdst_csets;\n\n\t\n\tstruct list_head\t*csets;\n\tstruct css_set\t\t*cur_cset;\n\tstruct task_struct\t*cur_task;\n};\n\n\nstruct task_struct *cgroup_taskset_first(struct cgroup_taskset *tset)\n{\n\ttset->", "4746": "< busiest->", "4747": "< c->", "4748": "< call->", "4749": "< caller_saved_regs; i++) {\n\t\treg = regs + caller_saved[i];\n\t\treg->", "4750": "< calltime)\n\t\t\tcalltime -= current->", "4751": "< capacity_of(env->", "4752": "< cbflood_n_burst; i++) {\n\t\t\tfor (j = 0; j < cbflood_n_per_burst; j++) {\n\t\t\t\tcur_ops->", "4753": "< cfs_rq->", "4754": "< cgroup_subsys_count; (ssid)++)\t\\\n\t\tif (!((css) = cgroup_e_css(cgrp, cgroup_subsys[(ssid)]))) \\\n\t\t\t;\t\t\t\t\t\t\\\n\t\telse\n\n\n#define for_each_subsys(ss, ssid)\t\t\t\t\t\\\n\tfor ((ssid) = 0; (ssid) < cgroup_subsys_count &&\t\t\\\n\t     (((ss) = cgroup_subsys[ssid]) || true); (ssid)++)\n\n\n#define for_each_root(root)\t\t\t\t\t\t\\\n\tlist_for_each_entry((root), &cgroup_roots, root_list)\n\n\n#define cgroup_for_each_live_child(child, cgrp)\t\t\t\t\\\n\tlist_for_each_entry((child), &(cgrp)->", "4755": "< cgroup_subsys_count; (ssid)++)\t\\\n\t\tif (!((css) = rcu_dereference_check(\t\t\t\\\n\t\t\t\t(cgrp)->", "4756": "< chain->", "4757": "< chainhash_size; i++)\n\t\tinit_list_head(chainhash_table + i);\n\traw_local_irq_restore(flags);\n}\n\nstatic void zap_class(struct lock_class *class)\n{\n\tint i;\n\n\t\n\tfor (i = 0; i < nr_list_entries; i++) {\n\t\tif (list_entries[i].class == class)\n\t\t\tlist_del_rcu(&list_entries[i].entry);\n\t}\n\t\n\tlist_del_rcu(&class->", "4758": "< chunk->", "4759": "< ci_ptr->", "4760": "< classhash_size; i++)\n\t\tinit_list_head(classhash_table + i);\n\n\tfor (i = 0; i < chainhash_size; i++)\n\t\tinit_list_head(chainhash_table + i);\n\n\tlockdep_initialized = 1;\n}\n\nvoid __init lockdep_info(void)\n{\n\tprintk(\"lock dependency validator: copyright (c) 2006 red hat, inc., ingo molnar\\n\");\n\n\tprintk(\"... max_lockdep_subclasses:  %lu\\n\", max_lockdep_subclasses);\n\tprintk(\"... max_lock_depth:          %lu\\n\", max_lock_depth);\n\tprintk(\"... max_lockdep_keys:        %lu\\n\", max_lockdep_keys);\n\tprintk(\"... classhash_size:          %lu\\n\", classhash_size);\n\tprintk(\"... max_lockdep_entries:     %lu\\n\", max_lockdep_entries);\n\tprintk(\"... max_lockdep_chains:      %lu\\n\", max_lockdep_chains);\n\tprintk(\"... chainhash_size:          %lu\\n\", chainhash_size);\n\n\tprintk(\" memory used by lock dependency info: %lu kb\\n\",\n\t\t(sizeof(struct lock_class) * max_lockdep_keys +\n\t\tsizeof(struct list_head) * classhash_size +\n\t\tsizeof(struct lock_list) * max_lockdep_entries +\n\t\tsizeof(struct lock_chain) * max_lockdep_chains +\n\t\tsizeof(struct list_head) * chainhash_size\n#ifdef config_prove_locking\n\t\t+ sizeof(struct circular_queue)\n#endif\n\t\t) / 1024\n\t\t);\n\n\tprintk(\" per task-struct memory footprint: %lu bytes\\n\",\n\t\tsizeof(struct held_lock) * max_lock_depth);\n\n#ifdef config_debug_lockdep\n\tif (lockdep_init_error) {\n\t\tprintk(\"warning: lockdep init error! lock-%s was acquired\"\n\t\t\t\"before lockdep_init\\n\", lock_init_error);\n\t\tprintk(\"call stack leading to lockdep invocation was:\\n\");\n\t\tprint_stack_trace(&lockdep_init_trace, 0);\n\t}\n#endif\n}\n\nstatic void\nprint_freed_lock_bug(struct task_struct *curr, const void *mem_from,\n\t\t     const void *mem_to, struct held_lock *hlock)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\tif (debug_locks_silent)\n\t\treturn;\n\n\tprintk(\"\\n\");\n\tprintk(\"=========================\\n\");\n\tprintk(\"[ bug: held lock freed! ]\\n\");\n\tprint_kernel_ident();\n\tprintk(\"-------------------------\\n\");\n\tprintk(\"%s/%d is freeing memory %p-%p, with a lock still held there!\\n\",\n\t\tcurr->", "4761": "< cnt; i++)\n\t\tfree_desc(from + i);\n\n\tmutex_lock(&sparse_irq_lock);\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}\nexport_symbol_gpl(irq_free_descs);\n\n\nint __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -einval;\n\n\tif (irq >", "4762": "< cnt; i++) {\n\t\tdesc = alloc_desc(start + i, node, owner);\n\t\tif (!desc)\n\t\t\tgoto err;\n\t\tmutex_lock(&sparse_irq_lock);\n\t\tirq_insert_desc(start + i, desc);\n\t\tmutex_unlock(&sparse_irq_lock);\n\t}\n\treturn start;\n\nerr:\n\tfor (i--; i >", "4763": "< cnt; i++) {\n\t\tstruct irq_desc *desc = irq_to_desc(start + i);\n\n\t\tdesc->", "4764": "< commit && !kill_test; i += inc) {\n\n\t\t\tif (i >", "4765": "< context->", "4766": "< count) {\n\t\t\tpr_warning(\"line length is too long: \"\n\t\t\t\t   \"should be less than %d.\", write_bufsize);\n\t\t\tret = -einval;\n\t\t\tgoto out;\n\t\t}\n\t\tdone += size;\n\t\t\n\t\ttmp = strchr(kbuf, '#');\n\n\t\tif (tmp)\n\t\t\t*tmp = '\\0';\n\n\t\tret = traceprobe_command(kbuf, createfn);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}\n\nstatic int __set_print_fmt(struct trace_probe *tp, char *buf, int len,\n\t\t\t   bool is_return)\n{\n\tint i;\n\tint pos = 0;\n\n\tconst char *fmt, *arg;\n\n\tif (!is_return) {\n\t\tfmt = \"(%lx)\";\n\t\targ = \"rec->", "4767": "< count) {\n\t\tsize = count - done;\n\n\t\tif (size >", "4768": "< count; i++) {\n\t\tdesc[i].kstat_irqs = alloc_percpu(unsigned int);\n\t\talloc_masks(&desc[i], gfp_kernel, node);\n\t\traw_spin_lock_init(&desc[i].lock);\n\t\tlockdep_set_class(&desc[i].lock, &irq_desc_lock_class);\n\t\tdesc_set_defaults(i, &desc[i], node, null);\n\t}\n\treturn arch_early_irq_init();\n}\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < nr_irqs) ? irq_desc + irq : null;\n}\nexport_symbol(irq_to_desc);\n\nstatic void free_desc(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&desc->", "4769": "< count; i++) {\n\t\tinit_list_head(&chunk->", "4770": "< count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}\nexport_symbol_gpl(irq_domain_associate_many);\n\n\nunsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tunsigned int virq;\n\n\tif (domain == null)\n\t\tdomain = irq_default_domain;\n\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(domain->", "4771": "< count; i++) {\n\t\tlink = kzalloc(sizeof(*link), gfp_kernel);\n\t\tif (!link) {\n\t\t\tfree_cgrp_cset_links(tmp_links);\n\t\t\treturn -enomem;\n\t\t}\n\t\tlist_add(&link->", "4772": "< cp->", "4773": "< cpu)) {\n\t\tkick = true;\n\t\tgoto unlock;\n\t}\n\nunlock:\n\trcu_read_unlock();\n\treturn kick;\n}\n#else\nstatic void nohz_idle_balance(struct rq *this_rq, enum cpu_idle_type idle) { }\n#endif\n\n\nstatic void run_rebalance_domains(struct softirq_action *h)\n{\n\tstruct rq *this_rq = this_rq();\n\tenum cpu_idle_type idle = this_rq->", "4774": "< cpu_index; cpu++)\n\t\ttarget_cpu = cpumask_next(target_cpu, pd->", "4775": "< cpu_load_idx_max; i++, scale += scale) {\n\t\tunsigned long old_load, new_load;\n\n\t\t\n\n\t\told_load = this_rq->", "4776": "< cpu_load_idx_max; j++)\n\t\t\trq->", "4777": "< cpu_max_idle_types;\n\t\t\t\t\titype++) {\n\t\t\t\tseq_printf(seq, \" %u %u %u %u %u %u %u %u\",\n\t\t\t\t    sd->", "4778": "< cpu_rq(target)->", "4779": "< cpumask_size())\n\t\tcpumask_clear(new_mask);\n\telse if (len >", "4780": "< cq_depth)\n\t\t\t\t\tmax_bfs_queue_depth = cq_depth;\n\t\t\t}\n\t\t}\n\t}\nexit:\n\treturn ret;\n}\n\nstatic inline int __bfs_forwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 1);\n\n}\n\nstatic inline int __bfs_backwards(struct lock_list *src_entry,\n\t\t\tvoid *data,\n\t\t\tint (*match)(struct lock_list *entry, void *data),\n\t\t\tstruct lock_list **target_entry)\n{\n\treturn __bfs(src_entry, data, match, target_entry, 0);\n\n}\n\n\n\n\nstatic noinline int\nprint_circular_bug_entry(struct lock_list *target, int depth)\n{\n\tif (debug_locks_silent)\n\t\treturn 0;\n\tprintk(\"\\n->", "4781": "< crashk_res.start) ||\n\t\t\t    (mend >", "4782": "< crashk_res.start) || (entry >", "4783": "< csn; i++)\n\t\tcsa[i]->", "4784": "< csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tint apn = a->", "4785": "< csn; i++) {\n\t\tstruct cpuset *a = csa[i];\n\t\tstruct cpumask *dp;\n\t\tint apn = a->", "4786": "< csn; j++) {\n\t\t\tstruct cpuset *b = csa[j];\n\t\t\tint bpn = b->", "4787": "< csn; k++) {\n\t\t\t\t\tstruct cpuset *c = csa[k];\n\n\t\t\t\t\tif (c->", "4788": "< cur->", "4789": "< cur_dl_b->", "4790": "< curr->", "4791": "< curr_cost + sd->", "4792": "< cxt.nrealwriters_stress ||\n\t\t    j < cxt.nrealreaders_stress; i++, j++) {\n\t\tif (i >", "4793": "< cxt.nrealwriters_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_writer,\n\t\t\t\t\t     writer_tasks[i]);\n\t\tkfree(writer_tasks);\n\t\twriter_tasks = null;\n\t}\n\n\tif (reader_tasks) {\n\t\tfor (i = 0; i < cxt.nrealreaders_stress; i++)\n\t\t\ttorture_stop_kthread(lock_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t\treader_tasks = null;\n\t}\n\n\ttorture_stop_kthread(lock_torture_stats, stats_task);\n\tlock_torture_stats_print();  \n\n\tif (atomic_read(&cxt.n_lock_torture_errors))\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"end of test: failure\");\n\telse if (torture_onoff_failures())\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"end of test: lock_hotplug\");\n\telse\n\t\tlock_torture_print_module_parms(cxt.cur_ops,\n\t\t\t\t\t\t\"end of test: success\");\n\ttorture_cleanup_end();\n}\n\nstatic int __init lock_torture_init(void)\n{\n\tint i, j;\n\tint firsterr = 0;\n\tstatic struct lock_torture_ops *torture_ops[] = {\n\t\t&lock_busted_ops,\n\t\t&spin_lock_ops, &spin_lock_irq_ops,\n\t\t&rw_lock_ops, &rw_lock_irq_ops,\n\t\t&mutex_lock_ops,\n\t\t&rwsem_lock_ops,\n\t};\n\n\tif (!torture_init_begin(torture_type, verbose, &torture_runnable))\n\t\treturn -ebusy;\n\n\t\n\tfor (i = 0; i < array_size(torture_ops); i++) {\n\t\tcxt.cur_ops = torture_ops[i];\n\t\tif (strcmp(torture_type, cxt.cur_ops->", "4794": "< cxt.nrealwriters_stress; i++) {\n\t\tcxt.lwsa[i].n_lock_fail = 0;\n\t\tcxt.lwsa[i].n_lock_acquired = 0;\n\t}\n\n\tif (cxt.cur_ops->", "4795": "< d->", "4796": "< dah_first) {\n\t\th->", "4797": "< dah_overhead)\n\t\tgoto out;\n\tif (rem >", "4798": "< data->", "4799": "< data[thr].unc_len; off += page_size) {\n\t\t\t\tmemcpy(data_of(*snapshot),\n\t\t\t\t       data[thr].unc + off, page_size);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tprintk(kern_info\n\t\t\t\t\t       \"pm: image loading progress: \"\n\t\t\t\t\t       \"%3d%%\\n\",\n\t\t\t\t\t       nr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\n\t\t\t\tret = snapshot_write_next(snapshot);\n\t\t\t\tif (ret <= 0) {\n\t\t\t\t\tcrc->", "4800": "< data_cnt; i++) {\n\t\tstruct event_filter *filter = null;\n\t\tstruct test_filter_data_t *d = &test_filter_data[i];\n\t\tint err;\n\n\t\terr = create_filter(&event_ftrace_test_filter, d->", "4801": "< dbg_max_reg_num; i++) {\n\t\tdbg_get_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}\n\nvoid gdb_regs_to_pt_regs(unsigned long *gdb_regs, struct pt_regs *regs)\n{\n\tint i;\n\tint idx = 0;\n\tchar *ptr = (char *)gdb_regs;\n\n\tfor (i = 0; i < dbg_max_reg_num; i++) {\n\t\tdbg_set_reg(i, ptr + idx, regs);\n\t\tidx += dbg_reg_def[i].size;\n\t}\n}\n#endif \n\n\nstatic int write_mem_msg(int binary)\n{\n\tchar *ptr = &remcom_in_buffer[1];\n\tunsigned long addr;\n\tunsigned long length;\n\tint err;\n\n\tif (kgdb_hex2long(&ptr, &addr) >", "4802": "< dbg_max_reg_num; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"error: register set currently not implemented\\n\");\n    return 0;\n#endif\n}\n\n#if defined(config_magic_sysrq)\n\nstatic int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(kdb_enable_all, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn kdb_argcount;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}\n#endif\t\n\n\nstatic int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn kdb_argcount;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, null);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}\n\n#if defined(config_modules)\n\nstatic int kdb_lsmod(int argc, const char **argv)\n{\n\tstruct module *mod;\n\n\tif (argc != 0)\n\t\treturn kdb_argcount;\n\n\tkdb_printf(\"module                  size  modstruct     used by\\n\");\n\tlist_for_each_entry(mod, kdb_modules, list) {\n\t\tif (mod->", "4803": "< dbg_max_reg_num; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize >", "4804": "< debug_alloc_pool ||\n\t    (char *)p >", "4805": "< defcmd_set_count; ++i, ++s) {\n\t\tif (strcmp(s->", "4806": "< delta)\n\t\t\t\t\tmax_offline = delta;\n\t\t\t}\n\t\t} else if (cpu_is_hotpluggable(cpu)) {\n\t\t\tif (verbose)\n\t\t\t\tpr_alert(\"%s\" torture_flag\n\t\t\t\t\t \"torture_onoff task: onlining %d\\n\",\n\t\t\t\t\t torture_type, cpu);\n\t\t\tstarttime = jiffies;\n\t\t\tn_online_attempts++;\n\t\t\tret = cpu_up(cpu);\n\t\t\tif (ret) {\n\t\t\t\tif (verbose)\n\t\t\t\t\tpr_alert(\"%s\" torture_flag\n\t\t\t\t\t\t \"torture_onoff task: online %d failed: errno %d\\n\",\n\t\t\t\t\t\t torture_type, cpu, ret);\n\t\t\t} else {\n\t\t\t\tif (verbose)\n\t\t\t\t\tpr_alert(\"%s\" torture_flag\n\t\t\t\t\t\t \"torture_onoff task: onlined %d\\n\",\n\t\t\t\t\t\t torture_type, cpu);\n\t\t\t\tn_online_successes++;\n\t\t\t\tdelta = jiffies - starttime;\n\t\t\t\tsum_online += delta;\n\t\t\t\tif (min_online < 0) {\n\t\t\t\t\tmin_online = delta;\n\t\t\t\t\tmax_online = delta;\n\t\t\t\t}\n\t\t\t\tif (min_online >", "4807": "< delta)\n\t\t\t\t\tmax_online = delta;\n\t\t\t}\n\t\t}\n\t\tschedule_timeout_interruptible(onoff_interval);\n\t}\n\ttorture_kthread_stopping(\"torture_onoff\");\n\treturn 0;\n}\n\n#endif \n\n\nint torture_onoff_init(long ooholdoff, long oointerval)\n{\n\tint ret = 0;\n\n#ifdef config_hotplug_cpu\n\tonoff_holdoff = ooholdoff;\n\tonoff_interval = oointerval;\n\tif (onoff_interval <= 0)\n\t\treturn 0;\n\tret = torture_create_kthread(torture_onoff, null, onoff_task);\n#endif \n\treturn ret;\n}\nexport_symbol_gpl(torture_onoff_init);\n\n\nstatic void torture_onoff_cleanup(void)\n{\n#ifdef config_hotplug_cpu\n\tif (onoff_task == null)\n\t\treturn;\n\tverbose_torout_string(\"stopping torture_onoff task\");\n\tkthread_stop(onoff_task);\n\tonoff_task = null;\n#endif \n}\nexport_symbol_gpl(torture_onoff_cleanup);\n\n\nvoid torture_onoff_stats(void)\n{\n#ifdef config_hotplug_cpu\n\tpr_cont(\"onoff: %ld/%ld:%ld/%ld %d,%d:%d,%d %lu:%lu (hz=%d) \",\n\t\tn_online_successes, n_online_attempts,\n\t\tn_offline_successes, n_offline_attempts,\n\t\tmin_online, max_online,\n\t\tmin_offline, max_offline,\n\t\tsum_online, sum_offline, hz);\n#endif \n}\nexport_symbol_gpl(torture_onoff_stats);\n\n\nbool torture_onoff_failures(void)\n{\n#ifdef config_hotplug_cpu\n\treturn n_online_successes != n_online_attempts ||\n\t       n_offline_successes != n_offline_attempts;\n#else \n\treturn false;\n#endif \n}\nexport_symbol_gpl(torture_onoff_failures);\n\n#define torture_random_mult\t39916801  \n#define torture_random_add\t479001701 \n#define torture_random_refresh\t10000\n\n\nunsigned long\ntorture_random(struct torture_random_state *trsp)\n{\n\tif (--trsp->", "4808": "< delta_jiffies) {\n\t\t\tnext_jiffies = last_jiffies + rcu_delta_jiffies;\n\t\t\tdelta_jiffies = rcu_delta_jiffies;\n\t\t}\n\t}\n\n\t\n\tif (!ts->", "4809": "< depth; i++) {\n\t\thlock = curr->", "4810": "< depth; i++) {\n\t\tprintk(\" #%d: \", i);\n\t\tprint_lock(curr->", "4811": "< desc->", "4812": "< dev->", "4813": "< dist) {\n\t\t\t\t\tfaults += group_faults(p, b);\n\t\t\t\t\tnode_set(b, this_group);\n\t\t\t\t\tnode_clear(b, nodes);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif (faults >", "4814": "< dl_b->", "4815": "< dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == audit_name_full ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}\n\nstatic int audit_filter_user_rules(struct audit_krule *rule, int type,\n\t\t\t\t   enum audit_state *state)\n{\n\tint i;\n\n\tfor (i = 0; i < rule->", "4816": "< domain->", "4817": "< dst->", "4818": "< dst_load * src_capacity;\n\telse\n\t\t\n\t\treturn dst_load * src_capacity < src_load * dst_capacity;\n}\n\n\nstatic void task_numa_compare(struct task_numa_env *env,\n\t\t\t      long taskimp, long groupimp)\n{\n\tstruct rq *src_rq = cpu_rq(env->", "4819": "< e->", "4820": "< ehdr->", "4821": "< elen)\n\t\treturn null;\n\n\tsnprintf(ptr, elen + 1, \"%ld\", map->", "4822": "< end) {\n\t\t\t\tnext_res = alloc_resource(gfp_atomic);\n\t\t\t\tif (!next_res) {\n\t\t\t\t\tfree_resource(res);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnext_res->", "4823": "< end) {\n\t\t\t*crash_size = size;\n\t\t\tbreak;\n\t\t}\n\t} while (*cur++ == ',');\n\n\tif (*crash_size >", "4824": "< end) {\n\t\t\tint mid = (index + end) / 2;\n\t\t\tif (cgroup_pid_fry(cgrp, l->", "4825": "< end) {\n\t\t\tp = &res->", "4826": "< end) {\n\t\t\n\t\tif (end - p < 4)\n\t\t\tgoto dodgy_cert;\n\t\tif (p[0] != 0x30 &&\n\t\t    p[1] != 0x82)\n\t\t\tgoto dodgy_cert;\n\t\tplen = (p[2] << 8) | p[3];\n\t\tplen += 4;\n\t\tif (plen >", "4827": "< end) {\n\t\tpr_err(\"requested range [0x%llx-0x%llx] not in root %pr\\n\",\n\t\t       (unsigned long long)start, (unsigned long long)end,\n\t\t       root);\n\t\tif (start >", "4828": "< end))\n\t\t\tbreak;\n\t}\n\n\tread_unlock(&resource_lock);\n\tif (!p)\n\t\treturn -1;\n\t\n\tif (res->", "4829": "< end))\n\t\treturn 1;\n\n\tif (arch_is_kernel_data(addr))\n\t\treturn 1;\n\n\t\n\tif (is_kernel_percpu_address(addr))\n\t\treturn 1;\n\n\t\n\treturn is_module_address(addr) || is_module_percpu_address(addr);\n}\n#endif\n\n\nstatic int count_matching_names(struct lock_class *new_class)\n{\n\tstruct lock_class *class;\n\tint count = 0;\n\n\tif (!new_class->", "4830": "< end; addr += page_size)\n\t\tfree_reserved_page(pfn_to_page(addr >", "4831": "< end; addr++) {\n\t\t\terr = get_user(val, addr);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t\tif (val)\n\t\t\t\treturn -e2big;\n\t\t}\n\t\tsize = sizeof(attr);\n\t}\n\n\t\n\tif (copy_from_user(&attr, uattr, size) != 0)\n\t\treturn -efault;\n\n\tswitch (cmd) {\n\tcase bpf_map_create:\n\t\terr = map_create(&attr);\n\t\tbreak;\n\tcase bpf_map_lookup_elem:\n\t\terr = map_lookup_elem(&attr);\n\t\tbreak;\n\tcase bpf_map_update_elem:\n\t\terr = map_update_elem(&attr);\n\t\tbreak;\n\tcase bpf_map_delete_elem:\n\t\terr = map_delete_elem(&attr);\n\t\tbreak;\n\tcase bpf_map_get_next_key:\n\t\terr = map_get_next_key(&attr);\n\t\tbreak;\n\tcase bpf_prog_load:\n\t\terr = bpf_prog_load(&attr);\n\t\tbreak;\n\tdefault:\n\t\terr = -einval;\n\t\tbreak;\n\t}\n\n\treturn err;\n}\n\n\n#include <linux/export.h>", "4832": "< end; addr++) {\n\t\t\tret = get_user(val, addr);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t\tif (val)\n\t\t\t\tgoto err_size;\n\t\t}\n\t\tsize = sizeof(*attr);\n\t}\n\n\tret = copy_from_user(attr, uattr, size);\n\tif (ret)\n\t\treturn -efault;\n\n\t\n\tattr->", "4833": "< end; i++)\n\t\tkfree(ret_stack_list[i]);\n\treturn ret;\n}\n\nstatic void\nftrace_graph_probe_sched_switch(void *ignore,\n\t\t\tstruct task_struct *prev, struct task_struct *next)\n{\n\tunsigned long long timestamp;\n\tint index;\n\n\t\n\tif (trace_flags & trace_iter_sleep_time)\n\t\treturn;\n\n\ttimestamp = trace_clock_local();\n\n\tprev->", "4834": "< end; iter++) {\n\t\tentry = arch_deref_entry_point((void *)*iter);\n\n\t\tif (!kernel_text_address(entry) ||\n\t\t    !kallsyms_lookup_size_offset(entry, &size, &offset)) {\n\t\t\tpr_err(\"failed to find blacklist at %p\\n\",\n\t\t\t\t(void *)entry);\n\t\t\tcontinue;\n\t\t}\n\n\t\tent = kmalloc(sizeof(*ent), gfp_kernel);\n\t\tif (!ent)\n\t\t\treturn -enomem;\n\t\tent->", "4835": "< end; iter++) {\n\t\tstruct trace_bprintk_fmt *tb_fmt = lookup_format(*iter);\n\t\tif (tb_fmt) {\n\t\t\t*iter = tb_fmt->", "4836": "< end; map++, offset = 0) {\n\t\tif (unlikely(!map->", "4837": "< end; p++) {\n\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tbreak;\n\n\t\ttrace_seq_puts(s, \" =>", "4838": "< ent->", "4839": "< entry->", "4840": "< env->", "4841": "< erule->", "4842": "< event->", "4843": "< ext->", "4844": "< extents; idx++) {\n\t\tfirst = map->", "4845": "< fcount; i++) {\n\t\tswitch (new->", "4846": "< fetch_mtd_end; i++)\n\t\tif (type->", "4847": "< filter->", "4848": "< first_space))\n\t\treturn parse_crashkernel_mem(ck_cmdline, system_ram,\n\t\t\t\tcrash_size, crash_base);\n\n\treturn parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);\n}\n\n\nint __init parse_crashkernel(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\t\"crashkernel=\", null);\n}\n\nint __init parse_crashkernel_high(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[suffix_high]);\n}\n\nint __init parse_crashkernel_low(char *cmdline,\n\t\t\t     unsigned long long system_ram,\n\t\t\t     unsigned long long *crash_size,\n\t\t\t     unsigned long long *crash_base)\n{\n\treturn __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,\n\t\t\t\t\"crashkernel=\", suffix_tbl[suffix_low]);\n}\n\nstatic void update_vmcoreinfo_note(void)\n{\n\tu32 *buf = vmcoreinfo_note;\n\n\tif (!vmcoreinfo_size)\n\t\treturn;\n\tbuf = append_elf_note(buf, vmcoreinfo_note_name, 0, vmcoreinfo_data,\n\t\t\t      vmcoreinfo_size);\n\tfinal_note(buf);\n}\n\nvoid crash_save_vmcoreinfo(void)\n{\n\tvmcoreinfo_append_str(\"crashtime=%ld\\n\", get_seconds());\n\tupdate_vmcoreinfo_note();\n}\n\nvoid vmcoreinfo_append_str(const char *fmt, ...)\n{\n\tva_list args;\n\tchar buf[0x50];\n\tsize_t r;\n\n\tva_start(args, fmt);\n\tr = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tr = min(r, vmcoreinfo_max_size - vmcoreinfo_size);\n\n\tmemcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);\n\n\tvmcoreinfo_size += r;\n}\n\n\nvoid __weak arch_crash_save_vmcoreinfo(void)\n{}\n\nunsigned long __weak paddr_vmcoreinfo_note(void)\n{\n\treturn __pa((unsigned long)(char *)&vmcoreinfo_note);\n}\n\nstatic int __init crash_save_vmcoreinfo_init(void)\n{\n\tvmcoreinfo_osrelease(init_uts_ns.name.release);\n\tvmcoreinfo_pagesize(page_size);\n\n\tvmcoreinfo_symbol(init_uts_ns);\n\tvmcoreinfo_symbol(node_online_map);\n#ifdef config_mmu\n\tvmcoreinfo_symbol(swapper_pg_dir);\n#endif\n\tvmcoreinfo_symbol(_stext);\n\tvmcoreinfo_symbol(vmap_area_list);\n\n#ifndef config_need_multiple_nodes\n\tvmcoreinfo_symbol(mem_map);\n\tvmcoreinfo_symbol(contig_page_data);\n#endif\n#ifdef config_sparsemem\n\tvmcoreinfo_symbol(mem_section);\n\tvmcoreinfo_length(mem_section, nr_section_roots);\n\tvmcoreinfo_struct_size(mem_section);\n\tvmcoreinfo_offset(mem_section, section_mem_map);\n#endif\n\tvmcoreinfo_struct_size(page);\n\tvmcoreinfo_struct_size(pglist_data);\n\tvmcoreinfo_struct_size(zone);\n\tvmcoreinfo_struct_size(free_area);\n\tvmcoreinfo_struct_size(list_head);\n\tvmcoreinfo_size(nodemask_t);\n\tvmcoreinfo_offset(page, flags);\n\tvmcoreinfo_offset(page, _count);\n\tvmcoreinfo_offset(page, mapping);\n\tvmcoreinfo_offset(page, lru);\n\tvmcoreinfo_offset(page, _mapcount);\n\tvmcoreinfo_offset(page, private);\n\tvmcoreinfo_offset(pglist_data, node_zones);\n\tvmcoreinfo_offset(pglist_data, nr_zones);\n#ifdef config_flat_node_mem_map\n\tvmcoreinfo_offset(pglist_data, node_mem_map);\n#endif\n\tvmcoreinfo_offset(pglist_data, node_start_pfn);\n\tvmcoreinfo_offset(pglist_data, node_spanned_pages);\n\tvmcoreinfo_offset(pglist_data, node_id);\n\tvmcoreinfo_offset(zone, free_area);\n\tvmcoreinfo_offset(zone, vm_stat);\n\tvmcoreinfo_offset(zone, spanned_pages);\n\tvmcoreinfo_offset(free_area, free_list);\n\tvmcoreinfo_offset(list_head, next);\n\tvmcoreinfo_offset(list_head, prev);\n\tvmcoreinfo_offset(vmap_area, va_start);\n\tvmcoreinfo_offset(vmap_area, list);\n\tvmcoreinfo_length(zone.free_area, max_order);\n\tlog_buf_kexec_setup();\n\tvmcoreinfo_length(free_area.free_list, migrate_types);\n\tvmcoreinfo_number(nr_free_pages);\n\tvmcoreinfo_number(pg_lru);\n\tvmcoreinfo_number(pg_private);\n\tvmcoreinfo_number(pg_swapcache);\n\tvmcoreinfo_number(pg_slab);\n#ifdef config_memory_failure\n\tvmcoreinfo_number(pg_hwpoison);\n#endif\n\tvmcoreinfo_number(pg_head_mask);\n\tvmcoreinfo_number(page_buddy_mapcount_value);\n#ifdef config_hugetlbfs\n\tvmcoreinfo_symbol(free_huge_page);\n#endif\n\n\tarch_crash_save_vmcoreinfo();\n\tupdate_vmcoreinfo_note();\n\n\treturn 0;\n}\n\nsubsys_initcall(crash_save_vmcoreinfo_init);\n\n#ifdef config_kexec_file\nstatic int locate_mem_hole_top_down(unsigned long start, unsigned long end,\n\t\t\t\t    struct kexec_buf *kbuf)\n{\n\tstruct kimage *image = kbuf->", "4849": "< flen; pc++) {\n\t\tstruct sock_filter *ftest = &filter[pc];\n\t\tu16 code = ftest->", "4850": "< fmt_size; i++) {\n\t\tif ((!isprint(fmt[i]) && !isspace(fmt[i])) || !isascii(fmt[i]))\n\t\t\treturn -einval;\n\n\t\tif (fmt[i] != '%')\n\t\t\tcontinue;\n\n\t\tif (fmt_cnt >", "4851": "< freezer_delta.tv64))\n\t\tfreezer_delta = delta;\n\tspin_unlock_irqrestore(&freezer_delta_lock, flags);\n}\n\n\n\nvoid alarm_init(struct alarm *alarm, enum alarmtimer_type type,\n\t\tenum alarmtimer_restart (*function)(struct alarm *, ktime_t))\n{\n\ttimerqueue_init(&alarm->", "4852": "< ftrace_retfunc_depth)\n\t\t\tcpu_data->", "4853": "< ftrace_retfunc_depth) {\n\t\t\tif (cpu_data->", "4854": "< ftrace_retstack_alloc_size; i++) {\n\t\tret_stack_list[i] = kmalloc(ftrace_retfunc_depth\n\t\t\t\t\t* sizeof(struct ftrace_ret_stack),\n\t\t\t\t\tgfp_kernel);\n\t\tif (!ret_stack_list[i]) {\n\t\t\tstart = 0;\n\t\t\tend = i;\n\t\t\tret = -enomem;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tread_lock_irqsave(&tasklist_lock, flags);\n\tdo_each_thread(g, t) {\n\t\tif (start == end) {\n\t\t\tret = -eagain;\n\t\t\tgoto unlock;\n\t\t}\n\n\t\tif (t->", "4855": "< ftrace_stack_entries; i++) {\n\t\tunsigned long ip = entry->", "4856": "< gc->", "4857": "< gcov_counters; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tpos += store_gcov_u32(buffer, pos,\n\t\t\t\t\t      gcov_tag_for_counter(ct_idx));\n\t\t\tpos += store_gcov_u32(buffer, pos, ci_ptr->", "4858": "< gcov_counters; ct_idx++) {\n\t\t\tif (!counter_active(info, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tmemset(ci_ptr->", "4859": "< gcov_counters; ct_idx++) {\n\t\t\tif (!counter_active(src, ct_idx))\n\t\t\t\tcontinue;\n\n\t\t\tfor (val_idx = 0; val_idx < sci_ptr->", "4860": "< gcov_counters; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}\n\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tstruct gcov_ctr_info *ci_ptr;\n\tunsigned int fi_idx;\n\tunsigned int ct_idx;\n\n\tfor (fi_idx = 0; fi_idx < info->", "4861": "< gcov_counters; i++) {\n\t\tif (counter_active(info, i))\n\t\t\tresult++;\n\t}\n\treturn result;\n}\n\n\nvoid gcov_info_reset(struct gcov_info *info)\n{\n\tunsigned int active = num_counter_active(info);\n\tunsigned int i;\n\n\tfor (i = 0; i < active; i++) {\n\t\tmemset(info->", "4862": "< gcov_counters; i++) {\n\t\tif (counter_active(iter->", "4863": "< gdbstub_use_prev_in_buf)\n\t\t\treturn remcom_in_buffer[gdbstub_prev_in_buf_pos++];\n\t\telse\n\t\t\tgdbstub_use_prev_in_buf = 0;\n\t}\n\n\t\n\twhile (ret < 0)\n\t\tfor (i = 0; kdb_poll_funcs[i] != null; i++) {\n\t\t\tret = kdb_poll_funcs[i]();\n\t\t\tif (ret >", "4864": "< get_func(iter)->", "4865": "< group_faults(p, src_nid);\n\t}\n\n\t\n\tif (src_nid == p->", "4866": "< group_first_cpu(sg)) {\n\t\tif (!sds->", "4867": "< group_info->", "4868": "< header_size) {\n\t\t\n\t\tstack_size = ushrt_max - header_size - sizeof(u64);\n\t\tstack_size = round_up(stack_size, sizeof(u64));\n\t}\n\n\treturn stack_size;\n}\n\nstatic void\nperf_output_sample_ustack(struct perf_output_handle *handle, u64 dump_size,\n\t\t\t  struct pt_regs *regs)\n{\n\t\n\tif (!regs) {\n\t\tu64 size = 0;\n\t\tperf_output_put(handle, size);\n\t} else {\n\t\tunsigned long sp;\n\t\tunsigned int rem;\n\t\tu64 dyn_size;\n\n\t\t\n\n\t\t\n\t\tperf_output_put(handle, dump_size);\n\n\t\t\n\t\tsp = perf_user_stack_pointer(regs);\n\t\trem = __output_copy_user(handle, (void *) sp, dump_size);\n\t\tdyn_size = dump_size - rem;\n\n\t\tperf_output_skip(handle, rem);\n\n\t\t\n\t\tperf_output_put(handle, dyn_size);\n\t}\n}\n\nstatic void __perf_event_header__init_id(struct perf_event_header *header,\n\t\t\t\t\t struct perf_sample_data *data,\n\t\t\t\t\t struct perf_event *event)\n{\n\tu64 sample_type = event->", "4869": "< highbp;\n\t    i++, bp++) {\n\t\tif (bp->", "4870": "< htab->", "4871": "< hz/4 && !force_up) \n\t\tj = j - rem;\n\telse \n\t\tj = j - rem + hz;\n\n\t\n\tj -= cpu * 3;\n\n\t\n\treturn time_is_after_jiffies(j) ? j : original;\n}\n\n\nunsigned long __round_jiffies(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, false);\n}\nexport_symbol_gpl(__round_jiffies);\n\n\nunsigned long __round_jiffies_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t\n\treturn round_jiffies_common(j + j0, cpu, false) - j0;\n}\nexport_symbol_gpl(__round_jiffies_relative);\n\n\nunsigned long round_jiffies(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), false);\n}\nexport_symbol_gpl(round_jiffies);\n\n\nunsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}\nexport_symbol_gpl(round_jiffies_relative);\n\n\nunsigned long __round_jiffies_up(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, true);\n}\nexport_symbol_gpl(__round_jiffies_up);\n\n\nunsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t\n\treturn round_jiffies_common(j + j0, cpu, true) - j0;\n}\nexport_symbol_gpl(__round_jiffies_up_relative);\n\n\nunsigned long round_jiffies_up(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), true);\n}\nexport_symbol_gpl(round_jiffies_up);\n\n\nunsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}\nexport_symbol_gpl(round_jiffies_up_relative);\n\n\nvoid set_timer_slack(struct timer_list *timer, int slack_hz)\n{\n\ttimer->", "4872": "< i; j++)\n\t\trdp->", "4873": "< i; j++) {\n\t\t\tunsigned long pstart, pend;\n\t\t\tpstart = image->", "4874": "< image->", "4875": "< imbalance*min_load)\n\t\treturn null;\n\treturn idlest;\n}\n\n\nstatic int\nfind_idlest_cpu(struct sched_group *group, struct task_struct *p, int this_cpu)\n{\n\tunsigned long load, min_load = ulong_max;\n\tunsigned int min_exit_latency = uint_max;\n\tu64 latest_idle_timestamp = 0;\n\tint least_loaded_cpu = this_cpu;\n\tint shallowest_idle_cpu = -1;\n\tint i;\n\n\t\n\tfor_each_cpu_and(i, sched_group_cpus(group), tsk_cpus_allowed(p)) {\n\t\tif (idle_cpu(i)) {\n\t\t\tstruct rq *rq = cpu_rq(i);\n\t\t\tstruct cpuidle_state *idle = idle_get_state(rq);\n\t\t\tif (idle && idle->", "4876": "< index)\n\t\t\t\t\tbreak;\n\t\t\t\treturn expires;\n\t\t\t}\n\t\t\tslot = (slot + 1) & tvn_mask;\n\t\t} while (slot != index);\n\n\t\tif (index)\n\t\t\ttimer_jiffies += tvn_size - index;\n\t\ttimer_jiffies >", "4877": "< index)\n\t\t\t\tgoto cascade;\n\t\t\treturn expires;\n\t\t}\n\t\tslot = (slot + 1) & tvr_mask;\n\t} while (slot != index);\n\ncascade:\n\t\n\tif (index)\n\t\ttimer_jiffies += tvr_size - index;\n\ttimer_jiffies >", "4878": "< info->", "4879": "< initcnt; i++) {\n\t\tdesc = alloc_desc(i, node, null);\n\t\tset_bit(i, allocated_irqs);\n\t\tirq_insert_desc(i, desc);\n\t}\n\treturn arch_early_irq_init();\n}\n\n#else \n\nstruct irq_desc irq_desc[nr_irqs] __cacheline_aligned_in_smp = {\n\t[0 ... nr_irqs-1] = {\n\t\t.handle_irq\t= handle_bad_irq,\n\t\t.depth\t\t= 1,\n\t\t.lock\t\t= __raw_spin_lock_unlocked(irq_desc->", "4880": "< insn_cnt; i++, insn++)\n\t\tif (insn->", "4881": "< insn_cnt; i++, insn++) {\n\t\tif (bpf_class(insn->", "4882": "< insn_cnt; i++, insn++) {\n\t\tif (insn->", "4883": "< iter->", "4884": "< iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}\n\n\nvoid __weak __init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\t\n}\n\nstatic void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop, int enable)\n{\n\tfor (; (entry < stop) &&\n\t      (entry->", "4885": "< iter_stop; iter++) {\n\t\tarch_jump_label_transform_static(iter, jump_label_disable);\n\t}\n}\n\nstatic int jump_label_add_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->", "4886": "< iter_stop; iter++) {\n\t\tif (iter->", "4887": "< iter_stop; iter++) {\n\t\tif (within_module_init(iter->", "4888": "< iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\titerk = (struct static_key *)(unsigned long)iter->", "4889": "< iters; ++i) {\n\t\tstruct timespec ts1, ts2;\n\t\tint time_passed;\n\n\t\tktime_get_ts(&ts1);\n\t\tudelay(usecs);\n\t\tktime_get_ts(&ts2);\n\t\ttime_passed = timespec_to_ns(&ts2) - timespec_to_ns(&ts1);\n\n\t\tif (i == 0 || time_passed < min)\n\t\t\tmin = time_passed;\n\t\tif (i == 0 || time_passed >", "4890": "< jeb->", "4891": "< k; i++) {\n\t\tif (range[i].end)\n\t\t\tcontinue;\n\t\tfor (j = k; j >", "4892": "< kbuf->", "4893": "< kcmp_types; i++)\n\t\tcookies[i][1] |= (~(~0ul >", "4894": "< kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->", "4895": "< kdb_max_commands;\t\t\t\t\t\\\n\t     num++, num == kdb_base_cmd_max ? cmd = kdb_commands : cmd++)\n\ntypedef struct _kdbmsg {\n\tint\tkm_diag;\t\n\tchar\t*km_msg;\t\n} kdbmsg_t;\n\n#define kdbmsg(msgnum, text) \\\n\t{ kdb_##msgnum, text }\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tkdbmsg(notfound, \"command not found\"),\n\tkdbmsg(argcount, \"improper argument count, see usage.\"),\n\tkdbmsg(badwidth, \"illegal value for bytesperword use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tkdbmsg(badradix, \"illegal value for radix use 8, 10 or 16\"),\n\tkdbmsg(notenv, \"cannot find environment variable\"),\n\tkdbmsg(noenvvalue, \"environment variable should have value\"),\n\tkdbmsg(notimp, \"command not implemented\"),\n\tkdbmsg(envfull, \"environment full\"),\n\tkdbmsg(envbuffull, \"environment buffer full\"),\n\tkdbmsg(toomanybpt, \"too many breakpoints defined\"),\n#ifdef config_cpu_xscale\n\tkdbmsg(toomanydbregs, \"more breakpoints than ibcr registers defined\"),\n#else\n\tkdbmsg(toomanydbregs, \"more breakpoints than db registers defined\"),\n#endif\n\tkdbmsg(dupbpt, \"duplicate breakpoint address\"),\n\tkdbmsg(bptnotfound, \"breakpoint not found\"),\n\tkdbmsg(badmode, \"invalid idmode\"),\n\tkdbmsg(badint, \"illegal numeric value\"),\n\tkdbmsg(invaddrfmt, \"invalid symbolic address format\"),\n\tkdbmsg(badreg, \"invalid register name\"),\n\tkdbmsg(badcpunum, \"invalid cpu number\"),\n\tkdbmsg(badlength, \"invalid length field\"),\n\tkdbmsg(nobp, \"no breakpoint exists\"),\n\tkdbmsg(badaddr, \"invalid address\"),\n\tkdbmsg(noperm, \"permission denied\"),\n};\n#undef kdbmsg\n\nstatic const int __nkdb_err = array_size(kdbmsgs);\n\n\n\n\nstatic char *__env[] = {\n#if defined(config_smp)\n \"prompt=[%d]kdb>", "4896": "< kdb_maxbpt) {\n\t\t\tbp = &kdb_breakpoints[addr];\n\t\t\tlowbp = highbp = addr;\n\t\t\thighbp++;\n\t\t} else {\n\t\t\tfor (i = 0, bp = kdb_breakpoints; i < kdb_maxbpt;\n\t\t\t    i++, bp++) {\n\t\t\t\tif (bp->", "4897": "< kdb_maxbpt;\n\t\t     bpno++, bp++) {\n\t\t\tif (bp->", "4898": "< kdb_maxbpt;\n\t     i++, bp_check++) {\n\t\tif (!bp_check->", "4899": "< kdb_maxbpt; bpno++, bp++) {\n\t\tif (bp->", "4900": "< kdb_maxbpt; i++) {\n\t\tkdb_bp_t *bp = &kdb_breakpoints[i];\n\n\t\tif (kdb_debug(bp)) {\n\t\t\tkdb_printf(\"%s: bp %d bp_enabled %d\\n\",\n\t\t\t\t   __func__, i, bp->", "4901": "< kdb_maxbpt; i++, bp++)\n\t\tbp->", "4902": "< kdb_maxbpt; i++, bp++) {\n\t\t\tif (bp->", "4903": "< kdb_maxbpt; i++, bp++) {\n\t\tif ((bp->", "4904": "< key_id_len; i++) {\n\t\t*q++ = hex_asc[*key_id >", "4905": "< kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state != bp_set)\n\t\t\tcontinue;\n\n\t\terror = kgdb_arch_set_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tret = error;\n\t\t\tpr_info(\"bp install failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = bp_active;\n\t}\n\treturn ret;\n}\n\nint dbg_set_sw_break(unsigned long addr)\n{\n\tint err = kgdb_validate_break_address(addr);\n\tint breakno = -1;\n\tint i;\n\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif ((kgdb_break[i].state == bp_set) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn -eexist;\n\t}\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state == bp_removed &&\n\t\t\t\t\tkgdb_break[i].bpt_addr == addr) {\n\t\t\tbreakno = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (breakno == -1) {\n\t\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\t\tif (kgdb_break[i].state == bp_undefined) {\n\t\t\t\tbreakno = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (breakno == -1)\n\t\treturn -e2big;\n\n\tkgdb_break[breakno].state = bp_set;\n\tkgdb_break[breakno].type = bp_breakpoint;\n\tkgdb_break[breakno].bpt_addr = addr;\n\n\treturn 0;\n}\n\nint dbg_deactivate_sw_breakpoints(void)\n{\n\tint error;\n\tint ret = 0;\n\tint i;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state != bp_active)\n\t\t\tcontinue;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error) {\n\t\t\tpr_info(\"bp remove failed: %lx\\n\",\n\t\t\t\tkgdb_break[i].bpt_addr);\n\t\t\tret = error;\n\t\t}\n\n\t\tkgdb_flush_swbreak_addr(kgdb_break[i].bpt_addr);\n\t\tkgdb_break[i].state = bp_set;\n\t}\n\treturn ret;\n}\n\nint dbg_remove_sw_break(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif ((kgdb_break[i].state == bp_set) &&\n\t\t\t\t(kgdb_break[i].bpt_addr == addr)) {\n\t\t\tkgdb_break[i].state = bp_removed;\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn -enoent;\n}\n\nint kgdb_isremovedbreak(unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif ((kgdb_break[i].state == bp_removed) &&\n\t\t\t\t\t(kgdb_break[i].bpt_addr == addr))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint dbg_remove_all_break(void)\n{\n\tint error;\n\tint i;\n\n\t\n\tfor (i = 0; i < kgdb_max_breakpoints; i++) {\n\t\tif (kgdb_break[i].state != bp_active)\n\t\t\tgoto setundefined;\n\t\terror = kgdb_arch_remove_breakpoint(&kgdb_break[i]);\n\t\tif (error)\n\t\t\tpr_err(\"breakpoint remove failed: %lx\\n\",\n\t\t\t       kgdb_break[i].bpt_addr);\nsetundefined:\n\t\tkgdb_break[i].state = bp_undefined;\n\t}\n\n\t\n\tif (arch_kgdb_ops.remove_all_hw_break)\n\t\tarch_kgdb_ops.remove_all_hw_break();\n\n\treturn 0;\n}\n\n\nstatic int kgdb_io_ready(int print_wait)\n{\n\tif (!dbg_io_ops)\n\t\treturn 0;\n\tif (kgdb_connected)\n\t\treturn 1;\n\tif (atomic_read(&kgdb_setting_breakpoint))\n\t\treturn 1;\n\tif (print_wait) {\n#ifdef config_kgdb_kdb\n\t\tif (!dbg_kdb_mode)\n\t\t\tpr_crit(\"waiting... or $3#33 for kdb\\n\");\n#else\n\t\tpr_crit(\"waiting for remote debugger\\n\");\n#endif\n\t}\n\treturn 1;\n}\n\nstatic int kgdb_reenter_check(struct kgdb_state *ks)\n{\n\tunsigned long addr;\n\n\tif (atomic_read(&kgdb_active) != raw_smp_processor_id())\n\t\treturn 0;\n\n\t\n\texception_level++;\n\taddr = kgdb_arch_pc(ks->", "4906": "< kj.tv64)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->", "4907": "< kprobe_table_size) ? pos : null;\n}\n\nstatic void *kprobe_seq_next(struct seq_file *f, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\tif (*pos >", "4908": "< kprobe_table_size; hash++) {\n\t\tkretprobe_table_lock(hash, &flags);\n\t\thead = &kretprobe_inst_table[hash];\n\t\thlist_for_each_entry_safe(ri, next, head, hlist) {\n\t\t\tif (ri->", "4909": "< kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tarm_kprobe(p);\n\t}\n\n\tprintk(kern_info \"kprobes globally enabled\\n\");\n\nalready_enabled:\n\tmutex_unlock(&kprobe_mutex);\n\treturn;\n}\n\nstatic void disarm_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\n\t\n\tif (kprobes_all_disarmed) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tkprobes_all_disarmed = true;\n\tprintk(kern_info \"kprobes globally disabled\\n\");\n\n\tfor (i = 0; i < kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!arch_trampoline_kprobe(p) && !kprobe_disabled(p))\n\t\t\t\tdisarm_kprobe(p, false);\n\t\t}\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\n\t\n\twait_for_kprobe_optimizer();\n}\n\n\nstatic ssize_t read_enabled_file_bool(struct file *file,\n\t       char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[3];\n\n\tif (!kprobes_all_disarmed)\n\t\tbuf[0] = '1';\n\telse\n\t\tbuf[0] = '0';\n\tbuf[1] = '\\n';\n\tbuf[2] = 0x00;\n\treturn simple_read_from_buffer(user_buf, count, ppos, buf, 2);\n}\n\nstatic ssize_t write_enabled_file_bool(struct file *file,\n\t       const char __user *user_buf, size_t count, loff_t *ppos)\n{\n\tchar buf[32];\n\tsize_t buf_size;\n\n\tbuf_size = min(count, (sizeof(buf)-1));\n\tif (copy_from_user(buf, user_buf, buf_size))\n\t\treturn -efault;\n\n\tbuf[buf_size] = '\\0';\n\tswitch (buf[0]) {\n\tcase 'y':\n\tcase 'y':\n\tcase '1':\n\t\tarm_all_kprobes();\n\t\tbreak;\n\tcase 'n':\n\tcase 'n':\n\tcase '0':\n\t\tdisarm_all_kprobes();\n\t\tbreak;\n\tdefault:\n\t\treturn -einval;\n\t}\n\n\treturn count;\n}\n\nstatic const struct file_operations fops_kp = {\n\t.read =         read_enabled_file_bool,\n\t.write =        write_enabled_file_bool,\n\t.llseek =\tdefault_llseek,\n};\n\nstatic int __init debugfs_kprobe_init(void)\n{\n\tstruct dentry *dir, *file;\n\tunsigned int value = 1;\n\n\tdir = debugfs_create_dir(\"kprobes\", null);\n\tif (!dir)\n\t\treturn -enomem;\n\n\tfile = debugfs_create_file(\"list\", 0444, dir, null,\n\t\t\t\t&debugfs_kprobes_operations);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"enabled\", 0600, dir,\n\t\t\t\t\t&value, &fops_kp);\n\tif (!file)\n\t\tgoto error;\n\n\tfile = debugfs_create_file(\"blacklist\", 0444, dir, null,\n\t\t\t\t&debugfs_kprobe_blacklist_ops);\n\tif (!file)\n\t\tgoto error;\n\n\treturn 0;\n\nerror:\n\tdebugfs_remove(dir);\n\treturn -enomem;\n}\n\nlate_initcall(debugfs_kprobe_init);\n#endif \n\nmodule_init(init_kprobes);\n\n\nexport_symbol_gpl(jprobe_return);\n\n\n\n#include <linux/list.h>", "4910": "< kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\toptimize_kprobe(p);\n\t}\n\tprintk(kern_info \"kprobes globally optimized\\n\");\nout:\n\tmutex_unlock(&kprobe_mutex);\n}\n\nstatic void unoptimize_all_kprobes(void)\n{\n\tstruct hlist_head *head;\n\tstruct kprobe *p;\n\tunsigned int i;\n\n\tmutex_lock(&kprobe_mutex);\n\t\n\tif (!kprobes_allow_optimization) {\n\t\tmutex_unlock(&kprobe_mutex);\n\t\treturn;\n\t}\n\n\tkprobes_allow_optimization = false;\n\tfor (i = 0; i < kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist) {\n\t\t\tif (!kprobe_disabled(p))\n\t\t\t\tunoptimize_kprobe(p, false);\n\t\t}\n\t}\n\tmutex_unlock(&kprobe_mutex);\n\n\t\n\twait_for_kprobe_optimizer();\n\tprintk(kern_info \"kprobes globally unoptimized\\n\");\n}\n\nstatic define_mutex(kprobe_sysctl_mutex);\nint sysctl_kprobes_optimization;\nint proc_kprobes_optimization_handler(struct ctl_table *table, int write,\n\t\t\t\t      void __user *buffer, size_t *length,\n\t\t\t\t      loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&kprobe_sysctl_mutex);\n\tsysctl_kprobes_optimization = kprobes_allow_optimization ? 1 : 0;\n\tret = proc_dointvec_minmax(table, write, buffer, length, ppos);\n\n\tif (sysctl_kprobes_optimization)\n\t\toptimize_all_kprobes();\n\telse\n\t\tunoptimize_all_kprobes();\n\tmutex_unlock(&kprobe_sysctl_mutex);\n\n\treturn ret;\n}\n#endif \n\n\nstatic void __arm_kprobe(struct kprobe *p)\n{\n\tstruct kprobe *_p;\n\n\t\n\t_p = get_optimized_kprobe((unsigned long)p->", "4911": "< kprobe_table_size; i++) {\n\t\thead = &kprobe_table[i];\n\t\thlist_for_each_entry_rcu(p, head, hlist)\n\t\t\tif (within_module_init((unsigned long)p->", "4912": "< kprobe_table_size; i++) {\n\t\tinit_hlist_head(&kprobe_table[i]);\n\t\tinit_hlist_head(&kretprobe_inst_table[i]);\n\t\traw_spin_lock_init(&(kretprobe_table_locks[i].lock));\n\t}\n\n\terr = populate_kprobe_blacklist(__start_kprobe_blacklist,\n\t\t\t\t\t__stop_kprobe_blacklist);\n\tif (err) {\n\t\tpr_err(\"kprobes: failed to populate blacklist: %d\\n\", err);\n\t\tpr_err(\"please take care of using kprobes.\\n\");\n\t}\n\n\tif (kretprobe_blacklist_size) {\n\t\t\n\t\tfor (i = 0; kretprobe_blacklist[i].name != null; i++) {\n\t\t\tkprobe_lookup_name(kretprobe_blacklist[i].name,\n\t\t\t\t\t   kretprobe_blacklist[i].addr);\n\t\t\tif (!kretprobe_blacklist[i].addr)\n\t\t\t\tprintk(\"kretprobe: lookup failed: %s\\n\",\n\t\t\t\t       kretprobe_blacklist[i].name);\n\t\t}\n\t}\n\n#if defined(config_optprobes)\n#if defined(__arch_want_kprobes_insn_slot)\n\t\n\tkprobe_optinsn_slots.insn_size = max_optinsn_size;\n#endif\n\t\n\tkprobes_allow_optimization = true;\n#endif\n\n\t\n\tkprobes_all_disarmed = false;\n\n\terr = arch_init_kprobes();\n\tif (!err)\n\t\terr = register_die_notifier(&kprobe_exceptions_nb);\n\tif (!err)\n\t\terr = register_module_notifier(&kprobe_module_nb);\n\n\tkprobes_initialized = (err == 0);\n\n\tif (!err)\n\t\tinit_test_probes();\n\treturn err;\n}\n\n#ifdef config_debug_fs\nstatic void report_probe(struct seq_file *pi, struct kprobe *p,\n\t\tconst char *sym, int offset, char *modname, struct kprobe *pp)\n{\n\tchar *kprobe_type;\n\n\tif (p->", "4913": "< len))\n\t\tgoto out;\n\n\titem = ring_buffer_event_data(event);\n\titem->", "4914": "< len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); \n}\n\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tbug_on(!ab->", "4915": "< len; i++) {\n\t\t\tif (call->", "4916": "< len; i++) {\n\t\tbuf += sprintf(buf, \"%s%02x\", i == 0 ? \"\" : \" \", cmd[i]);\n\t\tif (i == end && end != len - 1) {\n\t\t\tsprintf(buf, \" ..\");\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid blk_fill_rwbs(char *rwbs, u32 rw, int bytes)\n{\n\tint i = 0;\n\n\tif (rw & req_flush)\n\t\trwbs[i++] = 'f';\n\n\tif (rw & write)\n\t\trwbs[i++] = 'w';\n\telse if (rw & req_discard)\n\t\trwbs[i++] = 'd';\n\telse if (bytes)\n\t\trwbs[i++] = 'r';\n\telse\n\t\trwbs[i++] = 'n';\n\n\tif (rw & req_fua)\n\t\trwbs[i++] = 'f';\n\tif (rw & req_rahead)\n\t\trwbs[i++] = 'a';\n\tif (rw & req_sync)\n\t\trwbs[i++] = 's';\n\tif (rw & req_meta)\n\t\trwbs[i++] = 'm';\n\tif (rw & req_secure)\n\t\trwbs[i++] = 'e';\n\n\trwbs[i] = '\\0';\n}\nexport_symbol_gpl(blk_fill_rwbs);\n\n#endif \n\n\n\n#include <linux/export.h>", "4917": "< len; i++) {\n\t\tif (buff[i] == '*') {\n\t\t\tif (!i) {\n\t\t\t\t*search = buff + 1;\n\t\t\t\ttype = match_end_only;\n\t\t\t} else {\n\t\t\t\tif (type == match_end_only)\n\t\t\t\t\ttype = match_middle_only;\n\t\t\t\telse\n\t\t\t\t\ttype = match_front_only;\n\t\t\t\tbuff[i] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn type;\n}\n\nstatic void filter_build_regex(struct filter_pred *pred)\n{\n\tstruct regex *r = &pred->", "4918": "< length; src++) {\n\t\t\n\t\twhile (list[src] == list[src-1]) {\n\t\t\tsrc++;\n\t\t\tif (src == length)\n\t\t\t\tgoto after;\n\t\t}\n\t\t\n\t\tlist[dest] = list[src];\n\t\tdest++;\n\t}\nafter:\n\treturn dest;\n}\n\n\nstatic pid_t pid_fry(pid_t pid)\n{\n\tunsigned a = pid & 0x55555555;\n\tunsigned b = pid & 0xaaaaaaaa;\n\n\treturn (a << 1) | (b >", "4919": "< level; i++, j++) {\n\t\ttl[i] = (struct sched_domain_topology_level){\n\t\t\t.mask = sd_numa_mask,\n\t\t\t.sd_flags = cpu_numa_flags,\n\t\t\t.flags = sdtl_overlap,\n\t\t\t.numa_level = j,\n\t\t\tsd_init_name(numa)\n\t\t};\n\t}\n\n\tsched_domain_topology = tl;\n\n\tsched_domains_numa_levels = level;\n\tsched_max_numa_distance = sched_domains_numa_distance[level - 1];\n\n\tinit_numa_topology_type();\n}\n\nstatic void sched_domains_numa_masks_set(int cpu)\n{\n\tint i, j;\n\tint node = cpu_to_node(cpu);\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tif (node_distance(j, node) <= sched_domains_numa_distance[i])\n\t\t\t\tcpumask_set_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t\t}\n\t}\n}\n\nstatic void sched_domains_numa_masks_clear(int cpu)\n{\n\tint i, j;\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tcpumask_clear_cpu(cpu, sched_domains_numa_masks[i][j]);\n\t}\n}\n\n\nstatic int sched_domains_numa_masks_update(struct notifier_block *nfb,\n\t\t\t\t\t   unsigned long action,\n\t\t\t\t\t   void *hcpu)\n{\n\tint cpu = (long)hcpu;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_online:\n\t\tsched_domains_numa_masks_set(cpu);\n\t\tbreak;\n\n\tcase cpu_dead:\n\t\tsched_domains_numa_masks_clear(cpu);\n\t\tbreak;\n\n\tdefault:\n\t\treturn notify_done;\n\t}\n\n\treturn notify_ok;\n}\n#else\nstatic inline void sched_init_numa(void)\n{\n}\n\nstatic int sched_domains_numa_masks_update(struct notifier_block *nfb,\n\t\t\t\t\t   unsigned long action,\n\t\t\t\t\t   void *hcpu)\n{\n\treturn 0;\n}\n#endif \n\nstatic int __sdt_alloc(const struct cpumask *cpu_map)\n{\n\tstruct sched_domain_topology_level *tl;\n\tint j;\n\n\tfor_each_sd_topology(tl) {\n\t\tstruct sd_data *sdd = &tl->", "4920": "< levels_needed; i++) {\n\t\tnode = alloc_rtree_node(gfp_mask, safe_needed, ca,\n\t\t\t\t\t&zone->", "4921": "< lhs.tv_sec || res.tv_sec < rhs.tv_sec)\n\t\tres.tv_sec = time_t_max;\n\n\treturn res;\n}\n\n\n#include <linux/proc_fs.h>", "4922": "< limit) {\n\t\tif (!lzero || *id != 0) {\n\t\t\tpkt = hex_byte_pack(pkt, *id);\n\t\t\tlzero = 0;\n\t\t}\n\t\tid++;\n\t}\n\n\tif (lzero)\n\t\tpkt = hex_byte_pack(pkt, 0);\n\n\treturn pkt;\n}\n\nstatic void int_to_threadref(unsigned char *id, int value)\n{\n\tput_unaligned_be32(value, id);\n}\n\nstatic struct task_struct *getthread(struct pt_regs *regs, int tid)\n{\n\t\n\tif (tid == 0 || tid == -1)\n\t\ttid = -atomic_read(&kgdb_active) - 2;\n\tif (tid < -1 && tid >", "4923": "< load_b)\n\t\tswap(load_a, load_b);\n\n\t\n\timb = load_a * src_capacity * 100 -\n\t\tload_b * dst_capacity * env->", "4924": "< lockstat_points)\n\t\tstats->", "4925": "< lockstat_points; i++) {\n\t\tchar ip[32];\n\n\t\tif (class->", "4926": "< lockstat_points; i++) {\n\t\tif (points[i] == 0) {\n\t\t\tpoints[i] = ip;\n\t\t\tbreak;\n\t\t}\n\t\tif (points[i] == ip)\n\t\t\tbreak;\n\t}\n\n\treturn i;\n}\n\nstatic void lock_time_inc(struct lock_time *lt, u64 time)\n{\n\tif (time >", "4927": "< log_next_seq) {\n\t\tif (logbuf_has_space(msg_size, false))\n\t\t\treturn 0;\n\t\t\n\t\tlog_first_idx = log_next(log_first_idx);\n\t\tlog_first_seq++;\n\t}\n\n\t\n\tif (logbuf_has_space(msg_size, true))\n\t\treturn 0;\n\n\treturn -enomem;\n}\n\n\nstatic u32 msg_used_size(u16 text_len, u16 dict_len, u32 *pad_len)\n{\n\tu32 size;\n\n\tsize = sizeof(struct printk_log) + text_len + dict_len;\n\t*pad_len = (-size) & (log_align - 1);\n\tsize += *pad_len;\n\n\treturn size;\n}\n\n\n#define max_log_take_part 4\nstatic const char trunc_msg[] = \"<truncated>", "4928": "< long_max)\n\t\taccount_idle_ticks(ticks);\n#endif\n}\n\n\nvoid tick_nohz_idle_exit(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tlocal_irq_disable();\n\n\twarn_on_once(!ts->", "4929": "< loops; i++) {\n\t\t\tif (arch_read_trylock(&lock->", "4930": "< loops; i++) {\n\t\t\tif (arch_write_trylock(&lock->", "4931": "< loops; i++) {\n\t\tif (arch_spin_trylock(&lock->", "4932": "< lt->", "4933": "< lt_backtracedepth; q++) {\n\t\t\t\tunsigned long bt = lr->", "4934": "< lt_backtracedepth; q++) {\n\t\t\tunsigned long record = lat->", "4935": "< lt_backtracedepth; q++) {\n\t\t\tunsigned long record = lat.backtrace[q];\n\n\t\t\tif (mylat->", "4936": "< lzo_cmp_pages && asked) {\n\t\t\tret = hib_wait_on_bio_chain(&bio);\n\t\t\tif (ret)\n\t\t\t\tgoto out_finish;\n\t\t\thave += asked;\n\t\t\tasked = 0;\n\t\t\tif (eof)\n\t\t\t\teof = 2;\n\t\t}\n\n\t\tfor (run_threads = thr, thr = 0; thr < run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(kern_err\n\t\t\t\t       \"pm: lzo decompression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].unc_len ||\n\t\t\t             data[thr].unc_len >", "4937": "< lzo_header + data[thr].cmp_len;\n\t\t\t     off += page_size) {\n\t\t\t\tmemcpy(data[thr].cmp + off,\n\t\t\t\t       page[pg], page_size);\n\t\t\t\thave--;\n\t\t\t\twant++;\n\t\t\t\tif (++pg >", "4938": "< lzo_header + data[thr].cmp_len;\n\t\t\t     off += page_size) {\n\t\t\t\tmemcpy(page, data[thr].cmp + off, page_size);\n\n\t\t\t\tret = swap_write_page(handle, page, &bio);\n\t\t\t\tif (ret)\n\t\t\t\t\tgoto out_finish;\n\t\t\t}\n\t\t}\n\n\t\twait_event(crc->", "4939": "< map->", "4940": "< max_bpf_reg; i++) {\n\t\tregs[i].type = not_init;\n\t\tregs[i].imm = 0;\n\t\tregs[i].map_ptr = null;\n\t}\n\n\t\n\tregs[bpf_reg_fp].type = frame_ptr;\n\n\t\n\tregs[bpf_reg_1].type = ptr_to_ctx;\n}\n\nstatic void mark_reg_unknown_value(struct reg_state *regs, u32 regno)\n{\n\tbug_on(regno >", "4941": "< max_bpf_reg; i++) {\n\t\tt = env->", "4942": "< max_bpf_stack; i += bpf_reg_size) {\n\t\tif (env->", "4943": "< max_bpf_stack; i++) {\n\t\tif (old->", "4944": "< max_dma_channels ; i++) {\n\t\tif (dma_chan_busy[i].lock) {\n\t\t\tseq_printf(m, \"%2d: %s\\n\", i,\n\t\t\t\t   dma_chan_busy[i].device_id);\n\t\t}\n\t}\n\treturn 0;\n}\n#else\nstatic int proc_dma_show(struct seq_file *m, void *v)\n{\n\tseq_puts(m, \"no dma\\n\");\n\treturn 0;\n}\n#endif \n\nstatic int proc_dma_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, proc_dma_show, null);\n}\n\nstatic const struct file_operations proc_dma_operations = {\n\t.open\t\t= proc_dma_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= single_release,\n};\n\nstatic int __init proc_dma_init(void)\n{\n\tproc_create(\"dma\", 0, null, &proc_dma_operations);\n\treturn 0;\n}\n\n__initcall(proc_dma_init);\n#endif\n\nexport_symbol(request_dma);\nexport_symbol(free_dma);\nexport_symbol(dma_spin_lock);\n\n\n\n#include <linux/mm.h>", "4945": "< max_faults * 3 / 16)\n\t\t\tnode_clear(nid, numa_group->", "4946": "< max_lockdep_subclasses; j++) {\n\t\t\n\t\tclass = look_up_lock_class(lock, j);\n\t\tif (class)\n\t\t\tzap_class(class);\n\t}\n\t\n\tlocked = graph_lock();\n\tfor (i = 0; i < classhash_size; i++) {\n\t\thead = classhash_table + i;\n\t\tif (list_empty(head))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tint match = 0;\n\n\t\t\tfor (j = 0; j < nr_lockdep_caching_classes; j++)\n\t\t\t\tmatch |= class == lock->", "4947": "< max_optimized_length; i++)\n\t\tp = get_kprobe((void *)(addr - i));\n\n\tif (p && kprobe_optready(p)) {\n\t\top = container_of(p, struct optimized_kprobe, kp);\n\t\tif (arch_within_optimized_kprobe(op, addr))\n\t\t\treturn p;\n\t}\n\n\treturn null;\n}\n\n\nstatic list_head(optimizing_list);\nstatic list_head(unoptimizing_list);\nstatic list_head(freeing_list);\n\nstatic void kprobe_optimizer(struct work_struct *work);\nstatic declare_delayed_work(optimizing_work, kprobe_optimizer);\n#define optimize_delay 5\n\n\nstatic void do_optimize_kprobes(void)\n{\n\t\n\tif (kprobes_all_disarmed || !kprobes_allow_optimization ||\n\t    list_empty(&optimizing_list))\n\t\treturn;\n\n\t\n\tget_online_cpus();\n\tmutex_lock(&text_mutex);\n\tarch_optimize_kprobes(&optimizing_list);\n\tmutex_unlock(&text_mutex);\n\tput_online_cpus();\n}\n\n\nstatic void do_unoptimize_kprobes(void)\n{\n\tstruct optimized_kprobe *op, *tmp;\n\n\t\n\tif (list_empty(&unoptimizing_list))\n\t\treturn;\n\n\t\n\tget_online_cpus();\n\tmutex_lock(&text_mutex);\n\tarch_unoptimize_kprobes(&unoptimizing_list, &freeing_list);\n\t\n\tlist_for_each_entry_safe(op, tmp, &freeing_list, list) {\n\t\t\n\t\tif (kprobe_disabled(&op->", "4948": "< max_pinned_interval) ||\n\t\t\t(sd->", "4949": "< max_rt_prio; i++) {\n\t\tinit_list_head(array->", "4950": "< max_rt_test_mutexes; i++)\n\t\trt_mutex_init(&mutexes[i]);\n\n\tret = subsys_system_register(&rttest_subsys, null);\n\tif (ret)\n\t\treturn ret;\n\n\tfor (i = 0; i < max_rt_test_threads; i++) {\n\t\tret = init_test_thread(i);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = device_create_file(&thread_data[i].dev, &dev_attr_status);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tret = device_create_file(&thread_data[i].dev, &dev_attr_command);\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\tprintk(\"initializing rt-tester: %s\\n\", ret ? \"failed\" : \"ok\" );\n\n\treturn ret;\n}\n\ndevice_initcall(init_rttest);\n\n\n#include <linux/module.h>", "4951": "< max_rt_test_mutexes; i++) {\n\t\t\tif (td->", "4952": "< max_rt_test_threads; tid++) {\n\t\tif (threads[tid] == current)\n\t\t\tbreak;\n\t}\n\n\tbug_on(tid == max_rt_test_threads);\n\n\ttd = &thread_data[tid];\n\n\top = td->", "4953": "< max_scan_window)\n\t\twindows = max_scan_window / scan_size;\n\tfloor = 1000 / windows;\n\n\tscan = sysctl_numa_balancing_scan_period_min / task_nr_scan_windows(p);\n\treturn max_t(unsigned int, floor, scan);\n}\n\nstatic unsigned int task_scan_max(struct task_struct *p)\n{\n\tunsigned int smin = task_scan_min(p);\n\tunsigned int smax;\n\n\t\n\tsmax = sysctl_numa_balancing_scan_period_max / task_nr_scan_windows(p);\n\treturn max(smin, smax);\n}\n\nstatic void account_numa_enqueue(struct rq *rq, struct task_struct *p)\n{\n\trq->", "4954": "< max_stack_trace.nr_entries; i++) {\n\t\tif (stack_dump_trace[i] == ulong_max)\n\t\t\tbreak;\n\t\tif (i+1 == max_stack_trace.nr_entries ||\n\t\t\t\tstack_dump_trace[i+1] == ulong_max)\n\t\t\tsize = stack_dump_index[i];\n\t\telse\n\t\t\tsize = stack_dump_index[i] - stack_dump_index[i+1];\n\n\t\tpr_emerg(\"%3ld) %8d   %5d   %ps\\n\", i, stack_dump_index[i],\n\t\t\t\tsize, (void *)stack_dump_trace[i]);\n\t}\n}\n\nstatic inline void\ncheck_stack(unsigned long ip, unsigned long *stack)\n{\n\tunsigned long this_size, flags; unsigned long *p, *top, *start;\n\tstatic int tracer_frame;\n\tint frame_size = access_once(tracer_frame);\n\tint i;\n\n\tthis_size = ((unsigned long)stack) & (thread_size-1);\n\tthis_size = thread_size - this_size;\n\t\n\tthis_size -= frame_size;\n\n\tif (this_size <= max_stack_size)\n\t\treturn;\n\n\t\n\tif (!object_is_on_stack(stack))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tarch_spin_lock(&max_stack_lock);\n\n\t\n\tif (unlikely(!frame_size))\n\t\tthis_size -= tracer_frame;\n\n\t\n\tif (this_size <= max_stack_size)\n\t\tgoto out;\n\n\tmax_stack_size = this_size;\n\n\tmax_stack_trace.nr_entries = 0;\n\n\tif (using_ftrace_ops_list_func())\n\t\tmax_stack_trace.skip = 4;\n\telse\n\t\tmax_stack_trace.skip = 3;\n\n\tsave_stack_trace(&max_stack_trace);\n\n\t\n\tstack_dump_trace[0] = ip;\n\tmax_stack_trace.nr_entries++;\n\n\t\n\ti = 0;\n\tstart = stack;\n\ttop = (unsigned long *)\n\t\t(((unsigned long)start & ~(thread_size-1)) + thread_size);\n\n\t\n\twhile (i < max_stack_trace.nr_entries) {\n\t\tint found = 0;\n\n\t\tstack_dump_index[i] = this_size;\n\t\tp = start;\n\n\t\tfor (; p < top && i < max_stack_trace.nr_entries; p++) {\n\t\t\tif (*p == stack_dump_trace[i]) {\n\t\t\t\tthis_size = stack_dump_index[i++] =\n\t\t\t\t\t(top - p) * sizeof(unsigned long);\n\t\t\t\tfound = 1;\n\t\t\t\t\n\t\t\t\tstart = p + 1;\n\t\t\t\t\n\t\t\t\tif (unlikely(!tracer_frame) && i == 1) {\n\t\t\t\t\ttracer_frame = (p - stack) *\n\t\t\t\t\t\tsizeof(unsigned long);\n\t\t\t\t\tmax_stack_size -= tracer_frame;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!found)\n\t\t\ti++;\n\t}\n\n\tif (task_stack_end_corrupted(current)) {\n\t\tprint_max_stack();\n\t\tbug();\n\t}\n\n out:\n\tarch_spin_unlock(&max_stack_lock);\n\tlocal_irq_restore(flags);\n}\n\nstatic void\nstack_trace_call(unsigned long ip, unsigned long parent_ip,\n\t\t struct ftrace_ops *op, struct pt_regs *pt_regs)\n{\n\tunsigned long stack;\n\tint cpu;\n\n\tpreempt_disable_notrace();\n\n\tcpu = raw_smp_processor_id();\n\t\n\tif (per_cpu(trace_active, cpu)++ != 0)\n\t\tgoto out;\n\n\t\n\tif (fentry)\n\t\tip = parent_ip;\n\telse\n\t\tip += mcount_insn_size;\n\n\tcheck_stack(ip, &stack);\n\n out:\n\tper_cpu(trace_active, cpu)--;\n\t\n\tpreempt_enable_notrace();\n}\n\nstatic struct ftrace_ops trace_ops __read_mostly =\n{\n\t.func = stack_trace_call,\n\t.flags = ftrace_ops_fl_recursion_safe,\n};\n\nstatic ssize_t\nstack_max_size_read(struct file *filp, char __user *ubuf,\n\t\t    size_t count, loff_t *ppos)\n{\n\tunsigned long *ptr = filp->", "4955": "< max_zone_pfn; pfn++)\n\t\t\tif (page_is_saveable(zone, pfn))\n\t\t\t\tmemory_bm_set_bit(orig_bm, pfn);\n\t}\n\tmemory_bm_position_reset(orig_bm);\n\tmemory_bm_position_reset(copy_bm);\n\tfor(;;) {\n\t\tpfn = memory_bm_next_pfn(orig_bm);\n\t\tif (unlikely(pfn == bm_end_of_map))\n\t\t\tbreak;\n\t\tcopy_data_page(memory_bm_next_pfn(copy_bm), pfn);\n\t}\n}\n\n\nstatic unsigned int nr_copy_pages;\n\nstatic unsigned int nr_meta_pages;\n\nunsigned int alloc_normal, alloc_highmem;\n\nstatic struct memory_bitmap orig_bm;\n\nstatic struct memory_bitmap copy_bm;\n\n\n\nvoid swsusp_free(void)\n{\n\tunsigned long fb_pfn, fr_pfn;\n\n\tif (!forbidden_pages_map || !free_pages_map)\n\t\tgoto out;\n\n\tmemory_bm_position_reset(forbidden_pages_map);\n\tmemory_bm_position_reset(free_pages_map);\n\nloop:\n\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\n\t\n\tdo {\n\t\tif (fb_pfn < fr_pfn)\n\t\t\tfb_pfn = memory_bm_next_pfn(forbidden_pages_map);\n\t\tif (fr_pfn < fb_pfn)\n\t\t\tfr_pfn = memory_bm_next_pfn(free_pages_map);\n\t} while (fb_pfn != fr_pfn);\n\n\tif (fr_pfn != bm_end_of_map && pfn_valid(fr_pfn)) {\n\t\tstruct page *page = pfn_to_page(fr_pfn);\n\n\t\tmemory_bm_clear_current(forbidden_pages_map);\n\t\tmemory_bm_clear_current(free_pages_map);\n\t\t__free_page(page);\n\t\tgoto loop;\n\t}\n\nout:\n\tnr_copy_pages = 0;\n\tnr_meta_pages = 0;\n\trestore_pblist = null;\n\tbuffer = null;\n\talloc_normal = 0;\n\talloc_highmem = 0;\n}\n\n\n\n#define gfp_image\t(gfp_kernel | __gfp_nowarn)\n\n\nstatic unsigned long preallocate_image_pages(unsigned long nr_pages, gfp_t mask)\n{\n\tunsigned long nr_alloc = 0;\n\n\twhile (nr_pages >", "4956": "< max_zone_pfn; pfn++)\n\t\t\tif (pfn_valid(pfn))\n\t\t\t\tswsusp_unset_page_free(pfn_to_page(pfn));\n\t}\n\n\t\n\tmemory_bm_position_reset(bm);\n\tdo {\n\t\tpfn = memory_bm_next_pfn(bm);\n\t\tif (likely(pfn != bm_end_of_map)) {\n\t\t\tif (likely(pfn_valid(pfn)))\n\t\t\t\tswsusp_set_page_free(pfn_to_page(pfn));\n\t\t\telse\n\t\t\t\treturn -efault;\n\t\t}\n\t} while (pfn != bm_end_of_map);\n\n\tallocated_unsafe_pages = 0;\n\n\treturn 0;\n}\n\nstatic void\nduplicate_memory_bitmap(struct memory_bitmap *dst, struct memory_bitmap *src)\n{\n\tunsigned long pfn;\n\n\tmemory_bm_position_reset(src);\n\tpfn = memory_bm_next_pfn(src);\n\twhile (pfn != bm_end_of_map) {\n\t\tmemory_bm_set_bit(dst, pfn);\n\t\tpfn = memory_bm_next_pfn(src);\n\t}\n}\n\nstatic int check_header(struct swsusp_info *info)\n{\n\tchar *reason;\n\n\treason = check_image_kernel(info);\n\tif (!reason && info->", "4957": "< max_zone_pfn; pfn++)\n\t\t\tif (saveable_highmem_page(zone, pfn))\n\t\t\t\tn++;\n\t}\n\treturn n;\n}\n#else\nstatic inline void *saveable_highmem_page(struct zone *z, unsigned long p)\n{\n\treturn null;\n}\n#endif \n\n\nstatic struct page *saveable_page(struct zone *zone, unsigned long pfn)\n{\n\tstruct page *page;\n\n\tif (!pfn_valid(pfn))\n\t\treturn null;\n\n\tpage = pfn_to_page(pfn);\n\tif (page_zone(page) != zone)\n\t\treturn null;\n\n\tbug_on(pagehighmem(page));\n\n\tif (swsusp_page_is_forbidden(page) || swsusp_page_is_free(page))\n\t\treturn null;\n\n\tif (pagereserved(page)\n\t    && (!kernel_page_present(page) || pfn_is_nosave(pfn)))\n\t\treturn null;\n\n\tif (page_is_guard(page))\n\t\treturn null;\n\n\treturn page;\n}\n\n\n\nstatic unsigned int count_data_pages(void)\n{\n\tstruct zone *zone;\n\tunsigned long pfn, max_zone_pfn;\n\tunsigned int n = 0;\n\n\tfor_each_populated_zone(zone) {\n\t\tif (is_highmem(zone))\n\t\t\tcontinue;\n\n\t\tmark_free_pages(zone);\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->", "4958": "< max_zone_pfn; pfn++)\n\t\t\tif (saveable_page(zone, pfn))\n\t\t\t\tn++;\n\t}\n\treturn n;\n}\n\n\nstatic inline void do_copy_page(long *dst, long *src)\n{\n\tint n;\n\n\tfor (n = page_size / sizeof(long); n; n--)\n\t\t*dst++ = *src++;\n}\n\n\n\nstatic void safe_copy_page(void *dst, struct page *s_page)\n{\n\tif (kernel_page_present(s_page)) {\n\t\tdo_copy_page(dst, page_address(s_page));\n\t} else {\n\t\tkernel_map_pages(s_page, 1, 1);\n\t\tdo_copy_page(dst, page_address(s_page));\n\t\tkernel_map_pages(s_page, 1, 0);\n\t}\n}\n\n\n#ifdef config_highmem\nstatic inline struct page *\npage_is_saveable(struct zone *zone, unsigned long pfn)\n{\n\treturn is_highmem(zone) ?\n\t\tsaveable_highmem_page(zone, pfn) : saveable_page(zone, pfn);\n}\n\nstatic void copy_data_page(unsigned long dst_pfn, unsigned long src_pfn)\n{\n\tstruct page *s_page, *d_page;\n\tvoid *src, *dst;\n\n\ts_page = pfn_to_page(src_pfn);\n\td_page = pfn_to_page(dst_pfn);\n\tif (pagehighmem(s_page)) {\n\t\tsrc = kmap_atomic(s_page);\n\t\tdst = kmap_atomic(d_page);\n\t\tdo_copy_page(dst, src);\n\t\tkunmap_atomic(dst);\n\t\tkunmap_atomic(src);\n\t} else {\n\t\tif (pagehighmem(d_page)) {\n\t\t\t\n\t\t\tsafe_copy_page(buffer, s_page);\n\t\t\tdst = kmap_atomic(d_page);\n\t\t\tcopy_page(dst, buffer);\n\t\t\tkunmap_atomic(dst);\n\t\t} else {\n\t\t\tsafe_copy_page(page_address(d_page), s_page);\n\t\t}\n\t}\n}\n#else\n#define page_is_saveable(zone, pfn)\tsaveable_page(zone, pfn)\n\nstatic inline void copy_data_page(unsigned long dst_pfn, unsigned long src_pfn)\n{\n\tsafe_copy_page(page_address(pfn_to_page(dst_pfn)),\n\t\t\t\tpfn_to_page(src_pfn));\n}\n#endif \n\nstatic void\ncopy_data_pages(struct memory_bitmap *copy_bm, struct memory_bitmap *orig_bm)\n{\n\tstruct zone *zone;\n\tunsigned long pfn;\n\n\tfor_each_populated_zone(zone) {\n\t\tunsigned long max_zone_pfn;\n\n\t\tmark_free_pages(zone);\n\t\tmax_zone_pfn = zone_end_pfn(zone);\n\t\tfor (pfn = zone->", "4959": "< maxlen);\n\n\tdst[-1] = '\\0';\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\tif (ret < 0) {\t\n\t\t((u8 *)get_rloc_data(dest))[0] = '\\0';\n\t\t*(u32 *)dest = make_data_rloc(0, get_rloc_offs(*(u32 *)dest));\n\t} else {\n\t\t*(u32 *)dest = make_data_rloc(src - (u8 *)addr,\n\t\t\t\t\t      get_rloc_offs(*(u32 *)dest));\n\t}\n}\nnokprobe_symbol(fetch_func_name(memory, string));\n\n\nstatic void fetch_func_name(memory, string_size)(struct pt_regs *regs,\n\t\t\t\t\t\t void *addr, void *dest)\n{\n\tmm_segment_t old_fs;\n\tint ret, len = 0;\n\tu8 c;\n\n\told_fs = get_fs();\n\tset_fs(kernel_ds);\n\tpagefault_disable();\n\n\tdo {\n\t\tret = __copy_from_user_inatomic(&c, (u8 *)addr + len, 1);\n\t\tlen++;\n\t} while (c && ret == 0 && len < max_string_size);\n\n\tpagefault_enable();\n\tset_fs(old_fs);\n\n\tif (ret < 0)\t\n\t\t*(u32 *)dest = 0;\n\telse\n\t\t*(u32 *)dest = len;\n}\nnokprobe_symbol(fetch_func_name(memory, string_size));\n\n#define define_fetch_symbol(type)\t\t\t\t\t\\\nvoid fetch_func_name(symbol, type)(struct pt_regs *regs, void *data, void *dest)\\\n{\t\t\t\t\t\t\t\t\t\\\n\tstruct symbol_cache *sc = data;\t\t\t\t\t\\\n\tif (sc->", "4960": "< maxlr; i++) {\n\t\tint q, same = 1;\n\n\t\t\n\t\tif (!latency_record[i].backtrace[0]) {\n\t\t\tif (firstnonnull >", "4961": "< maxlr; i++) {\n\t\tstruct latency_record *lr = &latency_record[i];\n\n\t\tif (lr->", "4962": "< maxreserve) {\n\t\t\tstruct resource *res = reserve + x;\n\t\t\tres->", "4963": "< mcount_insn_size; i++)\n\t\tprintk(kern_cont \"%s%02x\", i ? \":\" : \"\", p[i]);\n}\n\nstatic struct ftrace_ops *\nftrace_find_tramp_ops_any(struct dyn_ftrace *rec);\n\n\nvoid ftrace_bug(int failed, struct dyn_ftrace *rec)\n{\n\tunsigned long ip = rec ? rec->", "4964": "< mend))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nstatic struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)\n{\n\tstruct page *pages;\n\n\tpages = alloc_pages(gfp_mask, order);\n\tif (pages) {\n\t\tunsigned int count, i;\n\t\tpages->", "4965": "< meta->", "4966": "< min)\n\t\t\t\tbreak;\n\t\t\tlist_add(&u->", "4967": "< min)\n\t\tres->", "4968": "< min) {\n\t\tpr_err(\"%s: needs at least %i arguments\\n\", name, min);\n\t\treturn -einval;\n\t}\n\treturn 0;\n}\n\nstatic int param_array_set(const char *val, const struct kernel_param *kp)\n{\n\tconst struct kparam_array *arr = kp->", "4969": "< min.tv64))\n\t\t\tmin = delta;\n\t}\n\tif (min.tv64 == 0)\n\t\treturn 0;\n\n\tif (ktime_to_ns(min) < 2 * nsec_per_sec) {\n\t\t__pm_wakeup_event(ws, 2 * msec_per_sec);\n\t\treturn -ebusy;\n\t}\n\n\t\n\trtc_timer_cancel(rtc, &rtctimer);\n\trtc_read_time(rtc, &tm);\n\tnow = rtc_tm_to_ktime(tm);\n\tnow = ktime_add(now, min);\n\n\t\n\tret = rtc_timer_start(rtc, &rtctimer, now, ktime_set(0, 0));\n\tif (ret < 0)\n\t\t__pm_wakeup_event(ws, msec_per_sec);\n\treturn ret;\n}\n#else\nstatic int alarmtimer_suspend(struct device *dev)\n{\n\treturn 0;\n}\n#endif\n\nstatic void alarmtimer_freezerset(ktime_t absexp, enum alarmtimer_type type)\n{\n\tktime_t delta;\n\tunsigned long flags;\n\tstruct alarm_base *base = &alarm_bases[type];\n\n\tdelta = ktime_sub(absexp, base->", "4970": "< min_cfs_quota_period || period < min_cfs_quota_period)\n\t\treturn -einval;\n\n\t\n\tif (period >", "4971": "< min_exit_latency) {\n\t\t\t\t\n\t\t\t\tmin_exit_latency = idle->", "4972": "< min_expire)\n\t\treturn 1;\n\n\treturn 0;\n}\n\nstatic void start_cfs_slack_bandwidth(struct cfs_bandwidth *cfs_b)\n{\n\tu64 min_left = cfs_bandwidth_slack_period + min_bandwidth_expiration;\n\n\t\n\tif (runtime_refresh_within(cfs_b, min_left))\n\t\treturn;\n\n\tstart_bandwidth_timer(&cfs_b->", "4973": "< min_load || (load == min_load && i == this_cpu)) {\n\t\t\t\tmin_load = load;\n\t\t\t\tleast_loaded_cpu = i;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn shallowest_idle_cpu != -1 ? shallowest_idle_cpu : least_loaded_cpu;\n}\n\n\nstatic int select_idle_sibling(struct task_struct *p, int target)\n{\n\tstruct sched_domain *sd;\n\tstruct sched_group *sg;\n\tint i = task_cpu(p);\n\n\tif (idle_cpu(target))\n\t\treturn target;\n\n\t\n\tif (i != target && cpus_share_cache(i, target) && idle_cpu(i))\n\t\treturn i;\n\n\t\n\tsd = rcu_dereference(per_cpu(sd_llc, target));\n\tfor_each_lower_domain(sd) {\n\t\tsg = sd->", "4974": "< min_load) {\n\t\t\tmin_load = avg_load;\n\t\t\tidlest = group;\n\t\t}\n\t} while (group = group->", "4975": "< min_nice || nice >", "4976": "< min_shares)\n\t\t\twl = min_shares;\n\n\t\t\n\t\twl -= se->", "4977": "< min_shares)\n\t\tshares = min_shares;\n\tif (shares >", "4978": "< minsec)\n\t\treturn 0;\n\n\tif (!(time_status & sta_fll) && (secs <= maxsec))\n\t\treturn 0;\n\n\ttime_status |= sta_mode;\n\n\treturn div64_long(offset64 << (ntp_scale_shift - shift_fll), secs);\n}\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & sta_pll))\n\t\treturn;\n\n\tif (!(time_status & sta_nano))\n\t\toffset *= nsec_per_usec;\n\n\t\n\toffset = min(offset, maxphase);\n\toffset = max(offset, -maxphase);\n\n\t\n\tsecs = get_seconds() - time_reftime;\n\tif (unlikely(time_status & sta_freqhold))\n\t\tsecs = 0;\n\n\ttime_reftime = get_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t\n\tif (unlikely(secs >", "4979": "< minsigstksz)\n\t\t\t\tgoto out;\n\t\t}\n\n\t\tcurrent->", "4980": "< mk->", "4981": "< mmap_min_addr)\n\t\t\tgoto out;\n\t}\n\n\t\n#define __prctl_check_order(__m1, __op, __m2)\t\t\t\t\\\n\t((unsigned long)prctl_map->", "4982": "< mmap_min_addr)\n\t\treturn -einval;\n\n\terror = -einval;\n\n\tdown_read(&mm->", "4983": "< mod->", "4984": "< module_addr_min || addr >", "4985": "< module_addr_min)\n\t\t\tmodule_addr_min = (unsigned long)ret;\n\t\tif ((unsigned long)ret + size >", "4986": "< msecs; i++) {\n\t\ttouch_nmi_watchdog();\n\t\tmdelay(1);\n\t}\n}\n\n\nstatic void do_oops_enter_exit(void)\n{\n\tunsigned long flags;\n\tstatic int spin_counter;\n\n\tif (!pause_on_oops)\n\t\treturn;\n\n\tspin_lock_irqsave(&pause_on_oops_lock, flags);\n\tif (pause_on_oops_flag == 0) {\n\t\t\n\t\tpause_on_oops_flag = 1;\n\t} else {\n\t\t\n\t\tif (!spin_counter) {\n\t\t\t\n\t\t\tspin_counter = pause_on_oops;\n\t\t\tdo {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(msec_per_sec);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t} while (--spin_counter);\n\t\t\tpause_on_oops_flag = 0;\n\t\t} else {\n\t\t\t\n\t\t\twhile (spin_counter) {\n\t\t\t\tspin_unlock(&pause_on_oops_lock);\n\t\t\t\tspin_msec(1);\n\t\t\t\tspin_lock(&pause_on_oops_lock);\n\t\t\t}\n\t\t}\n\t}\n\tspin_unlock_irqrestore(&pause_on_oops_lock, flags);\n}\n\n\nint oops_may_print(void)\n{\n\treturn pause_on_oops_flag == 0;\n}\n\n\nvoid oops_enter(void)\n{\n\ttracing_off();\n\t\n\tdebug_locks_off();\n\tdo_oops_enter_exit();\n}\n\n\nstatic u64 oops_id;\n\nstatic int init_oops_id(void)\n{\n\tif (!oops_id)\n\t\tget_random_bytes(&oops_id, sizeof(oops_id));\n\telse\n\t\toops_id++;\n\n\treturn 0;\n}\nlate_initcall(init_oops_id);\n\nvoid print_oops_end_marker(void)\n{\n\tinit_oops_id();\n\tpr_warn(\"---[ end trace %016llx ]---\\n\", (unsigned long long)oops_id);\n}\n\n\nvoid oops_exit(void)\n{\n\tdo_oops_enter_exit();\n\tprint_oops_end_marker();\n\tkmsg_dump(kmsg_dump_oops);\n}\n\n#ifdef want_warn_on_slowpath\nstruct slowpath_args {\n\tconst char *fmt;\n\tva_list args;\n};\n\nstatic void warn_slowpath_common(const char *file, int line, void *caller,\n\t\t\t\t unsigned taint, struct slowpath_args *args)\n{\n\tdisable_trace_on_warning();\n\n\tpr_warn(\"------------[ cut here ]------------\\n\");\n\tpr_warn(\"warning: cpu: %d pid: %d at %s:%d %ps()\\n\",\n\t\traw_smp_processor_id(), current->", "4987": "< mult_adj)) {\n\t\t\n\t\twarn_on_once(1);\n\t\treturn;\n\t}\n\n\ttk->", "4988": "< n; i++)\n\t\tnode = rb_next(node);\n\n\treturn node;\n}\n\nstatic void *stat_seq_next(struct seq_file *s, void *p, loff_t *pos)\n{\n\tstruct stat_session *session = s->", "4989": "< n; i++) {\n\t\tif (dash2underscore(a[i]) != dash2underscore(b[i]))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool parameq(const char *a, const char *b)\n{\n\treturn parameqn(a, b, strlen(a)+1);\n}\n\nstatic void param_check_unsafe(const struct kernel_param *kp)\n{\n\tif (kp->", "4990": "< n_barrier_cbs; i++)\n\t\t\twake_up(&barrier_cbs_wq[i]);\n\t\twait_event(barrier_wq,\n\t\t\t   atomic_read(&barrier_cbs_count) == 0 ||\n\t\t\t   torture_must_stop());\n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tn_barrier_attempts++;\n\t\tcur_ops->", "4991": "< n_barrier_cbs; i++) {\n\t\tinit_waitqueue_head(&barrier_cbs_wq[i]);\n\t\tret = torture_create_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     (void *)(long)i,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn torture_create_kthread(rcu_torture_barrier, null, barrier_task);\n}\n\n\nstatic void rcu_torture_barrier_cleanup(void)\n{\n\tint i;\n\n\ttorture_stop_kthread(rcu_torture_barrier, barrier_task);\n\tif (barrier_cbs_tasks != null) {\n\t\tfor (i = 0; i < n_barrier_cbs; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_barrier_cbs,\n\t\t\t\t\t     barrier_cbs_tasks[i]);\n\t\tkfree(barrier_cbs_tasks);\n\t\tbarrier_cbs_tasks = null;\n\t}\n\tif (barrier_cbs_wq != null) {\n\t\tkfree(barrier_cbs_wq);\n\t\tbarrier_cbs_wq = null;\n\t}\n}\n\nstatic int rcutorture_cpu_notify(struct notifier_block *self,\n\t\t\t\t unsigned long action, void *hcpu)\n{\n\tlong cpu = (long)hcpu;\n\n\tswitch (action) {\n\tcase cpu_online:\n\tcase cpu_down_failed:\n\t\t(void)rcutorture_booster_init(cpu);\n\t\tbreak;\n\tcase cpu_down_prepare:\n\t\trcutorture_booster_cleanup(cpu);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\nstatic struct notifier_block rcutorture_cpu_nb = {\n\t.notifier_call = rcutorture_cpu_notify,\n};\n\nstatic void\nrcu_torture_cleanup(void)\n{\n\tint i;\n\n\trcutorture_record_test_transition();\n\tif (torture_cleanup_begin()) {\n\t\tif (cur_ops->", "4992": "< n_preds; i++) {\n\t\tpred = &filter->", "4993": "< n_stress; i++) {\n\t\tif (statp[i].n_lock_fail)\n\t\t\tfail = true;\n\t\tsum += statp[i].n_lock_acquired;\n\t\tif (max < statp[i].n_lock_fail)\n\t\t\tmax = statp[i].n_lock_fail;\n\t\tif (min >", "4994": "< nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->", "4995": "< ncbflooders; i++) {\n\t\t\tfirsterr = torture_create_kthread(rcu_torture_cbflood,\n\t\t\t\t\t\t\t  null,\n\t\t\t\t\t\t\t  cbflood_task[i]);\n\t\t\tif (firsterr)\n\t\t\t\tgoto unwind;\n\t\t}\n\t}\n\trcutorture_record_test_transition();\n\ttorture_init_end();\n\treturn 0;\n\nunwind:\n\ttorture_init_end();\n\trcu_torture_cleanup();\n\treturn firsterr;\n}\n\nmodule_init(rcu_torture_init);\nmodule_exit(rcu_torture_cleanup);\n\n\n#define pr_fmt(fmt) \"kgdb: \" fmt\n\n#include <linux/pid_namespace.h>", "4996": "< ndoms; i++) {\n\t\tif (!alloc_cpumask_var(&doms[i], gfp_kernel)) {\n\t\t\tfree_sched_domains(doms, i);\n\t\t\treturn null;\n\t\t}\n\t}\n\treturn doms;\n}\n\nvoid free_sched_domains(cpumask_var_t doms[], unsigned int ndoms)\n{\n\tunsigned int i;\n\tfor (i = 0; i < ndoms; i++)\n\t\tfree_cpumask_var(doms[i]);\n\tkfree(doms);\n}\n\n\nstatic int init_sched_domains(const struct cpumask *cpu_map)\n{\n\tint err;\n\n\tarch_update_cpu_topology();\n\tndoms_cur = 1;\n\tdoms_cur = alloc_sched_domains(ndoms_cur);\n\tif (!doms_cur)\n\t\tdoms_cur = &fallback_doms;\n\tcpumask_andnot(doms_cur[0], cpu_map, cpu_isolated_map);\n\terr = build_sched_domains(doms_cur[0], null);\n\tregister_sched_domain_sysctl();\n\n\treturn err;\n}\n\n\nstatic void detach_destroy_domains(const struct cpumask *cpu_map)\n{\n\tint i;\n\n\trcu_read_lock();\n\tfor_each_cpu(i, cpu_map)\n\t\tcpu_attach_domain(null, &def_root_domain, i);\n\trcu_read_unlock();\n}\n\n\nstatic int dattrs_equal(struct sched_domain_attr *cur, int idx_cur,\n\t\t\tstruct sched_domain_attr *new, int idx_new)\n{\n\tstruct sched_domain_attr tmp;\n\n\t\n\tif (!new && !cur)\n\t\treturn 1;\n\n\ttmp = sd_attr_init;\n\treturn !memcmp(cur ? (cur + idx_cur) : &tmp,\n\t\t\tnew ? (new + idx_new) : &tmp,\n\t\t\tsizeof(struct sched_domain_attr));\n}\n\n\nvoid partition_sched_domains(int ndoms_new, cpumask_var_t doms_new[],\n\t\t\t     struct sched_domain_attr *dattr_new)\n{\n\tint i, j, n;\n\tint new_topology;\n\n\tmutex_lock(&sched_domains_mutex);\n\n\t\n\tunregister_sched_domain_sysctl();\n\n\t\n\tnew_topology = arch_update_cpu_topology();\n\n\tn = doms_new ? ndoms_new : 0;\n\n\t\n\tfor (i = 0; i < ndoms_cur; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_cur[i], doms_new[j])\n\t\t\t    && dattrs_equal(dattr_cur, i, dattr_new, j))\n\t\t\t\tgoto match1;\n\t\t}\n\t\t\n\t\tdetach_destroy_domains(doms_cur[i]);\nmatch1:\n\t\t;\n\t}\n\n\tn = ndoms_cur;\n\tif (doms_new == null) {\n\t\tn = 0;\n\t\tdoms_new = &fallback_doms;\n\t\tcpumask_andnot(doms_new[0], cpu_active_mask, cpu_isolated_map);\n\t\twarn_on_once(dattr_new);\n\t}\n\n\t\n\tfor (i = 0; i < ndoms_new; i++) {\n\t\tfor (j = 0; j < n && !new_topology; j++) {\n\t\t\tif (cpumask_equal(doms_new[i], doms_cur[j])\n\t\t\t    && dattrs_equal(dattr_new, i, dattr_cur, j))\n\t\t\t\tgoto match2;\n\t\t}\n\t\t\n\t\tbuild_sched_domains(doms_new[i], dattr_new ? dattr_new + i : null);\nmatch2:\n\t\t;\n\t}\n\n\t\n\tif (doms_cur != &fallback_doms)\n\t\tfree_sched_domains(doms_cur, ndoms_cur);\n\tkfree(dattr_cur);\t\n\tdoms_cur = doms_new;\n\tdattr_cur = dattr_new;\n\tndoms_cur = ndoms_new;\n\n\tregister_sched_domain_sysctl();\n\n\tmutex_unlock(&sched_domains_mutex);\n}\n\nstatic int num_cpus_frozen;\t\n\n\nstatic int cpuset_cpu_active(struct notifier_block *nfb, unsigned long action,\n\t\t\t     void *hcpu)\n{\n\tswitch (action) {\n\tcase cpu_online_frozen:\n\tcase cpu_down_failed_frozen:\n\n\t\t\n\t\tnum_cpus_frozen--;\n\t\tif (likely(num_cpus_frozen)) {\n\t\t\tpartition_sched_domains(1, null, null);\n\t\t\tbreak;\n\t\t}\n\n\t\t\n\n\tcase cpu_online:\n\t\tcpuset_update_active_cpus(true);\n\t\tbreak;\n\tdefault:\n\t\treturn notify_done;\n\t}\n\treturn notify_ok;\n}\n\nstatic int cpuset_cpu_inactive(struct notifier_block *nfb, unsigned long action,\n\t\t\t       void *hcpu)\n{\n\tunsigned long flags;\n\tlong cpu = (long)hcpu;\n\tstruct dl_bw *dl_b;\n\n\tswitch (action & ~cpu_tasks_frozen) {\n\tcase cpu_down_prepare:\n\t\t\n\t\tif (!(action & cpu_tasks_frozen)) {\n\t\t\tbool overflow;\n\t\t\tint cpus;\n\n\t\t\trcu_read_lock_sched();\n\t\t\tdl_b = dl_bw_of(cpu);\n\n\t\t\traw_spin_lock_irqsave(&dl_b->", "4997": "< new->", "4998": "< new_map->", "4999": "< new_map.nr_extents; idx++) {\n\t\tu32 lower_first;\n\t\textent = &new_map.extent[idx];\n\n\t\tlower_first = map_id_range_down(parent_map,\n\t\t\t\t\t\textent->", "5000": "< next_distance ||\n\t\t\t\t     next_distance == curr_distance))\n\t\t\t\t\tnext_distance = distance;\n\n\t\t\t\t\n\t\t\t\tif (sched_debug() && node_distance(k, i) != distance)\n\t\t\t\t\tsched_numa_warn(\"node-distance not symmetric\");\n\n\t\t\t\tif (sched_debug() && i && !find_numa_distance(distance))\n\t\t\t\t\tsched_numa_warn(\"node-0 not representative\");\n\t\t\t}\n\t\t\tif (next_distance != curr_distance) {\n\t\t\t\tsched_domains_numa_distance[level++] = next_distance;\n\t\t\t\tsched_domains_numa_levels = level;\n\t\t\t\tcurr_distance = next_distance;\n\t\t\t} else break;\n\t\t}\n\n\t\t\n\t\tif (!sched_debug())\n\t\t\tbreak;\n\t}\n\n\tif (!level)\n\t\treturn;\n\n\t\n\n\t\n\tsched_domains_numa_levels = 0;\n\n\tsched_domains_numa_masks = kzalloc(sizeof(void *) * level, gfp_kernel);\n\tif (!sched_domains_numa_masks)\n\t\treturn;\n\n\t\n\tfor (i = 0; i < level; i++) {\n\t\tsched_domains_numa_masks[i] =\n\t\t\tkzalloc(nr_node_ids * sizeof(void *), gfp_kernel);\n\t\tif (!sched_domains_numa_masks[i])\n\t\t\treturn;\n\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tstruct cpumask *mask = kzalloc(cpumask_size(), gfp_kernel);\n\t\t\tif (!mask)\n\t\t\t\treturn;\n\n\t\t\tsched_domains_numa_masks[i][j] = mask;\n\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tif (node_distance(j, k) >", "5001": "< next_event.tv64) {\n\t\t\tnext_event.tv64 = td->", "5002": "< next_timer_max_delta)) {\n\t\t\t\n\t\t\ttime_delta = min_t(u64, time_delta,\n\t\t\t\t\t   tick_period.tv64 * delta_jiffies);\n\t\t}\n\n\t\tif (time_delta < ktime_max)\n\t\t\texpires = ktime_add_ns(last_update, time_delta);\n\t\telse\n\t\t\texpires.tv64 = ktime_max;\n\n\t\t\n\t\tif (ts->", "5003": "< nextval\n\t\t    && *(mod->", "5004": "< nice_0_load) {\n\t\tse->", "5005": "< nlen; i++)\n\t\t\tprintk(\"%d.\", name[i]);\n\t\tprintk(\"\\n\");\n\t}\n\treturn;\n}\n\n#define warn_once_hash_bits 8\n#define warn_once_hash_size (1<<warn_once_hash_bits)\n\nstatic declare_bitmap(warn_once_bitmap, warn_once_hash_size);\n\n#define fnv32_offset 2166136261u\n#define fnv32_prime 0x01000193\n\n\nstatic void warn_on_bintable(const int *name, int nlen)\n{\n\tint i;\n\tu32 hash = fnv32_offset;\n\n\tfor (i = 0; i < nlen; i++)\n\t\thash = (hash ^ name[i]) * fnv32_prime;\n\thash %= warn_once_hash_size;\n\tif (__test_and_set_bit(hash, warn_once_bitmap))\n\t\treturn;\n\tdeprecated_sysctl_warning(name, nlen);\n}\n\nstatic ssize_t do_sysctl(int __user *args_name, int nlen,\n\tvoid __user *oldval, size_t oldlen, void __user *newval, size_t newlen)\n{\n\tint name[ctl_maxname];\n\tint i;\n\n\t\n\tif (nlen < 0 || nlen >", "5006": "< nlen; i++)\n\t\tif (get_user(name[i], args_name + i))\n\t\t\treturn -efault;\n\n\twarn_on_bintable(name, nlen);\n\n\treturn binary_sysctl(name, nlen, oldval, oldlen, newval, newlen);\n}\n\nsyscall_define1(sysctl, struct __sysctl_args __user *, args)\n{\n\tstruct __sysctl_args tmp;\n\tsize_t oldlen = 0;\n\tssize_t result;\n\n\tif (copy_from_user(&tmp, args, sizeof(tmp)))\n\t\treturn -efault;\n\n\tif (tmp.oldval && !tmp.oldlenp)\n\t\treturn -efault;\n\n\tif (tmp.oldlenp && get_user(oldlen, tmp.oldlenp))\n\t\treturn -efault;\n\n\tresult = do_sysctl(tmp.name, tmp.nlen, tmp.oldval, oldlen,\n\t\t\t   tmp.newval, tmp.newlen);\n\n\tif (result >", "5007": "< node->", "5008": "< notes; ++i)\n\t\tif (sysfs_create_bin_file(notes_attrs->", "5009": "< nr_blocks; i++) {\n\t\tif (add_rtree_block(zone, gfp_mask, safe_needed, ca)) {\n\t\t\tfree_zone_bm_rtree(zone, pg_unsafe_clear);\n\t\t\treturn null;\n\t\t}\n\t}\n\n\treturn zone;\n}\n\n\nstatic void free_zone_bm_rtree(struct mem_zone_bm_rtree *zone,\n\t\t\t       int clear_nosave_free)\n{\n\tstruct rtree_node *node;\n\n\tlist_for_each_entry(node, &zone->", "5010": "< nr_cpu_ids && idle_cpu(ilb))\n\t\treturn ilb;\n\n\treturn nr_cpu_ids;\n}\n\n\nstatic void nohz_balancer_kick(void)\n{\n\tint ilb_cpu;\n\n\tnohz.next_balance++;\n\n\tilb_cpu = find_new_ilb();\n\n\tif (ilb_cpu >", "5011": "< nr_cpu_ids)\n\t\tirq_do_set_affinity(&desc->", "5012": "< nr_cpu_ids)\n\t\tnr_cpu_ids = nr_cpus;\n\n\treturn 0;\n}\n\nearly_param(\"nr_cpus\", nrcpus);\n\nstatic int __init maxcpus(char *str)\n{\n\tget_option(&str, &setup_max_cpus);\n\tif (setup_max_cpus == 0)\n\t\tarch_disable_smp_support();\n\n\treturn 0;\n}\n\nearly_param(\"maxcpus\", maxcpus);\n\n\nint nr_cpu_ids __read_mostly = nr_cpus;\nexport_symbol(nr_cpu_ids);\n\n\nvoid __init setup_nr_cpu_ids(void)\n{\n\tnr_cpu_ids = find_last_bit(cpumask_bits(cpu_possible_mask),nr_cpus) + 1;\n}\n\nvoid __weak smp_announce(void)\n{\n\tprintk(kern_info \"brought up %d cpus\\n\", num_online_cpus());\n}\n\n\nvoid __init smp_init(void)\n{\n\tunsigned int cpu;\n\n\tidle_threads_init();\n\n\t\n\tfor_each_present_cpu(cpu) {\n\t\tif (num_online_cpus() >", "5013": "< nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\treturn null;\n}\n\nstatic void *sched_debug_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\treturn sched_debug_start(file, offset);\n}\n\nstatic void sched_debug_stop(struct seq_file *file, void *data)\n{\n}\n\nstatic const struct seq_operations sched_debug_sops = {\n\t.start = sched_debug_start,\n\t.next = sched_debug_next,\n\t.stop = sched_debug_stop,\n\t.show = sched_debug_show,\n};\n\nstatic int sched_debug_release(struct inode *inode, struct file *file)\n{\n\tseq_release(inode, file);\n\n\treturn 0;\n}\n\nstatic int sched_debug_open(struct inode *inode, struct file *filp)\n{\n\tint ret = 0;\n\n\tret = seq_open(filp, &sched_debug_sops);\n\n\treturn ret;\n}\n\nstatic const struct file_operations sched_debug_fops = {\n\t.open\t\t= sched_debug_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= sched_debug_release,\n};\n\nstatic int __init init_sched_debug_procfs(void)\n{\n\tstruct proc_dir_entry *pe;\n\n\tpe = proc_create(\"sched_debug\", 0444, null, &sched_debug_fops);\n\tif (!pe)\n\t\treturn -enomem;\n\treturn 0;\n}\n\n__initcall(init_sched_debug_procfs);\n\n#define __p(f) \\\n\tseq_printf(m, \"%-45s:%21ld\\n\", #f, (long long)f)\n#define p(f) \\\n\tseq_printf(m, \"%-45s:%21ld\\n\", #f, (long long)p->", "5014": "< nr_cpu_ids)\n\t\treturn (void *)(unsigned long)(n + 2);\n\treturn null;\n}\n\nstatic void *schedstat_next(struct seq_file *file, void *data, loff_t *offset)\n{\n\t(*offset)++;\n\treturn schedstat_start(file, offset);\n}\n\nstatic void schedstat_stop(struct seq_file *file, void *data)\n{\n}\n\nstatic const struct seq_operations schedstat_sops = {\n\t.start = schedstat_start,\n\t.next  = schedstat_next,\n\t.stop  = schedstat_stop,\n\t.show  = show_schedstat,\n};\n\nstatic int schedstat_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &schedstat_sops);\n}\n\nstatic const struct file_operations proc_schedstat_operations = {\n\t.open    = schedstat_open,\n\t.read    = seq_read,\n\t.llseek  = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic int __init proc_schedstat_init(void)\n{\n\tproc_create(\"schedstat\", 0, null, &proc_schedstat_operations);\n\treturn 0;\n}\nsubsys_initcall(proc_schedstat_init);\n\n\n#include <linux/export.h>", "5015": "< nr_cpu_ids)\n\t\treturn -einval;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -einval;\n\n\tif (!alloc_cpumask_var(&mask, gfp_kernel))\n\t\treturn -enomem;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tsize_t retlen = min_t(size_t, len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -efault;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\nint get_compat_itimerspec(struct itimerspec *dst,\n\t\t\t  const struct compat_itimerspec __user *src)\n{\n\tif (__compat_get_timespec(&dst->", "5016": "< nr_cpu_ids)\n\t\treturn -einval;\n\tif (len & (sizeof(unsigned long)-1))\n\t\treturn -einval;\n\n\tif (!alloc_cpumask_var(&mask, gfp_kernel))\n\t\treturn -enomem;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tsize_t retlen = min_t(size_t, len, cpumask_size());\n\n\t\tif (copy_to_user(user_mask_ptr, mask, retlen))\n\t\t\tret = -efault;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}\n\n\nsyscall_define0(sched_yield)\n{\n\tstruct rq *rq = this_rq_lock();\n\n\tschedstat_inc(rq, yld_count);\n\tcurrent->", "5017": "< nr_cpu_ids)\n\t\treturn per_cpu_ptr(rsp->", "5018": "< nr_cpu_ids)\n\t\tset_cpus_allowed_ptr(current, cpumask_of(cpu));\n#else \n\thousekeeping_affine(current);\n#endif \n}\n\n\nstatic void rcu_dynticks_task_enter(void)\n{\n#if defined(config_tasks_rcu) && defined(config_no_hz_full)\n\taccess_once(current->", "5019": "< nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(lowest_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\treturn -1;\n}\n\n\nstatic struct rq *find_lock_lowest_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *lowest_rq = null;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < rt_max_tries; tries++) {\n\t\tcpu = find_lowest_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->", "5020": "< nr_cpu_ids;\n\t     cpu = cpumask_next_and(cpu, nodemask, mask)) {\n\t\tif (cpu_online(cpu))\n\t\t\tgoto call;\n\t}\n\n\t\n\tcpu = cpumask_any_and(mask, cpu_online_mask);\ncall:\n\tret = smp_call_function_single(cpu, func, info, wait);\n\tput_cpu();\n\treturn ret;\n}\nexport_symbol_gpl(smp_call_function_any);\n\n\nvoid smp_call_function_many(const struct cpumask *mask,\n\t\t\t    smp_call_func_t func, void *info, bool wait)\n{\n\tstruct call_function_data *cfd;\n\tint cpu, next_cpu, this_cpu = smp_processor_id();\n\n\t\n\twarn_on_once(cpu_online(this_cpu) && irqs_disabled()\n\t\t     && !oops_in_progress && !early_boot_irqs_disabled);\n\n\t\n\tcpu = cpumask_first_and(mask, cpu_online_mask);\n\tif (cpu == this_cpu)\n\t\tcpu = cpumask_next_and(cpu, mask, cpu_online_mask);\n\n\t\n\tif (cpu >", "5021": "< nr_irqs; i++)\n\t\t\tinfo->", "5022": "< nr_lock_chains)\n\t\treturn lock_chains + (*pos - 1);\n\n\treturn null;\n}\n\nstatic void *lc_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn lc_start(m, pos);\n}\n\nstatic void lc_stop(struct seq_file *m, void *v)\n{\n}\n\nstatic int lc_show(struct seq_file *m, void *v)\n{\n\tstruct lock_chain *chain = v;\n\tstruct lock_class *class;\n\tint i;\n\n\tif (v == seq_start_token) {\n\t\tseq_printf(m, \"all lock chains:\\n\");\n\t\treturn 0;\n\t}\n\n\tseq_printf(m, \"irq_context: %d\\n\", chain->", "5023": "< nr_lockdep_caching_classes)\n\t\tclass = lock->", "5024": "< nr_lockdep_caching_classes)\n\t\tlock->", "5025": "< nr_lockdep_caching_classes; i++)\n\t\tlock->", "5026": "< nr_mm_counters; i++) {\n\t\tlong x = atomic_long_read(&mm->", "5027": "< nr_node_ids; i++) {\n\t\tprintk(kern_warning \"  \");\n\t\tfor (j = 0; j < nr_node_ids; j++)\n\t\t\tprintk(kern_cont \"%02d \", node_distance(i,j));\n\t\tprintk(kern_cont \"\\n\");\n\t}\n\tprintk(kern_warning \"\\n\");\n}\n\nbool find_numa_distance(int distance)\n{\n\tint i;\n\n\tif (distance == node_distance(0, 0))\n\t\treturn true;\n\n\tfor (i = 0; i < sched_domains_numa_levels; i++) {\n\t\tif (sched_domains_numa_distance[i] == distance)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}\n\n\nstatic void init_numa_topology_type(void)\n{\n\tint a, b, c, n;\n\n\tn = sched_max_numa_distance;\n\n\tif (n <= 1)\n\t\tsched_numa_topology_type = numa_direct;\n\n\tfor_each_online_node(a) {\n\t\tfor_each_online_node(b) {\n\t\t\t\n\t\t\tif (node_distance(a, b) < n)\n\t\t\t\tcontinue;\n\n\t\t\t\n\t\t\tfor_each_online_node(c) {\n\t\t\t\tif (node_distance(a, c) < n &&\n\t\t\t\t    node_distance(b, c) < n) {\n\t\t\t\t\tsched_numa_topology_type =\n\t\t\t\t\t\t\tnuma_glueless_mesh;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsched_numa_topology_type = numa_backplane;\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nstatic void sched_init_numa(void)\n{\n\tint next_distance, curr_distance = node_distance(0, 0);\n\tstruct sched_domain_topology_level *tl;\n\tint level = 0;\n\tint i, j, k;\n\n\tsched_domains_numa_distance = kzalloc(sizeof(int) * nr_node_ids, gfp_kernel);\n\tif (!sched_domains_numa_distance)\n\t\treturn;\n\n\t\n\tnext_distance = curr_distance;\n\tfor (i = 0; i < nr_node_ids; i++) {\n\t\tfor (j = 0; j < nr_node_ids; j++) {\n\t\t\tfor (k = 0; k < nr_node_ids; k++) {\n\t\t\t\tint distance = node_distance(i, k);\n\n\t\t\t\tif (distance >", "5028": "< nr_numa_hint_fault_stats * nr_node_ids; i++)\n\t\t\tgrp->", "5029": "< nr_numa_hint_fault_stats * nr_node_ids; i++) {\n\t\tmy_grp->", "5030": "< nr_numa_hint_fault_types; priv++) {\n\t\t\tlong diff, f_diff, f_weight;\n\n\t\t\tmem_idx = task_faults_idx(numa_mem, nid, priv);\n\t\t\tmembuf_idx = task_faults_idx(numa_membuf, nid, priv);\n\t\t\tcpu_idx = task_faults_idx(numa_cpu, nid, priv);\n\t\t\tcpubuf_idx = task_faults_idx(numa_cpubuf, nid, priv);\n\n\t\t\t\n\t\t\tdiff = p->", "5031": "< nr_pages; i++) {\n\t\tcompat_uptr_t p;\n\n\t\tif (get_user(p, pages32 + i) ||\n\t\t\tput_user(compat_ptr(p), pages + i))\n\t\t\treturn -efault;\n\t}\n\treturn sys_move_pages(pid, nr_pages, pages, nodes, status, flags);\n}\n\ncompat_syscall_define4(migrate_pages, compat_pid_t, pid,\n\t\t       compat_ulong_t, maxnode,\n\t\t       const compat_ulong_t __user *, old_nodes,\n\t\t       const compat_ulong_t __user *, new_nodes)\n{\n\tunsigned long __user *old = null;\n\tunsigned long __user *new = null;\n\tnodemask_t tmp_mask;\n\tunsigned long nr_bits;\n\tunsigned long size;\n\n\tnr_bits = min_t(unsigned long, maxnode - 1, max_numnodes);\n\tsize = align(nr_bits, bits_per_long) / 8;\n\tif (old_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), old_nodes, nr_bits))\n\t\t\treturn -efault;\n\t\told = compat_alloc_user_space(new_nodes ? size * 2 : size);\n\t\tif (new_nodes)\n\t\t\tnew = old + size / sizeof(unsigned long);\n\t\tif (copy_to_user(old, nodes_addr(tmp_mask), size))\n\t\t\treturn -efault;\n\t}\n\tif (new_nodes) {\n\t\tif (compat_get_bitmap(nodes_addr(tmp_mask), new_nodes, nr_bits))\n\t\t\treturn -efault;\n\t\tif (new == null)\n\t\t\tnew = compat_alloc_user_space(size);\n\t\tif (copy_to_user(new, nodes_addr(tmp_mask), size))\n\t\t\treturn -efault;\n\t}\n\treturn sys_migrate_pages(pid, nr_bits + 1, old, new);\n}\n#endif\n\ncompat_syscall_define2(sched_rr_get_interval,\n\t\t       compat_pid_t, pid,\n\t\t       struct compat_timespec __user *, interval)\n{\n\tstruct timespec t;\n\tint ret;\n\tmm_segment_t old_fs = get_fs();\n\n\tset_fs(kernel_ds);\n\tret = sys_sched_rr_get_interval(pid, (struct timespec __user *)&t);\n\tset_fs(old_fs);\n\tif (compat_put_timespec(&t, interval))\n\t\treturn -efault;\n\treturn ret;\n}\n\n\nvoid __user *compat_alloc_user_space(unsigned long len)\n{\n\tvoid __user *ptr;\n\n\t\n\tif (unlikely(len >", "5032": "< nr_pages; i++) {\n\t\trb->", "5033": "< nr_pages; i++) {\n\t\tstruct page *page;\n\t\t\n\t\tbpage = kzalloc_node(align(sizeof(*bpage), cache_line_size()),\n\t\t\t\t    gfp_kernel | __gfp_noretry,\n\t\t\t\t    cpu_to_node(cpu));\n\t\tif (!bpage)\n\t\t\tgoto free_pages;\n\n\t\tlist_add(&bpage->", "5034": "< nr_pages; nr_removed++) {\n\t\tto_remove = rb_list_head(to_remove)->", "5035": "< nr_pages;) {\n\t\tstruct page *page;\n\t\tint last, order;\n\n\t\torder = min(max_order, ilog2(nr_pages - rb->", "5036": "< nr_profile_hit; ++i) {\n\t\t\tif (!hits[i].hits) {\n\t\t\t\tif (hits[i].pc)\n\t\t\t\t\thits[i].pc = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\t\thits[i].hits = hits[i].pc = 0;\n\t\t}\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}\n\nstatic void profile_discard_flip_buffers(void)\n{\n\tint i, cpu;\n\n\tmutex_lock(&profile_flip_mutex);\n\ti = per_cpu(cpu_profile_flip, get_cpu());\n\tput_cpu();\n\ton_each_cpu(__profile_flip_buffers, null, 1);\n\tfor_each_online_cpu(cpu) {\n\t\tstruct profile_hit *hits = per_cpu(cpu_profile_hits, cpu)[i];\n\t\tmemset(hits, 0, nr_profile_hit*sizeof(struct profile_hit));\n\t}\n\tmutex_unlock(&profile_flip_mutex);\n}\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long primary, secondary, flags, pc = (unsigned long)__pc;\n\tint i, j, cpu;\n\tstruct profile_hit *hits;\n\n\tpc = min((pc - (unsigned long)_stext) >", "5037": "< nr_range; i++) {\n\t\tu64 common_start, common_end;\n\n\t\tif (!range[i].end)\n\t\t\tcontinue;\n\n\t\tcommon_start = max(range[i].start, start);\n\t\tcommon_end = min(range[i].end, end);\n\t\tif (common_start >", "5038": "< nr_segments; i++) {\n\t\t\tresult = kimage_load_segment(image, &image->", "5039": "< nr_segments; i++) {\n\t\t\tunsigned long mstart, mend;\n\n\t\t\tmstart = image->", "5040": "< nr_segments; i++) {\n\t\tresult = copy_from_user(&in, &segments[i], sizeof(in));\n\t\tif (result)\n\t\t\treturn -efault;\n\n\t\tout.buf   = compat_ptr(in.buf);\n\t\tout.bufsz = in.bufsz;\n\t\tout.mem   = in.mem;\n\t\tout.memsz = in.memsz;\n\n\t\tresult = copy_to_user(&ksegments[i], &out, sizeof(out));\n\t\tif (result)\n\t\t\treturn -efault;\n\t}\n\n\treturn sys_kexec_load(entry, nr_segments, ksegments, flags);\n}\n#endif\n\n#ifdef config_kexec_file\nsyscall_define5(kexec_file_load, int, kernel_fd, int, initrd_fd,\n\t\tunsigned long, cmdline_len, const char __user *, cmdline_ptr,\n\t\tunsigned long, flags)\n{\n\tint ret = 0, i;\n\tstruct kimage **dest_image, *image;\n\n\t\n\tif (!capable(cap_sys_boot) || kexec_load_disabled)\n\t\treturn -eperm;\n\n\t\n\tif (flags != (flags & kexec_file_flags))\n\t\treturn -einval;\n\n\timage = null;\n\n\tif (!mutex_trylock(&kexec_mutex))\n\t\treturn -ebusy;\n\n\tdest_image = &kexec_image;\n\tif (flags & kexec_file_on_crash)\n\t\tdest_image = &kexec_crash_image;\n\n\tif (flags & kexec_file_unload)\n\t\tgoto exchange;\n\n\t\n\tif (flags & kexec_file_on_crash)\n\t\tkimage_free(xchg(&kexec_crash_image, null));\n\n\tret = kimage_file_alloc_init(&image, kernel_fd, initrd_fd, cmdline_ptr,\n\t\t\t\t     cmdline_len, flags);\n\tif (ret)\n\t\tgoto out;\n\n\tret = machine_kexec_prepare(image);\n\tif (ret)\n\t\tgoto out;\n\n\tret = kexec_calculate_store_digests(image);\n\tif (ret)\n\t\tgoto out;\n\n\tfor (i = 0; i < image->", "5041": "< nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\t\tunsigned long j;\n\n\t\tmstart = image->", "5042": "< nr_segments; i++) {\n\t\tunsigned long mstart, mend;\n\n\t\tmstart = image->", "5043": "< nr_std_worker_pools; i++) {\n\t\tstruct workqueue_attrs *attrs;\n\n\t\tbug_on(!(attrs = alloc_workqueue_attrs(gfp_kernel)));\n\t\tattrs->", "5044": "< nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tif (page) free_page((unsigned long)page);\n\n\treturn ret;\n}\n\n\n\nstatic int enough_swap(unsigned int nr_pages, unsigned int flags)\n{\n\tunsigned int free_swap = count_swap_pages(root_swap, 1);\n\tunsigned int required;\n\n\tpr_debug(\"pm: free swap pages: %u\\n\", free_swap);\n\n\trequired = pages_for_io + nr_pages;\n\treturn free_swap >", "5045": "< nr_threads; thr++)\n\t\t\tif (data[thr].thr)\n\t\t\t\tkthread_stop(data[thr].thr);\n\t\tvfree(data);\n\t}\n\tvfree(page);\n\n\treturn ret;\n}\n\n\n\nint swsusp_read(unsigned int *flags_p)\n{\n\tint error;\n\tstruct swap_map_handle handle;\n\tstruct snapshot_handle snapshot;\n\tstruct swsusp_info *header;\n\n\tmemset(&snapshot, 0, sizeof(struct snapshot_handle));\n\terror = snapshot_write_next(&snapshot);\n\tif (error < page_size)\n\t\treturn error < 0 ? error : -efault;\n\theader = (struct swsusp_info *)data_of(snapshot);\n\terror = get_swap_reader(&handle, flags_p);\n\tif (error)\n\t\tgoto end;\n\tif (!error)\n\t\terror = swap_read_page(&handle, header, null);\n\tif (!error) {\n\t\terror = (*flags_p & sf_nocompress_mode) ?\n\t\t\tload_image(&handle, &snapshot, header->", "5046": "< nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct cmp_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), gfp_kernel);\n\tif (!crc) {\n\t\tprintk(kern_err \"pm: failed to allocate crc\\n\");\n\t\tret = -enomem;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_compress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_compress/%u\", thr);\n\t\tif (is_err(data[thr].thr)) {\n\t\t\tdata[thr].thr = null;\n\t\t\tprintk(kern_err\n\t\t\t       \"pm: cannot start compression threads\\n\");\n\t\t\tret = -enomem;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t\n\tinit_waitqueue_head(&crc->", "5047": "< nr_threads; thr++)\n\t\tmemset(&data[thr], 0, offsetof(struct dec_data, go));\n\n\tcrc = kmalloc(sizeof(*crc), gfp_kernel);\n\tif (!crc) {\n\t\tprintk(kern_err \"pm: failed to allocate crc\\n\");\n\t\tret = -enomem;\n\t\tgoto out_clean;\n\t}\n\tmemset(crc, 0, offsetof(struct crc_data, go));\n\n\t\n\tfor (thr = 0; thr < nr_threads; thr++) {\n\t\tinit_waitqueue_head(&data[thr].go);\n\t\tinit_waitqueue_head(&data[thr].done);\n\n\t\tdata[thr].thr = kthread_run(lzo_decompress_threadfn,\n\t\t                            &data[thr],\n\t\t                            \"image_decompress/%u\", thr);\n\t\tif (is_err(data[thr].thr)) {\n\t\t\tdata[thr].thr = null;\n\t\t\tprintk(kern_err\n\t\t\t       \"pm: cannot start decompression threads\\n\");\n\t\t\tret = -enomem;\n\t\t\tgoto out_clean;\n\t\t}\n\t}\n\n\t\n\tinit_waitqueue_head(&crc->", "5048": "< nr_threads; thr++) {\n\t\t\tdata[thr].cmp_len = *(size_t *)page[pg];\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >", "5049": "< nr_threads; thr++) {\n\t\t\tfor (off = 0; off < lzo_unc_size; off += page_size) {\n\t\t\t\tret = snapshot_read_next(snapshot);\n\t\t\t\tif (ret < 0)\n\t\t\t\t\tgoto out_finish;\n\n\t\t\t\tif (!ret)\n\t\t\t\t\tbreak;\n\n\t\t\t\tmemcpy(data[thr].unc + off,\n\t\t\t\t       data_of(*snapshot), page_size);\n\n\t\t\t\tif (!(nr_pages % m))\n\t\t\t\t\tprintk(kern_info\n\t\t\t\t\t       \"pm: image saving progress: \"\n\t\t\t\t\t       \"%3d%%\\n\",\n\t\t\t\t               nr_pages / m * 10);\n\t\t\t\tnr_pages++;\n\t\t\t}\n\t\t\tif (!off)\n\t\t\t\tbreak;\n\n\t\t\tdata[thr].unc_len = off;\n\n\t\t\tatomic_set(&data[thr].ready, 1);\n\t\t\twake_up(&data[thr].go);\n\t\t}\n\n\t\tif (!thr)\n\t\t\tbreak;\n\n\t\tcrc->", "5050": "< nr_threads; thr++) {\n\t\tcrc->", "5051": "< nrealreaders; i++)\n\t\t\ttorture_stop_kthread(rcu_torture_reader,\n\t\t\t\t\t     reader_tasks[i]);\n\t\tkfree(reader_tasks);\n\t}\n\trcu_torture_current = null;\n\n\tif (fakewriter_tasks) {\n\t\tfor (i = 0; i < nfakewriters; i++) {\n\t\t\ttorture_stop_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t     fakewriter_tasks[i]);\n\t\t}\n\t\tkfree(fakewriter_tasks);\n\t\tfakewriter_tasks = null;\n\t}\n\n\ttorture_stop_kthread(rcu_torture_stats, stats_task);\n\ttorture_stop_kthread(rcu_torture_fqs, fqs_task);\n\tfor (i = 0; i < ncbflooders; i++)\n\t\ttorture_stop_kthread(rcu_torture_cbflood, cbflood_task[i]);\n\tif ((test_boost == 1 && cur_ops->", "5052": "< ns->", "5053": "< nsrc; i++) {\n\t\tif (i == 0 ||\n\t\t    is_core_symbol(src+i, info->", "5054": "< num; i++)\n\t\tif (kps[i]->", "5055": "< num; i++)\n\t\tif (params[i].ops->", "5056": "< num; i++) {\n\t\tif (jps[i]->", "5057": "< num; i++) {\n\t\tif (rps[i]->", "5058": "< num; i++) {\n\t\ttarget = get_link_target(\n\t\t\t\tgcov_info_filename(get_node_info(node)),\n\t\t\t\t&gcov_link[i]);\n\t\tif (!target)\n\t\t\tgoto out_err;\n\t\tbasename = kbasename(target);\n\t\tif (basename == target)\n\t\t\tgoto out_err;\n\t\tnode->", "5059": "< num_counter_active(dest); i++) {\n\t\tfor (j = 0; j < dest->", "5060": "< num_params; i++) {\n\t\tif (kparam[i].perm == 0)\n\t\t\tcontinue;\n\t\terr = add_sysfs_param(&mod->", "5061": "< num_params; i++) {\n\t\tif (parameq(param, params[i].name)) {\n\t\t\tif (params[i].level < min_level\n\t\t\t    || params[i].level >", "5062": "< num_versions; i++) {\n\t\tif (strcmp(versions[i].name, symname) != 0)\n\t\t\tcontinue;\n\n\t\tif (versions[i].crc == maybe_relocated(*crc, crc_owner))\n\t\t\treturn 1;\n\t\tpr_debug(\"found checksum %lx vs module %lx\\n\",\n\t\t       maybe_relocated(*crc, crc_owner), versions[i].crc);\n\t\tgoto bad_version;\n\t}\n\n\tpr_warn(\"%s: no symbol version for %s\\n\", mod->", "5063": "< numchips; i++) {\n\t\t\n\t\tdgc->", "5064": "< offset; i++)\n\t\tseq_puts(m, \" \");\n\tfor (i = 0; i < length; i++)\n\t\tseq_printf(m, \"%c\", c);\n\tseq_puts(m, \"\\n\");\n}\n\nstatic void snprint_time(char *buf, size_t bufsiz, s64 nr)\n{\n\ts64 div;\n\ts32 rem;\n\n\tnr += 5; \n\tdiv = div_s64_rem(nr, 1000, &rem);\n\tsnprintf(buf, bufsiz, \"%lld.%02d\", (long long)div, (int)rem/10);\n}\n\nstatic void seq_time(struct seq_file *m, s64 time)\n{\n\tchar num[15];\n\n\tsnprint_time(num, sizeof(num), time);\n\tseq_printf(m, \" %14s\", num);\n}\n\nstatic void seq_lock_time(struct seq_file *m, struct lock_time *lt)\n{\n\tseq_printf(m, \"%14lu\", lt->", "5065": "< old->", "5066": "< op->", "5067": "< p->", "5068": "< page_size / sizeof(long); j++) {\n\t\tif (unlikely(buf[j] == bm_end_of_map))\n\t\t\tbreak;\n\n\t\t\n\t\tpage_key_memorize(buf + j);\n\n\t\tif (memory_bm_pfn_present(bm, buf[j]))\n\t\t\tmemory_bm_set_bit(bm, buf[j]);\n\t\telse\n\t\t\treturn -efault;\n\t}\n\n\treturn 0;\n}\n\n\nstatic struct linked_page *safe_pages_list;\n\n#ifdef config_highmem\n\nstruct highmem_pbe {\n\tstruct page *copy_page;\t\n\tstruct page *orig_page;\t\n\tstruct highmem_pbe *next;\n};\n\n\nstatic struct highmem_pbe *highmem_pblist;\n\n\n\nstatic unsigned int count_highmem_image_pages(struct memory_bitmap *bm)\n{\n\tunsigned long pfn;\n\tunsigned int cnt = 0;\n\n\tmemory_bm_position_reset(bm);\n\tpfn = memory_bm_next_pfn(bm);\n\twhile (pfn != bm_end_of_map) {\n\t\tif (pagehighmem(pfn_to_page(pfn)))\n\t\t\tcnt++;\n\n\t\tpfn = memory_bm_next_pfn(bm);\n\t}\n\treturn cnt;\n}\n\n\n\nstatic unsigned int safe_highmem_pages;\n\nstatic struct memory_bitmap *safe_highmem_bm;\n\nstatic int\nprepare_highmem_image(struct memory_bitmap *bm, unsigned int *nr_highmem_p)\n{\n\tunsigned int to_alloc;\n\n\tif (memory_bm_create(bm, gfp_atomic, pg_safe))\n\t\treturn -enomem;\n\n\tif (get_highmem_buffer(pg_safe))\n\t\treturn -enomem;\n\n\tto_alloc = count_free_highmem_pages();\n\tif (to_alloc >", "5069": "< page_size ? len : -einval;\n}\n\nstatic ssize_t store_cpumask(struct padata_instance *pinst,\n\t\t\t     struct attribute *attr,\n\t\t\t     const char *buf, size_t count)\n{\n\tcpumask_var_t new_cpumask;\n\tssize_t ret;\n\tint mask_type;\n\n\tif (!alloc_cpumask_var(&new_cpumask, gfp_kernel))\n\t\treturn -enomem;\n\n\tret = bitmap_parse(buf, count, cpumask_bits(new_cpumask),\n\t\t\t   nr_cpumask_bits);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tmask_type = !strcmp(attr->", "5070": "< page_size)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->", "5071": "< page_size) {\n\t\tif (error >", "5072": "< page_size) {\n\t\tprintk(kern_err \"pm: adding page to bio failed at %llu\\n\",\n\t\t\t(unsigned long long)sector);\n\t\tbio_put(bio);\n\t\treturn -efault;\n\t}\n\n\tlock_page(page);\n\tbio_get(bio);\n\n\tif (bio_chain == null) {\n\t\tsubmit_bio(bio_rw, bio);\n\t\twait_on_page_locked(page);\n\t\tif (rw == read)\n\t\t\tbio_set_pages_dirty(bio);\n\t\tbio_put(bio);\n\t} else {\n\t\tif (rw == read)\n\t\t\tget_page(page);\t\n\t\tbio->", "5073": "< pages)\n\t\tsize = min_t(unsigned long, pages, max_size);\n\n\t\n\tshrink_all_memory(saveable - size);\n\n\t\n\tpages_highmem = preallocate_image_highmem(highmem / 2);\n\talloc = count - max_size;\n\tif (alloc >", "5074": "< pages; i++) {\n\t\tpg->", "5075": "< panic_timeout * 1000; i += panic_timer_step) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >", "5076": "< parent->", "5077": "< parser->", "5078": "< path_max);\n\n\tcgrp = cgroup_kn_lock_live(of->", "5079": "< pdu_len; i++) {\n\n\t\ttrace_seq_printf(s, \"%s%02x\",\n\t\t\t\t i == 0 ? \"\" : \" \", pdu_buf[i]);\n\n\t\t\n\t\tif (i == end && end != pdu_len - 1) {\n\t\t\ttrace_seq_puts(s, \" ..) \");\n\t\t\treturn;\n\t\t}\n\t}\n\n\ttrace_seq_puts(s, \") \");\n}\n\nstatic void blk_log_generic(struct trace_seq *s, const struct trace_entry *ent)\n{\n\tchar cmd[task_comm_len];\n\n\ttrace_find_cmdline(ent->", "5080": "< pend))\n\t\t\t\treturn result;\n\t\t}\n\t}\n\n\t\n\tresult = -einval;\n\tfor (i = 0; i < nr_segments; i++) {\n\t\tif (image->", "5081": "< percent_b)\n\t\treturn -1;\n\tif (percent_a >", "5082": "< perf_aux_size(rb))\n\t\t\thandle->", "5083": "< perf_data_size(rb) + page_size)\n\t\t\tgoto aux_unlock;\n\n\t\tif (aux_offset != vma->", "5084": "< perf_event_state_inactive)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\t\toutput(event, data);\n\t}\n}\n\nstatic void\nperf_event_aux(perf_event_aux_output_cb output, void *data,\n\t       struct perf_event_context *task_ctx)\n{\n\tstruct perf_cpu_context *cpuctx;\n\tstruct perf_event_context *ctx;\n\tstruct pmu *pmu;\n\tint ctxn;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(pmu, &pmus, entry) {\n\t\tcpuctx = get_cpu_ptr(pmu->", "5085": "< perf_nr_contexts; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->", "5086": "< perf_nr_contexts; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = null;\n\t\t}\n\t}\n\n\tif (!--tp_event->", "5087": "< perf_nr_contexts; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = null;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->", "5088": "< perf_nr_task_contexts; (ctxn)++)\n\n\nvoid __perf_event_task_sched_out(struct task_struct *task,\n\t\t\t\t struct task_struct *next)\n{\n\tint ctxn;\n\n\tif (__this_cpu_read(perf_sched_cb_usages))\n\t\tperf_pmu_sched_task(task, next, false);\n\n\tfor_each_task_context_nr(ctxn)\n\t\tperf_event_context_sched_out(task, ctxn, next);\n\n\t\n\tif (atomic_read(this_cpu_ptr(&perf_cgroup_events)))\n\t\tperf_cgroup_sched_out(task, next);\n}\n\nstatic void task_ctx_sched_out(struct perf_event_context *ctx)\n{\n\tstruct perf_cpu_context *cpuctx = __get_cpu_context(ctx);\n\n\tif (!cpuctx->", "5089": "< pg->", "5090": "< pi->", "5091": "< pidmap_entries; i++)\n\t\tatomic_set(&ns->", "5092": "< pidmap_entries; i++)\n\t\tkfree(ns->", "5093": "< pidtype_max; ++type)\n\t\tinit_hlist_head(&pid->", "5094": "< pidtype_max; ++type) {\n\t\tinit_hlist_node(&links[type].node); \n\t\tlinks[type].pid = &init_struct_pid;\n\t}\n}\n\nstruct task_struct *fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\ttask = copy_process(clone_vm, 0, 0, null, &init_struct_pid, 0);\n\tif (!is_err(task)) {\n\t\tinit_idle_pids(task->", "5095": "< pm_qos_num_classes; i++) {\n\t\tret = register_pm_qos_misc(pm_qos_array[i], d);\n\t\tif (ret < 0) {\n\t\t\tprintk(kern_err \"pm_qos_param: %s setup failed\\n\",\n\t\t\t       pm_qos_array[i]->", "5096": "< pm_qos_num_classes; pm_qos_class++) {\n\t\tif (minor ==\n\t\t\tpm_qos_array[pm_qos_class]->", "5097": "< pm_suspend_max)\n\t\terror = pm_suspend(state);\n\telse if (state == pm_suspend_max)\n\t\terror = hibernate();\n\telse\n\t\terror = -einval;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}\n\npower_attr(state);\n\n#ifdef config_pm_sleep\n\n\nstatic ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -eintr;\n}\n\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() >", "5098": "< pm_suspend_max)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef config_hibernation\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}\n\nstatic ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == pm_suspend_on\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -einval;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}\n\npower_attr(autosleep);\n#endif \n\n#ifdef config_pm_wakelocks\nstatic ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}\n\nstatic ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}\n\npower_attr(wake_lock);\n\nstatic ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}\n\nstatic ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}\n\npower_attr(wake_unlock);\n\n#endif \n#endif \n\n#ifdef config_pm_trace\nint pm_trace_enabled;\n\nstatic ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}\n\nstatic ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"pm: enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"pm: correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -einval;\n}\n\npower_attr(pm_trace);\n\nstatic ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, page_size);\n}\n\nstatic ssize_t\npm_trace_dev_match_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t const char *buf, size_t n)\n{\n\treturn -einval;\n}\n\npower_attr(pm_trace_dev_match);\n\n#endif \n\n#ifdef config_freezer\nstatic ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}\n\nstatic ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -einval;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}\n\npower_attr(pm_freeze_timeout);\n\n#endif\t\n\nstatic struct attribute * g[] = {\n\t&state_attr.attr,\n#ifdef config_pm_trace\n\t&pm_trace_attr.attr,\n\t&pm_trace_dev_match_attr.attr,\n#endif\n#ifdef config_pm_sleep\n\t&pm_async_attr.attr,\n\t&wakeup_count_attr.attr,\n#ifdef config_pm_autosleep\n\t&autosleep_attr.attr,\n#endif\n#ifdef config_pm_wakelocks\n\t&wake_lock_attr.attr,\n\t&wake_unlock_attr.attr,\n#endif\n#ifdef config_pm_debug\n\t&pm_test_attr.attr,\n#endif\n#ifdef config_pm_sleep_debug\n\t&pm_print_times_attr.attr,\n#endif\n#endif\n#ifdef config_freezer\n\t&pm_freeze_timeout_attr.attr,\n#endif\n\tnull,\n};\n\nstatic struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\nstruct workqueue_struct *pm_wq;\nexport_symbol_gpl(pm_wq);\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", wq_freezable, 0);\n\n\treturn pm_wq ? 0 : -enomem;\n}\n\nstatic int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpower_kobj = kobject_create_and_add(\"power\", null);\n\tif (!power_kobj)\n\t\treturn -enomem;\n\terror = sysfs_create_group(power_kobj, &attr_group);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}\n\ncore_initcall(pm_init);\n\n\n#include <linux/init.h>", "5099": "< pm_suspend_max; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t\n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef config_suspend\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn pm_suspend_max;\n\n#ifdef config_suspend\n\tfor (state = pm_suspend_min; state < pm_suspend_max; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn pm_suspend_on;\n}\n\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() >", "5100": "< pm_suspend_max; test_state++) {\n\t\tconst char *state_label = pm_states[test_state];\n\n\t\tif (state_label && !strcmp(test_state_label, state_label))\n\t\t\tbreak;\n\t}\n\tif (test_state == pm_suspend_max) {\n\t\tprintk(warn_bad_state, test_state_label);\n\t\treturn 0;\n\t}\n\n\t\n\tdev = class_find_device(rtc_class, null, null, has_wakealarm);\n\tif (dev)\n\t\trtc = rtc_class_open(dev_name(dev));\n\tif (!rtc) {\n\t\tprintk(warn_no_rtc);\n\t\treturn 0;\n\t}\n\n\t\n\ttest_wakealarm(rtc, test_state);\n\trtc_class_close(rtc);\n\treturn 0;\n}\nlate_initcall(test_suspend);\n\n\n#include <linux/errno.h>", "5101": "< pos && i + insn->", "5102": "< pos)\n\t\t\tinsn->", "5103": "< pps_intmax) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}\n\n\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t\n\tif (freq_norm.sec >", "5104": "< preempt_mask) &&\n\t\t\t!(preempt_count() & preempt_mask)))\n\t\treturn;\n#endif\n\n\tif (preempt_count() == val)\n\t\ttrace_preempt_on(caller_addr0, get_parent_ip(caller_addr1));\n\t__preempt_count_sub(val);\n}\nexport_symbol(preempt_count_sub);\nnokprobe_symbol(preempt_count_sub);\n\n#endif\n\n\nstatic noinline void __schedule_bug(struct task_struct *prev)\n{\n\tif (oops_in_progress)\n\t\treturn;\n\n\tprintk(kern_err \"bug: scheduling while atomic: %s/%d/0x%08x\\n\",\n\t\tprev->", "5105": "< prev_prio)\n\t\tcpupri_set(&rq->", "5106": "< prev_prio)\n\t\trt_rq->", "5107": "< prev_prio);\n\n\t\t\n\t\tif (prio == prev_prio) {\n\t\t\tstruct rt_prio_array *array = &rt_rq->", "5108": "< prio)\n\t\t\tenqueue_flag = enqueue_head;\n\t\tp->", "5109": "< prio_process)\n\t\tgoto out;\n\n\t\n\terror = -esrch;\n\tif (niceval < min_nice)\n\t\tniceval = min_nice;\n\tif (niceval >", "5110": "< prio_process)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tswitch (which) {\n\tcase prio_process:\n\t\tif (who)\n\t\t\tp = find_task_by_vpid(who);\n\t\telse\n\t\t\tp = current;\n\t\tif (p) {\n\t\t\tniceval = nice_to_rlimit(task_nice(p));\n\t\t\tif (niceval >", "5111": "< prog->", "5112": "< ps->", "5113": "< pwq->", "5114": "< r->", "5115": "< r2->", "5116": "< range[j].end) {\n\t\t\t\n\t\t\tfor (i = 0; i < az; i++) {\n\t\t\t\tif (range[i].end == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < az) {\n\t\t\t\trange[i].end = range[j].end;\n\t\t\t\trange[i].start = end;\n\t\t\t} else {\n\t\t\t\tpr_err(\"%s: run out of slot in ranges\\n\",\n\t\t\t\t\t__func__);\n\t\t\t}\n\t\t\trange[j].end = start;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nstatic int cmp_range(const void *x1, const void *x2)\n{\n\tconst struct range *r1 = x1;\n\tconst struct range *r2 = x2;\n\n\tif (r1->", "5117": "< rb->", "5118": "< rb_page_size(reader))\n\t\tgoto out;\n\n\t\n\tif (rb_warn_on(cpu_buffer,\n\t\t       cpu_buffer->", "5119": "< rcu_next_size; i++)\n\t\t\tif (&rdp->", "5120": "< rcu_next_size; i++)\n\t\trdp->", "5121": "< rcu_next_tail; i++)\n\t\tif (rdp->", "5122": "< rcu_next_tail; i++)\n\t\tif (ulong_cmp_lt(c, rdp->", "5123": "< rcu_next_tail; i++) {\n\t\tif (ulong_cmp_lt(rnp->", "5124": "< rcu_next_tail; i++, j++) {\n\t\tif (rdp->", "5125": "< rcu_num_lvls; i++)\n\t\trsp->", "5126": "< rcu_num_nodes; rnp++) {\n\t\tif (rnp->", "5127": "< rcu_stall_rat_delay || !rcu_gp_in_progress(rsp)) {\n\t\traw_spin_unlock_irqrestore(&rnp->", "5128": "< rcu_torture_pipe_len + 1; i++)\n\t\tpr_cont(\" %ld\", pipesummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, torture_flag);\n\tpr_cont(\"reader batch: \");\n\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++)\n\t\tpr_cont(\" %ld\", batchsummary[i]);\n\tpr_cont(\"\\n\");\n\n\tpr_alert(\"%s%s \", torture_type, torture_flag);\n\tpr_cont(\"free-block circulation: \");\n\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++) {\n\t\tpr_cont(\" %d\", atomic_read(&rcu_torture_wcount[i]));\n\t}\n\tpr_cont(\"\\n\");\n\n\tif (cur_ops->", "5129": "< rcu_torture_pipe_len + 1; i++) {\n\t\t\tpipesummary[i] += per_cpu(rcu_torture_count, cpu)[i];\n\t\t\tbatchsummary[i] += per_cpu(rcu_torture_batch, cpu)[i];\n\t\t}\n\t}\n\tfor (i = rcu_torture_pipe_len - 1; i >", "5130": "< rdp->", "5131": "< re_cnt; i++) {\n\t\tret = ftrace_function_set_regexp(data->", "5132": "< read_pages; i++) {\n\t\tpage[i] = (void *)__get_free_page(i < lzo_cmp_pages ?\n\t\t                                  __gfp_wait | __gfp_high :\n\t\t                                  __gfp_wait | __gfp_nowarn |\n\t\t                                  __gfp_noretry);\n\n\t\tif (!page[i]) {\n\t\t\tif (i < lzo_cmp_pages) {\n\t\t\t\tring_size = i;\n\t\t\t\tprintk(kern_err\n\t\t\t\t       \"pm: failed to allocate lzo pages\\n\");\n\t\t\t\tret = -enomem;\n\t\t\t\tgoto out_clean;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\twant = ring_size = i;\n\n\tprintk(kern_info\n\t\t\"pm: using %u thread(s) for decompression.\\n\"\n\t\t\"pm: loading and decompressing image data (%u pages)...\\n\",\n\t\tnr_threads, nr_to_read);\n\tm = nr_to_read / 10;\n\tif (!m)\n\t\tm = 1;\n\tnr_pages = 0;\n\tbio = null;\n\tstart = ktime_get();\n\n\tret = snapshot_write_next(snapshot);\n\tif (ret <= 0)\n\t\tgoto out_finish;\n\n\tfor(;;) {\n\t\tfor (i = 0; !eof && i < want; i++) {\n\t\t\tret = swap_read_page(handle, page[ring], &bio);\n\t\t\tif (ret) {\n\t\t\t\t\n\t\t\t\tif (handle->", "5133": "< real_tk->", "5134": "< rec->", "5135": "< region->", "5136": "< regnum; i++)\n\t\toffset += dbg_reg_def[i].size;\n\treturn kgdb_mem2hex((char *)gdb_regs + offset, out,\n\t\t\t    dbg_reg_def[i].size);\n}\n\n\nstatic void gdb_cmd_reg_get(struct kgdb_state *ks)\n{\n\tunsigned long regnum;\n\tchar *ptr = &remcom_in_buffer[1];\n\n\tkgdb_hex2long(&ptr, &regnum);\n\tif (regnum >", "5137": "< repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z >", "5138": "< res.end) &&\n\t\t(!find_next_iomem_res(&res, name, false))) {\n\t\tret = (*func)(res.start, res.end, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tres.start = res.end + 1;\n\t\tres.end = orig_end;\n\t}\n\treturn ret;\n}\n\n\nint walk_system_ram_res(u64 start, u64 end, void *arg,\n\t\t\t\tint (*func)(u64, u64, void *))\n{\n\tstruct resource res;\n\tu64 orig_end;\n\tint ret = -1;\n\n\tres.start = start;\n\tres.end = end;\n\tres.flags = ioresource_mem | ioresource_busy;\n\torig_end = res.end;\n\twhile ((res.start < res.end) &&\n\t\t(!find_next_iomem_res(&res, \"system ram\", true))) {\n\t\tret = (*func)(res.start, res.end, arg);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tres.start = res.end + 1;\n\t\tres.end = orig_end;\n\t}\n\treturn ret;\n}\n\n#if !defined(config_arch_has_walk_memory)\n\n\nint walk_system_ram_range(unsigned long start_pfn, unsigned long nr_pages,\n\t\tvoid *arg, int (*func)(unsigned long, unsigned long, void *))\n{\n\tstruct resource res;\n\tunsigned long pfn, end_pfn;\n\tu64 orig_end;\n\tint ret = -1;\n\n\tres.start = (u64) start_pfn << page_shift;\n\tres.end = ((u64)(start_pfn + nr_pages) << page_shift) - 1;\n\tres.flags = ioresource_mem | ioresource_busy;\n\torig_end = res.end;\n\twhile ((res.start < res.end) &&\n\t\t(find_next_iomem_res(&res, \"system ram\", true) >", "5139": "< right);\n\tcase audit_le:\n\t\treturn (left <= right);\n\tcase audit_gt:\n\t\treturn (left >", "5140": "< ring_size; i++)\n\t\tfree_page((unsigned long)page[i]);\n\tif (crc) {\n\t\tif (crc->", "5141": "< root->", "5142": "< rp->", "5143": "< rq->", "5144": "< rq2) {\n\t\t\traw_spin_lock(&rq1->", "5145": "< rsp->", "5146": "< rt_b->", "5147": "< rule->", "5148": "< run_threads; thr++) {\n\t\t\twait_event(data[thr].done,\n\t\t\t           atomic_read(&data[thr].stop));\n\t\t\tatomic_set(&data[thr].stop, 0);\n\n\t\t\tret = data[thr].ret;\n\n\t\t\tif (ret < 0) {\n\t\t\t\tprintk(kern_err \"pm: lzo compression failed\\n\");\n\t\t\t\tgoto out_finish;\n\t\t\t}\n\n\t\t\tif (unlikely(!data[thr].cmp_len ||\n\t\t\t             data[thr].cmp_len >", "5149": "< runtime) {\n\t\t\t\trt_rq->", "5150": "< rwsem_waiting_bias)) {\n\t\t\t\n\t\t\tif (rwsem_atomic_update(-adjustment, sem) &\n\t\t\t\t\t\trwsem_active_mask)\n\t\t\t\tgoto out;\n\t\t\t\n\t\t\tgoto try_reader_grant;\n\t\t}\n\t}\n\n\t\n\twoken = 0;\n\tdo {\n\t\twoken++;\n\n\t\tif (waiter->", "5151": "< s->", "5152": "< sched_attr_size_ver0 || flags)\n\t\treturn -einval;\n\n\trcu_read_lock();\n\tp = find_process_by_pid(pid);\n\tretval = -esrch;\n\tif (!p)\n\t\tgoto out_unlock;\n\n\tretval = security_task_getscheduler(p);\n\tif (retval)\n\t\tgoto out_unlock;\n\n\tattr.sched_policy = p->", "5153": "< sched_attr_size_ver0)\n\t\tgoto err_size;\n\n\t\n\tif (size >", "5154": "< sched_nr_latency)\n\t\thrtick_start_fair(rq, curr);\n}\n#else \nstatic inline void\nhrtick_start_fair(struct rq *rq, struct task_struct *p)\n{\n}\n\nstatic inline void hrtick_update(struct rq *rq)\n{\n}\n#endif\n\n\nstatic void\nenqueue_task_fair(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct cfs_rq *cfs_rq;\n\tstruct sched_entity *se = &p->", "5155": "< sd->", "5156": "< sechdrs[i].sh_size/sizeof(elf_sym); k++) {\n\t\t\tif (elf_st_bind(syms[k].st_info) != stb_global)\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(strtab + syms[k].st_name, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (syms[k].st_shndx == shn_undef ||\n\t\t\t    syms[k].st_shndx >", "5157": "< sect_attrs->", "5158": "< sgs->", "5159": "< shdr->", "5160": "< sigrtmin)\n\t\toverride_rlimit = (is_si_special(info) || info->", "5161": "< sigrtmin) && sigismember(&signals->", "5162": "< size)\n\t\t\tgoto out_unlock;\n\n\t\t\n\t\tsave_timestamp = cpu_buffer->", "5163": "< size) {\n\t\tstruct linked_page *lp;\n\n\t\tlp = get_image_page(ca->", "5164": "< size))\n\t\t\tgoto fail;\n\n\t\t\n\n\t\thead += size;\n\t} while (local_cmpxchg(&rb->", "5165": "< size; i++)\n\t\t\tstate->", "5166": "< size; i++) {\n\t\t\tif (slot_type[i] != stack_misc) {\n\t\t\t\tverbose(\"invalid read from stack off %d+%d size %d\\n\",\n\t\t\t\t\toff, i, size);\n\t\t\t\treturn -eacces;\n\t\t\t}\n\t\t}\n\t\tif (value_regno >", "5167": "< size; i++) {\n\t\thhd = &hash->", "5168": "< size; i++) {\n\t\thhd = &src->", "5169": "< size; i++) {\n\t\thlist_for_each_entry(entry, &hash->", "5170": "< size; i++) {\n\t\tif (d >", "5171": "< sizeof(*(info->", "5172": "< sizeof(*attr)) {\n\t\tunsigned char *addr;\n\t\tunsigned char *end;\n\n\t\taddr = (void *)attr + usize;\n\t\tend  = (void *)attr + sizeof(*attr);\n\n\t\tfor (; addr < end; addr++) {\n\t\t\tif (*addr)\n\t\t\t\treturn -efbig;\n\t\t}\n\n\t\tattr->", "5173": "< sizeof(gdb_regs) * 2)\n\t\tif (hex_to_bin(ptr[i]) >", "5174": "< sizeof(stat_nam) - 1 ? stat_nam[state] : '?');\n#if bits_per_long == 32\n\tif (state == task_running)\n\t\tprintk(kern_cont \" running  \");\n\telse\n\t\tprintk(kern_cont \" %08lx \", thread_saved_pc(p));\n#else\n\tif (state == task_running)\n\t\tprintk(kern_cont \"  running task    \");\n\telse\n\t\tprintk(kern_cont \" %016lx \", thread_saved_pc(p));\n#endif\n#ifdef config_debug_stack_usage\n\tfree = stack_not_used(p);\n#endif\n\tppid = 0;\n\trcu_read_lock();\n\tif (pid_alive(p))\n\t\tppid = task_pid_nr(rcu_dereference(p->", "5175": "< sizeof(state_to_char) - 1 ? state_to_char[bit] : '?';\n}\n\n\nstruct trace_event *ftrace_find_event(int type)\n{\n\tstruct trace_event *event;\n\tunsigned key;\n\n\tkey = type & (event_hashsize - 1);\n\n\thlist_for_each_entry(event, &event_hash[key], node) {\n\t\tif (event->", "5176": "< sizeof(struct audit_rule_data))\n\t\t\treturn -einval;\n\t\tif (audit_enabled == audit_locked) {\n\t\t\taudit_log_common_recv_msg(&ab, audit_config_change);\n\t\t\taudit_log_format(ab, \" audit_enabled=%d res=0\", audit_enabled);\n\t\t\taudit_log_end(ab);\n\t\t\treturn -eperm;\n\t\t}\n\t\terr = audit_rule_change(msg_type, netlink_cb(skb).portid,\n\t\t\t\t\t   seq, data, nlmsg_len(nlh));\n\t\tbreak;\n\tcase audit_list_rules:\n\t\terr = audit_list_rules_send(skb, seq);\n\t\tbreak;\n\tcase audit_trim:\n\t\taudit_trim_trees();\n\t\taudit_log_common_recv_msg(&ab, audit_config_change);\n\t\taudit_log_format(ab, \" op=trim res=1\");\n\t\taudit_log_end(ab);\n\t\tbreak;\n\tcase audit_make_equiv: {\n\t\tvoid *bufp = data;\n\t\tu32 sizes[2];\n\t\tsize_t msglen = nlmsg_len(nlh);\n\t\tchar *old, *new;\n\n\t\terr = -einval;\n\t\tif (msglen < 2 * sizeof(u32))\n\t\t\tbreak;\n\t\tmemcpy(sizes, bufp, 2 * sizeof(u32));\n\t\tbufp += 2 * sizeof(u32);\n\t\tmsglen -= 2 * sizeof(u32);\n\t\told = audit_unpack_string(&bufp, &msglen, sizes[0]);\n\t\tif (is_err(old)) {\n\t\t\terr = ptr_err(old);\n\t\t\tbreak;\n\t\t}\n\t\tnew = audit_unpack_string(&bufp, &msglen, sizes[1]);\n\t\tif (is_err(new)) {\n\t\t\terr = ptr_err(new);\n\t\t\tkfree(old);\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\terr = audit_tag_tree(old, new);\n\n\t\taudit_log_common_recv_msg(&ab, audit_config_change);\n\n\t\taudit_log_format(ab, \" op=make_equiv old=\");\n\t\taudit_log_untrustedstring(ab, old);\n\t\taudit_log_format(ab, \" new=\");\n\t\taudit_log_untrustedstring(ab, new);\n\t\taudit_log_format(ab, \" res=%d\", !err);\n\t\taudit_log_end(ab);\n\t\tkfree(old);\n\t\tkfree(new);\n\t\tbreak;\n\t}\n\tcase audit_signal_info:\n\t\tlen = 0;\n\t\tif (audit_sig_sid) {\n\t\t\terr = security_secid_to_secctx(audit_sig_sid, &ctx, &len);\n\t\t\tif (err)\n\t\t\t\treturn err;\n\t\t}\n\t\tsig_data = kmalloc(sizeof(*sig_data) + len, gfp_kernel);\n\t\tif (!sig_data) {\n\t\t\tif (audit_sig_sid)\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\treturn -enomem;\n\t\t}\n\t\tsig_data->", "5177": "< sizeof(struct sock_filter));\n\tfp_size = fprog->", "5178": "< sizeof(unsigned int) && count >", "5179": "< slots_per_page(c)) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < slots_per_page(c); i++) {\n\t\t\t\tif (kip->", "5180": "< slots_per_page(c)) {\n\t\t\twarn_on(kip->", "5181": "< slots_per_page(c); i++) {\n\t\t\tif (kip->", "5182": "< src->", "5183": "< src_rq->", "5184": "< srcu_callback_batch; i++) {\n\t\thead = rcu_batch_dequeue(&sp->", "5185": "< start + mod->", "5186": "< start + size));\n}\n\n\nstatic int gcov_module_notifier(struct notifier_block *nb, unsigned long event,\n\t\t\t\tvoid *data)\n{\n\tstruct module *mod = data;\n\tstruct gcov_info *info = null;\n\tstruct gcov_info *prev = null;\n\n\tif (event != module_state_going)\n\t\treturn notify_ok;\n\tmutex_lock(&gcov_lock);\n\n\t\n\twhile ((info = gcov_info_next(info))) {\n\t\tif (within(info, mod->", "5187": "< start + size);\n}\n\n#ifdef config_kallsyms\n\nstatic inline int is_arm_mapping_symbol(const char *str)\n{\n\tif (str[0] == '.' && str[1] == 'l')\n\t\treturn true;\n\treturn str[0] == '$' && strchr(\"axtd\", str[1])\n\t       && (str[2] == '\\0' || str[2] == '.');\n}\n\nstatic const char *get_ksymbol(struct module *mod,\n\t\t\t       unsigned long addr,\n\t\t\t       unsigned long *size,\n\t\t\t       unsigned long *offset)\n{\n\tunsigned int i, best = 0;\n\tunsigned long nextval;\n\n\t\n\tif (within_module_init(addr, mod))\n\t\tnextval = (unsigned long)mod->", "5188": "< start + size;\n}\n\n\nvoid lockdep_free_key_range(void *start, unsigned long size)\n{\n\tstruct lock_class *class;\n\tstruct list_head *head;\n\tunsigned long flags;\n\tint i;\n\tint locked;\n\n\traw_local_irq_save(flags);\n\tlocked = graph_lock();\n\n\t\n\tfor (i = 0; i < classhash_size; i++) {\n\t\thead = classhash_table + i;\n\t\tif (list_empty(head))\n\t\t\tcontinue;\n\t\tlist_for_each_entry_rcu(class, head, hash_entry) {\n\t\t\tif (within(class->", "5189": "< start || temp_start < kbuf->", "5190": "< start)\n\t\t\tbreak;\t\n\t}\n\tread_unlock(&resource_lock);\n\treturn ret;\n}\n\nvoid __weak arch_remove_reservations(struct resource *avail)\n{\n}\n\nstatic resource_size_t simple_align_resource(void *data,\n\t\t\t\t\t     const struct resource *avail,\n\t\t\t\t\t     resource_size_t size,\n\t\t\t\t\t     resource_size_t align)\n{\n\treturn avail->", "5191": "< start)\n\t\t\tcontinue;\n\t\treturn tmp;\n\t}\n}\n\nstatic int __release_resource(struct resource *old)\n{\n\tstruct resource *tmp, **p;\n\n\tp = &old->", "5192": "< start)\n\t\treturn root;\n\tif (start < root->", "5193": "< start) || (tmp->", "5194": "< start_index)\n\t\treturn __start___trace_bprintk_fmt + *pos;\n\n\t\n\tlast_index = start_index;\n\tstart_index = __stop___tracepoint_str - __start___tracepoint_str;\n\n\tif (*pos < last_index + start_index)\n\t\treturn __start___tracepoint_str + (*pos - last_index);\n\n\treturn find_next_mod_format(start_index, v, fmt, pos);\n}\n\nstatic void *\nt_start(struct seq_file *m, loff_t *pos)\n{\n\tformat_mod_start();\n\treturn find_next(null, pos);\n}\n\nstatic void *t_next(struct seq_file *m, void * v, loff_t *pos)\n{\n\t(*pos)++;\n\treturn find_next(v, pos);\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tconst char **fmt = v;\n\tconst char *str = *fmt;\n\tint i;\n\n\tseq_printf(m, \"0x%lx : \\\"\", *(unsigned long *)fmt);\n\n\t\n\tfor (i = 0; str[i]; i++) {\n\t\tswitch (str[i]) {\n\t\tcase '\\n':\n\t\t\tseq_puts(m, \"\\\\n\");\n\t\t\tbreak;\n\t\tcase '\\t':\n\t\t\tseq_puts(m, \"\\\\t\");\n\t\t\tbreak;\n\t\tcase '\\\\':\n\t\t\tseq_putc(m, '\\\\');\n\t\t\tbreak;\n\t\tcase '\"':\n\t\t\tseq_puts(m, \"\\\\\\\"\");\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tseq_putc(m, str[i]);\n\t\t}\n\t}\n\tseq_puts(m, \"\\\"\\n\");\n\n\treturn 0;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tformat_mod_stop();\n}\n\nstatic const struct seq_operations show_format_seq_ops = {\n\t.start = t_start,\n\t.next = t_next,\n\t.show = t_show,\n\t.stop = t_stop,\n};\n\nstatic int\nftrace_formats_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &show_format_seq_ops);\n}\n\nstatic const struct file_operations ftrace_formats_fops = {\n\t.open = ftrace_formats_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\n\nstatic __init int init_trace_printk_function_export(void)\n{\n\tstruct dentry *d_tracer;\n\n\td_tracer = tracing_init_dentry();\n\tif (is_err(d_tracer))\n\t\treturn 0;\n\n\ttrace_create_file(\"printk_formats\", 0444, d_tracer,\n\t\t\t\t    null, &ftrace_formats_fops);\n\n\treturn 0;\n}\n\nfs_initcall(init_trace_printk_function_export);\n\nstatic __init int init_trace_printk(void)\n{\n\treturn register_module_notifier(&module_trace_bprintk_format_nb);\n}\n\nearly_initcall(init_trace_printk);\n\n#include <linux/rwsem.h>", "5195": "< stat.size) {\n\t\tbytes = kernel_read(f.file, pos, (char *)(*buf) + pos,\n\t\t\t\t    stat.size - pos);\n\t\tif (bytes < 0) {\n\t\t\tvfree(*buf);\n\t\t\tret = bytes;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (bytes == 0)\n\t\t\tbreak;\n\t\tpos += bytes;\n\t}\n\n\tif (pos != stat.size) {\n\t\tret = -ebadf;\n\t\tvfree(*buf);\n\t\tgoto out;\n\t}\n\n\t*buf_len = pos;\nout:\n\tfdput(f);\n\treturn ret;\n}\n\n\nint __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,\n\t\t\t\t\t unsigned long buf_len)\n{\n\treturn -enoexec;\n}\n\nvoid * __weak arch_kexec_kernel_image_load(struct kimage *image)\n{\n\treturn err_ptr(-enoexec);\n}\n\nvoid __weak arch_kimage_file_post_load_cleanup(struct kimage *image)\n{\n}\n\nint __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,\n\t\t\t\t\tunsigned long buf_len)\n{\n\treturn -ekeyrejected;\n}\n\n\nint __weak\narch_kexec_apply_relocations_add(const elf_ehdr *ehdr, elf_shdr *sechdrs,\n\t\t\t\t unsigned int relsec)\n{\n\tpr_err(\"rela relocation unsupported.\\n\");\n\treturn -enoexec;\n}\n\n\nint __weak\narch_kexec_apply_relocations(const elf_ehdr *ehdr, elf_shdr *sechdrs,\n\t\t\t     unsigned int relsec)\n{\n\tpr_err(\"rel relocation unsupported.\\n\");\n\treturn -enoexec;\n}\n\n\nstatic void kimage_file_post_load_cleanup(struct kimage *image)\n{\n\tstruct purgatory_info *pi = &image->", "5196": "< stat.size) {\n\t\tbytes = kernel_read(f.file, pos, (char *)(info->", "5197": "< stop; start++) {\n\t\tif ((*start)->", "5198": "< strlen(buts->", "5199": "< strlen(name); i++) {\n\t\t\t\tchar c = name[i];\n\t\t\t\tif (isalnum(c))\n\t\t\t\t\tcontinue;\n\t\t\t\tif ((c == '.') || (c == '-') || (c == '_'))\n\t\t\t\t\tcontinue;\n\t\t\t\treturn -einval;\n\t\t\t}\n\t\t\t\n\t\t\tif (opts->", "5200": "< symsec->", "5201": "< sysctl_sched_migration_cost ||\n\t    !this_rq->", "5202": "< sysctl_sched_min_granularity)\n\t\treturn;\n\n\tse = __pick_first_entity(cfs_rq);\n\tdelta = curr->", "5203": "< t)\n\t\t\t\n\t\t\tcval = cputime_one_jiffy;\n\t\telse\n\t\t\tcval = cval - t;\n\t}\n\n\tspin_unlock_irq(&tsk->", "5204": "< t2) | ((t1 >", "5205": "< task_comm_len);\n\n\t\n\tdelta = ktime_get_ns() - tsk->", "5206": "< task_faults(p, src_nid);\n}\n\n#else\nstatic inline bool migrate_improves_locality(struct task_struct *p,\n\t\t\t\t\t     struct lb_env *env)\n{\n\treturn false;\n}\n\nstatic inline bool migrate_degrades_locality(struct task_struct *p,\n\t\t\t\t\t     struct lb_env *env)\n{\n\treturn false;\n}\n#endif\n\n\nstatic\nint can_migrate_task(struct task_struct *p, struct lb_env *env)\n{\n\tint tsk_cache_hot = 0;\n\n\tlockdep_assert_held(&env->", "5207": "< task_nice(p) &&\n\t\t\t    !can_nice(p, attr->", "5208": "< task_nice(p) && !can_nice(p, niceval)) {\n\t\terror = -eacces;\n\t\tgoto out;\n\t}\n\tno_nice = security_task_setnice(p, niceval);\n\tif (no_nice) {\n\t\terror = no_nice;\n\t\tgoto out;\n\t}\n\tif (error == -esrch)\n\t\terror = 0;\n\tset_user_nice(p, niceval);\nout:\n\treturn error;\n}\n\nsyscall_define3(setpriority, int, which, int, who, int, niceval)\n{\n\tstruct task_struct *g, *p;\n\tstruct user_struct *user;\n\tconst struct cred *cred = current_cred();\n\tint error = -einval;\n\tstruct pid *pgrp;\n\tkuid_t uid;\n\n\tif (which >", "5209": "< this_rq) {\n\t\t\traw_spin_unlock(&this_rq->", "5210": "< this_rq->", "5211": "< tick_period.tv64)\n\t\treturn;\n\n\t\n\twrite_seqlock(&jiffies_lock);\n\n\tdelta = ktime_sub(now, last_jiffies_update);\n\tif (delta.tv64 >", "5212": "< tk->", "5213": "< tmp.start)\n\t\t\tgoto next;\n\n\t\tresource_clip(&tmp, constraint->", "5214": "< tocopy; i++) {\n\t\teffective.cap[i] = kdata[i].effective;\n\t\tpermitted.cap[i] = kdata[i].permitted;\n\t\tinheritable.cap[i] = kdata[i].inheritable;\n\t}\n\twhile (i < _kernel_capability_u32s) {\n\t\teffective.cap[i] = 0;\n\t\tpermitted.cap[i] = 0;\n\t\tinheritable.cap[i] = 0;\n\t\ti++;\n\t}\n\n\teffective.cap[cap_last_u32] &= cap_last_u32_valid_mask;\n\tpermitted.cap[cap_last_u32] &= cap_last_u32_valid_mask;\n\tinheritable.cap[cap_last_u32] &= cap_last_u32_valid_mask;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -enomem;\n\n\tret = security_capset(new, current_cred(),\n\t\t\t      &effective, &inheritable, &permitted);\n\tif (ret < 0)\n\t\tgoto error;\n\n\taudit_log_capset(new, current_cred());\n\n\treturn commit_creds(new);\n\nerror:\n\tabort_creds(new);\n\treturn ret;\n}\n\n\nbool has_ns_capability(struct task_struct *t,\n\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}\n\n\nbool has_capability(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability(t, &init_user_ns, cap);\n}\n\n\nbool has_ns_capability_noaudit(struct task_struct *t,\n\t\t\t       struct user_namespace *ns, int cap)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = security_capable_noaudit(__task_cred(t), ns, cap);\n\trcu_read_unlock();\n\n\treturn (ret == 0);\n}\n\n\nbool has_capability_noaudit(struct task_struct *t, int cap)\n{\n\treturn has_ns_capability_noaudit(t, &init_user_ns, cap);\n}\n\n\nbool ns_capable(struct user_namespace *ns, int cap)\n{\n\tif (unlikely(!cap_valid(cap))) {\n\t\tpr_crit(\"capable() called with invalid cap=%u\\n\", cap);\n\t\tbug();\n\t}\n\n\tif (security_capable(current_cred(), ns, cap) == 0) {\n\t\tcurrent->", "5215": "< tp->", "5216": "< trace->", "5217": "< tracing_thresh)\n\t\t\treturn 0;\n\t} else {\n\t\tif (delta <= tr->", "5218": "< tracing_thresh))\n\t\treturn;\n\telse\n\t\ttrace_graph_return(trace);\n}\n\nstatic int graph_trace_init(struct trace_array *tr)\n{\n\tint ret;\n\n\tset_graph_array(tr);\n\tif (tracing_thresh)\n\t\tret = register_ftrace_graph(&trace_graph_thresh_return,\n\t\t\t\t\t    &trace_graph_thresh_entry);\n\telse\n\t\tret = register_ftrace_graph(&trace_graph_return,\n\t\t\t\t\t    &trace_graph_entry);\n\tif (ret)\n\t\treturn ret;\n\ttracing_start_cmdline_record();\n\n\treturn 0;\n}\n\nstatic void graph_trace_reset(struct trace_array *tr)\n{\n\ttracing_stop_cmdline_record();\n\tunregister_ftrace_graph();\n}\n\nstatic int graph_trace_update_thresh(struct trace_array *tr)\n{\n\tgraph_trace_reset(tr);\n\treturn graph_trace_init(tr);\n}\n\nstatic int max_bytes_for_cpu;\n\nstatic void print_graph_cpu(struct trace_seq *s, int cpu)\n{\n\t\n\ttrace_seq_printf(s, \" %*d) \", max_bytes_for_cpu, cpu);\n}\n\n#define trace_graph_procinfo_length\t14\n\nstatic void print_graph_proc(struct trace_seq *s, pid_t pid)\n{\n\tchar comm[task_comm_len];\n\t\n\tchar pid_str[11];\n\tint spaces = 0;\n\tint len;\n\tint i;\n\n\ttrace_find_cmdline(pid, comm);\n\tcomm[7] = '\\0';\n\tsprintf(pid_str, \"%d\", pid);\n\n\t\n\tlen = strlen(comm) + strlen(pid_str) + 1;\n\n\tif (len < trace_graph_procinfo_length)\n\t\tspaces = trace_graph_procinfo_length - len;\n\n\t\n\tfor (i = 0; i < spaces / 2; i++)\n\t\ttrace_seq_putc(s, ' ');\n\n\ttrace_seq_printf(s, \"%s-%s\", comm, pid_str);\n\n\t\n\tfor (i = 0; i < spaces - (spaces / 2); i++)\n\t\ttrace_seq_putc(s, ' ');\n}\n\n\nstatic void print_graph_lat_fmt(struct trace_seq *s, struct trace_entry *entry)\n{\n\ttrace_seq_putc(s, ' ');\n\ttrace_print_lat_fmt(s, entry);\n}\n\n\nstatic void\nverif_pid(struct trace_seq *s, pid_t pid, int cpu, struct fgraph_data *data)\n{\n\tpid_t prev_pid;\n\tpid_t *last_pid;\n\n\tif (!data)\n\t\treturn;\n\n\tlast_pid = &(per_cpu_ptr(data->", "5219": "< tsk->", "5220": "< tu->", "5221": "< tvn_size; i++) {\n\t\tmigrate_timer_list(new_base, old_base->", "5222": "< tvn_size; j++) {\n\t\tinit_list_head(base->", "5223": "< tvr_size) {\n\t\tint i = expires & tvr_mask;\n\t\tvec = base->", "5224": "< tvr_size; i++)\n\t\tmigrate_timer_list(new_base, old_base->", "5225": "< tvr_size; j++)\n\t\tinit_list_head(base->", "5226": "< txc->", "5227": "< u->", "5228": "< uidhash_sz; ++n)\n\t\tinit_hlist_head(uidhash_table + n);\n\n\t\n\tspin_lock_irq(&uidhash_lock);\n\tuid_hash_insert(&root_user, uidhashentry(global_root_uid));\n\tspin_unlock_irq(&uidhash_lock);\n\n\treturn 0;\n}\nsubsys_initcall(uid_cache_init);\n\n\nextern int mod_verify_sig(const void *mod, unsigned long *_modlen);\n\n\n#define pr_fmt(fmt) kbuild_modname \": \" fmt\n\n#include <linux/file.h>", "5229": "< uinsns_per_page) {\n\t\t\tif (!test_and_set_bit(slot_nr, area->", "5230": "< uinsns_per_page));\n\t} while (slot_nr >", "5231": "< uprobes_hash_sz; i++)\n\t\tmutex_init(&uprobes_mmap_mutex[i]);\n\n\tif (percpu_init_rwsem(&dup_mmap_sem))\n\t\treturn -enomem;\n\n\treturn register_die_notifier(&uprobe_exception_nb);\n}\n__initcall(init_uprobes);\n\n\n#include <linux/capability.h>", "5232": "< usec_per_sec))\n\nint do_setitimer(int which, struct itimerval *value, struct itimerval *ovalue)\n{\n\tstruct task_struct *tsk = current;\n\tstruct hrtimer *timer;\n\tktime_t expires;\n\n\t\n\tif (!timeval_valid(&value->", "5233": "< usecs)\n\t\t\t++fail_count;\n\t\twarn_on(time_passed < 0);\n\t\tsum += time_passed;\n\t}\n\n\tavg = sum;\n\tdo_div(avg, iters);\n\tseq_printf(s, \"%d usecs x %d: exp=%d allowed=%d min=%d avg=%lld max=%d\",\n\t\t\tusecs, iters, usecs * 1000,\n\t\t\t(usecs * 1000) - allowed_error_ns, min, avg, max);\n\tif (fail_count)\n\t\tseq_printf(s, \" fail=%d\", fail_count);\n\tseq_puts(s, \"\\n\");\n\n\treturn 0;\n}\n\nstatic int udelay_test_show(struct seq_file *s, void *v)\n{\n\tint usecs;\n\tint iters;\n\tint ret = 0;\n\n\tmutex_lock(&udelay_test_lock);\n\tusecs = udelay_test_usecs;\n\titers = udelay_test_iterations;\n\tmutex_unlock(&udelay_test_lock);\n\n\tif (usecs >", "5234": "< user_hz\n\treturn x * (user_hz / hz);\n# else\n\treturn x / (hz / user_hz);\n# endif\n#else\n\treturn div_u64((u64)x * tick_nsec, nsec_per_sec / user_hz);\n#endif\n}\nexport_symbol(jiffies_to_clock_t);\n\nunsigned long clock_t_to_jiffies(unsigned long x)\n{\n#if (hz % user_hz)==0\n\tif (x >", "5235": "< user_hz\n\tx = div_u64(x * user_hz, hz);\n# elif hz >", "5236": "< val))\n\t\t\treturn -einval;\n\t\t*valp = val;\n\t} else {\n\t\tint val = *valp;\n\t\tif (val < 0) {\n\t\t\t*negp = true;\n\t\t\t*lvalp = (unsigned long)-val;\n\t\t} else {\n\t\t\t*negp = false;\n\t\t\t*lvalp = (unsigned long)val;\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct do_proc_dointvec_minmax_conv_param param = {\n\t\t.min = (int *) table->", "5237": "< val);\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase op_le:\t\t\t\t\t\t\t\\\n\t\tmatch = (*addr <= val);\t\t\t\t\t\\\n\t\tbreak;\t\t\t\t\t\t\t\\\n\tcase op_gt:\t\t\t\t\t\t\t\\\n\t\tmatch = (*addr >", "5238": "< view->", "5239": "< vmacache_size; i++) {\n\t\t\tif (!current->", "5240": "< w)\n\t\t\twl = (w * (long)tg->", "5241": "< wcount; i++)\n\t\t\tbufptr = hex_byte_pack(bufptr, s[i]);\n\t\t*bufptr = '\\0';\n\n\t\t\n\t\ts += wcount;\n\t\tlen -= wcount;\n\n\t\t\n\t\tput_packet(gdbmsgbuf);\n\t}\n}\n\n\nchar *kgdb_mem2hex(char *mem, char *buf, int count)\n{\n\tchar *tmp;\n\tint err;\n\n\t\n\ttmp = buf + count;\n\n\terr = probe_kernel_read(tmp, mem, count);\n\tif (err)\n\t\treturn null;\n\twhile (count >", "5242": "< work_nr_colors; i++) {\n\t\t\tif (warn_on(pwq->", "5243": "< zone->", "5244": "<%u>", "5245": "<, end_code);\n\terror |= __prctl_check_order(start_data, <, end_data);\n\terror |= __prctl_check_order(start_brk, <=, brk);\n\terror |= __prctl_check_order(arg_start, <=, arg_end);\n\terror |= __prctl_check_order(env_start, <=, env_end);\n\tif (error)\n\t\tgoto out;\n#undef __prctl_check_order\n\n\terror = -einval;\n\n\t\n\tif (prctl_map->", "5246": "<- %lx)\";\n\t\targ = \"rec->", "5247": "<...>", "5248": "<<\n\t\t\t\t\t\t(tk->", "5249": "<<  1)\n#define max_shares\t(1ul << 18)\n#endif\n\ntypedef int (*tg_visitor)(struct task_group *, void *);\n\nextern int walk_tg_tree_from(struct task_group *from,\n\t\t\t     tg_visitor down, tg_visitor up, void *data);\n\n\nstatic inline int walk_tg_tree(tg_visitor down, tg_visitor up, void *data)\n{\n\treturn walk_tg_tree_from(&root_task_group, down, up, data);\n}\n\nextern int tg_nop(struct task_group *tg, void *data);\n\nextern void free_fair_sched_group(struct task_group *tg);\nextern int alloc_fair_sched_group(struct task_group *tg, struct task_group *parent);\nextern void unregister_fair_sched_group(struct task_group *tg, int cpu);\nextern void init_tg_cfs_entry(struct task_group *tg, struct cfs_rq *cfs_rq,\n\t\t\tstruct sched_entity *se, int cpu,\n\t\t\tstruct sched_entity *parent);\nextern void init_cfs_bandwidth(struct cfs_bandwidth *cfs_b);\nextern int sched_group_set_shares(struct task_group *tg, unsigned long shares);\n\nextern void __refill_cfs_bandwidth_runtime(struct cfs_bandwidth *cfs_b);\nextern void __start_cfs_bandwidth(struct cfs_bandwidth *cfs_b, bool force);\nextern void unthrottle_cfs_rq(struct cfs_rq *cfs_rq);\n\nextern void free_rt_sched_group(struct task_group *tg);\nextern int alloc_rt_sched_group(struct task_group *tg, struct task_group *parent);\nextern void init_tg_rt_entry(struct task_group *tg, struct rt_rq *rt_rq,\n\t\tstruct sched_rt_entity *rt_se, int cpu,\n\t\tstruct sched_rt_entity *parent);\n\nextern struct task_group *sched_create_group(struct task_group *parent);\nextern void sched_online_group(struct task_group *tg,\n\t\t\t       struct task_group *parent);\nextern void sched_destroy_group(struct task_group *tg);\nextern void sched_offline_group(struct task_group *tg);\n\nextern void sched_move_task(struct task_struct *tsk);\n\n#ifdef config_fair_group_sched\nextern int sched_group_set_shares(struct task_group *tg, unsigned long shares);\n#endif\n\n#else \n\nstruct cfs_bandwidth { };\n\n#endif\t\n\n\nstruct cfs_rq {\n\tstruct load_weight load;\n\tunsigned int nr_running, h_nr_running;\n\n\tu64 exec_clock;\n\tu64 min_vruntime;\n#ifndef config_64bit\n\tu64 min_vruntime_copy;\n#endif\n\n\tstruct rb_root tasks_timeline;\n\tstruct rb_node *rb_leftmost;\n\n\t\n\tstruct sched_entity *curr, *next, *last, *skip;\n\n#ifdef\tconfig_sched_debug\n\tunsigned int nr_spread_over;\n#endif\n\n#ifdef config_smp\n\t\n\tunsigned long runnable_load_avg, blocked_load_avg, utilization_load_avg;\n\tatomic64_t decay_counter;\n\tu64 last_decay;\n\tatomic_long_t removed_load;\n\n#ifdef config_fair_group_sched\n\t\n\tu32 tg_runnable_contrib;\n\tunsigned long tg_load_contrib;\n\n\t\n\tunsigned long h_load;\n\tu64 last_h_load_update;\n\tstruct sched_entity *h_load_next;\n#endif \n#endif \n\n#ifdef config_fair_group_sched\n\tstruct rq *rq;\t\n\n\t\n\tint on_list;\n\tstruct list_head leaf_cfs_rq_list;\n\tstruct task_group *tg;\t\n\n#ifdef config_cfs_bandwidth\n\tint runtime_enabled;\n\tu64 runtime_expires;\n\ts64 runtime_remaining;\n\n\tu64 throttled_clock, throttled_clock_task;\n\tu64 throttled_clock_task_time;\n\tint throttled, throttle_count;\n\tstruct list_head throttled_list;\n#endif \n#endif \n};\n\nstatic inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >", "5250": "<< !!(file->", "5251": "<< (20 - page_shift);\n\trss = get_mm_rss(p->", "5252": "<< (bits_per_long-1))\n\n\ndefine_mutex(module_mutex);\nexport_symbol_gpl(module_mutex);\nstatic list_head(modules);\n#ifdef config_kgdb_kdb\nstruct list_head *kdb_modules = &modules; \n#endif \n\n#ifdef config_module_sig\n#ifdef config_module_sig_force\nstatic bool sig_enforce = true;\n#else\nstatic bool sig_enforce = false;\n\nstatic int param_set_bool_enable_only(const char *val,\n\t\t\t\t      const struct kernel_param *kp)\n{\n\tint err;\n\tbool test;\n\tstruct kernel_param dummy_kp = *kp;\n\n\tdummy_kp.arg = &test;\n\n\terr = param_set_bool(val, &dummy_kp);\n\tif (err)\n\t\treturn err;\n\n\t\n\tif (!test && sig_enforce)\n\t\treturn -erofs;\n\n\tif (test)\n\t\tsig_enforce = true;\n\treturn 0;\n}\n\nstatic const struct kernel_param_ops param_ops_bool_enable_only = {\n\t.flags = kernel_param_ops_fl_noarg,\n\t.set = param_set_bool_enable_only,\n\t.get = param_get_bool,\n};\n#define param_check_bool_enable_only param_check_bool\n\nmodule_param(sig_enforce, bool_enable_only, 0644);\n#endif \n#endif \n\n\nint modules_disabled = 0;\ncore_param(nomodule, modules_disabled, bint, 0);\n\n\nstatic declare_wait_queue_head(module_wq);\n\nstatic blocking_notifier_head(module_notify_list);\n\n\nstatic unsigned long module_addr_min = -1ul, module_addr_max = 0;\n\nint register_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&module_notify_list, nb);\n}\nexport_symbol(register_module_notifier);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}\nexport_symbol(unregister_module_notifier);\n\nstruct load_info {\n\telf_ehdr *hdr;\n\tunsigned long len;\n\telf_shdr *sechdrs;\n\tchar *secstrings, *strtab;\n\tunsigned long symoffs, stroffs;\n\tstruct _ddebug *debug;\n\tunsigned int num_debug;\n\tbool sig_ok;\n\tstruct {\n\t\tunsigned int sym, str, mod, vers, info, pcpu;\n\t} index;\n};\n\n\nstatic inline int strong_try_module_get(struct module *mod)\n{\n\tbug_on(mod && mod->", "5253": "<< (cpu - rdp->", "5254": "<< (expsize - 1));\t\n\t\tvalue >", "5255": "<< (frac_bits - 1);\n\t\tx >", "5256": "<< (fshift - 1);\n\treturn load >", "5257": "<< (i - gc->", "5258": "<< (j * bits_per_compat_long);\n\t\t}\n\t\t*mask++ = m;\n\t}\n\n\treturn 0;\n}\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tint i, j;\n\tunsigned long m;\n\tcompat_ulong_t um;\n\tunsigned long nr_compat_longs;\n\n\t\n\tbitmap_size = align(bitmap_size, bits_per_compat_long);\n\n\tif (!access_ok(verify_write, umask, bitmap_size / 8))\n\t\treturn -efault;\n\n\tnr_compat_longs = bits_to_compat_longs(bitmap_size);\n\n\tfor (i = 0; i < bits_to_longs(bitmap_size); i++) {\n\t\tm = *mask++;\n\n\t\tfor (j = 0; j < sizeof(m)/sizeof(um); j++) {\n\t\t\tum = m;\n\n\t\t\t\n\t\t\tif (nr_compat_longs-- >", "5259": "<< (mantsize2+expsize2-1)) - 1;\n\t} else {\n\t\treturn (value & (maxfract2>", "5260": "<< (mantsize2-1));\n\t}\n}\n#endif\n\n#if acct_version == 3\n\nstatic u32 encode_float(u64 value)\n{\n\tunsigned exp = 190;\n\tunsigned u;\n\n\tif (value == 0)\n\t\treturn 0;\n\twhile ((s64)value >", "5261": "<< (page_shift + page_order(rb));\n}\n\nstatic inline unsigned long perf_aux_size(struct ring_buffer *rb)\n{\n\treturn rb->", "5262": "<< (page_shift - 1);\n\nout:\n\tif (!ret)\n\t\trb->", "5263": "<< (page_shift - 10))\n\tkdb_printf(\"\\nmemtotal:       %8lu kb\\nmemfree:        %8lu kb\\n\"\n\t\t   \"buffers:        %8lu kb\\n\",\n\t\t   k(val.totalram), k(val.freeram), k(val.bufferram));\n\treturn 0;\n}\n\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0ul;\n\n\tif (argc < 1 || argc >", "5264": "<< (shift_pll + 1 + time_constant)))\n\t\tsecs = 1 << (shift_pll + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(ntp_scale_shift - 2 * (shift_pll + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, maxfreq_scaled);\n\n\ttime_freq   = max(freq_adj, -maxfreq_scaled);\n\n\ttime_offset = div_s64(offset64 << ntp_scale_shift, ntp_interval_freq);\n}\n\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t\n\ttime_status\t|= sta_unsync;\n\ttime_maxerror\t= ntp_phase_limit;\n\ttime_esterror\t= ntp_phase_limit;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\t\n\tpps_clear();\n}\n\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}\n\n\n\nint second_overflow(unsigned long secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\n\t\n\tswitch (time_state) {\n\tcase time_ok:\n\t\tif (time_status & sta_ins)\n\t\t\ttime_state = time_ins;\n\t\telse if (time_status & sta_del)\n\t\t\ttime_state = time_del;\n\t\tbreak;\n\tcase time_ins:\n\t\tif (!(time_status & sta_ins))\n\t\t\ttime_state = time_ok;\n\t\telse if (secs % 86400 == 0) {\n\t\t\tleap = -1;\n\t\t\ttime_state = time_oop;\n\t\t\tprintk(kern_notice\n\t\t\t\t\"clock: inserting leap second 23:59:60 utc\\n\");\n\t\t}\n\t\tbreak;\n\tcase time_del:\n\t\tif (!(time_status & sta_del))\n\t\t\ttime_state = time_ok;\n\t\telse if ((secs + 1) % 86400 == 0) {\n\t\t\tleap = 1;\n\t\t\ttime_state = time_wait;\n\t\t\tprintk(kern_notice\n\t\t\t\t\"clock: deleting leap second 23:59:59 utc\\n\");\n\t\t}\n\t\tbreak;\n\tcase time_oop:\n\t\ttime_state = time_wait;\n\t\tbreak;\n\n\tcase time_wait:\n\t\tif (!(time_status & (sta_ins | sta_del)))\n\t\t\ttime_state = time_ok;\n\t\tbreak;\n\t}\n\n\n\t\n\ttime_maxerror += maxfreq / nsec_per_usec;\n\tif (time_maxerror >", "5265": "<< (x))\n#define mask_declare_2(x)\tmask_declare_1(x), mask_declare_1(x+1)\n#define mask_declare_4(x)\tmask_declare_2(x), mask_declare_2(x+2)\n#define mask_declare_8(x)\tmask_declare_4(x), mask_declare_4(x+4)\n\nconst unsigned long cpu_bit_bitmap[bits_per_long+1][bits_to_longs(nr_cpus)] = {\n\n\tmask_declare_8(0),\tmask_declare_8(8),\n\tmask_declare_8(16),\tmask_declare_8(24),\n#if bits_per_long >", "5266": "<< 0)\n#define _irq_desc_percpu\t(1 << 1)\n\n#define irq_get_desc_check_global\t(_irq_desc_check)\n#define irq_get_desc_check_percpu\t(_irq_desc_check | _irq_desc_percpu)\n\nstruct irq_desc *\n__irq_get_desc_lock(unsigned int irq, unsigned long *flags, bool bus,\n\t\t    unsigned int check);\nvoid __irq_put_desc_unlock(struct irq_desc *desc, unsigned long flags, bool bus);\n\nstatic inline struct irq_desc *\nirq_get_desc_buslock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, true, check);\n}\n\nstatic inline void\nirq_put_desc_busunlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, true);\n}\n\nstatic inline struct irq_desc *\nirq_get_desc_lock(unsigned int irq, unsigned long *flags, unsigned int check)\n{\n\treturn __irq_get_desc_lock(irq, flags, false, check);\n}\n\nstatic inline void\nirq_put_desc_unlock(struct irq_desc *desc, unsigned long flags)\n{\n\t__irq_put_desc_unlock(desc, flags, false);\n}\n\n\nstatic inline void irqd_set_move_pending(struct irq_data *d)\n{\n\td->", "5267": "<< 0)\n#define tk_mirror\t\t(1 << 1)\n#define tk_clock_was_set\t(1 << 2)\n\n\nstatic struct {\n\tseqcount_t\t\tseq;\n\tstruct timekeeper\ttimekeeper;\n} tk_core ____cacheline_aligned;\n\nstatic define_raw_spinlock(timekeeper_lock);\nstatic struct timekeeper shadow_timekeeper;\n\n\nstruct tk_fast {\n\tseqcount_t\t\tseq;\n\tstruct tk_read_base\tbase[2];\n};\n\nstatic struct tk_fast tk_fast_mono ____cacheline_aligned;\nstatic struct tk_fast tk_fast_raw  ____cacheline_aligned;\n\n\nint __read_mostly timekeeping_suspended;\n\nstatic inline void tk_normalize_xtime(struct timekeeper *tk)\n{\n\twhile (tk->", "5268": "<< 0)\n};\n\nextern struct list_head ftrace_trace_arrays;\n\nextern struct mutex trace_types_lock;\n\nextern int trace_array_get(struct trace_array *tr);\nextern void trace_array_put(struct trace_array *tr);\n\n\nstatic inline struct trace_array *top_trace_array(void)\n{\n\tstruct trace_array *tr;\n\n\tif (list_empty(&ftrace_trace_arrays))\n\t\treturn null;\n\n\ttr = list_entry(ftrace_trace_arrays.prev,\n\t\t\ttypeof(*tr), list);\n\twarn_on(!(tr->", "5269": "<< 0), \n\tcgroup_freezing_self\t= (1 << 1), \n\tcgroup_freezing_parent\t= (1 << 2), \n\tcgroup_frozen\t\t= (1 << 3), \n\n\t\n\tcgroup_freezing\t\t= cgroup_freezing_self | cgroup_freezing_parent,\n};\n\nstruct freezer {\n\tstruct cgroup_subsys_state\tcss;\n\tunsigned int\t\t\tstate;\n};\n\nstatic define_mutex(freezer_mutex);\n\nstatic inline struct freezer *css_freezer(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct freezer, css) : null;\n}\n\nstatic inline struct freezer *task_freezer(struct task_struct *task)\n{\n\treturn css_freezer(task_css(task, freezer_cgrp_id));\n}\n\nstatic struct freezer *parent_freezer(struct freezer *freezer)\n{\n\treturn css_freezer(freezer->", "5270": "<< 1) + 1;\n}\n\nstatic inline int right_child(int i)\n{\n\treturn (i << 1) + 2;\n}\n\nstatic inline int dl_time_before(u64 a, u64 b)\n{\n\treturn (s64)(a - b) < 0;\n}\n\nstatic void cpudl_exchange(struct cpudl *cp, int a, int b)\n{\n\tint cpu_a = cp->", "5271": "<< 1) >", "5272": "<< 1),\n\ttracer_preempt_off\t= (1 << 2),\n};\n\nstatic int trace_type __read_mostly;\n\nstatic int save_flags;\nstatic bool function_enabled;\n\nstatic void stop_irqsoff_tracer(struct trace_array *tr, int graph);\nstatic int start_irqsoff_tracer(struct trace_array *tr, int graph);\n\n#ifdef config_preempt_tracer\nstatic inline int\npreempt_trace(void)\n{\n\treturn ((trace_type & tracer_preempt_off) && preempt_count());\n}\n#else\n# define preempt_trace() (0)\n#endif\n\n#ifdef config_irqsoff_tracer\nstatic inline int\nirq_trace(void)\n{\n\treturn ((trace_type & tracer_irqs_off) &&\n\t\tirqs_disabled());\n}\n#else\n# define irq_trace() (0)\n#endif\n\n#define trace_display_graph\t1\n\nstatic struct tracer_opt trace_opts[] = {\n#ifdef config_function_graph_tracer\n\t\n\t{ tracer_opt(display-graph, trace_display_graph) },\n#endif\n\t{ } \n};\n\nstatic struct tracer_flags tracer_flags = {\n\t.val  = 0,\n\t.opts = trace_opts,\n};\n\n#define is_graph() (tracer_flags.val & trace_display_graph)\n\n\nstatic __cacheline_aligned_in_smp\tunsigned long max_sequence;\n\n#ifdef config_function_tracer\n\nstatic int func_prolog_dec(struct trace_array *tr,\n\t\t\t   struct trace_array_cpu **data,\n\t\t\t   unsigned long *flags)\n{\n\tlong disabled;\n\tint cpu;\n\n\t\n\tcpu = raw_smp_processor_id();\n\tif (likely(!per_cpu(tracing_cpu, cpu)))\n\t\treturn 0;\n\n\tlocal_save_flags(*flags);\n\t\n\tif (!irqs_disabled_flags(*flags))\n\t\treturn 0;\n\n\t*data = per_cpu_ptr(tr->", "5273": "<< 1);\n\n\t\tp->", "5274": "<< 1);\n}\n\n\nstatic struct file *\nget_file_raw_ptr(struct task_struct *task, unsigned int idx)\n{\n\tstruct file *file = null;\n\n\ttask_lock(task);\n\trcu_read_lock();\n\n\tif (task->", "5275": "<< 10) | node);\n\n\t\tresult = -efault;\n\t\tif (put_user(dnaddr, (__le16 __user *)oldval))\n\t\t\tgoto out;\n\n\t\tcopied = sizeof(dnaddr);\n\t}\n\n\tif (newval && newlen) {\n\t\t__le16 dnaddr;\n\t\tchar buf[15];\n\t\tint len;\n\n\t\tresult = -einval;\n\t\tif (newlen != sizeof(dnaddr))\n\t\t\tgoto out;\n\n\t\tresult = -efault;\n\t\tif (get_user(dnaddr, (__le16 __user *)newval))\n\t\t\tgoto out;\n\n\t\tlen = scnprintf(buf, sizeof(buf), \"%hu.%hu\",\n\t\t\t\tle16_to_cpu(dnaddr) >", "5276": "<< 15)\n#define filter_pred_fold\t(1 << 15)\n\n\n#define max_filter_pred\t\t16384\n\nstruct filter_pred;\nstruct regex;\n\ntypedef int (*filter_pred_fn_t) (struct filter_pred *pred, void *event);\n\ntypedef int (*regex_match_func)(char *str, struct regex *r, int len);\n\nenum regex_type {\n\tmatch_full = 0,\n\tmatch_front_only,\n\tmatch_middle_only,\n\tmatch_end_only,\n};\n\nstruct regex {\n\tchar\t\t\tpattern[max_filter_str_val];\n\tint\t\t\tlen;\n\tint\t\t\tfield_len;\n\tregex_match_func\tmatch;\n};\n\nstruct filter_pred {\n\tfilter_pred_fn_t \tfn;\n\tu64 \t\t\tval;\n\tstruct regex\t\tregex;\n\tunsigned short\t\t*ops;\n\tstruct ftrace_event_field *field;\n\tint \t\t\toffset;\n\tint \t\t\tnot;\n\tint \t\t\top;\n\tunsigned short\t\tindex;\n\tunsigned short\t\tparent;\n\tunsigned short\t\tleft;\n\tunsigned short\t\tright;\n};\n\nextern enum regex_type\nfilter_parse_regex(char *buff, int len, char **search, int *not);\nextern void print_event_filter(struct ftrace_event_file *file,\n\t\t\t       struct trace_seq *s);\nextern int apply_event_filter(struct ftrace_event_file *file,\n\t\t\t      char *filter_string);\nextern int apply_subsystem_event_filter(struct ftrace_subsystem_dir *dir,\n\t\t\t\t\tchar *filter_string);\nextern void print_subsystem_event_filter(struct event_subsystem *system,\n\t\t\t\t\t struct trace_seq *s);\nextern int filter_assign_type(const char *type);\nextern int create_event_filter(struct ftrace_event_call *call,\n\t\t\t       char *filter_str, bool set_str,\n\t\t\t       struct event_filter **filterp);\nextern void free_event_filter(struct event_filter *filter);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct ftrace_event_call *call, char *name);\n\nextern void trace_event_enable_cmd_record(bool enable);\nextern int event_trace_add_tracer(struct dentry *parent, struct trace_array *tr);\nextern int event_trace_del_tracer(struct trace_array *tr);\n\nextern struct ftrace_event_file *find_event_file(struct trace_array *tr,\n\t\t\t\t\t\t const char *system,\n\t\t\t\t\t\t const char *event);\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn access_once(file_inode(filp)->", "5277": "<< 16) | ((u32)(roffs) & 0xffff))\n#define get_rloc_len(dl)\t\t((u32)(dl) >", "5278": "<< 16, period + 1);\n\t\t\tf_weight = (f_weight * p->", "5279": "<< 17))\n\n#if bits_per_long >", "5280": "<< 18) / sizeof(struct sock_filter))\n\n\nstatic void populate_seccomp_data(struct seccomp_data *sd)\n{\n\tstruct task_struct *task = current;\n\tstruct pt_regs *regs = task_pt_regs(task);\n\tunsigned long args[6];\n\n\tsd->", "5281": "<< 2); \n\t\tif (hlock->", "5282": "<< 2,\t\n\n\t\n\tworker_die\t\t= 1 << 1,\t\n\tworker_idle\t\t= 1 << 2,\t\n\tworker_prep\t\t= 1 << 3,\t\n\tworker_cpu_intensive\t= 1 << 6,\t\n\tworker_unbound\t\t= 1 << 7,\t\n\tworker_rebound\t\t= 1 << 8,\t\n\n\tworker_not_running\t= worker_prep | worker_cpu_intensive |\n\t\t\t\t  worker_unbound | worker_rebound,\n\n\tnr_std_worker_pools\t= 2,\t\t\n\n\tunbound_pool_hash_order\t= 6,\t\t\n\tbusy_worker_hash_order\t= 6,\t\t\n\n\tmax_idle_workers_ratio\t= 4,\t\t\n\tidle_worker_timeout\t= 300 * hz,\t\n\n\tmayday_initial_timeout  = hz / 100 >", "5283": "<< 20));\n#ifndef config_64bit\n\tcfs_rq->", "5284": "<< 20;\n\t\t\tupdate_entity_load_avg(se, 0);\n\t\t\t\n\t\t\tse->", "5285": "<< 20;\n\n\t\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << 20, period);\n}\n\n#ifdef config_smp\ninline struct dl_bw *dl_bw_of(int i)\n{\n\trcu_lockdep_assert(rcu_read_lock_sched_held(),\n\t\t\t   \"sched rcu must be held\");\n\treturn &cpu_rq(i)->", "5286": "<< 23);\n}\n#endif\n\n\n\nstatic void fill_ac(acct_t *ac)\n{\n\tstruct pacct_struct *pacct = &current->", "5287": "<< 24 | poison_free << 16 | poison_free << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\nexport_symbol(creds_are_invalid);\n\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(kern_err \"cred: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->", "5288": "<< 24 | poison_free << 16 | poison_free << 8)))\n\t\tprintk(kern_err \"cred: ->", "5289": "<< 31)\n\nstatic inline int system_refcount(struct event_subsystem *system)\n{\n\treturn system->", "5290": "<< 31);\n\tchunk->", "5291": "<< 32 );\n\tcase 1: set->", "5292": "<< 32 );\n\tcase 2: set->", "5293": "<< 32 );\n\tcase 3: set->", "5294": "<< 32 );\n\t}\n}\nexport_symbol_gpl(sigset_from_compat);\n\nvoid\nsigset_to_compat(compat_sigset_t *compat, const sigset_t *set)\n{\n\tswitch (_nsig_words) {\n\tcase 4: compat->", "5295": "<< 32;\n\t\tinsn++;\n\t\tcont;\n\talu64_arsh_x:\n\t\t(*(s64 *) &dst) >", "5296": "<< 32;\n\n\treturn (struct bpf_map *) (unsigned long) imm64;\n}\n\n\nstatic int check_ld_imm(struct verifier_env *env, struct bpf_insn *insn)\n{\n\tstruct reg_state *regs = env->", "5297": "<< 4;\n\t}\n\n\treturn probe_kernel_write(mem, tmp_raw, count);\n}\n\n\nint kgdb_hex2long(char **ptr, unsigned long *long_val)\n{\n\tint hex_val;\n\tint num = 0;\n\tint negate = 0;\n\n\t*long_val = 0;\n\n\tif (**ptr == '-') {\n\t\tnegate = 1;\n\t\t(*ptr)++;\n\t}\n\twhile (**ptr) {\n\t\thex_val = hex_to_bin(**ptr);\n\t\tif (hex_val < 0)\n\t\t\tbreak;\n\n\t\t*long_val = (*long_val << 4) | hex_val;\n\t\tnum++;\n\t\t(*ptr)++;\n\t}\n\n\tif (negate)\n\t\t*long_val = -*long_val;\n\n\treturn num;\n}\n\n\nstatic int kgdb_ebin2mem(char *buf, char *mem, int count)\n{\n\tint size = 0;\n\tchar *c = buf;\n\n\twhile (count-- >", "5298": "<< 59),\n\t\t\t\t  kern_warning \"delta way too big! %llu ts=%llu write stamp = %llu\\n%s\",\n\t\t\t\t  (unsigned long long)delta,\n\t\t\t\t  (unsigned long long)ts,\n\t\t\t\t  (unsigned long long)cpu_buffer->", "5299": "<< 63) ||\n\t    attr->", "5300": "<< 63))\n\t\treturn false;\n\n\t\n\tif ((attr->", "5301": "<< 8),\n\t\t\t\t cld_stopped);\n\t} else {\n\t\twarn_on_once(!signr);\n\t\tptrace_stop(signr, cld_stopped, 0, null);\n\t\tcurrent->", "5302": "<< \\\n\t  (ilog2(blk_tc_ ## __name) + blk_tc_shift - __req_ ## __name))\n\n\nstatic void __blk_add_trace(struct blk_trace *bt, sector_t sector, int bytes,\n\t\t     int rw, u32 what, int error, int pdu_len, void *pdu_data)\n{\n\tstruct task_struct *tsk = current;\n\tstruct ring_buffer_event *event = null;\n\tstruct ring_buffer *buffer = null;\n\tstruct blk_io_trace *t;\n\tunsigned long flags = 0;\n\tunsigned long *sequence;\n\tpid_t pid;\n\tint cpu, pc = 0;\n\tbool blk_tracer = blk_tracer_enabled;\n\n\tif (unlikely(bt->", "5303": "<< __sched_feat_##name) * enabled |\n\nconst_debug unsigned int sysctl_sched_features =\n#include \"features.h\"\n\t0;\n\n#undef sched_feat\n\n#ifdef config_sched_debug\n#define sched_feat(name, enabled)\t\\\n\t#name ,\n\nstatic const char * const sched_feat_names[] = {\n#include \"features.h\"\n};\n\n#undef sched_feat\n\nstatic int sched_feat_show(struct seq_file *m, void *v)\n{\n\tint i;\n\n\tfor (i = 0; i < __sched_feat_nr; i++) {\n\t\tif (!(sysctl_sched_features & (1ul << i)))\n\t\t\tseq_puts(m, \"no_\");\n\t\tseq_printf(m, \"%s \", sched_feat_names[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\n\treturn 0;\n}\n\n#ifdef have_jump_label\n\n#define jump_label_key__true  static_key_init_true\n#define jump_label_key__false static_key_init_false\n\n#define sched_feat(name, enabled)\t\\\n\tjump_label_key__##enabled ,\n\nstruct static_key sched_feat_keys[__sched_feat_nr] = {\n#include \"features.h\"\n};\n\n#undef sched_feat\n\nstatic void sched_feat_disable(int i)\n{\n\tif (static_key_enabled(&sched_feat_keys[i]))\n\t\tstatic_key_slow_dec(&sched_feat_keys[i]);\n}\n\nstatic void sched_feat_enable(int i)\n{\n\tif (!static_key_enabled(&sched_feat_keys[i]))\n\t\tstatic_key_slow_inc(&sched_feat_keys[i]);\n}\n#else\nstatic void sched_feat_disable(int i) { };\nstatic void sched_feat_enable(int i) { };\n#endif \n\nstatic int sched_feat_set(char *cmp)\n{\n\tint i;\n\tint neg = 0;\n\n\tif (strncmp(cmp, \"no_\", 3) == 0) {\n\t\tneg = 1;\n\t\tcmp += 3;\n\t}\n\n\tfor (i = 0; i < __sched_feat_nr; i++) {\n\t\tif (strcmp(cmp, sched_feat_names[i]) == 0) {\n\t\t\tif (neg) {\n\t\t\t\tsysctl_sched_features &= ~(1ul << i);\n\t\t\t\tsched_feat_disable(i);\n\t\t\t} else {\n\t\t\t\tsysctl_sched_features |= (1ul << i);\n\t\t\t\tsched_feat_enable(i);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn i;\n}\n\nstatic ssize_t\nsched_feat_write(struct file *filp, const char __user *ubuf,\n\t\tsize_t cnt, loff_t *ppos)\n{\n\tchar buf[64];\n\tchar *cmp;\n\tint i;\n\tstruct inode *inode;\n\n\tif (cnt >", "5304": "<< __sched_feat_##x))\n#endif \n\n#ifdef config_numa_balancing\n#define sched_feat_numa(x) sched_feat(x)\n#ifdef config_sched_debug\n#define numabalancing_enabled sched_feat_numa(numa)\n#else\nextern bool numabalancing_enabled;\n#endif \n#else\n#define sched_feat_numa(x) (0)\n#define numabalancing_enabled (0)\n#endif \n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * nsec_per_usec;\n}\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn runtime_inf;\n\n\treturn (u64)sysctl_sched_rt_runtime * nsec_per_usec;\n}\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->", "5305": "<< bad_bit)))\n\t\treturn print_usage_bug(curr, this, bad_bit, new_bit);\n\treturn 1;\n}\n\nstatic int mark_lock(struct task_struct *curr, struct held_lock *this,\n\t\t     enum lock_usage_bit new_bit);\n\n#if defined(config_trace_irqflags) && defined(config_prove_locking)\n\n\nstatic int\nprint_irq_inversion_bug(struct task_struct *curr,\n\t\t\tstruct lock_list *root, struct lock_list *other,\n\t\t\tstruct held_lock *this, int forwards,\n\t\t\tconst char *irqclass)\n{\n\tstruct lock_list *entry = other;\n\tstruct lock_list *middle = null;\n\tint depth;\n\n\tif (!debug_locks_off_graph_unlock() || debug_locks_silent)\n\t\treturn 0;\n\n\tprintk(\"\\n\");\n\tprintk(\"=========================================================\\n\");\n\tprintk(\"[ info: possible irq lock inversion dependency detected ]\\n\");\n\tprint_kernel_ident();\n\tprintk(\"---------------------------------------------------------\\n\");\n\tprintk(\"%s/%d just changed the state of lock:\\n\",\n\t\tcurr->", "5306": "<< bit)))\n\t\treturn -1;\n\n\tval |= 1 << bit;\n\tcurrent->", "5307": "<< bit)))\n\t\treturn 1;\n\n\tval |= (1 << bit);\n\t__this_cpu_write(current_context, val);\n\n\treturn 0;\n}\n\nstatic __always_inline void trace_recursive_unlock(void)\n{\n\t__this_cpu_and(current_context, __this_cpu_read(current_context) - 1);\n}\n\n#else\n\n#define trace_recursive_lock()\t\t(0)\n#define trace_recursive_unlock()\tdo { } while (0)\n\n#endif\n\n\nstruct ring_buffer_event *\nring_buffer_lock_reserve(struct ring_buffer *buffer, unsigned long length)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tstruct ring_buffer_event *event;\n\tint cpu;\n\n\tif (ring_buffer_flags != rb_buffers_on)\n\t\treturn null;\n\n\t\n\tpreempt_disable_notrace();\n\n\tif (atomic_read(&buffer->", "5308": "<< bit;\n\tval &= ~bit;\n\n\tbarrier();\n\tcurrent->", "5309": "<< bit;\n}\n\nstatic char get_usage_char(struct lock_class *class, enum lock_usage_bit bit)\n{\n\tchar c = '.';\n\n\tif (class->", "5310": "<< blk_tc_shift) & what) == 0)\n\t\treturn 1;\n\tif (sector && (sector < bt->", "5311": "<< blk_tc_shift) - 1);\n\tlong_act   = !!(trace_flags & trace_iter_verbose);\n\tlog_action = classic ? &blk_log_action_classic : &blk_log_action;\n\n\tif (t->", "5312": "<< bm_block_shift) - 1)\n\n\nstruct rtree_node {\n\tstruct list_head list;\n\tunsigned long *data;\n};\n\n\nstruct mem_zone_bm_rtree {\n\tstruct list_head list;\t\t\n\tstruct list_head nodes;\t\t\n\tstruct list_head leaves;\t\n\tunsigned long start_pfn;\t\n\tunsigned long end_pfn;\t\t\n\tstruct rtree_node *rtree;\t\n\tint levels;\t\t\t\n\tunsigned int blocks;\t\t\n};\n\n\n\nstruct bm_position {\n\tstruct mem_zone_bm_rtree *zone;\n\tstruct rtree_node *node;\n\tunsigned long node_pfn;\n\tint node_bit;\n};\n\nstruct memory_bitmap {\n\tstruct list_head zones;\n\tstruct linked_page *p_list;\t\n\tstruct bm_position cur;\t\n};\n\n\n\n#define bm_entries_per_level\t(page_size / sizeof(unsigned long))\n#if bits_per_long == 32\n#define bm_rtree_level_shift\t(page_shift - 2)\n#else\n#define bm_rtree_level_shift\t(page_shift - 3)\n#endif\n#define bm_rtree_level_mask\t((1ul << bm_rtree_level_shift) - 1)\n\n\nstatic struct rtree_node *alloc_rtree_node(gfp_t gfp_mask, int safe_needed,\n\t\t\t\t\t   struct chain_allocator *ca,\n\t\t\t\t\t   struct list_head *list)\n{\n\tstruct rtree_node *node;\n\n\tnode = chain_alloc(ca, sizeof(struct rtree_node));\n\tif (!node)\n\t\treturn null;\n\n\tnode->", "5313": "<< cc->", "5314": "<< classhash_bits)\n#define __classhashfn(key)\thash_long((unsigned long)key, classhash_bits)\n#define classhashentry(key)\t(classhash_table + __classhashfn((key)))\n\nstatic struct list_head classhash_table[classhash_size];\n\n\n#define chainhash_bits\t\t(max_lockdep_chains_bits-1)\n#define chainhash_size\t\t(1ul << chainhash_bits)\n#define __chainhashfn(chain)\thash_long(chain, chainhash_bits)\n#define chainhashentry(chain)\t(chainhash_table + __chainhashfn((chain)))\n\nstatic struct list_head chainhash_table[chainhash_size];\n\n\n#define iterate_chain_key(key1, key2) \\\n\t(((key1) << max_lockdep_keys_bits) ^ \\\n\t((key1) >", "5315": "<< config_log_buf_shift)\nstatic char __log_buf[__log_buf_len] __aligned(log_align);\nstatic char *log_buf = __log_buf;\nstatic u32 log_buf_len = __log_buf_len;\n\n\nchar *log_buf_addr_get(void)\n{\n\treturn log_buf;\n}\n\n\nu32 log_buf_len_get(void)\n{\n\treturn log_buf_len;\n}\n\n\nstatic char *log_text(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log);\n}\n\n\nstatic char *log_dict(const struct printk_log *msg)\n{\n\treturn (char *)msg + sizeof(struct printk_log) + msg->", "5316": "<< cpu))\n\t\t\t\t\tdump_cpu_task(rnp->", "5317": "<< cpu)) {\n\t\t\t\t\tprint_cpu_stall_info(rsp,\n\t\t\t\t\t\t\t     rnp->", "5318": "<< cpuset_cgrp_id);\n#endif\n\n\tmemset(opts, 0, sizeof(*opts));\n\n\twhile ((token = strsep(&o, \",\")) != null) {\n\t\tnr_opts++;\n\n\t\tif (!*token)\n\t\t\treturn -einval;\n\t\tif (!strcmp(token, \"none\")) {\n\t\t\t\n\t\t\topts->", "5319": "<< cs_online) | (1 << cs_cpu_exclusive) |\n\t\t  (1 << cs_mem_exclusive)),\n};\n\n\n#define cpuset_for_each_child(child_cs, pos_css, parent_cs)\t\t\\\n\tcss_for_each_child((pos_css), &(parent_cs)->", "5320": "<< css->", "5321": "<< debug_shift;\n}\n\nu64 ring_buffer_time_stamp(struct ring_buffer *buffer, int cpu)\n{\n\tu64 time;\n\n\tpreempt_disable_notrace();\n\ttime = rb_time_stamp(buffer);\n\tpreempt_enable_no_resched_notrace();\n\n\treturn time;\n}\nexport_symbol_gpl(ring_buffer_time_stamp);\n\nvoid ring_buffer_normalize_time_stamp(struct ring_buffer *buffer,\n\t\t\t\t      int cpu, u64 *ts)\n{\n\t\n\t*ts >", "5322": "<< evt->", "5323": "<< ffz(thread_mask);\n\n\t} else if (new->", "5324": "<< flag);\n}\n\n\nvoid __module_put_and_exit(struct module *mod, long code)\n{\n\tmodule_put(mod);\n\tdo_exit(code);\n}\nexport_symbol(__module_put_and_exit);\n\n\nstatic unsigned int find_sec(const struct load_info *info, const char *name)\n{\n\tunsigned int i;\n\n\tfor (i = 1; i < info->", "5325": "<< frac_bits;\n\n\tif (n) for (;;) {\n\t\tif (n & 1) {\n\t\t\tresult *= x;\n\t\t\tresult += 1ul << (frac_bits - 1);\n\t\t\tresult >", "5326": "<< ftrace_hash_bits)\n#define ftrace_hash_default_bits 10\n#define ftrace_hash_max_bits 12\n\n#define fl_global_control_mask (ftrace_ops_fl_control)\n\n#ifdef config_dynamic_ftrace\n#define init_ops_hash(opsname)\t\\\n\t.func_hash\t\t= &opsname.local_hash,\t\t\t\\\n\t.local_hash.regex_lock\t= __mutex_initializer(opsname.local_hash.regex_lock),\n#define assign_ops_hash(opsname, val) \\\n\t.func_hash\t\t= val, \\\n\t.local_hash.regex_lock\t= __mutex_initializer(opsname.local_hash.regex_lock),\n#else\n#define init_ops_hash(opsname)\n#define assign_ops_hash(opsname, val)\n#endif\n\nstatic struct ftrace_ops ftrace_list_end __read_mostly = {\n\t.func\t\t= ftrace_stub,\n\t.flags\t\t= ftrace_ops_fl_recursion_safe | ftrace_ops_fl_stub,\n\tinit_ops_hash(ftrace_list_end)\n};\n\n\nint ftrace_enabled __read_mostly;\nstatic int last_ftrace_enabled;\n\n\nstruct ftrace_ops *function_trace_op __read_mostly = &ftrace_list_end;\n\nstatic struct ftrace_ops *set_function_trace_op;\n\n\nlist_head(ftrace_pids);\nstruct ftrace_pid {\n\tstruct list_head list;\n\tstruct pid *pid;\n};\n\n\nstatic int ftrace_disabled __read_mostly;\n\nstatic define_mutex(ftrace_lock);\n\nstatic struct ftrace_ops *ftrace_control_list __read_mostly = &ftrace_list_end;\nstatic struct ftrace_ops *ftrace_ops_list __read_mostly = &ftrace_list_end;\nftrace_func_t ftrace_trace_function __read_mostly = ftrace_stub;\nftrace_func_t ftrace_pid_function __read_mostly = ftrace_stub;\nstatic struct ftrace_ops global_ops;\nstatic struct ftrace_ops control_ops;\n\nstatic void ftrace_ops_recurs_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t   struct ftrace_ops *op, struct pt_regs *regs);\n\n#if arch_supports_ftrace_ops\nstatic void ftrace_ops_list_func(unsigned long ip, unsigned long parent_ip,\n\t\t\t\t struct ftrace_ops *op, struct pt_regs *regs);\n#else\n\nstatic void ftrace_ops_no_ops(unsigned long ip, unsigned long parent_ip);\n#define ftrace_ops_list_func ((ftrace_func_t)ftrace_ops_no_ops)\n#endif\n\n\n#define do_for_each_ftrace_op(op, list)\t\t\t\\\n\top = rcu_dereference_raw_notrace(list);\t\t\t\\\n\tdo\n\n\n#define while_for_each_ftrace_op(op)\t\t\t\t\\\n\twhile (likely(op = rcu_dereference_raw_notrace((op)->", "5327": "<< hash->", "5328": "<< i)) {\n\t\t\t\n\t\t\ttemplate[i] = cgroup_e_css(cgrp, ss);\n\t\t} else {\n\t\t\t\n\t\t\ttemplate[i] = old_cset->", "5329": "<< i)) ||\n\t\t    ss->", "5330": "<< i)))\n\t\t\tcontinue;\n\t\tlist_for_each_entry(cfts, &ss->", "5331": "<< i)))\n\t\t\tcontinue;\n\n\t\tlist_for_each_entry(cfts, &ss->", "5332": "<< i);\n\t\t\tone_ss = true;\n\n\t\t\tbreak;\n\t\t}\n\t\tif (i == cgroup_subsys_count)\n\t\t\treturn -enoent;\n\t}\n\n\tif (opts->", "5333": "<< i);\n\n\t\n\tif (!opts->", "5334": "<< i;\n\n\t\t\tdesc->", "5335": "<< idx;\n\n\tirq_set_chip_and_handler(virq, chip, ct->", "5336": "<< iocsize_shift;\n\t\t}\n\t\tbreak;\n\t}\n\treturn perf_ioctl(file, cmd, arg);\n}\n#else\n# define perf_compat_ioctl null\n#endif\n\nint perf_event_task_enable(void)\n{\n\tstruct perf_event_context *ctx;\n\tstruct perf_event *event;\n\n\tmutex_lock(&current->", "5337": "<< kdb_debug_flag_shift))\n#define kdb_debug_state(text, value) if (kdb_debug(state)) \\\n\t\tkdb_print_state(text, value)\n\n#if bits_per_long == 32\n\n#define kdb_platform_env\t\"bytesperword=4\"\n\n#define kdb_machreg_fmt\t\t\"0x%lx\"\n#define kdb_machreg_fmt0\t\"0x%08lx\"\n#define kdb_bfd_vma_fmt\t\t\"0x%lx\"\n#define kdb_bfd_vma_fmt0\t\"0x%08lx\"\n#define kdb_elfw_addr_fmt\t\"0x%x\"\n#define kdb_elfw_addr_fmt0\t\"0x%08x\"\n#define kdb_f_count_fmt\t\t\"%d\"\n\n#elif bits_per_long == 64\n\n#define kdb_platform_env\t\"bytesperword=8\"\n\n#define kdb_machreg_fmt\t\t\"0x%lx\"\n#define kdb_machreg_fmt0\t\"0x%016lx\"\n#define kdb_bfd_vma_fmt\t\t\"0x%lx\"\n#define kdb_bfd_vma_fmt0\t\"0x%016lx\"\n#define kdb_elfw_addr_fmt\t\"0x%x\"\n#define kdb_elfw_addr_fmt0\t\"0x%016x\"\n#define kdb_f_count_fmt\t\t\"%ld\"\n\n#endif\n\n\n#define kdb_maxbpt\t16\n\n\ntypedef struct __ksymtab {\n\t\tunsigned long value;\t\n\t\tconst char *mod_name;\t\n\t\tunsigned long mod_start;\n\t\tunsigned long mod_end;\n\t\tconst char *sec_name;\t\n\t\tunsigned long sec_start;\n\t\tunsigned long sec_end;\n\t\tconst char *sym_name;\t\n\t\tunsigned long sym_start;\n\t\tunsigned long sym_end;\n\t\t} kdb_symtab_t;\nextern int kallsyms_symbol_next(char *prefix_name, int flag);\nextern int kallsyms_symbol_complete(char *prefix_name, int max_len);\n\n\nextern int kdb_getarea_size(void *, unsigned long, size_t);\nextern int kdb_putarea_size(unsigned long, void *, size_t);\n\n\n#define kdb_getarea(x, addr) kdb_getarea_size(&(x), addr, sizeof((x)))\n#define kdb_putarea(addr, x) kdb_putarea_size(addr, &(x), sizeof((x)))\n\nextern int kdb_getphysword(unsigned long *word,\n\t\t\tunsigned long addr, size_t size);\nextern int kdb_getword(unsigned long *, unsigned long, size_t);\nextern int kdb_putword(unsigned long, unsigned long, size_t);\n\nextern int kdbgetularg(const char *, unsigned long *);\nextern int kdbgetu64arg(const char *, u64 *);\nextern char *kdbgetenv(const char *);\nextern int kdbgetaddrarg(int, const char **, int*, unsigned long *,\n\t\t\t long *, char **);\nextern int kdbgetsymval(const char *, kdb_symtab_t *);\nextern int kdbnearsym(unsigned long, kdb_symtab_t *);\nextern void kdbnearsym_cleanup(void);\nextern char *kdb_strdup(const char *str, gfp_t type);\nextern void kdb_symbol_print(unsigned long, const kdb_symtab_t *, unsigned int);\n\n\nextern void kdb_print_state(const char *, int);\n\nextern int kdb_state;\n#define kdb_state_kdb\t\t0x00000001\t\n#define kdb_state_leaving\t0x00000002\t\n#define kdb_state_cmd\t\t0x00000004\t\n#define kdb_state_kdb_control\t0x00000008\t\n#define kdb_state_hold_cpu\t0x00000010\t\n#define kdb_state_doing_ss\t0x00000020\t\n#define kdb_state_ssbpt\t\t0x00000080\t\n#define kdb_state_reentry\t0x00000100\t\n#define kdb_state_suppress\t0x00000200\t\n#define kdb_state_pager\t\t0x00000400\t\n#define kdb_state_go_switch\t0x00000800\t\n#define kdb_state_printf_lock\t0x00001000\t\n#define kdb_state_wait_ipi\t0x00002000\t\n#define kdb_state_recurse\t0x00004000\t\n#define kdb_state_ip_adjusted\t0x00008000\t\n#define kdb_state_go1\t\t0x00010000\t\n#define kdb_state_keyboard\t0x00020000\t\n#define kdb_state_kexec\t\t0x00040000\t\n#define kdb_state_doing_kgdb\t0x00080000\t\n#define kdb_state_kgdb_trans\t0x00200000\t\n#define kdb_state_arch\t\t0xff000000\t\n\n#define kdb_state(flag) (kdb_state & kdb_state_##flag)\n#define kdb_state_set(flag) ((void)(kdb_state |= kdb_state_##flag))\n#define kdb_state_clear(flag) ((void)(kdb_state &= ~kdb_state_##flag))\n\nextern int kdb_nextline; \n\ntypedef struct _kdb_bp {\n\tunsigned long\tbp_addr;\t\n\tunsigned int\tbp_free:1;\t\n\tunsigned int\tbp_enabled:1;\t\n\tunsigned int\tbp_type:4;\t\n\tunsigned int\tbp_installed:1;\t\n\tunsigned int\tbp_delay:1;\t\n\tunsigned int\tbp_delayed:1;\t\n\tunsigned int\tbph_length;\t\n} kdb_bp_t;\n\n#ifdef config_kgdb_kdb\nextern kdb_bp_t kdb_breakpoints[];\n\n\ntypedef struct _kdbtab {\n\tchar    *cmd_name;\t\t\n\tkdb_func_t cmd_func;\t\t\n\tchar    *cmd_usage;\t\t\n\tchar    *cmd_help;\t\t\n\tshort    cmd_minlen;\t\t\n\tkdb_cmdflags_t cmd_flags;\t\n} kdbtab_t;\n\nextern int kdb_bt(int, const char **);\t\n\n\nextern void kdb_initbptab(void);\nextern void kdb_bp_install(struct pt_regs *);\nextern void kdb_bp_remove(void);\n\ntypedef enum {\n\tkdb_db_bpt,\t\n\tkdb_db_ss,\t\n\tkdb_db_ssbpt,\t\n\tkdb_db_nobpt\t\n} kdb_dbtrap_t;\n\nextern int kdb_main_loop(kdb_reason_t, kdb_reason_t,\n\t\t\t int, kdb_dbtrap_t, struct pt_regs *);\n\n\nextern int kdb_grepping_flag;\n#define kdb_grepping_flag_search 0x8000\nextern char kdb_grep_string[];\n#define kdb_grep_strlen 256\nextern int kdb_grep_leading;\nextern int kdb_grep_trailing;\nextern char *kdb_cmds[];\nextern unsigned long kdb_task_state_string(const char *);\nextern char kdb_task_state_char (const struct task_struct *);\nextern unsigned long kdb_task_state(const struct task_struct *p,\n\t\t\t\t    unsigned long mask);\nextern void kdb_ps_suppressed(void);\nextern void kdb_ps1(const struct task_struct *p);\nextern void kdb_print_nameval(const char *name, unsigned long val);\nextern void kdb_send_sig_info(struct task_struct *p, struct siginfo *info);\nextern void kdb_meminfo_proc_show(void);\nextern char *kdb_getstr(char *, size_t, const char *);\nextern void kdb_gdb_state_pass(char *buf);\n\n\n#define kdb_sp_spaceb\t0x0001\t\t\n#define kdb_sp_spacea\t0x0002\t\t\n#define kdb_sp_paren\t0x0004\t\t\n#define kdb_sp_value\t0x0008\t\t\n#define kdb_sp_symsize\t0x0010\t\t\n#define kdb_sp_newline\t0x0020\t\t\n#define kdb_sp_default (kdb_sp_value|kdb_sp_paren)\n\n#define kdb_tsk(cpu) kgdb_info[cpu].task\n#define kdb_tskregs(cpu) kgdb_info[cpu].debuggerinfo\n\nextern struct task_struct *kdb_curr_task(int);\n\n#define kdb_task_has_cpu(p) (task_curr(p))\n\n\n#define\tkdb_do_each_thread(g, p) do_each_thread(g, p)\n#define\tkdb_while_each_thread(g, p) while_each_thread(g, p)\n\n#define gfp_kdb (in_interrupt() ? gfp_atomic : gfp_kernel)\n\nextern void *debug_kmalloc(size_t size, gfp_t flags);\nextern void debug_kfree(void *);\nextern void debug_kusage(void);\n\nextern void kdb_set_current_task(struct task_struct *);\nextern struct task_struct *kdb_current_task;\n\n#ifdef config_kdb_keyboard\nextern void kdb_kbd_cleanup_state(void);\n#else \n#define kdb_kbd_cleanup_state()\n#endif \n\n#ifdef config_modules\nextern struct list_head *kdb_modules;\n#endif \n\nextern char kdb_prompt_str[];\n\n#define\tkdb_word_size\t((int)sizeof(unsigned long))\n\n#endif \n#endif\t\n\n#include <linux/interrupt.h>", "5338": "<< kprobe_hash_bits)\n\n\n\n#ifndef kprobe_lookup_name\n#define kprobe_lookup_name(name, addr) \\\n\taddr = ((kprobe_opcode_t *)(kallsyms_lookup_name(name)))\n#endif\n\nstatic int kprobes_initialized;\nstatic struct hlist_head kprobe_table[kprobe_table_size];\nstatic struct hlist_head kretprobe_inst_table[kprobe_table_size];\n\n\nstatic bool kprobes_all_disarmed;\n\n\nstatic define_mutex(kprobe_mutex);\nstatic define_per_cpu(struct kprobe *, kprobe_instance) = null;\nstatic struct {\n\traw_spinlock_t lock ____cacheline_aligned_in_smp;\n} kretprobe_table_locks[kprobe_table_size];\n\nstatic raw_spinlock_t *kretprobe_table_lock_ptr(unsigned long hash)\n{\n\treturn &(kretprobe_table_locks[hash].lock);\n}\n\n\nstatic list_head(kprobe_blacklist);\n\n#ifdef __arch_want_kprobes_insn_slot\n\nstruct kprobe_insn_page {\n\tstruct list_head list;\n\tkprobe_opcode_t *insns;\t\t\n\tstruct kprobe_insn_cache *cache;\n\tint nused;\n\tint ngarbage;\n\tchar slot_used[];\n};\n\n#define kprobe_insn_page_size(slots)\t\t\t\\\n\t(offsetof(struct kprobe_insn_page, slot_used) +\t\\\n\t (sizeof(char) * (slots)))\n\nstatic int slots_per_page(struct kprobe_insn_cache *c)\n{\n\treturn page_size/(c->", "5339": "<< lock_##__state),\n\nenum {\n#define lockdep_state(__state)\t\t\t\t\t\t\\\n\t__lockf(used_in_##__state)\t\t\t\t\t\\\n\t__lockf(used_in_##__state##_read)\t\t\t\t\\\n\t__lockf(enabled_##__state)\t\t\t\t\t\\\n\t__lockf(enabled_##__state##_read)\n#include \"lockdep_states.h\"\n#undef lockdep_state\n\t__lockf(used)\n};\n\n#define lockf_enabled_irq (lockf_enabled_hardirq | lockf_enabled_softirq)\n#define lockf_used_in_irq (lockf_used_in_hardirq | lockf_used_in_softirq)\n\n#define lockf_enabled_irq_read \\\n\t\t(lockf_enabled_hardirq_read | lockf_enabled_softirq_read)\n#define lockf_used_in_irq_read \\\n\t\t(lockf_used_in_hardirq_read | lockf_used_in_softirq_read)\n\n\n#define max_lockdep_entries\t32768ul\n\n#define max_lockdep_chains_bits\t16\n#define max_lockdep_chains\t(1ul << max_lockdep_chains_bits)\n\n#define max_lockdep_chain_hlocks (max_lockdep_chains*5)\n\n\n#define max_stack_trace_entries\t524288ul\n\nextern struct list_head all_lock_classes;\nextern struct lock_chain lock_chains[];\n\n#define lock_usage_chars (1+lock_usage_states/2)\n\nextern void get_usage_chars(struct lock_class *class,\n\t\t\t    char usage[lock_usage_chars]);\n\nextern const char * __get_key_name(struct lockdep_subclass_key *key, char *str);\n\nstruct lock_class *lock_chain_get_class(struct lock_chain *chain, int i);\n\nextern unsigned long nr_lock_classes;\nextern unsigned long nr_list_entries;\nextern unsigned long nr_lock_chains;\nextern int nr_chain_hlocks;\nextern unsigned long nr_stack_trace_entries;\n\nextern unsigned int nr_hardirq_chains;\nextern unsigned int nr_softirq_chains;\nextern unsigned int nr_process_chains;\nextern unsigned int max_lockdep_depth;\nextern unsigned int max_recursion_depth;\n\nextern unsigned int max_bfs_queue_depth;\n\n#ifdef config_prove_locking\nextern unsigned long lockdep_count_forward_deps(struct lock_class *);\nextern unsigned long lockdep_count_backward_deps(struct lock_class *);\n#else\nstatic inline unsigned long\nlockdep_count_forward_deps(struct lock_class *class)\n{\n\treturn 0;\n}\nstatic inline unsigned long\nlockdep_count_backward_deps(struct lock_class *class)\n{\n\treturn 0;\n}\n#endif\n\n#ifdef config_debug_lockdep\n\n#include <asm/local.h>", "5340": "<< mantsize) - 1)\t\n\nstatic comp_t encode_comp_t(unsigned long value)\n{\n\tint exp, rnd;\n\n\texp = rnd = 0;\n\twhile (value >", "5341": "<< max_entries_bits)\n\nstatic unsigned long nr_entries;\nstatic struct entry entries[max_entries];\n\nstatic atomic_t overflow_count;\n\n\n#define tstat_hash_bits\t\t(max_entries_bits - 1)\n#define tstat_hash_size\t\t(1ul << tstat_hash_bits)\n#define tstat_hash_mask\t\t(tstat_hash_size - 1)\n\n#define __tstat_hashfn(entry)\t\t\t\t\t\t\\\n\t(((unsigned long)(entry)->", "5342": "<< mmf_dump_filter_shift) &\n\t\tmmf_dump_filter_mask;\n\treturn 1;\n}\n\n__setup(\"coredump_filter=\", coredump_filter_setup);\n\n#include <linux/init_task.h>", "5343": "<< new_bit, ret = 1;\n\n\t\n\tif (likely(hlock_class(this)->", "5344": "<< nice_0_shift,\n\t\t\t  sa->", "5345": "<< nmi_watchdog_enabled_bit)\n#define soft_watchdog_enabled     (1 << soft_watchdog_enabled_bit)\n\n#ifdef config_hardlockup_detector\nstatic unsigned long __read_mostly watchdog_enabled = soft_watchdog_enabled|nmi_watchdog_enabled;\n#else\nstatic unsigned long __read_mostly watchdog_enabled = soft_watchdog_enabled;\n#endif\nint __read_mostly nmi_watchdog_enabled;\nint __read_mostly soft_watchdog_enabled;\nint __read_mostly watchdog_user_enabled;\nint __read_mostly watchdog_thresh = 10;\n\n#ifdef config_smp\nint __read_mostly sysctl_softlockup_all_cpu_backtrace;\n#else\n#define sysctl_softlockup_all_cpu_backtrace 0\n#endif\n\nstatic int __read_mostly watchdog_running;\nstatic u64 __read_mostly sample_period;\n\nstatic define_per_cpu(unsigned long, watchdog_touch_ts);\nstatic define_per_cpu(struct task_struct *, softlockup_watchdog);\nstatic define_per_cpu(struct hrtimer, watchdog_hrtimer);\nstatic define_per_cpu(bool, softlockup_touch_sync);\nstatic define_per_cpu(bool, soft_watchdog_warn);\nstatic define_per_cpu(unsigned long, hrtimer_interrupts);\nstatic define_per_cpu(unsigned long, soft_lockup_hrtimer_cnt);\nstatic define_per_cpu(struct task_struct *, softlockup_task_ptr_saved);\n#ifdef config_hardlockup_detector\nstatic define_per_cpu(bool, hard_watchdog_warn);\nstatic define_per_cpu(bool, watchdog_nmi_touch);\nstatic define_per_cpu(unsigned long, hrtimer_interrupts_saved);\nstatic define_per_cpu(struct perf_event *, watchdog_ev);\n#endif\nstatic unsigned long soft_lockup_nmi_warn;\n\n\n\n#ifdef config_hardlockup_detector\nstatic int hardlockup_panic =\n\t\t\tconfig_bootparam_hardlockup_panic_value;\n\nvoid hardlockup_detector_disable(void)\n{\n\twatchdog_enabled &= ~nmi_watchdog_enabled;\n}\n\nstatic int __init hardlockup_panic_setup(char *str)\n{\n\tif (!strncmp(str, \"panic\", 5))\n\t\thardlockup_panic = 1;\n\telse if (!strncmp(str, \"nopanic\", 7))\n\t\thardlockup_panic = 0;\n\telse if (!strncmp(str, \"0\", 1))\n\t\twatchdog_enabled &= ~nmi_watchdog_enabled;\n\telse if (!strncmp(str, \"1\", 1))\n\t\twatchdog_enabled |= nmi_watchdog_enabled;\n\treturn 1;\n}\n__setup(\"nmi_watchdog=\", hardlockup_panic_setup);\n#endif\n\nunsigned int __read_mostly softlockup_panic =\n\t\t\tconfig_bootparam_softlockup_panic_value;\n\nstatic int __init softlockup_panic_setup(char *str)\n{\n\tsoftlockup_panic = simple_strtoul(str, null, 0);\n\n\treturn 1;\n}\n__setup(\"softlockup_panic=\", softlockup_panic_setup);\n\nstatic int __init nowatchdog_setup(char *str)\n{\n\twatchdog_enabled = 0;\n\treturn 1;\n}\n__setup(\"nowatchdog\", nowatchdog_setup);\n\nstatic int __init nosoftlockup_setup(char *str)\n{\n\twatchdog_enabled &= ~soft_watchdog_enabled;\n\treturn 1;\n}\n__setup(\"nosoftlockup\", nosoftlockup_setup);\n\n#ifdef config_smp\nstatic int __init softlockup_all_cpu_backtrace_setup(char *str)\n{\n\tsysctl_softlockup_all_cpu_backtrace =\n\t\t!!simple_strtol(str, null, 0);\n\treturn 1;\n}\n__setup(\"softlockup_all_cpu_backtrace=\", softlockup_all_cpu_backtrace_setup);\n#endif\n\n\nstatic int get_softlockup_thresh(void)\n{\n\treturn watchdog_thresh * 2;\n}\n\n\nstatic unsigned long get_timestamp(void)\n{\n\treturn running_clock() >", "5346": "<< nr);\n}\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}\n\n\nstruct tasklet_head {\n\tstruct tasklet_struct *head;\n\tstruct tasklet_struct **tail;\n};\n\nstatic define_per_cpu(struct tasklet_head, tasklet_vec);\nstatic define_per_cpu(struct tasklet_head, tasklet_hi_vec);\n\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tt->", "5347": "<< ntp_scale_shift) / ntp_interval_freq)\n\n\n\n\nstatic int\t\t\ttime_state = time_ok;\n\n\nstatic int\t\t\ttime_status = sta_unsync;\n\n\nstatic s64\t\t\ttime_offset;\n\n\nstatic long\t\t\ttime_constant = 2;\n\n\nstatic long\t\t\ttime_maxerror = ntp_phase_limit;\n\n\nstatic long\t\t\ttime_esterror = ntp_phase_limit;\n\n\nstatic s64\t\t\ttime_freq;\n\n\nstatic long\t\t\ttime_reftime;\n\nstatic long\t\t\ttime_adjust;\n\n\nstatic s64\t\t\tntp_tick_adj;\n\n#ifdef config_ntp_pps\n\n\n#define pps_valid\t10\t\n#define pps_popcorn\t4\t\n#define pps_intmin\t2\t\n#define pps_intmax\t8\t\n#define pps_intcount\t4\t\n#define pps_maxwander\t100000\t\n\nstatic int pps_valid;\t\t\nstatic long pps_tf[3];\t\t\nstatic long pps_jitter;\t\t\nstatic struct timespec pps_fbase; \nstatic int pps_shift;\t\t\nstatic int pps_intcnt;\t\t\nstatic s64 pps_freq;\t\t\nstatic long pps_stabil;\t\t\n\n\nstatic long pps_calcnt;\t\t\nstatic long pps_jitcnt;\t\t\nstatic long pps_stbcnt;\t\t\nstatic long pps_errcnt;\t\t\n\n\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & sta_ppstime && time_status & sta_ppssignal)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, shift_pll + time_constant);\n}\n\nstatic inline void pps_reset_freq_interval(void)\n{\n\t\n\tpps_shift = pps_intmin;\n\tpps_intcnt = 0;\n}\n\n\nstatic inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}\n\n\nstatic inline void pps_dec_valid(void)\n{\n\tif (pps_valid >", "5348": "<< ntp_scale_shift;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, hz) >", "5349": "<< order) / entry_size >", "5350": "<< order) / entry_size;\n\tpg->", "5351": "<< order) << page_shift;\n\thole_start = (image->", "5352": "<< order;\n\t\tfor (i = 0; i < count; i++)\n\t\t\tsetpagereserved(pages + i);\n\t}\n\n\treturn pages;\n}\n\nstatic void kimage_free_pages(struct page *page)\n{\n\tunsigned int order, count, i;\n\n\torder = page_private(page);\n\tcount = 1 << order;\n\tfor (i = 0; i < count; i++)\n\t\tclearpagereserved(page + i);\n\t__free_pages(page, order);\n}\n\nstatic void kimage_free_page_list(struct list_head *list)\n{\n\tstruct list_head *pos, *next;\n\n\tlist_for_each_safe(pos, next, list) {\n\t\tstruct page *page;\n\n\t\tpage = list_entry(pos, struct page, lru);\n\t\tlist_del(&page->", "5353": "<< order;\n\tinit_list_head(&extra_pages);\n\n\t\n\tdo {\n\t\tunsigned long pfn, epfn, addr, eaddr;\n\n\t\tpages = kimage_alloc_pages(kexec_control_memory_gfp, order);\n\t\tif (!pages)\n\t\t\tbreak;\n\t\tpfn   = page_to_pfn(pages);\n\t\tepfn  = pfn + count;\n\t\taddr  = pfn << page_shift;\n\t\teaddr = epfn << page_shift;\n\t\tif ((epfn >", "5354": "<< page_order(rb);\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (len && written == size);\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\treturn len;\t\t\t\t\t\t\t\\\n}\n\nstatic inline unsigned long\nmemcpy_common(void *dst, const void *src, unsigned long n)\n{\n\tmemcpy(dst, src, n);\n\treturn 0;\n}\n\ndefine_output_copy(__output_copy, memcpy_common)\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}\n\ndefine_output_copy(__output_skip, memcpy_skip)\n\n#ifndef arch_perf_out_copy_user\n#define arch_perf_out_copy_user arch_perf_out_copy_user\n\nstatic inline unsigned long\narch_perf_out_copy_user(void *dst, const void *src, unsigned long n)\n{\n\tunsigned long ret;\n\n\tpagefault_disable();\n\tret = __copy_from_user_inatomic(dst, src, n);\n\tpagefault_enable();\n\n\treturn ret;\n}\n#endif\n\ndefine_output_copy(__output_copy_user, arch_perf_out_copy_user)\n\n\nextern struct perf_callchain_entry *\nperf_callchain(struct perf_event *event, struct pt_regs *regs);\nextern int get_callchain_buffers(void);\nextern void put_callchain_buffers(void);\n\nstatic inline int get_recursion_context(int *recursion)\n{\n\tint rctx;\n\n\tif (in_nmi())\n\t\trctx = 3;\n\telse if (in_irq())\n\t\trctx = 2;\n\telse if (in_softirq())\n\t\trctx = 1;\n\telse\n\t\trctx = 0;\n\n\tif (recursion[rctx])\n\t\treturn -1;\n\n\trecursion[rctx]++;\n\tbarrier();\n\n\treturn rctx;\n}\n\nstatic inline void put_recursion_context(int *recursion, int rctx)\n{\n\tbarrier();\n\trecursion[rctx]--;\n}\n\n#ifdef config_have_perf_user_stack_dump\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn true;\n}\n\n#define perf_user_stack_pointer(regs) user_stack_pointer(regs)\n#else\nstatic inline bool arch_perf_have_user_stack_dump(void)\n{\n\treturn false;\n}\n\n#define perf_user_stack_pointer(regs) 0\n#endif \n\n#endif \n#include <linux/stat.h>", "5355": "<< page_order(rb);\n}\n\nstatic struct page *\n__perf_mmap_to_page(struct ring_buffer *rb, unsigned long pgoff)\n{\n\t\n\tif (pgoff >", "5356": "<< page_private(page));\n\t\t     last >", "5357": "<< page_shift)\n\t\t\t\t- 1);\n\n\t\tfor (pfn = region->", "5358": "<< page_shift)\n\t\t\tgoto aux_unlock;\n\n\t\t\n\t\tif (rb_has_aux(rb) && rb->", "5359": "<< page_shift) + (vaddr - vma->", "5360": "<< page_shift) - 1;\n\thandle->", "5361": "<< page_shift) - offset;\n\n\tif (unlikely(have_lost)) {\n\t\tstruct perf_sample_data sample_data;\n\n\t\tlost_event.header.size = sizeof(lost_event);\n\t\tlost_event.header.type = perf_record_lost;\n\t\tlost_event.header.misc = 0;\n\t\tlost_event.id          = event->", "5362": "<< page_shift), hpage_size);\n\t\t\tend = min(end, vma->", "5363": "<< page_shift);\n\tzero_buf_sz = page_size;\n\n\ttfm = crypto_alloc_shash(\"sha256\", 0, 0);\n\tif (is_err(tfm)) {\n\t\tret = ptr_err(tfm);\n\t\tgoto out;\n\t}\n\n\tdesc_size = crypto_shash_descsize(tfm) + sizeof(*desc);\n\tdesc = kzalloc(desc_size, gfp_kernel);\n\tif (!desc) {\n\t\tret = -enomem;\n\t\tgoto out_free_tfm;\n\t}\n\n\tsha_region_sz = kexec_segment_max * sizeof(struct kexec_sha_region);\n\tsha_regions = vzalloc(sha_region_sz);\n\tif (!sha_regions)\n\t\tgoto out_free_desc;\n\n\tdesc->", "5364": "<< page_shift);\n}\n\nstatic loff_t vaddr_to_offset(struct vm_area_struct *vma, unsigned long vaddr)\n{\n\treturn ((loff_t)vma->", "5365": "<< page_shift,\n\t\t\t ((unsigned long long) region->", "5366": "<< page_shift,\n\t\t((unsigned long long) end_pfn << page_shift) - 1);\n}\n\n\nstatic struct memory_bitmap *forbidden_pages_map;\n\n\nstatic struct memory_bitmap *free_pages_map;\n\n\n\nvoid swsusp_set_page_free(struct page *page)\n{\n\tif (free_pages_map)\n\t\tmemory_bm_set_bit(free_pages_map, page_to_pfn(page));\n}\n\nstatic int swsusp_page_is_free(struct page *page)\n{\n\treturn free_pages_map ?\n\t\tmemory_bm_test_bit(free_pages_map, page_to_pfn(page)) : 0;\n}\n\nvoid swsusp_unset_page_free(struct page *page)\n{\n\tif (free_pages_map)\n\t\tmemory_bm_clear_bit(free_pages_map, page_to_pfn(page));\n}\n\nstatic void swsusp_set_page_forbidden(struct page *page)\n{\n\tif (forbidden_pages_map)\n\t\tmemory_bm_set_bit(forbidden_pages_map, page_to_pfn(page));\n}\n\nint swsusp_page_is_forbidden(struct page *page)\n{\n\treturn forbidden_pages_map ?\n\t\tmemory_bm_test_bit(forbidden_pages_map, page_to_pfn(page)) : 0;\n}\n\nstatic void swsusp_unset_page_forbidden(struct page *page)\n{\n\tif (forbidden_pages_map)\n\t\tmemory_bm_clear_bit(forbidden_pages_map, page_to_pfn(page));\n}\n\n\n\nstatic void mark_nosave_pages(struct memory_bitmap *bm)\n{\n\tstruct nosave_region *region;\n\n\tif (list_empty(&nosave_regions))\n\t\treturn;\n\n\tlist_for_each_entry(region, &nosave_regions, list) {\n\t\tunsigned long pfn;\n\n\t\tpr_debug(\"pm: marking nosave pages: [mem %#010llx-%#010llx]\\n\",\n\t\t\t (unsigned long long) region->", "5367": "<< page_shift, end_pfn - begin_pfn);\n\t}\n}\n\nstatic void unset_module_core_ro_nx(struct module *mod)\n{\n\tset_page_attributes(mod->", "5368": "<< page_shift, end_pfn - begin_pfn);\n}\n\nstatic void set_section_ro_nx(void *base,\n\t\t\tunsigned long text_size,\n\t\t\tunsigned long ro_size,\n\t\t\tunsigned long total_size)\n{\n\t\n\tunsigned long begin_pfn;\n\tunsigned long end_pfn;\n\n\t\n\tif (ro_size >", "5369": "<< page_shift;\n\t\tif (addr == destination) {\n\t\t\tlist_del(&page->", "5370": "<< page_shift;\n\t\tif (uprobe->", "5371": "<< page_shift;\n\n\t\t\n\t\tif (addr == destination)\n\t\t\tbreak;\n\n\t\t\n\t\tif (!kimage_is_destination_range(image, addr,\n\t\t\t\t\t\t  addr + page_size))\n\t\t\tbreak;\n\n\t\t\n\t\told = kimage_dst_used(image, addr);\n\t\tif (old) {\n\t\t\t\n\t\t\tunsigned long old_addr;\n\t\t\tstruct page *old_page;\n\n\t\t\told_addr = *old & page_mask;\n\t\t\told_page = pfn_to_page(old_addr >", "5372": "<< page_shift;\n}\n\n#define define_output_copy(func_name, memcpy_func)\t\t\t\\\nstatic inline unsigned long\t\t\t\t\t\t\\\nfunc_name(struct perf_output_handle *handle,\t\t\t\t\\\n\t  const void *buf, unsigned long len)\t\t\t\t\\\n{\t\t\t\t\t\t\t\t\t\\\n\tunsigned long size, written;\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tsize    = min(handle->", "5373": "<< pidhash_shift;\n\n\tfor (i = 0; i < pidhash_size; i++)\n\t\tinit_hlist_head(&pid_hash[i]);\n}\n\nvoid __init pidmap_init(void)\n{\n\t\n\tbuild_bug_on(pid_max_limit >", "5374": "<< pps_popcorn)) {\n\t\tprintk_deferred(kern_warning\n\t\t\t\t\"hardpps: ppsjitter: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << pps_popcorn));\n\t\ttime_status |= sta_ppsjitter;\n\t\tpps_jitcnt++;\n\t} else if (time_status & sta_ppstime) {\n\t\t\n\t\ttime_offset = div_s64(((s64)correction) << ntp_scale_shift,\n\t\t\t\tntp_interval_freq);\n\t\t\n\t\ttime_adjust = 0;\n\t}\n\t\n\tpps_jitter += (jitter - pps_jitter) >", "5375": "<< pps_shift)) {\n\t\tpps_calcnt++;\n\t\t\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}\n#endif\t\n\nstatic int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtol(str, 0, (long *)&ntp_tick_adj);\n\n\tif (rc)\n\t\treturn rc;\n\tntp_tick_adj <<= ntp_scale_shift;\n\n\treturn 1;\n}\n\n__setup(\"ntp_tick_adj=\", ntp_tick_adj_setup);\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n}\n\n#include <linux/spinlock.h>", "5376": "<< pps_shift)) {\n\t\ttime_status |= sta_ppserror;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(kern_err\n\t\t\t\"hardpps: ppserror: interval too long - %ld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << ntp_scale_shift,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, ntp_scale_shift);\n\tpps_freq = ftemp;\n\tif (delta >", "5377": "<< prof_shift;\n\n\tprofile_flip_buffers();\n\tif (p >", "5378": "<< profile_grpshift)\n#define nr_profile_hit\t\t(page_size/sizeof(struct profile_hit))\n#define nr_profile_grp\t\t(nr_profile_hit/profile_grpsz)\n\nstatic atomic_t *prof_buffer;\nstatic unsigned long prof_len, prof_shift;\n\nint prof_on __read_mostly;\nexport_symbol_gpl(prof_on);\n\nstatic cpumask_var_t prof_cpu_mask;\n#ifdef config_smp\nstatic define_per_cpu(struct profile_hit *[2], cpu_profile_hits);\nstatic define_per_cpu(int, cpu_profile_flip);\nstatic define_mutex(profile_flip_mutex);\n#endif \n\nint profile_setup(char *str)\n{\n\tstatic const char schedstr[] = \"schedule\";\n\tstatic const char sleepstr[] = \"sleep\";\n\tstatic const char kvmstr[] = \"kvm\";\n\tint par;\n\n\tif (!strncmp(str, sleepstr, strlen(sleepstr))) {\n#ifdef config_schedstats\n\t\tprof_on = sleep_profiling;\n\t\tif (str[strlen(sleepstr)] == ',')\n\t\t\tstr += strlen(sleepstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel sleep profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n#else\n\t\tpr_warn(\"kernel sleep profiling requires config_schedstats\\n\");\n#endif \n\t} else if (!strncmp(str, schedstr, strlen(schedstr))) {\n\t\tprof_on = sched_profiling;\n\t\tif (str[strlen(schedstr)] == ',')\n\t\t\tstr += strlen(schedstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel schedule profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (!strncmp(str, kvmstr, strlen(kvmstr))) {\n\t\tprof_on = kvm_profiling;\n\t\tif (str[strlen(kvmstr)] == ',')\n\t\t\tstr += strlen(kvmstr) + 1;\n\t\tif (get_option(&str, &par))\n\t\t\tprof_shift = par;\n\t\tpr_info(\"kernel kvm profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t} else if (get_option(&str, &par)) {\n\t\tprof_shift = par;\n\t\tprof_on = cpu_profiling;\n\t\tpr_info(\"kernel profiling enabled (shift: %ld)\\n\",\n\t\t\tprof_shift);\n\t}\n\treturn 1;\n}\n__setup(\"profile=\", profile_setup);\n\n\nint __ref profile_init(void)\n{\n\tint buffer_bytes;\n\tif (!prof_on)\n\t\treturn 0;\n\n\t\n\tprof_len = (_etext - _stext) >", "5379": "<< profile_grpshift;\n\tsecondary = (~(pc << 1) & (nr_profile_grp - 1)) << profile_grpshift;\n\tcpu = get_cpu();\n\thits = per_cpu(cpu_profile_hits, cpu)[per_cpu(cpu_profile_flip, cpu)];\n\tif (!hits) {\n\t\tput_cpu();\n\t\treturn;\n\t}\n\t\n\tlocal_irq_save(flags);\n\tdo {\n\t\tfor (j = 0; j < profile_grpsz; ++j) {\n\t\t\tif (hits[i + j].pc == pc) {\n\t\t\t\thits[i + j].hits += nr_hits;\n\t\t\t\tgoto out;\n\t\t\t} else if (!hits[i + j].hits) {\n\t\t\t\thits[i + j].pc = pc;\n\t\t\t\thits[i + j].hits = nr_hits;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\ti = (i + secondary) & (nr_profile_hit - 1);\n\t} while (i != primary);\n\n\t\n\tatomic_add(nr_hits, &prof_buffer[pc]);\n\tfor (i = 0; i < nr_profile_hit; ++i) {\n\t\tatomic_add(hits[i].hits, &prof_buffer[hits[i].pc]);\n\t\thits[i].pc = hits[i].hits = 0;\n\t}\nout:\n\tlocal_irq_restore(flags);\n\tput_cpu();\n}\n\nstatic int profile_cpu_callback(struct notifier_block *info,\n\t\t\t\t\tunsigned long action, void *__cpu)\n{\n\tint node, cpu = (unsigned long)__cpu;\n\tstruct page *page;\n\n\tswitch (action) {\n\tcase cpu_up_prepare:\n\tcase cpu_up_prepare_frozen:\n\t\tnode = cpu_to_mem(cpu);\n\t\tper_cpu(cpu_profile_flip, cpu) = 0;\n\t\tif (!per_cpu(cpu_profile_hits, cpu)[1]) {\n\t\t\tpage = alloc_pages_exact_node(node,\n\t\t\t\t\tgfp_kernel | __gfp_zero,\n\t\t\t\t\t0);\n\t\t\tif (!page)\n\t\t\t\treturn notifier_from_errno(-enomem);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[1] = page_address(page);\n\t\t}\n\t\tif (!per_cpu(cpu_profile_hits, cpu)[0]) {\n\t\t\tpage = alloc_pages_exact_node(node,\n\t\t\t\t\tgfp_kernel | __gfp_zero,\n\t\t\t\t\t0);\n\t\t\tif (!page)\n\t\t\t\tgoto out_free;\n\t\t\tper_cpu(cpu_profile_hits, cpu)[0] = page_address(page);\n\t\t}\n\t\tbreak;\nout_free:\n\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[1]);\n\t\tper_cpu(cpu_profile_hits, cpu)[1] = null;\n\t\t__free_page(page);\n\t\treturn notifier_from_errno(-enomem);\n\tcase cpu_online:\n\tcase cpu_online_frozen:\n\t\tif (prof_cpu_mask != null)\n\t\t\tcpumask_set_cpu(cpu, prof_cpu_mask);\n\t\tbreak;\n\tcase cpu_up_canceled:\n\tcase cpu_up_canceled_frozen:\n\tcase cpu_dead:\n\tcase cpu_dead_frozen:\n\t\tif (prof_cpu_mask != null)\n\t\t\tcpumask_clear_cpu(cpu, prof_cpu_mask);\n\t\tif (per_cpu(cpu_profile_hits, cpu)[0]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[0]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[0] = null;\n\t\t\t__free_page(page);\n\t\t}\n\t\tif (per_cpu(cpu_profile_hits, cpu)[1]) {\n\t\t\tpage = virt_to_page(per_cpu(cpu_profile_hits, cpu)[1]);\n\t\t\tper_cpu(cpu_profile_hits, cpu)[1] = null;\n\t\t\t__free_page(page);\n\t\t}\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n#else \n#define profile_flip_buffers()\t\tdo { } while (0)\n#define profile_discard_flip_buffers()\tdo { } while (0)\n#define profile_cpu_callback\t\tnull\n\nstatic void do_profile_hits(int type, void *__pc, unsigned int nr_hits)\n{\n\tunsigned long pc;\n\tpc = ((unsigned long)__pc - (unsigned long)_stext) >", "5380": "<< pt_opt_flag_shift);\n\tflags |= (data << pt_opt_flag_shift);\n\tchild->", "5381": "<< pt_opt_flag_shift);\n\t} else {\n\t\tflags = pt_ptraced;\n\t}\n\n\taudit_ptrace(task);\n\n\tretval = -eperm;\n\tif (unlikely(task->", "5382": "<< rb_buffers_on_bit,\n\trb_buffers_disabled\t= 1 << rb_buffers_disabled_bit,\n};\n\nstatic unsigned long ring_buffer_flags __read_mostly = rb_buffers_on;\n\n\n#define rb_buffer_off\t\t(1 << 20)\n\n#define buf_page_hdr_size offsetof(struct buffer_data_page, data)\n\n\nvoid tracing_off_permanent(void)\n{\n\tset_bit(rb_buffers_disabled_bit, &ring_buffer_flags);\n}\n\n#define rb_evnt_hdr_size (offsetof(struct ring_buffer_event, array))\n#define rb_alignment\t\t4u\n#define rb_max_small_data\t(rb_alignment * ringbuf_type_data_type_len_max)\n#define rb_evnt_min_size\t8u\t\n\n#ifndef config_have_64bit_aligned_access\n# define rb_force_8byte_alignment\t0\n# define rb_arch_alignment\t\trb_alignment\n#else\n# define rb_force_8byte_alignment\t1\n# define rb_arch_alignment\t\t8u\n#endif\n\n#define rb_align_data\t\t__aligned(rb_arch_alignment)\n\n\n#define ringbuf_type_data 0 ... ringbuf_type_data_type_len_max\n\nenum {\n\trb_len_time_extend = 8,\n\trb_len_time_stamp = 16,\n};\n\n#define skip_time_extend(event) \\\n\t((struct ring_buffer_event *)((char *)event + rb_len_time_extend))\n\nstatic inline int rb_null_event(struct ring_buffer_event *event)\n{\n\treturn event->", "5383": "<< rnp->", "5384": "<< sched_load_resolution)\n# define scale_load_down(w)\t((w) >", "5385": "<< sched_load_shift)\n\n#define nice_0_load\t\tsched_load_scale\n#define nice_0_shift\t\tsched_load_shift\n\n\n#define dl_scale (10)\n\n\n\n\n#define runtime_inf\t((u64)~0ull)\n\nstatic inline int fair_policy(int policy)\n{\n\treturn policy == sched_normal || policy == sched_batch;\n}\n\nstatic inline int rt_policy(int policy)\n{\n\treturn policy == sched_fifo || policy == sched_rr;\n}\n\nstatic inline int dl_policy(int policy)\n{\n\treturn policy == sched_deadline;\n}\n\nstatic inline int task_has_rt_policy(struct task_struct *p)\n{\n\treturn rt_policy(p->", "5386": "<< shift | bit;\n\n\treturn &zone->", "5387": "<< shift;\n\t*clock_set |= accumulate_nsecs_to_secs(tk);\n\n\t\n\traw_nsecs = (u64)tk->", "5388": "<< shift;\n\tloads[1] = (avenrun[1] + offset) << shift;\n\tloads[2] = (avenrun[2] + offset) << shift;\n}\n\nlong calc_load_fold_active(struct rq *this_rq)\n{\n\tlong nr_active, delta = 0;\n\n\tnr_active = this_rq->", "5389": "<< shift;\n\traw_nsecs += tk->", "5390": "<< shift;\n\ttk->", "5391": "<< shift;\n\tu64 raw_nsecs;\n\n\t\n\tif (offset < interval)\n\t\treturn offset;\n\n\t\n\toffset -= interval;\n\ttk->", "5392": "<< size_bits;\n\thash->", "5393": "<< src->", "5394": "<< ss->", "5395": "<< ssid))\n\t\t\t\tnew_ss_mask |= ss->", "5396": "<< ssid))\n\t\t\t\tseq_printf(m, \"%s%s\", count++ ? \",\" : \"\", ss->", "5397": "<< ssid))\n\t\t\tcgroup_clear_dir(&ss->", "5398": "<< ssid))\n\t\t\tseq_printf(seq, \",%s\", ss->", "5399": "<< ssid)) {\n\t\t\t\t\tret = -ebusy;\n\t\t\t\t\tgoto out_unlock;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!enable && !disable) {\n\t\tret = 0;\n\t\tgoto out_unlock;\n\t}\n\n\t\n\tif (enable && cgroup_parent(cgrp) && !list_empty(&cgrp->", "5400": "<< ssid)) {\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\n\t\t\tif (!(cgrp_dfl_root.subsys_mask & (1 << ssid)) ||\n\t\t\t    (cgroup_parent(cgrp) &&\n\t\t\t     !(cgroup_parent(cgrp)->", "5401": "<< ssid)) {\n\t\t\tif (cgrp->", "5402": "<< ssid)) {\n\t\t\tif (printed)\n\t\t\t\tseq_putc(seq, ' ');\n\t\t\tseq_printf(seq, \"%s\", ss->", "5403": "<< ssid)) {\n\t\t\tret = create_css(cgrp, ss,\n\t\t\t\t\t parent->", "5404": "<< ssid)))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (css_next_child(null, cgroup_css(&ss->", "5405": "<< ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tdefine_wait(wait);\n\n\t\t\tif (!cgroup_css(child, ss))\n\t\t\t\tcontinue;\n\n\t\t\tcgroup_get(child);\n\t\t\tprepare_to_wait(&child->", "5406": "<< ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tif (css_enable & (1 << ssid))\n\t\t\t\tret = create_css(child, ss,\n\t\t\t\t\tcgrp->", "5407": "<< ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(child, ss);\n\n\t\t\tif (!css)\n\t\t\t\tcontinue;\n\n\t\t\tif (css_enable & (1 << ssid))\n\t\t\t\tkill_css(css);\n\t\t\telse\n\t\t\t\tcgroup_clear_dir(child, 1 << ssid);\n\t\t}\n\t}\n\tgoto out_unlock;\n}\n\nstatic int cgroup_populated_show(struct seq_file *seq, void *v)\n{\n\tseq_printf(seq, \"%d\\n\", (bool)seq_css(seq)->", "5408": "<< ssid))) {\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t\n\t\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\t\tif (child->", "5409": "<< ssid)))) {\n\t\t\t\tret = -enoent;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else if (disable & (1 << ssid)) {\n\t\t\tif (!(cgrp->", "5410": "<< ssid));\n\t\t\telse\n\t\t\t\tret = cgroup_populate_dir(child, 1 << ssid);\n\t\t\tif (ret)\n\t\t\t\tgoto err_undo_css;\n\t\t}\n\t}\n\n\t\n\tret = cgroup_update_dfl_csses(cgrp);\n\tif (ret)\n\t\tgoto err_undo_css;\n\n\t\n\tfor_each_subsys(ss, ssid) {\n\t\tif (!(disable & (1 << ssid)))\n\t\t\tcontinue;\n\n\t\tcgroup_for_each_live_child(child, cgrp) {\n\t\t\tstruct cgroup_subsys_state *css = cgroup_css(child, ss);\n\n\t\t\tif (css_disable & (1 << ssid)) {\n\t\t\t\tkill_css(css);\n\t\t\t} else {\n\t\t\t\tcgroup_clear_dir(child, 1 << ssid);\n\t\t\t\tif (ss->", "5411": "<< ssid));\n\t\t\tif (ret)\n\t\t\t\tgoto out_destroy;\n\t\t}\n\t}\n\n\t\n\tif (!cgroup_on_dfl(cgrp)) {\n\t\tcgrp->", "5412": "<< ssid);\n\t\tcgroup_refresh_child_subsys_mask(&src_root->", "5413": "<< ssid);\n\t\tsrc_root->", "5414": "<< ssid);\n\n\tfor_each_subsys(ss, ssid) {\n\t\tstruct cgroup_root *src_root;\n\t\tstruct cgroup_subsys_state *css;\n\t\tstruct css_set *cset;\n\n\t\tif (!(ss_mask & (1 << ssid)))\n\t\t\tcontinue;\n\n\t\tsrc_root = ss->", "5415": "<< ssid;\n\t\t\t\tdisable &= ~(1 << ssid);\n\t\t\t} else if (*tok == '-') {\n\t\t\t\tdisable |= 1 << ssid;\n\t\t\t\tenable &= ~(1 << ssid);\n\t\t\t} else {\n\t\t\t\treturn -einval;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tif (ssid == cgroup_subsys_count)\n\t\t\treturn -einval;\n\t}\n\n\tcgrp = cgroup_kn_lock_live(of->", "5416": "<< ssid;\n\t\t\tcgroup_refresh_child_subsys_mask(&dst_root->", "5417": "<< ssid;\n\t\tif (dst_root != &cgrp_dfl_root) {\n\t\t\tdst_root->", "5418": "<< taint_crap))\n\t\tbuf[l++] = 'c';\n\tif (mod->", "5419": "<< taint_forced_module))\n\t\tbuf[l++] = 'f';\n\tif (mod->", "5420": "<< taint_oot_module))\n\t\tbuf[l++] = 'o';\n\tif (mod->", "5421": "<< taint_proprietary_module))\n\t\tbuf[l++] = 'p';\n\tif (mod->", "5422": "<< taint_proprietary_module)), true);\n\tif (!sym)\n\t\tgoto unlock;\n\n\tif (!check_version(info->", "5423": "<< taint_unsigned_module))\n\t\tbuf[l++] = 'e';\n\t\n\treturn l;\n}\n\nstatic ssize_t show_initstate(struct module_attribute *mattr,\n\t\t\t      struct module_kobject *mk, char *buffer)\n{\n\tconst char *state = \"unknown\";\n\n\tswitch (mk->", "5424": "<< tk->", "5425": "<< trace_graph_print_fill_shift)\n\nextern enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags);\nextern void print_graph_headers_flags(struct seq_file *s, u32 flags);\nextern void\ntrace_print_graph_duration(unsigned long long duration, struct trace_seq *s);\nextern void graph_trace_open(struct trace_iterator *iter);\nextern void graph_trace_close(struct trace_iterator *iter);\nextern int __trace_graph_entry(struct trace_array *tr,\n\t\t\t       struct ftrace_graph_ent *trace,\n\t\t\t       unsigned long flags, int pc);\nextern void __trace_graph_return(struct trace_array *tr,\n\t\t\t\t struct ftrace_graph_ret *trace,\n\t\t\t\t unsigned long flags, int pc);\n\n\n#ifdef config_dynamic_ftrace\n\n#define ftrace_graph_max_funcs\t\t32\nextern int ftrace_graph_count;\nextern unsigned long ftrace_graph_funcs[ftrace_graph_max_funcs];\nextern int ftrace_graph_notrace_count;\nextern unsigned long ftrace_graph_notrace_funcs[ftrace_graph_max_funcs];\n\nstatic inline int ftrace_graph_addr(unsigned long addr)\n{\n\tint i;\n\n\tif (!ftrace_graph_count)\n\t\treturn 1;\n\n\tfor (i = 0; i < ftrace_graph_count; i++) {\n\t\tif (addr == ftrace_graph_funcs[i]) {\n\t\t\t\n\t\t\tif (in_irq())\n\t\t\t\ttrace_recursion_set(trace_irq_bit);\n\t\t\telse\n\t\t\t\ttrace_recursion_clear(trace_irq_bit);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\tint i;\n\n\tif (!ftrace_graph_notrace_count)\n\t\treturn 0;\n\n\tfor (i = 0; i < ftrace_graph_notrace_count; i++) {\n\t\tif (addr == ftrace_graph_notrace_funcs[i])\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n#else\nstatic inline int ftrace_graph_addr(unsigned long addr)\n{\n\treturn 1;\n}\n\nstatic inline int ftrace_graph_notrace_addr(unsigned long addr)\n{\n\treturn 0;\n}\n#endif \n#else \nstatic inline enum print_line_t\nprint_graph_function_flags(struct trace_iterator *iter, u32 flags)\n{\n\treturn trace_type_unhandled;\n}\n#endif \n\nextern struct list_head ftrace_pids;\n\n#ifdef config_function_tracer\nextern bool ftrace_filter_param __initdata;\nstatic inline int ftrace_trace_task(struct task_struct *task)\n{\n\tif (list_empty(&ftrace_pids))\n\t\treturn 1;\n\n\treturn test_tsk_trace_trace(task);\n}\nextern int ftrace_is_dead(void);\nint ftrace_create_function_files(struct trace_array *tr,\n\t\t\t\t struct dentry *parent);\nvoid ftrace_destroy_function_files(struct trace_array *tr);\nvoid ftrace_init_global_array_ops(struct trace_array *tr);\nvoid ftrace_init_array_ops(struct trace_array *tr, ftrace_func_t func);\nvoid ftrace_reset_array_ops(struct trace_array *tr);\nint using_ftrace_ops_list_func(void);\n#else\nstatic inline int ftrace_trace_task(struct task_struct *task)\n{\n\treturn 1;\n}\nstatic inline int ftrace_is_dead(void) { return 0; }\nstatic inline int\nftrace_create_function_files(struct trace_array *tr,\n\t\t\t     struct dentry *parent)\n{\n\treturn 0;\n}\nstatic inline void ftrace_destroy_function_files(struct trace_array *tr) { }\nstatic inline __init void\nftrace_init_global_array_ops(struct trace_array *tr) { }\nstatic inline void ftrace_reset_array_ops(struct trace_array *tr) { }\n\n#define ftrace_init_array_ops(tr, func) do { } while (0)\n#endif \n\n#if defined(config_function_tracer) && defined(config_dynamic_ftrace)\nvoid ftrace_create_filter_files(struct ftrace_ops *ops,\n\t\t\t\tstruct dentry *parent);\nvoid ftrace_destroy_filter_files(struct ftrace_ops *ops);\n#else\n\n#define ftrace_create_filter_files(ops, parent) do { } while (0)\n#define ftrace_destroy_filter_files(ops) do { } while (0)\n#endif \n\nint ftrace_event_is_function(struct ftrace_event_call *call);\n\n\nstruct trace_parser {\n\tbool\t\tcont;\n\tchar\t\t*buffer;\n\tunsigned\tidx;\n\tunsigned\tsize;\n};\n\nstatic inline bool trace_parser_loaded(struct trace_parser *parser)\n{\n\treturn (parser->", "5426": "<< trace_graph_print_fill_shift,\n\tflags_fill_start = 2 << trace_graph_print_fill_shift,\n\tflags_fill_end   = 3 << trace_graph_print_fill_shift,\n};\n\nstatic void\nprint_graph_duration(unsigned long long duration, struct trace_seq *s,\n\t\t     u32 flags);\n\n\nint\nftrace_push_return_trace(unsigned long ret, unsigned long func, int *depth,\n\t\t\t unsigned long frame_pointer)\n{\n\tunsigned long long calltime;\n\tint index;\n\n\tif (unlikely(ftrace_graph_is_dead()))\n\t\treturn -ebusy;\n\n\tif (!current->", "5427": "<< ts_shift) - 1)\n#define ts_delta_test\t(~ts_mask)\n\n\n#define rb_missed_events\t(1 << 31)\n\n#define rb_missed_stored\t(1 << 30)\n\nstruct buffer_data_page {\n\tu64\t\t time_stamp;\t\n\tlocal_t\t\t commit;\t\n\tunsigned char\t data[] rb_align_data;\t\n};\n\n\nstruct buffer_page {\n\tstruct list_head list;\t\t\n\tlocal_t\t\t write;\t\t\n\tunsigned\t read;\t\t\n\tlocal_t\t\t entries;\t\n\tunsigned long\t real_end;\t\n\tstruct buffer_data_page *page;\t\n};\n\n\n#define rb_write_mask\t\t0xfffff\n#define rb_write_intcnt\t\t(1 << 20)\n\nstatic void rb_init_page(struct buffer_data_page *bpage)\n{\n\tlocal_set(&bpage->", "5428": "<< tvn_bits)\n#define tvr_size (1 << tvr_bits)\n#define tvn_mask (tvn_size - 1)\n#define tvr_mask (tvr_size - 1)\n#define max_tval ((unsigned long)((1ull << (tvr_bits + 4*tvn_bits)) - 1))\n\nstruct tvec {\n\tstruct list_head vec[tvn_size];\n};\n\nstruct tvec_root {\n\tstruct list_head vec[tvr_size];\n};\n\nstruct tvec_base {\n\tspinlock_t lock;\n\tstruct timer_list *running_timer;\n\tunsigned long timer_jiffies;\n\tunsigned long next_timer;\n\tunsigned long active_timers;\n\tunsigned long all_timers;\n\tint cpu;\n\tstruct tvec_root tv1;\n\tstruct tvec tv2;\n\tstruct tvec tv3;\n\tstruct tvec tv4;\n\tstruct tvec tv5;\n} ____cacheline_aligned;\n\n\nstruct tvec_base boot_tvec_bases;\nexport_symbol(boot_tvec_bases);\n\nstatic define_per_cpu(struct tvec_base *, tvec_bases) = &boot_tvec_bases;\n\n\nstatic inline unsigned int tbase_get_deferrable(struct tvec_base *base)\n{\n\treturn ((unsigned int)(unsigned long)base & timer_deferrable);\n}\n\nstatic inline unsigned int tbase_get_irqsafe(struct tvec_base *base)\n{\n\treturn ((unsigned int)(unsigned long)base & timer_irqsafe);\n}\n\nstatic inline struct tvec_base *tbase_get_base(struct tvec_base *base)\n{\n\treturn ((struct tvec_base *)((unsigned long)base & ~timer_flag_mask));\n}\n\nstatic inline void\ntimer_set_base(struct timer_list *timer, struct tvec_base *new_base)\n{\n\tunsigned long flags = (unsigned long)timer->", "5429": "<< type) & info->", "5430": "<< uidhash_bits)\n#define uidhash_mask\t\t(uidhash_sz - 1)\n#define __uidhashfn(uid)\t(((uid >", "5431": "<< work_offq_pool_shift,\n\t\t      work_struct_pending);\n}\n\nstatic void set_work_pool_and_clear_pending(struct work_struct *work,\n\t\t\t\t\t    int pool_id)\n{\n\t\n\tsmp_wmb();\n\tset_work_data(work, (unsigned long)pool_id << work_offq_pool_shift, 0);\n}\n\nstatic void clear_work_data(struct work_struct *work)\n{\n\tsmp_wmb();\t\n\tset_work_data(work, work_struct_no_pool, 0);\n}\n\nstatic struct pool_workqueue *get_work_pwq(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->", "5432": "<< work_struct_color_bits) - 1);\n}\n\nstatic int work_next_color(int color)\n{\n\treturn (color + 1) % work_nr_colors;\n}\n\n\nstatic inline void set_work_data(struct work_struct *work, unsigned long data,\n\t\t\t\t unsigned long flags)\n{\n\twarn_on_once(!work_pending(work));\n\tatomic_long_set(&work->", "5433": "<< work_struct_color_shift;\n}\n\nstatic int get_work_color(struct work_struct *work)\n{\n\treturn (*work_data_bits(work) >", "5434": "<< work_struct_flag_bits);\n\n\nstruct wq_flusher {\n\tstruct list_head\tlist;\t\t\n\tint\t\t\tflush_color;\t\n\tstruct completion\tdone;\t\t\n};\n\nstruct wq_device;\n\n\nstruct workqueue_struct {\n\tstruct list_head\tpwqs;\t\t\n\tstruct list_head\tlist;\t\t\n\n\tstruct mutex\t\tmutex;\t\t\n\tint\t\t\twork_color;\t\n\tint\t\t\tflush_color;\t\n\tatomic_t\t\tnr_pwqs_to_flush; \n\tstruct wq_flusher\t*first_flusher;\t\n\tstruct list_head\tflusher_queue;\t\n\tstruct list_head\tflusher_overflow; \n\n\tstruct list_head\tmaydays;\t\n\tstruct worker\t\t*rescuer;\t\n\n\tint\t\t\tnr_drainers;\t\n\tint\t\t\tsaved_max_active; \n\n\tstruct workqueue_attrs\t*unbound_attrs;\t\n\tstruct pool_workqueue\t*dfl_pwq;\t\n\n#ifdef config_sysfs\n\tstruct wq_device\t*wq_dev;\t\n#endif\n#ifdef config_lockdep\n\tstruct lockdep_map\tlockdep_map;\n#endif\n\tchar\t\t\tname[wq_name_len]; \n\n\t\n\tstruct rcu_head\t\trcu;\n\n\t\n\tunsigned int\t\tflags ____cacheline_aligned; \n\tstruct pool_workqueue __percpu *cpu_pwqs; \n\tstruct pool_workqueue __rcu *numa_pwq_tbl[]; \n};\n\nstatic struct kmem_cache *pwq_cache;\n\nstatic cpumask_var_t *wq_numa_possible_cpumask;\n\t\t\t\t\t\n\nstatic bool wq_disable_numa;\nmodule_param_named(disable_numa, wq_disable_numa, bool, 0444);\n\n\n#ifdef config_wq_power_efficient_default\nstatic bool wq_power_efficient = true;\n#else\nstatic bool wq_power_efficient;\n#endif\n\nmodule_param_named(power_efficient, wq_power_efficient, bool, 0444);\n\nstatic bool wq_numa_enabled;\t\t\n\n\nstatic struct workqueue_attrs *wq_update_unbound_numa_attrs_buf;\n\nstatic define_mutex(wq_pool_mutex);\t\nstatic define_spinlock(wq_mayday_lock);\t\n\nstatic list_head(workqueues);\t\t\nstatic bool workqueue_freezing;\t\t\n\n\nstatic define_per_cpu_shared_aligned(struct worker_pool [nr_std_worker_pools],\n\t\t\t\t     cpu_worker_pools);\n\nstatic define_idr(worker_pool_idr);\t\n\n\nstatic define_hashtable(unbound_pool_hash, unbound_pool_hash_order);\n\n\nstatic struct workqueue_attrs *unbound_std_wq_attrs[nr_std_worker_pools];\n\n\nstatic struct workqueue_attrs *ordered_wq_attrs[nr_std_worker_pools];\n\nstruct workqueue_struct *system_wq __read_mostly;\nexport_symbol(system_wq);\nstruct workqueue_struct *system_highpri_wq __read_mostly;\nexport_symbol_gpl(system_highpri_wq);\nstruct workqueue_struct *system_long_wq __read_mostly;\nexport_symbol_gpl(system_long_wq);\nstruct workqueue_struct *system_unbound_wq __read_mostly;\nexport_symbol_gpl(system_unbound_wq);\nstruct workqueue_struct *system_freezable_wq __read_mostly;\nexport_symbol_gpl(system_freezable_wq);\nstruct workqueue_struct *system_power_efficient_wq __read_mostly;\nexport_symbol_gpl(system_power_efficient_wq);\nstruct workqueue_struct *system_freezable_power_efficient_wq __read_mostly;\nexport_symbol_gpl(system_freezable_power_efficient_wq);\n\nstatic int worker_thread(void *__worker);\nstatic void copy_workqueue_attrs(struct workqueue_attrs *to,\n\t\t\t\t const struct workqueue_attrs *from);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\n#define create_trace_points\n#include <trace/events/workqueue.h>", "5435": "<<(bit)))\n\n#define trace_context_bits\t4\n\n#define trace_ftrace_start\ttrace_ftrace_bit\n#define trace_ftrace_max\t((1 << (trace_ftrace_start + trace_context_bits)) - 1)\n\n#define trace_list_start\ttrace_internal_bit\n#define trace_list_max\t\t((1 << (trace_list_start + trace_context_bits)) - 1)\n\n#define trace_context_mask\ttrace_list_max\n\nstatic __always_inline int trace_get_context_bit(void)\n{\n\tint bit;\n\n\tif (in_interrupt()) {\n\t\tif (in_nmi())\n\t\t\tbit = 0;\n\n\t\telse if (in_irq())\n\t\t\tbit = 1;\n\t\telse\n\t\t\tbit = 2;\n\t} else\n\t\tbit = 3;\n\n\treturn bit;\n}\n\nstatic __always_inline int trace_test_and_set_recursion(int start, int max)\n{\n\tunsigned int val = current->", "5436": "<<(bit)); } while (0)\n#define trace_recursion_clear(bit)\tdo { (current)->", "5437": "<<(bit)); } while (0)\n#define trace_recursion_test(bit)\t((current)->", "5438": "<<)\n\talu(rsh, >", "5439": "<<1;\n\tif (new_len >", "5440": "<<31)) {\n\t\t\tlist_del_init(p);\n\t\t\tlist_add(p, &tree->", "5441": "<<31)))\n\t\t\tbreak;\n\n\t\tuntag_chunk(node);\n\t}\n\tif (!tree->", "5442": "<<31);\n\t\t\tspin_unlock(&hash_lock);\n\t\t} else {\n\t\t\ttrim_marked(tree);\n\t\t}\n\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&barrier);\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n\tpath_put(&path1);\n\tdrop_collected_mounts(tagged);\n\treturn failed;\n}\n\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}\n\n\nvoid audit_kill_trees(struct list_head *list)\n{\n\tmutex_lock(&audit_cmd_mutex);\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->", "5443": "<<31);\n\t\tspin_unlock(&hash_lock);\n\t} else {\n\t\ttrim_marked(tree);\n\t\tgoto err;\n\t}\n\n\tmutex_lock(&audit_filter_mutex);\n\tif (list_empty(&rule->", "5444": "<<31);\n\t\t}\n\t\tspin_unlock(&hash_lock);\n\t\ttrim_marked(tree);\n\t\tdrop_collected_mounts(root_mnt);\nskip_it:\n\t\tput_tree(tree);\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\tlist_del(&cursor);\n\tmutex_unlock(&audit_filter_mutex);\n}\n\nint audit_make_tree(struct audit_krule *rule, char *pathname, u32 op)\n{\n\n\tif (pathname[0] != '/' ||\n\t    rule->", "5445": "<<31);\n\tp -= index;\n\treturn container_of(p, struct audit_chunk, owners[0]);\n}\n\nstatic void untag_chunk(struct node *p)\n{\n\tstruct audit_chunk *chunk = find_chunk(p);\n\tstruct fsnotify_mark *entry = &chunk->", "5446": "<<31);\n\tp->", "5447": "<<31;\n\t\t\tif (iterate_mounts(compare_root, inode, root_mnt))\n\t\t\t\tnode->", "5448": "<<= 1) {\n\t\t\tif ((rnp->", "5449": "<<= 1;\n\t\texp--;\n\t}\n\tu = (u32)(value >", "5450": "<<= 1;\n\t\tif (mem_total < sav_total)\n\t\t\tgoto out;\n\t}\n\n\t\n\n\tinfo->", "5451": "<<= 1;\n\t\trtime >", "5452": "<<= 1;\n\n\t\n\n\tfor (i = rcu_num_lvls - 1; i >", "5453": "<<= 1; \n\n\tswitch_count = &prev->", "5454": "<<= 20 - page_shift; \n\tif (!pages)\n\t\treturn;\n\n\tdown_read(&mm->", "5455": "<<= adj_scale;\n\tinterval <<= adj_scale;\n\toffset <<= adj_scale;\n\n\t\n\tif ((mult_adj >", "5456": "<<= bitcount;\n\tinfo->", "5457": "<<= bitcount;\n\nout:\n\treturn 0;\n}\n\nsyscall_define1(sysinfo, struct sysinfo __user *, info)\n{\n\tstruct sysinfo val;\n\n\tdo_sysinfo(&val);\n\n\tif (copy_to_user(info, &val, sizeof(struct sysinfo)))\n\t\treturn -efault;\n\n\treturn 0;\n}\n\n#ifdef config_compat\nstruct compat_sysinfo {\n\ts32 uptime;\n\tu32 loads[3];\n\tu32 totalram;\n\tu32 freeram;\n\tu32 sharedram;\n\tu32 bufferram;\n\tu32 totalswap;\n\tu32 freeswap;\n\tu16 procs;\n\tu16 pad;\n\tu32 totalhigh;\n\tu32 freehigh;\n\tu32 mem_unit;\n\tchar _f[20-2*sizeof(u32)-sizeof(int)];\n};\n\ncompat_syscall_define1(sysinfo, struct compat_sysinfo __user *, info)\n{\n\tstruct sysinfo s;\n\n\tdo_sysinfo(&s);\n\n\t\n\tif (upper_32_bits(s.totalram) || upper_32_bits(s.totalswap)) {\n\t\tint bitcount = 0;\n\n\t\twhile (s.mem_unit < page_size) {\n\t\t\ts.mem_unit <<= 1;\n\t\t\tbitcount++;\n\t\t}\n\n\t\ts.totalram >", "5458": "<<= bprm->", "5459": "<<= clock->", "5460": "<<= mantsize;\t\t\n\texp += value;\t\t\t\n\treturn exp;\n}\n\n#if acct_version == 1 || acct_version == 2\n\n\n#define mantsize2       20                      \n#define expsize2        5                       \n#define maxfract2       ((1ul << mantsize2) - 1) \n#define maxexp2         ((1 << expsize2) - 1)    \n\nstatic comp2_t encode_comp2_t(u64 value)\n{\n\tint exp, rnd;\n\n\texp = (value >", "5461": "<<= page_shift;\n\t\t\terror = put_user(offset, (loff_t __user *)arg);\n\t\t} else {\n\t\t\terror = -enospc;\n\t\t}\n\t\tbreak;\n\n\tcase snapshot_free_swap_pages:\n\t\tif (data->", "5462": "<<= page_shift;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase snapshot_alloc_swap_page:\n\t\tif (data->", "5463": "<<= page_shift;\n\t\terror = put_user(size, (loff_t __user *)arg);\n\t\tbreak;\n\n\tcase snapshot_avail_swap_size:\n\t\tsize = count_swap_pages(data->", "5464": "<<= page_shift;\n\treturn init_header_complete(info);\n}\n\n\n\nstatic inline void\npack_pfns(unsigned long *buf, struct memory_bitmap *bm)\n{\n\tint j;\n\n\tfor (j = 0; j < page_size / sizeof(long); j++) {\n\t\tbuf[j] = memory_bm_next_pfn(bm);\n\t\tif (unlikely(buf[j] == bm_end_of_map))\n\t\t\tbreak;\n\t\t\n\t\tpage_key_read(buf + j);\n\t}\n}\n\n\n\nint snapshot_read_next(struct snapshot_handle *handle)\n{\n\tif (handle->", "5465": "<<= shift_change;\n\t}\n\ttk->", "5466": "<<= ts_shift;\n\t\t\tdelta += event->", "5467": "<<= ts_shift;\n\t\tdelta += event->", "5468": "<<= work_offq_pool_shift;\n\tset_work_data(work, pool_id | work_offq_canceling, work_struct_pending);\n}\n\nstatic bool work_is_canceling(struct work_struct *work)\n{\n\tunsigned long data = atomic_long_read(&work->", "5469": "<<shift)\n\t\t\tshift--;\n\t}\n\n\t\n\ttimekeeping_adjust(tk, offset);\n\n\t\n\told_vsyscall_fixup(tk);\n\n\t\n\tclock_set |= accumulate_nsecs_to_secs(tk);\n\n\twrite_seqcount_begin(&tk_core.seq);\n\t\n\tmemcpy(real_tk, tk, sizeof(*tk));\n\ttimekeeping_update(real_tk, clock_set);\n\twrite_seqcount_end(&tk_core.seq);\nout:\n\traw_spin_unlock_irqrestore(&timekeeper_lock, flags);\n\tif (clock_set)\n\t\t\n\t\tclock_was_set_delayed();\n}\n\n\nvoid getboottime64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tktime_t t = ktime_sub(tk->", "5470": "<=\n\t\t\t\tenv->", "5471": "<=\n\t\t\ttask_rlimit(t, rlimit_sigpending)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == null)) {\n\t\tatomic_dec(&user->", "5472": "<=\n\t\t     extent->", "5473": "<= (*pos - iter->", "5474": "<= (1ull << evt->", "5475": "<= (busiest->", "5476": "<= (irq_handled | irq_wake_thread)))\n\t\treturn 0;\n\treturn 1;\n}\n\n\nstatic void\n__report_bad_irq(unsigned int irq, struct irq_desc *desc,\n\t\t irqreturn_t action_ret)\n{\n\tstruct irqaction *action;\n\tunsigned long flags;\n\n\tif (bad_action_ret(action_ret)) {\n\t\tprintk(kern_err \"irq event %d: bogus return value %x\\n\",\n\t\t\t\tirq, action_ret);\n\t} else {\n\t\tprintk(kern_err \"irq %d: nobody cared (try booting with \"\n\t\t\t\t\"the \\\"irqpoll\\\" option)\\n\", irq);\n\t}\n\tdump_stack();\n\tprintk(kern_err \"handlers:\\n\");\n\n\t\n\traw_spin_lock_irqsave(&desc->", "5477": "<= (unsigned long)_einittext)\n\t\treturn 1;\n\treturn 0;\n}\n\nstatic inline int is_kernel_text(unsigned long addr)\n{\n\tif ((addr >", "5478": "<= (unsigned long)_end)\n\t\treturn 1;\n\treturn in_gate_area_no_mm(addr);\n}\n\nstatic int is_ksym_addr(unsigned long addr)\n{\n\tif (all_var)\n\t\treturn is_kernel(addr);\n\n\treturn is_kernel_text(addr) || is_kernel_inittext(addr);\n}\n\n\nstatic unsigned int kallsyms_expand_symbol(unsigned int off,\n\t\t\t\t\t   char *result, size_t maxlen)\n{\n\tint len, skipped_first = 0;\n\tconst u8 *tptr, *data;\n\n\t\n\tdata = &kallsyms_names[off];\n\tlen = *data;\n\tdata++;\n\n\t\n\toff += len + 1;\n\n\t\n\twhile (len) {\n\t\ttptr = &kallsyms_token_table[kallsyms_token_index[*data]];\n\t\tdata++;\n\t\tlen--;\n\n\t\twhile (*tptr) {\n\t\t\tif (skipped_first) {\n\t\t\t\tif (maxlen <= 1)\n\t\t\t\t\tgoto tail;\n\t\t\t\t*result = *tptr;\n\t\t\t\tresult++;\n\t\t\t\tmaxlen--;\n\t\t\t} else\n\t\t\t\tskipped_first = 1;\n\t\t\ttptr++;\n\t\t}\n\t}\n\ntail:\n\tif (maxlen)\n\t\t*result = '\\0';\n\n\t\n\treturn off;\n}\n\n\nstatic char kallsyms_get_symbol_type(unsigned int off)\n{\n\t\n\treturn kallsyms_token_table[kallsyms_token_index[kallsyms_names[off + 1]]];\n}\n\n\n\nstatic unsigned int get_symbol_offset(unsigned long pos)\n{\n\tconst u8 *name;\n\tint i;\n\n\t\n\tname = &kallsyms_names[kallsyms_markers[pos >", "5479": "<= (unsigned long)_etext) ||\n\t    arch_is_kernel_text(addr))\n\t\treturn 1;\n\treturn in_gate_area_no_mm(addr);\n}\n\nstatic inline int is_kernel(unsigned long addr)\n{\n\tif (addr >", "5480": "<= (unsigned long)end &&\n\t\tentry->", "5481": "<= *pos; ) {\n\t\tfile = s_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}\n\nstatic int t_show(struct seq_file *m, void *v)\n{\n\tstruct ftrace_event_file *file = v;\n\tstruct ftrace_event_call *call = file->", "5482": "<= *pos; ) {\n\t\tfile = t_next(m, file, &l);\n\t\tif (!file)\n\t\t\tbreak;\n\t}\n\treturn file;\n}\n\nstatic void *\ns_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ftrace_event_file *file = v;\n\tstruct trace_array *tr = m->", "5483": "<= *pos; ) {\n\t\tp = t_next(m, p, &l);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tif (!p)\n\t\treturn t_hash_start(m, pos);\n\n\treturn iter;\n}\n\nstatic void t_stop(struct seq_file *m, void *p)\n{\n\tmutex_unlock(&ftrace_lock);\n}\n\nvoid * __weak\narch_ftrace_trampoline_func(struct ftrace_ops *ops, struct dyn_ftrace *rec)\n{\n\treturn null;\n}\n\nstatic void add_trampoline_func(struct seq_file *m, struct ftrace_ops *ops,\n\t\t\t\tstruct dyn_ftrace *rec)\n{\n\tvoid *ptr;\n\n\tptr = arch_ftrace_trampoline_func(ops, rec);\n\tif (ptr)\n\t\tseq_printf(m, \" ->", "5484": "<= -erestartsys) &&\n\t    (return_code >", "5485": "<= 0 ?\n\t\t\trr_timeslice : msecs_to_jiffies(sched_rr_timeslice);\n\t}\n\tmutex_unlock(&mutex);\n\treturn ret;\n}\n\n#ifdef config_cgroup_sched\n\nstatic inline struct task_group *css_tg(struct cgroup_subsys_state *css)\n{\n\treturn css ? container_of(css, struct task_group, css) : null;\n}\n\nstatic struct cgroup_subsys_state *\ncpu_cgroup_css_alloc(struct cgroup_subsys_state *parent_css)\n{\n\tstruct task_group *parent = css_tg(parent_css);\n\tstruct task_group *tg;\n\n\tif (!parent) {\n\t\t\n\t\treturn &root_task_group.css;\n\t}\n\n\ttg = sched_create_group(parent);\n\tif (is_err(tg))\n\t\treturn err_ptr(-enomem);\n\n\treturn &tg->", "5486": "<= 0 || (*prog)->", "5487": "<= 0 || nargs >", "5488": "<= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, false);\n\t\t\t\n\t\t\tif (unlikely(error == -esrch))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}\n\nstatic int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct siginfo info = {};\n\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = si_tkill;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}\n\n\nsyscall_define3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -einval;\n\n\treturn do_tkill(tgid, pid, sig);\n}\n\n\nsyscall_define2(tkill, pid_t, pid, int, sig)\n{\n\t\n\tif (pid <= 0)\n\t\treturn -einval;\n\n\treturn do_tkill(0, pid, sig);\n}\n\nstatic int do_rt_sigqueueinfo(pid_t pid, int sig, siginfo_t *info)\n{\n\t\n\tif ((info->", "5489": "<= 0 || tgid <= 0)\n\t\treturn -einval;\n\n\t\n\tif ((info->", "5490": "<= 0)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tinit_list_head(&cpu_buffer->", "5491": "<= 0)\n\t\t\t\tgoto out;\n\n\t\t\tcond_resched();\n\t\t} while (end != vma->", "5492": "<= 0)\n\t\t\tbreak;\n\t\tp += len;\n\t}\n\tkfree(buf);\n}\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, gfp_kernel, context->", "5493": "<= 0)\n\t\t\tbreak;\n\t\tret = swap_read_page(handle, data_of(*snapshot), &bio);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (snapshot->", "5494": "<= 0)\n\t\t\tbreak;\n\t\tret = swap_write_page(handle, data_of(*snapshot), &bio);\n\t\tif (ret)\n\t\t\tbreak;\n\t\tif (!(nr_pages % m))\n\t\t\tprintk(kern_info \"pm: image saving progress: %3d%%\\n\",\n\t\t\t       nr_pages / m * 10);\n\t\tnr_pages++;\n\t}\n\terr2 = hib_wait_on_bio_chain(&bio);\n\tstop = ktime_get();\n\tif (!ret)\n\t\tret = err2;\n\tif (!ret)\n\t\tprintk(kern_info \"pm: image saving done.\\n\");\n\tswsusp_show_speed(start, stop, nr_to_write, \"wrote\");\n\treturn ret;\n}\n\n\nstruct crc_data {\n\tstruct task_struct *thr;                  \n\tatomic_t ready;                           \n\tatomic_t stop;                            \n\tunsigned run_threads;                     \n\twait_queue_head_t go;                     \n\twait_queue_head_t done;                   \n\tu32 *crc32;                               \n\tsize_t *unc_len[lzo_threads];             \n\tunsigned char *unc[lzo_threads];          \n};\n\n\nstatic int crc32_threadfn(void *data)\n{\n\tstruct crc_data *d = data;\n\tunsigned i;\n\n\twhile (1) {\n\t\twait_event(d->", "5495": "<= 0)\n\t\t\tbreak;\n\t\tsleep_jf = div_round_up(sleep_jf * 11, 10);\n\t}\nupdate_state:\n\toldstate = atomic_read(&per_cpu(cpu_hotplug_state, cpu));\n\tif (oldstate == cpu_dead) {\n\t\t\n\t\tsmp_mb(); \n\t\tatomic_set(&per_cpu(cpu_hotplug_state, cpu), cpu_post_dead);\n\t} else {\n\t\t\n\t\tif (atomic_cmpxchg(&per_cpu(cpu_hotplug_state, cpu),\n\t\t\t\t   oldstate, cpu_broken) != oldstate)\n\t\t\tgoto update_state;\n\t\tret = false;\n\t}\n\treturn ret;\n}\n\n\nbool cpu_report_death(void)\n{\n\tint oldstate;\n\tint newstate;\n\tint cpu = smp_processor_id();\n\n\tdo {\n\t\toldstate = atomic_read(&per_cpu(cpu_hotplug_state, cpu));\n\t\tif (oldstate != cpu_broken)\n\t\t\tnewstate = cpu_dead;\n\t\telse\n\t\t\tnewstate = cpu_dead_frozen;\n\t} while (atomic_cmpxchg(&per_cpu(cpu_hotplug_state, cpu),\n\t\t\t\toldstate, newstate) != oldstate);\n\treturn newstate == cpu_dead;\n}\n\n#endif \n\n\n#include <linux/module.h>", "5496": "<= 0)\n\t\t\tbreak;\n\n\t\tcontinue;\nnext:\n\t\tlist_move_tail(&p->", "5497": "<= 0)\n\t\t\tcurrent->", "5498": "<= 0)\n\t\t\tgoto out;\n\t}\n\n\n\t\n\tret = -erestart_restartblock;\nout:\n\treturn ret;\n}\n\n\nstatic int alarm_timer_nsleep(const clockid_t which_clock, int flags,\n\t\t     struct timespec *tsreq, struct timespec __user *rmtp)\n{\n\tenum  alarmtimer_type type = clock2alarm(which_clock);\n\tstruct alarm alarm;\n\tktime_t exp;\n\tint ret = 0;\n\tstruct restart_block *restart;\n\n\tif (!alarmtimer_get_rtcdev())\n\t\treturn -enotsupp;\n\n\tif (flags & ~timer_abstime)\n\t\treturn -einval;\n\n\tif (!capable(cap_wake_alarm))\n\t\treturn -eperm;\n\n\talarm_init(&alarm, type, alarmtimer_nsleep_wakeup);\n\n\texp = timespec_to_ktime(*tsreq);\n\t\n\tif (flags != timer_abstime) {\n\t\tktime_t now = alarm_bases[type].gettime();\n\t\texp = ktime_add(now, exp);\n\t}\n\n\tif (alarmtimer_do_nsleep(&alarm, exp))\n\t\tgoto out;\n\n\tif (freezing(current))\n\t\talarmtimer_freezerset(exp, type);\n\n\t\n\tif (flags == timer_abstime) {\n\t\tret = -erestartnohand;\n\t\tgoto out;\n\t}\n\n\tif (rmtp) {\n\t\tret = update_rmtp(exp, type, rmtp);\n\t\tif (ret <= 0)\n\t\t\tgoto out;\n\t}\n\n\trestart = &current->", "5499": "<= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = page_size - pg_offp;\n\t}\n\n\tres = simple_read_from_buffer(buf, count, &pg_offp,\n\t\t\tdata_of(data->", "5500": "<= 0)\n\t\t\tgoto unlock;\n\t} else {\n\t\tres = page_size - pg_offp;\n\t}\n\n\tres = simple_write_to_buffer(data_of(data->", "5501": "<= 0)\n\t\t\tnrealreaders = 1;\n\t}\n\trcu_torture_print_module_parms(cur_ops, \"start of test\");\n\n\t\n\n\tinit_list_head(&rcu_torture_freelist);\n\tfor (i = 0; i < array_size(rcu_tortures); i++) {\n\t\trcu_tortures[i].rtort_mbtest = 0;\n\t\tlist_add_tail(&rcu_tortures[i].rtort_free,\n\t\t\t      &rcu_torture_freelist);\n\t}\n\n\t\n\n\trcu_torture_current = null;\n\trcu_torture_current_version = 0;\n\tatomic_set(&n_rcu_torture_alloc, 0);\n\tatomic_set(&n_rcu_torture_alloc_fail, 0);\n\tatomic_set(&n_rcu_torture_free, 0);\n\tatomic_set(&n_rcu_torture_mberror, 0);\n\tatomic_set(&n_rcu_torture_error, 0);\n\tn_rcu_torture_barrier_error = 0;\n\tn_rcu_torture_boost_ktrerror = 0;\n\tn_rcu_torture_boost_rterror = 0;\n\tn_rcu_torture_boost_failure = 0;\n\tn_rcu_torture_boosts = 0;\n\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++)\n\t\tatomic_set(&rcu_torture_wcount[i], 0);\n\tfor_each_possible_cpu(cpu) {\n\t\tfor (i = 0; i < rcu_torture_pipe_len + 1; i++) {\n\t\t\tper_cpu(rcu_torture_count, cpu)[i] = 0;\n\t\t\tper_cpu(rcu_torture_batch, cpu)[i] = 0;\n\t\t}\n\t}\n\n\t\n\n\tfirsterr = torture_create_kthread(rcu_torture_writer, null,\n\t\t\t\t\t  writer_task);\n\tif (firsterr)\n\t\tgoto unwind;\n\tfakewriter_tasks = kzalloc(nfakewriters * sizeof(fakewriter_tasks[0]),\n\t\t\t\t   gfp_kernel);\n\tif (fakewriter_tasks == null) {\n\t\tverbose_torout_errstring(\"out of memory\");\n\t\tfirsterr = -enomem;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nfakewriters; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_fakewriter,\n\t\t\t\t\t\t  null, fakewriter_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\treader_tasks = kzalloc(nrealreaders * sizeof(reader_tasks[0]),\n\t\t\t       gfp_kernel);\n\tif (reader_tasks == null) {\n\t\tverbose_torout_errstring(\"out of memory\");\n\t\tfirsterr = -enomem;\n\t\tgoto unwind;\n\t}\n\tfor (i = 0; i < nrealreaders; i++) {\n\t\tfirsterr = torture_create_kthread(rcu_torture_reader, null,\n\t\t\t\t\t\t  reader_tasks[i]);\n\t\tif (firsterr)\n\t\t\tgoto unwind;\n\t}\n\tif (stat_interval >", "5502": "<= 0)\n\t\t\trem.tv64 = nsec_per_usec;\n\t} else\n\t\trem.tv64 = 0;\n\n\treturn ktime_to_timeval(rem);\n}\n\nstatic void get_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   struct itimerval *const value)\n{\n\tcputime_t cval, cinterval;\n\tstruct cpu_itimer *it = &tsk->", "5503": "<= 0)\n\t\t\treturn false;\n\t\tudelay(srcu_retry_check_delay);\n\t}\n}\n\n\nstatic void srcu_flip(struct srcu_struct *sp)\n{\n\tsp->", "5504": "<= 0)\n\t\treturn -1;\n\n\tgran = wakeup_gran(curr, se);\n\tif (vdiff >", "5505": "<= 0)\n\t\treturn -einval;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kprobe(kps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i >", "5506": "<= 0)\n\t\treturn -einval;\n\tfor (i = 0; i < num; i++) {\n\t\tret = register_kretprobe(rps[i]);\n\t\tif (ret < 0) {\n\t\t\tif (i >", "5507": "<= 0)\n\t\treturn -einval;\n\tfor (i = 0; i < num; i++) {\n\t\tunsigned long addr, offset;\n\t\tjp = jps[i];\n\t\taddr = arch_deref_entry_point(jp->", "5508": "<= 0)\n\t\treturn -einval;\n\n\tif ((sysctl_sched_rt_runtime != runtime_inf) &&\n\t\t(sysctl_sched_rt_runtime >", "5509": "<= 0)\n\t\treturn -einval;\n\n\tif (kexec_purgatory_size < sizeof(elf_ehdr))\n\t\treturn -enoexec;\n\n\tpi->", "5510": "<= 0)\n\t\treturn -einval;\n\n\tworkqueue_set_max_active(wq, val);\n\treturn count;\n}\nstatic device_attr_rw(max_active);\n\nstatic struct attribute *wq_sysfs_attrs[] = {\n\t&dev_attr_per_cpu.attr,\n\t&dev_attr_max_active.attr,\n\tnull,\n};\nattribute_groups(wq_sysfs);\n\nstatic ssize_t wq_pool_ids_show(struct device *dev,\n\t\t\t\tstruct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tconst char *delim = \"\";\n\tint node, written = 0;\n\n\trcu_read_lock_sched();\n\tfor_each_node(node) {\n\t\twritten += scnprintf(buf + written, page_size - written,\n\t\t\t\t     \"%s%d:%d\", delim, node,\n\t\t\t\t     unbound_pwq_by_node(wq, node)->", "5511": "<= 0)\n\t\treturn 0;\n\treturn torture_create_kthread(rcu_torture_stall, null, stall_task);\n}\n\n\nstatic void rcu_torture_barrier_cbf(struct rcu_head *rcu)\n{\n\tatomic_inc(&barrier_cbs_invoked);\n}\n\n\nstatic int rcu_torture_barrier_cbs(void *arg)\n{\n\tlong myid = (long)arg;\n\tbool lastphase = 0;\n\tbool newphase;\n\tstruct rcu_head rcu;\n\n\tinit_rcu_head_on_stack(&rcu);\n\tverbose_torout_string(\"rcu_torture_barrier_cbs task started\");\n\tset_user_nice(current, max_nice);\n\tdo {\n\t\twait_event(barrier_cbs_wq[myid],\n\t\t\t   (newphase =\n\t\t\t    access_once(barrier_phase)) != lastphase ||\n\t\t\t   torture_must_stop());\n\t\tlastphase = newphase;\n\t\tsmp_mb(); \n\t\tif (torture_must_stop())\n\t\t\tbreak;\n\t\tcur_ops->", "5512": "<= 0)\n\t\treturn 0;\n\trmt = ktime_to_timespec(rem);\n\n\tif (copy_to_user(rmtp, &rmt, sizeof(*rmtp)))\n\t\treturn -efault;\n\n\treturn 1;\n\n}\n\n\nstatic long __sched alarm_timer_nsleep_restart(struct restart_block *restart)\n{\n\tenum  alarmtimer_type type = restart->", "5513": "<= 0)\n\t\treturn 0;\n\n\twhile (!list_empty(tasks)) {\n\t\tp = list_first_entry(tasks, struct task_struct, se.group_node);\n\n\t\tenv->", "5514": "<= 0)\n\t\treturn false;\n\n\t\n\torig_src_load = env->", "5515": "<= 0)\n\t\treturn force ? clockevents_program_min_delta(dev) : -etime;\n\n\tdelta = min(delta, (int64_t) dev->", "5516": "<= 0)\n\t\treturn now + 1;\n\n\ttsdelta = ktime_to_timespec(hr_delta);\n\tdelta = timespec_to_jiffies(&tsdelta);\n\n\t\n\tif (delta >", "5517": "<= 0)\n\t\treturn print_unlock_imbalance_bug(curr, lock, ip);\n\n\treturn 1;\n}\n\nstatic int match_held_lock(struct held_lock *hlock, struct lockdep_map *lock)\n{\n\tif (hlock->", "5518": "<= 0)\n\t\treturn ret;\n\n\tret = verify_opcode(old_page, vaddr, &opcode);\n\tif (ret <= 0)\n\t\tgoto put_old;\n\n\tret = anon_vma_prepare(vma);\n\tif (ret)\n\t\tgoto put_old;\n\n\tret = -enomem;\n\tnew_page = alloc_page_vma(gfp_highuser_movable, vma, vaddr);\n\tif (!new_page)\n\t\tgoto put_old;\n\n\t__setpageuptodate(new_page);\n\tcopy_highpage(new_page, old_page);\n\tcopy_to_page(new_page, vaddr, &opcode, uprobe_swbp_insn_size);\n\n\tret = __replace_page(vma, vaddr, old_page, new_page);\n\tpage_cache_release(new_page);\nput_old:\n\tput_page(old_page);\n\n\tif (unlikely(ret == -eagain))\n\t\tgoto retry;\n\treturn ret;\n}\n\n\nint __weak set_swbp(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(mm, vaddr, uprobe_swbp_insn);\n}\n\n\nint __weak\nset_orig_insn(struct arch_uprobe *auprobe, struct mm_struct *mm, unsigned long vaddr)\n{\n\treturn uprobe_write_opcode(mm, vaddr, *(uprobe_opcode_t *)&auprobe->", "5519": "<= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(&jps[i]->", "5520": "<= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(&rps[i]->", "5521": "<= 0)\n\t\treturn;\n\tmutex_lock(&kprobe_mutex);\n\tfor (i = 0; i < num; i++)\n\t\tif (__unregister_kprobe_top(kps[i]) < 0)\n\t\t\tkps[i]->", "5522": "<= 0)\n\t\treturn;\n\n\tmemset(&lat, 0, sizeof(lat));\n\tlat.count = 1;\n\tlat.time = usecs;\n\tlat.max = usecs;\n\tstore_stacktrace(tsk, &lat);\n\n\traw_spin_lock_irqsave(&latency_lock, flags);\n\n\taccount_global_scheduler_latency(tsk, &lat);\n\n\tfor (i = 0; i < tsk->", "5523": "<= 0)\n\t\treturn;\n\n\traw_spin_lock(&cfs_b->", "5524": "<= 0)\n\t\tthrottle_cfs_rq(cfs_rq);\n}\n\n\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq)\n{\n\tif (!cfs_bandwidth_used())\n\t\treturn false;\n\n\tif (likely(!cfs_rq->", "5525": "<= 0) {\n\t\t\t\tkill_test();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tring_buffer_free_read_page(buffer, bpage);\n\n\tif (ret < 0)\n\t\treturn event_dropped;\n\treturn event_found;\n}\n\nstatic void ring_buffer_consumer(void)\n{\n\t\n\tread_events ^= 1;\n\n\tread = 0;\n\twhile (!reader_finish && !kill_test) {\n\t\tint found;\n\n\t\tdo {\n\t\t\tint cpu;\n\n\t\t\tfound = 0;\n\t\t\tfor_each_online_cpu(cpu) {\n\t\t\t\tenum event_status stat;\n\n\t\t\t\tif (read_events)\n\t\t\t\t\tstat = read_event(cpu);\n\t\t\t\telse\n\t\t\t\t\tstat = read_page(cpu);\n\n\t\t\t\tif (kill_test)\n\t\t\t\t\tbreak;\n\t\t\t\tif (stat == event_found)\n\t\t\t\t\tfound = 1;\n\t\t\t}\n\t\t} while (found && !kill_test);\n\n\t\tset_current_state(task_interruptible);\n\t\tif (reader_finish)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\treader_finish = 0;\n\tcomplete(&read_done);\n}\n\nstatic void ring_buffer_producer(void)\n{\n\tktime_t start_time, end_time, timeout;\n\tunsigned long long time;\n\tunsigned long long entries;\n\tunsigned long long overruns;\n\tunsigned long missed = 0;\n\tunsigned long hit = 0;\n\tunsigned long avg;\n\tint cnt = 0;\n\n\t\n\ttrace_printk(\"starting ring buffer hammer\\n\");\n\tstart_time = ktime_get();\n\ttimeout = ktime_add_ns(start_time, run_time * nsec_per_sec);\n\tdo {\n\t\tstruct ring_buffer_event *event;\n\t\tint *entry;\n\t\tint i;\n\n\t\tfor (i = 0; i < write_iteration; i++) {\n\t\t\tevent = ring_buffer_lock_reserve(buffer, 10);\n\t\t\tif (!event) {\n\t\t\t\tmissed++;\n\t\t\t} else {\n\t\t\t\thit++;\n\t\t\t\tentry = ring_buffer_event_data(event);\n\t\t\t\t*entry = smp_processor_id();\n\t\t\t\tring_buffer_unlock_commit(buffer, event);\n\t\t\t}\n\t\t}\n\t\tend_time = ktime_get();\n\n\t\tcnt++;\n\t\tif (consumer && !(cnt % wakeup_interval))\n\t\t\twake_up_process(consumer);\n\n#ifndef config_preempt\n\t\t\n\t\tif (cnt % wakeup_interval)\n\t\t\tcond_resched();\n#endif\n\n\t} while (ktime_before(end_time, timeout) && !kill_test);\n\ttrace_printk(\"end ring buffer hammer\\n\");\n\n\tif (consumer) {\n\t\t\n\t\tinit_completion(&read_start);\n\t\tinit_completion(&read_done);\n\t\t\n\t\tsmp_wmb();\n\t\treader_finish = 1;\n\t\t\n\t\tsmp_wmb();\n\t\twake_up_process(consumer);\n\t\twait_for_completion(&read_done);\n\t}\n\n\ttime = ktime_us_delta(end_time, start_time);\n\n\tentries = ring_buffer_entries(buffer);\n\toverruns = ring_buffer_overruns(buffer);\n\n\tif (kill_test)\n\t\ttrace_printk(\"error!\\n\");\n\n\tif (!disable_reader) {\n\t\tif (consumer_fifo < 0)\n\t\t\ttrace_printk(\"running consumer at nice: %d\\n\",\n\t\t\t\t     consumer_nice);\n\t\telse\n\t\t\ttrace_printk(\"running consumer at sched_fifo %d\\n\",\n\t\t\t\t     consumer_fifo);\n\t}\n\tif (producer_fifo < 0)\n\t\ttrace_printk(\"running producer at nice: %d\\n\",\n\t\t\t     producer_nice);\n\telse\n\t\ttrace_printk(\"running producer at sched_fifo %d\\n\",\n\t\t\t     producer_fifo);\n\n\t\n\tif (producer_fifo < 0 && consumer_fifo < 0 &&\n\t    producer_nice == max_nice && consumer_nice == max_nice)\n\t\ttrace_printk(\"warning!!! this test is running at lowest priority.\\n\");\n\n\ttrace_printk(\"time:     %lld (usecs)\\n\", time);\n\ttrace_printk(\"overruns: %lld\\n\", overruns);\n\tif (disable_reader)\n\t\ttrace_printk(\"read:     (reader disabled)\\n\");\n\telse\n\t\ttrace_printk(\"read:     %ld  (by %s)\\n\", read,\n\t\t\tread_events ? \"events\" : \"pages\");\n\ttrace_printk(\"entries:  %lld\\n\", entries);\n\ttrace_printk(\"total:    %lld\\n\", entries + overruns + read);\n\ttrace_printk(\"missed:   %ld\\n\", missed);\n\ttrace_printk(\"hit:      %ld\\n\", hit);\n\n\t\n\tdo_div(time, usec_per_msec);\n\tif (time)\n\t\thit /= (long)time;\n\telse\n\t\ttrace_printk(\"time is zero??\\n\");\n\n\ttrace_printk(\"entries per millisec: %ld\\n\", hit);\n\n\tif (hit) {\n\t\t\n\t\tavg = nsec_per_msec / hit;\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n\n\tif (missed) {\n\t\tif (time)\n\t\t\tmissed /= (long)time;\n\n\t\ttrace_printk(\"total iterations per millisec: %ld\\n\",\n\t\t\t     hit + missed);\n\n\t\t\n\t\tif (!(hit + missed)) {\n\t\t\ttrace_printk(\"hit + missed overflowed and totalled zero!\\n\");\n\t\t\thit--; \n\t\t}\n\n\t\t\n\t\tavg = nsec_per_msec / (hit + missed);\n\t\ttrace_printk(\"%ld ns per entry\\n\", avg);\n\t}\n}\n\nstatic void wait_to_die(void)\n{\n\tset_current_state(task_interruptible);\n\twhile (!kthread_should_stop()) {\n\t\tschedule();\n\t\tset_current_state(task_interruptible);\n\t}\n\t__set_current_state(task_running);\n}\n\nstatic int ring_buffer_consumer_thread(void *arg)\n{\n\twhile (!kthread_should_stop() && !kill_test) {\n\t\tcomplete(&read_start);\n\n\t\tring_buffer_consumer();\n\n\t\tset_current_state(task_interruptible);\n\t\tif (kthread_should_stop() || kill_test)\n\t\t\tbreak;\n\n\t\tschedule();\n\t}\n\t__set_current_state(task_running);\n\n\tif (kill_test)\n\t\twait_to_die();\n\n\treturn 0;\n}\n\nstatic int ring_buffer_producer_thread(void *arg)\n{\n\tinit_completion(&read_start);\n\n\twhile (!kthread_should_stop() && !kill_test) {\n\t\tring_buffer_reset(buffer);\n\n\t\tif (consumer) {\n\t\t\tsmp_wmb();\n\t\t\twake_up_process(consumer);\n\t\t\twait_for_completion(&read_start);\n\t\t}\n\n\t\tring_buffer_producer();\n\n\t\ttrace_printk(\"sleeping for 10 secs\\n\");\n\t\tset_current_state(task_interruptible);\n\t\tschedule_timeout(hz * sleep_time);\n\t}\n\n\tif (kill_test)\n\t\twait_to_die();\n\n\treturn 0;\n}\n\nstatic int __init ring_buffer_benchmark_init(void)\n{\n\tint ret;\n\n\t\n\tbuffer = ring_buffer_alloc(1000000, rb_fl_overwrite);\n\tif (!buffer)\n\t\treturn -enomem;\n\n\tif (!disable_reader) {\n\t\tconsumer = kthread_create(ring_buffer_consumer_thread,\n\t\t\t\t\t  null, \"rb_consumer\");\n\t\tret = ptr_err(consumer);\n\t\tif (is_err(consumer))\n\t\t\tgoto out_fail;\n\t}\n\n\tproducer = kthread_run(ring_buffer_producer_thread,\n\t\t\t       null, \"rb_producer\");\n\tret = ptr_err(producer);\n\n\tif (is_err(producer))\n\t\tgoto out_kill;\n\n\t\n\tif (!disable_reader) {\n\t\tif (consumer_fifo >", "5526": "<= 0) {\n\t\t\n\t\tif ((timr->", "5527": "<= 0) {\n\t\tkdb_printf(\"process id must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t\n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"the specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->", "5528": "<= 0) {\n\t\tpr_debug(\"->", "5529": "<= 0) {\n\t\tpr_warn(\"%s: gave up waiting for init of module %s.\\n\",\n\t\t\tmod->", "5530": "<= 0) {\n\t\tprintk(kern_err \"kgdb: internal thread select error\\n\");\n\t\tdump_stack();\n\t\treturn null;\n\t}\n\n\t\n\treturn find_task_by_pid_ns(tid, &init_pid_ns);\n}\n\n\n\nstatic inline int shadow_pid(int realpid)\n{\n\tif (realpid)\n\t\treturn realpid;\n\n\treturn -raw_smp_processor_id() - 2;\n}\n\n\n\n\nstatic void gdb_cmd_status(struct kgdb_state *ks)\n{\n\t\n\tdbg_remove_all_break();\n\n\tremcom_out_buffer[0] = 's';\n\thex_byte_pack(&remcom_out_buffer[1], ks->", "5531": "<= 0) {\n\t\tverbose(\"invalid stack type r%d off=%d access_size=%d\\n\",\n\t\t\tregno, off, access_size);\n\t\treturn -eacces;\n\t}\n\n\tfor (i = 0; i < access_size; i++) {\n\t\tif (state->", "5532": "<= 0) {\n#ifdef config_preempt\n\t\trp->", "5533": "<= 0) || (event->", "5534": "<= 0))\n\t\t\tgoto timed_out;\n\t\t__set_task_state(task, state);\n\t\traw_spin_unlock_irq(&sem->", "5535": "<= 0))\n\t\treturn;\n\n\tcurr->", "5536": "<= 0))\n\t\treturn;\n\n\tdata->", "5537": "<= 0))\n\t\treturn;\n\n\tschedstat_set(curr->", "5538": "<= 0)) {\n\t\t\n\t\ttimekeeping_apply_adjustment(tk, offset, 1, 0);\n\t\ttk->", "5539": "<= 0)) {\n\t\tse->", "5540": "<= 0);\n\t\t\treturn; \n\t\t} else {\n\t\t\trdtp->", "5541": "<= 0);\n\t\tif (rdtp->", "5542": "<= 0);\n\tkdb_flags = kdb_flags_stack[--kdb_flags_index];\n}\n\n\n#include <linux/proc_fs.h>", "5543": "<= 0);\n\tpwq->", "5544": "<= 0);\n\twarn_on_once(!(atomic_read(&rdtp->", "5545": "<= 1)\n\t\t\treturn null;\n\t}\n\n\t\n\twhile (!string[0]) {\n\t\tstring++;\n\t\tif ((*secsize)-- <= 1)\n\t\t\treturn null;\n\t}\n\treturn string;\n}\n\nstatic char *get_modinfo(struct load_info *info, const char *tag)\n{\n\tchar *p;\n\tunsigned int taglen = strlen(tag);\n\telf_shdr *infosec = &info->", "5546": "<= 1)\n\t\tdump_stack();\n#endif\n\n\t\n\tif (!crash_kexec_post_notifiers)\n\t\tcrash_kexec(null);\n\n\t\n\tsmp_send_stop();\n\n\t\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\tkmsg_dump(kmsg_dump_panic);\n\n\t\n\tcrash_kexec(null);\n\n\tbust_spinlocks(0);\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout >", "5547": "<= 1)\n\t\tgoto out;\n\n\t\n\tif ((long)delta_jiffies >", "5548": "<= 1)\n\t\tgoto out_unlock;\n\n\t\n\tbug_on(busiest_rq == target_rq);\n\n\t\n\trcu_read_lock();\n\tfor_each_domain(target_cpu, sd) {\n\t\tif ((sd->", "5549": "<= 1)\n\t\treturn;\n\n\tif (wq_disable_numa) {\n\t\tpr_info(\"workqueue: numa affinity support disabled\\n\");\n\t\treturn;\n\t}\n\n\twq_update_unbound_numa_attrs_buf = alloc_workqueue_attrs(gfp_kernel);\n\tbug_on(!wq_update_unbound_numa_attrs_buf);\n\n\t\n\ttbl = kzalloc(nr_node_ids * sizeof(tbl[0]), gfp_kernel);\n\tbug_on(!tbl);\n\n\tfor_each_node(node)\n\t\tbug_on(!zalloc_cpumask_var_node(&tbl[node], gfp_kernel,\n\t\t\t\tnode_online(node) ? node : numa_no_node));\n\n\tfor_each_possible_cpu(cpu) {\n\t\tnode = cpu_to_node(cpu);\n\t\tif (warn_on(node == numa_no_node)) {\n\t\t\tpr_warn(\"workqueue: numa node mapping not available for cpu%d, disabling numa support\\n\", cpu);\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tcpumask_set_cpu(cpu, tbl[node]);\n\t}\n\n\twq_numa_possible_cpumask = tbl;\n\twq_numa_enabled = true;\n}\n\nstatic int __init init_workqueues(void)\n{\n\tint std_nice[nr_std_worker_pools] = { 0, highpri_nice_level };\n\tint i, cpu;\n\n\twarn_on(__alignof__(struct pool_workqueue) < __alignof__(long long));\n\n\tpwq_cache = kmem_cache(pool_workqueue, slab_panic);\n\n\tcpu_notifier(workqueue_cpu_up_callback, cpu_pri_workqueue_up);\n\thotcpu_notifier(workqueue_cpu_down_callback, cpu_pri_workqueue_down);\n\n\twq_numa_init();\n\n\t\n\tfor_each_possible_cpu(cpu) {\n\t\tstruct worker_pool *pool;\n\n\t\ti = 0;\n\t\tfor_each_cpu_worker_pool(pool, cpu) {\n\t\t\tbug_on(init_worker_pool(pool));\n\t\t\tpool->", "5550": "<= 1)\n\t\tstddev = 0;\n\telse {\n\t\t\n\t\tstddev = rec->", "5551": "<= 1) {\n\t\tif (!task_current(rq, p))\n\t\t\tdequeue_pushable_task(rq, p);\n\t\tbug_on(!rq->", "5552": "<= 1))\n\t\t\treturn kdb_noperm;\n\n\t\tkdb_state_set(cmd);\n\t\tresult = (*tp->", "5553": "<= 1);\n\n\tbug_on(!task_on_rq_queued(p));\n\tbug_on(!rt_task(p));\n\n\treturn p;\n}\n\n\nstatic int push_rt_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *lowest_rq;\n\tint ret = 0;\n\n\tif (!rq->", "5554": "<= 1000))\n\t\t\tpr_warn(\"workqueue %s: drain_workqueue() isn't complete after %u tries\\n\",\n\t\t\t\twq->", "5555": "<= 1;\n\tpreempt_enable();\n\treturn ret;\n}\n\n\nvoid synchronize_sched(void)\n{\n\trcu_lockdep_assert(!lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"illegal synchronize_sched() in rcu-sched read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_sched_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu_sched);\n}\nexport_symbol_gpl(synchronize_sched);\n\n\nvoid synchronize_rcu_bh(void)\n{\n\trcu_lockdep_assert(!lock_is_held(&rcu_bh_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_lock_map) &&\n\t\t\t   !lock_is_held(&rcu_sched_lock_map),\n\t\t\t   \"illegal synchronize_rcu_bh() in rcu-bh read-side critical section\");\n\tif (rcu_blocking_is_gp())\n\t\treturn;\n\tif (rcu_gp_is_expedited())\n\t\tsynchronize_rcu_bh_expedited();\n\telse\n\t\twait_rcu_gp(call_rcu_bh);\n}\nexport_symbol_gpl(synchronize_rcu_bh);\n\n\nunsigned long get_state_synchronize_rcu(void)\n{\n\t\n\tsmp_mb();  \n\n\t\n\treturn smp_load_acquire(&rcu_state_p->", "5556": "<= 1;\n}\n\n\nstatic bool need_to_create_worker(struct worker_pool *pool)\n{\n\treturn need_more_worker(pool) && !may_start_working(pool);\n}\n\n\nstatic bool too_many_workers(struct worker_pool *pool)\n{\n\tbool managing = mutex_is_locked(&pool->", "5557": "<= 1;\n}\n\n\nstatic int dyntick_save_progress_counter(struct rcu_data *rdp,\n\t\t\t\t\t bool *isidle, unsigned long *maxj)\n{\n\trdp->", "5558": "<= 256) \n\t\t\trcu_expedite_gp();\n\t\tbreak;\n\tcase pm_post_hibernation:\n\tcase pm_post_suspend:\n\t\tif (nr_cpu_ids <= 256) \n\t\t\trcu_unexpedite_gp();\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn notify_ok;\n}\n\n\nstatic int __init rcu_spawn_gp_kthread(void)\n{\n\tunsigned long flags;\n\tint kthread_prio_in = kthread_prio;\n\tstruct rcu_node *rnp;\n\tstruct rcu_state *rsp;\n\tstruct sched_param sp;\n\tstruct task_struct *t;\n\n\t\n\tif (is_enabled(config_rcu_boost) && kthread_prio < 1)\n\t\tkthread_prio = 1;\n\telse if (kthread_prio < 0)\n\t\tkthread_prio = 0;\n\telse if (kthread_prio >", "5559": "<= addr\n\t\t    && mod->", "5560": "<= addr)\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\t\n\twhile (low && kallsyms_addresses[low-1] == kallsyms_addresses[low])\n\t\t--low;\n\n\tsymbol_start = kallsyms_addresses[low];\n\n\t\n\tfor (i = low + 1; i < kallsyms_num_syms; i++) {\n\t\tif (kallsyms_addresses[i] >", "5561": "<= alloc_normal)\n\t\treturn 0;\n\n\talloc = avail_normal - alloc_normal;\n\tif (nr_pages < alloc)\n\t\talloc = nr_pages;\n\n\treturn preallocate_image_pages(alloc, gfp_image);\n}\n\n#ifdef config_highmem\nstatic unsigned long preallocate_image_highmem(unsigned long nr_pages)\n{\n\treturn preallocate_image_pages(nr_pages, gfp_image | __gfp_highmem);\n}\n\n\nstatic unsigned long __fraction(u64 x, u64 multiplier, u64 base)\n{\n\tx *= multiplier;\n\tdo_div(x, base);\n\treturn (unsigned long)x;\n}\n\nstatic unsigned long preallocate_highmem_fraction(unsigned long nr_pages,\n\t\t\t\t\t\tunsigned long highmem,\n\t\t\t\t\t\tunsigned long total)\n{\n\tunsigned long alloc = __fraction(nr_pages, highmem, total);\n\n\treturn preallocate_image_pages(alloc, gfp_image | __gfp_highmem);\n}\n#else \nstatic inline unsigned long preallocate_image_highmem(unsigned long nr_pages)\n{\n\treturn 0;\n}\n\nstatic inline unsigned long preallocate_highmem_fraction(unsigned long nr_pages,\n\t\t\t\t\t\tunsigned long highmem,\n\t\t\t\t\t\tunsigned long total)\n{\n\treturn 0;\n}\n#endif \n\n\nstatic unsigned long free_unnecessary_pages(void)\n{\n\tunsigned long save, to_free_normal, to_free_highmem, free;\n\n\tsave = count_data_pages();\n\tif (alloc_normal >", "5562": "<= allowed_ns)\n\t\treturn;\n\n\tif (max_samples_per_tick <= 1)\n\t\treturn;\n\n\tmax_samples_per_tick = div_round_up(max_samples_per_tick, 2);\n\tsysctl_perf_event_sample_rate = max_samples_per_tick * hz;\n\tperf_sample_period_ns = nsec_per_sec / sysctl_perf_event_sample_rate;\n\n\tupdate_perf_cpu_limits();\n\n\tif (!irq_work_queue(&perf_duration_work)) {\n\t\tearly_printk(\"perf interrupt took too long (%lld >", "5563": "<= audit_backlog_limit)\n\t\t\t\twake_up(&audit_backlog_wait);\n\t\t\tif (audit_pid)\n\t\t\t\tkauditd_send_skb(skb);\n\t\t\telse\n\t\t\t\taudit_printk_skb(skb);\n\t\t\tcontinue;\n\t\t}\n\n\t\twait_event_freezable(kauditd_wait, skb_queue_len(&audit_skb_queue));\n\t}\n\treturn 0;\n}\n\nint audit_send_list(void *_dest)\n{\n\tstruct audit_netlink_list *dest = _dest;\n\tstruct sk_buff *skb;\n\tstruct net *net = dest->", "5564": "<= audit_last_feature; i++) {\n\t\tu32 feature = audit_feature_to_mask(i);\n\t\tu32 old_feature, new_feature, old_lock, new_lock;\n\n\t\t\n\t\tif (!(feature & uaf->", "5565": "<= bp_vaddr) {\n\t\tif (valid_vma(vma, false)) {\n\t\t\tstruct inode *inode = file_inode(vma->", "5566": "<= buf_page_hdr_size)\n\t\tgoto out;\n\n\tlen -= buf_page_hdr_size;\n\n\tif (!data_page)\n\t\tgoto out;\n\n\tbpage = *data_page;\n\tif (!bpage)\n\t\tgoto out;\n\n\traw_spin_lock_irqsave(&cpu_buffer->", "5567": "<= busiest->", "5568": "<= config_no_hz_full_sysidle_small)\n\t\treturn 0;\n\treturn div_round_up(nr_cpu_ids * hz, rcu_fanout_leaf * 1000);\n}\n\n\nstatic void rcu_sysidle(unsigned long j)\n{\n\t\n\tswitch (access_once(full_sysidle_state)) {\n\tcase rcu_sysidle_not:\n\n\t\t\n\t\taccess_once(full_sysidle_state) = rcu_sysidle_short;\n\t\tbreak;\n\n\tcase rcu_sysidle_short:\n\n\t\t\n\t\tif (ulong_cmp_ge(jiffies, j + rcu_sysidle_delay()))\n\t\t\t(void)cmpxchg(&full_sysidle_state,\n\t\t\t\t      rcu_sysidle_short, rcu_sysidle_long);\n\t\tbreak;\n\n\tcase rcu_sysidle_long:\n\n\t\t\n\t\tif (ulong_cmp_ge(jiffies, j + rcu_sysidle_delay()))\n\t\t\t(void)cmpxchg(&full_sysidle_state,\n\t\t\t\t      rcu_sysidle_long, rcu_sysidle_full);\n\t\tbreak;\n\n\tdefault:\n\t\tbreak;\n\t}\n}\n\n\nstatic void rcu_sysidle_cancel(void)\n{\n\tsmp_mb();\n\tif (full_sysidle_state >", "5569": "<= config_no_hz_full_sysidle_small)\n\t\treturn;  \n\tif (isidle)\n\t\trcu_sysidle(maxj);    \n\telse\n\t\trcu_sysidle_cancel(); \n}\n\n\nstatic void rcu_sysidle_report_gp(struct rcu_state *rsp, int isidle,\n\t\t\t\t  unsigned long maxj)\n{\n\t\n\tif (!tick_nohz_full_enabled())\n\t\treturn;\n\n\trcu_sysidle_report(rsp, isidle, maxj, true);\n}\n\n\nstruct rcu_sysidle_head {\n\tstruct rcu_head rh;\n\tint inuse;\n};\n\nstatic void rcu_sysidle_cb(struct rcu_head *rhp)\n{\n\tstruct rcu_sysidle_head *rshp;\n\n\t\n\tsmp_mb();  \n\n\trshp = container_of(rhp, struct rcu_sysidle_head, rh);\n\taccess_once(rshp->", "5570": "<= config_no_hz_full_sysidle_small) {\n\t\tint oldrss = rss - 1;\n\n\t\t\n\t\twhile (rss < rcu_sysidle_full && oldrss < rss) {\n\t\t\tint cpu;\n\t\t\tbool isidle = true;\n\t\t\tunsigned long maxj = jiffies - ulong_max / 4;\n\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\n\t\t\tfor_each_possible_cpu(cpu) {\n\t\t\t\trdp = per_cpu_ptr(rcu_state_p->", "5571": "<= crashk_res.end) {\n\t\tunsigned long i;\n\n\t\tif (hole_end >", "5572": "<= ctx->", "5573": "<= end))\n\t\tgoto out;\n\n\ttmp = parent->", "5574": "<= env->", "5575": "<= ext->", "5576": "<= extent->", "5577": "<= fp_old->", "5578": "<= handle->", "5579": "<= hibernation_max; i++) {\n\t\tif (!hibernation_modes[i])\n\t\t\tcontinue;\n\t\tswitch (i) {\n\t\tcase hibernation_shutdown:\n\t\tcase hibernation_reboot:\n#ifdef config_suspend\n\t\tcase hibernation_suspend:\n#endif\n\t\t\tbreak;\n\t\tcase hibernation_platform:\n\t\t\tif (hibernation_ops)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == hibernation_mode)\n\t\t\tbuf += sprintf(buf, \"[%s] \", hibernation_modes[i]);\n\t\telse\n\t\t\tbuf += sprintf(buf, \"%s \", hibernation_modes[i]);\n\t}\n\tbuf += sprintf(buf, \"\\n\");\n\treturn buf-start;\n}\n\nstatic ssize_t disk_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  const char *buf, size_t n)\n{\n\tint error = 0;\n\tint i;\n\tint len;\n\tchar *p;\n\tint mode = hibernation_invalid;\n\n\tif (!hibernation_available())\n\t\treturn -eperm;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\tfor (i = hibernation_first; i <= hibernation_max; i++) {\n\t\tif (len == strlen(hibernation_modes[i])\n\t\t    && !strncmp(buf, hibernation_modes[i], len)) {\n\t\t\tmode = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (mode != hibernation_invalid) {\n\t\tswitch (mode) {\n\t\tcase hibernation_shutdown:\n\t\tcase hibernation_reboot:\n#ifdef config_suspend\n\t\tcase hibernation_suspend:\n#endif\n\t\t\thibernation_mode = mode;\n\t\t\tbreak;\n\t\tcase hibernation_platform:\n\t\t\tif (hibernation_ops)\n\t\t\t\thibernation_mode = mode;\n\t\t\telse\n\t\t\t\terror = -einval;\n\t\t}\n\t} else\n\t\terror = -einval;\n\n\tif (!error)\n\t\tpr_debug(\"pm: hibernation mode set to '%s'\\n\",\n\t\t\t hibernation_modes[mode]);\n\tunlock_system_sleep();\n\treturn error ? error : n;\n}\n\npower_attr(disk);\n\nstatic ssize_t resume_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   char *buf)\n{\n\treturn sprintf(buf,\"%d:%d\\n\", major(swsusp_resume_device),\n\t\t       minor(swsusp_resume_device));\n}\n\nstatic ssize_t resume_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t    const char *buf, size_t n)\n{\n\tdev_t res;\n\tint len = n;\n\tchar *name;\n\n\tif (len && buf[len-1] == '\\n')\n\t\tlen--;\n\tname = kstrndup(buf, len, gfp_kernel);\n\tif (!name)\n\t\treturn -enomem;\n\n\tres = name_to_dev_t(name);\n\tkfree(name);\n\tif (!res)\n\t\treturn -einval;\n\n\tlock_system_sleep();\n\tswsusp_resume_device = res;\n\tunlock_system_sleep();\n\tprintk(kern_info \"pm: starting manual resume from disk\\n\");\n\tnoresume = 0;\n\tsoftware_resume();\n\treturn n;\n}\n\npower_attr(resume);\n\nstatic ssize_t image_size_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", image_size);\n}\n\nstatic ssize_t image_size_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\timage_size = size;\n\t\treturn n;\n\t}\n\n\treturn -einval;\n}\n\npower_attr(image_size);\n\nstatic ssize_t reserved_size_show(struct kobject *kobj,\n\t\t\t\t  struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%lu\\n\", reserved_size);\n}\n\nstatic ssize_t reserved_size_store(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr,\n\t\t\t\t   const char *buf, size_t n)\n{\n\tunsigned long size;\n\n\tif (sscanf(buf, \"%lu\", &size) == 1) {\n\t\treserved_size = size;\n\t\treturn n;\n\t}\n\n\treturn -einval;\n}\n\npower_attr(reserved_size);\n\nstatic struct attribute * g[] = {\n\t&disk_attr.attr,\n\t&resume_attr.attr,\n\t&image_size_attr.attr,\n\t&reserved_size_attr.attr,\n\tnull,\n};\n\n\nstatic struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\n\nstatic int __init pm_disk_init(void)\n{\n\treturn sysfs_create_group(power_kobj, &attr_group);\n}\n\ncore_initcall(pm_disk_init);\n\n\nstatic int __init resume_setup(char *str)\n{\n\tif (noresume)\n\t\treturn 1;\n\n\tstrncpy( resume_file, str, 255 );\n\treturn 1;\n}\n\nstatic int __init resume_offset_setup(char *str)\n{\n\tunsigned long long offset;\n\n\tif (noresume)\n\t\treturn 1;\n\n\tif (sscanf(str, \"%llu\", &offset) == 1)\n\t\tswsusp_resume_block = offset;\n\n\treturn 1;\n}\n\nstatic int __init hibernate_setup(char *str)\n{\n\tif (!strncmp(str, \"noresume\", 8))\n\t\tnoresume = 1;\n\telse if (!strncmp(str, \"nocompress\", 10))\n\t\tnocompress = 1;\n\telse if (!strncmp(str, \"no\", 2)) {\n\t\tnoresume = 1;\n\t\tnohibernate = 1;\n\t}\n\treturn 1;\n}\n\nstatic int __init noresume_setup(char *str)\n{\n\tnoresume = 1;\n\treturn 1;\n}\n\nstatic int __init resumewait_setup(char *str)\n{\n\tresume_wait = 1;\n\treturn 1;\n}\n\nstatic int __init resumedelay_setup(char *str)\n{\n\tint rc = kstrtouint(str, 0, &resume_delay);\n\n\tif (rc)\n\t\treturn rc;\n\treturn 1;\n}\n\nstatic int __init nohibernate_setup(char *str)\n{\n\tnoresume = 1;\n\tnohibernate = 1;\n\treturn 1;\n}\n\nstatic int __init kaslr_nohibernate_setup(char *str)\n{\n\treturn nohibernate_setup(str);\n}\n\n__setup(\"noresume\", noresume_setup);\n__setup(\"resume_offset=\", resume_offset_setup);\n__setup(\"resume=\", resume_setup);\n__setup(\"hibernate=\", hibernate_setup);\n__setup(\"resumewait\", resumewait_setup);\n__setup(\"resumedelay=\", resumedelay_setup);\n__setup(\"nohibernate\", nohibernate_setup);\n__setup(\"kaslr\", kaslr_nohibernate_setup);\n\n#include <linux/mutex.h>", "5580": "<= interval)))\n\t\treturn;\n\n\t\n\tnegative = (tick_error < 0);\n\n\t\n\ttick_error = abs(tick_error);\n\tfor (adj = 0; tick_error >", "5581": "<= is_cpu_exclusive(q) &&\n\t\tis_mem_exclusive(p) <= is_mem_exclusive(q);\n}\n\n\nstatic struct cpuset *alloc_trial_cpuset(struct cpuset *cs)\n{\n\tstruct cpuset *trial;\n\n\ttrial = kmemdup(cs, sizeof(*cs), gfp_kernel);\n\tif (!trial)\n\t\treturn null;\n\n\tif (!alloc_cpumask_var(&trial->", "5582": "<= jiffies_to_usecs(1) * 1000) {\n\t\t\n\t} else if (gran == 1000000000) {\n\t\tt.tv_nsec = 0;\n\t} else {\n\t\tt.tv_nsec -= t.tv_nsec % gran;\n\t}\n\treturn t;\n}\nexport_symbol(timespec_trunc);\n\n\ntime64_t mktime64(const unsigned int year0, const unsigned int mon0,\n\t\tconst unsigned int day, const unsigned int hour,\n\t\tconst unsigned int min, const unsigned int sec)\n{\n\tunsigned int mon = mon0, year = year0;\n\n\t\n\tif (0 >", "5583": "<= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase kdb_not_initialized:\n\t\t\tkdb_inittab();\t\t\n\t\t\tkdb_initbptab();\t\n\t\t\tbreak;\n\t\tcase kdb_init_early:\n\t\t\tkdb_cmd_init();\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}\n\n\n#define pr_fmt(fmt) kbuild_modname \": \" fmt\n\n#include <linux/kernel.h>", "5584": "<= last &&\n\t\t    (id2 >", "5585": "<= last)\n\t\t\tbreak;\n\t}\n\t\n\tif (idx < extents)\n\t\tid = (id - first) + map->", "5586": "<= last))\n\t\t\tbreak;\n\t}\n\t\n\tif (idx < extents)\n\t\tid = (id - first) + map->", "5587": "<= load_avg_period))\n\t\treturn runnable_avg_yn_sum[n];\n\telse if (unlikely(n >", "5588": "<= long_max &&\n\t    (ctx->", "5589": "<= lower_last) &&\n\t\t    (prev_lower_last >", "5590": "<= max_lockdep_chain_hlocks)) {\n\t\tchain->", "5591": "<= max_nice)\n\t\tret = apply_workqueue_attrs(wq, attrs);\n\telse\n\t\tret = -einval;\n\n\tfree_workqueue_attrs(attrs);\n\treturn ret ?: count;\n}\n\nstatic ssize_t wq_cpumask_show(struct device *dev,\n\t\t\t       struct device_attribute *attr, char *buf)\n{\n\tstruct workqueue_struct *wq = dev_to_wq(dev);\n\tint written;\n\n\tmutex_lock(&wq->", "5592": "<= max_rcu_lvls; i++)\n\t\tif (n <= rcu_capacity[i]) {\n\t\t\tfor (j = 0; j <= i; j++)\n\t\t\t\tnum_rcu_lvl[j] =\n\t\t\t\t\tdiv_round_up(n, rcu_capacity[i - j]);\n\t\t\trcu_num_lvls = i;\n\t\t\tfor (j = i + 1; j <= max_rcu_lvls; j++)\n\t\t\t\tnum_rcu_lvl[j] = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\n\trcu_num_nodes = 0;\n\tfor (i = 0; i <= max_rcu_lvls; i++)\n\t\trcu_num_nodes += num_rcu_lvl[i];\n\trcu_num_nodes -= n;\n}\n\nvoid __init rcu_init(void)\n{\n\tint cpu;\n\n\trcu_early_boot_tests();\n\n\trcu_bootup_announce();\n\trcu_init_geometry();\n\trcu_init_one(&rcu_bh_state, &rcu_bh_data);\n\trcu_init_one(&rcu_sched_state, &rcu_sched_data);\n\t__rcu_init_preempt();\n\topen_softirq(rcu_softirq, rcu_process_callbacks);\n\n\t\n\tcpu_notifier(rcu_cpu_notify, 0);\n\tpm_notifier(rcu_pm_notify, 0);\n\tfor_each_online_cpu(cpu)\n\t\trcu_cpu_notify(null, cpu_up_prepare, (void *)(long)cpu);\n}\n\n#include \"tree_plugin.h\"\n\n#include <linux/module.h>", "5593": "<= max_rcu_lvls; i++)\n\t\trcu_capacity[i] = rcu_capacity[i - 1] * config_rcu_fanout;\n\n\t\n\tif (rcu_fanout_leaf < config_rcu_fanout_leaf ||\n\t    rcu_fanout_leaf >", "5594": "<= max_scan; ++i) {\n\t\tif (unlikely(!map->", "5595": "<= mem_from ||\n\t\tmem_from + mem_len <= lock_from;\n}\n\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tfor (i = 0; i < curr->", "5596": "<= mend)) {\n\t\t\t\t\n\t\t\t\thole_start = (mend + (size - 1)) & ~(size - 1);\n\t\t\t\thole_end   = hole_start + size - 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (i == image->", "5597": "<= mm->", "5598": "<= msec_per_sec && !(msec_per_sec % hz)\n\treturn (msec_per_sec / hz) * j;\n#elif hz >", "5599": "<= now.tv64) {\n\t\t\t\tcpumask_set_cpu(cpu, tick_broadcast_force_mask);\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t\n\t\t\ttick_program_event(dev->", "5600": "<= now.tv64) {\n\t\t\tcpumask_set_cpu(cpu, tmpmask);\n\t\t\t\n\t\t\tcpumask_set_cpu(cpu, tick_broadcast_pending_mask);\n\t\t} else if (td->", "5601": "<= nr; i++)\n\t\tperf_mmap_unmark_page(base + (i * page_size));\n\n\tvfree(base);\n\tkfree(rb);\n}\n\nvoid rb_free(struct ring_buffer *rb)\n{\n\tschedule_work(&rb->", "5602": "<= nr_meta_pages + 1) {\n\t\terror = unpack_orig_pfns(buffer, &copy_bm);\n\t\tif (error)\n\t\t\treturn error;\n\n\t\tif (handle->", "5603": "<= nr_meta_pages + nr_copy_pages);\n}\n\n#ifdef config_highmem\n\nstatic inline void\nswap_two_pages_data(struct page *p1, struct page *p2, void *buf)\n{\n\tvoid *kaddr1, *kaddr2;\n\n\tkaddr1 = kmap_atomic(p1);\n\tkaddr2 = kmap_atomic(p2);\n\tcopy_page(buf, kaddr1);\n\tcopy_page(kaddr1, kaddr2);\n\tcopy_page(kaddr2, buf);\n\tkunmap_atomic(kaddr2);\n\tkunmap_atomic(kaddr1);\n}\n\n\n\nint restore_highmem(void)\n{\n\tstruct highmem_pbe *pbe = highmem_pblist;\n\tvoid *buf;\n\n\tif (!pbe)\n\t\treturn 0;\n\n\tbuf = get_image_page(gfp_atomic, pg_safe);\n\tif (!buf)\n\t\treturn -enomem;\n\n\twhile (pbe) {\n\t\tswap_two_pages_data(pbe->", "5604": "<= nr_meta_pages) {\n\t\tclear_page(buffer);\n\t\tpack_pfns(buffer, &orig_bm);\n\t} else {\n\t\tstruct page *page;\n\n\t\tpage = pfn_to_page(memory_bm_next_pfn(&copy_bm));\n\t\tif (pagehighmem(page)) {\n\t\t\t\n\t\t\tvoid *kaddr;\n\n\t\t\tkaddr = kmap_atomic(page);\n\t\t\tcopy_page(buffer, kaddr);\n\t\t\tkunmap_atomic(kaddr);\n\t\t\thandle->", "5605": "<= ns->", "5606": "<= p->", "5607": "<= perf_event_state_off)\n\t\t\tcontinue;\n\t\t\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, can_add_hw)) {\n\t\t\tif (group_sched_in(event, cpuctx, ctx))\n\t\t\t\tcan_add_hw = 0;\n\t\t}\n\t}\n}\n\nstatic void\nctx_sched_in(struct perf_event_context *ctx,\n\t     struct perf_cpu_context *cpuctx,\n\t     enum event_type_t event_type,\n\t     struct task_struct *task)\n{\n\tu64 now;\n\tint is_active = ctx->", "5608": "<= perf_event_state_off)\n\t\t\tcontinue;\n\t\tif (!event_filter_match(event))\n\t\t\tcontinue;\n\n\t\t\n\t\tif (is_cgroup_event(event))\n\t\t\tperf_cgroup_mark_enabled(event, ctx);\n\n\t\tif (group_can_go_on(event, cpuctx, 1))\n\t\t\tgroup_sched_in(event, cpuctx, ctx);\n\n\t\t\n\t\tif (event->", "5609": "<= perf_event_state_off)\n\t\treturn 0;\n\n\tevent->", "5610": "<= pfn_down(addr) &&\n\t\t    pfn_down(p->", "5611": "<= pi->", "5612": "<= pid)\n\t\t\t\tindex = mid + 1;\n\t\t\telse\n\t\t\t\tend = mid;\n\t\t}\n\t}\n\t\n\tif (index >", "5613": "<= pid->", "5614": "<= prctl_map->", "5615": "<= prev_eff_load;\n\n\tschedstat_inc(p, se.statistics.nr_wakeups_affine_attempts);\n\n\tif (!balanced)\n\t\treturn 0;\n\n\tschedstat_inc(sd, ttwu_move_affine);\n\tschedstat_inc(p, se.statistics.nr_wakeups_affine);\n\n\treturn 1;\n}\n\n\nstatic struct sched_group *\nfind_idlest_group(struct sched_domain *sd, struct task_struct *p,\n\t\t  int this_cpu, int sd_flag)\n{\n\tstruct sched_group *idlest = null, *group = sd->", "5616": "<= pse_depth) {\n\t\t\t\tput_prev_entity(cfs_rq_of(pse), pse);\n\t\t\t\tpse = parent_entity(pse);\n\t\t\t}\n\t\t\tif (se_depth >", "5617": "<= qlowmark)\n\t\trdp->", "5618": "<= range[j].start && end < range[j].end &&\n\t\t    range[j].start < end) {\n\t\t\trange[j].start = end;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tif (start >", "5619": "<= rcu_fanout_1\n#  define rcu_num_lvls\t      1\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      (nr_cpus)\n#  define num_rcu_lvl_2\t      0\n#  define num_rcu_lvl_3\t      0\n#  define num_rcu_lvl_4\t      0\n#elif nr_cpus <= rcu_fanout_2\n#  define rcu_num_lvls\t      2\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      div_round_up(nr_cpus, rcu_fanout_1)\n#  define num_rcu_lvl_2\t      (nr_cpus)\n#  define num_rcu_lvl_3\t      0\n#  define num_rcu_lvl_4\t      0\n#elif nr_cpus <= rcu_fanout_3\n#  define rcu_num_lvls\t      3\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      div_round_up(nr_cpus, rcu_fanout_2)\n#  define num_rcu_lvl_2\t      div_round_up(nr_cpus, rcu_fanout_1)\n#  define num_rcu_lvl_3\t      (nr_cpus)\n#  define num_rcu_lvl_4\t      0\n#elif nr_cpus <= rcu_fanout_4\n#  define rcu_num_lvls\t      4\n#  define num_rcu_lvl_0\t      1\n#  define num_rcu_lvl_1\t      div_round_up(nr_cpus, rcu_fanout_3)\n#  define num_rcu_lvl_2\t      div_round_up(nr_cpus, rcu_fanout_2)\n#  define num_rcu_lvl_3\t      div_round_up(nr_cpus, rcu_fanout_1)\n#  define num_rcu_lvl_4\t      (nr_cpus)\n#else\n# error \"config_rcu_fanout insufficient for nr_cpus\"\n#endif \n\n#define rcu_sum (num_rcu_lvl_0 + num_rcu_lvl_1 + num_rcu_lvl_2 + num_rcu_lvl_3 + num_rcu_lvl_4)\n#define num_rcu_nodes (rcu_sum - nr_cpus)\n\nextern int rcu_num_lvls;\nextern int rcu_num_nodes;\n\n\nstruct rcu_dynticks {\n\tlong long dynticks_nesting; \n\t\t\t\t    \n\tint dynticks_nmi_nesting;   \n\tatomic_t dynticks;\t    \n#ifdef config_no_hz_full_sysidle\n\tlong long dynticks_idle_nesting;\n\t\t\t\t    \n\tatomic_t dynticks_idle;\t    \n\t\t\t\t    \n\tunsigned long dynticks_idle_jiffies;\n\t\t\t\t    \n#endif \n#ifdef config_rcu_fast_no_hz\n\tbool all_lazy;\t\t    \n\tunsigned long nonlazy_posted;\n\t\t\t\t    \n\tunsigned long nonlazy_posted_snap;\n\t\t\t\t    \n\tunsigned long last_accelerate;\n\t\t\t\t    \n\tunsigned long last_advance_all;\n\t\t\t\t    \n\tint tick_nohz_enabled_snap; \n#endif \n};\n\n\n#define rcu_kthread_stopped  0\n#define rcu_kthread_running  1\n#define rcu_kthread_waiting  2\n#define rcu_kthread_offcpu   3\n#define rcu_kthread_yielding 4\n#define rcu_kthread_max      4\n\n\nstruct rcu_node {\n\traw_spinlock_t lock;\t\n\t\t\t\t\n\tunsigned long gpnum;\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long completed; \n\t\t\t\t\n\t\t\t\t\n\tunsigned long qsmask;\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long expmask;\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long qsmaskinit;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tunsigned long qsmaskinitnext;\n\t\t\t\t\n\tunsigned long grpmask;\t\n\t\t\t\t\n\tint\tgrplo;\t\t\n\tint\tgrphi;\t\t\n\tu8\tgrpnum;\t\t\n\tu8\tlevel;\t\t\n\tbool\twait_blkd_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct rcu_node *parent;\n\tstruct list_head blkd_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct list_head *gp_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct list_head *exp_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n#ifdef config_rcu_boost\n\tstruct list_head *boost_tasks;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\tstruct rt_mutex boost_mtx;\n\t\t\t\t\n\t\t\t\t\n\tunsigned long boost_time;\n\t\t\t\t\n\tstruct task_struct *boost_kthread_task;\n\t\t\t\t\n\t\t\t\t\n\tunsigned int boost_kthread_status;\n\t\t\t\t\n\tunsigned long n_tasks_boosted;\n\t\t\t\t\n\tunsigned long n_exp_boosts;\n\t\t\t\t\n\tunsigned long n_normal_boosts;\n\t\t\t\t\n\tunsigned long n_balk_blkd_tasks;\n\t\t\t\t\n\tunsigned long n_balk_exp_gp_tasks;\n\t\t\t\t\n\tunsigned long n_balk_boost_tasks;\n\t\t\t\t\n\tunsigned long n_balk_notblocked;\n\t\t\t\t\n\tunsigned long n_balk_notyet;\n\t\t\t\t\n\tunsigned long n_balk_nos;\n\t\t\t\t\n\t\t\t\t\n#endif \n#ifdef config_rcu_nocb_cpu\n\twait_queue_head_t nocb_gp_wq[2];\n\t\t\t\t\n#endif \n\tint need_future_gp[2];\n\t\t\t\t\n\traw_spinlock_t fqslock ____cacheline_internodealigned_in_smp;\n} ____cacheline_internodealigned_in_smp;\n\n\n#define rcu_for_each_node_breadth_first(rsp, rnp) \\\n\tfor ((rnp) = &(rsp)->", "5620": "<= rcu_next_tail; i++) {\n\t\trdp->", "5621": "<= real_ns) ? 0 : cpu_ns - real_ns;\n}\n\nstatic void set_cpu_itimer(struct task_struct *tsk, unsigned int clock_id,\n\t\t\t   const struct itimerval *const value,\n\t\t\t   struct itimerval *const ovalue)\n{\n\tcputime_t cval, nval, cinterval, ninterval;\n\ts64 ns_ninterval, ns_nval;\n\tu32 error, incr_error;\n\tstruct cpu_itimer *it = &tsk->", "5622": "<= res->", "5623": "<= ringbuf_type_data_type_len_max)\n\t\tcpu_buffer->", "5624": "<= rnp->", "5625": "<= s->", "5626": "<= sds->", "5627": "<= send_sig_forced;\n}\n\nstatic inline bool si_fromuser(const struct siginfo *info)\n{\n\treturn info == send_sig_noinfo ||\n\t\t(!is_si_special(info) && si_fromuser(info));\n}\n\n\nstatic int kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\tif (uid_eq(cred->", "5628": "<= sgs->", "5629": "<= size ? 0 : saveable - size;\n}\n\n\nint hibernate_preallocate_memory(void)\n{\n\tstruct zone *zone;\n\tunsigned long saveable, size, max_size, count, highmem, pages = 0;\n\tunsigned long alloc, save_highmem, pages_highmem, avail_normal;\n\tktime_t start, stop;\n\tint error;\n\n\tprintk(kern_info \"pm: preallocating image memory... \");\n\tstart = ktime_get();\n\n\terror = memory_bm_create(&orig_bm, gfp_image, pg_any);\n\tif (error)\n\t\tgoto err_out;\n\n\terror = memory_bm_create(&copy_bm, gfp_image, pg_any);\n\tif (error)\n\t\tgoto err_out;\n\n\talloc_normal = 0;\n\talloc_highmem = 0;\n\n\t\n\tsave_highmem = count_highmem_pages();\n\tsaveable = count_data_pages();\n\n\t\n\tcount = saveable;\n\tsaveable += save_highmem;\n\thighmem = save_highmem;\n\tsize = 0;\n\tfor_each_populated_zone(zone) {\n\t\tsize += snapshot_additional_pages(zone);\n\t\tif (is_highmem(zone))\n\t\t\thighmem += zone_page_state(zone, nr_free_pages);\n\t\telse\n\t\t\tcount += zone_page_state(zone, nr_free_pages);\n\t}\n\tavail_normal = count;\n\tcount += highmem;\n\tcount -= totalreserve_pages;\n\n\t\n\tsize += page_key_additional_pages(saveable);\n\n\t\n\tmax_size = (count - (size + pages_for_io)) / 2\n\t\t\t- 2 * div_round_up(reserved_size, page_size);\n\t\n\tsize = div_round_up(image_size, page_size);\n\tif (size >", "5630": "<= size; i++, j++) {\n\t\tstruct audit_tree *s;\n\t\tif (&chunk->", "5631": "<= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t\n\tdefault:\n\t\tdiag = kdb_badwidth;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}\n\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t\n\tdefault:\n\t\tdiag = kdb_badwidth;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}\n\n\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\t\n\tdefault:\n\t\tdiag = kdb_badwidth;\n\t\tkdb_printf(\"kdb_putword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}\n\n\n\n\n#define unrunnable\t(1ul << (8*sizeof(unsigned long) - 1))\n#define running\t\t(1ul << (8*sizeof(unsigned long) - 2))\n#define idle\t\t(1ul << (8*sizeof(unsigned long) - 3))\n#define daemon\t\t(1ul << (8*sizeof(unsigned long) - 4))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"ps\");\n\t\tif (!s)\n\t\t\ts = \"drstczeu\";\t\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'd':\n\t\t\tres |= task_uninterruptible;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tres |= running;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tres |= task_interruptible;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tres |= task_stopped;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tres |= task_traced;\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\tres |= exit_zombie << 16;\n\t\t\tbreak;\n\t\tcase 'e':\n\t\t\tres |= exit_dead << 16;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tres |= unrunnable;\n\t\t\tbreak;\n\t\tcase 'i':\n\t\t\tres |= idle;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tres |= daemon;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tres = ~0ul;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}\n\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'e';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->", "5632": "<= sizeof(ms))\n\t\treturn -ebadmsg;\n\n\tmemcpy(&ms, mod + (modlen - sizeof(ms)), sizeof(ms));\n\tmodlen -= sizeof(ms);\n\n\tsig_len = be32_to_cpu(ms.sig_len);\n\tif (sig_len >", "5633": "<= skb_tail_pointer(skb))\n\t\treturn ptr;\n\n\treturn null;\n}\n\nstruct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = gfp_kernel | __gfp_highmem | __gfp_zero |\n\t\t\t  gfp_extra_flags;\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *fp;\n\n\tsize = round_up(size, page_size);\n\tfp = __vmalloc(size, gfp_flags, page_kernel);\n\tif (fp == null)\n\t\treturn null;\n\n\taux = kzalloc(sizeof(*aux), gfp_kernel | gfp_extra_flags);\n\tif (aux == null) {\n\t\tvfree(fp);\n\t\treturn null;\n\t}\n\n\tfp->", "5634": "<= slot_addr && slot_addr < vma_end) {\n\t\tunsigned long offset;\n\t\tint slot_nr;\n\n\t\toffset = slot_addr - area->", "5635": "<= start && end <= p->", "5636": "<= start && res->", "5637": "<= start) {\n\t\t\t\tpr_warn(\"crashkernel: end <= start\\n\");\n\t\t\t\treturn -einval;\n\t\t\t}\n\t\t}\n\n\t\tif (*cur != ':') {\n\t\t\tpr_warn(\"crashkernel: ':' expected\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t\tcur++;\n\n\t\tsize = memparse(cur, &tmp);\n\t\tif (cur == tmp) {\n\t\t\tpr_warn(\"memory value expected\\n\");\n\t\t\treturn -einval;\n\t\t}\n\t\tcur = tmp;\n\t\tif (size >", "5638": "<= suspend) {\n\t\t\tacct->", "5639": "<= task->", "5640": "<= task_rlimit(p, rlimit_nice) ||\n\t\tcapable(cap_sys_nice));\n}\n\n#ifdef __arch_want_sys_nice\n\n\nsyscall_define1(nice, int, increment)\n{\n\tlong nice, retval;\n\n\t\n\tincrement = clamp(increment, -nice_width, nice_width);\n\tnice = task_nice(current) + increment;\n\n\tnice = clamp_val(nice, min_nice, max_nice);\n\tif (increment < 0 && !can_nice(current, nice))\n\t\treturn -eperm;\n\n\tretval = security_task_setnice(current, nice);\n\tif (retval)\n\t\treturn retval;\n\n\tset_user_nice(current, nice);\n\treturn 0;\n}\n\n#endif\n\n\nint task_prio(const struct task_struct *p)\n{\n\treturn p->", "5641": "<= test_max; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}\n\nstatic ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tconst char * const *s;\n\tint level;\n\tchar *p;\n\tint len;\n\tint error = -einval;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\n\tlevel = test_first;\n\tfor (s = &pm_tests[level]; level <= test_max; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep();\n\n\treturn error ? error : n;\n}\n\npower_attr(pm_test);\n#endif \n\n#ifdef config_debug_fs\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase suspend_freeze:\n\t\treturn \"freeze\";\n\tcase suspend_prepare:\n\t\treturn \"prepare\";\n\tcase suspend_suspend:\n\t\treturn \"suspend\";\n\tcase suspend_suspend_noirq:\n\t\treturn \"suspend_noirq\";\n\tcase suspend_resume_noirq:\n\t\treturn \"resume_noirq\";\n\tcase suspend_resume:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}\n\nstatic int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + rec_failed_num - 1;\n\tlast_dev %= rec_failed_num;\n\tlast_errno = suspend_stats.last_failed_errno + rec_failed_num - 1;\n\tlast_errno %= rec_failed_num;\n\tlast_step = suspend_stats.last_failed_step + rec_failed_num - 1;\n\tlast_step %= rec_failed_num;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < rec_failed_num; i++) {\n\t\tindex = last_dev + rec_failed_num - i;\n\t\tindex %= rec_failed_num;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < rec_failed_num; i++) {\n\t\tindex = last_errno + rec_failed_num - i;\n\t\tindex %= rec_failed_num;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < rec_failed_num; i++) {\n\t\tindex = last_step + rec_failed_num - i;\n\t\tindex %= rec_failed_num;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}\n\nstatic int suspend_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, suspend_stats_show, null);\n}\n\nstatic const struct file_operations suspend_stats_operations = {\n\t.open           = suspend_stats_open,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = single_release,\n};\n\nstatic int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", s_ifreg | s_irugo,\n\t\t\tnull, null, &suspend_stats_operations);\n\treturn 0;\n}\n\nlate_initcall(pm_debugfs_init);\n#endif \n\n#endif \n\n#ifdef config_pm_sleep_debug\n\nbool pm_print_times_enabled;\n\nstatic ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}\n\nstatic ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -einval;\n\n\tif (val >", "5642": "<= tick_period.tv64)\n\t\treturn;\n\n\ttick_nohz_restart(ts, now);\n#endif\n}\n\nstatic inline void tick_nohz_irq_enter(void)\n{\n\tstruct tick_sched *ts = this_cpu_ptr(&tick_cpu_sched);\n\tktime_t now;\n\n\tif (!ts->", "5643": "<= tmp->", "5644": "<= tp->", "5645": "<= upper_last) &&\n\t\t    (prev_upper_last >", "5646": "<= usec_per_sec && !(usec_per_sec % hz)\n\treturn (u + (usec_per_sec / hz) - 1) / (usec_per_sec / hz);\n#elif hz >", "5647": "<= usec_per_sec && !(usec_per_sec % hz)\n\treturn (usec_per_sec / hz) * j;\n#elif hz >", "5648": "<= vma->", "5649": "<= wl_gc_count_max)\n\t\treturn;\n\n\tnow = ktime_get();\n\tlist_for_each_entry_safe_reverse(wl, aux, &wakelocks_lru_list, lru) {\n\t\tu64 idle_time_ns;\n\t\tbool active;\n\n\t\tspin_lock_irq(&wl->", "5650": "<==%s() = ok\\n\", __func__);\n\treturn pks;\n\nerror:\n\tkfree(pks);\nerror_no_pks:\n\tcrypto_free_shash(tfm);\n\tpr_devel(\"<==%s() = %d\\n\", __func__, ret);\n\treturn err_ptr(ret);\n}\n\n\nstatic int mod_extract_mpi_array(struct public_key_signature *pks,\n\t\t\t\t const void *data, size_t len)\n{\n\tsize_t nbytes;\n\tmpi mpi;\n\n\tif (len < 3)\n\t\treturn -ebadmsg;\n\tnbytes = ((const u8 *)data)[0] << 8 | ((const u8 *)data)[1];\n\tdata += 2;\n\tlen -= 2;\n\tif (len != nbytes)\n\t\treturn -ebadmsg;\n\n\tmpi = mpi_read_raw_data(data, nbytes);\n\tif (!mpi)\n\t\treturn -enomem;\n\tpks->", "5651": "<asm-generic/mutex-null.h>", "5652": "<asm-generic/sections.h>", "5653": "<asm/bitsperlong.h>", "5654": "<asm/byteorder.h>", "5655": "<asm/cacheflush.h>", "5656": "<asm/div64.h>", "5657": "<asm/dma.h>", "5658": "<asm/errno.h>", "5659": "<asm/io.h>", "5660": "<asm/irq_regs.h>", "5661": "<asm/local.h>", "5662": "<asm/mcs_spinlock.h>", "5663": "<asm/mmu_context.h>", "5664": "<asm/mutex.h>", "5665": "<asm/nmi.h>", "5666": "<asm/page.h>", "5667": "<asm/param.h>", "5668": "<asm/paravirt.h>", "5669": "<asm/pgalloc.h>", "5670": "<asm/pgtable.h>", "5671": "<asm/processor.h>", "5672": "<asm/ptrace.h>", "5673": "<asm/qrwlock.h>", "5674": "<asm/sections.h>", "5675": "<asm/setup.h>", "5676": "<asm/siginfo.h>", "5677": "<asm/stacktrace.h>", "5678": "<asm/switch_to.h>", "5679": "<asm/syscall.h>", "5680": "<asm/timex.h>", "5681": "<asm/tlb.h>", "5682": "<asm/tlbflush.h>", "5683": "<asm/types.h>", "5684": "<asm/uaccess.h>", "5685": "<asm/unaligned.h>", "5686": "<asm/unistd.h>", "5687": "<audit_nr_filters; i++) {\n\t\tlist_for_each_entry(r, &audit_rules_list[i], list) {\n\t\t\tstruct audit_rule_data *data;\n\n\t\t\tdata = audit_krule_to_data(r);\n\t\t\tif (unlikely(!data))\n\t\t\t\tbreak;\n\t\t\tskb = audit_make_reply(portid, seq, audit_list_rules,\n\t\t\t\t\t       0, 1, data,\n\t\t\t\t\t       sizeof(*data) + data->", "5688": "<crypto/hash.h>", "5689": "<crypto/sha.h>", "5690": "<event>", "5691": "<filter>", "5692": "<function>", "5693": "<generated/utsrelease.h>", "5694": "<interrupt>", "5695": "<keys/asymmetric-type.h>", "5696": "<keys/system_keyring.h>", "5697": "<keys/user-type.h>", "5698": "<linux/acct.h>", "5699": "<linux/acpi.h>", "5700": "<linux/aio.h>", "5701": "<linux/alarmtimer.h>", "5702": "<linux/anon_inodes.h>", "5703": "<linux/async.h>", "5704": "<linux/atomic.h>", "5705": "<linux/audit.h>", "5706": "<linux/backing-dev.h>", "5707": "<linux/binfmts.h>", "5708": "<linux/bio.h>", "5709": "<linux/bitmap.h>", "5710": "<linux/bitops.h>", "5711": "<linux/blkdev.h>", "5712": "<linux/blktrace_api.h>", "5713": "<linux/bootmem.h>", "5714": "<linux/bpf.h>", "5715": "<linux/bsearch.h>", "5716": "<linux/bug.h>", "5717": "<linux/cache.h>", "5718": "<linux/capability.h>", "5719": "<linux/cgroup.h>", "5720": "<linux/cgroup_subsys.h>", "5721": "<linux/cgroupstats.h>", "5722": "<linux/circ_buf.h>", "5723": "<linux/clockchips.h>", "5724": "<linux/clocksource.h>", "5725": "<linux/cn_proc.h>", "5726": "<linux/compaction.h>", "5727": "<linux/compat.h>", "5728": "<linux/compiler.h>", "5729": "<linux/completion.h>", "5730": "<linux/console.h>", "5731": "<linux/context_tracking.h>", "5732": "<linux/coredump.h>", "5733": "<linux/cpu.h>", "5734": "<linux/cpu_pm.h>", "5735": "<linux/cpuidle.h>", "5736": "<linux/cpumask.h>", "5737": "<linux/cpuset.h>", "5738": "<linux/crash_dump.h>", "5739": "<linux/crc32.h>", "5740": "<linux/cred.h>", "5741": "<linux/ctype.h>", "5742": "<linux/dcache.h>", "5743": "<linux/dcookies.h>", "5744": "<linux/debug_locks.h>", "5745": "<linux/debugfs.h>", "5746": "<linux/delay.h>", "5747": "<linux/delayacct.h>", "5748": "<linux/device.h>", "5749": "<linux/dnotify.h>", "5750": "<linux/elf.h>", "5751": "<linux/elfcore.h>", "5752": "<linux/err.h>", "5753": "<linux/errno.h>", "5754": "<linux/export.h>", "5755": "<linux/fcntl.h>", "5756": "<linux/fdtable.h>", "5757": "<linux/file.h>", "5758": "<linux/filter.h>", "5759": "<linux/freezer.h>", "5760": "<linux/fs.h>", "5761": "<linux/fs_pin.h>", "5762": "<linux/fs_struct.h>", "5763": "<linux/fsnotify_backend.h>", "5764": "<linux/ftrace.h>", "5765": "<linux/ftrace_event.h>", "5766": "<linux/futex.h>", "5767": "<linux/genhd.h>", "5768": "<linux/getcpu.h>", "5769": "<linux/gfp.h>", "5770": "<linux/hardirq.h>", "5771": "<linux/hash.h>", "5772": "<linux/hashtable.h>", "5773": "<linux/highmem.h>", "5774": "<linux/highuid.h>", "5775": "<linux/hrtimer.h>", "5776": "<linux/hugetlb.h>", "5777": "<linux/hw_breakpoint.h>", "5778": "<linux/idr.h>", "5779": "<linux/init.h>", "5780": "<linux/init_task.h>", "5781": "<linux/initrd.h>", "5782": "<linux/inotify.h>", "5783": "<linux/interrupt.h>", "5784": "<linux/io.h>", "5785": "<linux/iocontext.h>", "5786": "<linux/ioport.h>", "5787": "<linux/ipc_namespace.h>", "5788": "<linux/irq.h>", "5789": "<linux/irq_work.h>", "5790": "<linux/irqdesc.h>", "5791": "<linux/irqdomain.h>", "5792": "<linux/irqflags.h>", "5793": "<linux/jhash.h>", "5794": "<linux/jiffies.h>", "5795": "<linux/jump_label.h>", "5796": "<linux/jump_label_ratelimit.h>", "5797": "<linux/kallsyms.h>", "5798": "<linux/kbuild.h>", "5799": "<linux/kcmp.h>", "5800": "<linux/kdb.h>", "5801": "<linux/kdebug.h>", "5802": "<linux/kernel.h>", "5803": "<linux/kernel_stat.h>", "5804": "<linux/kexec.h>", "5805": "<linux/key-type.h>", "5806": "<linux/key.h>", "5807": "<linux/keyctl.h>", "5808": "<linux/kgdb.h>", "5809": "<linux/khugepaged.h>", "5810": "<linux/kmemcheck.h>", "5811": "<linux/kmemleak.h>", "5812": "<linux/kmod.h>", "5813": "<linux/kmsg_dump.h>", "5814": "<linux/kobject.h>", "5815": "<linux/kprobes.h>", "5816": "<linux/kref.h>", "5817": "<linux/ksm.h>", "5818": "<linux/kthread.h>", "5819": "<linux/ktime.h>", "5820": "<linux/kvm_para.h>", "5821": "<linux/latencytop.h>", "5822": "<linux/lglock.h>", "5823": "<linux/license.h>", "5824": "<linux/limits.h>", "5825": "<linux/linkage.h>", "5826": "<linux/list.h>", "5827": "<linux/livepatch.h>", "5828": "<linux/lockdep.h>", "5829": "<linux/log2.h>", "5830": "<linux/lzo.h>", "5831": "<linux/magic.h>", "5832": "<linux/math64.h>", "5833": "<linux/memblock.h>", "5834": "<linux/memcontrol.h>", "5835": "<linux/memory.h>", "5836": "<linux/mempolicy.h>", "5837": "<linux/migrate.h>", "5838": "<linux/miscdevice.h>", "5839": "<linux/mm.h>", "5840": "<linux/mm_types.h>", "5841": "<linux/mman.h>", "5842": "<linux/mmiotrace.h>", "5843": "<linux/mmu_notifier.h>", "5844": "<linux/mmzone.h>", "5845": "<linux/mnt_namespace.h>", "5846": "<linux/module.h>", "5847": "<linux/moduleloader.h>", "5848": "<linux/moduleparam.h>", "5849": "<linux/mount.h>", "5850": "<linux/mqueue.h>", "5851": "<linux/msi.h>", "5852": "<linux/mutex.h>", "5853": "<linux/namei.h>", "5854": "<linux/net.h>", "5855": "<linux/netdevice.h>", "5856": "<linux/netlink.h>", "5857": "<linux/nfs_fs.h>", "5858": "<linux/nmi.h>", "5859": "<linux/nodemask.h>", "5860": "<linux/notifier.h>", "5861": "<linux/nsproxy.h>", "5862": "<linux/numa.h>", "5863": "<linux/of.h>", "5864": "<linux/of_address.h>", "5865": "<linux/of_irq.h>", "5866": "<linux/oom.h>", "5867": "<linux/osq_lock.h>", "5868": "<linux/padata.h>", "5869": "<linux/page-flags.h>", "5870": "<linux/pagemap.h>", "5871": "<linux/pci.h>", "5872": "<linux/percpu-rwsem.h>", "5873": "<linux/percpu.h>", "5874": "<linux/perf_event.h>", "5875": "<linux/personality.h>", "5876": "<linux/pfn.h>", "5877": "<linux/pid.h>", "5878": "<linux/pid_namespace.h>", "5879": "<linux/pipe_fs_i.h>", "5880": "<linux/platform_device.h>", "5881": "<linux/pm-trace.h>", "5882": "<linux/pm.h>", "5883": "<linux/pm_qos.h>", "5884": "<linux/pm_wakeup.h>", "5885": "<linux/poison.h>", "5886": "<linux/poll.h>", "5887": "<linux/posix-clock.h>", "5888": "<linux/posix-timers.h>", "5889": "<linux/prctl.h>", "5890": "<linux/preempt.h>", "5891": "<linux/prefetch.h>", "5892": "<linux/printk.h>", "5893": "<linux/proc_fs.h>", "5894": "<linux/proc_ns.h>", "5895": "<linux/profile.h>", "5896": "<linux/projid.h>", "5897": "<linux/ptrace.h>", "5898": "<linux/pvclock_gtod.h>", "5899": "<linux/radix-tree.h>", "5900": "<linux/random.h>", "5901": "<linux/range.h>", "5902": "<linux/ratelimit.h>", "5903": "<linux/rbtree.h>", "5904": "<linux/rculist.h>", "5905": "<linux/rcupdate.h>", "5906": "<linux/reboot.h>", "5907": "<linux/regset.h>", "5908": "<linux/resource.h>", "5909": "<linux/resource_ext.h>", "5910": "<linux/ring_buffer.h>", "5911": "<linux/rmap.h>", "5912": "<linux/rtc.h>", "5913": "<linux/rtmutex.h>", "5914": "<linux/rwlock.h>", "5915": "<linux/rwsem.h>", "5916": "<linux/sched.h>", "5917": "<linux/sched/deadline.h>", "5918": "<linux/sched/rt.h>", "5919": "<linux/sched/sysctl.h>", "5920": "<linux/seccomp.h>", "5921": "<linux/securebits.h>", "5922": "<linux/security.h>", "5923": "<linux/sem.h>", "5924": "<linux/semaphore.h>", "5925": "<linux/seq_file.h>", "5926": "<linux/seqlock.h>", "5927": "<linux/serial_core.h>", "5928": "<linux/shmem_fs.h>", "5929": "<linux/signal.h>", "5930": "<linux/signalfd.h>", "5931": "<linux/skbuff.h>", "5932": "<linux/slab.h>", "5933": "<linux/smp.h>", "5934": "<linux/smpboot.h>", "5935": "<linux/socket.h>", "5936": "<linux/sort.h>", "5937": "<linux/spinlock.h>", "5938": "<linux/spinlock_types.h>", "5939": "<linux/splice.h>", "5940": "<linux/srcu.h>", "5941": "<linux/stackprotector.h>", "5942": "<linux/stacktrace.h>", "5943": "<linux/stat.h>", "5944": "<linux/static_key.h>", "5945": "<linux/stddef.h>", "5946": "<linux/stop_machine.h>", "5947": "<linux/string.h>", "5948": "<linux/stringify.h>", "5949": "<linux/sunrpc/debug.h>", "5950": "<linux/suspend.h>", "5951": "<linux/suspend_ioctls.h>", "5952": "<linux/swap.h>", "5953": "<linux/swapops.h>", "5954": "<linux/syscalls.h>", "5955": "<linux/syscore_ops.h>", "5956": "<linux/sysctl.h>", "5957": "<linux/sysfs.h>", "5958": "<linux/syslog.h>", "5959": "<linux/sysrq.h>", "5960": "<linux/task_io_accounting_ops.h>", "5961": "<linux/task_work.h>", "5962": "<linux/taskstats.h>", "5963": "<linux/taskstats_kern.h>", "5964": "<linux/thread_info.h>", "5965": "<linux/threads.h>", "5966": "<linux/tick.h>", "5967": "<linux/time.h>", "5968": "<linux/timecounter.h>", "5969": "<linux/timekeeper_internal.h>", "5970": "<linux/timer.h>", "5971": "<linux/timerqueue.h>", "5972": "<linux/times.h>", "5973": "<linux/timex.h>", "5974": "<linux/topology.h>", "5975": "<linux/torture.h>", "5976": "<linux/trace_clock.h>", "5977": "<linux/trace_seq.h>", "5978": "<linux/tracefs.h>", "5979": "<linux/tracehook.h>", "5980": "<linux/tracepoint.h>", "5981": "<linux/tsacct_kern.h>", "5982": "<linux/tty.h>", "5983": "<linux/tty_driver.h>", "5984": "<linux/types.h>", "5985": "<linux/uaccess.h>", "5986": "<linux/uidgid.h>", "5987": "<linux/uio.h>", "5988": "<linux/unistd.h>", "5989": "<linux/uprobes.h>", "5990": "<linux/usb.h>", "5991": "<linux/user-return-notifier.h>", "5992": "<linux/user_namespace.h>", "5993": "<linux/uts.h>", "5994": "<linux/utsname.h>", "5995": "<linux/vermagic.h>", "5996": "<linux/version.h>", "5997": "<linux/vfs.h>", "5998": "<linux/vmacache.h>", "5999": "<linux/vmalloc.h>", "6000": "<linux/vmstat.h>", "6001": "<linux/wait.h>", "6002": "<linux/workqueue.h>", "6003": "<linux/writeback.h>", "6004": "<linux/ww_mutex.h>", "6005": "<module-name>", "6006": "<net/genetlink.h>", "6007": "<net/net_namespace.h>", "6008": "<net/netlink.h>", "6009": "<net/netns/generic.h>", "6010": "<net/sock.h>", "6011": "<scsi/sg.h>", "6012": "<stdarg.h>", "6013": "<system>", "6014": "<trace/define_trace.h>", "6015": "<trace/events/block.h>", "6016": "<trace/events/context_tracking.h>", "6017": "<trace/events/irq.h>", "6018": "<trace/events/lock.h>", "6019": "<trace/events/module.h>", "6020": "<trace/events/power.h>", "6021": "<trace/events/printk.h>", "6022": "<trace/events/rcu.h>", "6023": "<trace/events/rpm.h>", "6024": "<trace/events/sched.h>", "6025": "<trace/events/signal.h>", "6026": "<trace/events/syscalls.h>", "6027": "<trace/events/task.h>", "6028": "<trace/events/timer.h>", "6029": "<trace/syscall.h>", "6030": "<trigger>", "6031": "<uapi/linux/limits.h>", "6032": "<uapi/linux/module.h>", "6033": "<uapi/linux/mqueue.h>", "6034": "<user stack trace>", "6035": "=", "6036": "==", "6037": ">", "6038": ">=", "6039": "[", "6040": "\\", "6041": "]", "6042": "^", "6043": "_", "6044": "_____i", "6045": "_____ret", "6046": "____cacheline_aligned", "6047": "____cacheline_aligned_in_smp", "6048": "____cacheline_internodealigned_in_smp", "6049": "____call_usermodehelper", "6050": "____ftrace_", "6051": "____ftrace_check_", "6052": "___might_sleep", "6053": "___n", "6054": "___p", "6055": "___pd", "6056": "___ps", "6057": "___r", "6058": "___ret", "6059": "__account_cfs_rq_runtime", "6060": "__account_scheduler_latency", "6061": "__account_system_time", "6062": "__acct_update_integrals", "6063": "__acquire", "6064": "__acquires", "6065": "__add_event_to_tracers", "6066": "__add_hash_entry", "6067": "__add_wait_queue", "6068": "__add_wait_queue_tail", "6069": "__adjust_resource", "6070": "__aligned", "6071": "__alignof__", "6072": "__alloc_filter", "6073": "__alloc_percpu", "6074": "__alloc_pred_stack", "6075": "__alloc_preds", "6076": "__alloc_reserved_percpu", "6077": "__alloc_workqueue_key", "6078": "__always_inline", "6079": "__always_unused", "6080": "__arch_has_ka_restorer", "6081": "__arch_has_sa_restorer", "6082": "__arch_has_vtime_account", "6083": "__arch_has_vtime_task_switch", "6084": "__arch_irq_exit_irqs_disabled", "6085": "__arch_irq_stat", "6086": "__arch_rw_lock_unlocked", "6087": "__arch_si_trapno", "6088": "__arch_sigsys", "6089": "__arch_spin_lock_unlocked", "6090": "__arch_um__", "6091": "__arch_want_compat_sys_time", "6092": "__arch_want_sys_alarm", "6093": "__arch_want_sys_clone", "6094": "__arch_want_sys_fork", "6095": "__arch_want_sys_gethostname", "6096": "__arch_want_sys_getpgrp", "6097": "__arch_want_sys_old_getrlimit", "6098": "__arch_want_sys_old_uname", "6099": "__arch_want_sys_pause", "6100": "__arch_want_sys_signal", "6101": "__arch_want_sys_sigpending", "6102": "__arch_want_sys_sigprocmask", "6103": "__arch_want_sys_time", "6104": "__arch_want_sys_vfork", "6105": "__arm_kprobe", "6106": "__array", "6107": "__array_desc", "6108": "__assign_fetch_type", "6109": "__async_schedule", "6110": "__atomic_notifier_call_chain", "6111": "__attr", "6112": "__attr_null", "6113": "__attr_ro", "6114": "__attr_rw", "6115": "__attribute__", "6116": "__audit_bprm", "6117": "__audit_fd_pair", "6118": "__audit_file", "6119": "__audit_free", "6120": "__audit_getname", "6121": "__audit_inode", "6122": "__audit_inode_child", "6123": "__audit_ipc_obj", "6124": "__audit_ipc_set_perm", "6125": "__audit_log_bprm_fcaps", "6126": "__audit_log_capset", "6127": "__audit_mmap_fd", "6128": "__audit_mq_getsetattr", "6129": "__audit_mq_notify", "6130": "__audit_mq_open", "6131": "__audit_mq_sendrecv", "6132": "__audit_ptrace", "6133": "__audit_reusename", "6134": "__audit_seccomp", "6135": "__audit_signal_info", "6136": "__audit_sockaddr", "6137": "__audit_socketcall", "6138": "__audit_syscall_entry", "6139": "__audit_syscall_exit", "6140": "__b", "6141": "__bad_type_size", "6142": "__be64", "6143": "__bfs", "6144": "__big_endian", "6145": "__blk_add_trace", "6146": "__blk_ta_backmerge", "6147": "__blk_ta_bounce", "6148": "__blk_ta_complete", "6149": "__blk_ta_frontmerge", "6150": "__blk_ta_getrq", "6151": "__blk_ta_insert", "6152": "__blk_ta_issue", "6153": "__blk_ta_plug", "6154": "__blk_ta_queue", "6155": "__blk_ta_remap", "6156": "__blk_ta_requeue", "6157": "__blk_ta_sleeprq", "6158": "__blk_ta_split", "6159": "__blk_ta_unplug_io", "6160": "__blk_ta_unplug_timer", "6161": "__blocking_notifier_call_chain", "6162": "__bpf_call_base", "6163": "__bpf_func_max_id", "6164": "__bpf_prog_free", "6165": "__bpf_prog_run", "6166": "__buffer_unlock_commit", "6167": "__builtin_return_address", "6168": "__builtin_types_compatible_p", "6169": "__cacheline_aligned", "6170": "__cacheline_aligned_in_smp", "6171": "__calc_delta", "6172": "__call_rcu", "6173": "__call_rcu_core", "6174": "__call_rcu_nocb", "6175": "__call_rcu_nocb_enqueue", "6176": "__call_usermodehelper", "6177": "__cancel_work_timer", "6178": "__cap_empty_set", "6179": "__cfs_bandwidth_used", "6180": "__cfs_schedulable", "6181": "__cftype_not_on_dfl", "6182": "__cftype_only_on_dfl", "6183": "__cgroup_procs_write", "6184": "__change_pid", "6185": "__checkparam_dl", "6186": "__cleanup_sighand", "6187": "__clear_bit", "6188": "__clear_buddies_last", "6189": "__clear_buddies_next", "6190": "__clear_buddies_skip", "6191": "__clear_sched_clock_stable", "6192": "__clockevents_set_state", "6193": "__clockevents_try_unbind", "6194": "__clockevents_unbind", "6195": "__clockevents_update_freq", "6196": "__common_field", "6197": "__compat_get_timespec", "6198": "__compat_get_timeval", "6199": "__compat_put_timespec", "6200": "__compat_put_timeval", "6201": "__compat_save_altstack", "6202": "__compute_runnable_contrib", "6203": "__cond_lock", "6204": "__cond_resched_lock", "6205": "__cond_resched_softirq", "6206": "__context_tracking_task_switch", "6207": "__copy_from_user_inatomic", "6208": "__copy_insn", "6209": "__copy_to_user", "6210": "__count", "6211": "__cpu", "6212": "__cpu_die", "6213": "__cpu_disable", "6214": "__cpu_lockdep_stats", "6215": "__cpu_notify", "6216": "__cpu_up", "6217": "__cpuinit", "6218": "__cpuset_memory_pressure_bump", "6219": "__cpuset_node_allowed", "6220": "__cq_dequeue", "6221": "__cq_empty", "6222": "__cq_enqueue", "6223": "__cq_full", "6224": "__cq_get_elem_count", "6225": "__cq_init", "6226": "__create_xol_area", "6227": "__current_clr_polling", "6228": "__current_kernel_time", "6229": "__current_set_polling", "6230": "__data", "6231": "__debug_atomic_inc", "6232": "__debug_locks_off", "6233": "__default_fetch_type", "6234": "__delay", "6235": "__delayacct_add_tsk", "6236": "__delayacct_blkio_end", "6237": "__delayacct_blkio_start", "6238": "__delayacct_blkio_ticks", "6239": "__delayacct_freepages_end", "6240": "__delayacct_freepages_start", "6241": "__delayacct_tsk_init", "6242": "__dequeue_entity", "6243": "__dequeue_rt_entity", "6244": "__dequeue_signal", "6245": "__devm_release_region", "6246": "__devm_request_region", "6247": "__disable_irq", "6248": "__disable_irq_nosync", "6249": "__disable_kprobe", "6250": "__disable_runtime", "6251": "__disable_trace_on_warning", "6252": "__disarm_kprobe", "6253": "__dl_add", "6254": "__dl_clear", "6255": "__dl_clear_params", "6256": "__dl_overflow", "6257": "__do_adjtimex", "6258": "__do_proc_dointvec", "6259": "__do_proc_doulongvec_minmax", "6260": "__do_softirq", "6261": "__down", "6262": "__down_common", "6263": "__down_interruptible", "6264": "__down_killable", "6265": "__down_read", "6266": "__down_read_trylock", "6267": "__down_timeout", "6268": "__down_trylock_console_sem", "6269": "__down_write", "6270": "__down_write_nested", "6271": "__down_write_trylock", "6272": "__downgrade_write", "6273": "__dynamic_array", "6274": "__enable_irq", "6275": "__enable_runtime", "6276": "__enqueue_entity", "6277": "__enqueue_rt_entity", "6278": "__entry", "6279": "__event_", "6280": "__exit", "6281": "__fatal_signal_pending", "6282": "__ffs", "6283": "__field", "6284": "__field_desc", "6285": "__field_struct", "6286": "__file__", "6287": "__find_event_field", "6288": "__find_resource", "6289": "__find_uprobe", "6290": "__flush_itimer_signals", "6291": "__flush_signals", "6292": "__force", "6293": "__fput_sync", "6294": "__free_domain_allocs", "6295": "__free_event", "6296": "__free_filter", "6297": "__free_ftrace_hash_rcu", "6298": "__free_insn_slot", "6299": "__free_irq", "6300": "__free_page", "6301": "__free_percpu_irq", "6302": "__free_pred_stack", "6303": "__free_preds", "6304": "__free_subsystem_filter", "6305": "__ftrace_bad_type", "6306": "__ftrace_event_enable_disable", "6307": "__ftrace_function_set_filter", "6308": "__ftrace_graph_entry", "6309": "__ftrace_hash_rec_update", "6310": "__ftrace_hash_update_ipmodify", "6311": "__ftrace_modify_code", "6312": "__ftrace_ops_list_func", "6313": "__ftrace_replace_code", "6314": "__ftrace_set_clr_event", "6315": "__ftrace_set_clr_event_nolock", "6316": "__ftrace_vbprintk", "6317": "__ftrace_vprintk", "6318": "__func__", "6319": "__gcov_flush", "6320": "__gcov_init", "6321": "__gcov_merge_add", "6322": "__gcov_merge_delta", "6323": "__gcov_merge_ior", "6324": "__gcov_merge_single", "6325": "__gcov_merge_time_profile", "6326": "__generating_bounds_h", "6327": "__get_cached_msi_msg", "6328": "__get_cpu_context", "6329": "__get_data_size", "6330": "__get_free_page", "6331": "__get_free_pages", "6332": "__get_insn_slot", "6333": "__get_key_name", "6334": "__get_system", "6335": "__get_system_dir", "6336": "__get_user", "6337": "__get_valid_kprobe", "6338": "__getname", "6339": "__getnstimeofday64", "6340": "__getparam_dl", "6341": "__gfp_cold", "6342": "__gfp_fs", "6343": "__gfp_hardwall", "6344": "__gfp_high", "6345": "__gfp_highmem", "6346": "__gfp_nomemalloc", "6347": "__gfp_noretry", "6348": "__gfp_notrack_false_positive", "6349": "__gfp_nowarn", "6350": "__gfp_thisnode", "6351": "__gfp_wait", "6352": "__gfp_zero", "6353": "__gnuc__", "6354": "__gnuc_minor__", "6355": "__group_send_sig_info", "6356": "__handle_domain_irq", "6357": "__hardpps", "6358": "__hibernation_after_last", "6359": "__hotcpu_notifier", "6360": "__hppa__", "6361": "__hrtick_restart", "6362": "__hrtick_start", "6363": "__hrtimer_start_range_ns", "6364": "__hrtimer_tasklet_trampoline", "6365": "__i386__", "6366": "__init", "6367": "__init_kthread_worker", "6368": "__init_rwsem", "6369": "__init_srcu_struct", "6370": "__init_waitqueue_head", "6371": "__init_work", "6372": "__initcall", "6373": "__initconst", "6374": "__initdata", "6375": "__initdata_or_module", "6376": "__insert_resource", "6377": "__insert_uprobe", "6378": "__internal_add_timer", "6379": "__iomem", "6380": "__irq_alloc_descs", "6381": "__irq_domain_add", "6382": "__irq_domain_alloc_irqs", "6383": "__irq_enter", "6384": "__irq_get_desc_lock", "6385": "__irq_put_desc_unlock", "6386": "__irq_set_affinity", "6387": "__irq_set_handler", "6388": "__irq_set_trigger", "6389": "__irq_wake_thread", "6390": "__irqentry_text_end", "6391": "__irqf_timer", "6392": "__irqsoff_tracer_init", "6393": "__is_kfree_rcu_offset", "6394": "__is_ram", "6395": "__jump_label_mod_text_reserved", "6396": "__jump_label_mod_update", "6397": "__jump_label_text_reserved", "6398": "__jump_label_update", "6399": "__kernel__", "6400": "__kernel_param_lock", "6401": "__kernel_param_unlock", "6402": "__kernel_size_t", "6403": "__kernel_time_t", "6404": "__kernel_write", "6405": "__kernfs_create_file", "6406": "__kexec_load_purgatory", "6407": "__kgid_val", "6408": "__kill_pgrp_info", "6409": "__klp_disable_patch", "6410": "__klp_enable_patch", "6411": "__kprobe_trace_func", "6412": "__kprobes_text_start", "6413": "__kprojid_val", "6414": "__kretprobe_trace_func", "6415": "__kthread_bind", "6416": "__kthread_parkme", "6417": "__kthread_unpark", "6418": "__ktime_get_fast_ns", "6419": "__kuid_val", "6420": "__le16", "6421": "__line__", "6422": "__linux_mcs_spinlock_h", "6423": "__linux_rcu_h", "6424": "__list_del", "6425": "__local_bh_disable_ip", "6426": "__local_bh_enable", "6427": "__local_bh_enable_ip", "6428": "__lock_acquire", "6429": "__lock_acquired", "6430": "__lock_contended", "6431": "__lock_is_held", "6432": "__lock_release", "6433": "__lock_set_class", "6434": "__lock_task_sighand", "6435": "__lock_text_end", "6436": "__lock_text_start", "6437": "__lock_timer", "6438": "__lockdep_no_validate__", "6439": "__lockdep_trace_alloc", "6440": "__lockf", "6441": "__lockfunc", "6442": "__log_buf_len", "6443": "__m1", "6444": "__m2", "6445": "__max_nr_zones", "6446": "__maybe_unused", "6447": "__might_sleep", "6448": "__migrate_swap_task", "6449": "__migrate_task", "6450": "__mmdrop", "6451": "__mod_timer", "6452": "__modinit", "6453": "__module_address", "6454": "__module_get", "6455": "__module_text_address", "6456": "__modver_version_show", "6457": "__mutex_fastpath_lock", "6458": "__mutex_fastpath_lock_retval", "6459": "__mutex_fastpath_trylock", "6460": "__mutex_fastpath_unlock", "6461": "__mutex_init", "6462": "__mutex_initializer", "6463": "__mutex_lock_common", "6464": "__mutex_lock_interruptible_slowpath", "6465": "__mutex_lock_killable_slowpath", "6466": "__mutex_lock_slowpath", "6467": "__mutex_slowpath_needs_to_unlock", "6468": "__mutex_trylock_slowpath", "6469": "__mutex_unlock_common_slowpath", "6470": "__mutex_unlock_slowpath", "6471": "__name", "6472": "__need_more_worker", "6473": "__net_exit", "6474": "__net_init", "6475": "__net_initdata", "6476": "__new_uts_len", "6477": "__next", "6478": "__next_timer_interrupt", "6479": "__noreturn", "6480": "__normal_prio", "6481": "__nosavedata", "6482": "__note_gp_changes", "6483": "__nr_pageflags", "6484": "__nr_seccomp_exit", "6485": "__nr_seccomp_exit_32", "6486": "__nr_seccomp_read", "6487": "__nr_seccomp_read_32", "6488": "__nr_seccomp_sigreturn", "6489": "__nr_seccomp_sigreturn_32", "6490": "__nr_seccomp_write", "6491": "__nr_seccomp_write_32", "6492": "__old", "6493": "__old_uts_len", "6494": "__op", "6495": "__output_copy", "6496": "__output_skip", "6497": "__p", "6498": "__packed", "6499": "__padata_add_cpu", "6500": "__padata_free", "6501": "__padata_list_init", "6502": "__padata_remove_cpu", "6503": "__padata_set_cpumasks", "6504": "__padata_start", "6505": "__padata_stop", "6506": "__parse_bitfield_probe_arg", "6507": "__parse_crashkernel", "6508": "__pc", "6509": "__per_cpu_offset", "6510": "__percpu", "6511": "__percpu_init_rwsem", "6512": "__perf_event__output_id_sample", "6513": "__perf_event_count", "6514": "__perf_event_disable", "6515": "__perf_event_enable", "6516": "__perf_event_header__init_id", "6517": "__perf_event_init_context", "6518": "__perf_event_mark_enabled", "6519": "__perf_event_read", "6520": "__perf_event_sync_stat", "6521": "__perf_event_task_sched_in", "6522": "__perf_install_in_context", "6523": "__perf_mmap_to_page", "6524": "__perf_remove_from_context", "6525": "__pick_first_entity", "6526": "__pick_last_entity", "6527": "__pick_next_entity", "6528": "__pm_qos_update_request", "6529": "__pm_relax", "6530": "__pm_stay_awake", "6531": "__pm_wakeup_event", "6532": "__pn", "6533": "__pool", "6534": "__pop_pred_stack", "6535": "__posix_timers_find", "6536": "__prctl_check_order", "6537": "__preempt_count_add", "6538": "__preempt_count_sub", "6539": "__print_graph_headers_flags", "6540": "__print_lock_name", "6541": "__print_symbol", "6542": "__profile_flip_buffers", "6543": "__ptrace_detach", "6544": "__ptrace_link", "6545": "__ptrace_may_access", "6546": "__ptrace_unlink", "6547": "__push_pred_stack", "6548": "__put_chunk", "6549": "__put_cred", "6550": "__put_system", "6551": "__put_system_dir", "6552": "__put_task_struct", "6553": "__put_user", "6554": "__putname", "6555": "__queue_delayed_work", "6556": "__queue_work", "6557": "__r", "6558": "__raise_softirq_irqoff", "6559": "__raw_", "6560": "__raw_notifier_call_chain", "6561": "__raw_read_lock", "6562": "__raw_read_lock_bh", "6563": "__raw_read_lock_irq", "6564": "__raw_read_lock_irqsave", "6565": "__raw_read_trylock", "6566": "__raw_read_unlock", "6567": "__raw_read_unlock_bh", "6568": "__raw_read_unlock_irq", "6569": "__raw_read_unlock_irqrestore", "6570": "__raw_spin_lock", "6571": "__raw_spin_lock_bh", "6572": "__raw_spin_lock_init", "6573": "__raw_spin_lock_irq", "6574": "__raw_spin_lock_irqsave", "6575": "__raw_spin_lock_unlocked", "6576": "__raw_spin_trylock", "6577": "__raw_spin_trylock_bh", "6578": "__raw_spin_unlock", "6579": "__raw_spin_unlock_bh", "6580": "__raw_spin_unlock_irq", "6581": "__raw_spin_unlock_irqrestore", "6582": "__raw_write_lock", "6583": "__raw_write_lock_bh", "6584": "__raw_write_lock_irq", "6585": "__raw_write_lock_irqsave", "6586": "__raw_write_trylock", "6587": "__raw_write_unlock", "6588": "__raw_write_unlock_bh", "6589": "__raw_write_unlock_irq", "6590": "__raw_write_unlock_irqrestore", "6591": "__rb_allocate_pages", "6592": "__rb_data_page_index", "6593": "__rb_free_aux", "6594": "__rb_page_index", "6595": "__rb_reserve_next", "6596": "__rcu", "6597": "__rcu_init_preempt", "6598": "__rcu_is_watching", "6599": "__rcu_pending", "6600": "__rcu_process_callbacks", "6601": "__rcu_read_lock", "6602": "__rcu_read_unlock", "6603": "__rcu_reclaim", "6604": "__read_lock_debug", "6605": "__read_mostly", "6606": "__ref", "6607": "__refdata", "6608": "__refill_cfs_bandwidth_runtime", "6609": "__refrigerator", "6610": "__register_cpu_notifier", "6611": "__register_event", "6612": "__register_ftrace_function", "6613": "__register_nosave_region", "6614": "__register_trace_kprobe", "6615": "__release", "6616": "__release_child_resources", "6617": "__release_region", "6618": "__release_resource", "6619": "__releases", "6620": "__remove_filter", "6621": "__remove_wait_queue", "6622": "__replace_page", "6623": "__report_bad_irq", "6624": "__request_module", "6625": "__request_region", "6626": "__request_resource", "6627": "__res", "6628": "__rescuer", "6629": "__reserve_region_with_split", "6630": "__reserved", "6631": "__reset_stat_session", "6632": "__return_cfs_rq_runtime", "6633": "__ring_buffer_alloc", "6634": "__rq_clock_broken", "6635": "__rt_schedulable", "6636": "__run_timers", "6637": "__rwlock_init", "6638": "__rwsem_do_wake", "6639": "__rwsem_initializer", "6640": "__rwsem_wake_one_writer", "6641": "__same_type", "6642": "__save_altstack", "6643": "__sched", "6644": "__sched_clock_stable", "6645": "__sched_clock_stable_early", "6646": "__sched_feat_", "6647": "__sched_feat_nr", "6648": "__sched_fork", "6649": "__sched_info_switch", "6650": "__sched_period", "6651": "__sched_setscheduler", "6652": "__sched_text_start", "6653": "__schedule", "6654": "__schedule_bug", "6655": "__sd", "6656": "__sdt_alloc", "6657": "__sdt_free", "6658": "__seccomp_phase1_filter", "6659": "__secure_computing", "6660": "__secure_computing_strict", "6661": "__send_signal", "6662": "__seq_open_private", "6663": "__set_bit", "6664": "__set_current_blocked", "6665": "__set_current_state", "6666": "__set_enter_print_fmt", "6667": "__set_print_fmt", "6668": "__set_sched_clock_stable", "6669": "__set_task_blocked", "6670": "__set_task_cpu", "6671": "__set_task_state", "6672": "__setparam_dl", "6673": "__setscheduler", "6674": "__setscheduler_params", "6675": "__setup", "6676": "__setup_irq", "6677": "__si_chld", "6678": "__si_fault", "6679": "__si_kill", "6680": "__si_mask", "6681": "__si_mesgq", "6682": "__si_poll", "6683": "__si_rt", "6684": "__si_special", "6685": "__si_sys", "6686": "__si_timer", "6687": "__sighandler_t", "6688": "__sigqueue_alloc", "6689": "__sigqueue_free", "6690": "__size", "6691": "__skb_dequeue", "6692": "__smpboot_create_thread", "6693": "__sparc__", "6694": "__spin_lock_debug", "6695": "__sprint_symbol", "6696": "__srcu_notifier_call_chain", "6697": "__srcu_read_lock", "6698": "__srcu_read_unlock", "6699": "__stack_chk_fail", "6700": "__start___ex_table", "6701": "__start___jump_table", "6702": "__start___kcrctab", "6703": "__start___kcrctab_gpl", "6704": "__start___kcrctab_gpl_future", "6705": "__start___kcrctab_unused", "6706": "__start___kcrctab_unused_gpl", "6707": "__start___ksymtab", "6708": "__start___ksymtab_gpl", "6709": "__start___ksymtab_gpl_future", "6710": "__start___ksymtab_unused", "6711": "__start___ksymtab_unused_gpl", "6712": "__start___modver", "6713": "__start___param", "6714": "__start___trace_bprintk_fmt", "6715": "__start___tracepoint_str", "6716": "__start_annotated_branch_profile", "6717": "__start_branch_profile", "6718": "__start_cfs_bandwidth", "6719": "__start_ftrace_events", "6720": "__start_kprobe_blacklist", "6721": "__start_syscalls_metadata", "6722": "__state", "6723": "__static_key_slow_dec", "6724": "__stop___ex_table", "6725": "__stop___jump_table", "6726": "__stop___ksymtab", "6727": "__stop___ksymtab_gpl", "6728": "__stop___ksymtab_gpl_future", "6729": "__stop___ksymtab_unused", "6730": "__stop___ksymtab_unused_gpl", "6731": "__stop___modver", "6732": "__stop___trace_bprintk_fmt", "6733": "__stop___tracepoint_str", "6734": "__stop_annotated_branch_profile", "6735": "__stop_branch_profile", "6736": "__stop_cpus", "6737": "__stop_ftrace_events", "6738": "__stop_kprobe_blacklist", "6739": "__stop_machine", "6740": "__stop_syscalls_metadata", "6741": "__stringify", "6742": "__symbol_get", "6743": "__symbol_put", "6744": "__synchronize_entity_decay", "6745": "__synchronize_hardirq", "6746": "__synchronize_srcu", "6747": "__sysrq_enabled", "6748": "__task_cred", "6749": "__task_pid_nr_ns", "6750": "__task_rq_lock", "6751": "__task_rq_unlock", "6752": "__task_stopped", "6753": "__task_traced", "6754": "__tasklet_hi_schedule", "6755": "__tasklet_hi_schedule_first", "6756": "__tasklet_hrtimer_trampoline", "6757": "__tasklet_schedule", "6758": "__test_after_last", "6759": "__thaw_task", "6760": "__this_cpu_add", "6761": "__this_cpu_dec", "6762": "__this_cpu_inc", "6763": "__this_cpu_inc_return", "6764": "__this_cpu_read", "6765": "__this_cpu_write", "6766": "__this_cpu_xchg", "6767": "__tick_nohz_full_check", "6768": "__tick_nohz_idle_enter", "6769": "__tick_nohz_task_switch", "6770": "__timekeeping_inject_sleeptime", "6771": "__timekeeping_set_tai_offset", "6772": "__timer_stats_timer_set_start_info", "6773": "__timespec_to_jiffies", "6774": "__timr", "6775": "__to_kthread", "6776": "__torture_print_stats", "6777": "__total", "6778": "__touch_watchdog", "6779": "__trace_add_event_dirs", "6780": "__trace_add_new_event", "6781": "__trace_array_put", "6782": "__trace_bprintk", "6783": "__trace_bputs", "6784": "__trace_define_field", "6785": "__trace_early_add_event_dirs", "6786": "__trace_early_add_events", "6787": "__trace_early_add_new_event", "6788": "__trace_find_cmdline", "6789": "__trace_first_type", "6790": "__trace_function", "6791": "__trace_graph_entry", "6792": "__trace_graph_function", "6793": "__trace_graph_return", "6794": "__trace_hardirqs_on_caller", "6795": "__trace_last_type", "6796": "__trace_mmiotrace_map", "6797": "__trace_mmiotrace_rw", "6798": "__trace_note_message", "6799": "__trace_printk", "6800": "__trace_puts", "6801": "__trace_remove_event_call", "6802": "__trace_remove_event_dirs", "6803": "__trace_seq_init", "6804": "__trace_stack", "6805": "__trace_stat_h", "6806": "__tracepoint_string", "6807": "__tracer_data", "6808": "__tstat_hashfn", "6809": "__tvec_bases", "6810": "__u16", "6811": "__u32", "6812": "__u64", "6813": "__u8", "6814": "__uidhashfn", "6815": "__unregister_cpu_notifier", "6816": "__unregister_ftrace_event", "6817": "__unregister_ftrace_function", "6818": "__unregister_kprobe_bottom", "6819": "__unregister_kprobe_top", "6820": "__unregister_trace_kprobe", "6821": "__unused", "6822": "__up", "6823": "__up_read", "6824": "__up_write", "6825": "__update_blocked_averages_cpu", "6826": "__update_cfs_rq_tg_load_contrib", "6827": "__update_cpu_load", "6828": "__update_entity_load_avg_contrib", "6829": "__update_entity_runnable_avg", "6830": "__update_entity_utilization_avg_contrib", "6831": "__update_group_entity_contrib", "6832": "__update_inv_weight", "6833": "__update_max_tr", "6834": "__update_task_entity_contrib", "6835": "__update_task_entity_utilization", "6836": "__update_tg_runnable_avg", "6837": "__uprobe_perf_filter", "6838": "__uprobe_perf_func", "6839": "__uprobe_register", "6840": "__uprobe_trace_func", "6841": "__uprobe_unregister", "6842": "__usage", "6843": "__used", "6844": "__user", "6845": "__user_cap_data_struct", "6846": "__usermodehelper_set_disable_depth", "6847": "__va", "6848": "__va_args__", "6849": "__val", "6850": "__validate_process_creds", "6851": "__visible", "6852": "__visit_domain_allocation_hell", "6853": "__vma_link_rb", "6854": "__vmalloc", "6855": "__vtime_account_system", "6856": "__wait_atomic_t_key_initializer", "6857": "__wait_bit_key_initializer", "6858": "__wait_on_atomic_t", "6859": "__wait_on_bit", "6860": "__wait_on_bit_lock", "6861": "__wait_queue_head_initializer", "6862": "__wake_up", "6863": "__wake_up_bit", "6864": "__wake_up_common", "6865": "__wake_up_locked", "6866": "__wake_up_locked_key", "6867": "__wake_up_parent", "6868": "__wake_up_sync", "6869": "__wake_up_sync_key", "6870": "__wakeup_reset", "6871": "__wakeup_tracer_init", "6872": "__wall", "6873": "__weak", "6874": "__worker", "6875": "__wq_draining", "6876": "__wq_ordered", "6877": "__write_lock_debug", "6878": "__ww_mutex_lock", "6879": "__ww_mutex_lock_check_stamp", "6880": "__ww_mutex_lock_interruptible", "6881": "__ww_mutex_lock_interruptible_slowpath", "6882": "__ww_mutex_lock_slowpath", "6883": "_attr", "6884": "_braille_console_setup", "6885": "_braille_register_console", "6886": "_braille_unregister_console", "6887": "_can_lock", "6888": "_cgrp_id", "6889": "_cgrp_subsys", "6890": "_cond_resched", "6891": "_console_cmdline_h", "6892": "_cpu_down", "6893": "_cpu_up", "6894": "_create", "6895": "_cred", "6896": "_data", "6897": "_ddebug", "6898": "_debug_core_h_", "6899": "_default_fetch_type", "6900": "_double_lock_balance", "6901": "_down_write_nest_lock", "6902": "_einittext", "6903": "_end", "6904": "_etext", "6905": "_exists", "6906": "_fls", "6907": "_fmttype", "6908": "_free_event", "6909": "_ioc_nr", "6910": "_ioc_size", "6911": "_ioc_type", "6912": "_irq_default_init_flags", "6913": "_irq_desc_check", "6914": "_irq_desc_percpu", "6915": "_irq_is_polled", "6916": "_irq_level", "6917": "_irq_move_pcntxt", "6918": "_irq_nested_thread", "6919": "_irq_no_balancing", "6920": "_irq_noautoen", "6921": "_irq_noprobe", "6922": "_irq_norequest", "6923": "_irq_nothread", "6924": "_irq_per_cpu", "6925": "_irq_per_cpu_devid", "6926": "_irqf_modify_mask", "6927": "_k", "6928": "_kdb_bp_install", "6929": "_kdb_bp_remove", "6930": "_kdbprivate_h", "6931": "_kernel_capability_u32s", "6932": "_kernel_capability_version", "6933": "_kernel_events_internal_h", "6934": "_kernel_time_timekeeping_h", "6935": "_kobj", "6936": "_last_field", "6937": "_linux_capability_u32s_1", "6938": "_linux_capability_u32s_3", "6939": "_linux_capability_version_1", "6940": "_linux_capability_version_2", "6941": "_linux_capability_version_3", "6942": "_linux_kernel_trace_h", "6943": "_linux_ntp_internal_h", "6944": "_local_bh_enable", "6945": "_lock", "6946": "_lock_bh", "6947": "_lock_irq", "6948": "_lock_irqsave", "6949": "_modlen", "6950": "_mutex_lock_nest_lock", "6951": "_name", "6952": "_nsig", "6953": "_nsig_words", "6954": "_p", "6955": "_param", "6956": "_perf_event_disable", "6957": "_perf_event_enable", "6958": "_perf_event_refresh", "6959": "_perf_event_reset", "6960": "_perf_ioctl", "6961": "_pick_next_task_rt", "6962": "_printk_braille_h", "6963": "_proc_do_string", "6964": "_qr_bias", "6965": "_qw_locked", "6966": "_qw_waiting", "6967": "_qw_wmask", "6968": "_raw_", "6969": "_raw_read_lock", "6970": "_raw_read_lock_bh", "6971": "_raw_read_lock_irq", "6972": "_raw_read_lock_irqsave", "6973": "_raw_read_trylock", "6974": "_raw_read_unlock", "6975": "_raw_read_unlock_bh", "6976": "_raw_read_unlock_irq", "6977": "_raw_read_unlock_irqrestore", "6978": "_raw_spin_lock", "6979": "_raw_spin_lock_bh", "6980": "_raw_spin_lock_bh_nested", "6981": "_raw_spin_lock_irq", "6982": "_raw_spin_lock_irqsave", "6983": "_raw_spin_lock_irqsave_nested", "6984": "_raw_spin_lock_nest_lock", "6985": "_raw_spin_lock_nested", "6986": "_raw_spin_trylock", "6987": "_raw_spin_trylock_bh", "6988": "_raw_spin_unlock", "6989": "_raw_spin_unlock_bh", "6990": "_raw_spin_unlock_irq", "6991": "_raw_spin_unlock_irqrestore", "6992": "_raw_write_lock", "6993": "_raw_write_lock_bh", "6994": "_raw_write_lock_irq", "6995": "_raw_write_lock_irqsave", "6996": "_raw_write_trylock", "6997": "_raw_write_unlock", "6998": "_raw_write_unlock_bh", "6999": "_raw_write_unlock_irq", "7000": "_raw_write_unlock_irqrestore", "7001": "_rcu_barrier", "7002": "_rcu_barrier_trace", "7003": "_read", "7004": "_relax", "7005": "_ret_ip_", "7006": "_sched_setscheduler", "7007": "_sdata", "7008": "_show", "7009": "_show_name", "7010": "_sinittext", "7011": "_size", "7012": "_state", "7013": "_stext", "7014": "_store", "7015": "_store_name", "7016": "_t", "7017": "_this_ip_", "7018": "_tick_sched_h", "7019": "_tif_need_resched", "7020": "_tif_polling_nrflag", "7021": "_timekeeping_internal_h", "7022": "_torture_create_kthread", "7023": "_torture_stop_kthread", "7024": "_trace_benchmark_h", "7025": "_trace_test_h", "7026": "_trylock", "7027": "_varname", "7028": "_verbose", "7029": "_x", "7030": "a", "7031": "a0", "7032": "a1", "7033": "a2", "7034": "a3", "7035": "a4", "7036": "a5", "7037": "a6", "7038": "a_ops", "7039": "a_preds", "7040": "ab", "7041": "abbr", "7042": "abi", "7043": "abort", "7044": "abort_creds", "7045": "abort_exclusive_wait", "7046": "abs", "7047": "abs_msec", "7048": "abs_timeout", "7049": "abs_ts", "7050": "abs_usec", "7051": "absexp", "7052": "abstime", "7053": "ac", "7054": "ac_ahz", "7055": "ac_btime", "7056": "ac_comm", "7057": "ac_etime", "7058": "ac_etime_hi", "7059": "ac_etime_lo", "7060": "ac_exitcode", "7061": "ac_flag", "7062": "ac_gid", "7063": "ac_gid16", "7064": "ac_majflt", "7065": "ac_mem", "7066": "ac_minflt", "7067": "ac_nice", "7068": "ac_pid", "7069": "ac_ppid", "7070": "ac_sched", "7071": "ac_stime", "7072": "ac_stimescaled", "7073": "ac_tty", "7074": "ac_uid", "7075": "ac_uid16", "7076": "ac_utime", "7077": "ac_utimescaled", "7078": "ac_version", "7079": "acc_mode", "7080": "accept", "7081": "accepts", "7082": "access", "7083": "access_lock", "7084": "access_ok", "7085": "access_once", "7086": "access_process_vm", "7087": "access_size", "7088": "account", "7089": "account_cfs_rq_runtime", "7090": "account_entity_dequeue", "7091": "account_entity_enqueue", "7092": "account_global_scheduler_latency", "7093": "account_group_exec_runtime", "7094": "account_group_system_time", "7095": "account_group_user_time", "7096": "account_guest_time", "7097": "account_idle_ticks", "7098": "account_idle_time", "7099": "account_irq_enter_time", "7100": "account_irq_exit_time", "7101": "account_kernel_stack", "7102": "account_numa_dequeue", "7103": "account_numa_enqueue", "7104": "account_process_tick", "7105": "account_scheduler_latency", "7106": "account_steal_ticks", "7107": "account_steal_time", "7108": "account_system_time", "7109": "account_user_time", "7110": "accounting", "7111": "acct", "7112": "acct_account_cputime", "7113": "acct_byteorder", "7114": "acct_clear_integrals", "7115": "acct_collect", "7116": "acct_exit_ns", "7117": "acct_get", "7118": "acct_on", "7119": "acct_on_mutex", "7120": "acct_parm", "7121": "acct_pin_kill", "7122": "acct_process", "7123": "acct_put", "7124": "acct_rss_mem1", "7125": "acct_t", "7126": "acct_timeout", "7127": "acct_timexpd", "7128": "acct_update_integrals", "7129": "acct_version", "7130": "acct_vm_mem1", "7131": "accumulate_nsecs_to_secs", "7132": "accumulate_thread_rusage", "7133": "ack", "7134": "ack_bad", "7135": "ack_bad_irq", "7136": "ack_state", "7137": "acore", "7138": "acpi_pm", "7139": "acpi_realmode_flags", "7140": "acquire", "7141": "acquire_ip", "7142": "acquired", "7143": "acquirelock", "7144": "across", "7145": "act", "7146": "act_log_check", "7147": "act_mask", "7148": "act_waiter", "7149": "action", "7150": "action_msg", "7151": "action_ptr", "7152": "action_ret", "7153": "actions", "7154": "activate", "7155": "activate_task", "7156": "active", "7157": "active_balance", "7158": "active_balance_work", "7159": "active_cpus", "7160": "active_ctx_list", "7161": "active_load_balance_cpu_stop", "7162": "active_mm", "7163": "active_nodes", "7164": "active_oncpu", "7165": "active_reqs", "7166": "active_timers", "7167": "active_uprobe", "7168": "active_writer", "7169": "actual_nr_irqs", "7170": "add", "7171": "add_del_listener", "7172": "add_dev", "7173": "add_event_to_ctx", "7174": "add_ftrace_list_ops", "7175": "add_ftrace_ops", "7176": "add_hash_entry", "7177": "add_if_not_found", "7178": "add_info", "7179": "add_interrupt_randomness", "7180": "add_kallsyms", "7181": "add_links", "7182": "add_lock_to_list", "7183": "add_module_usage", "7184": "add_new_kprobe", "7185": "add_node", "7186": "add_notes_attrs", "7187": "add_nr_running", "7188": "add_offset", "7189": "add_range", "7190": "add_range_with_merge", "7191": "add_rtree_block", "7192": "add_sect_attrs", "7193": "add_sysfs_param", "7194": "add_taint", "7195": "add_taint_module", "7196": "add_timer", "7197": "add_timer_on", "7198": "add_timestamp", "7199": "add_unformed_module", "7200": "add_usage_links", "7201": "add_wait_queue", "7202": "add_wait_queue_exclusive", "7203": "add_watch_to_parent", "7204": "added_mask", "7205": "addend", "7206": "adding", "7207": "addr", "7208": "addr_conflict", "7209": "address", "7210": "address_space", "7211": "adj", "7212": "adj_adjtime", "7213": "adj_esterror", "7214": "adj_frequency", "7215": "adj_maxerror", "7216": "adj_micro", "7217": "adj_nano", "7218": "adj_offset", "7219": "adj_offset_readonly", "7220": "adj_offset_singleshot", "7221": "adj_scale", "7222": "adj_setoffset", "7223": "adj_status", "7224": "adj_tai", "7225": "adj_tick", "7226": "adj_timeconst", "7227": "adjtimex", "7228": "adjust", "7229": "adjust_branches", "7230": "adjust_resource", "7231": "adjust_stack_addr", "7232": "adjustment", "7233": "af", "7234": "affine_sd", "7235": "affinity", "7236": "affinity_hint", "7237": "affinity_notify", "7238": "afork", "7239": "after", "7240": "after_dashes", "7241": "ag", "7242": "again", "7243": "age_stamp", "7244": "agentbuf", "7245": "aggr_break_handler", "7246": "aggr_fault_handler", "7247": "aggr_kprobe_disabled", "7248": "aggr_post_handler", "7249": "aggr_pre_handler", "7250": "ahz", "7251": "aiee", "7252": "ainsn", "7253": "aio_max_nr", "7254": "aio_nr", "7255": "al", "7256": "alarm", "7257": "alarm_base", "7258": "alarm_bases", "7259": "alarm_boottime", "7260": "alarm_cancel", "7261": "alarm_clock", "7262": "alarm_clock_get", "7263": "alarm_clock_getres", "7264": "alarm_expires_remaining", "7265": "alarm_forward", "7266": "alarm_forward_now", "7267": "alarm_handle_timer", "7268": "alarm_init", "7269": "alarm_numtype", "7270": "alarm_realtime", "7271": "alarm_restart", "7272": "alarm_setitimer", "7273": "alarm_start", "7274": "alarm_start_relative", "7275": "alarm_timer_create", "7276": "alarm_timer_del", "7277": "alarm_timer_get", "7278": "alarm_timer_nsleep", "7279": "alarm_timer_nsleep_restart", "7280": "alarm_timer_set", "7281": "alarm_try_to_cancel", "7282": "alarmtimer", "7283": "alarmtimer_dequeue", "7284": "alarmtimer_do_nsleep", "7285": "alarmtimer_driver", "7286": "alarmtimer_enqueue", "7287": "alarmtimer_fired", "7288": "alarmtimer_freezerset", "7289": "alarmtimer_get_rtcdev", "7290": "alarmtimer_init", "7291": "alarmtimer_norestart", "7292": "alarmtimer_nsleep_wakeup", "7293": "alarmtimer_pm_ops", "7294": "alarmtimer_restart", "7295": "alarmtimer_rtc_add_device", "7296": "alarmtimer_rtc_interface", "7297": "alarmtimer_rtc_interface_remove", "7298": "alarmtimer_rtc_interface_setup", "7299": "alarmtimer_rtc_timer_init", "7300": "alarmtimer_state_enqueued", "7301": "alarmtimer_state_inactive", "7302": "alarmtimer_suspend", "7303": "alarmtimer_type", "7304": "alb_count", "7305": "alb_failed", "7306": "alb_pushed", "7307": "algo", "7308": "align", "7309": "alignf", "7310": "alignf_data", "7311": "alignment", "7312": "all", "7313": "all_annotated_branch_stats", "7314": "all_branch_stat_headers", "7315": "all_branch_stat_next", "7316": "all_branch_stat_start", "7317": "all_branch_stats", "7318": "all_buf", "7319": "all_cpu_access_lock", "7320": "all_cpus_idle", "7321": "all_head", "7322": "all_lazy", "7323": "all_lock_classes", "7324": "all_ss", "7325": "all_stat_sessions", "7326": "all_stat_sessions_mutex", "7327": "all_timers", "7328": "all_var", "7329": "alloc", "7330": "alloc_aggr_kprobe", "7331": "alloc_and_copy_ftrace_hash", "7332": "alloc_and_link_pwqs", "7333": "alloc_bootmem_cpumask_var", "7334": "alloc_callchain_buffers", "7335": "alloc_chunk", "7336": "alloc_cpumask_var", "7337": "alloc_desc", "7338": "alloc_descs", "7339": "alloc_entry", "7340": "alloc_fair_sched_group", "7341": "alloc_frozen_cpus", "7342": "alloc_ftrace_hash", "7343": "alloc_highmem", "7344": "alloc_highmem_pages", "7345": "alloc_image_page", "7346": "alloc_insn_page", "7347": "alloc_kmem_pages_node", "7348": "alloc_large_system_hash", "7349": "alloc_list_entry", "7350": "alloc_lock", "7351": "alloc_masks", "7352": "alloc_normal", "7353": "alloc_ordered_workqueue", "7354": "alloc_page", "7355": "alloc_pages_exact", "7356": "alloc_pages_exact_node", "7357": "alloc_pages_node", "7358": "alloc_percpu", "7359": "alloc_percpu_gfp", "7360": "alloc_perf_context", "7361": "alloc_pid", "7362": "alloc_pidmap", "7363": "alloc_posix_timer", "7364": "alloc_resource", "7365": "alloc_retstack_tasklist", "7366": "alloc_rootdomain", "7367": "alloc_rt_sched_group", "7368": "alloc_rtree_node", "7369": "alloc_sched_domains", "7370": "alloc_snapshot", "7371": "alloc_state", "7372": "alloc_swapdev_block", "7373": "alloc_symbol_cache", "7374": "alloc_task_struct_node", "7375": "alloc_thread_info_node", "7376": "alloc_trace_kprobe", "7377": "alloc_trace_uprobe", "7378": "alloc_tree", "7379": "alloc_trial_cpuset", "7380": "alloc_uid", "7381": "alloc_unbound_pwq", "7382": "alloc_uprobe", "7383": "alloc_worker", "7384": "alloc_workqueue", "7385": "alloc_workqueue_attrs", "7386": "allocate", "7387": "allocate_cgrp_cset_links", "7388": "allocate_cmdlines_buffer", "7389": "allocate_ftrace_ops", "7390": "allocate_mm", "7391": "allocate_resource", "7392": "allocate_snapshot", "7393": "allocated", "7394": "allocated_irqs", "7395": "allocated_snapshot", "7396": "allocated_unsafe_pages", "7397": "allocates", "7398": "allocating", "7399": "allocation", "7400": "allow_changes", "7401": "allow_instances", "7402": "allow_nohz", "7403": "allow_signal", "7404": "allowed", "7405": "allowed_error_ns", "7406": "allowed_ns", "7407": "alm", "7408": "already", "7409": "already_enabled", "7410": "already_gone", "7411": "already_uses", "7412": "alter_cred_subscribers", "7413": "alu", "7414": "alu64_", "7415": "alu64_add_k", "7416": "alu64_add_x", "7417": "alu64_and_k", "7418": "alu64_and_x", "7419": "alu64_arsh_k", "7420": "alu64_arsh_x", "7421": "alu64_div_k", "7422": "alu64_div_x", "7423": "alu64_lsh_k", "7424": "alu64_lsh_x", "7425": "alu64_mod_k", "7426": "alu64_mod_x", "7427": "alu64_mov_k", "7428": "alu64_mov_x", "7429": "alu64_mul_k", "7430": "alu64_mul_x", "7431": "alu64_neg", "7432": "alu64_or_k", "7433": "alu64_or_x", "7434": "alu64_rsh_k", "7435": "alu64_rsh_x", "7436": "alu64_sub_k", "7437": "alu64_sub_x", "7438": "alu64_xor_k", "7439": "alu64_xor_x", "7440": "alu_", "7441": "alu_add_k", "7442": "alu_add_x", "7443": "alu_and_k", "7444": "alu_and_x", "7445": "alu_div_k", "7446": "alu_div_x", "7447": "alu_end_to_be", "7448": "alu_end_to_le", "7449": "alu_lsh_k", "7450": "alu_lsh_x", "7451": "alu_mod_k", "7452": "alu_mod_x", "7453": "alu_mov_k", "7454": "alu_mov_x", "7455": "alu_mul_k", "7456": "alu_mul_x", "7457": "alu_neg", "7458": "alu_or_k", "7459": "alu_or_x", "7460": "alu_rsh_k", "7461": "alu_rsh_x", "7462": "alu_sub_k", "7463": "alu_sub_x", "7464": "alu_xor_k", "7465": "alu_xor_x", "7466": "amagic", "7467": "amount", "7468": "amt", "7469": "an", "7470": "aname", "7471": "ancestor", "7472": "and", "7473": "annotated_branch_stat_cmp", "7474": "annotated_branch_stat_headers", "7475": "annotated_branch_stat_next", "7476": "annotated_branch_stat_start", "7477": "annotated_branch_stats", "7478": "anon_inode_getfd", "7479": "anon_vma_chain", "7480": "anon_vma_fork", "7481": "another", "7482": "any", "7483": "any_count", "7484": "ap", "7485": "apn", "7486": "append_elf_note", "7487": "append_filter_err", "7488": "append_filter_string", "7489": "append_operand_char", "7490": "apply_event_filter", "7491": "apply_relocate", "7492": "apply_relocate_add", "7493": "apply_relocations", "7494": "apply_slack", "7495": "apply_subsystem_event_filter", "7496": "apply_workqueue_attrs", "7497": "ar", "7498": "arch", "7499": "arch_", "7500": "arch_arm_kprobe", "7501": "arch_capacity", "7502": "arch_check_ftrace_location", "7503": "arch_check_optimized_kprobe", "7504": "arch_compat_alloc_user_space", "7505": "arch_cpu_idle", "7506": "arch_cpu_idle_dead", "7507": "arch_cpu_idle_enter", "7508": "arch_cpu_idle_exit", "7509": "arch_cpu_idle_prepare", "7510": "arch_deref_entry_point", "7511": "arch_disable_smp_support", "7512": "arch_disarm_kprobe", "7513": "arch_dup_mmap", "7514": "arch_dup_task_struct", "7515": "arch_dynirq_lower_bound", "7516": "arch_early_irq_init", "7517": "arch_enable_nonboot_cpus_begin", "7518": "arch_enable_nonboot_cpus_end", "7519": "arch_f", "7520": "arch_ftrace_trampoline_free", "7521": "arch_ftrace_update_code", "7522": "arch_ftrace_update_trampoline", "7523": "arch_gettimeoffset", "7524": "arch_has_block_step", "7525": "arch_has_single_step", "7526": "arch_has_syscall_match_sym_name", "7527": "arch_hibernation_header_restore", "7528": "arch_hibernation_header_save", "7529": "arch_initcall", "7530": "arch_irq_work_has_interrupt", "7531": "arch_irq_work_raise", "7532": "arch_jump_label_transform", "7533": "arch_jump_label_transform_static", "7534": "arch_kexec_apply_relocations", "7535": "arch_kexec_apply_relocations_add", "7536": "arch_kexec_kernel_image_load", "7537": "arch_kexec_kernel_image_probe", "7538": "arch_kexec_kernel_verify_sig", "7539": "arch_kgdb_breakpoint", "7540": "arch_kgdb_ops", "7541": "arch_kimage_file_post_load_cleanup", "7542": "arch_mcs_spin_lock_contended", "7543": "arch_mcs_spin_unlock_contended", "7544": "arch_min_mmstruct_align", "7545": "arch_min_taskalign", "7546": "arch_needs_cpu", "7547": "arch_perf_update_userpage", "7548": "arch_prepare_kprobe", "7549": "arch_prepare_kprobe_ftrace", "7550": "arch_prepare_kretprobe", "7551": "arch_prepare_optimized_kprobe", "7552": "arch_prepared_optinsn", "7553": "arch_probe_nr_irqs", "7554": "arch_ptrace_attach", "7555": "arch_ptrace_stop", "7556": "arch_ptrace_stop_needed", "7557": "arch_read_lock", "7558": "arch_read_relax", "7559": "arch_read_trylock", "7560": "arch_read_unlock", "7561": "arch_release_task_struct", "7562": "arch_release_thread_info", "7563": "arch_relocates_kcrctab", "7564": "arch_remove_kprobe", "7565": "arch_remove_optimized_kprobe", "7566": "arch_remove_reservations", "7567": "arch_rwlock_t", "7568": "arch_scale_cpu_capacity", "7569": "arch_scale_freq_capacity", "7570": "arch_send_call_function_ipi_mask", "7571": "arch_send_call_function_single_ipi", "7572": "arch_setup_hwirq", "7573": "arch_shf_small", "7574": "arch_show_interrupts", "7575": "arch_specific_insn", "7576": "arch_spin_is_locked", "7577": "arch_spin_lock", "7578": "arch_spin_relax", "7579": "arch_spin_trylock", "7580": "arch_spin_unlock", "7581": "arch_spinlock_t", "7582": "arch_start_context_switch", "7583": "arch_supports_ftrace_ops", "7584": "arch_syscall_match_sym_name", "7585": "arch_task_cache_init", "7586": "arch_teardown_hwirq", "7587": "arch_trace_ignore_compat_syscalls", "7588": "arch_trace_is_compat_syscall", "7589": "arch_unoptimize_kprobe", "7590": "arch_update_cpu_topology", "7591": "arch_uprobe", "7592": "arch_uprobe_abort_xol", "7593": "arch_uprobe_analyze_insn", "7594": "arch_uprobe_copy_ixol", "7595": "arch_uprobe_exception_notify", "7596": "arch_uprobe_ignore", "7597": "arch_uprobe_post_xol", "7598": "arch_uprobe_pre_xol", "7599": "arch_uprobe_skip_sstep", "7600": "arch_uprobe_xol_was_trapped", "7601": "arch_uretprobe_hijack_return_addr", "7602": "arch_vma_name", "7603": "arch_vtime_task_switch", "7604": "arch_within_kprobe_blacklist", "7605": "arch_write_lock", "7606": "arch_write_relax", "7607": "arch_write_trylock", "7608": "arch_write_unlock", "7609": "are", "7610": "area", "7611": "arg", "7612": "arg1", "7613": "arg1_type", "7614": "arg2", "7615": "arg2_type", "7616": "arg3", "7617": "arg3_type", "7618": "arg4", "7619": "arg4_type", "7620": "arg5", "7621": "arg5_type", "7622": "arg_anything", "7623": "arg_const_map_ptr", "7624": "arg_const_stack_size", "7625": "arg_dontcare", "7626": "arg_end", "7627": "arg_num", "7628": "arg_num_len", "7629": "arg_num_len_buf", "7630": "arg_ptr_to_ctx", "7631": "arg_ptr_to_map_key", "7632": "arg_ptr_to_map_value", "7633": "arg_ptr_to_stack", "7634": "arg_start", "7635": "arg_type", "7636": "argc", "7637": "argcount", "7638": "args", "7639": "args2", "7640": "argv", "7641": "argv_free", "7642": "argv_split", "7643": "arm_all_kprobes", "7644": "arm_kprobe", "7645": "arm_kprobe_ftrace", "7646": "arr", "7647": "array", "7648": "array_descriptor", "7649": "array_map_alloc", "7650": "array_map_delete_elem", "7651": "array_map_free", "7652": "array_map_get_next_key", "7653": "array_map_lookup_elem", "7654": "array_map_update_elem", "7655": "array_ops", "7656": "array_size", "7657": "array_type", "7658": "arrsize", "7659": "as", "7660": "asked", "7661": "asm", "7662": "asmlinkage", "7663": "assert_raw_spin_locked", "7664": "assert_rcu_or_pool_mutex", "7665": "assert_rcu_or_wq_mutex", "7666": "assert_spin_locked", "7667": "assign", "7668": "assign_cfs_rq_runtime", "7669": "assign_fetch_func", "7670": "assign_fetch_type", "7671": "assign_fetch_type_end", "7672": "assign_ops_hash", "7673": "assuming", "7674": "asu", "7675": "async_cookie_max", "7676": "async_cookie_t", "7677": "async_dfl_domain", "7678": "async_domain", "7679": "async_done", "7680": "async_entry", "7681": "async_func_t", "7682": "async_global_pending", "7683": "async_lock", "7684": "async_run_entry_fn", "7685": "async_schedule", "7686": "async_schedule_domain", "7687": "async_synchronize_cookie", "7688": "async_synchronize_cookie_domain", "7689": "async_synchronize_full", "7690": "async_synchronize_full_domain", "7691": "async_unregister_domain", "7692": "at", "7693": "at_null", "7694": "at_vector_size", "7695": "atomic64_add", "7696": "atomic64_read", "7697": "atomic64_set", "7698": "atomic64_t", "7699": "atomic_add", "7700": "atomic_add_return", "7701": "atomic_add_unless", "7702": "atomic_cmpxchg", "7703": "atomic_dec", "7704": "atomic_dec_and_lock", "7705": "atomic_dec_and_mutex_lock", "7706": "atomic_dec_and_test", "7707": "atomic_dec_if_positive", "7708": "atomic_dec_return", "7709": "atomic_dec_unless_positive", "7710": "atomic_inc", "7711": "atomic_inc_not_zero", "7712": "atomic_inc_return", "7713": "atomic_inc_unless_negative", "7714": "atomic_init", "7715": "atomic_long_add", "7716": "atomic_long_cmpxchg", "7717": "atomic_long_dec_and_test", "7718": "atomic_long_inc", "7719": "atomic_long_inc_not_zero", "7720": "atomic_long_inc_return", "7721": "atomic_long_read", "7722": "atomic_long_set", "7723": "atomic_long_sub", "7724": "atomic_long_t", "7725": "atomic_long_xchg", "7726": "atomic_notifier_call_chain", "7727": "atomic_notifier_chain_register", "7728": "atomic_notifier_chain_unregister", "7729": "atomic_notifier_head", "7730": "atomic_read", "7731": "atomic_set", "7732": "atomic_sub", "7733": "atomic_sub_return", "7734": "atomic_t", "7735": "atomic_t_waitqueue", "7736": "atomic_write_len", "7737": "atomic_xchg", "7738": "attach", "7739": "attach_in_progress", "7740": "attach_mutex", "7741": "attach_one_task", "7742": "attach_pid", "7743": "attach_state", "7744": "attach_task", "7745": "attach_tasks", "7746": "attempt", "7747": "attempted", "7748": "attr", "7749": "attr2pentry", "7750": "attr_gid", "7751": "attr_uid", "7752": "attribute", "7753": "attribute_group", "7754": "attributes", "7755": "attrs", "7756": "audit_add", "7757": "audit_add_rule", "7758": "audit_add_to_parent", "7759": "audit_add_tree_rule", "7760": "audit_add_watch", "7761": "audit_alloc", "7762": "audit_alloc_context", "7763": "audit_alloc_name", "7764": "audit_always", "7765": "audit_anom_abend", "7766": "audit_anom_link", "7767": "audit_arch", "7768": "audit_arg0", "7769": "audit_arg1", "7770": "audit_arg2", "7771": "audit_arg3", "7772": "audit_aux_data", "7773": "audit_aux_data_bprm_fcaps", "7774": "audit_aux_data_pids", "7775": "audit_aux_ipcperm", "7776": "audit_aux_pids", "7777": "audit_backlog_limit", "7778": "audit_backlog_wait", "7779": "audit_backlog_wait_overflow", "7780": "audit_backlog_wait_time", "7781": "audit_backlog_wait_time_master", "7782": "audit_bad", "7783": "audit_bind", "7784": "audit_bit", "7785": "audit_bit_mask", "7786": "audit_bit_test", "7787": "audit_bitmask", "7788": "audit_bitmask_size", "7789": "audit_bittest", "7790": "audit_bprm_fcaps", "7791": "audit_buffer", "7792": "audit_buffer_alloc", "7793": "audit_buffer_free", "7794": "audit_bufsiz", "7795": "audit_build_context", "7796": "audit_cap_data", "7797": "audit_capset", "7798": "audit_chunk", "7799": "audit_class_chattr", "7800": "audit_class_chattr_32", "7801": "audit_class_read", "7802": "audit_class_read_32", "7803": "audit_class_signal", "7804": "audit_class_signal_32", "7805": "audit_class_write", "7806": "audit_class_write_32", "7807": "audit_classify_arch", "7808": "audit_classify_syscall", "7809": "audit_cmd_mutex", "7810": "audit_comparator", "7811": "audit_compare_auid_to_euid", "7812": "audit_compare_auid_to_fsuid", "7813": "audit_compare_auid_to_obj_uid", "7814": "audit_compare_auid_to_suid", "7815": "audit_compare_dname_path", "7816": "audit_compare_egid_to_fsgid", "7817": "audit_compare_egid_to_obj_gid", "7818": "audit_compare_egid_to_sgid", "7819": "audit_compare_euid_to_fsuid", "7820": "audit_compare_euid_to_obj_uid", "7821": "audit_compare_euid_to_suid", "7822": "audit_compare_fsgid_to_obj_gid", "7823": "audit_compare_fsuid_to_obj_uid", "7824": "audit_compare_gid", "7825": "audit_compare_gid_to_egid", "7826": "audit_compare_gid_to_fsgid", "7827": "audit_compare_gid_to_obj_gid", "7828": "audit_compare_gid_to_sgid", "7829": "audit_compare_rule", "7830": "audit_compare_sgid_to_fsgid", "7831": "audit_compare_sgid_to_obj_gid", "7832": "audit_compare_suid_to_fsuid", "7833": "audit_compare_suid_to_obj_uid", "7834": "audit_compare_uid", "7835": "audit_compare_uid_to_auid", "7836": "audit_compare_uid_to_euid", "7837": "audit_compare_uid_to_fsuid", "7838": "audit_compare_uid_to_obj_uid", "7839": "audit_compare_uid_to_suid", "7840": "audit_config_change", "7841": "audit_context", "7842": "audit_copy_fcaps", "7843": "audit_copy_inode", "7844": "audit_core_dumps", "7845": "audit_cwd", "7846": "audit_data_to_entry", "7847": "audit_default", "7848": "audit_del", "7849": "audit_del_rule", "7850": "audit_devmajor", "7851": "audit_devminor", "7852": "audit_dir", "7853": "audit_disabled", "7854": "audit_do_config_change", "7855": "audit_dummy_context", "7856": "audit_dupe_lsm_field", "7857": "audit_dupe_rule", "7858": "audit_dupe_watch", "7859": "audit_egid", "7860": "audit_enabled", "7861": "audit_entry", "7862": "audit_eoe", "7863": "audit_equal", "7864": "audit_euid", "7865": "audit_ever_enabled", "7866": "audit_execve", "7867": "audit_exit", "7868": "audit_expand", "7869": "audit_fail_panic", "7870": "audit_fail_printk", "7871": "audit_fail_silent", "7872": "audit_failure", "7873": "audit_fd_pair", "7874": "audit_feature_bitmap_all", "7875": "audit_feature_change", "7876": "audit_feature_loginuid_immutable", "7877": "audit_feature_names", "7878": "audit_feature_only_unset_loginuid", "7879": "audit_feature_to_mask", "7880": "audit_feature_version", "7881": "audit_features", "7882": "audit_field", "7883": "audit_field_compare", "7884": "audit_field_valid", "7885": "audit_filetype", "7886": "audit_filter_entry", "7887": "audit_filter_exit", "7888": "audit_filter_inode_name", "7889": "audit_filter_inodes", "7890": "audit_filter_list", "7891": "audit_filter_mutex", "7892": "audit_filter_prepend", "7893": "audit_filter_rules", "7894": "audit_filter_syscall", "7895": "audit_filter_task", "7896": "audit_filter_type", "7897": "audit_filter_user", "7898": "audit_filter_user_rules", "7899": "audit_filterkey", "7900": "audit_find_parent", "7901": "audit_find_rule", "7902": "audit_first_user_msg", "7903": "audit_first_user_msg2", "7904": "audit_free", "7905": "audit_free_aux", "7906": "audit_free_context", "7907": "audit_free_lsm_field", "7908": "audit_free_names", "7909": "audit_free_parent", "7910": "audit_free_rule", "7911": "audit_free_rule_rcu", "7912": "audit_freelist", "7913": "audit_freelist_count", "7914": "audit_freelist_lock", "7915": "audit_fs_watch", "7916": "audit_fsgid", "7917": "audit_fsuid", "7918": "audit_ge", "7919": "audit_get", "7920": "audit_get_feature", "7921": "audit_get_loginuid", "7922": "audit_get_nd", "7923": "audit_get_parent", "7924": "audit_get_sessionid", "7925": "audit_get_stamp", "7926": "audit_get_watch", "7927": "audit_gid", "7928": "audit_gid_comparator", "7929": "audit_greater_than", "7930": "audit_greater_than_or_equal", "7931": "audit_gt", "7932": "audit_hash_ino", "7933": "audit_hold_skb", "7934": "audit_in_mask", "7935": "audit_init", "7936": "audit_init_entry", "7937": "audit_init_parent", "7938": "audit_init_watch", "7939": "audit_initialized", "7940": "audit_inode", "7941": "audit_inode_buckets", "7942": "audit_inode_hash", "7943": "audit_inode_hidden", "7944": "audit_inode_parent", "7945": "audit_ipc", "7946": "audit_ipc_set_perm", "7947": "audit_kernel", "7948": "audit_kill_trees", "7949": "audit_killed_trees", "7950": "audit_krule", "7951": "audit_krule_to_data", "7952": "audit_last_feature", "7953": "audit_last_user_msg", "7954": "audit_last_user_msg2", "7955": "audit_launch_prune", "7956": "audit_le", "7957": "audit_less_than", "7958": "audit_less_than_or_equal", "7959": "audit_list", "7960": "audit_list_rules", "7961": "audit_list_rules_send", "7962": "audit_locked", "7963": "audit_log", "7964": "audit_log_cap", "7965": "audit_log_common_recv_msg", "7966": "audit_log_config_change", "7967": "audit_log_d_path", "7968": "audit_log_d_path_exe", "7969": "audit_log_end", "7970": "audit_log_execve_info", "7971": "audit_log_exit", "7972": "audit_log_fcaps", "7973": "audit_log_feature_change", "7974": "audit_log_format", "7975": "audit_log_key", "7976": "audit_log_link_denied", "7977": "audit_log_lost", "7978": "audit_log_n_hex", "7979": "audit_log_n_string", "7980": "audit_log_n_untrustedstring", "7981": "audit_log_name", "7982": "audit_log_pid_context", "7983": "audit_log_proctitle", "7984": "audit_log_rule_change", "7985": "audit_log_secctx", "7986": "audit_log_session_info", "7987": "audit_log_set_loginuid", "7988": "audit_log_single_execve_arg", "7989": "audit_log_start", "7990": "audit_log_string", "7991": "audit_log_task", "7992": "audit_log_task_context", "7993": "audit_log_task_info", "7994": "audit_log_untrustedstring", "7995": "audit_log_vformat", "7996": "audit_login", "7997": "audit_loginuid", "7998": "audit_loginuid_legacy", "7999": "audit_loginuid_set", "8000": "audit_lost", "8001": "audit_lt", "8002": "audit_make_equiv", "8003": "audit_make_reply", "8004": "audit_make_tree", "8005": "audit_match_class", "8006": "audit_match_class_bits", "8007": "audit_match_filetype", "8008": "audit_match_perm", "8009": "audit_match_signal", "8010": "audit_max_field_compare", "8011": "audit_max_fields", "8012": "audit_max_key_len", "8013": "audit_maxfree", "8014": "audit_mmap", "8015": "audit_mq_getsetattr", "8016": "audit_mq_notify", "8017": "audit_mq_open", "8018": "audit_mq_sendrecv", "8019": "audit_msgtype", "8020": "audit_n_rules", "8021": "audit_name_full", "8022": "audit_names", "8023": "audit_net", "8024": "audit_net_exit", "8025": "audit_net_id", "8026": "audit_net_init", "8027": "audit_net_ops", "8028": "audit_netlink_list", "8029": "audit_netlink_ok", "8030": "audit_never", "8031": "audit_nlgrp_max", "8032": "audit_nlgrp_readlog", "8033": "audit_nlk_portid", "8034": "audit_not_equal", "8035": "audit_nr_filters", "8036": "audit_obj_gid", "8037": "audit_obj_lev_high", "8038": "audit_obj_lev_low", "8039": "audit_obj_pid", "8040": "audit_obj_role", "8041": "audit_obj_type", "8042": "audit_obj_uid", "8043": "audit_obj_user", "8044": "audit_off", "8045": "audit_on", "8046": "audit_ops", "8047": "audit_pack_string", "8048": "audit_panic", "8049": "audit_parent", "8050": "audit_path", "8051": "audit_perm", "8052": "audit_perm_attr", "8053": "audit_perm_exec", "8054": "audit_perm_read", "8055": "audit_perm_write", "8056": "audit_pers", "8057": "audit_pid", "8058": "audit_possible", "8059": "audit_ppid", "8060": "audit_printk_skb", "8061": "audit_proctitle", "8062": "audit_proctitle_free", "8063": "audit_proctitle_rtrim", "8064": "audit_put_chunk", "8065": "audit_put_parent", "8066": "audit_put_tree", "8067": "audit_put_watch", "8068": "audit_rate_check", "8069": "audit_rate_limit", "8070": "audit_receive", "8071": "audit_receive_msg", "8072": "audit_receive_skb", "8073": "audit_record_context", "8074": "audit_register_class", "8075": "audit_remove_parent_watches", "8076": "audit_remove_tree_rule", "8077": "audit_remove_watch", "8078": "audit_remove_watch_rule", "8079": "audit_reply", "8080": "audit_rule_change", "8081": "audit_rule_data", "8082": "audit_rules_list", "8083": "audit_schedule_prune", "8084": "audit_seccomp", "8085": "audit_send_list", "8086": "audit_send_reply", "8087": "audit_send_reply_thread", "8088": "audit_serial", "8089": "audit_set", "8090": "audit_set_auditable", "8091": "audit_set_backlog_limit", "8092": "audit_set_backlog_wait_time", "8093": "audit_set_enabled", "8094": "audit_set_failure", "8095": "audit_set_feature", "8096": "audit_set_loginuid", "8097": "audit_set_loginuid_perm", "8098": "audit_set_portid", "8099": "audit_set_rate_limit", "8100": "audit_sgid", "8101": "audit_sig_info", "8102": "audit_sig_pid", "8103": "audit_sig_sid", "8104": "audit_sig_uid", "8105": "audit_signal_info", "8106": "audit_signals", "8107": "audit_skb_hold_queue", "8108": "audit_skb_queue", "8109": "audit_sock", "8110": "audit_sockaddr", "8111": "audit_socketcall", "8112": "audit_state", "8113": "audit_status", "8114": "audit_status_enabled", "8115": "audit_status_rate_limit", "8116": "audit_string_contains_control", "8117": "audit_subj_clr", "8118": "audit_subj_role", "8119": "audit_subj_sen", "8120": "audit_subj_type", "8121": "audit_subj_user", "8122": "audit_success", "8123": "audit_suid", "8124": "audit_syscall", "8125": "audit_syscall_classes", "8126": "audit_tag_tree", "8127": "audit_take_context", "8128": "audit_to_entry_common", "8129": "audit_to_inode", "8130": "audit_to_op", "8131": "audit_to_watch", "8132": "audit_tree", "8133": "audit_tree_destroy_watch", "8134": "audit_tree_freeing_mark", "8135": "audit_tree_group", "8136": "audit_tree_handle_event", "8137": "audit_tree_log_remove_rule", "8138": "audit_tree_lookup", "8139": "audit_tree_match", "8140": "audit_tree_path", "8141": "audit_tree_refs", "8142": "audit_trim", "8143": "audit_trim_trees", "8144": "audit_tty", "8145": "audit_tty_get", "8146": "audit_tty_log_passwd", "8147": "audit_tty_set", "8148": "audit_tty_status", "8149": "audit_type_child_create", "8150": "audit_type_child_delete", "8151": "audit_type_normal", "8152": "audit_type_parent", "8153": "audit_type_unknown", "8154": "audit_uid", "8155": "audit_uid_comparator", "8156": "audit_uid_unset", "8157": "audit_uninitialized", "8158": "audit_unpack_string", "8159": "audit_update_lsm_rules", "8160": "audit_update_watch", "8161": "audit_user", "8162": "audit_user_avc", "8163": "audit_watch", "8164": "audit_watch_compare", "8165": "audit_watch_free_mark", "8166": "audit_watch_fsnotify_ops", "8167": "audit_watch_group", "8168": "audit_watch_handle_event", "8169": "audit_watch_init", "8170": "audit_watch_log_rule_change", "8171": "audit_watch_path", "8172": "audit_word", "8173": "auditsc_args", "8174": "auditsc_failure", "8175": "auditsc_get_stamp", "8176": "auditsc_invalid", "8177": "auditsc_success", "8178": "auid", "8179": "aunet", "8180": "aup", "8181": "autogroup", "8182": "autogroup_create", "8183": "autogroup_default", "8184": "autogroup_destroy", "8185": "autogroup_free", "8186": "autogroup_init", "8187": "autogroup_kref_get", "8188": "autogroup_kref_put", "8189": "autogroup_move_group", "8190": "autogroup_path", "8191": "autogroup_seq_nr", "8192": "autogroup_task_get", "8193": "autogroup_task_group", "8194": "autoreap", "8195": "autoremove_wake_function", "8196": "autosleep_lock", "8197": "autosleep_show", "8198": "autosleep_state", "8199": "autosleep_wq", "8200": "autosleep_ws", "8201": "aux", "8202": "aux_head", "8203": "aux_mmap_count", "8204": "aux_mmap_locked", "8205": "aux_nest", "8206": "aux_nr_pages", "8207": "aux_offset", "8208": "aux_overwrite", "8209": "aux_pages", "8210": "aux_pgoff", "8211": "aux_pids", "8212": "aux_priv", "8213": "aux_refcount", "8214": "aux_size", "8215": "aux_tail", "8216": "aux_unlock", "8217": "aux_wakeup", "8218": "aux_watermark", "8219": "auxv", "8220": "auxv_size", "8221": "avail", "8222": "avail_normal", "8223": "available", "8224": "available_filter_functions", "8225": "available_tracers", "8226": "avenrun", "8227": "avg", "8228": "avg_atom", "8229": "avg_idle", "8230": "avg_load", "8231": "avg_local_sample_len", "8232": "avg_per_cpu", "8233": "avg_period", "8234": "ax", "8235": "axp", "8236": "axs", "8237": "axsig", "8238": "az", "8239": "b", "8240": "bacct", "8241": "bacct_add_tsk", "8242": "back", "8243": "backlog", "8244": "backlog_limit", "8245": "backlog_wait_time", "8246": "backtrace", "8247": "backtrace_regression_test", "8248": "backtrace_tasklet", "8249": "backtrace_test_irq", "8250": "backtrace_test_irq_callback", "8251": "backtrace_test_normal", "8252": "backtrace_test_saved", "8253": "backtrace_work", "8254": "bad", "8255": "bad_action_ret", "8256": "bad_bit", "8257": "bad_fork_cleanup_audit", "8258": "bad_fork_cleanup_count", "8259": "bad_fork_cleanup_files", "8260": "bad_fork_cleanup_fs", "8261": "bad_fork_cleanup_io", "8262": "bad_fork_cleanup_mm", "8263": "bad_fork_cleanup_namespaces", "8264": "bad_fork_cleanup_perf", "8265": "bad_fork_cleanup_policy", "8266": "bad_fork_cleanup_semundo", "8267": "bad_fork_cleanup_sighand", "8268": "bad_fork_cleanup_signal", "8269": "bad_fork_cleanup_threadgroup_lock", "8270": "bad_fork_free", "8271": "bad_fork_free_pid", "8272": "bad_unshare_cleanup_cred", "8273": "bad_unshare_cleanup_fd", "8274": "bad_unshare_cleanup_fs", "8275": "bad_unshare_out", "8276": "bad_version", "8277": "balance", "8278": "balance_cpu", "8279": "balance_flag_changed", "8280": "balance_interval", "8281": "balance_runtime", "8282": "balanced", "8283": "balancing", "8284": "barr", "8285": "barrier", "8286": "barrier_cbs_count", "8287": "barrier_cbs_invoked", "8288": "barrier_cbs_tasks", "8289": "barrier_cbs_wq", "8290": "barrier_completion", "8291": "barrier_cpu_count", "8292": "barrier_head", "8293": "barrier_mutex", "8294": "barrier_phase", "8295": "barrier_task", "8296": "barrier_wq", "8297": "base", "8298": "base_addr", "8299": "base_clockid", "8300": "base_files", "8301": "baseid", "8302": "basename", "8303": "batch_check0", "8304": "batch_check1", "8305": "batch_count", "8306": "batch_done", "8307": "batch_queue", "8308": "batchsummary", "8309": "bc", "8310": "bc_handler", "8311": "bc_moved", "8312": "bc_set_mode", "8313": "bc_set_next", "8314": "bc_stopped", "8315": "bctimer", "8316": "bd_dev", "8317": "bd_disk", "8318": "bd_mutex", "8319": "bd_part", "8320": "bdev", "8321": "bdev_get_queue", "8322": "bdevname", "8323": "bdevname_size", "8324": "bdget", "8325": "bdput", "8326": "be", "8327": "be32_to_cpu", "8328": "be64_to_cpu", "8329": "became", "8330": "because", "8331": "beenhere", "8332": "beenonline", "8333": "before", "8334": "begin", "8335": "begin_pfn", "8336": "being", "8337": "benchmark", "8338": "benchmark_event", "8339": "benchmark_event_strlen", "8340": "best", "8341": "best_cpu", "8342": "best_imp", "8343": "best_task", "8344": "bestprev", "8345": "between", "8346": "bf", "8347": "bfs", "8348": "bi_bdev", "8349": "bi_end_io", "8350": "bi_io_vec", "8351": "bi_iter", "8352": "bi_private", "8353": "bi_rw", "8354": "bi_sector", "8355": "bi_size", "8356": "big_event_size", "8357": "bin", "8358": "bin_attr", "8359": "bin_attribute", "8360": "bin_bus_isa_table", "8361": "bin_bus_table", "8362": "bin_convert_t", "8363": "bin_dev_table", "8364": "bin_dir", "8365": "bin_dn_node_address", "8366": "bin_fs_ocfs2_nm_table", "8367": "bin_fs_ocfs2_table", "8368": "bin_fs_quota_table", "8369": "bin_fs_table", "8370": "bin_fs_xfs_table", "8371": "bin_inotify_table", "8372": "bin_intvec", "8373": "bin_ipmi_table", "8374": "bin_kern_table", "8375": "bin_mac_hid_files", "8376": "bin_net_atalk_table", "8377": "bin_net_ax25_param_table", "8378": "bin_net_ax25_table", "8379": "bin_net_core_table", "8380": "bin_net_decnet_conf", "8381": "bin_net_decnet_conf_vars", "8382": "bin_net_decnet_table", "8383": "bin_net_ipv4_conf_table", "8384": "bin_net_ipv4_conf_vars_table", "8385": "bin_net_ipv4_netfilter_table", "8386": "bin_net_ipv4_route_table", "8387": "bin_net_ipv4_table", "8388": "bin_net_ipv6_conf_table", "8389": "bin_net_ipv6_conf_var_table", "8390": "bin_net_ipv6_icmp_table", "8391": "bin_net_ipv6_route_table", "8392": "bin_net_ipv6_table", "8393": "bin_net_ipx_table", "8394": "bin_net_irda_table", "8395": "bin_net_llc_llc2_table", "8396": "bin_net_llc_llc2_timeout_table", "8397": "bin_net_llc_station_table", "8398": "bin_net_llc_table", "8399": "bin_net_neigh_table", "8400": "bin_net_neigh_vars_table", "8401": "bin_net_netfilter_table", "8402": "bin_net_netrom_table", "8403": "bin_net_rose_table", "8404": "bin_net_sctp_table", "8405": "bin_net_table", "8406": "bin_net_tr_table", "8407": "bin_net_unix_table", "8408": "bin_net_x25_table", "8409": "bin_pm_table", "8410": "bin_pty_table", "8411": "bin_raid_table", "8412": "bin_random_table", "8413": "bin_root_table", "8414": "bin_s390dbf_table", "8415": "bin_scsi_table", "8416": "bin_string", "8417": "bin_sunrpc_table", "8418": "bin_table", "8419": "bin_ulongvec", "8420": "bin_uuid", "8421": "bin_vm_table", "8422": "binary", "8423": "binary_sysctl", "8424": "bind", "8425": "binfmt", "8426": "binfmt_misc_table", "8427": "bio", "8428": "bio_add_page", "8429": "bio_alloc", "8430": "bio_chain", "8431": "bio_flagged", "8432": "bio_put", "8433": "bio_rw", "8434": "bio_uptodate", "8435": "bit", "8436": "bit_a", "8437": "bit_b", "8438": "bit_backwards", "8439": "bit_forwards", "8440": "bit_nr", "8441": "bit_wait", "8442": "bit_wait_io", "8443": "bit_wait_io_timeout", "8444": "bit_wait_timeout", "8445": "bit_waitqueue", "8446": "bitcount", "8447": "bitfield", "8448": "bitfield_fetch_param", "8449": "bitmap", "8450": "bitmap_clear", "8451": "bitmap_copy", "8452": "bitmap_empty", "8453": "bitmap_find_next_zero_area", "8454": "bitmap_len", "8455": "bitmap_or", "8456": "bitmap_set", "8457": "bitmap_size", "8458": "bitmask_ptr", "8459": "bitmask_size", "8460": "bits", "8461": "bits_per_byte", "8462": "bits_per_compat_long", "8463": "bits_per_long", "8464": "bits_per_page", "8465": "bits_per_page_mask", "8466": "bits_to_compat_longs", "8467": "bits_to_longs", "8468": "bkt", "8469": "bl", "8470": "blimit", "8471": "blk_add_driver_data", "8472": "blk_add_trace_bio", "8473": "blk_add_trace_bio_backmerge", "8474": "blk_add_trace_bio_bounce", "8475": "blk_add_trace_bio_complete", "8476": "blk_add_trace_bio_frontmerge", "8477": "blk_add_trace_bio_queue", "8478": "blk_add_trace_bio_remap", "8479": "blk_add_trace_getrq", "8480": "blk_add_trace_plug", "8481": "blk_add_trace_rq", "8482": "blk_add_trace_rq_abort", "8483": "blk_add_trace_rq_complete", "8484": "blk_add_trace_rq_insert", "8485": "blk_add_trace_rq_issue", "8486": "blk_add_trace_rq_remap", "8487": "blk_add_trace_rq_requeue", "8488": "blk_add_trace_sleeprq", "8489": "blk_add_trace_split", "8490": "blk_add_trace_unplug", "8491": "blk_classic", "8492": "blk_create_buf_file_callback", "8493": "blk_dropped_fops", "8494": "blk_dropped_read", "8495": "blk_dump_cmd", "8496": "blk_flush_plug", "8497": "blk_io_trace", "8498": "blk_io_trace_magic", "8499": "blk_io_trace_remap", "8500": "blk_io_trace_version", "8501": "blk_log_action", "8502": "blk_log_action_classic", "8503": "blk_log_action_t", "8504": "blk_log_dump_pdu", "8505": "blk_log_generic", "8506": "blk_log_msg", "8507": "blk_log_plug", "8508": "blk_log_remap", "8509": "blk_log_split", "8510": "blk_log_unplug", "8511": "blk_log_with_error", "8512": "blk_msg_fops", "8513": "blk_msg_write", "8514": "blk_needs_flush_plug", "8515": "blk_probes_ref", "8516": "blk_register_tracepoints", "8517": "blk_relay_callbacks", "8518": "blk_remove_buf_file_callback", "8519": "blk_rq_bytes", "8520": "blk_rq_pos", "8521": "blk_schedule_flush_plug", "8522": "blk_subbuf_start_callback", "8523": "blk_ta_abort", "8524": "blk_ta_backmerge", "8525": "blk_ta_bounce", "8526": "blk_ta_complete", "8527": "blk_ta_drv_data", "8528": "blk_ta_frontmerge", "8529": "blk_ta_getrq", "8530": "blk_ta_insert", "8531": "blk_ta_issue", "8532": "blk_ta_plug", "8533": "blk_ta_queue", "8534": "blk_ta_remap", "8535": "blk_ta_requeue", "8536": "blk_ta_sleeprq", "8537": "blk_ta_split", "8538": "blk_ta_unplug_io", "8539": "blk_ta_unplug_timer", "8540": "blk_tc_act", "8541": "blk_tc_ahead", "8542": "blk_tc_complete", "8543": "blk_tc_discard", "8544": "blk_tc_drv_data", "8545": "blk_tc_flush", "8546": "blk_tc_fs", "8547": "blk_tc_fua", "8548": "blk_tc_issue", "8549": "blk_tc_meta", "8550": "blk_tc_notify", "8551": "blk_tc_pc", "8552": "blk_tc_queue", "8553": "blk_tc_rahead", "8554": "blk_tc_read", "8555": "blk_tc_requeue", "8556": "blk_tc_shift", "8557": "blk_tc_sync", "8558": "blk_tc_write", "8559": "blk_tn_max_msg", "8560": "blk_tn_message", "8561": "blk_tn_process", "8562": "blk_tn_timestamp", "8563": "blk_tr", "8564": "blk_trace", "8565": "blk_trace_attr_group", "8566": "blk_trace_attrs", "8567": "blk_trace_cleanup", "8568": "blk_trace_device_attr", "8569": "blk_trace_event_print", "8570": "blk_trace_event_print_binary", "8571": "blk_trace_free", "8572": "blk_trace_get_queue", "8573": "blk_trace_init_sysfs", "8574": "blk_trace_ioctl", "8575": "blk_trace_mask2str", "8576": "blk_trace_remove", "8577": "blk_trace_remove_queue", "8578": "blk_trace_remove_sysfs", "8579": "blk_trace_setup", "8580": "blk_trace_setup_lba", "8581": "blk_trace_setup_queue", "8582": "blk_trace_shutdown", "8583": "blk_trace_startstop", "8584": "blk_trace_str2mask", "8585": "blk_trace_synthesize_old_trace", "8586": "blk_tracer", "8587": "blk_tracer_enabled", "8588": "blk_tracer_flags", "8589": "blk_tracer_init", "8590": "blk_tracer_opts", "8591": "blk_tracer_print_header", "8592": "blk_tracer_print_line", "8593": "blk_tracer_reset", "8594": "blk_tracer_set_flag", "8595": "blk_tracer_start", "8596": "blk_tracer_stop", "8597": "blk_tree_mutex", "8598": "blk_tree_root", "8599": "blk_unregister_tracepoints", "8600": "blk_user_trace_setup", "8601": "blkd_tasks", "8602": "blkdev_get_by_dev", "8603": "blkdev_put", "8604": "blkio_count", "8605": "blkio_delay", "8606": "blkio_delay_total", "8607": "blkio_start", "8608": "blktrace_bdev_size", "8609": "blktrace_running", "8610": "blktrace_seq", "8611": "blktrace_setup", "8612": "blktrace_stopped", "8613": "blktracesetup", "8614": "blktracesetup32", "8615": "blktracestart", "8616": "blktracestop", "8617": "blktraceteardown", "8618": "block", "8619": "block_all_signals", "8620": "block_device", "8621": "block_dump", "8622": "block_max", "8623": "block_nr", "8624": "block_start", "8625": "block_unplug", "8626": "blocked", "8627": "blocked_load_avg", "8628": "blocked_on", "8629": "blocking_init_notifier_head", "8630": "blocking_notifier_call_chain", "8631": "blocking_notifier_chain_cond_register", "8632": "blocking_notifier_chain_register", "8633": "blocking_notifier_chain_unregister", "8634": "blocking_notifier_head", "8635": "blocks", "8636": "bm", "8637": "bm1", "8638": "bm2", "8639": "bm_avg", "8640": "bm_bits_per_block", "8641": "bm_block_mask", "8642": "bm_block_shift", "8643": "bm_cnt", "8644": "bm_end_of_map", "8645": "bm_entries_per_level", "8646": "bm_event_thread", "8647": "bm_first", "8648": "bm_last", "8649": "bm_max", "8650": "bm_min", "8651": "bm_rtree_level_mask", "8652": "bm_rtree_level_shift", "8653": "bm_std", "8654": "bm_stddev", "8655": "bm_str", "8656": "bm_total", "8657": "bm_totalsq", "8658": "bmagic", "8659": "bo", "8660": "body", "8661": "bool", "8662": "boolkp", "8663": "boolval", "8664": "boost", "8665": "boost_kthread_status", "8666": "boost_kthread_task", "8667": "boost_mtx", "8668": "boost_mutex", "8669": "boost_starttime", "8670": "boost_tasks", "8671": "boost_time", "8672": "boot", "8673": "boot_acpi", "8674": "boot_alloc_snapshot", "8675": "boot_cpu", "8676": "boot_delay", "8677": "boot_init_stack_canary", "8678": "boot_tvec_bases", "8679": "bootconsole", "8680": "bootloader_type", "8681": "bootloader_version", "8682": "bootmem_resource_free", "8683": "bootmem_resource_lock", "8684": "bootup", "8685": "bootup_event_buf", "8686": "bootup_tracer_buf", "8687": "bounce_acquired", "8688": "bounce_acquired_read", "8689": "bounce_acquired_write", "8690": "bounce_contended", "8691": "bounce_contended_read", "8692": "bounce_contended_write", "8693": "bounces", "8694": "bound_on", "8695": "bp", "8696": "bp_access_watchpoint", "8697": "bp_addr", "8698": "bp_breakpoint", "8699": "bp_check", "8700": "bp_delay", "8701": "bp_delayed", "8702": "bp_enabled", "8703": "bp_free", "8704": "bp_hardware_breakpoint", "8705": "bp_installed", "8706": "bp_type", "8707": "bp_undefined", "8708": "bp_vaddr", "8709": "bp_write_watchpoint", "8710": "bpage", "8711": "bpf", "8712": "bpf_a", "8713": "bpf_abs", "8714": "bpf_access_type", "8715": "bpf_add", "8716": "bpf_alu", "8717": "bpf_alu64", "8718": "bpf_alu_string", "8719": "bpf_and", "8720": "bpf_arg_type", "8721": "bpf_array", "8722": "bpf_arsh", "8723": "bpf_attr", "8724": "bpf_b", "8725": "bpf_binary_header", "8726": "bpf_call", "8727": "bpf_check", "8728": "bpf_check_classic", "8729": "bpf_class", "8730": "bpf_class_string", "8731": "bpf_convert_filter", "8732": "bpf_div", "8733": "bpf_dw", "8734": "bpf_end", "8735": "bpf_exist", "8736": "bpf_exit", "8737": "bpf_fill_ill_insns", "8738": "bpf_func", "8739": "bpf_func_id", "8740": "bpf_func_ktime_get_ns", "8741": "bpf_func_map_delete_elem", "8742": "bpf_func_map_lookup_elem", "8743": "bpf_func_map_update_elem", "8744": "bpf_func_probe_read", "8745": "bpf_func_proto", "8746": "bpf_func_trace_printk", "8747": "bpf_get_prandom_u32", "8748": "bpf_get_prandom_u32_proto", "8749": "bpf_get_smp_processor_id", "8750": "bpf_get_smp_processor_id_proto", "8751": "bpf_h", "8752": "bpf_htab", "8753": "bpf_imm", "8754": "bpf_ind", "8755": "bpf_insn", "8756": "bpf_int_jit_compile", "8757": "bpf_internal_load_pointer_neg_helper", "8758": "bpf_ja", "8759": "bpf_jeq", "8760": "bpf_jge", "8761": "bpf_jgt", "8762": "bpf_jit_binary_alloc", "8763": "bpf_jit_binary_free", "8764": "bpf_jit_fill_hole_t", "8765": "bpf_jit_free", "8766": "bpf_jmp", "8767": "bpf_jmp_string", "8768": "bpf_jne", "8769": "bpf_jset", "8770": "bpf_jsge", "8771": "bpf_jsgt", "8772": "bpf_k", "8773": "bpf_ktime_get_ns", "8774": "bpf_ktime_get_ns_proto", "8775": "bpf_ld", "8776": "bpf_ldst_string", "8777": "bpf_ldx", "8778": "bpf_len", "8779": "bpf_load_pointer", "8780": "bpf_lsh", "8781": "bpf_map", "8782": "bpf_map_create", "8783": "bpf_map_create_last_field", "8784": "bpf_map_delete_elem", "8785": "bpf_map_delete_elem_last_field", "8786": "bpf_map_delete_elem_proto", "8787": "bpf_map_fops", "8788": "bpf_map_free_deferred", "8789": "bpf_map_get", "8790": "bpf_map_get_next_key", "8791": "bpf_map_get_next_key_last_field", "8792": "bpf_map_lookup_elem", "8793": "bpf_map_lookup_elem_last_field", "8794": "bpf_map_lookup_elem_proto", "8795": "bpf_map_ops", "8796": "bpf_map_put", "8797": "bpf_map_release", "8798": "bpf_map_type_array", "8799": "bpf_map_type_hash", "8800": "bpf_map_type_list", "8801": "bpf_map_types", "8802": "bpf_map_update_elem", "8803": "bpf_map_update_elem_last_field", "8804": "bpf_map_update_elem_proto", "8805": "bpf_maxinsns", "8806": "bpf_mem", "8807": "bpf_misc", "8808": "bpf_mod", "8809": "bpf_mode", "8810": "bpf_mov", "8811": "bpf_mul", "8812": "bpf_neg", "8813": "bpf_noexist", "8814": "bpf_op", "8815": "bpf_or", "8816": "bpf_probe_read", "8817": "bpf_probe_read_proto", "8818": "bpf_prog", "8819": "bpf_prog_active", "8820": "bpf_prog_alloc", "8821": "bpf_prog_aux", "8822": "bpf_prog_fops", "8823": "bpf_prog_free", "8824": "bpf_prog_free_deferred", "8825": "bpf_prog_get", "8826": "bpf_prog_load", "8827": "bpf_prog_load_last_field", "8828": "bpf_prog_lock_ro", "8829": "bpf_prog_put", "8830": "bpf_prog_realloc", "8831": "bpf_prog_release", "8832": "bpf_prog_run", "8833": "bpf_prog_select_runtime", "8834": "bpf_prog_size", "8835": "bpf_prog_type", "8836": "bpf_prog_type_kprobe", "8837": "bpf_prog_type_list", "8838": "bpf_prog_type_sched_act", "8839": "bpf_prog_type_sched_cls", "8840": "bpf_prog_type_socket_filter", "8841": "bpf_prog_types", "8842": "bpf_pseudo_map_fd", "8843": "bpf_r0", "8844": "bpf_r1", "8845": "bpf_r10", "8846": "bpf_r2", "8847": "bpf_r3", "8848": "bpf_r4", "8849": "bpf_r5", "8850": "bpf_r6", "8851": "bpf_r7", "8852": "bpf_r8", "8853": "bpf_r9", "8854": "bpf_read", "8855": "bpf_reg_0", "8856": "bpf_reg_1", "8857": "bpf_reg_10", "8858": "bpf_reg_2", "8859": "bpf_reg_3", "8860": "bpf_reg_4", "8861": "bpf_reg_5", "8862": "bpf_reg_6", "8863": "bpf_reg_7", "8864": "bpf_reg_8", "8865": "bpf_reg_9", "8866": "bpf_reg_a", "8867": "bpf_reg_arg1", "8868": "bpf_reg_ctx", "8869": "bpf_reg_fp", "8870": "bpf_reg_size", "8871": "bpf_reg_type", "8872": "bpf_reg_x", "8873": "bpf_register_map_type", "8874": "bpf_register_prog_type", "8875": "bpf_ret", "8876": "bpf_rsh", "8877": "bpf_size", "8878": "bpf_size_to_bytes", "8879": "bpf_src", "8880": "bpf_st", "8881": "bpf_stack_slot_type", "8882": "bpf_stx", "8883": "bpf_sub", "8884": "bpf_tax", "8885": "bpf_to_be", "8886": "bpf_to_le", "8887": "bpf_trace_printk", "8888": "bpf_trace_printk_proto", "8889": "bpf_txa", "8890": "bpf_verifier_lock", "8891": "bpf_verifier_ops", "8892": "bpf_w", "8893": "bpf_write", "8894": "bpf_x", "8895": "bpf_xadd", "8896": "bpf_xor", "8897": "bph_length", "8898": "bpn", "8899": "bpno", "8900": "bprint", "8901": "bprint_entry", "8902": "bprm", "8903": "bpt", "8904": "bpt_addr", "8905": "bpt_type", "8906": "bputs", "8907": "bputs_entry", "8908": "br_stack", "8909": "braille", "8910": "braille_register_console", "8911": "braille_set_options", "8912": "braille_unregister_console", "8913": "branch", "8914": "branch_print_header", "8915": "branch_stat_show", "8916": "branch_trace", "8917": "branch_trace_init", "8918": "branch_trace_reset", "8919": "branch_tracer", "8920": "branch_tracing_enabled", "8921": "branch_tracing_mutex", "8922": "break", "8923": "break_handler", "8924": "break_instr_size", "8925": "break_lock", "8926": "breakpoint", "8927": "brk", "8928": "brl", "8929": "brl_options", "8930": "broadcast", "8931": "broadcast_needs_cpu", "8932": "broadcast_shutdown_local", "8933": "broken_hierarchy", "8934": "brw", "8935": "bs", "8936": "bsd_acct_struct", "8937": "bsearch", "8938": "bsize", "8939": "bss_addr", "8940": "bss_align", "8941": "bss_pad", "8942": "bss_sz", "8943": "bt", "8944": "btaprompt", "8945": "btrace_mutex", "8946": "btrace_seq", "8947": "buckets", "8948": "buf", "8949": "buf_addr", "8950": "buf_align", "8951": "buf_len", "8952": "buf_max", "8953": "buf_max_data_size", "8954": "buf_min", "8955": "buf_nr", "8956": "buf_page_hdr_size", "8957": "buf_page_size", "8958": "buf_size", "8959": "buf_sz", "8960": "buf_thread_id_size", "8961": "buff", "8962": "buffer", "8963": "buffer_a", "8964": "buffer_b", "8965": "buffer_bytes", "8966": "buffer_data_page", "8967": "buffer_disabled", "8968": "buffer_ftrace_now", "8969": "buffer_iter", "8970": "buffer_page", "8971": "buffer_size_kb", "8972": "buffer_total_size_kb", "8973": "bufferram", "8974": "buffers", "8975": "buflen", "8976": "bufmax", "8977": "bufp", "8978": "bufptr", "8979": "bufsz", "8980": "bug", "8981": "bug_cleanup", "8982": "bug_msg", "8983": "bug_on", "8984": "build_bug_on", "8985": "build_group_mask", "8986": "build_lock_ops", "8987": "build_map_info", "8988": "build_overlap_sched_groups", "8989": "build_probe_list", "8990": "build_sched_domain", "8991": "build_sched_domains", "8992": "build_sched_groups", "8993": "burst", "8994": "bus", "8995": "bus_isa_mem_base", "8996": "bus_isa_port_base", "8997": "bus_isa_port_shift", "8998": "bus_mceerr_ao", "8999": "bus_mceerr_ar", "9000": "bus_type", "9001": "busiest", "9002": "busiest_capacity", "9003": "busiest_cpu", "9004": "busiest_load", "9005": "busiest_rq", "9006": "busiest_stat", "9007": "bust_spinlocks", "9008": "busy", "9009": "busy_factor", "9010": "busy_hash", "9011": "busy_idx", "9012": "busy_sd", "9013": "busy_worker_hash_order", "9014": "but", "9015": "buts", "9016": "bv_page", "9017": "bw", "9018": "bx", "9019": "by", "9020": "byte", "9021": "bytes", "9022": "bytes_alloc", "9023": "bytes_alloc_nested", "9024": "bytes_dropped", "9025": "bytes_dropped_nested", "9026": "bytes_to_bits", "9027": "bytes_written", "9028": "bytes_written_nested", "9029": "bytesperword", "9030": "c", "9031": "c0", "9032": "c1", "9033": "c_a_d", "9034": "c_old", "9035": "c_out", "9036": "ca", "9037": "cache", "9038": "cache_flush_is_safe", "9039": "cache_hit", "9040": "cache_hot_buddy", "9041": "cache_line_size", "9042": "cache_nice_tries", "9043": "cache_read", "9044": "cache_reader_page", "9045": "cachep", "9046": "cad_pid", "9047": "calc_cfs_shares", "9048": "calc_delta_fair", "9049": "calc_global_load", "9050": "calc_global_nohz", "9051": "calc_load", "9052": "calc_load_account_active", "9053": "calc_load_active", "9054": "calc_load_enter_idle", "9055": "calc_load_exit_idle", "9056": "calc_load_fold_active", "9057": "calc_load_fold_idle", "9058": "calc_load_idle", "9059": "calc_load_idx", "9060": "calc_load_migrate", "9061": "calc_load_n", "9062": "calc_load_read_idx", "9063": "calc_load_tasks", "9064": "calc_load_update", "9065": "calc_load_write_idx", "9066": "calc_tg_weight", "9067": "calc_timer_values", "9068": "calcnt", "9069": "calculate_imbalance", "9070": "call", "9071": "call_args", "9072": "call_fetch", "9073": "call_filter_check_discard", "9074": "call_function_data", "9075": "call_function_init", "9076": "call_modprobe", "9077": "call_panic", "9078": "call_rcu", "9079": "call_rcu_bh", "9080": "call_rcu_busted", "9081": "call_rcu_func_t", "9082": "call_rcu_sched", "9083": "call_rcu_tasks", "9084": "call_rcu_time", "9085": "call_single_data", "9086": "call_single_queue", "9087": "call_srcu", "9088": "call_timer_fn", "9089": "call_usermodehelper", "9090": "call_usermodehelper_exec", "9091": "call_usermodehelper_freeinfo", "9092": "call_usermodehelper_setup", "9093": "callback_head", "9094": "callback_lock", "9095": "callchain", "9096": "callchain_cpus_entries", "9097": "callchain_mutex", "9098": "callchain_recursion", "9099": "called", "9100": "caller", "9101": "caller_addr", "9102": "caller_addr0", "9103": "caller_addr1", "9104": "caller_addr2", "9105": "caller_addr3", "9106": "caller_saved", "9107": "caller_saved_regs", "9108": "calls", "9109": "calltime", "9110": "can", "9111": "can_add_hw", "9112": "can_attach", "9113": "can_boost", "9114": "can_cont", "9115": "can_expedite", "9116": "can_migrate_task", "9117": "can_nice", "9118": "can_request_irq", "9119": "can_stop_full_tick", "9120": "can_stop_idle_tick", "9121": "cancel_attach", "9122": "cancel_delayed_work", "9123": "cancel_delayed_work_sync", "9124": "cancel_ref", "9125": "cancel_txn", "9126": "cancel_waitq", "9127": "cancel_work_sync", "9128": "cancelled_write_bytes", "9129": "candidate", "9130": "cannot", "9131": "canrequest", "9132": "cap", "9133": "cap_array", "9134": "cap_audit_control", "9135": "cap_audit_read", "9136": "cap_audit_write", "9137": "cap_bit0_is_deprecated", "9138": "cap_block_suspend", "9139": "cap_bset", "9140": "cap_effective", "9141": "cap_empty_set", "9142": "cap_for_each_u32", "9143": "cap_full_set", "9144": "cap_get_target_pid", "9145": "cap_inheritable", "9146": "cap_intersect", "9147": "cap_ipc_lock", "9148": "cap_isclear", "9149": "cap_issubset", "9150": "cap_kill", "9151": "cap_last_cap", "9152": "cap_last_u32", "9153": "cap_permitted", "9154": "cap_pi", "9155": "cap_setgid", "9156": "cap_setid", "9157": "cap_setpcap", "9158": "cap_setuid", "9159": "cap_sys_admin", "9160": "cap_sys_boot", "9161": "cap_sys_module", "9162": "cap_sys_nice", "9163": "cap_sys_pacct", "9164": "cap_sys_ptrace", "9165": "cap_sys_resource", "9166": "cap_sys_time", "9167": "cap_syslog", "9168": "cap_user_data_t", "9169": "cap_user_header_t", "9170": "cap_valid", "9171": "cap_validate_magic", "9172": "cap_wake_alarm", "9173": "capa_move", "9174": "capa_now", "9175": "capabilities", "9176": "capable", "9177": "capable_wrt_inode_uidgid", "9178": "capacity", "9179": "capacity_of", "9180": "capacity_orig_of", "9181": "capget", "9182": "caps", "9183": "capset", "9184": "cascade", "9185": "case", "9186": "cat", "9187": "catastrophic", "9188": "catchup_timer_jiffies", "9189": "cb", "9190": "cb_barrier", "9191": "cb_count", "9192": "cb_cpu", "9193": "cbcpu", "9194": "cbcpumask", "9195": "cbflood_inter_holdoff", "9196": "cbflood_intra_holdoff", "9197": "cbflood_n_burst", "9198": "cbflood_n_per_burst", "9199": "cbflood_task", "9200": "cbs", "9201": "cbs_ready", "9202": "cbuf", "9203": "cbuts", "9204": "cc", "9205": "cc_cyc2ns_backwards", "9206": "cc_using_fentry", "9207": "ccur", "9208": "ccversion", "9209": "cd", "9210": "cdev", "9211": "cdev_add", "9212": "cdev_del", "9213": "cdev_init", "9214": "ce", "9215": "ce_broadcast_hrtimer", "9216": "ce_unbind", "9217": "ced", "9218": "centisecs", "9219": "cev_delta2ns", "9220": "cfd", "9221": "cfd_data", "9222": "cfg", "9223": "cfg_checksum", "9224": "cflags", "9225": "cfs", "9226": "cfs_b", "9227": "cfs_bandwidth", "9228": "cfs_bandwidth_slack_period", "9229": "cfs_bandwidth_usage_dec", "9230": "cfs_bandwidth_usage_inc", "9231": "cfs_bandwidth_used", "9232": "cfs_constraints_mutex", "9233": "cfs_period_us", "9234": "cfs_quota_us", "9235": "cfs_rq", "9236": "cfs_rq_clock_task", "9237": "cfs_rq_of", "9238": "cfs_rq_throttled", "9239": "cfs_schedulable_data", "9240": "cfs_tasks", "9241": "cft", "9242": "cfts", "9243": "cftype", "9244": "cftype_no_prefix", "9245": "cftype_not_on_root", "9246": "cftype_only_on_root", "9247": "cg_list", "9248": "cgroup", "9249": "cgroup_add_cftypes", "9250": "cgroup_add_dfl_cftypes", "9251": "cgroup_add_file", "9252": "cgroup_add_legacy_cftypes", "9253": "cgroup_addrm_files", "9254": "cgroup_apply_cftypes", "9255": "cgroup_assert_mutex_or_rcu_locked", "9256": "cgroup_attach_task", "9257": "cgroup_attach_task_all", "9258": "cgroup_calc_child_subsys_mask", "9259": "cgroup_clear_dir", "9260": "cgroup_clone_children_read", "9261": "cgroup_clone_children_write", "9262": "cgroup_controllers_show", "9263": "cgroup_css", "9264": "cgroup_css_links_read", "9265": "cgroup_destroy_locked", "9266": "cgroup_destroy_root", "9267": "cgroup_destroy_wq", "9268": "cgroup_dfl_base_files", "9269": "cgroup_disable", "9270": "cgroup_e_css", "9271": "cgroup_enable_task_cg_lists", "9272": "cgroup_exit", "9273": "cgroup_exit_cftypes", "9274": "cgroup_exit_root_id", "9275": "cgroup_file_mode", "9276": "cgroup_file_name", "9277": "cgroup_file_name_max", "9278": "cgroup_file_procs", "9279": "cgroup_file_tasks", "9280": "cgroup_file_write", "9281": "cgroup_filetype", "9282": "cgroup_fork", "9283": "cgroup_free_root", "9284": "cgroup_freezer_online", "9285": "cgroup_freezing", "9286": "cgroup_freezing_parent", "9287": "cgroup_freezing_self", "9288": "cgroup_frozen", "9289": "cgroup_fs", "9290": "cgroup_fs_type", "9291": "cgroup_get", "9292": "cgroup_get_e_css", "9293": "cgroup_has_tasks", "9294": "cgroup_hierarchy_idr", "9295": "cgroup_idr", "9296": "cgroup_idr_alloc", "9297": "cgroup_idr_lock", "9298": "cgroup_idr_remove", "9299": "cgroup_idr_replace", "9300": "cgroup_init", "9301": "cgroup_init_cftypes", "9302": "cgroup_init_early", "9303": "cgroup_init_root_id", "9304": "cgroup_init_subsys", "9305": "cgroup_is_dead", "9306": "cgroup_is_descendant", "9307": "cgroup_kf_ops", "9308": "cgroup_kf_single_ops", "9309": "cgroup_kf_syscall_ops", "9310": "cgroup_kill_sb", "9311": "cgroup_kn_lock_live", "9312": "cgroup_kn_set_ugid", "9313": "cgroup_kn_unlock", "9314": "cgroup_kobj", "9315": "cgroup_legacy_base_files", "9316": "cgroup_legacy_files_on_dfl", "9317": "cgroup_migrate", "9318": "cgroup_migrate_add_src", "9319": "cgroup_migrate_finish", "9320": "cgroup_migrate_prepare_dst", "9321": "cgroup_mkdir", "9322": "cgroup_mount", "9323": "cgroup_mutex", "9324": "cgroup_name", "9325": "cgroup_on_dfl", "9326": "cgroup_parent", "9327": "cgroup_path", "9328": "cgroup_pid_fry", "9329": "cgroup_pidlist", "9330": "cgroup_pidlist_destroy_all", "9331": "cgroup_pidlist_destroy_delay", "9332": "cgroup_pidlist_destroy_work_fn", "9333": "cgroup_pidlist_destroy_wq", "9334": "cgroup_pidlist_find", "9335": "cgroup_pidlist_find_create", "9336": "cgroup_pidlist_next", "9337": "cgroup_pidlist_show", "9338": "cgroup_pidlist_start", "9339": "cgroup_pidlist_stop", "9340": "cgroup_populate_dir", "9341": "cgroup_populated_show", "9342": "cgroup_post_fork", "9343": "cgroup_print_ss_mask", "9344": "cgroup_procs_write", "9345": "cgroup_put", "9346": "cgroup_read_notify_on_release", "9347": "cgroup_refresh_child_subsys_mask", "9348": "cgroup_release_agent", "9349": "cgroup_release_agent_show", "9350": "cgroup_release_agent_write", "9351": "cgroup_remount", "9352": "cgroup_rename", "9353": "cgroup_rm_cftypes", "9354": "cgroup_rm_cftypes_locked", "9355": "cgroup_rm_file", "9356": "cgroup_rmdir", "9357": "cgroup_root", "9358": "cgroup_root_controllers_show", "9359": "cgroup_root_count", "9360": "cgroup_root_from_kf", "9361": "cgroup_roots", "9362": "cgroup_sane_behavior_show", "9363": "cgroup_sb_opts", "9364": "cgroup_seqfile_next", "9365": "cgroup_seqfile_show", "9366": "cgroup_seqfile_start", "9367": "cgroup_seqfile_stop", "9368": "cgroup_set_legacy_files_on_dfl", "9369": "cgroup_setup_root", "9370": "cgroup_show_options", "9371": "cgroup_subsys", "9372": "cgroup_subsys_count", "9373": "cgroup_subsys_name", "9374": "cgroup_subsys_state", "9375": "cgroup_subtree_control_show", "9376": "cgroup_subtree_control_write", "9377": "cgroup_super_magic", "9378": "cgroup_task_count", "9379": "cgroup_task_migrate", "9380": "cgroup_tasks_write", "9381": "cgroup_taskset", "9382": "cgroup_taskset_first", "9383": "cgroup_taskset_for_each", "9384": "cgroup_taskset_next", "9385": "cgroup_transfer_tasks", "9386": "cgroup_tryget", "9387": "cgroup_update_dfl_csses", "9388": "cgroup_update_populated", "9389": "cgroup_write_notify_on_release", "9390": "cgroups", "9391": "cgroupstats", "9392": "cgroupstats_build", "9393": "cgroupstats_cmd_attr_fd", "9394": "cgroupstats_cmd_attr_max", "9395": "cgroupstats_cmd_get", "9396": "cgroupstats_cmd_get_policy", "9397": "cgroupstats_cmd_new", "9398": "cgroupstats_open", "9399": "cgroupstats_user_cmd", "9400": "cgrp", "9401": "cgrp1", "9402": "cgrp2", "9403": "cgrp_cpuset_clone_children", "9404": "cgrp_cset_link", "9405": "cgrp_dfl_root", "9406": "cgrp_dfl_root_inhibit_ss_mask", "9407": "cgrp_dfl_root_visible", "9408": "cgrp_link", "9409": "cgrp_links", "9410": "cgrp_notify_on_release", "9411": "cgrp_root_noprefix", "9412": "cgrp_root_sane_behavior", "9413": "cgrp_root_xattr", "9414": "ch", "9415": "chain", "9416": "chain_alloc", "9417": "chain_allocator", "9418": "chain_head", "9419": "chain_hlocks", "9420": "chain_init", "9421": "chain_key", "9422": "chain_lookup_hits", "9423": "chain_lookup_misses", "9424": "chained", "9425": "chainhashentry", "9426": "chan", "9427": "change", "9428": "change_clocksource", "9429": "change_okay", "9430": "change_pid", "9431": "change_prot_numa", "9432": "char", "9433": "charge", "9434": "charp", "9435": "check", "9436": "check_alu_op", "9437": "check_asym_packing", "9438": "check_attr", "9439": "check_call", "9440": "check_cfg", "9441": "check_cfs_rq_runtime", "9442": "check_chain_key", "9443": "check_class_changed", "9444": "check_clocks", "9445": "check_cond_jmp_op", "9446": "check_cpu_capacity", "9447": "check_cpu_stall", "9448": "check_cpu_stall_init", "9449": "check_cpu_stalls", "9450": "check_critical_timing", "9451": "check_ctx_access", "9452": "check_data_rlimit", "9453": "check_deadlock", "9454": "check_enqueue_throttle", "9455": "check_fetch_funcs", "9456": "check_flags", "9457": "check_for_release", "9458": "check_for_tasks", "9459": "check_free_space", "9460": "check_func_arg", "9461": "check_grep", "9462": "check_header", "9463": "check_holdout_task", "9464": "check_hung_task", "9465": "check_hung_uninterruptible_tasks", "9466": "check_image", "9467": "check_image_kernel", "9468": "check_irq_entry", "9469": "check_irq_resend", "9470": "check_irq_return", "9471": "check_irq_usage", "9472": "check_kill_permission", "9473": "check_kprobe_address_safe", "9474": "check_kprobe_rereg", "9475": "check_kthr_stop", "9476": "check_ld_abs", "9477": "check_ld_imm", "9478": "check_map_access", "9479": "check_mem_access", "9480": "check_mm", "9481": "check_modinfo", "9482": "check_modstruct_version", "9483": "check_module_license_and_versions", "9484": "check_noncircular", "9485": "check_pgt_cache", "9486": "check_pred_data", "9487": "check_pred_tree", "9488": "check_pred_tree_cb", "9489": "check_preds", "9490": "check_preempt_curr", "9491": "check_preempt_curr_idle", "9492": "check_preempt_curr_rt", "9493": "check_preempt_equal_prio", "9494": "check_preempt_tick", "9495": "check_preempt_wakeup", "9496": "check_prev_add", "9497": "check_prev_add_irq", "9498": "check_prevs_add", "9499": "check_prlimit_permission", "9500": "check_reg_arg", "9501": "check_resched", "9502": "check_same_owner", "9503": "check_spread", "9504": "check_stack_boundary", "9505": "check_stack_read", "9506": "check_stack_write", "9507": "check_state", "9508": "check_symbol", "9509": "check_unlock", "9510": "check_unshare_flags", "9511": "check_usage", "9512": "check_usage_backwards", "9513": "check_usage_f", "9514": "check_usage_forwards", "9515": "check_version", "9516": "check_xadd", "9517": "checkcore", "9518": "checksum", "9519": "checkwait", "9520": "child", "9521": "child_cs", "9522": "child_list", "9523": "child_mutex", "9524": "child_reaper", "9525": "child_subsys_mask", "9526": "child_tidptr", "9527": "child_total_time_enabled", "9528": "child_total_time_running", "9529": "children", "9530": "chip", "9531": "chip_bus_lock", "9532": "chip_bus_sync_unlock", "9533": "chip_data", "9534": "chip_types", "9535": "choose", "9536": "chown16", "9537": "chunk", "9538": "chunk_entry", "9539": "chunk_hash", "9540": "chunk_hash_heads", "9541": "chunks", "9542": "chwalk", "9543": "chz", "9544": "ci_ptr", "9545": "cinblock", "9546": "cinterval", "9547": "circ_space", "9548": "circular", "9549": "circular_queue", "9550": "ck_cmdline", "9551": "cl", "9552": "claim_allocations", "9553": "clamp", "9554": "clamp_t", "9555": "clamp_val", "9556": "class", "9557": "class_cache", "9558": "class_filter", "9559": "class_idx", "9560": "class_interface", "9561": "class_interface_register", "9562": "class_interface_unregister", "9563": "class_intf", "9564": "classes", "9565": "classhash_bits", "9566": "classhash_size", "9567": "classhashentry", "9568": "classic", "9569": "clc", "9570": "cld_continued", "9571": "cld_dumped", "9572": "cld_exited", "9573": "cld_killed", "9574": "cld_stopped", "9575": "cld_trapped", "9576": "clean_sort_range", "9577": "cleanup", "9578": "cleanup_all_probes", "9579": "cleanup_rp_inst", "9580": "cleanup_srcu_struct", "9581": "clear", "9582": "clear_all_latency_tracing", "9583": "clear_bit", "9584": "clear_buddies", "9585": "clear_child_tid", "9586": "clear_code", "9587": "clear_event_triggers", "9588": "clear_fast_ctr", "9589": "clear_frozen", "9590": "clear_ftrace_function", "9591": "clear_ftrace_pid", "9592": "clear_ftrace_pid_task", "9593": "clear_ftrace_swapper", "9594": "clear_global_latency_tracing", "9595": "clear_idx", "9596": "clear_lock_stats", "9597": "clear_nosave_free", "9598": "clear_operand_string", "9599": "clear_page", "9600": "clear_page_nosave", "9601": "clear_pending", "9602": "clear_preempt_need_resched", "9603": "clear_restore_sigmask", "9604": "clear_sched_clock_stable", "9605": "clear_seq", "9606": "clear_thread_flag", "9607": "clear_tlb_flush_pending", "9608": "clear_trace", "9609": "clear_tsk_need_resched", "9610": "clear_tsk_thread_flag", "9611": "clear_tsk_trace_trace", "9612": "clear_user_return_notifier", "9613": "clearpageprivate", "9614": "clears", "9615": "clk", "9616": "clock", "9617": "clock2alarm", "9618": "clock_adj", "9619": "clock_adjtime", "9620": "clock_base", "9621": "clock_boottime", "9622": "clock_boottime_alarm", "9623": "clock_event_device", "9624": "clock_event_mode", "9625": "clock_event_state", "9626": "clock_evt_feat_c3stop", "9627": "clock_evt_feat_dummy", "9628": "clock_evt_feat_dynirq", "9629": "clock_evt_feat_hrtimer", "9630": "clock_evt_feat_ktime", "9631": "clock_evt_feat_oneshot", "9632": "clock_evt_feat_percpu", "9633": "clock_evt_feat_periodic", "9634": "clock_evt_mode_resume", "9635": "clock_evt_mode_shutdown", "9636": "clock_evt_mode_unused", "9637": "clock_evt_state_detached", "9638": "clock_evt_state_oneshot", "9639": "clock_evt_state_periodic", "9640": "clock_evt_state_shutdown", "9641": "clock_get", "9642": "clock_getres", "9643": "clock_gettime", "9644": "clock_id", "9645": "clock_monotonic", "9646": "clock_monotonic_coarse", "9647": "clock_monotonic_raw", "9648": "clock_nanosleep", "9649": "clock_nanosleep_restart", "9650": "clock_posix_dynamic", "9651": "clock_realtime", "9652": "clock_realtime_alarm", "9653": "clock_realtime_coarse", "9654": "clock_set", "9655": "clock_settime", "9656": "clock_skip_update", "9657": "clock_source_suspend_nonstop", "9658": "clock_source_valid_for_hres", "9659": "clock_t", "9660": "clock_t_to_compat_clock_t", "9661": "clock_t_to_jiffies", "9662": "clock_tai", "9663": "clock_task", "9664": "clock_was_set", "9665": "clockevent_delta2ns", "9666": "clockevent_devices", "9667": "clockevents_calc_mult_shift", "9668": "clockevents_config", "9669": "clockevents_config_and_register", "9670": "clockevents_exchange_device", "9671": "clockevents_handle_noop", "9672": "clockevents_increase_min_delta", "9673": "clockevents_init_sysfs", "9674": "clockevents_lock", "9675": "clockevents_mutex", "9676": "clockevents_notify_released", "9677": "clockevents_program_event", "9678": "clockevents_program_min_delta", "9679": "clockevents_register_device", "9680": "clockevents_released", "9681": "clockevents_replace", "9682": "clockevents_resume", "9683": "clockevents_sanity_check", "9684": "clockevents_set_state", "9685": "clockevents_shutdown", "9686": "clockevents_subsys", "9687": "clockevents_suspend", "9688": "clockevents_tick_resume", "9689": "clockevents_unbind", "9690": "clockevents_unbind_device", "9691": "clockevents_update_freq", "9692": "clockid", "9693": "clockid_t", "9694": "clockid_to_fd", "9695": "clockid_to_kclock", "9696": "clocksource", "9697": "clocksource_cyc2ns", "9698": "clocksource_default_clock", "9699": "clocksource_delta", "9700": "clocksource_resume", "9701": "clocksource_suspend", "9702": "clocksource_touch_watchdog", "9703": "clone", "9704": "clone_child_cleartid", "9705": "clone_child_settid", "9706": "clone_ctx", "9707": "clone_files", "9708": "clone_flags", "9709": "clone_fs", "9710": "clone_io", "9711": "clone_newipc", "9712": "clone_newnet", "9713": "clone_newns", "9714": "clone_newpid", "9715": "clone_newuser", "9716": "clone_newuts", "9717": "clone_parent", "9718": "clone_parent_settid", "9719": "clone_ptrace", "9720": "clone_sighand", "9721": "clone_sysvsem", "9722": "clone_thread", "9723": "clone_untraced", "9724": "clone_uts_ns", "9725": "clone_vfork", "9726": "clone_vm", "9727": "close", "9728": "close_finish", "9729": "close_work", "9730": "clr", "9731": "cm", "9732": "cma", "9733": "cmaj_flt", "9734": "cmaxrss", "9735": "cmd", "9736": "cmd_attr_deregister_cpumask", "9737": "cmd_attr_pid", "9738": "cmd_attr_register_cpumask", "9739": "cmd_attr_tgid", "9740": "cmd_buflen", "9741": "cmd_cur", "9742": "cmd_enable", "9743": "cmd_flags", "9744": "cmd_func", "9745": "cmd_head", "9746": "cmd_help", "9747": "cmd_hist", "9748": "cmd_interrupt", "9749": "cmd_len", "9750": "cmd_minlen", "9751": "cmd_name", "9752": "cmd_ops", "9753": "cmd_tail", "9754": "cmd_type", "9755": "cmd_usage", "9756": "cmdbuf", "9757": "cmdline", "9758": "cmdline_buf", "9759": "cmdline_buf_len", "9760": "cmdline_idx", "9761": "cmdline_len", "9762": "cmdline_num", "9763": "cmdline_ptr", "9764": "cmdptr", "9765": "cmdstr", "9766": "cmin_flt", "9767": "cmp", "9768": "cmp_data", "9769": "cmp_len", "9770": "cmp_name", "9771": "cmp_next_hrtimer_event", "9772": "cmp_stat_t", "9773": "cmppid", "9774": "cmpxchg", "9775": "cmpxchg64", "9776": "cmpxchg_cputime", "9777": "cnivcsw", "9778": "cnt", "9779": "cnts", "9780": "cnvcsw", "9781": "co", "9782": "code", "9783": "collect_garbage_slots", "9784": "collect_mounts", "9785": "collect_one_slot", "9786": "collect_signal", "9787": "collection", "9788": "collision", "9789": "colon", "9790": "color", "9791": "columns", "9792": "comm", "9793": "comm_event", "9794": "comm_size", "9795": "comma", "9796": "command", "9797": "command_line_size", "9798": "commands", "9799": "commit", "9800": "commit_creds", "9801": "commit_overrun", "9802": "commit_page", "9803": "commit_txn", "9804": "commits", "9805": "committing", "9806": "common_end", "9807": "common_head", "9808": "common_nsleep", "9809": "common_timer_create", "9810": "common_timer_del", "9811": "common_timer_get", "9812": "common_timer_set", "9813": "comp", "9814": "compare_css_sets", "9815": "compare_root", "9816": "compat", "9817": "compat_alloc_user_space", "9818": "compat_arch_ptrace", "9819": "compat_blk_trace_setup", "9820": "compat_blk_user_trace_setup", "9821": "compat_clock_nanosleep_restart", "9822": "compat_clock_t", "9823": "compat_convert_timespec", "9824": "compat_exit_robust_list", "9825": "compat_get_bitmap", "9826": "compat_get_timespec", "9827": "compat_get_timeval", "9828": "compat_get_timex", "9829": "compat_get_user_cpu_mask", "9830": "compat_ioctl", "9831": "compat_iovec", "9832": "compat_itimerspec", "9833": "compat_itimerval", "9834": "compat_jiffies_to_clock_t", "9835": "compat_kexec_segment", "9836": "compat_loff_t", "9837": "compat_log", "9838": "compat_long_t", "9839": "compat_nanosleep_restart", "9840": "compat_old_sigaction", "9841": "compat_old_sigset_t", "9842": "compat_oldlenp", "9843": "compat_pid_t", "9844": "compat_ptr", "9845": "compat_put_timespec", "9846": "compat_put_timeval", "9847": "compat_put_timex", "9848": "compat_restore_altstack", "9849": "compat_resume_swap_area", "9850": "compat_rlim_infinity", "9851": "compat_rlim_old_infinity", "9852": "compat_rlimit", "9853": "compat_rmtp", "9854": "compat_robust_list", "9855": "compat_robust_list_head", "9856": "compat_rusage", "9857": "compat_sig_setmask", "9858": "compat_sigaction", "9859": "compat_sigevent", "9860": "compat_siginfo", "9861": "compat_siginfo_t", "9862": "compat_sigset_t", "9863": "compat_sigset_word", "9864": "compat_size_t", "9865": "compat_sock_fprog", "9866": "compat_stack_t", "9867": "compat_sys_epoll_pwait", "9868": "compat_sys_fanotify_mark", "9869": "compat_sys_futex", "9870": "compat_sys_get_mempolicy", "9871": "compat_sys_get_robust_list", "9872": "compat_sys_getsockopt", "9873": "compat_sys_ipc", "9874": "compat_sys_kexec_load", "9875": "compat_sys_keyctl", "9876": "compat_sys_lookup_dcookie", "9877": "compat_sys_mbind", "9878": "compat_sys_migrate_pages", "9879": "compat_sys_move_pages", "9880": "compat_sys_mq_getsetattr", "9881": "compat_sys_mq_notify", "9882": "compat_sys_mq_open", "9883": "compat_sys_mq_timedreceive", "9884": "compat_sys_mq_timedsend", "9885": "compat_sys_msgctl", "9886": "compat_sys_msgrcv", "9887": "compat_sys_msgsnd", "9888": "compat_sys_open_by_handle_at", "9889": "compat_sys_process_vm_readv", "9890": "compat_sys_process_vm_writev", "9891": "compat_sys_recv", "9892": "compat_sys_recvfrom", "9893": "compat_sys_recvmmsg", "9894": "compat_sys_recvmsg", "9895": "compat_sys_s390_ipc", "9896": "compat_sys_semctl", "9897": "compat_sys_semtimedop", "9898": "compat_sys_sendmmsg", "9899": "compat_sys_sendmsg", "9900": "compat_sys_set_mempolicy", "9901": "compat_sys_set_robust_list", "9902": "compat_sys_setsockopt", "9903": "compat_sys_shmat", "9904": "compat_sys_shmctl", "9905": "compat_sys_sigaltstack", "9906": "compat_sys_signalfd", "9907": "compat_sys_signalfd4", "9908": "compat_sys_socketcall", "9909": "compat_sys_sysctl", "9910": "compat_sys_timerfd_gettime", "9911": "compat_sys_timerfd_settime", "9912": "compat_syscall_define1", "9913": "compat_syscall_define2", "9914": "compat_syscall_define3", "9915": "compat_syscall_define4", "9916": "compat_syscall_define5", "9917": "compat_syscall_define6", "9918": "compat_sysctl_args", "9919": "compat_sysinfo", "9920": "compat_time_t", "9921": "compat_timespec", "9922": "compat_timeval", "9923": "compat_timex", "9924": "compat_tms", "9925": "compat_uint_t", "9926": "compat_ulong_t", "9927": "compat_uptr_t", "9928": "compat_use_64bit_time", "9929": "compat_user_stack_pointer", "9930": "compat_uts_machine", "9931": "compatible", "9932": "complete", "9933": "complete_formation", "9934": "complete_signal", "9935": "complete_vfork_done", "9936": "completed", "9937": "completion", "9938": "completion_done", "9939": "completion_initializer_onstack", "9940": "compressed", "9941": "compute_capacity", "9942": "con", "9943": "con_brl", "9944": "con_enabled", "9945": "con_printbuffer", "9946": "cond", "9947": "cond_func", "9948": "cond_resched", "9949": "cond_resched_completed", "9950": "cond_resched_rcu_qs", "9951": "cond_suspend_depth", "9952": "cond_sync", "9953": "cond_synchronize_rcu", "9954": "cond_syscall", "9955": "cond_unmask_eoi_irq", "9956": "cond_unmask_irq", "9957": "config", "9958": "config_64bit", "9959": "config_a11y_braille_console", "9960": "config_acpi_sleep", "9961": "config_aio", "9962": "config_arch_hibernation_header", "9963": "config_arch_task_struct_allocator", "9964": "config_arch_thread_info_allocator", "9965": "config_arch_uses_gettimeoffset", "9966": "config_arm", "9967": "config_audit_tree", "9968": "config_audit_watch", "9969": "config_auditsyscall", "9970": "config_auto_irq_affinity", "9971": "config_base_small", "9972": "config_bcache", "9973": "config_binfmt_elf_fdpic", "9974": "config_binfmt_misc", "9975": "config_binfmt_misc_module", "9976": "config_blk_dev_initrd", "9977": "config_blk_dev_io_trace", "9978": "config_block", "9979": "config_bootparam_hung_task_panic_value", "9980": "config_bpf_jit", "9981": "config_branch_tracer", "9982": "config_bsd_process_acct", "9983": "config_cc_stackprotector", "9984": "config_cfs_bandwidth", "9985": "config_cgroup_cpuacct", "9986": "config_cgroup_debug", "9987": "config_cgroup_sched", "9988": "config_cgroups", "9989": "config_checkpoint_restore", "9990": "config_chr_dev_sg", "9991": "config_clocksource_validate_last_cycle", "9992": "config_clone_backwards", "9993": "config_clone_backwards2", "9994": "config_clone_backwards3", "9995": "config_compaction", "9996": "config_compat", "9997": "config_compat_old_sigaction", "9998": "config_constructors", "9999": "config_context_switch_tracer", "10000": "config_context_tracking", "10001": "config_context_tracking_force", "10002": "config_coredump", "10003": "config_cpu_idle", "10004": "config_cpusets", "10005": "config_debug_atomic_sleep", "10006": "config_debug_bugverbose", "10007": "config_debug_credentials", "10008": "config_debug_fs", "10009": "config_debug_kmemleak", "10010": "config_debug_lock_alloc", "10011": "config_debug_lockdep", "10012": "config_debug_mutexes", "10013": "config_debug_notifiers", "10014": "config_debug_objects_rcu_head", "10015": "config_debug_objects_timers", "10016": "config_debug_objects_work", "10017": "config_debug_preempt", "10018": "config_debug_rodata", "10019": "config_debug_rt_mutexes", "10020": "config_debug_set_module_ronx", "10021": "config_debug_shirq", "10022": "config_debug_shirq_fixme", "10023": "config_debug_spinlock", "10024": "config_debug_stackoverflow", "10025": "config_debug_timekeeping", "10026": "config_debug_ww_mutex_slowpath", "10027": "config_default_hung_task_timeout", "10028": "config_detect_hung_task", "10029": "config_dnotify", "10030": "config_dynamic_debug", "10031": "config_dynamic_ftrace", "10032": "config_dynamic_ftrace_with_regs", "10033": "config_epoll", "10034": "config_event_trace_test_syscalls", "10035": "config_event_tracing", "10036": "config_fair_group_sched", "10037": "config_file_locking", "10038": "config_freezer", "10039": "config_ftrace_mcount_record", "10040": "config_ftrace_selftest", "10041": "config_ftrace_startup_test", "10042": "config_ftrace_syscalls", "10043": "config_function_graph_tracer", "10044": "config_function_tracer", "10045": "config_futex", "10046": "config_generic_clockevents", "10047": "config_generic_clockevents_broadcast", "10048": "config_generic_clockevents_min_adjust", "10049": "config_generic_irq_legacy", "10050": "config_generic_irq_legacy_alloc_hwirq", "10051": "config_generic_irq_show", "10052": "config_generic_irq_show_level", "10053": "config_generic_lockbreak", "10054": "config_generic_msi_irq_domain", "10055": "config_generic_pending_irq", "10056": "config_generic_smp_idle_thread", "10057": "config_generic_time_vsyscall_old", "10058": "config_handle_domain_irq", "10059": "config_hardirqs_sw_resend", "10060": "config_hardlockup_detector", "10061": "config_have_arch_seccomp_filter", "10062": "config_have_arch_tracehook", "10063": "config_have_efficient_unaligned_access", "10064": "config_have_function_graph_fp_test", "10065": "config_have_irq_exit_on_irq_stack", "10066": "config_have_nmi_watchdog", "10067": "config_have_unstable_sched_clock", "10068": "config_hibernation", "10069": "config_high_res_timers", "10070": "config_highmem", "10071": "config_hotplug_cpu", "10072": "config_hugetlb_page", "10073": "config_ia64", "10074": "config_ikconfig_proc", "10075": "config_init_all_possible", "10076": "config_inline_read_lock", "10077": "config_inline_read_lock_bh", "10078": "config_inline_read_lock_irq", "10079": "config_inline_read_lock_irqsave", "10080": "config_inline_read_trylock", "10081": "config_inline_read_unlock", "10082": "config_inline_read_unlock_bh", "10083": "config_inline_read_unlock_irq", "10084": "config_inline_read_unlock_irqrestore", "10085": "config_inline_spin_lock", "10086": "config_inline_spin_lock_bh", "10087": "config_inline_spin_lock_irq", "10088": "config_inline_spin_lock_irqsave", "10089": "config_inline_spin_trylock", "10090": "config_inline_spin_trylock_bh", "10091": "config_inline_spin_unlock_bh", "10092": "config_inline_spin_unlock_irq", "10093": "config_inline_spin_unlock_irqrestore", "10094": "config_inline_write_lock", "10095": "config_inline_write_lock_bh", "10096": "config_inline_write_lock_irq", "10097": "config_inline_write_lock_irqsave", "10098": "config_inline_write_trylock", "10099": "config_inline_write_unlock", "10100": "config_inline_write_unlock_bh", "10101": "config_inline_write_unlock_irq", "10102": "config_inline_write_unlock_irqrestore", "10103": "config_inotify_user", "10104": "config_irq_domain", "10105": "config_irq_domain_hierarchy", "10106": "config_irq_edge_eoi_handler", "10107": "config_irq_forced_threading", "10108": "config_irq_preflow_fasteoi", "10109": "config_irq_time_accounting", "10110": "config_irq_work", "10111": "config_irqsoff_tracer", "10112": "config_kallsyms", "10113": "config_kallsyms_all", "10114": "config_kdb_continue_catastrophic", "10115": "config_kdb_default_enable", "10116": "config_kexec", "10117": "config_kexec_file", "10118": "config_kexec_jump", "10119": "config_kexec_verify_sig", "10120": "config_keys", "10121": "config_kgdb_kdb", "10122": "config_kmemcheck", "10123": "config_kprobe_event", "10124": "config_kprobes_on_ftrace", "10125": "config_kretprobes", "10126": "config_latencytop", "10127": "config_lock_stat", "10128": "config_lockdep", "10129": "config_lockup_detector", "10130": "config_magic_sysrq", "10131": "config_magic_sysrq_default_enable", "10132": "config_mathemu", "10133": "config_memcg", "10134": "config_memory_failure", "10135": "config_memory_hotremove", "10136": "config_mmu", "10137": "config_module_force_load", "10138": "config_module_force_unload", "10139": "config_module_sig", "10140": "config_module_unload", "10141": "config_modules", "10142": "config_modversions", "10143": "config_mpu", "10144": "config_multiuser", "10145": "config_mutex_spin_on_owner", "10146": "config_net", "10147": "config_no_hz_common", "10148": "config_no_hz_full", "10149": "config_no_hz_full_sysidle", "10150": "config_no_hz_full_sysidle_small", "10151": "config_nop_tracer", "10152": "config_nr_cpus", "10153": "config_ntp_pps", "10154": "config_numa", "10155": "config_numa_balancing", "10156": "config_odd_rt_sigaction", "10157": "config_old_sigaction", "10158": "config_old_sigsuspend", "10159": "config_old_sigsuspend3", "10160": "config_optprobes", "10161": "config_panic_on_oops_value", "10162": "config_panic_timeout", "10163": "config_paravirt", "10164": "config_paravirt_time_accounting", "10165": "config_perf_events", "10166": "config_perf_use_vmalloc", "10167": "config_persistent_keyrings", "10168": "config_pid_ns", "10169": "config_pm", "10170": "config_pm_autosleep", "10171": "config_pm_debug", "10172": "config_pm_sleep", "10173": "config_pm_sleep_smp", "10174": "config_pm_std_partition", "10175": "config_pm_test_suspend", "10176": "config_pm_wakelocks", "10177": "config_pm_wakelocks_gc", "10178": "config_pm_wakelocks_limit", "10179": "config_posix_mqueue", "10180": "config_preempt", "10181": "config_preempt_notifiers", "10182": "config_preempt_rcu", "10183": "config_preempt_tracer", "10184": "config_printk", "10185": "config_proc_fs", "10186": "config_proc_pid_cpuset", "10187": "config_proc_sysctl", "10188": "config_profile_all_branches", "10189": "config_profiling", "10190": "config_prove_locking", "10191": "config_prove_rcu", "10192": "config_prove_rcu_repeatedly", "10193": "config_randomize_base", "10194": "config_rcu_boost", "10195": "config_rcu_boost_delay", "10196": "config_rcu_cpu_stall_info", "10197": "config_rcu_cpu_stall_timeout", "10198": "config_rcu_expedite_boot", "10199": "config_rcu_fanout", "10200": "config_rcu_fanout_exact", "10201": "config_rcu_fanout_leaf", "10202": "config_rcu_fast_no_hz", "10203": "config_rcu_kthread_prio", "10204": "config_rcu_nocb_cpu", "10205": "config_rcu_nocb_cpu_all", "10206": "config_rcu_nocb_cpu_none", "10207": "config_rcu_nocb_cpu_zero", "10208": "config_rcu_stall_common", "10209": "config_rcu_torture_test_runnable", "10210": "config_rcu_torture_test_slow_init", "10211": "config_rcu_torture_test_slow_init_delay", "10212": "config_rcu_trace", "10213": "config_rcu_user_qs", "10214": "config_ring_buffer_allow_swap", "10215": "config_ring_buffer_startup_test", "10216": "config_rt_group_sched", "10217": "config_rt_mutex_tester", "10218": "config_rt_mutexes", "10219": "config_rtc_class", "10220": "config_rtc_hctosys_device", "10221": "config_rwsem_spin_on_owner", "10222": "config_s390", "10223": "config_sched_autogroup", "10224": "config_sched_debug", "10225": "config_sched_hrtick", "10226": "config_sched_mc", "10227": "config_sched_smt", "10228": "config_sched_stack_end_check", "10229": "config_sched_tracer", "10230": "config_schedstats", "10231": "config_seccomp", "10232": "config_seccomp_filter", "10233": "config_security", "10234": "config_security_selinux", "10235": "config_sgetmask_syscall", "10236": "config_smp", "10237": "config_sparc", "10238": "config_sparc64", "10239": "config_sparse_irq", "10240": "config_srcu", "10241": "config_stack_growsup", "10242": "config_stack_tracer", "10243": "config_stacktrace", "10244": "config_stop_machine", "10245": "config_strict_devmem", "10246": "config_superh", "10247": "config_suspend", "10248": "config_suspend_freezer", "10249": "config_sysctl", "10250": "config_sysctl_arch_unalign_allow", "10251": "config_sysctl_arch_unalign_no_warn", "10252": "config_sysctl_exception_trace", "10253": "config_sysctl_syscall", "10254": "config_sysfs", "10255": "config_sysvipc", "10256": "config_task_delay_acct", "10257": "config_task_io_accounting", "10258": "config_task_xacct", "10259": "config_tasks_rcu", "10260": "config_tick_oneshot", "10261": "config_timer_stats", "10262": "config_tiny_rcu", "10263": "config_trace_enum_map_file", "10264": "config_trace_irqflags", "10265": "config_tracepoints", "10266": "config_tracer_max_trace", "10267": "config_tracer_snapshot", "10268": "config_tracing", "10269": "config_transparent_hugepage", "10270": "config_tree_rcu", "10271": "config_uevent_helper", "10272": "config_uml", "10273": "config_unicore32", "10274": "config_uninline_spin_unlock", "10275": "config_unused_symbols", "10276": "config_user_ns", "10277": "config_virt_cpu_accounting", "10278": "config_virt_cpu_accounting_gen", "10279": "config_virt_cpu_accounting_native", "10280": "config_vsyscall", "10281": "config_x86", "10282": "config_x86_32", "10283": "config_x86_64", "10284": "config_x86_local_apic", "10285": "configured", "10286": "conflict", "10287": "connects", "10288": "console", "10289": "console_cmdline", "10290": "console_drivers", "10291": "console_idx", "10292": "console_lock_dep_map", "10293": "console_locked", "10294": "console_loglevel", "10295": "console_loglevel_default", "10296": "console_loglevel_min", "10297": "console_loglevel_motormouth", "10298": "console_may_schedule", "10299": "console_prev", "10300": "console_printk", "10301": "console_sem", "10302": "console_seq", "10303": "console_set_on_cmdline", "10304": "console_suspended", "10305": "console_verbose", "10306": "const", "10307": "const_debug", "10308": "const_imm", "10309": "const_ptr_to_map", "10310": "constant", "10311": "constraint", "10312": "constraints", "10313": "consume", "10314": "consume_skb", "10315": "consumer", "10316": "consumer_add", "10317": "consumer_del", "10318": "consumer_fifo", "10319": "consumer_filter", "10320": "consumer_nice", "10321": "consumer_rwsem", "10322": "consumers", "10323": "consuming", "10324": "cont", "10325": "cont_jmp", "10326": "container", "10327": "container_of", "10328": "containing", "10329": "contending_lock", "10330": "contending_point", "10331": "content", "10332": "contention_point", "10333": "contents", "10334": "context", "10335": "context_equiv", "10336": "context_kernel", "10337": "context_switch", "10338": "context_tracking", "10339": "context_tracking_cpu_set", "10340": "context_tracking_enabled", "10341": "context_tracking_enter", "10342": "context_tracking_exit", "10343": "context_tracking_in_user", "10344": "context_tracking_init", "10345": "context_tracking_is_enabled", "10346": "context_tracking_task_switch", "10347": "context_tracking_user_enter", "10348": "context_tracking_user_exit", "10349": "context_user", "10350": "continue", "10351": "continue_balancing", "10352": "contrib", "10353": "contrib_delta", "10354": "contribution", "10355": "contributions", "10356": "control", "10357": "control_code_page", "10358": "control_ops", "10359": "control_ops_alloc", "10360": "control_ops_disable_all", "10361": "control_ops_free", "10362": "control_page", "10363": "control_pages", "10364": "conv", "10365": "convdiv", "10366": "convert", "10367": "convert_ctx_access", "10368": "convert_ctx_accesses", "10369": "convert_kthread_status", "10370": "convert_pseudo_ld_imm64", "10371": "convert_rloc_to_loc", "10372": "convert_to_gcda", "10373": "convmul", "10374": "cookie", "10375": "cookies", "10376": "copied", "10377": "copy", "10378": "copy_bm", "10379": "copy_chunk_size", "10380": "copy_chunked_from_user", "10381": "copy_creds", "10382": "copy_data_pages", "10383": "copy_file_from_fd", "10384": "copy_files", "10385": "copy_from_page", "10386": "copy_from_user", "10387": "copy_fs", "10388": "copy_fs_struct", "10389": "copy_highpage", "10390": "copy_insn", "10391": "copy_io", "10392": "copy_ipcs", "10393": "copy_kprobe", "10394": "copy_last_highmem_page", "10395": "copy_mm", "10396": "copy_mnt_ns", "10397": "copy_module_from_fd", "10398": "copy_module_from_user", "10399": "copy_namespaces", "10400": "copy_net_ns", "10401": "copy_page", "10402": "copy_page_range", "10403": "copy_pid_ns", "10404": "copy_process", "10405": "copy_regset_from_user", "10406": "copy_regset_to_user", "10407": "copy_seccomp", "10408": "copy_semundo", "10409": "copy_sighand", "10410": "copy_siginfo", "10411": "copy_siginfo_from_user32", "10412": "copy_siginfo_to_user", "10413": "copy_siginfo_to_user32", "10414": "copy_signal", "10415": "copy_thread", "10416": "copy_to_page", "10417": "copy_to_user", "10418": "copy_user_segment_list", "10419": "copy_utsname", "10420": "copy_workqueue_attrs", "10421": "copybytes", "10422": "core_initcall", "10423": "core_internal_state__do_not_mess_with_it", "10424": "core_kernel_data", "10425": "core_kernel_text", "10426": "core_note_type", "10427": "core_num_syms", "10428": "core_param", "10429": "core_pattern", "10430": "core_pipe_limit", "10431": "core_ro_size", "10432": "core_size", "10433": "core_state", "10434": "core_strtab", "10435": "core_symtab", "10436": "core_text_size", "10437": "core_uses_pid", "10438": "coredump_filter_setup", "10439": "coredump_params", "10440": "coremem", "10441": "corename_max_size", "10442": "coresize", "10443": "correct", "10444": "correct_hw_break", "10445": "correction", "10446": "corrupted", "10447": "coublock", "10448": "could", "10449": "count", "10450": "count_data_pages", "10451": "count_fls", "10452": "count_free_highmem_pages", "10453": "count_highmem_image_pages", "10454": "count_highmem_pages", "10455": "count_lazy", "10456": "count_leafs", "10457": "count_leafs_cb", "10458": "count_matching_names", "10459": "count_overruns", "10460": "count_pages_for_highmem", "10461": "count_preds", "10462": "counter", "10463": "counter_active", "10464": "counters", "10465": "counts", "10466": "covered", "10467": "cp", "10468": "cp2", "10469": "cpl", "10470": "cpp", "10471": "cprm", "10472": "cprv", "10473": "cpu", "10474": "cpu0", "10475": "cpu0_err", "10476": "cpu1", "10477": "cpu2", "10478": "cpu_a", "10479": "cpu_access_lock", "10480": "cpu_active", "10481": "cpu_active_bits", "10482": "cpu_active_mask", "10483": "cpu_add_remove_lock", "10484": "cpu_all_bits", "10485": "cpu_all_mask", "10486": "cpu_attach_domain", "10487": "cpu_avg_load_per_task", "10488": "cpu_b", "10489": "cpu_base", "10490": "cpu_bit_bitmap", "10491": "cpu_bits_all", "10492": "cpu_broken", "10493": "cpu_buffer", "10494": "cpu_buffer_a", "10495": "cpu_buffer_b", "10496": "cpu_busy", "10497": "cpu_callback", "10498": "cpu_capacity", "10499": "cpu_capacity_orig", "10500": "cpu_cfs_period_read_u64", "10501": "cpu_cfs_period_write_u64", "10502": "cpu_cfs_quota_read_s64", "10503": "cpu_cfs_quota_write_s64", "10504": "cpu_cgroup_attach", "10505": "cpu_cgroup_can_attach", "10506": "cpu_cgroup_css_alloc", "10507": "cpu_cgroup_css_free", "10508": "cpu_cgroup_css_offline", "10509": "cpu_cgroup_css_online", "10510": "cpu_cgroup_exit", "10511": "cpu_cgroup_fork", "10512": "cpu_cgrp_id", "10513": "cpu_cgrp_subsys", "10514": "cpu_chain", "10515": "cpu_check_up_prepare", "10516": "cpu_clk", "10517": "cpu_clock", "10518": "cpu_cluster_pm_enter", "10519": "cpu_cluster_pm_enter_failed", "10520": "cpu_cluster_pm_exit", "10521": "cpu_core_flags", "10522": "cpu_coregroup_mask", "10523": "cpu_count", "10524": "cpu_cpu_mask", "10525": "cpu_ctx_sched_in", "10526": "cpu_ctx_sched_out", "10527": "cpu_curr", "10528": "cpu_current", "10529": "cpu_data", "10530": "cpu_dead", "10531": "cpu_dead_frozen", "10532": "cpu_dead_idle", "10533": "cpu_delay_total", "10534": "cpu_dma_constraints", "10535": "cpu_dma_lat_notifier", "10536": "cpu_dma_pm_qos", "10537": "cpu_dont_care", "10538": "cpu_down", "10539": "cpu_down_failed", "10540": "cpu_down_failed_frozen", "10541": "cpu_down_prepare", "10542": "cpu_down_prepare_frozen", "10543": "cpu_dying", "10544": "cpu_dying_frozen", "10545": "cpu_dying_idle", "10546": "cpu_entries", "10547": "cpu_entry", "10548": "cpu_extra", "10549": "cpu_file", "10550": "cpu_files", "10551": "cpu_function_call", "10552": "cpu_going_down", "10553": "cpu_hardirq_time", "10554": "cpu_has_callbacks_ready_to_invoke", "10555": "cpu_hotplug", "10556": "cpu_hotplug_begin", "10557": "cpu_hotplug_disable", "10558": "cpu_hotplug_disabled", "10559": "cpu_hotplug_done", "10560": "cpu_hotplug_enable", "10561": "cpu_hotplug_pm_callback", "10562": "cpu_hotplug_pm_sync_init", "10563": "cpu_hotplug_state", "10564": "cpu_i", "10565": "cpu_id", "10566": "cpu_idle", "10567": "cpu_idle_force_poll", "10568": "cpu_idle_loop", "10569": "cpu_idle_poll", "10570": "cpu_idle_poll_ctrl", "10571": "cpu_idle_type", "10572": "cpu_idx", "10573": "cpu_index", "10574": "cpu_intensive", "10575": "cpu_is_hotpluggable", "10576": "cpu_is_offline", "10577": "cpu_isolated_map", "10578": "cpu_khz", "10579": "cpu_limit", "10580": "cpu_load", "10581": "cpu_load_idx_max", "10582": "cpu_lock_stats", "10583": "cpu_loop", "10584": "cpu_map", "10585": "cpu_maps_update_begin", "10586": "cpu_maps_update_done", "10587": "cpu_master_loop", "10588": "cpu_needs_another_gp", "10589": "cpu_newly_idle", "10590": "cpu_nfb", "10591": "cpu_node", "10592": "cpu_not_idle", "10593": "cpu_notifier", "10594": "cpu_notifier_register_begin", "10595": "cpu_notifier_register_done", "10596": "cpu_notify", "10597": "cpu_notify_nofail", "10598": "cpu_ns", "10599": "cpu_num", "10600": "cpu_of", "10601": "cpu_off", "10602": "cpu_online", "10603": "cpu_online_bits", "10604": "cpu_online_frozen", "10605": "cpu_online_mask", "10606": "cpu_pid_to_cpupid", "10607": "cpu_pm_enter", "10608": "cpu_pm_enter_failed", "10609": "cpu_pm_event", "10610": "cpu_pm_exit", "10611": "cpu_pm_init", "10612": "cpu_pm_notifier_chain", "10613": "cpu_pm_notifier_lock", "10614": "cpu_pm_notify", "10615": "cpu_pm_register_notifier", "10616": "cpu_pm_resume", "10617": "cpu_pm_suspend", "10618": "cpu_pm_syscore_ops", "10619": "cpu_pm_unregister_notifier", "10620": "cpu_pools", "10621": "cpu_possible", "10622": "cpu_possible_bits", "10623": "cpu_possible_mask", "10624": "cpu_post_dead", "10625": "cpu_present", "10626": "cpu_present_bits", "10627": "cpu_present_mask", "10628": "cpu_pri_cpuset_active", "10629": "cpu_pri_cpuset_inactive", "10630": "cpu_pri_migration", "10631": "cpu_pri_sched_active", "10632": "cpu_pri_sched_inactive", "10633": "cpu_pri_smpboot", "10634": "cpu_profile_flip", "10635": "cpu_profile_hits", "10636": "cpu_profiling", "10637": "cpu_pwqs", "10638": "cpu_relax", "10639": "cpu_relax_lowlatency", "10640": "cpu_report_state", "10641": "cpu_rq", "10642": "cpu_rt_period_read_uint", "10643": "cpu_rt_period_write_uint", "10644": "cpu_rt_runtime_read", "10645": "cpu_rt_runtime_write", "10646": "cpu_run_real_total", "10647": "cpu_run_virtual_total", "10648": "cpu_scaled_run_real_total", "10649": "cpu_sdc", "10650": "cpu_set_state_online", "10651": "cpu_shares_read_u64", "10652": "cpu_shares_write_u64", "10653": "cpu_smt_flags", "10654": "cpu_smt_mask", "10655": "cpu_softirq_time", "10656": "cpu_starting", "10657": "cpu_starting_frozen", "10658": "cpu_startup_entry", "10659": "cpu_stats", "10660": "cpu_stats_show", "10661": "cpu_stop_create", "10662": "cpu_stop_done", "10663": "cpu_stop_fn_t", "10664": "cpu_stop_init", "10665": "cpu_stop_init_done", "10666": "cpu_stop_park", "10667": "cpu_stop_queue_work", "10668": "cpu_stop_should_run", "10669": "cpu_stop_signal_done", "10670": "cpu_stop_threads", "10671": "cpu_stop_unpark", "10672": "cpu_stop_work", "10673": "cpu_stopper", "10674": "cpu_stopper_task", "10675": "cpu_stopper_thread", "10676": "cpu_tasks_frozen", "10677": "cpu_timers", "10678": "cpu_to_be16", "10679": "cpu_to_be32", "10680": "cpu_to_be64", "10681": "cpu_to_le16", "10682": "cpu_to_le32", "10683": "cpu_to_le64", "10684": "cpu_to_mem", "10685": "cpu_to_node", "10686": "cpu_up", "10687": "cpu_up_canceled", "10688": "cpu_up_canceled_frozen", "10689": "cpu_up_prepare", "10690": "cpu_up_prepare_frozen", "10691": "cpu_vfs_cap_data", "10692": "cpu_wait_death", "10693": "cpu_worker_pools", "10694": "cpuacct", "10695": "cpuacct_account_field", "10696": "cpuacct_cgrp_id", "10697": "cpuacct_cgrp_subsys", "10698": "cpuacct_charge", "10699": "cpuacct_cpuusage_read", "10700": "cpuacct_cpuusage_write", "10701": "cpuacct_css_alloc", "10702": "cpuacct_css_free", "10703": "cpuacct_percpu_seq_show", "10704": "cpuacct_stat_desc", "10705": "cpuacct_stat_index", "10706": "cpuacct_stat_nstats", "10707": "cpuacct_stat_system", "10708": "cpuacct_stat_user", "10709": "cpuacct_stats_show", "10710": "cpubuf_idx", "10711": "cpuclock_prof", "10712": "cpuclock_virt", "10713": "cpuctx", "10714": "cpudl", "10715": "cpudl_change_key", "10716": "cpudl_cleanup", "10717": "cpudl_clear_freecpu", "10718": "cpudl_exchange", "10719": "cpudl_find", "10720": "cpudl_heapify", "10721": "cpudl_init", "10722": "cpudl_item", "10723": "cpudl_maximum", "10724": "cpudl_set", "10725": "cpudl_set_freecpu", "10726": "cpudump", "10727": "cpudump_probe_ops", "10728": "cpuhp_lock_acquire", "10729": "cpuhp_lock_acquire_read", "10730": "cpuhp_lock_acquire_tryread", "10731": "cpuhp_lock_release", "10732": "cpuhp_state", "10733": "cpuidle_enter", "10734": "cpuidle_find_deepest_state", "10735": "cpuidle_idle_call", "10736": "cpuidle_reflect", "10737": "cpuidle_select", "10738": "cpuidle_state", "10739": "cpulist_parse", "10740": "cpumask", "10741": "cpumask_and", "10742": "cpumask_andnot", "10743": "cpumask_any", "10744": "cpumask_any_and", "10745": "cpumask_bits", "10746": "cpumask_change_notifier", "10747": "cpumask_clear", "10748": "cpumask_clear_cpu", "10749": "cpumask_copy", "10750": "cpumask_empty", "10751": "cpumask_equal", "10752": "cpumask_first", "10753": "cpumask_first_and", "10754": "cpumask_intersects", "10755": "cpumask_next", "10756": "cpumask_next_and", "10757": "cpumask_of", "10758": "cpumask_of_node", "10759": "cpumask_or", "10760": "cpumask_parse", "10761": "cpumask_parse_user", "10762": "cpumask_parselist_user", "10763": "cpumask_pr_args", "10764": "cpumask_set_cpu", "10765": "cpumask_setall", "10766": "cpumask_size", "10767": "cpumask_subset", "10768": "cpumask_t", "10769": "cpumask_test_and_clear_cpu", "10770": "cpumask_test_and_set_cpu", "10771": "cpumask_test_cpu", "10772": "cpumask_type", "10773": "cpumask_var_t", "10774": "cpumask_weight", "10775": "cpunum", "10776": "cpup", "10777": "cpupid", "10778": "cpupid_match_pid", "10779": "cpupid_pid_unset", "10780": "cpupid_to_cpu", "10781": "cpupid_to_nid", "10782": "cpupri", "10783": "cpupri_cleanup", "10784": "cpupri_find", "10785": "cpupri_init", "10786": "cpupri_invalid", "10787": "cpupri_set", "10788": "cpus", "10789": "cpus_allowed", "10790": "cpus_attach", "10791": "cpus_share_cache", "10792": "cpus_updated", "10793": "cpuset", "10794": "cpuset_attach", "10795": "cpuset_attach_nodemask_to", "10796": "cpuset_attach_old_cs", "10797": "cpuset_attach_wq", "10798": "cpuset_being_rebound", "10799": "cpuset_bind", "10800": "cpuset_can_attach", "10801": "cpuset_cancel_attach", "10802": "cpuset_cgrp_id", "10803": "cpuset_cgrp_subsys", "10804": "cpuset_change_task_nodemask", "10805": "cpuset_clone_children", "10806": "cpuset_common_seq_show", "10807": "cpuset_cpu_active", "10808": "cpuset_cpu_inactive", "10809": "cpuset_cpumask_can_shrink", "10810": "cpuset_cpus_allowed", "10811": "cpuset_cpus_allowed_fallback", "10812": "cpuset_css_alloc", "10813": "cpuset_css_free", "10814": "cpuset_css_offline", "10815": "cpuset_css_online", "10816": "cpuset_dec", "10817": "cpuset_filetype_t", "10818": "cpuset_flagbits_t", "10819": "cpuset_for_each_child", "10820": "cpuset_for_each_descendant_pre", "10821": "cpuset_fs_type", "10822": "cpuset_hotplug_update_tasks", "10823": "cpuset_hotplug_work", "10824": "cpuset_hotplug_workfn", "10825": "cpuset_inc", "10826": "cpuset_init", "10827": "cpuset_init_current_mems_allowed", "10828": "cpuset_init_smp", "10829": "cpuset_mem_spread_node", "10830": "cpuset_mem_spread_rotor", "10831": "cpuset_memory_pressure_enabled", "10832": "cpuset_mems_allowed", "10833": "cpuset_mems_allowed_intersects", "10834": "cpuset_migrate_mm", "10835": "cpuset_mount", "10836": "cpuset_mutex", "10837": "cpuset_nodemask_valid_mems_allowed", "10838": "cpuset_print_task_mems_allowed", "10839": "cpuset_read_s64", "10840": "cpuset_read_u64", "10841": "cpuset_slab_spread_node", "10842": "cpuset_slab_spread_rotor", "10843": "cpuset_spread_node", "10844": "cpuset_task_status_allowed", "10845": "cpuset_track_online_nodes", "10846": "cpuset_track_online_nodes_nb", "10847": "cpuset_update_active_cpus", "10848": "cpuset_update_task_spread_flag", "10849": "cpuset_write_resmask", "10850": "cpuset_write_s64", "10851": "cpuset_write_u64", "10852": "cpusets_enabled_key", "10853": "cpusets_overlap", "10854": "cpustat", "10855": "cpustride", "10856": "cputime", "10857": "cputime64_to_clock_t", "10858": "cputime_adjust", "10859": "cputime_advance", "10860": "cputime_expires", "10861": "cputime_guest", "10862": "cputime_guest_nice", "10863": "cputime_idle", "10864": "cputime_iowait", "10865": "cputime_irq", "10866": "cputime_nice", "10867": "cputime_one_jiffy", "10868": "cputime_scaled", "10869": "cputime_softirq", "10870": "cputime_steal", "10871": "cputime_sub_ns", "10872": "cputime_system", "10873": "cputime_t", "10874": "cputime_to_clock_t", "10875": "cputime_to_jiffies", "10876": "cputime_to_nsecs", "10877": "cputime_to_scaled", "10878": "cputime_to_timespec", "10879": "cputime_to_timeval", "10880": "cputime_to_usecs", "10881": "cputime_user", "10882": "cputimer", "10883": "cputimer_running", "10884": "cpuusage", "10885": "cpuusage_read", "10886": "cpuusage_write", "10887": "cpy_name", "10888": "cq", "10889": "cq_depth", "10890": "cq_mask", "10891": "cr", "10892": "crash_base", "10893": "crash_free_reserved_phys_range", "10894": "crash_get_memory_size", "10895": "crash_kexec", "10896": "crash_kexec_post_notifiers", "10897": "crash_map_reserved_pages", "10898": "crash_notes", "10899": "crash_notes_memory_init", "10900": "crash_save_cpu", "10901": "crash_save_vmcoreinfo", "10902": "crash_setup_regs", "10903": "crash_shrink_memory", "10904": "crash_size", "10905": "crash_unmap_reserved_pages", "10906": "crashk_low_res", "10907": "crashk_res", "10908": "crc", "10909": "crc32", "10910": "crc32_le", "10911": "crc32_threadfn", "10912": "crc_data", "10913": "crc_owner", "10914": "crcs", "10915": "create", "10916": "create_basic_memory_bitmaps", "10917": "create_buf_file", "10918": "create_chunk", "10919": "create_cooldown", "10920": "create_css", "10921": "create_event_filter", "10922": "create_event_toplevel_files", "10923": "create_filter", "10924": "create_filter_finish", "10925": "create_filter_start", "10926": "create_hash_tables", "10927": "create_image", "10928": "create_kthread", "10929": "create_mem_extents", "10930": "create_new_namespaces", "10931": "create_new_subsystem", "10932": "create_nsproxy", "10933": "create_pid_cachep", "10934": "create_pid_namespace", "10935": "create_pred", "10936": "create_proc_profile", "10937": "create_prof_cpu_mask", "10938": "create_reader", "10939": "create_singlethread_workqueue", "10940": "create_system_filter", "10941": "create_trace_kprobe", "10942": "create_trace_points", "10943": "create_trace_uprobe", "10944": "create_user_ns", "10945": "create_uts_ns", "10946": "create_worker", "10947": "create_zone_bm_rtree", "10948": "created_timer_id", "10949": "createfn", "10950": "creation", "10951": "cred", "10952": "cred_alloc_blank", "10953": "cred_cap_issubset", "10954": "cred_guard_mutex", "10955": "cred_init", "10956": "cred_jar", "10957": "cred_magic", "10958": "cred_magic_dead", "10959": "credentials", "10960": "creds", "10961": "creds_are_invalid", "10962": "crf", "10963": "critical_end", "10964": "critical_sequence", "10965": "critical_start", "10966": "crypto_shash", "10967": "crypto_shash_final", "10968": "crypto_shash_init", "10969": "crypto_shash_update", "10970": "cs", "10971": "cs_cpu_exclusive", "10972": "cs_cpus_allowed", "10973": "cs_last", "10974": "cs_mem_exclusive", "10975": "cs_mem_hardwall", "10976": "cs_memory_migrate", "10977": "cs_name_len", "10978": "cs_now", "10979": "cs_online", "10980": "cs_sched_load_balance", "10981": "cs_spread_page", "10982": "cs_spread_slab", "10983": "csa", "10984": "csd", "10985": "csd_data", "10986": "csd_flag_lock", "10987": "csd_flag_synchronous", "10988": "csd_lock", "10989": "csd_lock_wait", "10990": "csd_next", "10991": "csd_stack", "10992": "csd_unlock", "10993": "cset", "10994": "cset_cgroup_from_root", "10995": "cset_head", "10996": "cset_link", "10997": "cset_links", "10998": "cset_pos", "10999": "csets", "11000": "csignal", "11001": "csn", "11002": "css", "11003": "css_advance_task_iter", "11004": "css_alloc", "11005": "css_ca", "11006": "css_cs", "11007": "css_disable", "11008": "css_e_css_changed", "11009": "css_enable", "11010": "css_for_each_child", "11011": "css_for_each_descendant_post", "11012": "css_for_each_descendant_pre", "11013": "css_free", "11014": "css_free_rcu_fn", "11015": "css_free_work_fn", "11016": "css_freezer", "11017": "css_from_id", "11018": "css_get", "11019": "css_has_online_children", "11020": "css_idr", "11021": "css_killed_ref_fn", "11022": "css_killed_work_fn", "11023": "css_leftmost_descendant", "11024": "css_next_child", "11025": "css_next_descendant_post", "11026": "css_next_descendant_pre", "11027": "css_no_ref", "11028": "css_offline", "11029": "css_online", "11030": "css_put", "11031": "css_release", "11032": "css_release_work_fn", "11033": "css_released", "11034": "css_reset", "11035": "css_rightmost_descendant", "11036": "css_serial_nr_next", "11037": "css_set", "11038": "css_set_count", "11039": "css_set_hash", "11040": "css_set_hash_bits", "11041": "css_set_rwsem", "11042": "css_set_table", "11043": "css_task_iter", "11044": "css_task_iter_end", "11045": "css_task_iter_next", "11046": "css_task_iter_start", "11047": "css_tg", "11048": "css_tryget", "11049": "css_tryget_online", "11050": "css_tryget_online_from_dir", "11051": "cstime", "11052": "ct", "11053": "ct_idx", "11054": "ctime", "11055": "ctl_abi", "11056": "ctl_bus", "11057": "ctl_bus_isa", "11058": "ctl_dev", "11059": "ctl_dir", "11060": "ctl_dnadr", "11061": "ctl_fs", "11062": "ctl_int", "11063": "ctl_kern", "11064": "ctl_max_resvport", "11065": "ctl_maxname", "11066": "ctl_min_resvport", "11067": "ctl_name", "11068": "ctl_net", "11069": "ctl_path", "11070": "ctl_pm", "11071": "ctl_s390dbf", "11072": "ctl_slottable_tcp", "11073": "ctl_slottable_udp", "11074": "ctl_str", "11075": "ctl_sunrpc", "11076": "ctl_table", "11077": "ctl_table_header", "11078": "ctl_ulong", "11079": "ctl_uuid", "11080": "ctl_vm", "11081": "ctors", "11082": "ctr", "11083": "ctr_mask", "11084": "ctr_type", "11085": "ctrl_n", "11086": "ctrl_p", "11087": "ctrs", "11088": "cts", "11089": "ctv", "11090": "ctx", "11091": "ctx1", "11092": "ctx2", "11093": "ctx_flexible_sched_in", "11094": "ctx_pinned_sched_in", "11095": "ctx_sched_in", "11096": "ctx_sched_out", "11097": "ctx_state", "11098": "ctx_switch_entry", "11099": "ctx_time", "11100": "ctxn", "11101": "cu", "11102": "cur", "11103": "cur_cset", "11104": "cur_dl_b", "11105": "cur_ld_moved", "11106": "cur_ops", "11107": "cur_ret", "11108": "cur_setting", "11109": "cur_ss_mask", "11110": "cur_stack", "11111": "cur_state", "11112": "cur_swap", "11113": "cur_task", "11114": "cur_uprobe", "11115": "curdev", "11116": "curr", "11117": "curr_chain_key", "11118": "curr_cost", "11119": "curr_cpu", "11120": "curr_distance", "11121": "curr_jiffies", "11122": "curr_load_addr", "11123": "curr_operand", "11124": "curr_ret_stack", "11125": "curr_target", "11126": "curr_value", "11127": "current", "11128": "current_chrooted", "11129": "current_clr_polling_and_test", "11130": "current_context", "11131": "current_cpuset_is_being_rebound", "11132": "current_cred", "11133": "current_css_set_cg_links_read", "11134": "current_css_set_read", "11135": "current_css_set_refcount_read", "11136": "current_device", "11137": "current_egid", "11138": "current_euid", "11139": "current_fs_time", "11140": "current_fsgid", "11141": "current_fsuid", "11142": "current_func", "11143": "current_gid", "11144": "current_is_async", "11145": "current_is_workqueue_rescuer", "11146": "current_kernel_time", "11147": "current_pwq", "11148": "current_state", "11149": "current_thread_info", "11150": "current_time", "11151": "current_trace", "11152": "current_tracer", "11153": "current_uid", "11154": "current_uid_gid", "11155": "current_user", "11156": "current_user_ns", "11157": "current_user_stack_pointer", "11158": "current_work", "11159": "current_wq_worker", "11160": "cursor", "11161": "curstate", "11162": "curtail", "11163": "curtask", "11164": "cutime", "11165": "cv_idx", "11166": "cv_size", "11167": "cval", "11168": "cwait", "11169": "cwt_wait", "11170": "cwt_wakefn", "11171": "cxt", "11172": "cycle", "11173": "cycle_delta", "11174": "cycle_interval", "11175": "cycle_last", "11176": "cycle_now", "11177": "cycle_t", "11178": "cycle_tstamp", "11179": "cyclecounter", "11180": "cyclecounter_cyc2ns", "11181": "cycles", "11182": "cycles_at_suspend", "11183": "d", "11184": "d_backing_inode", "11185": "d_child", "11186": "d_events", "11187": "d_inode", "11188": "d_is_positive", "11189": "d_lock", "11190": "d_name", "11191": "d_parent", "11192": "d_path", "11193": "d_really_is_positive", "11194": "d_sb", "11195": "d_subdirs", "11196": "d_tracer", "11197": "d_tracing", "11198": "dac_mmap_min_addr", "11199": "daemon", "11200": "dah_align", "11201": "dah_first", "11202": "dah_first_call", "11203": "dah_overhead", "11204": "dah_used", "11205": "dah_used_max", "11206": "dap_lock", "11207": "dap_locked", "11208": "dash2underscore", "11209": "dat", "11210": "data", "11211": "data_cnt", "11212": "data_head", "11213": "data_len", "11214": "data_of", "11215": "data_offset", "11216": "data_page", "11217": "data_page_nr", "11218": "data_pages", "11219": "data_rec", "11220": "data_size", "11221": "data_src", "11222": "data_tail", "11223": "data_type", "11224": "datalp", "11225": "dataof_trace_entry", "11226": "datap", "11227": "dataptr", "11228": "datasz", "11229": "datavp", "11230": "dattr", "11231": "dattr_cur", "11232": "day", "11233": "days", "11234": "db_result", "11235": "dbg_activate_sw_breakpoints", "11236": "dbg_deactivate_sw_breakpoints", "11237": "dbg_get_reg", "11238": "dbg_io_get_char", "11239": "dbg_io_ops", "11240": "dbg_is_early", "11241": "dbg_kdb_mode", "11242": "dbg_late_init", "11243": "dbg_master_lock", "11244": "dbg_max_reg_num", "11245": "dbg_module_load_nb", "11246": "dbg_notify_reboot", "11247": "dbg_pass_event", "11248": "dbg_reboot_notifier", "11249": "dbg_reg_def", "11250": "dbg_remove_all_break", "11251": "dbg_remove_sw_break", "11252": "dbg_set_reg", "11253": "dbg_set_sw_break", "11254": "dbg_slave_lock", "11255": "dbg_switch_cpu", "11256": "dbg_switch_cpu_event", "11257": "dbg_touch_watchdogs", "11258": "dci_ptr", "11259": "dcount", "11260": "dcpu_is_slave", "11261": "dcpu_next_master", "11262": "dcpu_sstep", "11263": "dcpu_want_master", "11264": "ddebug_add_module", "11265": "ddebug_cleanup", "11266": "ddebug_dyndbg_module_param_cb", "11267": "ddebug_remove_module", "11268": "ddir_act", "11269": "de", "11270": "deactivate", "11271": "deactivate_mm", "11272": "deactivate_super", "11273": "deactivate_task", "11274": "dead", "11275": "dead_cpu", "11276": "deadcpu", "11277": "deadline", "11278": "deadlock", "11279": "deadlock_inject_countdown", "11280": "deadlock_inject_interval", "11281": "deadlock_lock", "11282": "deadlock_task_pid", "11283": "debug", "11284": "debug_activate", "11285": "debug_align", "11286": "debug_alloc_header", "11287": "debug_alloc_pool", "11288": "debug_alloc_pool_aligned", "11289": "debug_assert_init", "11290": "debug_atomic_dec", "11291": "debug_atomic_inc", "11292": "debug_atomic_read", "11293": "debug_cgrp_subsys", "11294": "debug_check_no_locks_freed", "11295": "debug_check_no_locks_held", "11296": "debug_css_alloc", "11297": "debug_css_free", "11298": "debug_deactivate", "11299": "debug_files", "11300": "debug_hint", "11301": "debug_init", "11302": "debug_kfree", "11303": "debug_kmalloc", "11304": "debug_kusage", "11305": "debug_kusage_one_time", "11306": "debug_lock", "11307": "debug_lockdep_rcu_enabled", "11308": "debug_locks", "11309": "debug_locks_off", "11310": "debug_locks_off_graph_unlock", "11311": "debug_locks_silent", "11312": "debug_locks_warn_on", "11313": "debug_mutex_add_waiter", "11314": "debug_mutex_free_waiter", "11315": "debug_mutex_init", "11316": "debug_mutex_lock_common", "11317": "debug_mutex_unlock", "11318": "debug_mutex_wake_waiter", "11319": "debug_obj_descr", "11320": "debug_obj_state", "11321": "debug_object_activate", "11322": "debug_object_active_state", "11323": "debug_object_assert_init", "11324": "debug_object_deactivate", "11325": "debug_object_free", "11326": "debug_object_init", "11327": "debug_object_init_on_stack", "11328": "debug_rcu_head_queue", "11329": "debug_rcu_head_unqueue", "11330": "debug_rt_mutex_deadlock", "11331": "debug_rt_mutex_detect_deadlock", "11332": "debug_rt_mutex_free_waiter", "11333": "debug_rt_mutex_init", "11334": "debug_rt_mutex_init_waiter", "11335": "debug_rt_mutex_lock", "11336": "debug_rt_mutex_print_deadlock", "11337": "debug_rt_mutex_proxy_lock", "11338": "debug_rt_mutex_proxy_unlock", "11339": "debug_rt_mutex_reset_waiter", "11340": "debug_rt_mutex_unlock", "11341": "debug_shift", "11342": "debug_show_all_locks", "11343": "debug_show_held_locks", "11344": "debug_spin_lock_after", "11345": "debug_spin_lock_before", "11346": "debug_spin_unlock", "11347": "debug_table", "11348": "debug_taskcount_read", "11349": "debug_timer_activate", "11350": "debug_timer_assert_init", "11351": "debug_timer_deactivate", "11352": "debug_timer_free", "11353": "debug_timer_init", "11354": "debug_work_activate", "11355": "debug_work_deactivate", "11356": "debug_write_lock_after", "11357": "debug_write_lock_before", "11358": "debug_write_unlock", "11359": "debugfs", "11360": "debugfs_create_dir", "11361": "debugfs_create_file", "11362": "debugfs_create_symlink", "11363": "debugfs_filename", "11364": "debugfs_kprobe_blacklist_ops", "11365": "debugfs_kprobes_operations", "11366": "debugfs_remove", "11367": "debugfs_remove_recursive", "11368": "debuggerinfo", "11369": "debuggerinfo_struct", "11370": "debugging", "11371": "dec", "11372": "dec_data", "11373": "dec_mm_counter", "11374": "dec_rt_group", "11375": "dec_rt_migration", "11376": "dec_rt_prio", "11377": "dec_rt_prio_smp", "11378": "dec_rt_tasks", "11379": "decay_count", "11380": "decay_counter", "11381": "decay_load", "11382": "decay_load_missed", "11383": "decayed", "11384": "decays", "11385": "declare_basic_fetch_funcs", "11386": "declare_basic_print_type_func", "11387": "declare_bitmap", "11388": "declare_completion", "11389": "declare_completion_onstack", "11390": "declare_fetch_func", "11391": "declare_hashtable", "11392": "declare_per_cpu", "11393": "declare_per_cpu_shared_aligned", "11394": "declare_rwsem", "11395": "declare_tasklet", "11396": "declare_wait_queue_head", "11397": "declare_waitqueue", "11398": "declare_work", "11399": "decode_state", "11400": "decrement", "11401": "decrement_wakelocks_number", "11402": "decremented", "11403": "decrements", "11404": "def_dl_bandwidth", "11405": "def_flags", "11406": "def_root_domain", "11407": "def_rt_bandwidth", "11408": "default", "11409": "default_affinity_open", "11410": "default_affinity_proc_fops", "11411": "default_affinity_show", "11412": "default_affinity_write", "11413": "default_arch_gettimeoffset", "11414": "default_attrs", "11415": "default_bootup_tracer", "11416": "default_cfs_period", "11417": "default_cpu_time_max_percent", "11418": "default_dump_filter", "11419": "default_fetch_type", "11420": "default_fetch_type_str", "11421": "default_fs_overflowuid", "11422": "default_handle", "11423": "default_iterations", "11424": "default_label", "11425": "default_llseek", "11426": "default_max_sample_rate", "11427": "default_overflowgid", "11428": "default_overflowuid", "11429": "default_reboot_mode", "11430": "default_relax_domain_level", "11431": "default_sample_period_ns", "11432": "default_scale_cpu_capacity", "11433": "default_sys_filter_message", "11434": "default_timer_slack_ns", "11435": "default_topology", "11436": "default_value", "11437": "default_wake_function", "11438": "defcmd", "11439": "defcmd_in_progress", "11440": "defcmd_set", "11441": "defcmd_set_count", "11442": "deferred_free", "11443": "define", "11444": "define_basic_fetch_funcs", "11445": "define_basic_print_type_func", "11446": "define_comparison_pred", "11447": "define_equality_pred", "11448": "define_fetch_", "11449": "define_fetch_bitfield", "11450": "define_fetch_deref", "11451": "define_fetch_file_offset", "11452": "define_fetch_memory", "11453": "define_fetch_reg", "11454": "define_fetch_retval", "11455": "define_fetch_stack", "11456": "define_fetch_symbol", "11457": "define_field", "11458": "define_fields", "11459": "define_hashtable", "11460": "define_idr", "11461": "define_irq_work", "11462": "define_mutex", "11463": "define_per_cpu", "11464": "define_per_cpu_shared_aligned", "11465": "define_raw_spinlock", "11466": "define_rcu_tps", "11467": "define_rwlock", "11468": "define_semaphore", "11469": "define_spinlock", "11470": "define_srcu", "11471": "define_static_lglock", "11472": "define_static_srcu", "11473": "define_timer", "11474": "define_torture_random", "11475": "define_wait", "11476": "define_wait_atomic_t", "11477": "define_wait_bit", "11478": "defined", "11479": "degrade_factor", "11480": "degrade_shift", "11481": "degrade_zero_ticks", "11482": "del", "11483": "del_singleshot_timer_sync", "11484": "del_timer", "11485": "del_timer_sync", "11486": "del_usage_links", "11487": "delay", "11488": "delayacct_add_tsk", "11489": "delayacct_blkio_end", "11490": "delayacct_blkio_start", "11491": "delayacct_cache", "11492": "delayacct_end", "11493": "delayacct_init", "11494": "delayacct_is_task_waiting_on_io", "11495": "delayacct_on", "11496": "delayacct_pf_swapin", "11497": "delayacct_setup_disable", "11498": "delayacct_tsk_free", "11499": "delayacct_tsk_init", "11500": "delayed_free_pidns", "11501": "delayed_put_pid", "11502": "delayed_work", "11503": "delayed_work_pending", "11504": "delayed_work_timer_fn", "11505": "delayed_works", "11506": "delays", "11507": "delcount", "11508": "delete_all_elements", "11509": "delete_clock", "11510": "delete_irq_desc", "11511": "delete_module", "11512": "delete_uprobe", "11513": "delim", "11514": "delta", "11515": "delta_cpu", "11516": "delta_delta", "11517": "delta_exec", "11518": "delta_jiffies", "11519": "delta_ns", "11520": "delta_w", "11521": "dentry", "11522": "dentry_stat", "11523": "dep_gen_id", "11524": "dep_map", "11525": "dependencies", "11526": "dependency", "11527": "depends", "11528": "depends_on", "11529": "deprecated", "11530": "deprecated_sysctl_warning", "11531": "depth", "11532": "depth_irq", "11533": "dequeue", "11534": "dequeue_entity", "11535": "dequeue_entity_load_avg", "11536": "dequeue_pushable_task", "11537": "dequeue_rt_entity", "11538": "dequeue_rt_stack", "11539": "dequeue_signal", "11540": "dequeue_sleep", "11541": "dequeue_task", "11542": "dequeue_task_fair", "11543": "dequeue_task_idle", "11544": "dequeue_task_rt", "11545": "dequeue_top_rt_rq", "11546": "deref", "11547": "deref_fetch_param", "11548": "dereference_function_descriptor", "11549": "deregister", "11550": "des_cs", "11551": "desc", "11552": "desc_node", "11553": "desc_set_defaults", "11554": "desc_size", "11555": "desc_smp_init", "11556": "desc_valid", "11557": "description", "11558": "deskew", "11559": "desktop", "11560": "dest", "11561": "dest_cfs_rq", "11562": "dest_cpu", "11563": "dest_image", "11564": "dest_pages", "11565": "destination", "11566": "destroy", "11567": "destroy_cfs_bandwidth", "11568": "destroy_context", "11569": "destroy_delayed_work_on_stack", "11570": "destroy_dwork", "11571": "destroy_header_iter", "11572": "destroy_params", "11573": "destroy_pid_namespace", "11574": "destroy_rcu_head", "11575": "destroy_rcu_head_on_stack", "11576": "destroy_root", "11577": "destroy_rt_bandwidth", "11578": "destroy_sched_domain", "11579": "destroy_sched_domains", "11580": "destroy_session", "11581": "destroy_timer_on_stack", "11582": "destroy_work", "11583": "destroy_work_on_stack", "11584": "destroy_worker", "11585": "destroy_workqueue", "11586": "detach_completion", "11587": "detach_expired_timer", "11588": "detach_group", "11589": "detach_if_pending", "11590": "detach_one_task", "11591": "detach_pid", "11592": "detach_task", "11593": "detach_tasks", "11594": "detach_timer", "11595": "detached", "11596": "detected", "11597": "dev", "11598": "dev_attr_act_mask", "11599": "dev_attr_current_device", "11600": "dev_attr_enable", "11601": "dev_attr_end_lba", "11602": "dev_attr_pid", "11603": "dev_attr_start_lba", "11604": "dev_attr_unbind_device", "11605": "dev_dbg", "11606": "dev_err", "11607": "dev_get_by_index", "11608": "dev_groups", "11609": "dev_id", "11610": "dev_ipmi", "11611": "dev_ipmi_poweroff_powercycle", "11612": "dev_mac_hid", "11613": "dev_mac_hid_mouse_button2_keycode", "11614": "dev_mac_hid_mouse_button3_keycode", "11615": "dev_mac_hid_mouse_button_emulation", "11616": "dev_name", "11617": "dev_pm_ops", "11618": "dev_put", "11619": "dev_raid", "11620": "dev_raid_speed_limit_max", "11621": "dev_raid_speed_limit_min", "11622": "dev_scsi", "11623": "dev_scsi_logging_level", "11624": "dev_set_uevent_suppress", "11625": "dev_t", "11626": "dev_table", "11627": "dev_to_node", "11628": "dev_to_part", "11629": "dev_to_wq", "11630": "devfn", "11631": "device", "11632": "device_attr", "11633": "device_attr_ro", "11634": "device_attribute", "11635": "device_create_file", "11636": "device_from", "11637": "device_id", "11638": "device_initcall", "11639": "device_may_wakeup", "11640": "device_node", "11641": "device_register", "11642": "device_shutdown", "11643": "device_to", "11644": "device_unregister", "11645": "devices", "11646": "devid", "11647": "devm_region_match", "11648": "devm_region_release", "11649": "devm_release_resource", "11650": "devm_request_resource", "11651": "devm_resource_match", "11652": "devm_resource_release", "11653": "devname", "11654": "devres_add", "11655": "devres_alloc", "11656": "devres_destroy", "11657": "devres_free", "11658": "devres_release", "11659": "devtree", "11660": "df", "11661": "dfl_cftypes", "11662": "dfl_cgrp", "11663": "dfl_pwq", "11664": "dgc", "11665": "diag", "11666": "diagnostic", "11667": "dict_len", "11668": "did", "11669": "did_panic", "11670": "die", "11671": "die_args", "11672": "die_chain", "11673": "die_oops", "11674": "die_val", "11675": "diff", "11676": "digest", "11677": "dir", "11678": "dir_notify_enable", "11679": "direct", "11680": "direct_max", "11681": "directory", "11682": "dirty", "11683": "dirty_background_bytes", "11684": "dirty_background_bytes_handler", "11685": "dirty_background_ratio", "11686": "dirty_background_ratio_handler", "11687": "dirty_bytes_handler", "11688": "dirty_bytes_min", "11689": "dirty_expire_interval", "11690": "dirty_paused_when", "11691": "dirty_ratio_handler", "11692": "dirty_writeback_centisecs_handler", "11693": "dirty_writeback_interval", "11694": "dirtytime_expire_interval", "11695": "dirtytime_interval_handler", "11696": "disable", "11697": "disable_branch_profiling", "11698": "disable_branch_tracing", "11699": "disable_event", "11700": "disable_event_str", "11701": "disable_first", "11702": "disable_hardirq", "11703": "disable_hw_break", "11704": "disable_irq", "11705": "disable_irq_nosync", "11706": "disable_kprobe", "11707": "disable_kretprobe", "11708": "disable_mmiotrace", "11709": "disable_nonboot_cpus", "11710": "disable_percpu_irq", "11711": "disable_pid_allocation", "11712": "disable_reader", "11713": "disable_sched_clock_irqtime", "11714": "disable_trace_kprobe", "11715": "disable_trace_on_warning", "11716": "disable_tsc", "11717": "disabled", "11718": "disabled_wait", "11719": "disables", "11720": "disarm_kprobe", "11721": "disarm_kprobe_ftrace", "11722": "disarmed", "11723": "discard", "11724": "discovered", "11725": "disk_devt", "11726": "disk_show", "11727": "displaced", "11728": "display", "11729": "dist", "11730": "distance", "11731": "distribute_cfs_runtime", "11732": "div64_u64", "11733": "div64_u64_rem", "11734": "div64_ul", "11735": "div_factor", "11736": "div_round_closest", "11737": "div_round_up", "11738": "div_s64", "11739": "div_s64_rem", "11740": "div_u64", "11741": "div_u64_rem", "11742": "dividend", "11743": "divisor", "11744": "dj", "11745": "dl", "11746": "dl_b", "11747": "dl_bandwidth", "11748": "dl_bandwidth_enabled", "11749": "dl_boosted", "11750": "dl_bw", "11751": "dl_bw_cpus", "11752": "dl_bw_of", "11753": "dl_deadline", "11754": "dl_entity_preempt", "11755": "dl_new", "11756": "dl_nr_migratory", "11757": "dl_nr_running", "11758": "dl_overflow", "11759": "dl_param_changed", "11760": "dl_period", "11761": "dl_policy", "11762": "dl_prio", "11763": "dl_rq", "11764": "dl_runtime", "11765": "dl_runtime_lock", "11766": "dl_sched_class", "11767": "dl_se", "11768": "dl_task", "11769": "dl_throttled", "11770": "dl_time_before", "11771": "dl_yielded", "11772": "dlen", "11773": "dlo_count", "11774": "dlo_mask", "11775": "dma_chan", "11776": "dma_chan_busy", "11777": "dma_spin_lock", "11778": "dmanr", "11779": "dmesg_restrict", "11780": "dnaddr", "11781": "dname", "11782": "do", "11783": "do_acct_process", "11784": "do_adjtimex", "11785": "do_balance_runtime", "11786": "do_blk_trace_setup", "11787": "do_check", "11788": "do_coredump", "11789": "do_div", "11790": "do_each_pid_task", "11791": "do_each_pid_thread", "11792": "do_each_thread", "11793": "do_execve", "11794": "do_exit", "11795": "do_fault", "11796": "do_for_each_event_file", "11797": "do_for_each_event_file_safe", "11798": "do_for_each_ftrace_op", "11799": "do_for_each_ftrace_rec", "11800": "do_fork", "11801": "do_free_cleaned_kprobes", "11802": "do_free_init", "11803": "do_full_getstr", "11804": "do_futex", "11805": "do_getitimer", "11806": "do_gettimeofday", "11807": "do_group_exit", "11808": "do_init_module", "11809": "do_init_timer", "11810": "do_jobctl_trap", "11811": "do_kernel_restart", "11812": "do_kimage_alloc_init", "11813": "do_migrate_pages", "11814": "do_mod_ctors", "11815": "do_no_restart_syscall", "11816": "do_nocb_deferred_wakeup", "11817": "do_nothing", "11818": "do_notify_parent", "11819": "do_notify_parent_cldstop", "11820": "do_one_initcall", "11821": "do_optimize_kprobes", "11822": "do_poweroff", "11823": "do_print_state", "11824": "do_prlimit", "11825": "do_proc_dointvec", "11826": "do_proc_dointvec_conv", "11827": "do_proc_dointvec_jiffies_conv", "11828": "do_proc_dointvec_minmax_conv", "11829": "do_proc_dointvec_minmax_conv_param", "11830": "do_proc_doulongvec_minmax", "11831": "do_profile_hits", "11832": "do_raw_", "11833": "do_raw_read_lock", "11834": "do_raw_read_trylock", "11835": "do_raw_read_unlock", "11836": "do_raw_spin_lock", "11837": "do_raw_spin_lock_flags", "11838": "do_raw_spin_trylock", "11839": "do_raw_spin_unlock", "11840": "do_raw_write_lock", "11841": "do_raw_write_trylock", "11842": "do_raw_write_unlock", "11843": "do_rt_sigqueueinfo", "11844": "do_rt_tgsigqueueinfo", "11845": "do_sched_cfs_period_timer", "11846": "do_sched_cfs_slack_timer", "11847": "do_sched_rt_period_timer", "11848": "do_sched_setscheduler", "11849": "do_schedule_next_timer", "11850": "do_seccomp", "11851": "do_send_sig_info", "11852": "do_send_specific", "11853": "do_set_cpus_allowed", "11854": "do_setitimer", "11855": "do_settimeofday", "11856": "do_settimeofday64", "11857": "do_sigaction", "11858": "do_sigaltstack", "11859": "do_signal_stop", "11860": "do_sigpending", "11861": "do_sigtimedwait", "11862": "do_softirq", "11863": "do_softirq_own_stack", "11864": "do_switch", "11865": "do_sys_settimeofday", "11866": "do_sys_times", "11867": "do_sysctl", "11868": "do_sysinfo", "11869": "do_sysvsem", "11870": "do_test", "11871": "do_timer", "11872": "do_timer_last", "11873": "do_trace_rcu_torture_read", "11874": "do_trap", "11875": "do_unoptimize_kprobes", "11876": "do_usleep_range", "11877": "dodgy_cert", "11878": "does", "11879": "doesn", "11880": "doing", "11881": "doing_kgdb", "11882": "doing_ss", "11883": "doit", "11884": "dolock", "11885": "domain", "11886": "domain_cost", "11887": "domain_list", "11888": "domain_num", "11889": "domainname", "11890": "domains", "11891": "doms", "11892": "doms_cur", "11893": "done", "11894": "done_acquire", "11895": "done_seqretry_irqrestore", "11896": "donetail", "11897": "dont_count", "11898": "dot", "11899": "double_lock", "11900": "double_lock_balance", "11901": "double_lock_irq", "11902": "double_raw_lock", "11903": "double_rq_lock", "11904": "double_rq_unlock", "11905": "double_tick", "11906": "double_unlock_balance", "11907": "down", "11908": "down_console_sem", "11909": "down_interruptible", "11910": "down_killable", "11911": "down_read", "11912": "down_read_nested", "11913": "down_read_non_owner", "11914": "down_read_trylock", "11915": "down_timeout", "11916": "down_trylock", "11917": "down_trylock_console_sem", "11918": "down_write", "11919": "down_write_nested", "11920": "down_write_trylock", "11921": "downgrade_write", "11922": "dp", "11923": "dpm_complete", "11924": "dpm_prepare", "11925": "dpm_resume", "11926": "dpm_resume_end", "11927": "dpm_resume_start", "11928": "dpm_suspend", "11929": "dpm_suspend_end", "11930": "dpm_suspend_start", "11931": "dprm", "11932": "dput", "11933": "dr", "11934": "drain_local_pages", "11935": "drain_workqueue", "11936": "drained", "11937": "driver", "11938": "drivers_dir", "11939": "drop", "11940": "drop_boost_mutex", "11941": "drop_caches_sysctl_handler", "11942": "drop_collected_mounts", "11943": "drop_precision", "11944": "dropped", "11945": "dropped_count", "11946": "dropped_events", "11947": "dropped_file", "11948": "drv", "11949": "dry_run", "11950": "dsize", "11951": "dst", "11952": "dst_capacity", "11953": "dst_cgrp", "11954": "dst_cpu", "11955": "dst_cset", "11956": "dst_csets", "11957": "dst_grpmask", "11958": "dst_load", "11959": "dst_nid", "11960": "dst_op", "11961": "dst_op_no_mark", "11962": "dst_reg", "11963": "dst_root", "11964": "dst_rq", "11965": "dst_stats", "11966": "dst_task", "11967": "dtabcount", "11968": "dtime", "11969": "dummy", "11970": "dummy_clock_read", "11971": "dummy_cmp", "11972": "dummy_irq_chip", "11973": "dummy_set_flag", "11974": "dummy_tracer_flags", "11975": "dummy_tracer_opt", "11976": "dump", "11977": "dump_all", "11978": "dump_cpu_task", "11979": "dump_kprobe", "11980": "dump_orig", "11981": "dump_probe_ops", "11982": "dump_stack", "11983": "dumpable", "11984": "dumping", "11985": "dup", "11986": "dup_fd", "11987": "dup_mm", "11988": "dup_mmap", "11989": "dup_mmap_sem", "11990": "dup_task_struct", "11991": "dup_utask", "11992": "dup_xol_addr", "11993": "dup_xol_work", "11994": "duplicate_memory_bitmap", "11995": "duration", "11996": "during", "11997": "dw", "11998": "dwork", "11999": "dyn_ftrace", "12000": "dyn_ftrace_test_name", "12001": "dyn_ftrace_test_name2", "12002": "dyn_ftrace_total_info", "12003": "dyn_ops", "12004": "dynamic", "12005": "dynamic_debug_remove", "12006": "dynamic_debug_setup", "12007": "dyntick_save_progress_counter", "12008": "dyntick_task_exit_idle", "12009": "dyntick_task_flag", "12010": "dyntick_task_mask", "12011": "dyntick_task_nest_mask", "12012": "dyntick_task_nest_value", "12013": "dyntick_task_nest_width", "12014": "dynticks", "12015": "dynticks_fqs", "12016": "dynticks_idle", "12017": "dynticks_idle_jiffies", "12018": "dynticks_idle_nesting", "12019": "dynticks_nesting", "12020": "dynticks_nmi_nesting", "12021": "dynticks_snap", "12022": "e", "12023": "e1", "12024": "e2", "12025": "e2big", "12026": "e_cset_node", "12027": "e_csets", "12028": "e_entry", "12029": "e_ident", "12030": "e_shentsize", "12031": "e_shnum", "12032": "e_shoff", "12033": "e_shstrndx", "12034": "e_type", "12035": "eacces", "12036": "each_symbol_in_section", "12037": "each_symbol_section", "12038": "eaddr", "12039": "eaddrnotavail", "12040": "eagain", "12041": "ealready", "12042": "earliest_dl", "12043": "early", "12044": "early_boot_irqs_disabled", "12045": "early_boot_test_call_rcu", "12046": "early_boot_test_call_rcu_bh", "12047": "early_boot_test_call_rcu_sched", "12048": "early_boot_test_counter", "12049": "early_enable_events", "12050": "early_event_add_tracer", "12051": "early_init", "12052": "early_initcall", "12053": "early_irq_init", "12054": "early_param", "12055": "ebadf", "12056": "ebadmsg", "12057": "ebusy", "12058": "echild", "12059": "echo", "12060": "ecode", "12061": "econnrefused", "12062": "edeadlk", "12063": "eexist", "12064": "efault", "12065": "efbig", "12066": "effective", "12067": "effective_cpus", "12068": "effective_flags", "12069": "effective_load", "12070": "effective_mems", "12071": "effective_prio", "12072": "egid", "12073": "egidp", "12074": "ehdr", "12075": "eilseq", "12076": "einprogress", "12077": "eintr", "12078": "einval", "12079": "eio", "12080": "elapsed", "12081": "elapsed_centisecs64", "12082": "elapsed_msecs", "12083": "elapsed_msecs64", "12084": "elem", "12085": "elem_size", "12086": "element", "12087": "elements", "12088": "elemsize", "12089": "elen", "12090": "elf_check_arch", "12091": "elf_core_copy_kernel_regs", "12092": "elf_core_extra_data_size", "12093": "elf_core_extra_phdrs", "12094": "elf_core_write_extra_data", "12095": "elf_core_write_extra_phdrs", "12096": "elf_ehdr", "12097": "elf_half", "12098": "elf_header_check", "12099": "elf_note", "12100": "elf_prstatus", "12101": "elf_shdr", "12102": "elf_st_bind", "12103": "elf_st_type", "12104": "elf_sym", "12105": "elf_type", "12106": "elfcore_addr_max", "12107": "elfcorehdr_addr", "12108": "elfcorehdr_size", "12109": "elfmag", "12110": "elif", "12111": "else", "12112": "elt", "12113": "emergency_restart", "12114": "empty", "12115": "empty_buckets", "12116": "empty_exp", "12117": "empty_exp_now", "12118": "empty_hash", "12119": "empty_norm", "12120": "empty_rp", "12121": "en_flags", "12122": "enable", "12123": "enable_branch_tracing", "12124": "enable_cpus", "12125": "enable_data", "12126": "enable_event", "12127": "enable_event_str", "12128": "enable_irq", "12129": "enable_irqs", "12130": "enable_kprobe", "12131": "enable_kretprobe", "12132": "enable_mask", "12133": "enable_mmiotrace", "12134": "enable_nmi", "12135": "enable_nonboot_cpus", "12136": "enable_on_exec", "12137": "enable_percpu_irq", "12138": "enable_sched_clock_irqtime", "12139": "enable_stacktrace", "12140": "enable_trace_kprobe", "12141": "enable_trigger_data", "12142": "enabled", "12143": "enabled_functions", "12144": "enabled_kobj_attr", "12145": "enabled_perf_enter_syscalls", "12146": "enabled_perf_exit_syscalls", "12147": "enabled_show", "12148": "enabled_store", "12149": "enables", "12150": "enametoolong", "12151": "enanosleep_notsup", "12152": "encode_comp_t", "12153": "encode_float", "12154": "end", "12155": "end_addr", "12156": "end_code", "12157": "end_data", "12158": "end_lba", "12159": "end_of_stack", "12160": "end_p", "12161": "end_pfn", "12162": "end_swap_bio_read", "12163": "end_time", "12164": "ended", "12165": "endefcmd", "12166": "endp", "12167": "endtime", "12168": "enodata", "12169": "enodev", "12170": "enoent", "12171": "enoexec", "12172": "enoioctlcmd", "12173": "enokey", "12174": "enomem", "12175": "enomem_pwq", "12176": "enopkg", "12177": "enospc", "12178": "enosys", "12179": "enotdir", "12180": "enotsup", "12181": "enotsupp", "12182": "enotty", "12183": "enough_free_mem", "12184": "enough_swap", "12185": "enqueue", "12186": "enqueue_entity", "12187": "enqueue_entity_load_avg", "12188": "enqueue_flag", "12189": "enqueue_head", "12190": "enqueue_pushable_task", "12191": "enqueue_replenish", "12192": "enqueue_rt_entity", "12193": "enqueue_sleeper", "12194": "enqueue_task", "12195": "enqueue_task_fair", "12196": "enqueue_task_rt", "12197": "enqueue_top_rt_rq", "12198": "enqueue_wakeup", "12199": "enqueue_waking", "12200": "ent", "12201": "ent_cpu", "12202": "ent_size", "12203": "ent_ts", "12204": "enter", "12205": "enter_event", "12206": "enter_fields", "12207": "enter_funcs", "12208": "enter_kgdb", "12209": "enter_lazy_tlb", "12210": "enter_syscall_files", "12211": "entered_state", "12212": "entering", "12213": "entering_platform_hibernation", "12214": "entity_before", "12215": "entity_is_task", "12216": "entity_tick", "12217": "entries", "12218": "entries_bytes", "12219": "entries_per_page", "12220": "entry", "12221": "entry1", "12222": "entry2", "12223": "entry_count", "12224": "entry_handler", "12225": "entry_sidx", "12226": "entry_size", "12227": "entryfunc", "12228": "enum", "12229": "enum_map", "12230": "enum_replace", "12231": "enum_string", "12232": "enum_value", "12233": "env", "12234": "env_end", "12235": "env_start", "12236": "environment", "12237": "envp", "12238": "enxio", "12239": "eof", "12240": "eoi", "12241": "eopnotsupp", "12242": "eperm", "12243": "epoll_table", "12244": "equals", "12245": "erange", "12246": "erestart_restartblock", "12247": "erestartnohand", "12248": "erestartnointr", "12249": "erestartsys", "12250": "err", "12251": "err2", "12252": "err_alloc", "12253": "err_broadcast", "12254": "err_buffer", "12255": "err_cachep", "12256": "err_cast", "12257": "err_close", "12258": "err_code", "12259": "err_cpu", "12260": "err_desc", "12261": "err_destroy", "12262": "err_flags", "12263": "err_free", "12264": "err_free_css", "12265": "err_free_id", "12266": "err_free_info", "12267": "err_free_inst", "12268": "err_free_iter_info", "12269": "err_free_masks", "12270": "err_free_pd", "12271": "err_free_percpu_ref", "12272": "err_free_pqueue", "12273": "err_free_rq", "12274": "err_free_squeue", "12275": "err_free_wq", "12276": "err_kstat", "12277": "err_list_del", "12278": "err_no_task", "12279": "err_nomem", "12280": "err_out", "12281": "err_ptr", "12282": "err_put", "12283": "err_readtime", "12284": "err_rel", "12285": "err_remove", "12286": "err_size", "12287": "err_suspend", "12288": "err_text", "12289": "err_undo_css", "12290": "err_unlock", "12291": "err_wakealarm", "12292": "errcnt", "12293": "errno", "12294": "error", "12295": "error_packet", "12296": "error_path", "12297": "error_put", "12298": "error_put_key", "12299": "errors", "12300": "errout", "12301": "erule", "12302": "escaped", "12303": "esize", "12304": "esrch", "12305": "esterror", "12306": "et_rel", "12307": "etime", "12308": "ett_event_enable", "12309": "ett_none", "12310": "ett_snapshot", "12311": "ett_stacktrace", "12312": "ett_trace_onoff", "12313": "etype", "12314": "euid", "12315": "euidp", "12316": "eusers", "12317": "ev", "12318": "eval", "12319": "evector", "12320": "even_unformed", "12321": "event", "12322": "event_", "12323": "event_all", "12324": "event_branch", "12325": "event_buf_size", "12326": "event_call", "12327": "event_class_ftrace_", "12328": "event_clear_filter", "12329": "event_clear_no_set_filter_flag", "12330": "event_command", "12331": "event_context_switch", "12332": "event_create_dir", "12333": "event_dir", "12334": "event_disable_cmd", "12335": "event_disable_count_probe_ops", "12336": "event_disable_count_trigger_ops", "12337": "event_disable_probe_ops", "12338": "event_disable_trigger_ops", "12339": "event_dropped", "12340": "event_enable_cmd", "12341": "event_enable_count_probe", "12342": "event_enable_count_probe_ops", "12343": "event_enable_count_trigger", "12344": "event_enable_count_trigger_ops", "12345": "event_enable_file", "12346": "event_enable_free", "12347": "event_enable_func", "12348": "event_enable_get_trigger_ops", "12349": "event_enable_init", "12350": "event_enable_on_exec", "12351": "event_enable_print", "12352": "event_enable_probe", "12353": "event_enable_probe_ops", "12354": "event_enable_read", "12355": "event_enable_register_trigger", "12356": "event_enable_trigger", "12357": "event_enable_trigger_free", "12358": "event_enable_trigger_func", "12359": "event_enable_trigger_ops", "12360": "event_enable_trigger_print", "12361": "event_enable_unregister_trigger", "12362": "event_enable_write", "12363": "event_entry", "12364": "event_file", "12365": "event_file_data", "12366": "event_file_link", "12367": "event_filter", "12368": "event_filter_match", "12369": "event_filter_read", "12370": "event_filter_write", "12371": "event_flexible", "12372": "event_found", "12373": "event_funcgraph_entry", "12374": "event_funcgraph_exit", "12375": "event_function", "12376": "event_handler", "12377": "event_hash", "12378": "event_hashsize", "12379": "event_id", "12380": "event_id_read", "12381": "event_idx", "12382": "event_init", "12383": "event_len", "12384": "event_length", "12385": "event_limit", "12386": "event_list", "12387": "event_lock", "12388": "event_mapped", "12389": "event_mmiotrace_map", "12390": "event_mmiotrace_rw", "12391": "event_mutex", "12392": "event_no_set_filter_flag", "12393": "event_owner_kernel", "12394": "event_pinned", "12395": "event_probe_data", "12396": "event_remove", "12397": "event_sched_in", "12398": "event_sched_out", "12399": "event_set_filter", "12400": "event_set_filtered_flag", "12401": "event_set_no_set_filter_flag", "12402": "event_source", "12403": "event_status", "12404": "event_subsystem", "12405": "event_subsystem_dir", "12406": "event_subsystems", "12407": "event_test_stuff", "12408": "event_test_thread", "12409": "event_trace_add_tracer", "12410": "event_trace_del_tracer", "12411": "event_trace_enable", "12412": "event_trace_enable_again", "12413": "event_trace_init", "12414": "event_trace_memsetup", "12415": "event_trace_self_test_with_function", "12416": "event_trace_self_tests", "12417": "event_trigger_callback", "12418": "event_trigger_data", "12419": "event_trigger_fops", "12420": "event_trigger_free", "12421": "event_trigger_init", "12422": "event_trigger_open", "12423": "event_trigger_ops", "12424": "event_trigger_print", "12425": "event_trigger_regex_open", "12426": "event_trigger_regex_release", "12427": "event_trigger_regex_write", "12428": "event_trigger_release", "12429": "event_trigger_type", "12430": "event_trigger_unlock_commit", "12431": "event_trigger_unlock_commit_regs", "12432": "event_trigger_write", "12433": "event_triggers_call", "12434": "event_triggers_post_call", "12435": "event_triggers_seq_ops", "12436": "event_type", "12437": "event_type_t", "12438": "event_unmapped", "12439": "event_wakeup", "12440": "events", "12441": "events_check_enabled", "12442": "events_nested", "12443": "every", "12444": "evict_chunk", "12445": "evt", "12446": "evtdev", "12447": "ew", "12448": "ewouldblock", "12449": "ex_vector", "12450": "example", "12451": "exception", "12452": "exception_enter", "12453": "exception_exit", "12454": "exception_level", "12455": "exception_state", "12456": "exception_table_entry", "12457": "exchange", "12458": "excl_bit", "12459": "exclude_callchain_kernel", "12460": "exclude_callchain_user", "12461": "exclusive", "12462": "exclusive_bit", "12463": "exclusive_cnt", "12464": "exclusive_console", "12465": "exclusive_event_destroy", "12466": "exclusive_event_init", "12467": "exclusive_event_installable", "12468": "exclusive_event_match", "12469": "exe", "12470": "exe_fd", "12471": "exe_file", "12472": "exec", "12473": "exec_clock", "12474": "exec_fdpic_loadmap", "12475": "exec_max", "12476": "exec_start", "12477": "exec_vm", "12478": "execdomains_proc_fops", "12479": "execdomains_proc_open", "12480": "execdomains_proc_show", "12481": "executable", "12482": "execute_in_process_context", "12483": "execute_work", "12484": "executed", "12485": "execve", "12486": "existing", "12487": "exists", "12488": "exit", "12489": "exit_aio", "12490": "exit_code", "12491": "exit_creds", "12492": "exit_dead", "12493": "exit_err", "12494": "exit_event", "12495": "exit_files", "12496": "exit_free", "12497": "exit_free_rbtree", "12498": "exit_fs", "12499": "exit_idle", "12500": "exit_io_context", "12501": "exit_itimers", "12502": "exit_latency", "12503": "exit_loop", "12504": "exit_mmap", "12505": "exit_nofree", "12506": "exit_pi_state_list", "12507": "exit_ptrace", "12508": "exit_put", "12509": "exit_rcu", "12510": "exit_robust_list", "12511": "exit_root_id", "12512": "exit_sem", "12513": "exit_shm", "12514": "exit_signal", "12515": "exit_signals", "12516": "exit_state", "12517": "exit_syscall_files", "12518": "exit_task_namespaces", "12519": "exit_zombie", "12520": "exitcode", "12521": "exited", "12522": "exitf", "12523": "exp", "12524": "exp_1", "12525": "exp_15", "12526": "exp_5", "12527": "exp_sync", "12528": "exp_tasks", "12529": "expanded", "12530": "expect", "12531": "expected_type", "12532": "expedited_done", "12533": "expedited_done_exit", "12534": "expedited_done_lost", "12535": "expedited_done_tries", "12536": "expedited_normal", "12537": "expedited_start", "12538": "expedited_stoppedcpus", "12539": "expedited_tryfail", "12540": "expedited_workdone1", "12541": "expedited_workdone2", "12542": "expedited_wrap", "12543": "expediting", "12544": "expire", "12545": "expire_cfs_rq_runtime", "12546": "expire_func", "12547": "expires", "12548": "expires_limit", "12549": "expires_next", "12550": "explicit", "12551": "explored", "12552": "explored_states", "12553": "expmask", "12554": "export_per_cpu_symbol", "12555": "export_per_cpu_symbol_gpl", "12556": "export_symbol", "12557": "export_symbol_gpl", "12558": "export_tracepoint_symbol", "12559": "export_tracepoint_symbol_gpl", "12560": "exported", "12561": "expsize", "12562": "ext", "12563": "ext3", "12564": "extable", "12565": "extent", "12566": "extents", "12567": "extern", "12568": "external", "12569": "extra", "12570": "extra1", "12571": "extra2", "12572": "extra_flags", "12573": "extra_pages", "12574": "extra_size", "12575": "f", "12576": "f_bavail", "12577": "f_blocks", "12578": "f_cred", "12579": "f_diff", "12580": "f_flags", "12581": "f_mapping", "12582": "f_mode", "12583": "f_next", "12584": "f_op", "12585": "f_path", "12586": "f_pos", "12587": "f_printk", "12588": "f_show", "12589": "f_start", "12590": "f_struct", "12591": "f_weight", "12592": "facility", "12593": "fact", "12594": "factor", "12595": "fail", "12596": "fail_address_parse", "12597": "fail_all_buf", "12598": "fail_count", "12599": "fail_data_pages", "12600": "fail_defcmd", "12601": "fail_deprobe", "12602": "fail_deprobe_wake_new", "12603": "fail_free_buffer", "12604": "fail_free_buffers", "12605": "fail_free_cpumask", "12606": "fail_free_freeinit", "12607": "fail_free_reader", "12608": "fail_help", "12609": "fail_mem", "12610": "fail_name", "12611": "fail_nocontext", "12612": "fail_nomem", "12613": "fail_nomem_anon_vma_fork", "12614": "fail_nomem_policy", "12615": "fail_nopgd", "12616": "fail_usage", "12617": "fail_user_page", "12618": "failed", "12619": "failed_css", "12620": "failure", "12621": "fair_policy", "12622": "fair_sched_class", "12623": "fake_sched_class", "12624": "fake_signal_wake_up", "12625": "fake_task", "12626": "fakewriter_tasks", "12627": "fallback", "12628": "fallback_doms", "12629": "fallthrough", "12630": "false", "12631": "family", "12632": "family_registered", "12633": "fast_no_hz", "12634": "fast_read_ctr", "12635": "fasync", "12636": "fasync_helper", "12637": "fatal_signal_pending", "12638": "fault", "12639": "fault_flag_mkwrite", "12640": "fault_flag_write", "12641": "fault_handler", "12642": "fault_types", "12643": "faults", "12644": "faults_cpu", "12645": "fbq_classify_group", "12646": "fbq_classify_rq", "12647": "fbq_type", "12648": "fbuffer", "12649": "fcap", "12650": "fcap_ver", "12651": "fcheck_files", "12652": "fchown16", "12653": "fcount", "12654": "fd", "12655": "fd1", "12656": "fd2", "12657": "fdget", "12658": "fdput", "12659": "fds", "12660": "fe", "12661": "feature", "12662": "feature_bitmap", "12663": "features", "12664": "fentry", "12665": "fetch", "12666": "fetch_", "12667": "fetch_bitfield_string", "12668": "fetch_bitfield_string_size", "12669": "fetch_file_offset_string", "12670": "fetch_file_offset_string_size", "12671": "fetch_file_offset_u16", "12672": "fetch_file_offset_u32", "12673": "fetch_file_offset_u64", "12674": "fetch_file_offset_u8", "12675": "fetch_func_name", "12676": "fetch_func_t", "12677": "fetch_kernel_stack_address", "12678": "fetch_memory_", "12679": "fetch_mtd_", "12680": "fetch_mtd_bitfield", "12681": "fetch_mtd_deref", "12682": "fetch_mtd_end", "12683": "fetch_mtd_file_offset", "12684": "fetch_mtd_memory", "12685": "fetch_mtd_reg", "12686": "fetch_mtd_retval", "12687": "fetch_mtd_stack", "12688": "fetch_mtd_symbol", "12689": "fetch_or", "12690": "fetch_param", "12691": "fetch_reg_string", "12692": "fetch_reg_string_size", "12693": "fetch_retval_string", "12694": "fetch_retval_string_size", "12695": "fetch_robust_entry", "12696": "fetch_size", "12697": "fetch_stack_string", "12698": "fetch_stack_string_size", "12699": "fetch_symbol_string", "12700": "fetch_symbol_string_size", "12701": "fetch_symbol_u16", "12702": "fetch_symbol_u32", "12703": "fetch_symbol_u64", "12704": "fetch_symbol_u8", "12705": "fetch_task_cputime", "12706": "fetch_type", "12707": "fetch_type_string", "12708": "fetch_type_strsize", "12709": "fetch_user_stack_address", "12710": "ffs", "12711": "ffz", "12712": "fget", "12713": "fgraph_cpu_data", "12714": "fgraph_data", "12715": "fi_idx", "12716": "fi_ptr", "12717": "fi_size", "12718": "field", "12719": "field_cachep", "12720": "field_count", "12721": "field_is_signed", "12722": "field_len", "12723": "field_size", "12724": "field_string_func", "12725": "field_string_ip", "12726": "field_string_retip", "12727": "fieldflags", "12728": "fields", "12729": "file", "12730": "file_cachep", "12731": "file_caps_disable", "12732": "file_caps_enabled", "12733": "file_cpu_exclusive", "12734": "file_cpulist", "12735": "file_effective_cpulist", "12736": "file_effective_memlist", "12737": "file_end_write", "12738": "file_inode", "12739": "file_mem_exclusive", "12740": "file_mem_hardwall", "12741": "file_memlist", "12742": "file_memory_migrate", "12743": "file_memory_pressure", "12744": "file_memory_pressure_enabled", "12745": "file_mode", "12746": "file_name", "12747": "file_ns_capable", "12748": "file_offset", "12749": "file_open_name", "12750": "file_open_root", "12751": "file_operations", "12752": "file_sched_load_balance", "12753": "file_sched_relax_domain_level", "12754": "file_size", "12755": "file_spread_page", "12756": "file_spread_slab", "12757": "file_start_write_trylock", "12758": "file_system_type", "12759": "filename", "12760": "files", "12761": "files_cachep", "12762": "files_stat", "12763": "files_struct", "12764": "filesystems", "12765": "fill_ac", "12766": "fill_rwbs", "12767": "fill_stats", "12768": "fill_stats_for_pid", "12769": "fill_stats_for_tgid", "12770": "fill_tgid_exit", "12771": "filp", "12772": "filp1", "12773": "filp2", "12774": "filp_close", "12775": "filt_err_bad_subsys_filter", "12776": "filt_err_field_not_found", "12777": "filt_err_illegal_field_op", "12778": "filt_err_illegal_intval", "12779": "filt_err_illegal_not_op", "12780": "filt_err_invalid_filter", "12781": "filt_err_invalid_op", "12782": "filt_err_ip_field_only", "12783": "filt_err_missing_field", "12784": "filt_err_none", "12785": "filt_err_operand_too_long", "12786": "filt_err_too_many_operands", "12787": "filt_err_too_many_preds", "12788": "filt_err_unbalanced_paren", "12789": "filter", "12790": "filter_add_pred", "12791": "filter_assign_type", "12792": "filter_build_regex", "12793": "filter_chain", "12794": "filter_check_discard", "12795": "filter_disable", "12796": "filter_dyn_string", "12797": "filter_free_subsystem_filters", "12798": "filter_free_subsystem_preds", "12799": "filter_func_t", "12800": "filter_hash", "12801": "filter_item", "12802": "filter_list", "12803": "filter_match_preds", "12804": "filter_match_preds_cb", "12805": "filter_match_preds_data", "12806": "filter_op", "12807": "filter_op_ids", "12808": "filter_ops", "12809": "filter_opstack_clear", "12810": "filter_opstack_empty", "12811": "filter_opstack_pop", "12812": "filter_opstack_push", "12813": "filter_opstack_top", "12814": "filter_other", "12815": "filter_parse", "12816": "filter_parse_regex", "12817": "filter_parse_state", "12818": "filter_pred", "12819": "filter_pred_", "12820": "filter_pred_16", "12821": "filter_pred_32", "12822": "filter_pred_64", "12823": "filter_pred_8", "12824": "filter_pred_fn_t", "12825": "filter_pred_fold", "12826": "filter_pred_invalid", "12827": "filter_pred_is_right", "12828": "filter_pred_none", "12829": "filter_pred_pchar", "12830": "filter_pred_s16", "12831": "filter_pred_s32", "12832": "filter_pred_s64", "12833": "filter_pred_s8", "12834": "filter_pred_string", "12835": "filter_pred_strloc", "12836": "filter_pred_u16", "12837": "filter_pred_u32", "12838": "filter_pred_u64", "12839": "filter_pred_u8", "12840": "filter_pred_walkcb_t", "12841": "filter_ptr_string", "12842": "filter_ret", "12843": "filter_set_pred", "12844": "filter_static_string", "12845": "filter_str", "12846": "filter_string", "12847": "filter_trace_fn", "12848": "filter_type", "12849": "filtered", "12850": "filtering", "12851": "filterkey", "12852": "filterp", "12853": "filters", "12854": "final_count", "12855": "final_note", "12856": "find_active_uprobe", "12857": "find_and_alloc_map", "12858": "find_busiest_group", "12859": "find_busiest_queue", "12860": "find_chunk", "12861": "find_css_set", "12862": "find_event_file", "12863": "find_event_file_link", "12864": "find_existing_css_set", "12865": "find_fetch_type", "12866": "find_first_bit", "12867": "find_first_elem", "12868": "find_first_zero_bit", "12869": "find_ge_pid", "12870": "find_get_context", "12871": "find_get_pid", "12872": "find_idlest_cpu", "12873": "find_idlest_group", "12874": "find_lively_task_by_vpid", "12875": "find_lock_lowest_rq", "12876": "find_lowest_rq", "12877": "find_matching_se", "12878": "find_module", "12879": "find_module_all", "12880": "find_module_sections", "12881": "find_new_ilb", "12882": "find_next", "12883": "find_next_bit", "12884": "find_next_iomem_res", "12885": "find_next_mod_format", "12886": "find_next_offset", "12887": "find_next_push_cpu", "12888": "find_next_zero_bit", "12889": "find_node_in_range", "12890": "find_numa_distance", "12891": "find_pcpusec", "12892": "find_pid_ns", "12893": "find_pm_qos_object_by_minor", "12894": "find_probe_event", "12895": "find_process_by_pid", "12896": "find_prog_type", "12897": "find_regset", "12898": "find_resource", "12899": "find_sec", "12900": "find_symbol", "12901": "find_symbol_arg", "12902": "find_symbol_in_section", "12903": "find_syscall_meta", "12904": "find_task_by_pid_ns", "12905": "find_task_by_vpid", "12906": "find_trace_kprobe", "12907": "find_trace_probe_file", "12908": "find_uprobe", "12909": "find_usage_backwards", "12910": "find_usage_forwards", "12911": "find_user", "12912": "find_vma", "12913": "find_vpid", "12914": "find_worker_executing_work", "12915": "finish", "12916": "finish_arch_post_lock_switch", "12917": "finish_arch_switch", "12918": "finish_lock_switch", "12919": "finish_task_switch", "12920": "finish_wait", "12921": "finished", "12922": "finished_loading", "12923": "finishing", "12924": "finit_module", "12925": "fire_sched_in_preempt_notifiers", "12926": "fire_sched_out_preempt_notifiers", "12927": "first", "12928": "first_colon", "12929": "first_cpu", "12930": "first_filter", "12931": "first_flusher", "12932": "first_free_id", "12933": "first_idle_worker", "12934": "first_irq", "12935": "first_level_children_only", "12936": "first_node", "12937": "first_notrace", "12938": "first_online_node", "12939": "first_page", "12940": "first_sector", "12941": "first_space", "12942": "first_trees", "12943": "first_uprobe", "12944": "firstc", "12945": "firsterr", "12946": "firstnonnull", "12947": "firstreport", "12948": "firstsnap", "12949": "firsttime", "12950": "fix", "12951": "fix_small_imbalance", "12952": "fixed_1", "12953": "fixed_power_int", "12954": "fixed_regs", "12955": "fixing", "12956": "fixup_activate", "12957": "fixup_assert_init", "12958": "fixup_bpf_calls", "12959": "fixup_free", "12960": "fixup_init", "12961": "fixup_owner", "12962": "fk", "12963": "fl_mask", "12964": "flag", "12965": "flag_array", "12966": "flag_changed", "12967": "flags", "12968": "flags_fill_end", "12969": "flags_fill_full", "12970": "flags_fill_start", "12971": "flags_p", "12972": "flavor_mask", "12973": "flavors", "12974": "flen", "12975": "flexible_groups", "12976": "flim", "12977": "floor", "12978": "fls64", "12979": "flush", "12980": "flush_cache_dup_mm", "12981": "flush_cache_page", "12982": "flush_cache_range", "12983": "flush_cnt", "12984": "flush_color", "12985": "flush_dcache_mmap_lock", "12986": "flush_dcache_mmap_unlock", "12987": "flush_dcache_page", "12988": "flush_delayed_work", "12989": "flush_hold_queue", "12990": "flush_icache_range", "12991": "flush_insn_slot", "12992": "flush_itimer_signals", "12993": "flush_kthread_work", "12994": "flush_kthread_worker", "12995": "flush_module_icache", "12996": "flush_scheduled_work", "12997": "flush_signal_handlers", "12998": "flush_signals", "12999": "flush_sigqueue", "13000": "flush_sigqueue_mask", "13001": "flush_smp_call_function_queue", "13002": "flush_swap_writer", "13003": "flush_tlb_mm", "13004": "flush_work", "13005": "flush_workqueue", "13006": "flush_workqueue_prep_pwqs", "13007": "flusher_overflow", "13008": "flusher_queue", "13009": "fm_coef", "13010": "fm_maxcnt", "13011": "fm_maxticks", "13012": "fm_scale", "13013": "fmeter", "13014": "fmeter_getrate", "13015": "fmeter_init", "13016": "fmeter_markevent", "13017": "fmeter_update", "13018": "fmode_can_write", "13019": "fmode_read", "13020": "fmode_t", "13021": "fmode_write", "13022": "fmp", "13023": "fmt", "13024": "fmt_cnt", "13025": "fmt_size", "13026": "fmtchar", "13027": "fmtstr", "13028": "fmttype", "13029": "fn", "13030": "fold_pred", "13031": "fold_pred_cb", "13032": "fold_pred_data", "13033": "fold_pred_tree", "13034": "fold_pred_tree_cb", "13035": "foo", "13036": "fops", "13037": "for", "13038": "for_each_active_irq", "13039": "for_each_buffer_cpu", "13040": "for_each_class", "13041": "for_each_cpu", "13042": "for_each_cpu_and", "13043": "for_each_cpu_worker_pool", "13044": "for_each_css", "13045": "for_each_domain", "13046": "for_each_e_css", "13047": "for_each_event", "13048": "for_each_irq_desc", "13049": "for_each_irq_desc_reverse", "13050": "for_each_kdbcmd", "13051": "for_each_kimage_entry", "13052": "for_each_leaf_cfs_rq", "13053": "for_each_lower_domain", "13054": "for_each_msi_entry", "13055": "for_each_node", "13056": "for_each_node_mask", "13057": "for_each_online_cpu", "13058": "for_each_online_node", "13059": "for_each_pool", "13060": "for_each_pool_worker", "13061": "for_each_populated_zone", "13062": "for_each_possible_cpu", "13063": "for_each_present_cpu", "13064": "for_each_process", "13065": "for_each_process_thread", "13066": "for_each_pwq", "13067": "for_each_rcu_flavor", "13068": "for_each_root", "13069": "for_each_rt_rq", "13070": "for_each_sched_entity", "13071": "for_each_sched_rt_entity", "13072": "for_each_sd_topology", "13073": "for_each_set_bit", "13074": "for_each_subsys", "13075": "for_each_task_context_nr", "13076": "for_each_thread", "13077": "for_each_tracing_cpu", "13078": "for_ptracer", "13079": "forbidden_pages_map", "13080": "force", "13081": "force_balance", "13082": "force_default", "13083": "force_irqthreads", "13084": "force_qs_rnp", "13085": "force_quiescent_state", "13086": "force_resume_depth", "13087": "force_sd_overlap", "13088": "force_sig", "13089": "force_sig_info", "13090": "force_sigsegv", "13091": "force_successful_syscall_return", "13092": "force_unoptimize_kprobe", "13093": "force_up", "13094": "force_update", "13095": "forced", "13096": "fork", "13097": "fork_idle", "13098": "fork_init", "13099": "fork_out", "13100": "forkexec_idx", "13101": "format", "13102": "format_field_seperator", "13103": "format_header", "13104": "format_mod_start", "13105": "format_mod_stop", "13106": "format_printfmt", "13107": "forward", "13108": "forwards", "13109": "found", "13110": "found_child", "13111": "found_it", "13112": "found_parent", "13113": "four", "13114": "fp", "13115": "fp_old", "13116": "fp_size", "13117": "fpid", "13118": "fpid_next", "13119": "fpid_show", "13120": "fpid_start", "13121": "fpid_stop", "13122": "fprm", "13123": "fprog", "13124": "fprog32", "13125": "fput", "13126": "fqs", "13127": "fqs_burst_remaining", "13128": "fqs_duration", "13129": "fqs_holdoff", "13130": "fqs_resume_time", "13131": "fqs_state", "13132": "fqs_state_in", "13133": "fqs_stutter", "13134": "fqs_task", "13135": "fqslock", "13136": "frac", "13137": "frac_bits", "13138": "frame_pointer", "13139": "frame_ptr", "13140": "free", "13141": "free_aggr_kprobe", "13142": "free_all_swap_pages", "13143": "free_arch_cleanup", "13144": "free_area", "13145": "free_argv", "13146": "free_aux", "13147": "free_basic_memory_bitmaps", "13148": "free_bitfield_fetch_param", "13149": "free_bitmap", "13150": "free_bitmaps", "13151": "free_bt", "13152": "free_buffer", "13153": "free_buffer_page", "13154": "free_cgrp_cset_links", "13155": "free_chunk", "13156": "free_copy", "13157": "free_cpumask", "13158": "free_cpumask_var", "13159": "free_cpus", "13160": "free_cs", "13161": "free_deref_fetch_param", "13162": "free_desc", "13163": "free_dlo_mask", "13164": "free_dma", "13165": "free_env", "13166": "free_event", "13167": "free_event_filter", "13168": "free_event_rcu", "13169": "free_fair_sched_group", "13170": "free_filter", "13171": "free_filter_prog", "13172": "free_first_bitmap", "13173": "free_first_object", "13174": "free_fs_struct", "13175": "free_ftrace_hash", "13176": "free_ftrace_hash_rcu", "13177": "free_hash", "13178": "free_hash_entry", "13179": "free_highmem", "13180": "free_highmem_data", "13181": "free_htab", "13182": "free_image_page", "13183": "free_info", "13184": "free_insn_page", "13185": "free_instances", "13186": "free_irq", "13187": "free_key", "13188": "free_kmem_pages", "13189": "free_list", "13190": "free_list_of_pages", "13191": "free_log_buf", "13192": "free_map_info", "13193": "free_masks", "13194": "free_mem_extents", "13195": "free_mm", "13196": "free_modinfo", "13197": "free_modinfo_", "13198": "free_modprobe_argv", "13199": "free_module", "13200": "free_module_name", "13201": "free_module_param_attrs", "13202": "free_next_key", "13203": "free_notes_attrs", "13204": "free_nsproxy", "13205": "free_online", "13206": "free_out", "13207": "free_page", "13208": "free_pages", "13209": "free_pages_map", "13210": "free_percpu", "13211": "free_percpu_irq", "13212": "free_pid", "13213": "free_pid_ns", "13214": "free_pidmap", "13215": "free_prog", "13216": "free_pt", "13217": "free_resource", "13218": "free_rootdomain", "13219": "free_rp_inst", "13220": "free_rt_sched_group", "13221": "free_rto_mask", "13222": "free_sched_domain", "13223": "free_sched_group", "13224": "free_sched_group_rcu", "13225": "free_sched_groups", "13226": "free_second_object", "13227": "free_sect_attrs", "13228": "free_sgc", "13229": "free_signal_struct", "13230": "free_snapshot", "13231": "free_span", "13232": "free_states", "13233": "free_symbol_cache", "13234": "free_syscall_print_fmt", "13235": "free_task", "13236": "free_task_struct", "13237": "free_thread_info", "13238": "free_ti", "13239": "free_trace_kprobe", "13240": "free_trace_uprobe", "13241": "free_tree_refs", "13242": "free_trial_cpuset", "13243": "free_tsk", "13244": "free_uid", "13245": "free_unbound_pwq", "13246": "free_unload", "13247": "free_used_maps", "13248": "free_user", "13249": "free_user_ns", "13250": "free_uts_ns", "13251": "free_value", "13252": "free_workqueue_attrs", "13253": "free_zone_bm_rtree", "13254": "freed", "13255": "freehigh", "13256": "freeing_list", "13257": "freeinit", "13258": "freeme", "13259": "freepages_count", "13260": "freepages_delay", "13261": "freepages_delay_total", "13262": "freepages_start", "13263": "freeram", "13264": "frees", "13265": "freeswap", "13266": "freezable", "13267": "freezable_schedule", "13268": "freezable_schedule_timeout_interruptible", "13269": "freeze", "13270": "freeze_cgroup", "13271": "freeze_kernel_threads", "13272": "freeze_processes", "13273": "freeze_task", "13274": "freeze_timeout_msecs", "13275": "freeze_workqueues_begin", "13276": "freeze_workqueues_busy", "13277": "freezer", "13278": "freezer_apply_state", "13279": "freezer_attach", "13280": "freezer_cgrp_id", "13281": "freezer_cgrp_subsys", "13282": "freezer_change_state", "13283": "freezer_count", "13284": "freezer_css_alloc", "13285": "freezer_css_free", "13286": "freezer_css_offline", "13287": "freezer_css_online", "13288": "freezer_delta", "13289": "freezer_delta_lock", "13290": "freezer_do_not_count", "13291": "freezer_fork", "13292": "freezer_lock", "13293": "freezer_mutex", "13294": "freezer_parent_freezing_read", "13295": "freezer_read", "13296": "freezer_self_freezing_read", "13297": "freezer_should_skip", "13298": "freezer_state_flags", "13299": "freezer_state_strs", "13300": "freezer_test_done", "13301": "freezer_write", "13302": "freezing", "13303": "freezing_slow_path", "13304": "freq", "13305": "freq_count_stamp", "13306": "freq_norm", "13307": "frequency", "13308": "frequency_fls", "13309": "fried_cmppid", "13310": "from", "13311": "from_ancestor_ns", "13312": "from_cgrp", "13313": "from_kgid", "13314": "from_kgid_munged", "13315": "from_kprojid", "13316": "from_kprojid_munged", "13317": "from_kuid", "13318": "from_kuid_munged", "13319": "front", "13320": "frozen", "13321": "frozen_cpus", "13322": "fs", "13323": "fs_aio_max_nr", "13324": "fs_aio_nr", "13325": "fs_cachep", "13326": "fs_create", "13327": "fs_delete", "13328": "fs_delete_self", "13329": "fs_dentry", "13330": "fs_dir_notify", "13331": "fs_dq_allocated", "13332": "fs_dq_cache_hits", "13333": "fs_dq_drops", "13334": "fs_dq_free", "13335": "fs_dq_lookups", "13336": "fs_dq_reads", "13337": "fs_dq_syncs", "13338": "fs_dq_warnings", "13339": "fs_dq_writes", "13340": "fs_dqstats", "13341": "fs_event_on_child", "13342": "fs_in_ignored", "13343": "fs_initcall", "13344": "fs_inotify", "13345": "fs_kobj", "13346": "fs_lease_time", "13347": "fs_leases", "13348": "fs_maxfile", "13349": "fs_move", "13350": "fs_move_self", "13351": "fs_moved_from", "13352": "fs_moved_to", "13353": "fs_nrinode", "13354": "fs_ocfs2", "13355": "fs_overflowgid", "13356": "fs_overflowuid", "13357": "fs_pin", "13358": "fs_statinode", "13359": "fs_struct", "13360": "fs_table", "13361": "fs_type", "13362": "fs_unmount", "13363": "fs_xfs", "13364": "fsa", "13365": "fsgid", "13366": "fshift", "13367": "fsnotify_add_mark", "13368": "fsnotify_alloc_group", "13369": "fsnotify_destroy_mark", "13370": "fsnotify_duplicate_mark", "13371": "fsnotify_event_inode", "13372": "fsnotify_event_path", "13373": "fsnotify_find_inode_mark", "13374": "fsnotify_get_mark", "13375": "fsnotify_group", "13376": "fsnotify_init_mark", "13377": "fsnotify_mark", "13378": "fsnotify_ops", "13379": "fsnotify_put_mark", "13380": "fsuid", "13381": "ftbl", "13382": "ftest", "13383": "ftrace", "13384": "ftrace_add_profile", "13385": "ftrace_addr", "13386": "ftrace_allocate_pages", "13387": "ftrace_allocate_records", "13388": "ftrace_arch_code_modify_post_process", "13389": "ftrace_arch_code_modify_prepare", "13390": "ftrace_avail_fops", "13391": "ftrace_branch_data", "13392": "ftrace_buff_max", "13393": "ftrace_bug", "13394": "ftrace_callsites", "13395": "ftrace_check_record", "13396": "ftrace_clear_events", "13397": "ftrace_cmp_recs", "13398": "ftrace_cmp_type", "13399": "ftrace_code_disable", "13400": "ftrace_common_fields", "13401": "ftrace_control_list", "13402": "ftrace_cpu_disabled", "13403": "ftrace_cpudump_print", "13404": "ftrace_cpudump_probe", "13405": "ftrace_create_filter_files", "13406": "ftrace_create_function_files", "13407": "ftrace_ctx_fields", "13408": "ftrace_define_fields_", "13409": "ftrace_destroy_filter_files", "13410": "ftrace_destroy_function_files", "13411": "ftrace_disable_calls", "13412": "ftrace_disable_ftrace_graph_caller", "13413": "ftrace_disabled", "13414": "ftrace_dump", "13415": "ftrace_dump_buf", "13416": "ftrace_dump_mode", "13417": "ftrace_dump_on_oops", "13418": "ftrace_dump_print", "13419": "ftrace_dump_probe", "13420": "ftrace_enable_fops", "13421": "ftrace_enable_ftrace_graph_caller", "13422": "ftrace_enable_sysctl", "13423": "ftrace_enabled", "13424": "ftrace_entry", "13425": "ftrace_entry_dup", "13426": "ftrace_entry_reg", "13427": "ftrace_event_avail_open", "13428": "ftrace_event_buffer", "13429": "ftrace_event_buffer_commit", "13430": "ftrace_event_buffer_reserve", "13431": "ftrace_event_call", "13432": "ftrace_event_class", "13433": "ftrace_event_enable_disable", "13434": "ftrace_event_field", "13435": "ftrace_event_file", "13436": "ftrace_event_filter_fops", "13437": "ftrace_event_fl_enabled", "13438": "ftrace_event_fl_enabled_bit", "13439": "ftrace_event_fl_filtered", "13440": "ftrace_event_fl_no_set_filter", "13441": "ftrace_event_fl_recorded_cmd", "13442": "ftrace_event_fl_recorded_cmd_bit", "13443": "ftrace_event_fl_soft_disabled", "13444": "ftrace_event_fl_soft_disabled_bit", "13445": "ftrace_event_fl_soft_mode", "13446": "ftrace_event_fl_soft_mode_bit", "13447": "ftrace_event_fl_trigger_cond_bit", "13448": "ftrace_event_fl_trigger_mode_bit", "13449": "ftrace_event_format_fops", "13450": "ftrace_event_id_fops", "13451": "ftrace_event_is_function", "13452": "ftrace_event_list", "13453": "ftrace_event_name", "13454": "ftrace_event_open", "13455": "ftrace_event_reg", "13456": "ftrace_event_release", "13457": "ftrace_event_set_open", "13458": "ftrace_event_write", "13459": "ftrace_events", "13460": "ftrace_file", "13461": "ftrace_filter", "13462": "ftrace_filter_param", "13463": "ftrace_filter_write", "13464": "ftrace_find_event", "13465": "ftrace_find_profiled_func", "13466": "ftrace_find_tramp_ops_any", "13467": "ftrace_find_tramp_ops_curr", "13468": "ftrace_find_tramp_ops_new", "13469": "ftrace_fl_enabled", "13470": "ftrace_fl_ipmodify", "13471": "ftrace_fl_regs", "13472": "ftrace_fl_regs_en", "13473": "ftrace_fl_tramp", "13474": "ftrace_fl_tramp_en", "13475": "ftrace_force_list_func", "13476": "ftrace_free_filter", "13477": "ftrace_func_command", "13478": "ftrace_func_entry", "13479": "ftrace_func_hash", "13480": "ftrace_func_hashsize", "13481": "ftrace_func_probe", "13482": "ftrace_func_t", "13483": "ftrace_function_check_pred", "13484": "ftrace_function_filter_re", "13485": "ftrace_function_local_disable", "13486": "ftrace_function_local_disabled", "13487": "ftrace_function_local_enable", "13488": "ftrace_function_set_filter", "13489": "ftrace_function_set_filter_cb", "13490": "ftrace_function_set_regexp", "13491": "ftrace_get_addr_curr", "13492": "ftrace_get_addr_new", "13493": "ftrace_graph_active", "13494": "ftrace_graph_addr", "13495": "ftrace_graph_ent", "13496": "ftrace_graph_ent_entry", "13497": "ftrace_graph_entry", "13498": "ftrace_graph_entry_stub", "13499": "ftrace_graph_entry_test", "13500": "ftrace_graph_exit_task", "13501": "ftrace_graph_filter", "13502": "ftrace_graph_ignore_irqs", "13503": "ftrace_graph_init_idle_task", "13504": "ftrace_graph_init_task", "13505": "ftrace_graph_is_dead", "13506": "ftrace_graph_notrace", "13507": "ftrace_graph_notrace_addr", "13508": "ftrace_graph_probe_sched_switch", "13509": "ftrace_graph_ret", "13510": "ftrace_graph_ret_entry", "13511": "ftrace_graph_return", "13512": "ftrace_graph_skip_irqs", "13513": "ftrace_graph_stop", "13514": "ftrace_graph_tramp_addr", "13515": "ftrace_hash", "13516": "ftrace_hash_bits", "13517": "ftrace_hash_clear", "13518": "ftrace_hash_empty", "13519": "ftrace_hash_ipmodify_disable", "13520": "ftrace_hash_ipmodify_enable", "13521": "ftrace_hash_ipmodify_update", "13522": "ftrace_hash_max_bits", "13523": "ftrace_hash_move", "13524": "ftrace_hash_rec_disable", "13525": "ftrace_hash_rec_disable_modify", "13526": "ftrace_hash_rec_enable", "13527": "ftrace_hash_rec_enable_modify", "13528": "ftrace_hash_rec_update_modify", "13529": "ftrace_init_array_ops", "13530": "ftrace_init_dyn_tracefs", "13531": "ftrace_init_global_array_ops", "13532": "ftrace_init_tracefs", "13533": "ftrace_is_dead", "13534": "ftrace_iter_do_hash", "13535": "ftrace_iter_enabled", "13536": "ftrace_iter_filter", "13537": "ftrace_iter_hash", "13538": "ftrace_iter_notrace", "13539": "ftrace_iter_printall", "13540": "ftrace_iterator", "13541": "ftrace_kill", "13542": "ftrace_likely_update", "13543": "ftrace_list_end", "13544": "ftrace_location", "13545": "ftrace_location_range", "13546": "ftrace_lock", "13547": "ftrace_lookup_ip", "13548": "ftrace_make_call", "13549": "ftrace_make_nop", "13550": "ftrace_max_event", "13551": "ftrace_modify_all_code", "13552": "ftrace_modify_call", "13553": "ftrace_module_file_ops", "13554": "ftrace_module_init", "13555": "ftrace_nodyn_init", "13556": "ftrace_notrace", "13557": "ftrace_notrace_depth", "13558": "ftrace_now", "13559": "ftrace_nr_registered_ops", "13560": "ftrace_old_addr", "13561": "ftrace_ops", "13562": "ftrace_ops_control_func", "13563": "ftrace_ops_fl_adding", "13564": "ftrace_ops_fl_alloc_tramp", "13565": "ftrace_ops_fl_control", "13566": "ftrace_ops_fl_deleted", "13567": "ftrace_ops_fl_dynamic", "13568": "ftrace_ops_fl_enabled", "13569": "ftrace_ops_fl_initialized", "13570": "ftrace_ops_fl_ipmodify", "13571": "ftrace_ops_fl_modifying", "13572": "ftrace_ops_fl_recursion_safe", "13573": "ftrace_ops_fl_removing", "13574": "ftrace_ops_fl_save_regs", "13575": "ftrace_ops_fl_save_regs_if_supported", "13576": "ftrace_ops_fl_stub", "13577": "ftrace_ops_get_func", "13578": "ftrace_ops_get_list_func", "13579": "ftrace_ops_hash", "13580": "ftrace_ops_init", "13581": "ftrace_ops_list", "13582": "ftrace_ops_list_func", "13583": "ftrace_ops_no_ops", "13584": "ftrace_ops_recurs_func", "13585": "ftrace_ops_test", "13586": "ftrace_output_call", "13587": "ftrace_output_raw", "13588": "ftrace_page", "13589": "ftrace_pages", "13590": "ftrace_pages_start", "13591": "ftrace_pid", "13592": "ftrace_pid_add", "13593": "ftrace_pid_fops", "13594": "ftrace_pid_func", "13595": "ftrace_pid_function", "13596": "ftrace_pid_open", "13597": "ftrace_pid_release", "13598": "ftrace_pid_reset", "13599": "ftrace_pid_sops", "13600": "ftrace_pid_write", "13601": "ftrace_pids", "13602": "ftrace_pop_return_trace", "13603": "ftrace_print_bitmask_seq", "13604": "ftrace_print_flags_seq", "13605": "ftrace_print_hex_seq", "13606": "ftrace_print_symbols_seq", "13607": "ftrace_print_symbols_seq_u64", "13608": "ftrace_probe_ops", "13609": "ftrace_probe_print", "13610": "ftrace_profile", "13611": "ftrace_profile_alloc", "13612": "ftrace_profile_enabled", "13613": "ftrace_profile_fops", "13614": "ftrace_profile_free_filter", "13615": "ftrace_profile_hash_bits", "13616": "ftrace_profile_hash_size", "13617": "ftrace_profile_init", "13618": "ftrace_profile_init_cpu", "13619": "ftrace_profile_lock", "13620": "ftrace_profile_ops", "13621": "ftrace_profile_page", "13622": "ftrace_profile_pages_init", "13623": "ftrace_profile_reset", "13624": "ftrace_profile_set_filter", "13625": "ftrace_profile_stat", "13626": "ftrace_profile_stats", "13627": "ftrace_profile_tracefs", "13628": "ftrace_profile_write", "13629": "ftrace_raw_ftrace_test_filter", "13630": "ftrace_raw_output_prep", "13631": "ftrace_rec_count", "13632": "ftrace_rec_iter", "13633": "ftrace_rec_iter_next", "13634": "ftrace_rec_iter_record", "13635": "ftrace_rec_iter_start", "13636": "ftrace_ref_max", "13637": "ftrace_regex_open", "13638": "ftrace_regex_release", "13639": "ftrace_regs_addr", "13640": "ftrace_replace_code", "13641": "ftrace_reset_array_ops", "13642": "ftrace_ret_stack", "13643": "ftrace_retfunc_depth", "13644": "ftrace_retstack_alloc_size", "13645": "ftrace_return_to_handler", "13646": "ftrace_run_modify_code", "13647": "ftrace_run_stop_machine", "13648": "ftrace_run_update_code", "13649": "ftrace_set_clr_event", "13650": "ftrace_set_early_filter", "13651": "ftrace_set_event_fops", "13652": "ftrace_set_filter", "13653": "ftrace_set_filter_ip", "13654": "ftrace_set_global_filter", "13655": "ftrace_set_notrace", "13656": "ftrace_show_header_fops", "13657": "ftrace_shutdown", "13658": "ftrace_shutdown_sysctl", "13659": "ftrace_stack_entries", "13660": "ftrace_stacktrace", "13661": "ftrace_stacktrace_count", "13662": "ftrace_stacktrace_print", "13663": "ftrace_start_func_ret", "13664": "ftrace_start_up", "13665": "ftrace_startup", "13666": "ftrace_startup_all", "13667": "ftrace_startup_enable", "13668": "ftrace_startup_sysctl", "13669": "ftrace_stop_func_ret", "13670": "ftrace_stub", "13671": "ftrace_subsystem_dir", "13672": "ftrace_subsystem_filter_fops", "13673": "ftrace_suspend_notifier", "13674": "ftrace_suspend_notifier_call", "13675": "ftrace_swapper_pid", "13676": "ftrace_sync", "13677": "ftrace_sync_ipi", "13678": "ftrace_syscall_enter", "13679": "ftrace_syscall_exit", "13680": "ftrace_system_enable_fops", "13681": "ftrace_test_event_disable", "13682": "ftrace_test_event_filter", "13683": "ftrace_test_filter", "13684": "ftrace_test_record", "13685": "ftrace_text_reserved", "13686": "ftrace_timestamp", "13687": "ftrace_tr_enable_fops", "13688": "ftrace_trace_arrays", "13689": "ftrace_trace_function", "13690": "ftrace_trace_probe_callback", "13691": "ftrace_trace_stack", "13692": "ftrace_trace_stack_regs", "13693": "ftrace_trace_task", "13694": "ftrace_trace_userstack", "13695": "ftrace_traceoff", "13696": "ftrace_traceoff_count", "13697": "ftrace_traceoff_print", "13698": "ftrace_traceon", "13699": "ftrace_traceon_count", "13700": "ftrace_traceon_print", "13701": "ftrace_trigger_soft_disabled", "13702": "ftrace_update_calls", "13703": "ftrace_update_code", "13704": "ftrace_update_ftrace_func", "13705": "ftrace_update_ignore", "13706": "ftrace_update_make_call", "13707": "ftrace_update_make_nop", "13708": "ftrace_update_modify_call", "13709": "ftrace_update_pid_func", "13710": "ftrace_update_record", "13711": "ftrace_update_time", "13712": "ftrace_update_tot_cnt", "13713": "ftrace_update_trace_func", "13714": "ftrace_update_trampoline", "13715": "ftrace_warn_on", "13716": "ftrace_warn_on_once", "13717": "ftype", "13718": "fua", "13719": "full", "13720": "full_sysidle_state", "13721": "full_waiters", "13722": "full_waiters_pending", "13723": "fullstop", "13724": "fullstop_dontstop", "13725": "fullstop_mutex", "13726": "fullstop_rmmod", "13727": "fullstop_shutdown", "13728": "func", "13729": "func1_name", "13730": "func2_name", "13731": "func_begin", "13732": "func_end", "13733": "func_flags", "13734": "func_full_name", "13735": "func_graph_set_flag", "13736": "func_hash", "13737": "func_id", "13738": "func_match", "13739": "func_middle", "13740": "func_name", "13741": "func_opts", "13742": "func_pos", "13743": "func_prolog_dec", "13744": "func_prolog_preempt_disable", "13745": "func_ptr_is_kernel_text", "13746": "func_set_flag", "13747": "func_stack", "13748": "func_stack_trace", "13749": "funcgraph", "13750": "funcgraph_entry", "13751": "funcgraph_exit", "13752": "funcs", "13753": "function", "13754": "function_enabled", "13755": "function_filter_data", "13756": "function_graph", "13757": "function_name", "13758": "function_profile_call", "13759": "function_stack_trace_call", "13760": "function_stat_cmp", "13761": "function_stat_headers", "13762": "function_stat_next", "13763": "function_stat_show", "13764": "function_stat_start", "13765": "function_stats", "13766": "function_test_events_call", "13767": "function_trace", "13768": "function_trace_call", "13769": "function_trace_init", "13770": "function_trace_op", "13771": "function_trace_reset", "13772": "function_trace_start", "13773": "functions", "13774": "futex", "13775": "futex_cmd_mask", "13776": "futex_cmp_requeue", "13777": "futex_cmp_requeue_pi", "13778": "futex_cmpxchg_enabled", "13779": "futex_hashsize", "13780": "futex_lock_pi", "13781": "futex_offset", "13782": "futex_queues", "13783": "futex_requeue", "13784": "futex_tid_mask", "13785": "futex_uaddr", "13786": "futex_wait", "13787": "futex_wait_bitset", "13788": "futex_wait_requeue_pi", "13789": "futex_wake", "13790": "futex_wake_op", "13791": "fwork", "13792": "g", "13793": "gattr", "13794": "gc", "13795": "gc_flags", "13796": "gc_list", "13797": "gc_lock", "13798": "gcflags", "13799": "gcov_action", "13800": "gcov_add", "13801": "gcov_counters", "13802": "gcov_ctr_info", "13803": "gcov_data_fops", "13804": "gcov_data_magic", "13805": "gcov_enable_events", "13806": "gcov_event", "13807": "gcov_events_enabled", "13808": "gcov_fn_info", "13809": "gcov_fs_init", "13810": "gcov_h", "13811": "gcov_info", "13812": "gcov_info_add", "13813": "gcov_info_dup", "13814": "gcov_info_filename", "13815": "gcov_info_free", "13816": "gcov_info_head", "13817": "gcov_info_is_compatible", "13818": "gcov_info_link", "13819": "gcov_info_next", "13820": "gcov_info_reset", "13821": "gcov_info_unlink", "13822": "gcov_info_version", "13823": "gcov_init", "13824": "gcov_iter_free", "13825": "gcov_iter_get_info", "13826": "gcov_iter_new", "13827": "gcov_iter_next", "13828": "gcov_iter_start", "13829": "gcov_iter_write", "13830": "gcov_iterator", "13831": "gcov_link", "13832": "gcov_lock", "13833": "gcov_module_notifier", "13834": "gcov_nb", "13835": "gcov_node", "13836": "gcov_persist", "13837": "gcov_persist_setup", "13838": "gcov_remove", "13839": "gcov_reset_fops", "13840": "gcov_seq_next", "13841": "gcov_seq_open", "13842": "gcov_seq_ops", "13843": "gcov_seq_release", "13844": "gcov_seq_show", "13845": "gcov_seq_start", "13846": "gcov_seq_stop", "13847": "gcov_seq_write", "13848": "gcov_tag_counter_base", "13849": "gcov_tag_for_counter", "13850": "gcov_tag_function", "13851": "gcov_tag_function_length", "13852": "gcov_type", "13853": "gcov_version", "13854": "gdb_bpt_instr", "13855": "gdb_cmd_binwrite", "13856": "gdb_cmd_break", "13857": "gdb_cmd_detachkill", "13858": "gdb_cmd_exception_pass", "13859": "gdb_cmd_getregs", "13860": "gdb_cmd_memread", "13861": "gdb_cmd_memwrite", "13862": "gdb_cmd_query", "13863": "gdb_cmd_reboot", "13864": "gdb_cmd_reg_get", "13865": "gdb_cmd_reg_set", "13866": "gdb_cmd_setregs", "13867": "gdb_cmd_status", "13868": "gdb_cmd_task", "13869": "gdb_cmd_thread", "13870": "gdb_get_regs_helper", "13871": "gdb_hex_reg_helper", "13872": "gdb_regs", "13873": "gdb_regs_to_pt_regs", "13874": "gdb_serial_stub", "13875": "gdbmsgbuf", "13876": "gdbstub_exit", "13877": "gdbstub_msg_write", "13878": "gdbstub_prev_in_buf_pos", "13879": "gdbstub_read_wait", "13880": "gdbstub_state", "13881": "gdbstub_use_prev_in_buf", "13882": "gen", "13883": "generate_sched_domains", "13884": "generated", "13885": "generation", "13886": "generic_exec_single", "13887": "generic_file_llseek", "13888": "generic_handle_irq", "13889": "generic_handle_irq_desc", "13890": "generic_msi_domain_ops", "13891": "generic_ptrace_peekdata", "13892": "generic_ptrace_pokedata", "13893": "generic_smp_call_function_single_interrupt", "13894": "genl_admin_perm", "13895": "genl_family", "13896": "genl_id_generate", "13897": "genl_info", "13898": "genl_ops", "13899": "genl_register_family_with_ops", "13900": "genlhdr", "13901": "genlmsg_data", "13902": "genlmsg_end", "13903": "genlmsg_new", "13904": "genlmsg_put", "13905": "genlmsg_put_reply", "13906": "genlmsg_reply", "13907": "genlmsg_unicast", "13908": "genlmsghdr", "13909": "gentle_fair_sleepers", "13910": "get", "13911": "get_accumulated_info", "13912": "get_avenrun", "13913": "get_buffer", "13914": "get_cached_msi_msg", "13915": "get_callchain_buffers", "13916": "get_callchain_entry", "13917": "get_char_func", "13918": "get_child_by_name", "13919": "get_clock_desc", "13920": "get_cmdline", "13921": "get_compat_itimerspec", "13922": "get_compat_itimerval", "13923": "get_compat_sigevent", "13924": "get_count_order", "13925": "get_cpu", "13926": "get_cpu_idle_time_us", "13927": "get_cpu_iowait_time_us", "13928": "get_cpu_itimer", "13929": "get_cpu_usage", "13930": "get_cpu_var", "13931": "get_cred", "13932": "get_css_set", "13933": "get_ctx", "13934": "get_current_user", "13935": "get_dap_lock", "13936": "get_device", "13937": "get_dumpable", "13938": "get_endian", "13939": "get_fetch_size_function", "13940": "get_fields", "13941": "get_file", "13942": "get_file_raw_ptr", "13943": "get_file_rcu", "13944": "get_fn_info", "13945": "get_fn_size", "13946": "get_fp_mode", "13947": "get_fpemu_ctl", "13948": "get_fpexc_ctl", "13949": "get_fs", "13950": "get_fs_pwd", "13951": "get_fs_type", "13952": "get_func", "13953": "get_func_proto", "13954": "get_gendisk", "13955": "get_group", "13956": "get_group_info", "13957": "get_highmem_buffer", "13958": "get_highmem_page_buffer", "13959": "get_hwirq", "13960": "get_image_page", "13961": "get_incorrect_percent", "13962": "get_info_index", "13963": "get_iowait_load", "13964": "get_irq_regs", "13965": "get_jiffies_64", "13966": "get_kprobe", "13967": "get_ksymbol", "13968": "get_ksymbol_core", "13969": "get_ksymbol_mod", "13970": "get_ktype", "13971": "get_last_crashkernel", "13972": "get_link_target", "13973": "get_loc_data", "13974": "get_lock_depth", "13975": "get_lock_parent", "13976": "get_lock_stats", "13977": "get_mm_exe_file", "13978": "get_mm_hiwater_rss", "13979": "get_mm_hiwater_vm", "13980": "get_mm_rss", "13981": "get_modinfo", "13982": "get_monotonic_boottime", "13983": "get_monotonic_coarse", "13984": "get_monotonic_coarse64", "13985": "get_net", "13986": "get_next_timer_interrupt", "13987": "get_node_by_name", "13988": "get_node_info", "13989": "get_nohz_timer_target", "13990": "get_nr_threads", "13991": "get_nsproxy", "13992": "get_num_physpages", "13993": "get_numa_group", "13994": "get_offset", "13995": "get_online_cpus", "13996": "get_optimized_kprobe", "13997": "get_option", "13998": "get_order", "13999": "get_packet", "14000": "get_page", "14001": "get_parent", "14002": "get_parent_ip", "14003": "get_pdu_int", "14004": "get_pdu_remap", "14005": "get_pid", "14006": "get_pid_ns", "14007": "get_pid_task", "14008": "get_posix_clock", "14009": "get_pred_parent", "14010": "get_proc_ns", "14011": "get_prog", "14012": "get_pwq", "14013": "get_random_bytes", "14014": "get_random_int", "14015": "get_recursion_context", "14016": "get_return_for_leaf", "14017": "get_rloc_data", "14018": "get_rloc_len", "14019": "get_rloc_offs", "14020": "get_robust_list", "14021": "get_rq_runnable_load", "14022": "get_rr_interval", "14023": "get_rr_interval_fair", "14024": "get_rr_interval_idle", "14025": "get_rr_interval_rt", "14026": "get_safe_page", "14027": "get_saved_cmdlines", "14028": "get_sd_balance_interval", "14029": "get_sd_load_idx", "14030": "get_seccomp_filter", "14031": "get_seconds", "14032": "get_signal", "14033": "get_softlockup_thresh", "14034": "get_state", "14035": "get_state_synchronize_rcu", "14036": "get_swap_page_of_type", "14037": "get_swap_reader", "14038": "get_swap_writer", "14039": "get_symbol_offset", "14040": "get_symbol_pos", "14041": "get_sysctl", "14042": "get_sysctl_timer_migration", "14043": "get_taint", "14044": "get_task_comm", "14045": "get_task_cred", "14046": "get_task_io_context", "14047": "get_task_mm", "14048": "get_task_pid", "14049": "get_task_struct", "14050": "get_time", "14051": "get_timestamp", "14052": "get_trampoline_vaddr", "14053": "get_tree", "14054": "get_trigger_ops", "14055": "get_tsc_ctl", "14056": "get_type", "14057": "get_uid", "14058": "get_unalign_ctl", "14059": "get_unaligned_be16", "14060": "get_unaligned_be32", "14061": "get_unbound_pool", "14062": "get_unmapped_area", "14063": "get_update_sysctl_factor", "14064": "get_usage_char", "14065": "get_usage_chars", "14066": "get_user", "14067": "get_user_cpu_mask", "14068": "get_user_ns", "14069": "get_user_pages", "14070": "get_user_stack_nth", "14071": "get_utask", "14072": "get_uts_ns", "14073": "get_value", "14074": "get_vfs_caps_from_disk", "14075": "get_vtime_delta", "14076": "get_wchan", "14077": "get_work_color", "14078": "get_work_pool", "14079": "get_work_pool_id", "14080": "get_work_pwq", "14081": "get_xol_area", "14082": "get_zeroed_page", "14083": "getboottime64", "14084": "getcpu", "14085": "getcpu_cache", "14086": "getegid", "14087": "getegid16", "14088": "geteuid", "14089": "geteuid16", "14090": "getgid", "14091": "getgid16", "14092": "getgroups16", "14093": "gethostname", "14094": "getitimer", "14095": "getname", "14096": "getname_kernel", "14097": "getnstime_raw_and_real", "14098": "getnstimeofday", "14099": "getnstimeofday64", "14100": "getpgid", "14101": "getpgrp", "14102": "getpid", "14103": "getppid", "14104": "getpriority", "14105": "getrawmonotonic", "14106": "getrawmonotonic64", "14107": "getresgid", "14108": "getresgid16", "14109": "getresuid16", "14110": "getrlimit", "14111": "getrusage", "14112": "getsid", "14113": "getthread", "14114": "gettid", "14115": "gettime", "14116": "gettimeofday", "14117": "getuid", "14118": "getuid16", "14119": "gf", "14120": "gfp", "14121": "gfp_atomic", "14122": "gfp_extra_flags", "14123": "gfp_flags", "14124": "gfp_highuser", "14125": "gfp_kdb", "14126": "gfp_kernel", "14127": "gfp_mask", "14128": "gfp_nofs", "14129": "gfp_nowait", "14130": "gfp_t", "14131": "gfp_temporary", "14132": "gfp_trace", "14133": "gfp_user", "14134": "gfpflags", "14135": "gid", "14136": "gid_eq", "14137": "gid_gt", "14138": "gid_gte", "14139": "gid_lt", "14140": "gid_lte", "14141": "gid_m_show", "14142": "gid_m_start", "14143": "gid_map", "14144": "gid_t", "14145": "gid_valid", "14146": "gidsetsize", "14147": "glob", "14148": "global", "14149": "global_list", "14150": "global_ops", "14151": "global_page_state", "14152": "global_root_gid", "14153": "global_root_uid", "14154": "global_rt_period", "14155": "global_rt_runtime", "14156": "global_trace", "14157": "go", "14158": "going", "14159": "goner", "14160": "good_mm", "14161": "good_one", "14162": "good_sigevent", "14163": "got_name", "14164": "got_nohz_idle_kick", "14165": "got_you_moron", "14166": "gotcbs", "14167": "goto", "14168": "gp", "14169": "gp_activity", "14170": "gp_cond", "14171": "gp_cond1", "14172": "gp_duration", "14173": "gp_exp", "14174": "gp_exp1", "14175": "gp_flags", "14176": "gp_init_delay", "14177": "gp_kthread", "14178": "gp_max", "14179": "gp_normal", "14180": "gp_normal1", "14181": "gp_snap", "14182": "gp_start", "14183": "gp_state", "14184": "gp_sync", "14185": "gp_sync1", "14186": "gp_tasks", "14187": "gp_wq", "14188": "gpa", "14189": "gpage", "14190": "gpkt", "14191": "gpl", "14192": "gpl_compatible", "14193": "gpl_crcs", "14194": "gpl_future_crcs", "14195": "gpl_future_syms", "14196": "gpl_only", "14197": "gpl_syms", "14198": "gplok", "14199": "gpmax", "14200": "gpnum", "14201": "gps", "14202": "gpwrap", "14203": "gran", "14204": "graph", "14205": "graph_array", "14206": "graph_depth_fops", "14207": "graph_depth_read", "14208": "graph_depth_write", "14209": "graph_ent", "14210": "graph_functions", "14211": "graph_hang_thresh", "14212": "graph_init_task", "14213": "graph_lock", "14214": "graph_max_func_test", "14215": "graph_ops", "14216": "graph_ret", "14217": "graph_trace", "14218": "graph_trace_close", "14219": "graph_trace_entry_event", "14220": "graph_trace_init", "14221": "graph_trace_open", "14222": "graph_trace_reset", "14223": "graph_trace_ret_event", "14224": "graph_trace_update_thresh", "14225": "graph_tracer_flags", "14226": "graph_unlock", "14227": "greater", "14228": "greatest", "14229": "grep", "14230": "group", "14231": "group_at", "14232": "group_balance_cpu", "14233": "group_can_go_on", "14234": "group_capacity", "14235": "group_cfs_rq", "14236": "group_classify", "14237": "group_dead", "14238": "group_entry", "14239": "group_error", "14240": "group_event", "14241": "group_exit", "14242": "group_exit_code", "14243": "group_faults", "14244": "group_faults_cpu", "14245": "group_first_cpu", "14246": "group_flags", "14247": "group_has_capacity", "14248": "group_imbalance", "14249": "group_imbalanced", "14250": "group_info", "14251": "group_is_overloaded", "14252": "group_leader", "14253": "group_load", "14254": "group_lock", "14255": "group_no_capacity", "14256": "group_node", "14257": "group_other", "14258": "group_overloaded", "14259": "group_path", "14260": "group_rq", "14261": "group_rt_rq", "14262": "group_rwsem", "14263": "group_sched_in", "14264": "group_sched_out", "14265": "group_send_sig_info", "14266": "group_stop", "14267": "group_stop_count", "14268": "group_type", "14269": "group_usage", "14270": "group_weight", "14271": "groupimp", "14272": "grouplist", "14273": "groupmask", "14274": "groups", "14275": "groups16_from_user", "14276": "groups16_to_user", "14277": "groups_alloc", "14278": "groupweight", "14279": "grow_tree_refs", "14280": "grp", "14281": "grphi", "14282": "grplo", "14283": "grpmask", "14284": "grpnum", "14285": "gstop", "14286": "gstop_done", "14287": "gtime", "14288": "guarantee_online_cpus", "14289": "guarantee_online_mems", "14290": "h", "14291": "h_free", "14292": "h_load", "14293": "h_load_next", "14294": "h_nr_running", "14295": "h_offset", "14296": "h_used", "14297": "halt_fast_timekeeper", "14298": "handle", "14299": "handle_bad_irq", "14300": "handle_ctrl_cmd", "14301": "handle_edge_eoi_irq", "14302": "handle_edge_irq", "14303": "handle_error", "14304": "handle_event", "14305": "handle_fasteoi_irq", "14306": "handle_futex_death", "14307": "handle_irq", "14308": "handle_irq_event", "14309": "handle_irq_event_percpu", "14310": "handle_level_irq", "14311": "handle_nested_irq", "14312": "handle_one", "14313": "handle_op", "14314": "handle_path", "14315": "handle_percpu_devid_irq", "14316": "handle_percpu_irq", "14317": "handle_poweroff", "14318": "handle_simple_irq", "14319": "handle_singlestep", "14320": "handle_swbp", "14321": "handle_trampoline", "14322": "handle_unknown", "14323": "handle_uretprobe_chain", "14324": "handled", "14325": "handler", "14326": "handler_chain", "14327": "handler_data", "14328": "handler_errors", "14329": "handler_fn", "14330": "handler_name", "14331": "happens", "14332": "hard", "14333": "hard_irq_disable", "14334": "hard_watchdog_warn", "14335": "hardirq", "14336": "hardirq_context", "14337": "hardirq_count", "14338": "hardirq_disable_event", "14339": "hardirq_disable_ip", "14340": "hardirq_enable_event", "14341": "hardirq_enable_ip", "14342": "hardirq_offset", "14343": "hardirq_shift", "14344": "hardirq_verbose", "14345": "hardirqs_enabled", "14346": "hardirqs_off", "14347": "hardirqs_off_events", "14348": "hardirqs_on_events", "14349": "hardlockup_panic", "14350": "hardpps", "14351": "hardpps_update_phase", "14352": "hardsoft_irq", "14353": "has", "14354": "has_aux", "14355": "has_branch_stack", "14356": "has_child_subreaper", "14357": "has_cntl", "14358": "has_crcs", "14359": "has_free_capacity", "14360": "has_in_flight", "14361": "has_ns_capability", "14362": "has_ns_capability_noaudit", "14363": "has_pending", "14364": "has_pending_signals", "14365": "has_perm", "14366": "has_pushable_tasks", "14367": "hash", "14368": "hash32_ptr", "14369": "hash_32", "14370": "hash_add", "14371": "hash_algo_name", "14372": "hash_bits", "14373": "hash_contains_ip", "14374": "hash_del", "14375": "hash_early", "14376": "hash_entry", "14377": "hash_for_each", "14378": "hash_for_each_possible", "14379": "hash_head", "14380": "hash_init", "14381": "hash_lock", "14382": "hash_long", "14383": "hash_node", "14384": "hash_ptr", "14385": "hash_size", "14386": "hash_small", "14387": "hashent", "14388": "have", "14389": "have_arch_copy_siginfo_to_user", "14390": "have_arch_pick_mmap_layout", "14391": "have_jump_label", "14392": "have_lost", "14393": "have_rcu_nocb_mask", "14394": "have_rt_push_ipi", "14395": "hc", "14396": "hcpu", "14397": "hd", "14398": "hd_struct", "14399": "hdr", "14400": "he", "14401": "head", "14402": "head_bit", "14403": "head_page", "14404": "head_page_with_bit", "14405": "head_ptr", "14406": "header", "14407": "header_iter", "14408": "header_size", "14409": "height", "14410": "held_lock", "14411": "held_locks", "14412": "help", "14413": "help_msg", "14414": "helper_lock", "14415": "helper_unlock", "14416": "hentry", "14417": "here", "14418": "hex", "14419": "hex_asc", "14420": "hex_asc_hi", "14421": "hex_asc_lo", "14422": "hex_byte_pack", "14423": "hex_to_bin", "14424": "hhd", "14425": "hi1", "14426": "hi2", "14427": "hi_shift", "14428": "hi_softirq", "14429": "hib_bio_read_page", "14430": "hib_bio_write_page", "14431": "hib_resume_bdev", "14432": "hib_wait_on_bio_chain", "14433": "hibernate", "14434": "hibernate_image_size_init", "14435": "hibernate_preallocate_memory", "14436": "hibernate_reserved_size_init", "14437": "hibernate_sig", "14438": "hibernation_available", "14439": "hibernation_debug_sleep", "14440": "hibernation_first", "14441": "hibernation_invalid", "14442": "hibernation_max", "14443": "hibernation_mode", "14444": "hibernation_modes", "14445": "hibernation_ops", "14446": "hibernation_platform", "14447": "hibernation_platform_enter", "14448": "hibernation_reboot", "14449": "hibernation_restore", "14450": "hibernation_set_ops", "14451": "hibernation_shutdown", "14452": "hibernation_snapshot", "14453": "hibernation_suspend", "14454": "hibernation_test", "14455": "hidden", "14456": "hidx", "14457": "hierarchical_quota", "14458": "hierarchy_id", "14459": "high", "14460": "high2lowgid", "14461": "high2lowuid", "14462": "highbp", "14463": "highest_flag_domain", "14464": "highest_prio", "14465": "highmem_pbe", "14466": "highmem_pblist", "14467": "highpri", "14468": "highpri_nice_level", "14469": "highres", "14470": "hit", "14471": "hiter", "14472": "hits", "14473": "hiwater_rss", "14474": "hiwater_vm", "14475": "hlist", "14476": "hlist_add_head", "14477": "hlist_add_head_rcu", "14478": "hlist_del", "14479": "hlist_del_init", "14480": "hlist_del_rcu", "14481": "hlist_empty", "14482": "hlist_entry", "14483": "hlist_entry_safe", "14484": "hlist_first_rcu", "14485": "hlist_for_each_entry", "14486": "hlist_for_each_entry_rcu", "14487": "hlist_for_each_entry_rcu_notrace", "14488": "hlist_for_each_entry_safe", "14489": "hlist_head", "14490": "hlist_lock", "14491": "hlist_next_rcu", "14492": "hlist_node", "14493": "hlist_replace_rcu", "14494": "hlock", "14495": "hlock_class", "14496": "hlock_curr", "14497": "hnd", "14498": "hold_ctx", "14499": "hold_module_trace_bprintk_format", "14500": "holders_dir", "14501": "holding", "14502": "holdtime", "14503": "holdtime_stamp", "14504": "hole", "14505": "hole_end", "14506": "hole_start", "14507": "home_node", "14508": "hook", "14509": "host_data", "14510": "hostname", "14511": "hotcpu_notifier", "14512": "hotplug_cfd", "14513": "hotplug_cfd_notifier", "14514": "hotplug_cpu__broadcast_tick_pull", "14515": "hotplug_hrtick", "14516": "hotplug_threads", "14517": "hotplug_update_tasks", "14518": "hotplug_update_tasks_legacy", "14519": "hour", "14520": "housekeeping_affine", "14521": "housekeeping_mask", "14522": "how", "14523": "howto", "14524": "hp", "14525": "hp_thread_active", "14526": "hp_thread_none", "14527": "hp_thread_parked", "14528": "hr1", "14529": "hr2", "14530": "hr_delta", "14531": "hres_active", "14532": "hrint", "14533": "hrt", "14534": "hrtick", "14535": "hrtick_clear", "14536": "hrtick_csd", "14537": "hrtick_csd_pending", "14538": "hrtick_enabled", "14539": "hrtick_start", "14540": "hrtick_start_fair", "14541": "hrtick_timer", "14542": "hrtick_update", "14543": "hrtimer", "14544": "hrtimer_active", "14545": "hrtimer_add_expires", "14546": "hrtimer_add_expires_ns", "14547": "hrtimer_bases", "14548": "hrtimer_callback_running", "14549": "hrtimer_cancel", "14550": "hrtimer_cb_get_time", "14551": "hrtimer_cpu_base", "14552": "hrtimer_expires_remaining", "14553": "hrtimer_forward", "14554": "hrtimer_forward_now", "14555": "hrtimer_get_expires", "14556": "hrtimer_get_next_event", "14557": "hrtimer_get_remaining", "14558": "hrtimer_get_res", "14559": "hrtimer_get_softexpires", "14560": "hrtimer_init", "14561": "hrtimer_interrupt", "14562": "hrtimer_interrupts", "14563": "hrtimer_interrupts_saved", "14564": "hrtimer_is_hres_active", "14565": "hrtimer_is_queued", "14566": "hrtimer_max_clock_bases", "14567": "hrtimer_mode", "14568": "hrtimer_mode_abs", "14569": "hrtimer_mode_abs_pinned", "14570": "hrtimer_mode_rel", "14571": "hrtimer_mode_rel_pinned", "14572": "hrtimer_nanosleep", "14573": "hrtimer_nanosleep_restart", "14574": "hrtimer_norestart", "14575": "hrtimer_restart", "14576": "hrtimer_run_pending", "14577": "hrtimer_run_queues", "14578": "hrtimer_set_expires", "14579": "hrtimer_sleeper", "14580": "hrtimer_start", "14581": "hrtimer_start_expires", "14582": "hrtimer_try_to_cancel", "14583": "hrtimers_resume", "14584": "hsd", "14585": "ht", "14586": "htab", "14587": "htab_elem", "14588": "htab_map_alloc", "14589": "htab_map_delete_elem", "14590": "htab_map_free", "14591": "htab_map_get_next_key", "14592": "htab_map_hash", "14593": "htab_map_lookup_elem", "14594": "htab_map_update_elem", "14595": "htab_ops", "14596": "htab_type", "14597": "hugepages_treat_as_movable", "14598": "hugetlb_mempolicy_sysctl_handler", "14599": "hugetlb_overcommit_handler", "14600": "hugetlb_sysctl_handler", "14601": "hung_task_batching", "14602": "hung_task_init", "14603": "hung_task_panic", "14604": "hung_task_panic_setup", "14605": "hung_task_timeout_max", "14606": "hw", "14607": "hw_breakpoint", "14608": "hw_irq", "14609": "hw_nmi_get_sample_period", "14610": "hw_perf_event", "14611": "hwc", "14612": "hweight64", "14613": "hwirq", "14614": "hwirq_base", "14615": "hwirq_max", "14616": "hz", "14617": "hz_to_msec_den", "14618": "hz_to_msec_mul32", "14619": "hz_to_msec_num", "14620": "hz_to_msec_shr32", "14621": "hz_to_usec_den", "14622": "hz_to_usec_mul32", "14623": "hz_to_usec_num", "14624": "hz_to_usec_shr32", "14625": "i", "14626": "i_cdev", "14627": "i_fsnotify_marks", "14628": "i_generation", "14629": "i_gid", "14630": "i_ino", "14631": "i_mapping", "14632": "i_mmap", "14633": "i_mmap_lock_read", "14634": "i_mmap_lock_write", "14635": "i_mmap_unlock_read", "14636": "i_mmap_unlock_write", "14637": "i_mmap_writable", "14638": "i_mode", "14639": "i_mutex", "14640": "i_next", "14641": "i_private", "14642": "i_rdev", "14643": "i_sb", "14644": "i_size_read", "14645": "i_uid", "14646": "i_writecount", "14647": "ia_gid", "14648": "ia_uid", "14649": "ia_valid", "14650": "iattr", "14651": "id", "14652": "id2", "14653": "id_buf", "14654": "id_header_size", "14655": "id_type", "14656": "ida", "14657": "ida_destroy", "14658": "ida_init", "14659": "ida_simple_get", "14660": "ida_simple_remove", "14661": "idata", "14662": "ideal_runtime", "14663": "ident", "14664": "idle", "14665": "idle_active", "14666": "idle_balance", "14667": "idle_calls", "14668": "idle_cpu", "14669": "idle_cpus", "14670": "idle_cpus_mask", "14671": "idle_enter_fair", "14672": "idle_entrytime", "14673": "idle_exit_fair", "14674": "idle_exittime", "14675": "idle_expires", "14676": "idle_get_state", "14677": "idle_idx", "14678": "idle_init", "14679": "idle_jiffies", "14680": "idle_list", "14681": "idle_ret_stack", "14682": "idle_sched_class", "14683": "idle_set_state", "14684": "idle_sleeps", "14685": "idle_sleeptime", "14686": "idle_stamp", "14687": "idle_state", "14688": "idle_task", "14689": "idle_task_exit", "14690": "idle_thread_get", "14691": "idle_thread_set_boot_cpu", "14692": "idle_threads", "14693": "idle_threads_init", "14694": "idle_time_ns", "14695": "idle_timer", "14696": "idle_waketime", "14697": "idle_worker_timeout", "14698": "idlest", "14699": "idr", "14700": "idr_alloc", "14701": "idr_alloc_cyclic", "14702": "idr_destroy", "14703": "idr_find", "14704": "idr_get_next", "14705": "idr_init", "14706": "idr_preload", "14707": "idr_preload_end", "14708": "idr_remove", "14709": "idr_replace", "14710": "idx", "14711": "idx1", "14712": "idx2", "14713": "idx_invalid", "14714": "if", "14715": "if_assign", "14716": "ignore", "14717": "ignore_errors", "14718": "ignore_loglevel", "14719": "ignore_signals", "14720": "ignore_state", "14721": "ignored", "14722": "ignoring", "14723": "ignoring_children", "14724": "igrab", "14725": "ikconfig_cleanup", "14726": "ikconfig_file_ops", "14727": "ikconfig_init", "14728": "ikconfig_read_current", "14729": "ilb", "14730": "ilb_cpu", "14731": "illegal", "14732": "ilog2", "14733": "image", "14734": "image_loader_data", "14735": "image_pages", "14736": "image_ptr", "14737": "image_size", "14738": "imb", "14739": "imbalance", "14740": "imbalance_pct", "14741": "imbn", "14742": "iminor", "14743": "imm", "14744": "imm64", "14745": "immediately", "14746": "imp", "14747": "implementation", "14748": "important", "14749": "in", "14750": "in_atomic", "14751": "in_atomic_preempt_off", "14752": "in_dbg_master", "14753": "in_egroup_p", "14754": "in_exec", "14755": "in_group_p", "14756": "in_hardirq", "14757": "in_hash", "14758": "in_interrupt", "14759": "in_iowait", "14760": "in_irq", "14761": "in_lock_functions", "14762": "in_mask", "14763": "in_new", "14764": "in_nmi", "14765": "in_ns", "14766": "in_old", "14767": "in_other_hash", "14768": "in_quote", "14769": "in_serving_softirq", "14770": "in_softirq", "14771": "in_string", "14772": "in_suspend", "14773": "in_syscall", "14774": "inactive", "14775": "inblock", "14776": "inc", "14777": "inc_chains", "14778": "inc_mm_counter", "14779": "inc_rt_group", "14780": "inc_rt_migration", "14781": "inc_rt_prio", "14782": "inc_rt_prio_smp", "14783": "inc_rt_tasks", "14784": "incby", "14785": "include", "14786": "incorrect", "14787": "incr", "14788": "incr_error", "14789": "increment", "14790": "increment_cpu_stall_ticks", "14791": "increment_wakelocks_number", "14792": "ind", "14793": "ind_destination", "14794": "ind_done", "14795": "ind_indirection", "14796": "ind_page", "14797": "ind_source", "14798": "index", "14799": "individual", "14800": "infix", "14801": "infix_advance", "14802": "infix_get_op", "14803": "infix_next", "14804": "infix_peek", "14805": "infix_string", "14806": "inflight", "14807": "info", "14808": "info1", "14809": "info2", "14810": "info_test", "14811": "information", "14812": "infosec", "14813": "ing", "14814": "inh", "14815": "inherit", "14816": "inherit_stat", "14817": "inheritable", "14818": "inidle", "14819": "init", "14820": "init_aggr_kprobe", "14821": "init_and_link_css", "14822": "init_annotated_branch_stats", "14823": "init_blk_tracer", "14824": "init_branch_tracer", "14825": "init_callback_list", "14826": "init_cfs_bandwidth", "14827": "init_cfs_rq", "14828": "init_cfs_rq_runtime", "14829": "init_cgroup_housekeeping", "14830": "init_cgroup_root", "14831": "init_completion", "14832": "init_cpu_online", "14833": "init_cpu_possible", "14834": "init_cpu_present", "14835": "init_cred", "14836": "init_css_set", "14837": "init_default_callback_list", "14838": "init_defrootdomain", "14839": "init_delayed_work", "14840": "init_dl_bandwidth", "14841": "init_dl_bw", "14842": "init_dl_rq", "14843": "init_dl_task_timer", "14844": "init_fs_pin", "14845": "init_ftrace_syscalls", "14846": "init_graph_trace", "14847": "init_graph_tracefs", "14848": "init_groups", "14849": "init_header", "14850": "init_header_complete", "14851": "init_hlist_head", "14852": "init_hlist_node", "14853": "init_hrtick", "14854": "init_idle", "14855": "init_idle_bootup_task", "14856": "init_idle_pids", "14857": "init_idle_preempt_count", "14858": "init_ipc_ns", "14859": "init_irq_default_affinity", "14860": "init_irq_proc", "14861": "init_irq_work", "14862": "init_irqsoff_tracer", "14863": "init_kernel_text", "14864": "init_kprobe_trace", "14865": "init_kprobes", "14866": "init_kstat_irqs", "14867": "init_list_head", "14868": "init_llist_head", "14869": "init_lstats_procfs", "14870": "init_mm", "14871": "init_mmio_trace", "14872": "init_module", "14873": "init_name", "14874": "init_net", "14875": "init_new_context", "14876": "init_nocb_callback_list", "14877": "init_node", "14878": "init_nsproxy", "14879": "init_offset_mask", "14880": "init_ops_hash", "14881": "init_pid_ns", "14882": "init_pids", "14883": "init_posix_timers", "14884": "init_pred", "14885": "init_pwq", "14886": "init_radix_tree", "14887": "init_rcu_head", "14888": "init_rcu_head_on_stack", "14889": "init_reg_state", "14890": "init_ret", "14891": "init_ro_size", "14892": "init_rootdomain", "14893": "init_rq_hrtick", "14894": "init_rt_bandwidth", "14895": "init_rt_rq", "14896": "init_rttest", "14897": "init_rwsem", "14898": "init_sched_dl_class", "14899": "init_sched_domains", "14900": "init_sched_fair_class", "14901": "init_sched_groups_capacity", "14902": "init_sched_rt_class", "14903": "init_sd_lb_stats", "14904": "init_sigpending", "14905": "init_size", "14906": "init_srcu_struct", "14907": "init_srcu_struct_fields", "14908": "init_stat_file", "14909": "init_struct_pid", "14910": "init_syscall_trace", "14911": "init_task", "14912": "init_task_comm", "14913": "init_task_pid", "14914": "init_task_preempt_count", "14915": "init_task_runnable_average", "14916": "init_task_work", "14917": "init_test_thread", "14918": "init_text_size", "14919": "init_tg_cfs_entry", "14920": "init_tg_rt_entry", "14921": "init_timer_cpu", "14922": "init_timer_cpus", "14923": "init_timer_deferrable", "14924": "init_timer_key", "14925": "init_timer_on_stack_key", "14926": "init_timer_stats", "14927": "init_timers", "14928": "init_trace_uprobe_filter", "14929": "init_uprobe_trace", "14930": "init_uprobes", "14931": "init_user", "14932": "init_user_ns", "14933": "init_uts_ns", "14934": "init_utsname", "14935": "init_wait", "14936": "init_waitqueue_head", "14937": "init_wakeup_tracer", "14938": "init_work", "14939": "init_work_onstack", "14940": "init_worker_pool", "14941": "init_workqueues", "14942": "initcall_debug", "14943": "initcnt", "14944": "initial", "14945": "initial_count", "14946": "initial_jiffies", "14947": "initialiser", "14948": "initialization", "14949": "initrd_buf", "14950": "initrd_buf_len", "14951": "initrd_fd", "14952": "initsize", "14953": "initstate", "14954": "inlin", "14955": "inline", "14956": "ino", "14957": "ino_generation", "14958": "inode", "14959": "inode_f", "14960": "inode_mark", "14961": "inode_permission", "14962": "inodes_stat", "14963": "inotify_max_queued_events", "14964": "inotify_max_user_instances", "14965": "inotify_max_user_watches", "14966": "inotify_table", "14967": "inprogress", "14968": "input", "14969": "insert_hash", "14970": "insert_kthread_work", "14971": "insert_resource", "14972": "insert_resource_conflict", "14973": "insert_resource_expand_to_fit", "14974": "insert_stat", "14975": "insert_uprobe", "14976": "insert_work", "14977": "insert_wq_barrier", "14978": "insn", "14979": "insn_buf", "14980": "insn_cnt", "14981": "insn_idx", "14982": "insn_processed", "14983": "insn_size", "14984": "insn_stack", "14985": "insn_state", "14986": "insns", "14987": "insnsi", "14988": "inst", "14989": "install", "14990": "install_breakpoint", "14991": "install_special_mapping", "14992": "install_thread_keyring_to_cred", "14993": "installed", "14994": "instance", "14995": "instances", "14996": "instruction_pointer", "14997": "instruction_pointer_set", "14998": "int", "14999": "int64_t", "15000": "int_max", "15001": "int_min", "15002": "int_sqrt", "15003": "int_to_threadref", "15004": "inter", "15005": "internal", "15006": "internal_add_timer", "15007": "internal_trace_puts", "15008": "interp_fdpic_loadmap", "15009": "interrupt", "15010": "interrupted", "15011": "interrupts", "15012": "interval", "15013": "into", "15014": "inum", "15015": "inuse", "15016": "inv_weight", "15017": "invalid", "15018": "invalid_rcu_flavor", "15019": "invalid_uid", "15020": "invalidating", "15021": "invoke_rcu_callbacks", "15022": "invoke_rcu_callbacks_kthread", "15023": "invoke_rcu_core", "15024": "invoke_softirq", "15025": "io_context", "15026": "io_delay_type", "15027": "io_num", "15028": "io_schedule", "15029": "io_schedule_timeout", "15030": "io_space_limit", "15031": "io_start", "15032": "ioac", "15033": "ioc", "15034": "ioc_task_link", "15035": "iocsize_mask", "15036": "ioctl", "15037": "ioctx_lock", "15038": "ioctx_table", "15039": "iomem_is_exclusive", "15040": "iomem_map_sanity_check", "15041": "iomem_open", "15042": "iomem_resource", "15043": "ioport_resource", "15044": "ioports_open", "15045": "ioprio", "15046": "ioprio_valid", "15047": "ioread32be", "15048": "ioresource_busy", "15049": "ioresource_exclusive", "15050": "ioresource_io", "15051": "ioresource_mem", "15052": "ioresource_muxed", "15053": "ioresource_sizealign", "15054": "ioresource_startalign", "15055": "ioresource_unset", "15056": "ioresources_init", "15057": "iov_base", "15058": "iov_len", "15059": "iovec", "15060": "iowait", "15061": "iowait_count", "15062": "iowait_sleeptime", "15063": "iowait_sum", "15064": "iowrite32be", "15065": "ip", "15066": "ip_fmt", "15067": "ipc", "15068": "ipc_ns", "15069": "ipcp", "15070": "iput", "15071": "irq", "15072": "irq_ack", "15073": "irq_affinity_hint_proc_fops", "15074": "irq_affinity_hint_proc_open", "15075": "irq_affinity_hint_proc_show", "15076": "irq_affinity_list_proc_fops", "15077": "irq_affinity_list_proc_open", "15078": "irq_affinity_list_proc_show", "15079": "irq_affinity_list_proc_write", "15080": "irq_affinity_notify", "15081": "irq_affinity_proc_fops", "15082": "irq_affinity_proc_open", "15083": "irq_affinity_proc_show", "15084": "irq_affinity_proc_write", "15085": "irq_alloc_descs", "15086": "irq_alloc_domain_generic_chips", "15087": "irq_alloc_generic_chip", "15088": "irq_alloc_hwirqs", "15089": "irq_base", "15090": "irq_bitmap_bits", "15091": "irq_bus_lock", "15092": "irq_bus_sync_unlock", "15093": "irq_calc_mask", "15094": "irq_can_move_pcntxt", "15095": "irq_can_set_affinity", "15096": "irq_capable", "15097": "irq_check_poll", "15098": "irq_chip", "15099": "irq_chip_ack_parent", "15100": "irq_chip_compose_msi_msg", "15101": "irq_chip_eoi_parent", "15102": "irq_chip_generic", "15103": "irq_chip_mask_parent", "15104": "irq_chip_retrigger_hierarchy", "15105": "irq_chip_set_affinity_parent", "15106": "irq_chip_set_wake_parent", "15107": "irq_chip_type", "15108": "irq_chip_unmask_parent", "15109": "irq_chip_write_msi_msg", "15110": "irq_clear_status_flags", "15111": "irq_cnt", "15112": "irq_compose_msi_msg", "15113": "irq_context", "15114": "irq_copy_pending", "15115": "irq_count", "15116": "irq_cpu_offline", "15117": "irq_cpu_online", "15118": "irq_cpu_stop_queue_work", "15119": "irq_cpu_stop_queue_work_info", "15120": "irq_cpustat_t", "15121": "irq_create_direct_mapping", "15122": "irq_create_mapping", "15123": "irq_data", "15124": "irq_data_get_chip_type", "15125": "irq_data_get_irq_chip", "15126": "irq_data_get_irq_chip_data", "15127": "irq_data_to_desc", "15128": "irq_default_affinity", "15129": "irq_default_domain", "15130": "irq_default_init_flags", "15131": "irq_default_primary_handler", "15132": "irq_delta", "15133": "irq_depth", "15134": "irq_desc", "15135": "irq_desc_get_chip", "15136": "irq_desc_get_irq_data", "15137": "irq_desc_lock_class", "15138": "irq_desc_tree", "15139": "irq_disable", "15140": "irq_do_set_affinity", "15141": "irq_domain", "15142": "irq_domain_activate_irq", "15143": "irq_domain_add_hierarchy", "15144": "irq_domain_add_simple", "15145": "irq_domain_alloc_descs", "15146": "irq_domain_alloc_irqs_parent", "15147": "irq_domain_associate", "15148": "irq_domain_associate_many", "15149": "irq_domain_check_hierarchy", "15150": "irq_domain_chip_generic", "15151": "irq_domain_deactivate_irq", "15152": "irq_domain_disassociate", "15153": "irq_domain_free_irqs", "15154": "irq_domain_free_irqs_top", "15155": "irq_domain_list", "15156": "irq_domain_mapping", "15157": "irq_domain_mutex", "15158": "irq_domain_ops", "15159": "irq_domain_remove", "15160": "irq_domain_set_hwirq_and_chip", "15161": "irq_domain_xlate_onetwocell", "15162": "irq_enable", "15163": "irq_enter", "15164": "irq_eoi", "15165": "irq_events", "15166": "irq_exit", "15167": "irq_expand_nr_irqs", "15168": "irq_finalize_oneshot", "15169": "irq_find_host", "15170": "irq_find_mapping", "15171": "irq_flags", "15172": "irq_flags_to_clear", "15173": "irq_flags_to_set", "15174": "irq_flow_handler_t", "15175": "irq_forced_thread_fn", "15176": "irq_found", "15177": "irq_free_desc", "15178": "irq_free_descs", "15179": "irq_free_hwirqs", "15180": "irq_gc_ack_clr_bit", "15181": "irq_gc_ack_set_bit", "15182": "irq_gc_be_io", "15183": "irq_gc_eoi", "15184": "irq_gc_flags", "15185": "irq_gc_get_irq_data", "15186": "irq_gc_init_mask_cache", "15187": "irq_gc_init_nested_lock", "15188": "irq_gc_init_ops", "15189": "irq_gc_lock", "15190": "irq_gc_mask_cache_per_type", "15191": "irq_gc_mask_clr_bit", "15192": "irq_gc_mask_disable_reg", "15193": "irq_gc_mask_disable_reg_and_ack", "15194": "irq_gc_mask_set_bit", "15195": "irq_gc_no_mask", "15196": "irq_gc_noop", "15197": "irq_gc_resume", "15198": "irq_gc_set_wake", "15199": "irq_gc_shutdown", "15200": "irq_gc_suspend", "15201": "irq_gc_syscore_ops", "15202": "irq_gc_unlock", "15203": "irq_gc_unmask_enable_reg", "15204": "irq_generic_chip_ops", "15205": "irq_get_desc_buslock", "15206": "irq_get_desc_check_global", "15207": "irq_get_desc_check_percpu", "15208": "irq_get_desc_lock", "15209": "irq_get_domain_generic_chip", "15210": "irq_get_irq_data", "15211": "irq_get_irqchip_state", "15212": "irq_get_msi_desc", "15213": "irq_get_next_irq", "15214": "irq_get_pending", "15215": "irq_handled", "15216": "irq_handler_t", "15217": "irq_hw_number_t", "15218": "irq_init_desc", "15219": "irq_init_generic_chip", "15220": "irq_insert_desc", "15221": "irq_is_polled", "15222": "irq_level", "15223": "irq_lock_sparse", "15224": "irq_map_generic_chip", "15225": "irq_mark_irq", "15226": "irq_mask", "15227": "irq_mask_ack", "15228": "irq_may_run", "15229": "irq_modify_status", "15230": "irq_move_irq", "15231": "irq_move_masked_irq", "15232": "irq_move_pcntxt", "15233": "irq_move_pending", "15234": "irq_nested_lock_class", "15235": "irq_nested_primary_handler", "15236": "irq_nested_thread", "15237": "irq_no_balancing", "15238": "irq_noautoen", "15239": "irq_node_proc_fops", "15240": "irq_node_proc_open", "15241": "irq_node_proc_show", "15242": "irq_none", "15243": "irq_noprobe", "15244": "irq_norequest", "15245": "irq_nothread", "15246": "irq_offset", "15247": "irq_per_cpu", "15248": "irq_per_cpu_devid", "15249": "irq_percpu_disable", "15250": "irq_percpu_enable", "15251": "irq_pm_check_wakeup", "15252": "irq_pm_init_ops", "15253": "irq_pm_install_action", "15254": "irq_pm_remove_action", "15255": "irq_pm_shutdown", "15256": "irq_pm_syscore_ops", "15257": "irq_pm_syscore_resume", "15258": "irq_poll_active", "15259": "irq_poll_cpu", "15260": "irq_print_chip", "15261": "irq_put_desc_busunlock", "15262": "irq_put_desc_unlock", "15263": "irq_readl_be", "15264": "irq_reg_readl", "15265": "irq_reg_writel", "15266": "irq_release_resources", "15267": "irq_remove_generic_chip", "15268": "irq_request_resources", "15269": "irq_resume", "15270": "irq_retrigger", "15271": "irq_select_affinity", "15272": "irq_select_affinity_usr", "15273": "irq_set_affinity", "15274": "irq_set_affinity_hint", "15275": "irq_set_affinity_locked", "15276": "irq_set_affinity_notifier", "15277": "irq_set_chip", "15278": "irq_set_chip_and_handler", "15279": "irq_set_chip_and_handler_name", "15280": "irq_set_chip_data", "15281": "irq_set_default_host", "15282": "irq_set_handler", "15283": "irq_set_handler_data", "15284": "irq_set_irq_type", "15285": "irq_set_irq_wake", "15286": "irq_set_irqchip_state", "15287": "irq_set_lockdep_class", "15288": "irq_set_mask_ok", "15289": "irq_set_mask_ok_done", "15290": "irq_set_mask_ok_nocopy", "15291": "irq_set_msi_desc", "15292": "irq_set_msi_desc_off", "15293": "irq_set_parent", "15294": "irq_set_percpu_devid", "15295": "irq_set_percpu_devid_flags", "15296": "irq_set_status_flags", "15297": "irq_set_thread_affinity", "15298": "irq_set_type", "15299": "irq_set_wake", "15300": "irq_settings_can_autoenable", "15301": "irq_settings_can_move_pcntxt", "15302": "irq_settings_can_probe", "15303": "irq_settings_can_request", "15304": "irq_settings_can_thread", "15305": "irq_settings_clr_and_set", "15306": "irq_settings_clr_level", "15307": "irq_settings_clr_noprobe", "15308": "irq_settings_clr_norequest", "15309": "irq_settings_clr_nothread", "15310": "irq_settings_get_trigger_mask", "15311": "irq_settings_has_no_balance_set", "15312": "irq_settings_is_level", "15313": "irq_settings_is_nested_thread", "15314": "irq_settings_is_per_cpu", "15315": "irq_settings_is_per_cpu_devid", "15316": "irq_settings_is_polled", "15317": "irq_settings_set_level", "15318": "irq_settings_set_no_balancing", "15319": "irq_settings_set_noprobe", "15320": "irq_settings_set_norequest", "15321": "irq_settings_set_nothread", "15322": "irq_settings_set_per_cpu", "15323": "irq_settings_set_trigger_mask", "15324": "irq_setup_alt_chip", "15325": "irq_setup_forced_threading", "15326": "irq_setup_generic_chip", "15327": "irq_shutdown", "15328": "irq_spurious_proc_fops", "15329": "irq_spurious_proc_open", "15330": "irq_spurious_proc_show", "15331": "irq_start_time", "15332": "irq_startup", "15333": "irq_stat", "15334": "irq_state_clr_disabled", "15335": "irq_state_clr_masked", "15336": "irq_state_set_disabled", "15337": "irq_state_set_masked", "15338": "irq_suspend", "15339": "irq_thread", "15340": "irq_thread_check_affinity", "15341": "irq_thread_dtor", "15342": "irq_thread_fn", "15343": "irq_time", "15344": "irq_time_read", "15345": "irq_time_seq", "15346": "irq_time_write_begin", "15347": "irq_time_write_end", "15348": "irq_to_desc", "15349": "irq_trace", "15350": "irq_type_level_mask", "15351": "irq_type_none", "15352": "irq_type_probe", "15353": "irq_type_sense_mask", "15354": "irq_unlock_sparse", "15355": "irq_unmask", "15356": "irq_wait_for_interrupt", "15357": "irq_wait_for_poll", "15358": "irq_wake_thread", "15359": "irq_was_disabled", "15360": "irq_work", "15361": "irq_work_busy", "15362": "irq_work_claim", "15363": "irq_work_flags", "15364": "irq_work_lazy", "15365": "irq_work_needs_cpu", "15366": "irq_work_pending", "15367": "irq_work_queue", "15368": "irq_work_queue_on", "15369": "irq_work_run", "15370": "irq_work_run_list", "15371": "irq_work_sync", "15372": "irq_work_tick", "15373": "irq_write_msi_msg", "15374": "irq_writel_be", "15375": "irqaction", "15376": "irqc_is_hardirq", "15377": "irqc_is_nested", "15378": "irqchip_eoi_if_handled", "15379": "irqchip_eoi_threaded", "15380": "irqchip_irq_state", "15381": "irqchip_mask_on_suspend", "15382": "irqchip_oneshot_safe", "15383": "irqchip_onoffline_enabled", "15384": "irqchip_set_type_masked", "15385": "irqchip_skip_set_wake", "15386": "irqclass", "15387": "irqd_affinity_set", "15388": "irqd_can_balance", "15389": "irqd_can_move_in_process_context", "15390": "irqd_clear", "15391": "irqd_clr_move_pending", "15392": "irqd_get_trigger_type", "15393": "irqd_has_set", "15394": "irqd_irq_disabled", "15395": "irqd_irq_inprogress", "15396": "irqd_irq_masked", "15397": "irqd_is_level_type", "15398": "irqd_is_setaffinity_pending", "15399": "irqd_is_wakeup_armed", "15400": "irqd_is_wakeup_set", "15401": "irqd_level", "15402": "irqd_move_pcntxt", "15403": "irqd_no_balancing", "15404": "irqd_per_cpu", "15405": "irqd_set", "15406": "irqd_set_move_pending", "15407": "irqd_setaffinity_pending", "15408": "irqd_trigger_mask", "15409": "irqd_wakeup_armed", "15410": "irqd_wakeup_state", "15411": "irqf_cond_suspend", "15412": "irqf_early_resume", "15413": "irqf_force_resume", "15414": "irqf_irqpoll", "15415": "irqf_modify_mask", "15416": "irqf_no_suspend", "15417": "irqf_no_thread", "15418": "irqf_nobalancing", "15419": "irqf_oneshot", "15420": "irqf_percpu", "15421": "irqf_probe_shared", "15422": "irqf_shared", "15423": "irqf_trigger_mask", "15424": "irqfixup", "15425": "irqfixup_setup", "15426": "irqflags", "15427": "irqpoll_setup", "15428": "irqreader", "15429": "irqreturn_t", "15430": "irqs", "15431": "irqs_autodetect", "15432": "irqs_disabled", "15433": "irqs_disabled_flags", "15434": "irqs_inprogress", "15435": "irqs_masked", "15436": "irqs_off", "15437": "irqs_oneshot", "15438": "irqs_pending", "15439": "irqs_per_chip", "15440": "irqs_poll_inprogress", "15441": "irqs_replay", "15442": "irqs_resend", "15443": "irqs_spurious_disabled", "15444": "irqs_sum", "15445": "irqs_suspended", "15446": "irqs_unhandled", "15447": "irqs_waiting", "15448": "irqsafe", "15449": "irqsoff_busy", "15450": "irqsoff_flag_changed", "15451": "irqsoff_function_set", "15452": "irqsoff_graph_entry", "15453": "irqsoff_graph_return", "15454": "irqsoff_print_header", "15455": "irqsoff_print_line", "15456": "irqsoff_set_flag", "15457": "irqsoff_trace", "15458": "irqsoff_trace_close", "15459": "irqsoff_trace_open", "15460": "irqsoff_tracer", "15461": "irqsoff_tracer_call", "15462": "irqsoff_tracer_init", "15463": "irqsoff_tracer_reset", "15464": "irqsoff_tracer_start", "15465": "irqsoff_tracer_stop", "15466": "irqtf_affinity", "15467": "irqtf_forced_thread", "15468": "irqtf_runthread", "15469": "irqtf_warned", "15470": "irqtime_account_hi_update", "15471": "irqtime_account_idle_ticks", "15472": "irqtime_account_irq", "15473": "irqtime_account_process_tick", "15474": "irqtime_account_si_update", "15475": "is", "15476": "is_active", "15477": "is_add", "15478": "is_affinity_mask_valid", "15479": "is_ancestor", "15480": "is_arm_mapping_symbol", "15481": "is_audit_feature_set", "15482": "is_cgroup_event", "15483": "is_chained", "15484": "is_chained_work", "15485": "is_child_reaper", "15486": "is_child_subreaper", "15487": "is_compat_task", "15488": "is_core_symbol", "15489": "is_cpu_exclusive", "15490": "is_cpuset_online", "15491": "is_cpuset_subset", "15492": "is_current_pgrp_orphaned", "15493": "is_delete", "15494": "is_dwork", "15495": "is_early", "15496": "is_empty", "15497": "is_enabled", "15498": "is_err", "15499": "is_err_or_null", "15500": "is_err_value", "15501": "is_error_status", "15502": "is_event_hup", "15503": "is_exported", "15504": "is_ftrace_trampoline", "15505": "is_function_field", "15506": "is_global", "15507": "is_global_init", "15508": "is_good_name", "15509": "is_gpl", "15510": "is_graph", "15511": "is_hardlockup", "15512": "is_highmem", "15513": "is_idle_task", "15514": "is_kernel_event", "15515": "is_kernel_inittext", "15516": "is_kprobe", "15517": "is_ksym_addr", "15518": "is_kthread_should_stop", "15519": "is_last", "15520": "is_legal_op", "15521": "is_mem_exclusive", "15522": "is_mem_hardwall", "15523": "is_memory_migrate", "15524": "is_module_address", "15525": "is_module_percpu_address", "15526": "is_module_text_address", "15527": "is_op_char", "15528": "is_orphaned_child", "15529": "is_power_of_2", "15530": "is_precedence_lower", "15531": "is_ready", "15532": "is_register", "15533": "is_ret", "15534": "is_ret_probe", "15535": "is_return", "15536": "is_same_group", "15537": "is_sampling_event", "15538": "is_sched_load_balance", "15539": "is_si_special", "15540": "is_signed", "15541": "is_signed_type", "15542": "is_singleblock", "15543": "is_singlestep", "15544": "is_softlockup", "15545": "is_software_event", "15546": "is_spread_page", "15547": "is_spread_slab", "15548": "is_state_visited", "15549": "is_string_field", "15550": "is_swbp", "15551": "is_swbp_insn", "15552": "is_sysemu_singlestep", "15553": "is_sysidle_rcu_state", "15554": "is_thread_group", "15555": "is_tracing_stopped", "15556": "is_trap_at_addr", "15557": "is_trap_insn", "15558": "is_valid", "15559": "is_valid_access", "15560": "is_vm_hugetlb_page", "15561": "isadd", "15562": "isalnum", "15563": "isalpha", "15564": "isdigit", "15565": "isidle", "15566": "ismax", "15567": "isolated_cpu_setup", "15568": "isprint", "15569": "ispunct", "15570": "isspace", "15571": "istate", "15572": "it", "15573": "it_clock", "15574": "it_id", "15575": "it_id_not_set", "15576": "it_id_set", "15577": "it_interval", "15578": "it_lock", "15579": "it_new", "15580": "it_old", "15581": "it_overrun", "15582": "it_overrun_last", "15583": "it_pid", "15584": "it_real_fn", "15585": "it_real_incr", "15586": "it_requeue_pending", "15587": "it_sigev_notify", "15588": "it_signal", "15589": "it_value", "15590": "item", "15591": "items", "15592": "iter", "15593": "iter_end", "15594": "iter_event", "15595": "iter_flags", "15596": "iter_start", "15597": "iter_stop", "15598": "iter_stride", "15599": "iterate_chain_key", "15600": "iterate_mounts", "15601": "iterk", "15602": "iters", "15603": "itimer_delete", "15604": "itimer_get_remtime", "15605": "itimer_prof", "15606": "itimer_real", "15607": "itimer_virtual", "15608": "itimerspec", "15609": "itimerval", "15610": "itype", "15611": "iv", "15612": "ixol", "15613": "j", "15614": "j1", "15615": "jea", "15616": "jeb", "15617": "jf_left", "15618": "jhash", "15619": "jhash_1word", "15620": "jif", "15621": "jiffies", "15622": "jiffies_64", "15623": "jiffies_64_to_clock_t", "15624": "jiffies_force_qs", "15625": "jiffies_lock", "15626": "jiffies_resched", "15627": "jiffies_snap", "15628": "jiffies_stall", "15629": "jiffies_till_first_fqs", "15630": "jiffies_till_next_fqs", "15631": "jiffies_till_sched_qs", "15632": "jiffies_to_ahz", "15633": "jiffies_to_clock_t", "15634": "jiffies_to_cputime", "15635": "jiffies_to_msecs", "15636": "jiffies_to_nsecs", "15637": "jiffies_to_timespec", "15638": "jiffies_to_timeval", "15639": "jiffies_to_usecs", "15640": "jiffy", "15641": "jit_keyring", "15642": "jitcnt", "15643": "jited", "15644": "jitter", "15645": "jlm", "15646": "jmp_call", "15647": "jmp_exit", "15648": "jmp_ja", "15649": "jmp_jeq_k", "15650": "jmp_jeq_x", "15651": "jmp_jge_k", "15652": "jmp_jge_x", "15653": "jmp_jgt_k", "15654": "jmp_jgt_x", "15655": "jmp_jne_k", "15656": "jmp_jne_x", "15657": "jmp_jset_k", "15658": "jmp_jset_x", "15659": "jmp_jsge_k", "15660": "jmp_jsge_x", "15661": "jmp_jsgt_k", "15662": "jmp_jsgt_x", "15663": "jobctl", "15664": "jobctl_listening", "15665": "jobctl_pending_mask", "15666": "jobctl_stop_consume", "15667": "jobctl_stop_dequeued", "15668": "jobctl_stop_pending", "15669": "jobctl_stop_sigmask", "15670": "jobctl_trap_mask", "15671": "jobctl_trap_notify", "15672": "jobctl_trap_stop", "15673": "jobctl_trapping", "15674": "jobctl_trapping_bit", "15675": "join", "15676": "jp", "15677": "jph_val", "15678": "jprobe", "15679": "jps", "15680": "js", "15681": "jump_entries", "15682": "jump_entry", "15683": "jump_label_add_module", "15684": "jump_label_apply_nops", "15685": "jump_label_cmp", "15686": "jump_label_del_module", "15687": "jump_label_disable", "15688": "jump_label_enable", "15689": "jump_label_get_branch_default", "15690": "jump_label_get_entries", "15691": "jump_label_init", "15692": "jump_label_init_module", "15693": "jump_label_invalidate_module_init", "15694": "jump_label_lock", "15695": "jump_label_module_nb", "15696": "jump_label_module_notify", "15697": "jump_label_mutex", "15698": "jump_label_nop_size", "15699": "jump_label_rate_limit", "15700": "jump_label_sort_entries", "15701": "jump_label_t", "15702": "jump_label_text_reserved", "15703": "jump_label_type", "15704": "jump_label_unlock", "15705": "jump_label_update", "15706": "jump_label_update_timeout", "15707": "jumptable", "15708": "just", "15709": "k", "15710": "k_clock", "15711": "k_getrusage", "15712": "k_itimer", "15713": "k_itimer_rcu_free", "15714": "k_sigaction", "15715": "ka", "15716": "ka_restorer", "15717": "kaddr", "15718": "kallsym_iter", "15719": "kallsyms_addresses", "15720": "kallsyms_expand_symbol", "15721": "kallsyms_get_symbol_type", "15722": "kallsyms_init", "15723": "kallsyms_lookup", "15724": "kallsyms_lookup_name", "15725": "kallsyms_lookup_size_offset", "15726": "kallsyms_markers", "15727": "kallsyms_names", "15728": "kallsyms_num_syms", "15729": "kallsyms_on_each_symbol", "15730": "kallsyms_op", "15731": "kallsyms_open", "15732": "kallsyms_operations", "15733": "kallsyms_symbol_next", "15734": "kallsyms_token_index", "15735": "kallsyms_token_table", "15736": "kasprintf", "15737": "kauditd_send_multicast_skb", "15738": "kauditd_send_skb", "15739": "kauditd_task", "15740": "kauditd_thread", "15741": "kauditd_wait", "15742": "kb", "15743": "kb_mask", "15744": "kbasename", "15745": "kbuf", "15746": "kbuild_modname", "15747": "kc", "15748": "kcalloc", "15749": "kcmp", "15750": "kcmp_cookies_init", "15751": "kcmp_file", "15752": "kcmp_files", "15753": "kcmp_fs", "15754": "kcmp_io", "15755": "kcmp_lock", "15756": "kcmp_ptr", "15757": "kcmp_sighand", "15758": "kcmp_sysvsem", "15759": "kcmp_type", "15760": "kcmp_types", "15761": "kcmp_unlock", "15762": "kcmp_vm", "15763": "kcpustat", "15764": "kcpustat_this_cpu", "15765": "kdata", "15766": "kdb", "15767": "kdb_argcount", "15768": "kdb_badaddr", "15769": "kdb_badcpunum", "15770": "kdb_badint", "15771": "kdb_badlength", "15772": "kdb_badradix", "15773": "kdb_badreg", "15774": "kdb_badwidth", "15775": "kdb_base_cmd_max", "15776": "kdb_base_commands", "15777": "kdb_bc", "15778": "kdb_bfd_vma_fmt", "15779": "kdb_bfd_vma_fmt0", "15780": "kdb_bp", "15781": "kdb_bp_install", "15782": "kdb_bp_remove", "15783": "kdb_bp_t", "15784": "kdb_bptnotfound", "15785": "kdb_bptype", "15786": "kdb_breakpoints", "15787": "kdb_bt", "15788": "kdb_bt1", "15789": "kdb_check_flags", "15790": "kdb_check_regs", "15791": "kdb_cmd_cpu", "15792": "kdb_cmd_enabled", "15793": "kdb_cmd_go", "15794": "kdb_cmd_history_count", "15795": "kdb_cmd_init", "15796": "kdb_cmd_kgdb", "15797": "kdb_cmd_ss", "15798": "kdb_cmdflags_t", "15799": "kdb_cmds", "15800": "kdb_command_extend", "15801": "kdb_commands", "15802": "kdb_common_deinit_state", "15803": "kdb_common_init_state", "15804": "kdb_continue_catastrophic", "15805": "kdb_cpu", "15806": "kdb_curr_task", "15807": "kdb_current", "15808": "kdb_current_regs", "15809": "kdb_current_task", "15810": "kdb_db_bpt", "15811": "kdb_db_nobpt", "15812": "kdb_db_ss", "15813": "kdb_db_ssbpt", "15814": "kdb_dbtrap_t", "15815": "kdb_debug", "15816": "kdb_debug_flag_", "15817": "kdb_debug_flag_ar", "15818": "kdb_debug_flag_ara", "15819": "kdb_debug_flag_bb", "15820": "kdb_debug_flag_bb_summ", "15821": "kdb_debug_flag_bp", "15822": "kdb_debug_flag_mask", "15823": "kdb_debug_flag_shift", "15824": "kdb_debug_flag_state", "15825": "kdb_debug_state", "15826": "kdb_defcmd", "15827": "kdb_defcmd2", "15828": "kdb_diemsg", "15829": "kdb_disable_nmi", "15830": "kdb_dmesg", "15831": "kdb_do_each_thread", "15832": "kdb_dumpregs", "15833": "kdb_dupbpt", "15834": "kdb_ef", "15835": "kdb_enable_always_safe", "15836": "kdb_enable_always_safe_no_args", "15837": "kdb_enable_flow_ctrl", "15838": "kdb_enable_inspect", "15839": "kdb_enable_inspect_no_args", "15840": "kdb_enable_mem_read", "15841": "kdb_enable_mem_write", "15842": "kdb_enable_reboot", "15843": "kdb_enable_reg_read", "15844": "kdb_enable_reg_write", "15845": "kdb_enable_signal", "15846": "kdb_env", "15847": "kdb_event", "15848": "kdb_exec_defcmd", "15849": "kdb_flag", "15850": "kdb_flag_clear", "15851": "kdb_flag_set", "15852": "kdb_flags", "15853": "kdb_flags_index", "15854": "kdb_flags_stack", "15855": "kdb_ftdump", "15856": "kdb_func_t", "15857": "kdb_gdb_state_pass", "15858": "kdb_getarea", "15859": "kdb_getarea_size", "15860": "kdb_getphys", "15861": "kdb_getphysword", "15862": "kdb_getstr", "15863": "kdb_getword", "15864": "kdb_gmtime", "15865": "kdb_go", "15866": "kdb_go_count", "15867": "kdb_grep_help", "15868": "kdb_grep_leading", "15869": "kdb_grep_string", "15870": "kdb_grep_strlen", "15871": "kdb_grep_trailing", "15872": "kdb_grepping_flag", "15873": "kdb_handle_bp", "15874": "kdb_help", "15875": "kdb_init", "15876": "kdb_init_early", "15877": "kdb_init_full", "15878": "kdb_init_lvl", "15879": "kdb_initbptab", "15880": "kdb_initial_cpu", "15881": "kdb_inittab", "15882": "kdb_kgdb", "15883": "kdb_kill", "15884": "kdb_ks", "15885": "kdb_local", "15886": "kdb_lsmod", "15887": "kdb_machreg_fmt", "15888": "kdb_machreg_fmt0", "15889": "kdb_main_loop", "15890": "kdb_max_commands", "15891": "kdb_maxbpt", "15892": "kdb_md", "15893": "kdb_md_line", "15894": "kdb_mdr", "15895": "kdb_mm", "15896": "kdb_name_table", "15897": "kdb_nextline", "15898": "kdb_not_initialized", "15899": "kdb_notfound", "15900": "kdb_notimp", "15901": "kdb_parse", "15902": "kdb_parsebp", "15903": "kdb_pcu", "15904": "kdb_per_cpu", "15905": "kdb_pid", "15906": "kdb_poll_funcs", "15907": "kdb_poll_idx", "15908": "kdb_prev_t", "15909": "kdb_print_nameval", "15910": "kdb_printbp", "15911": "kdb_printf", "15912": "kdb_private", "15913": "kdb_process_cpu", "15914": "kdb_prompt_str", "15915": "kdb_ps", "15916": "kdb_ps1", "15917": "kdb_ps_suppressed", "15918": "kdb_putarea_size", "15919": "kdb_putword", "15920": "kdb_rd", "15921": "kdb_reason_break", "15922": "kdb_reason_debug", "15923": "kdb_reason_enter", "15924": "kdb_reason_enter_slave", "15925": "kdb_reason_keyboard", "15926": "kdb_reason_nmi", "15927": "kdb_reason_oops", "15928": "kdb_reason_recurse", "15929": "kdb_reason_sstep", "15930": "kdb_reason_switch", "15931": "kdb_reason_system_nmi", "15932": "kdb_reason_t", "15933": "kdb_reboot", "15934": "kdb_register", "15935": "kdb_register_flags", "15936": "kdb_repeat_no_args", "15937": "kdb_repeat_with_args", "15938": "kdb_restore_flags", "15939": "kdb_rm", "15940": "kdb_rwtypes", "15941": "kdb_save_flags", "15942": "kdb_send_sig_info", "15943": "kdb_set", "15944": "kdb_set_current_task", "15945": "kdb_setsinglestep", "15946": "kdb_show_stack", "15947": "kdb_sp_default", "15948": "kdb_sp_newline", "15949": "kdb_sp_paren", "15950": "kdb_sp_spacea", "15951": "kdb_sp_spaceb", "15952": "kdb_sp_symsize", "15953": "kdb_sp_value", "15954": "kdb_sr", "15955": "kdb_ss", "15956": "kdb_state", "15957": "kdb_state_clear", "15958": "kdb_state_set", "15959": "kdb_strdup", "15960": "kdb_stub", "15961": "kdb_summary", "15962": "kdb_symbol_print", "15963": "kdb_symtab_t", "15964": "kdb_sysinfo", "15965": "kdb_task_has_cpu", "15966": "kdb_task_state", "15967": "kdb_task_state_char", "15968": "kdb_task_state_string", "15969": "kdb_tm", "15970": "kdb_toomanybpt", "15971": "kdb_trap_printk", "15972": "kdb_tsk", "15973": "kdb_tskregs", "15974": "kdb_unregister", "15975": "kdb_walk_kallsyms", "15976": "kdb_walk_kallsyms_iter", "15977": "kdb_while_each_thread", "15978": "kdb_word_size", "15979": "kdbcmd_bc", "15980": "kdbcmd_bd", "15981": "kdbcmd_be", "15982": "kdbdebug", "15983": "kdbgetaddrarg", "15984": "kdbgetenv", "15985": "kdbgetintenv", "15986": "kdbgetsymval", "15987": "kdbgetu64arg", "15988": "kdbgetularg", "15989": "kdbnearsym", "15990": "kdbnearsym_cleanup", "15991": "kdbtab_t", "15992": "kdebug", "15993": "keep_bootcon", "15994": "keep_regs", "15995": "keep_working", "15996": "kegid", "15997": "kern_acct", "15998": "kern_alert", "15999": "kern_bootloader_type", "16000": "kern_cadpid", "16001": "kern_compat_log", "16002": "kern_cont", "16003": "kern_core_pattern", "16004": "kern_core_uses_pid", "16005": "kern_crit", "16006": "kern_ctlaltdel", "16007": "kern_debug", "16008": "kern_default", "16009": "kern_domainname", "16010": "kern_emerg", "16011": "kern_err", "16012": "kern_hotplug", "16013": "kern_hppa_pwrsw", "16014": "kern_hppa_unaligned", "16015": "kern_ia64_unaligned", "16016": "kern_ieee_emulation_warnings", "16017": "kern_info", "16018": "kern_ipc_perm", "16019": "kern_max_lock_depth", "16020": "kern_max_threads", "16021": "kern_modprobe", "16022": "kern_msgmax", "16023": "kern_msgmnb", "16024": "kern_msgmni", "16025": "kern_ngroups_max", "16026": "kern_nodename", "16027": "kern_osrelease", "16028": "kern_ostype", "16029": "kern_overflowgid", "16030": "kern_overflowuid", "16031": "kern_panic", "16032": "kern_panic_on_nmi", "16033": "kern_panic_on_oops", "16034": "kern_panic_on_warn", "16035": "kern_path", "16036": "kern_path_locked", "16037": "kern_pidmax", "16038": "kern_ppc_powersave_nap", "16039": "kern_printk", "16040": "kern_printk_ratelimit", "16041": "kern_printk_ratelimit_burst", "16042": "kern_pty", "16043": "kern_random", "16044": "kern_randomize", "16045": "kern_realrootdev", "16046": "kern_s390_user_debug_logging", "16047": "kern_sem", "16048": "kern_setuid_dumpable", "16049": "kern_sg_big_buff", "16050": "kern_shmall", "16051": "kern_shmmax", "16052": "kern_shmmni", "16053": "kern_sparc_reboot", "16054": "kern_sparc_scons_pwroff", "16055": "kern_sparc_stop_a", "16056": "kern_spin_retry", "16057": "kern_sysrq", "16058": "kern_table", "16059": "kern_unknown_nmi_panic", "16060": "kern_version", "16061": "kern_warning", "16062": "kernel", "16063": "kernel_add_sysfs_param", "16064": "kernel_attr_group", "16065": "kernel_attr_ro", "16066": "kernel_attr_rw", "16067": "kernel_buf", "16068": "kernel_buf_len", "16069": "kernel_cap_t", "16070": "kernel_config_data", "16071": "kernel_config_data_size", "16072": "kernel_cpustat", "16073": "kernel_ds", "16074": "kernel_fd", "16075": "kernel_halt", "16076": "kernel_kexec", "16077": "kernel_kobj", "16078": "kernel_param", "16079": "kernel_param_fl_unsafe", "16080": "kernel_param_ops", "16081": "kernel_param_ops_fl_noarg", "16082": "kernel_power_off", "16083": "kernel_read", "16084": "kernel_restart", "16085": "kernel_restart_prepare", "16086": "kernel_shutdown_prepare", "16087": "kernel_sigaction", "16088": "kernel_stack", "16089": "kernel_stack_pointer", "16090": "kernel_stat", "16091": "kernel_symbol", "16092": "kernel_text_address", "16093": "kernel_thread", "16094": "kernel_tp", "16095": "kernel_write", "16096": "kernfs_activate", "16097": "kernfs_break_active_protection", "16098": "kernfs_create_dir", "16099": "kernfs_create_root", "16100": "kernfs_destroy_root", "16101": "kernfs_dir", "16102": "kernfs_get", "16103": "kernfs_kill_sb", "16104": "kernfs_mount", "16105": "kernfs_node", "16106": "kernfs_node_from_dentry", "16107": "kernfs_notify", "16108": "kernfs_open_file", "16109": "kernfs_ops", "16110": "kernfs_pin_sb", "16111": "kernfs_put", "16112": "kernfs_remove", "16113": "kernfs_remove_by_name", "16114": "kernfs_rename", "16115": "kernfs_root", "16116": "kernfs_root_create_deactivated", "16117": "kernfs_root_from_sb", "16118": "kernfs_setattr", "16119": "kernfs_syscall_ops", "16120": "kernfs_type", "16121": "kernfs_unbreak_active_protection", "16122": "keuid", "16123": "kevent", "16124": "kexec_add_buffer", "16125": "kexec_apply_relocations", "16126": "kexec_arch", "16127": "kexec_arch_default", "16128": "kexec_arch_mask", "16129": "kexec_buf", "16130": "kexec_calculate_store_digests", "16131": "kexec_control_memory_limit", "16132": "kexec_control_page_size", "16133": "kexec_core_note_name", "16134": "kexec_crash_control_memory_limit", "16135": "kexec_crash_image", "16136": "kexec_crash_loaded", "16137": "kexec_crash_loaded_show", "16138": "kexec_crash_mem_align", "16139": "kexec_crash_size_show", "16140": "kexec_crash_size_store", "16141": "kexec_destination_memory_limit", "16142": "kexec_file_no_initramfs", "16143": "kexec_file_on_crash", "16144": "kexec_flags", "16145": "kexec_flush_icache_page", "16146": "kexec_image", "16147": "kexec_in_progress", "16148": "kexec_load", "16149": "kexec_load_disabled", "16150": "kexec_load_purgatory", "16151": "kexec_loaded", "16152": "kexec_loaded_show", "16153": "kexec_mutex", "16154": "kexec_on_crash", "16155": "kexec_on_panic", "16156": "kexec_preserve_context", "16157": "kexec_purgatory", "16158": "kexec_purgatory_find_symbol", "16159": "kexec_purgatory_get_set_symbol", "16160": "kexec_purgatory_get_symbol_addr", "16161": "kexec_purgatory_size", "16162": "kexec_segment", "16163": "kexec_segment_max", "16164": "kexec_sha_region", "16165": "kexec_should_crash", "16166": "kexec_source_memory_limit", "16167": "kexec_type_crash", "16168": "kexec_type_default", "16169": "key", "16170": "key2", "16171": "key_alloc_not_in_quota", "16172": "key_alloc_trusted", "16173": "key_create_or_update", "16174": "key_flag_builtin", "16175": "key_flag_trusted_only", "16176": "key_fsgid_changed", "16177": "key_fsuid_changed", "16178": "key_get", "16179": "key_id", "16180": "key_id_len", "16181": "key_len", "16182": "key_name", "16183": "key_pos_all", "16184": "key_pos_setattr", "16185": "key_put", "16186": "key_ref_put", "16187": "key_ref_t", "16188": "key_ref_to_ptr", "16189": "key_reqkey_defl_thread_keyring", "16190": "key_serial", "16191": "key_size", "16192": "key_sysctls", "16193": "key_type_asymmetric", "16194": "key_usr_read", "16195": "key_usr_search", "16196": "key_usr_view", "16197": "keyboard", "16198": "keyring_alloc", "16199": "keyring_search", "16200": "kf_ops", "16201": "kf_root", "16202": "kfree", "16203": "kfree_call_rcu", "16204": "kfree_rcu", "16205": "kfree_skb", "16206": "kgdb", "16207": "kgdb_active", "16208": "kgdb_arch_exit", "16209": "kgdb_arch_handle_exception", "16210": "kgdb_arch_init", "16211": "kgdb_arch_late", "16212": "kgdb_arch_pc", "16213": "kgdb_arch_remove_breakpoint", "16214": "kgdb_arch_set_breakpoint", "16215": "kgdb_arch_set_pc", "16216": "kgdb_bkpt", "16217": "kgdb_break", "16218": "kgdb_break_asap", "16219": "kgdb_break_tasklet_var", "16220": "kgdb_breakpoint", "16221": "kgdb_con_registered", "16222": "kgdb_connected", "16223": "kgdb_console_write", "16224": "kgdb_contthread", "16225": "kgdb_cpu_doing_single_step", "16226": "kgdb_cpu_enter", "16227": "kgdb_do_roundup", "16228": "kgdb_ebin2mem", "16229": "kgdb_exit", "16230": "kgdb_flush_swbreak_addr", "16231": "kgdb_handle_exception", "16232": "kgdb_hex2long", "16233": "kgdb_hex2mem", "16234": "kgdb_hw_breakpoint", "16235": "kgdb_info", "16236": "kgdb_initial_breakpoint", "16237": "kgdb_io", "16238": "kgdb_io_module_registered", "16239": "kgdb_io_ready", "16240": "kgdb_max_breakpoints", "16241": "kgdb_max_thread_query", "16242": "kgdb_mem2hex", "16243": "kgdb_nmicallback", "16244": "kgdb_nmicallin", "16245": "kgdb_panic_event", "16246": "kgdb_panic_event_nb", "16247": "kgdb_reenter_check", "16248": "kgdb_register_callbacks", "16249": "kgdb_register_io_module", "16250": "kgdb_registration_lock", "16251": "kgdb_restore", "16252": "kgdb_roundup_cpus", "16253": "kgdb_schedule_breakpoint", "16254": "kgdb_setting_breakpoint", "16255": "kgdb_single_step", "16256": "kgdb_skipexception", "16257": "kgdb_sstep_pid", "16258": "kgdb_state", "16259": "kgdb_tasklet_bpt", "16260": "kgdb_tasklet_breakpoint", "16261": "kgdb_trans", "16262": "kgdb_unregister_callbacks", "16263": "kgdb_unregister_io_module", "16264": "kgdb_use_con", "16265": "kgdb_usethread", "16266": "kgdb_usethreadid", "16267": "kgdb_validate_break_address", "16268": "kgdb_var", "16269": "kgdbcons", "16270": "kgdbreboot", "16271": "kgid", "16272": "kgid_has_mapping", "16273": "kgid_t", "16274": "kgidt_init", "16275": "khelper_wq", "16276": "khugepaged_exit", "16277": "khugepaged_fork", "16278": "kick", "16279": "kick_all_cpus_sync", "16280": "kick_kprobe_optimizer", "16281": "kick_process", "16282": "kill", "16283": "kill_as_cred_perm", "16284": "kill_css", "16285": "kill_fasync", "16286": "kill_ftrace_graph", "16287": "kill_kprobe", "16288": "kill_ok_by_cred", "16289": "kill_optimized_kprobe", "16290": "kill_pgrp", "16291": "kill_pid", "16292": "kill_pid_info", "16293": "kill_pid_info_as_cred", "16294": "kill_proc_info", "16295": "kill_rules", "16296": "kill_sb", "16297": "kill_something_info", "16298": "kill_test", "16299": "killed", "16300": "killed_trees", "16301": "killing", "16302": "kimage", "16303": "kimage_add_entry", "16304": "kimage_add_page", "16305": "kimage_alloc_control_pages", "16306": "kimage_alloc_crash_control_pages", "16307": "kimage_alloc_init", "16308": "kimage_alloc_normal_control_pages", "16309": "kimage_alloc_page", "16310": "kimage_alloc_pages", "16311": "kimage_dst_used", "16312": "kimage_entry_t", "16313": "kimage_file_alloc_init", "16314": "kimage_file_post_load_cleanup", "16315": "kimage_file_prepare_segments", "16316": "kimage_free", "16317": "kimage_free_entry", "16318": "kimage_free_extra_pages", "16319": "kimage_free_page_list", "16320": "kimage_free_pages", "16321": "kimage_is_destination_range", "16322": "kimage_load_crash_segment", "16323": "kimage_load_normal_segment", "16324": "kimage_load_segment", "16325": "kimage_no_dest", "16326": "kimage_set_destination", "16327": "kimage_terminate", "16328": "kin", "16329": "kiov", "16330": "kip", "16331": "kit", "16332": "kj", "16333": "kloginuid", "16334": "klp_alive", "16335": "klp_arch_set_pc", "16336": "klp_check_compiler_support", "16337": "klp_disable_func", "16338": "klp_disable_object", "16339": "klp_disable_patch", "16340": "klp_disabled", "16341": "klp_enable_func", "16342": "klp_enable_object", "16343": "klp_enable_patch", "16344": "klp_enabled", "16345": "klp_find_arg", "16346": "klp_find_callback", "16347": "klp_find_external_symbol", "16348": "klp_find_object_module", "16349": "klp_find_object_symbol", "16350": "klp_find_ops", "16351": "klp_find_verify_func_addr", "16352": "klp_free_funcs_limited", "16353": "klp_free_object_loaded", "16354": "klp_free_objects_limited", "16355": "klp_free_patch", "16356": "klp_ftrace_handler", "16357": "klp_func", "16358": "klp_init", "16359": "klp_init_func", "16360": "klp_init_object", "16361": "klp_init_object_loaded", "16362": "klp_init_patch", "16363": "klp_initialized", "16364": "klp_is_module", "16365": "klp_is_object_loaded", "16366": "klp_is_patch_registered", "16367": "klp_kobj_release_func", "16368": "klp_kobj_release_patch", "16369": "klp_ktype_func", "16370": "klp_ktype_patch", "16371": "klp_module_nb", "16372": "klp_module_notify", "16373": "klp_module_notify_coming", "16374": "klp_module_notify_going", "16375": "klp_mutex", "16376": "klp_object", "16377": "klp_ops", "16378": "klp_patch", "16379": "klp_patch_attrs", "16380": "klp_patches", "16381": "klp_register_patch", "16382": "klp_reloc", "16383": "klp_root_kobj", "16384": "klp_unregister_patch", "16385": "klp_verify_args", "16386": "klp_verify_callback", "16387": "klp_verify_vmlinux_symbol", "16388": "klp_write_module_reloc", "16389": "klp_write_object_relocations", "16390": "km", "16391": "kmalloc", "16392": "kmalloc_array", "16393": "kmalloc_node", "16394": "kmalloc_parameter", "16395": "kmalloced_param", "16396": "kmalloced_params", "16397": "kmap", "16398": "kmap_atomic", "16399": "kmem", "16400": "kmem_cache", "16401": "kmem_cache_alloc", "16402": "kmem_cache_alloc_node", "16403": "kmem_cache_create", "16404": "kmem_cache_free", "16405": "kmem_cache_zalloc", "16406": "kmemcheck_annotate_bitfield", "16407": "kmemcheck_enabled", "16408": "kmemcheck_mark_initialized", "16409": "kmemdup", "16410": "kmemleak_ignore", "16411": "kmemleak_load_module", "16412": "kmemleak_not_leak", "16413": "kmemleak_scan_area", "16414": "kmin", "16415": "kmod_concurrent", "16416": "kmod_loop_msg", "16417": "kmod_path_len", "16418": "kmsg_dump", "16419": "kmsg_dump_emerg", "16420": "kmsg_dump_halt", "16421": "kmsg_dump_poweroff", "16422": "kmsg_dump_restart", "16423": "kn", "16424": "knt1", "16425": "knt1_size", "16426": "kobj", "16427": "kobj2pinst", "16428": "kobj_add", "16429": "kobj_attribute", "16430": "kobj_completion", "16431": "kobj_sysfs_ops", "16432": "kobj_type", "16433": "kobject", "16434": "kobject_action", "16435": "kobject_action_type", "16436": "kobject_create_and_add", "16437": "kobject_get", "16438": "kobject_init", "16439": "kobject_init_and_add", "16440": "kobject_put", "16441": "kobject_uevent", "16442": "koldloginuid", "16443": "kout", "16444": "kp", "16445": "kp_post_handler", "16446": "kp_pre_handler", "16447": "kpage", "16448": "kparam", "16449": "kparam_array", "16450": "kparam_string", "16451": "kprobe", "16452": "kprobe_addr", "16453": "kprobe_aggrprobe", "16454": "kprobe_blacklist", "16455": "kprobe_blacklist_entry", "16456": "kprobe_blacklist_open", "16457": "kprobe_blacklist_seq_next", "16458": "kprobe_blacklist_seq_ops", "16459": "kprobe_blacklist_seq_show", "16460": "kprobe_blacklist_seq_start", "16461": "kprobe_disabled", "16462": "kprobe_disarmed", "16463": "kprobe_dispatcher", "16464": "kprobe_event_define_fields", "16465": "kprobe_event_system", "16466": "kprobe_events_ops", "16467": "kprobe_exceptions_nb", "16468": "kprobe_exceptions_notify", "16469": "kprobe_flag_disabled", "16470": "kprobe_flag_ftrace", "16471": "kprobe_flag_gone", "16472": "kprobe_flag_optimized", "16473": "kprobe_flush_task", "16474": "kprobe_ftrace", "16475": "kprobe_ftrace_enabled", "16476": "kprobe_ftrace_handler", "16477": "kprobe_ftrace_ops", "16478": "kprobe_funcs", "16479": "kprobe_gone", "16480": "kprobe_hash_bits", "16481": "kprobe_insn_cache", "16482": "kprobe_insn_page", "16483": "kprobe_insn_page_size", "16484": "kprobe_insn_slots", "16485": "kprobe_instance", "16486": "kprobe_lookup_name", "16487": "kprobe_module_nb", "16488": "kprobe_mutex", "16489": "kprobe_opcode_t", "16490": "kprobe_optimized", "16491": "kprobe_optimizer", "16492": "kprobe_optinsn_slots", "16493": "kprobe_optready", "16494": "kprobe_perf_func", "16495": "kprobe_profile_ops", "16496": "kprobe_prog_func_proto", "16497": "kprobe_prog_is_valid_access", "16498": "kprobe_prog_ops", "16499": "kprobe_queued", "16500": "kprobe_register", "16501": "kprobe_seq_next", "16502": "kprobe_seq_start", "16503": "kprobe_seq_stop", "16504": "kprobe_slot_state", "16505": "kprobe_table", "16506": "kprobe_table_size", "16507": "kprobe_target", "16508": "kprobe_tl", "16509": "kprobe_trace_entry_head", "16510": "kprobe_trace_func", "16511": "kprobe_trace_self_tests_init", "16512": "kprobe_trace_selftest_target", "16513": "kprobe_type", "16514": "kprobe_unused", "16515": "kprobes", "16516": "kprobes_all_disarmed", "16517": "kprobes_allow_optimization", "16518": "kprobes_fetch_type_table", "16519": "kprobes_inc_nmissed_count", "16520": "kprobes_initialized", "16521": "kprobes_module_callback", "16522": "kprobes_open", "16523": "kprobes_seq_ops", "16524": "kprojid", "16525": "kprojid_t", "16526": "kprojidt_init", "16527": "kps", "16528": "kptr_obfuscate", "16529": "kptr_restrict", "16530": "krealloc", "16531": "kref", "16532": "kref_get", "16533": "kref_init", "16534": "kref_put", "16535": "kretprobe", "16536": "kretprobe_blacklist", "16537": "kretprobe_blacklist_size", "16538": "kretprobe_dispatcher", "16539": "kretprobe_event_define_fields", "16540": "kretprobe_funcs", "16541": "kretprobe_hash_lock", "16542": "kretprobe_hash_unlock", "16543": "kretprobe_inst_table", "16544": "kretprobe_instance", "16545": "kretprobe_perf_func", "16546": "kretprobe_table_lock", "16547": "kretprobe_table_lock_ptr", "16548": "kretprobe_table_unlock", "16549": "kretprobe_trace_entry_head", "16550": "kretprobe_trace_func", "16551": "kretprobed", "16552": "krgid", "16553": "kruid", "16554": "krule", "16555": "ks", "16556": "ks_namebuf_prev", "16557": "ksegment", "16558": "ksegments", "16559": "kset", "16560": "kset_create_and_add", "16561": "kset_exit", "16562": "kset_find_obj", "16563": "kset_uevent_ops", "16564": "ksgid", "16565": "ksig", "16566": "ksignal", "16567": "ksm_exit", "16568": "ksm_fork", "16569": "ksoftirqd", "16570": "ksoftirqd_should_run", "16571": "kstack_depth_to_print", "16572": "kstat", "16573": "kstat_incr_irq_this_cpu", "16574": "kstat_incr_irqs_this_cpu", "16575": "kstat_incr_softirqs_this_cpu", "16576": "kstat_irqs", "16577": "kstat_irqs_cpu", "16578": "kstat_irqs_usr", "16579": "kstat_softirqs_cpu", "16580": "kstatfs", "16581": "kstk_eip", "16582": "kstrdup", "16583": "kstrndup", "16584": "kstrtoint", "16585": "kstrtol", "16586": "kstrtoll", "16587": "kstrtos16", "16588": "kstrtos32_from_user", "16589": "kstrtou16", "16590": "kstrtou32", "16591": "kstrtou64", "16592": "kstrtou8", "16593": "kstrtouint", "16594": "kstrtoul", "16595": "kstrtoul_from_user", "16596": "kstrtoull", "16597": "ksuid", "16598": "ksym", "16599": "ksym_buf", "16600": "ksym_name_len", "16601": "ksym_symbol_len", "16602": "ksysfs_init", "16603": "kt", "16604": "kthread", "16605": "kthread_bind", "16606": "kthread_bits", "16607": "kthread_create", "16608": "kthread_create_info", "16609": "kthread_create_list", "16610": "kthread_create_lock", "16611": "kthread_create_on_cpu", "16612": "kthread_create_on_node", "16613": "kthread_data", "16614": "kthread_flush_work", "16615": "kthread_flush_work_fn", "16616": "kthread_freezable_should_stop", "16617": "kthread_is_parked", "16618": "kthread_is_per_cpu", "16619": "kthread_park", "16620": "kthread_parkme", "16621": "kthread_prio", "16622": "kthread_prio_in", "16623": "kthread_run", "16624": "kthread_should_park", "16625": "kthread_should_stop", "16626": "kthread_status", "16627": "kthread_stop", "16628": "kthread_unpark", "16629": "kthread_work", "16630": "kthread_work_init", "16631": "kthread_worker", "16632": "kthread_worker_fn", "16633": "kthreadd", "16634": "kthreadd_task", "16635": "ktime", "16636": "ktime_add", "16637": "ktime_add_ns", "16638": "ktime_add_safe", "16639": "ktime_divns", "16640": "ktime_equal", "16641": "ktime_get", "16642": "ktime_get_boot_ns", "16643": "ktime_get_boottime", "16644": "ktime_get_mono_fast_ns", "16645": "ktime_get_ns", "16646": "ktime_get_raw", "16647": "ktime_get_raw_fast_ns", "16648": "ktime_get_real", "16649": "ktime_get_real_seconds", "16650": "ktime_get_real_ts", "16651": "ktime_get_seconds", "16652": "ktime_get_ts", "16653": "ktime_get_ts64", "16654": "ktime_get_update_offsets_now", "16655": "ktime_get_update_offsets_tick", "16656": "ktime_get_with_offset", "16657": "ktime_low_res", "16658": "ktime_max", "16659": "ktime_mono_to_any", "16660": "ktime_now", "16661": "ktime_sec", "16662": "ktime_set", "16663": "ktime_sub", "16664": "ktime_t", "16665": "ktime_to_ns", "16666": "ktime_to_timespec", "16667": "ktime_to_timespec64", "16668": "ktime_to_timeval", "16669": "ktime_to_us", "16670": "kts", "16671": "ktv", "16672": "ktx", "16673": "ktype", "16674": "kuid", "16675": "kuid_has_mapping", "16676": "kuid_t", "16677": "kuidt_init", "16678": "kunmap", "16679": "kunmap_atomic", "16680": "kvfree", "16681": "kvm_check_and_clear_guest_paused", "16682": "kwatchdog", "16683": "kzalloc", "16684": "kzalloc_node", "16685": "l", "16686": "l1", "16687": "l1_cache_bytes", "16688": "l2", "16689": "l_new", "16690": "l_next", "16691": "l_old", "16692": "l_show", "16693": "l_start", "16694": "l_stop", "16695": "label", "16696": "lagged", "16697": "laptop_mode", "16698": "large", "16699": "largest", "16700": "last", "16701": "last_accelerate", "16702": "last_active", "16703": "last_addr", "16704": "last_advance_all", "16705": "last_arrival", "16706": "last_balance", "16707": "last_buddy", "16708": "last_bytesperword", "16709": "last_check", "16710": "last_cpupid", "16711": "last_cpupid_mask", "16712": "last_decay", "16713": "last_entry", "16714": "last_ftrace_enabled", "16715": "last_h_load_update", "16716": "last_highmem_page", "16717": "last_highmem_page_copied", "16718": "last_i", "16719": "last_index", "16720": "last_jiffies", "16721": "last_jiffies_update", "16722": "last_load_update_tick", "16723": "last_msg", "16724": "last_overrun", "16725": "last_page", "16726": "last_pid", "16727": "last_pool", "16728": "last_queued", "16729": "last_radix", "16730": "last_repeat", "16731": "last_residency", "16732": "last_runnable_update", "16733": "last_sched_tick", "16734": "last_seed", "16735": "last_siginfo", "16736": "last_stack_tracer_enabled", "16737": "last_sum_exec_runtime", "16738": "last_switch_count", "16739": "last_system", "16740": "last_task", "16741": "last_task_numa_placement", "16742": "last_tick", "16743": "last_time", "16744": "last_unhandled", "16745": "last_unloaded_module", "16746": "last_update", "16747": "last_update_time", "16748": "last_wakee", "16749": "last_write", "16750": "lasterr", "16751": "lasterr_pos", "16752": "lastp", "16753": "lastreport", "16754": "lat", "16755": "lat_flag", "16756": "lat_print_generic", "16757": "lat_print_timestamp", "16758": "latch", "16759": "late", "16760": "late_initcall", "16761": "late_initcall_sync", "16762": "latency", "16763": "latency_lock", "16764": "latency_record", "16765": "latency_record_count", "16766": "latencytop_enabled", "16767": "later_mask", "16768": "latest_idle_timestamp", "16769": "latest_ns", "16770": "layout_and_allocate", "16771": "layout_sections", "16772": "layout_symtab", "16773": "lazy", "16774": "lazy_list", "16775": "lb_balanced", "16776": "lb_bias", "16777": "lb_count", "16778": "lb_env", "16779": "lb_failed", "16780": "lb_gained", "16781": "lb_hot_gained", "16782": "lb_imbalance", "16783": "lb_min", "16784": "lb_nobusyg", "16785": "lb_nobusyq", "16786": "lbf_all_pinned", "16787": "lbf_dst_pinned", "16788": "lbf_need_break", "16789": "lbf_some_pinned", "16790": "lbuf", "16791": "lc_next", "16792": "lc_show", "16793": "lc_start", "16794": "lc_stop", "16795": "lchown16", "16796": "ld", "16797": "ld_abs_b", "16798": "ld_abs_h", "16799": "ld_abs_w", "16800": "ld_imm64_to_map_ptr", "16801": "ld_imm_dw", "16802": "ld_ind_b", "16803": "ld_ind_h", "16804": "ld_ind_w", "16805": "ld_moved", "16806": "ldata", "16807": "ldst", "16808": "ldx_mem_", "16809": "ldx_mem_b", "16810": "ldx_mem_dw", "16811": "ldx_mem_h", "16812": "ldx_mem_w", "16813": "le16_to_cpu", "16814": "leader", "16815": "leader_pid", "16816": "leaf", "16817": "leaf_cfs_rq_list", "16818": "leaf_ret", "16819": "leap", "16820": "lease_break_time", "16821": "leases_enable", "16822": "leave", "16823": "leaves", "16824": "left", "16825": "left_child", "16826": "leftmost", "16827": "legacy_cftypes", "16828": "legacy_queue", "16829": "len", "16830": "len1", "16831": "len2", "16832": "len_left", "16833": "len_or_zero", "16834": "len_ptr", "16835": "len_sent", "16836": "length", "16837": "lenp", "16838": "level", "16839": "levelcnt", "16840": "levels", "16841": "levels_needed", "16842": "levelspread", "16843": "lg", "16844": "lg_global_lock", "16845": "lg_global_unlock", "16846": "lg_local_lock", "16847": "lg_local_lock_cpu", "16848": "lg_local_unlock", "16849": "lg_local_unlock_cpu", "16850": "lg_lock_init", "16851": "lglock", "16852": "lhs", "16853": "licence", "16854": "license", "16855": "license_is_gpl_compatible", "16856": "like", "16857": "likely", "16858": "lim", "16859": "limit", "16860": "limited", "16861": "limits", "16862": "line", "16863": "linear", "16864": "linear_revmap", "16865": "lineno_checksum", "16866": "lines", "16867": "link", "16868": "link1", "16869": "link2", "16870": "link_css_set", "16871": "link_pwq", "16872": "link_target", "16873": "linked", "16874": "linked_page", "16875": "linked_page_data_size", "16876": "links", "16877": "links_to_free", "16878": "linux_binprm", "16879": "linux_reboot_cmd_cad_off", "16880": "linux_reboot_cmd_cad_on", "16881": "linux_reboot_cmd_halt", "16882": "linux_reboot_cmd_power_off", "16883": "linux_reboot_cmd_restart", "16884": "linux_reboot_cmd_restart2", "16885": "linux_reboot_magic1", "16886": "linux_reboot_magic2", "16887": "linux_reboot_magic2a", "16888": "linux_reboot_magic2b", "16889": "linux_reboot_magic2c", "16890": "linux_regs", "16891": "linux_version_code", "16892": "list", "16893": "list_add", "16894": "list_add_event", "16895": "list_add_leaf_cfs_rq", "16896": "list_add_rcu", "16897": "list_add_tail", "16898": "list_add_tail_rcu", "16899": "list_del", "16900": "list_del_event", "16901": "list_del_init", "16902": "list_del_leaf_cfs_rq", "16903": "list_del_rcu", "16904": "list_empty", "16905": "list_empty_careful", "16906": "list_entries", "16907": "list_entry", "16908": "list_entry_rcu", "16909": "list_first_entry", "16910": "list_first_entry_or_null", "16911": "list_first_or_null_rcu", "16912": "list_for_each", "16913": "list_for_each_entry", "16914": "list_for_each_entry_continue", "16915": "list_for_each_entry_rcu", "16916": "list_for_each_entry_reverse", "16917": "list_for_each_entry_safe", "16918": "list_for_each_entry_safe_continue", "16919": "list_for_each_entry_safe_from", "16920": "list_head", "16921": "list_head_init", "16922": "list_is_last", "16923": "list_is_singular", "16924": "list_move", "16925": "list_move_tail", "16926": "list_next_entry", "16927": "list_node", "16928": "list_op_pending", "16929": "list_p", "16930": "list_poison2", "16931": "list_prev_entry", "16932": "list_replace", "16933": "list_replace_init", "16934": "list_replace_rcu", "16935": "list_rotate_left", "16936": "list_splice_init", "16937": "list_splice_tail", "16938": "list_splice_tail_init", "16939": "listener", "16940": "listener_array", "16941": "listener_list", "16942": "listeners", "16943": "listnr", "16944": "live", "16945": "lld", "16946": "llist", "16947": "llist_add", "16948": "llist_del_all", "16949": "llist_empty", "16950": "llist_entry", "16951": "llist_for_each_entry", "16952": "llist_for_each_entry_safe", "16953": "llist_head", "16954": "llist_next", "16955": "llist_node", "16956": "llist_reverse_order", "16957": "llnode", "16958": "llong_max", "16959": "llong_min", "16960": "llseek", "16961": "llu", "16962": "lluns", "16963": "llx", "16964": "load", "16965": "load_a", "16966": "load_above_capacity", "16967": "load_addr", "16968": "load_avg", "16969": "load_avg_contrib", "16970": "load_avg_max", "16971": "load_avg_max_n", "16972": "load_avg_period", "16973": "load_b", "16974": "load_balance", "16975": "load_balance_mask", "16976": "load_byte", "16977": "load_contrib", "16978": "load_frac", "16979": "load_freq", "16980": "load_half", "16981": "load_header", "16982": "load_idx", "16983": "load_image", "16984": "load_image_lzo", "16985": "load_info", "16986": "load_int", "16987": "load_module", "16988": "load_per_task", "16989": "load_system_certificate_list", "16990": "load_too_imbalanced", "16991": "load_weight", "16992": "load_word", "16993": "loaded", "16994": "loaded_info", "16995": "loads", "16996": "loc", "16997": "local", "16998": "local64_read", "16999": "local64_set", "17000": "local64_xchg", "17001": "local_add", "17002": "local_add_return", "17003": "local_bh_disable", "17004": "local_bh_enable", "17005": "local_clock", "17006": "local_clock_stable", "17007": "local_cmpxchg", "17008": "local_cpu", "17009": "local_cpu_mask", "17010": "local_debuggerinfo", "17011": "local_dec", "17012": "local_dec_and_test", "17013": "local_distance", "17014": "local_group", "17015": "local_hash", "17016": "local_inc", "17017": "local_inc_return", "17018": "local_irq_disable", "17019": "local_irq_enable", "17020": "local_irq_restore", "17021": "local_irq_save", "17022": "local_list", "17023": "local_n", "17024": "local_read", "17025": "local_samples_len", "17026": "local_save_flags", "17027": "local_set", "17028": "local_softirq_pending", "17029": "local_stat", "17030": "local_sub", "17031": "local_t", "17032": "local_xchg", "17033": "locate_mem_hole_bottom_up", "17034": "locate_mem_hole_callback", "17035": "locate_mem_hole_top_down", "17036": "locate_module_kobject", "17037": "lock", "17038": "lock_accessed", "17039": "lock_acquire", "17040": "lock_acquire_exclusive", "17041": "lock_acquire_shared", "17042": "lock_acquired", "17043": "lock_busted_ops", "17044": "lock_chain", "17045": "lock_chain_get_class", "17046": "lock_chains", "17047": "lock_class", "17048": "lock_class_key", "17049": "lock_class_stats", "17050": "lock_classes", "17051": "lock_contended", "17052": "lock_contended_flags", "17053": "lock_count", "17054": "lock_cq", "17055": "lock_dep_map", "17056": "lock_device_hotplug", "17057": "lock_enabled_", "17058": "lock_enabled_hardirq", "17059": "lock_enabled_hardirq_read", "17060": "lock_enabled_softirq", "17061": "lock_enabled_softirq_read", "17062": "lock_entry", "17063": "lock_flag", "17064": "lock_from", "17065": "lock_id", "17066": "lock_init_error", "17067": "lock_is_held", "17068": "lock_is_read_held", "17069": "lock_is_write_held", "17070": "lock_key", "17071": "lock_len", "17072": "lock_limit", "17073": "lock_list", "17074": "lock_map_acquire", "17075": "lock_map_acquire_read", "17076": "lock_map_acquire_tryread", "17077": "lock_map_release", "17078": "lock_name", "17079": "lock_page", "17080": "lock_point", "17081": "lock_release", "17082": "lock_release_holdtime", "17083": "lock_release_nested", "17084": "lock_release_non_nested", "17085": "lock_set_class", "17086": "lock_set_subclass", "17087": "lock_stat", "17088": "lock_stat_cmp", "17089": "lock_stat_data", "17090": "lock_stat_open", "17091": "lock_stat_release", "17092": "lock_stat_seq", "17093": "lock_stat_write", "17094": "lock_stats", "17095": "lock_stress_stats", "17096": "lock_system_sleep", "17097": "lock_task_sighand", "17098": "lock_time", "17099": "lock_time_add", "17100": "lock_time_inc", "17101": "lock_timer", "17102": "lock_timer_base", "17103": "lock_torture_cleanup", "17104": "lock_torture_cxt", "17105": "lock_torture_init", "17106": "lock_torture_ops", "17107": "lock_torture_print_module_parms", "17108": "lock_torture_reader", "17109": "lock_torture_stats", "17110": "lock_torture_stats_print", "17111": "lock_torture_writer", "17112": "lock_usage_bit", "17113": "lock_usage_chars", "17114": "lock_usage_states", "17115": "lock_used", "17116": "lock_used_in_", "17117": "lock_used_in_hardirq", "17118": "lock_used_in_hardirq_read", "17119": "lock_used_in_reclaim_fs", "17120": "lock_used_in_reclaim_fs_read", "17121": "lock_used_in_softirq", "17122": "lock_used_in_softirq_read", "17123": "lockdep", "17124": "lockdep_assert_held", "17125": "lockdep_chains_open", "17126": "lockdep_chains_ops", "17127": "lockdep_clear_current_reclaim_state", "17128": "lockdep_copy_map", "17129": "lockdep_count_backward_deps", "17130": "lockdep_count_forward_deps", "17131": "lockdep_dependency_gen_id", "17132": "lockdep_depth", "17133": "lockdep_free_key_range", "17134": "lockdep_init", "17135": "lockdep_init_error", "17136": "lockdep_init_map", "17137": "lockdep_init_trace", "17138": "lockdep_init_trace_data", "17139": "lockdep_initialized", "17140": "lockdep_is_held", "17141": "lockdep_key", "17142": "lockdep_lock", "17143": "lockdep_map", "17144": "lockdep_now_unreliable", "17145": "lockdep_off", "17146": "lockdep_ok", "17147": "lockdep_on", "17148": "lockdep_open", "17149": "lockdep_ops", "17150": "lockdep_print_held_locks", "17151": "lockdep_proc_init", "17152": "lockdep_rcu_suspicious", "17153": "lockdep_reclaim_gfp", "17154": "lockdep_recursion", "17155": "lockdep_reset", "17156": "lockdep_reset_lock", "17157": "lockdep_set_class", "17158": "lockdep_set_class_and_name", "17159": "lockdep_set_current_reclaim_state", "17160": "lockdep_softirq_end", "17161": "lockdep_softirq_enter", "17162": "lockdep_softirq_exit", "17163": "lockdep_softirq_start", "17164": "lockdep_state", "17165": "lockdep_stats", "17166": "lockdep_stats_debug_show", "17167": "lockdep_stats_open", "17168": "lockdep_stats_show", "17169": "lockdep_still_ok", "17170": "lockdep_subclass_key", "17171": "lockdep_sys_exit", "17172": "lockdep_tasklist_lock_is_held", "17173": "lockdep_trace_alloc", "17174": "locked", "17175": "locked_shm", "17176": "locked_vm", "17177": "lockf_", "17178": "lockf_enabled_hardirq", "17179": "lockf_enabled_hardirq_read", "17180": "lockf_enabled_irq", "17181": "lockf_enabled_irq_read", "17182": "lockf_enabled_softirq", "17183": "lockf_enabled_softirq_read", "17184": "lockf_used", "17185": "lockf_used_in_hardirq", "17186": "lockf_used_in_hardirq_read", "17187": "lockf_used_in_irq", "17188": "lockf_used_in_irq_read", "17189": "lockf_used_in_softirq", "17190": "lockf_used_in_softirq_read", "17191": "locking", "17192": "locks_after", "17193": "locks_before", "17194": "lockstat_clock", "17195": "lockstat_ops", "17196": "locktorture_runnable_init", "17197": "locktype", "17198": "lockup_detector_init", "17199": "lockwakeup", "17200": "loff_t", "17201": "log", "17202": "log_action", "17203": "log_align", "17204": "log_buf", "17205": "log_buf_len", "17206": "log_cont", "17207": "log_first_idx", "17208": "log_first_seq", "17209": "log_flags", "17210": "log_from_idx", "17211": "log_len", "17212": "log_level", "17213": "log_line_max", "17214": "log_lvl", "17215": "log_make_free_space", "17216": "log_newline", "17217": "log_next", "17218": "log_next_idx", "17219": "log_next_seq", "17220": "log_nocons", "17221": "log_passwd", "17222": "log_prefix", "17223": "log_size", "17224": "log_ubuf", "17225": "log_wait", "17226": "logarithmic_accumulation", "17227": "logbuf_has_space", "17228": "logbuf_lock", "17229": "logged", "17230": "logging", "17231": "loginuid", "17232": "loglevel", "17233": "long", "17234": "long_act", "17235": "long_max", "17236": "long_min", "17237": "longdelay", "17238": "longdelay_ms", "17239": "longdelay_us", "17240": "longjmp_break_handler", "17241": "look_up_lock_class", "17242": "lookup", "17243": "lookup_chain_cache", "17244": "lookup_elem_raw", "17245": "lookup_format", "17246": "lookup_module_symbol_attrs", "17247": "lookup_module_symbol_name", "17248": "lookup_resource", "17249": "lookup_symbol", "17250": "lookup_symbol_attrs", "17251": "lookup_symbol_name", "17252": "loop", "17253": "loop_break", "17254": "loop_max", "17255": "loops", "17256": "loops_per_jiffy", "17257": "loops_per_msec", "17258": "lost", "17259": "lost_event", "17260": "lost_events", "17261": "low", "17262": "low2highgid", "17263": "low2highuid", "17264": "low_free_pages", "17265": "low_shift", "17266": "lowbp", "17267": "lower", "17268": "lower_first", "17269": "lower_last", "17270": "lower_ns", "17271": "lowering", "17272": "lowest_flag_domain", "17273": "lowest_in_progress", "17274": "lowest_mask", "17275": "lowest_rq", "17276": "lowmem_reserve_ratio_sysctl_handler", "17277": "lp", "17278": "lparam", "17279": "lpj", "17280": "lr", "17281": "lrsa", "17282": "lrsp", "17283": "lru", "17284": "lru_cache_add_active_or_unevictable", "17285": "ls", "17286": "ls_next", "17287": "ls_show", "17288": "ls_start", "17289": "ls_stop", "17290": "lsh", "17291": "lsm_rule", "17292": "lsm_setid_fs", "17293": "lsm_setid_id", "17294": "lsm_setid_re", "17295": "lsm_setid_res", "17296": "lsm_str", "17297": "lstats_fops", "17298": "lstats_open", "17299": "lstats_show", "17300": "lstats_write", "17301": "lt", "17302": "lt_backtracedepth", "17303": "lt_savecount", "17304": "lu", "17305": "lval", "17306": "lvalp", "17307": "lvl", "17308": "lw", "17309": "lwsa", "17310": "lwsp", "17311": "lx", "17312": "lzero", "17313": "lzo1x_1_compress", "17314": "lzo1x_1_mem_compress", "17315": "lzo1x_decompress_safe", "17316": "lzo1x_worst_compress", "17317": "lzo_cmp_pages", "17318": "lzo_cmp_size", "17319": "lzo_compress_threadfn", "17320": "lzo_decompress_threadfn", "17321": "lzo_header", "17322": "lzo_max_rd_pages", "17323": "lzo_min_rd_pages", "17324": "lzo_threads", "17325": "lzo_unc_pages", "17326": "lzo_unc_size", "17327": "m", "17328": "m1", "17329": "m2", "17330": "m_next", "17331": "m_show", "17332": "m_start", "17333": "m_stop", "17334": "machine", "17335": "machine_crash_shutdown", "17336": "machine_emergency_restart", "17337": "machine_halt", "17338": "machine_kexec", "17339": "machine_kexec_cleanup", "17340": "machine_kexec_prepare", "17341": "machine_power_off", "17342": "machine_restart", "17343": "machine_shutdown", "17344": "machine_suspend", "17345": "maddr", "17346": "magic", "17347": "magic1", "17348": "magic2", "17349": "magic_end", "17350": "magic_etc", "17351": "magic_size", "17352": "magic_start", "17353": "main", "17354": "main_extable_sort_needed", "17355": "main_ops", "17356": "maj", "17357": "maj_flt", "17358": "major", "17359": "make", "17360": "make_data_rloc", "17361": "make_key_ref", "17362": "make_kgid", "17363": "make_kprojid", "17364": "make_kuid", "17365": "manage_workers", "17366": "manager", "17367": "manager_arb", "17368": "managing", "17369": "mantsize", "17370": "map", "17371": "map_alloc", "17372": "map_cmdline_to_pid", "17373": "map_count", "17374": "map_create", "17375": "map_delete_elem", "17376": "map_denywrite", "17377": "map_executable", "17378": "map_fd", "17379": "map_flags", "17380": "map_free", "17381": "map_get_next_key", "17382": "map_hugetlb", "17383": "map_id", "17384": "map_id_down", "17385": "map_id_range_down", "17386": "map_id_up", "17387": "map_info", "17388": "map_locked", "17389": "map_lookup_elem", "17390": "map_page_entries", "17391": "map_pid_to_cmdline", "17392": "map_private", "17393": "map_ptr", "17394": "map_shared", "17395": "map_type", "17396": "map_update_elem", "17397": "map_write", "17398": "mapp", "17399": "mapped", "17400": "mapping", "17401": "mappings_overlap", "17402": "maps", "17403": "mark", "17404": "mark_explored", "17405": "mark_free_pages", "17406": "mark_held_locks", "17407": "mark_irqflags", "17408": "mark_lock", "17409": "mark_lock_accessed", "17410": "mark_lock_irq", "17411": "mark_nosave_pages", "17412": "mark_reg_unknown_value", "17413": "mark_swapfiles", "17414": "mark_type", "17415": "mark_unsafe_pages", "17416": "mark_work_canceling", "17417": "markerlen", "17418": "marking", "17419": "mask", "17420": "mask_ack_irq", "17421": "mask_cache", "17422": "mask_cache_priv", "17423": "mask_declare_1", "17424": "mask_declare_8", "17425": "mask_i", "17426": "mask_irq", "17427": "mask_m", "17428": "mask_maps", "17429": "mask_tc_bit", "17430": "mask_type", "17431": "masked", "17432": "maskp", "17433": "masks", "17434": "masters_in_kgdb", "17435": "match", "17436": "match_data", "17437": "match_end_only", "17438": "match_entries", "17439": "match_front_only", "17440": "match_full", "17441": "match_held_lock", "17442": "match_middle_only", "17443": "match_state", "17444": "match_tree_refs", "17445": "match_uprobe", "17446": "mattr", "17447": "max", "17448": "max_active", "17449": "max_active_show", "17450": "max_active_store", "17451": "max_arch_header_size", "17452": "max_arg_strlen", "17453": "max_argstr_len", "17454": "max_bfs_queue_depth", "17455": "max_bpf_reg", "17456": "max_bpf_stack", "17457": "max_buf", "17458": "max_buffer", "17459": "max_bytes_for_cpu", "17460": "max_cfs_quota_period", "17461": "max_cftype_name", "17462": "max_cgroup_root_namelen", "17463": "max_cgroup_type_namelen", "17464": "max_circular_queue_size", "17465": "max_clock", "17466": "max_clocks", "17467": "max_cmdlineconsoles", "17468": "max_cost", "17469": "max_count", "17470": "max_cycles", "17471": "max_data", "17472": "max_delta", "17473": "max_delta_ns", "17474": "max_delta_ticks", "17475": "max_depth", "17476": "max_dl_prio", "17477": "max_dma_channels", "17478": "max_entries", "17479": "max_entries_bits", "17480": "max_errno", "17481": "max_event_name_len", "17482": "max_execve_audit_len", "17483": "max_extfrag_threshold", "17484": "max_faults", "17485": "max_files", "17486": "max_filter_pred", "17487": "max_filter_str_val", "17488": "max_graph_depth", "17489": "max_group", "17490": "max_group_faults", "17491": "max_group_nid", "17492": "max_hang_time", "17493": "max_idle_balance_cost", "17494": "max_idle_ns", "17495": "max_idle_workers_ratio", "17496": "max_insn_size", "17497": "max_insns_per_path", "17498": "max_interrupts", "17499": "max_interval", "17500": "max_iores_level", "17501": "max_jiffy_offset", "17502": "max_kmod_concurrent", "17503": "max_latency", "17504": "max_level", "17505": "max_load_balance_interval", "17506": "max_load_idx", "17507": "max_lock", "17508": "max_lock_depth", "17509": "max_lockdep_chain_hlocks", "17510": "max_lockdep_chains", "17511": "max_lockdep_depth", "17512": "max_lockdep_entries", "17513": "max_lockdep_keys", "17514": "max_lockdep_keys_bits", "17515": "max_lockdep_subclasses", "17516": "max_modprobes", "17517": "max_namelen", "17518": "max_newidle_lb_cost", "17519": "max_nice", "17520": "max_nid", "17521": "max_node", "17522": "max_nr_zones", "17523": "max_numnodes", "17524": "max_obj_num", "17525": "max_offline", "17526": "max_online", "17527": "max_order", "17528": "max_pid_ns_level", "17529": "max_pinned_interval", "17530": "max_prio", "17531": "max_proctitle_audit_len", "17532": "max_pull", "17533": "max_rcu_lvls", "17534": "max_restart", "17535": "max_rt_prio", "17536": "max_rt_test_mutexes", "17537": "max_rt_test_threads", "17538": "max_samples_per_tick", "17539": "max_scan", "17540": "max_scan_window", "17541": "max_sched_granularity_ns", "17542": "max_sched_tunable_scaling", "17543": "max_schedule_timeout", "17544": "max_score", "17545": "max_sec_in_jiffies", "17546": "max_sequence", "17547": "max_shares", "17548": "max_size", "17549": "max_size_nested", "17550": "max_softirq_restart", "17551": "max_softirq_time", "17552": "max_stack_lock", "17553": "max_stack_size", "17554": "max_stack_trace", "17555": "max_stack_trace_entries", "17556": "max_string_size", "17557": "max_swapfiles", "17558": "max_t", "17559": "max_tasks_shown_per_css", "17560": "max_threads", "17561": "max_threads_suggested", "17562": "max_tickadj", "17563": "max_tickadj_scaled", "17564": "max_trace_args", "17565": "max_trace_lock", "17566": "max_tracer_size", "17567": "max_tval", "17568": "max_uprobe_xol_slots", "17569": "max_uretprobe_depth", "17570": "max_used_maps", "17571": "max_user_rt_prio", "17572": "max_vruntime", "17573": "max_wakeup_granularity_ns", "17574": "max_work", "17575": "max_write_len", "17576": "max_zone_pfn", "17577": "maxactive", "17578": "maxadj", "17579": "maxargc", "17580": "maxattr", "17581": "maxcpu", "17582": "maxdist", "17583": "maxerror", "17584": "maxexp2", "17585": "maxfract", "17586": "maxfract2", "17587": "maxfreq", "17588": "maxfreq_scaled", "17589": "maximum", "17590": "maxj", "17591": "maxlen", "17592": "maxlr", "17593": "maxolduid", "17594": "maxreserve", "17595": "maxrss", "17596": "maxshift", "17597": "maxtc", "17598": "may", "17599": "may_access_skb", "17600": "may_exec", "17601": "may_init_module", "17602": "may_ptrace_stop", "17603": "may_setgroups", "17604": "may_start_working", "17605": "maybe_create_worker", "17606": "maybe_kfree_parameter", "17607": "maybe_relocated", "17608": "mayday_initial_timeout", "17609": "mayday_interval", "17610": "mayday_node", "17611": "mayday_timer", "17612": "maydays", "17613": "mb", "17614": "mb_ret", "17615": "mbytes", "17616": "mc", "17617": "mchunk", "17618": "mckenney", "17619": "mcount_addr", "17620": "mcount_insn_size", "17621": "mcount_record", "17622": "mcs_spin_lock", "17623": "mcs_spin_unlock", "17624": "mcs_spinlock", "17625": "mdcount", "17626": "mdelay", "17627": "me", "17628": "means", "17629": "mem", "17630": "mem_bm_set_bit_check", "17631": "mem_cgroup", "17632": "mem_cgroup_cancel_charge", "17633": "mem_cgroup_commit_charge", "17634": "mem_cgroup_try_charge", "17635": "mem_extent", "17636": "mem_extents", "17637": "mem_from", "17638": "mem_idx", "17639": "mem_len", "17640": "mem_node", "17641": "mem_to", "17642": "mem_total", "17643": "mem_unit", "17644": "mem_zone_bm_rtree", "17645": "memblock_virt_alloc", "17646": "membuf_idx", "17647": "memcg", "17648": "memchr_inv", "17649": "memcmp", "17650": "memcpy", "17651": "memcpy_func", "17652": "memmove", "17653": "memory", "17654": "memory_bandwidth_notifier", "17655": "memory_bandwidth_pm_qos", "17656": "memory_bitmap", "17657": "memory_bm_clear_bit", "17658": "memory_bm_clear_current", "17659": "memory_bm_create", "17660": "memory_bm_find_bit", "17661": "memory_bm_free", "17662": "memory_bm_next_pfn", "17663": "memory_bm_pfn_present", "17664": "memory_bm_position_reset", "17665": "memory_bm_set_bit", "17666": "memory_bm_test_bit", "17667": "memory_bw_constraints", "17668": "memparse", "17669": "mempolicy", "17670": "mems_allowed", "17671": "mems_allowed_seq", "17672": "mems_updated", "17673": "memset", "17674": "memsz", "17675": "mend", "17676": "merge", "17677": "message", "17678": "message_loglevel_default", "17679": "messages", "17680": "meta", "17681": "method", "17682": "mg_dst_cset", "17683": "mg_node", "17684": "mg_preload_node", "17685": "mg_src_cgrp", "17686": "mg_tasks", "17687": "mg_tasks_head", "17688": "mid", "17689": "middle", "17690": "might", "17691": "might_sleep", "17692": "might_sleep_if", "17693": "migrate", "17694": "migrate_degrades_locality", "17695": "migrate_improves_locality", "17696": "migrate_swap", "17697": "migrate_swap_stop", "17698": "migrate_task_rq", "17699": "migrate_task_rq_fair", "17700": "migrate_task_to", "17701": "migrate_tasks", "17702": "migrate_timer_list", "17703": "migrate_timers", "17704": "migrate_to_reboot_cpu", "17705": "migrated", "17706": "migration_arg", "17707": "migration_call", "17708": "migration_cpu_stop", "17709": "migration_init", "17710": "migration_notifier", "17711": "migration_swap_arg", "17712": "min", "17713": "min_amount", "17714": "min_bandwidth_expiration", "17715": "min_cfs_quota_period", "17716": "min_cfs_rq_runtime", "17717": "min_clock", "17718": "min_delta", "17719": "min_delta_limit", "17720": "min_delta_ns", "17721": "min_delta_ticks", "17722": "min_exit_latency", "17723": "min_expire", "17724": "min_extfrag_threshold", "17725": "min_flt", "17726": "min_free_kbytes", "17727": "min_free_kbytes_sysctl_handler", "17728": "min_interval", "17729": "min_level", "17730": "min_load", "17731": "min_load_idx", "17732": "min_nice", "17733": "min_offline", "17734": "min_online", "17735": "min_sched_granularity_ns", "17736": "min_sched_tunable_scaling", "17737": "min_shares", "17738": "min_size", "17739": "min_size_nested", "17740": "min_t", "17741": "min_threads", "17742": "min_vruntime", "17743": "min_vruntime_copy", "17744": "min_wakeup_granularity_ns", "17745": "mini", "17746": "minimum_image_size", "17747": "minlen", "17748": "minolduid", "17749": "minor", "17750": "misc", "17751": "misc_dynamic_minor", "17752": "misc_register", "17753": "miscdevice", "17754": "mismatch", "17755": "misrouted_irq", "17756": "missed_events", "17757": "missed_updates", "17758": "missing", "17759": "mk", "17760": "mk_pid", "17761": "mk_pte", "17762": "mk_reply", "17763": "mkdir", "17764": "mkobj", "17765": "mktime64", "17766": "mm", "17767": "mm_access", "17768": "mm_alloc", "17769": "mm_alloc_pgd", "17770": "mm_anonpages", "17771": "mm_cachep", "17772": "mm_count", "17773": "mm_filepages", "17774": "mm_free_pgd", "17775": "mm_init", "17776": "mm_init_aio", "17777": "mm_init_cpumask", "17778": "mm_init_owner", "17779": "mm_nr_pmds", "17780": "mm_nr_pmds_init", "17781": "mm_rb", "17782": "mm_release", "17783": "mm_segment_t", "17784": "mm_struct", "17785": "mm_users", "17786": "mmap", "17787": "mmap2", "17788": "mmap_count", "17789": "mmap_data", "17790": "mmap_event", "17791": "mmap_init", "17792": "mmap_locked", "17793": "mmap_max_addr", "17794": "mmap_min_addr_handler", "17795": "mmap_mutex", "17796": "mmap_sem", "17797": "mmap_user", "17798": "mmdrop", "17799": "mmf_dump_filter_default", "17800": "mmf_exe_file_changed", "17801": "mmf_has_uprobes", "17802": "mmf_init_mask", "17803": "mmf_recalc_uprobes", "17804": "mmio_close", "17805": "mmio_pipe_open", "17806": "mmio_print_line", "17807": "mmio_print_map", "17808": "mmio_print_mark", "17809": "mmio_print_pcidev", "17810": "mmio_print_rw", "17811": "mmio_probe", "17812": "mmio_read", "17813": "mmio_reset_data", "17814": "mmio_trace_array", "17815": "mmio_trace_init", "17816": "mmio_trace_mapping", "17817": "mmio_trace_printk", "17818": "mmio_trace_reset", "17819": "mmio_trace_rw", "17820": "mmio_trace_start", "17821": "mmio_tracer", "17822": "mmio_unknown_op", "17823": "mmio_unprobe", "17824": "mmio_write", "17825": "mmiotrace_map", "17826": "mmiotrace_rw", "17827": "mmlist", "17828": "mmlist_lock", "17829": "mmput", "17830": "mmu_notifier_invalidate_range_end", "17831": "mmu_notifier_invalidate_range_start", "17832": "mmu_notifier_mm_destroy", "17833": "mmu_notifier_mm_init", "17834": "mmun_end", "17835": "mmun_start", "17836": "mnt", "17837": "mnt_clone_internal", "17838": "mnt_drop_write", "17839": "mnt_flags", "17840": "mnt_noexec", "17841": "mnt_ns", "17842": "mnt_root", "17843": "mnt_want_write", "17844": "mntput", "17845": "mod", "17846": "mod_delayed_work", "17847": "mod_delayed_work_on", "17848": "mod_extract_mpi_array", "17849": "mod_find_symname", "17850": "mod_fmt", "17851": "mod_initfree", "17852": "mod_kobject_put", "17853": "mod_make_digest", "17854": "mod_name", "17855": "mod_number_of_pages", "17856": "mod_percpu", "17857": "mod_sysfs_fini", "17858": "mod_sysfs_init", "17859": "mod_sysfs_setup", "17860": "mod_sysfs_teardown", "17861": "mod_timer", "17862": "mod_timer_pending", "17863": "mod_timer_pinned", "17864": "mod_verify_sig", "17865": "mod_zone_page_state", "17866": "modaddr", "17867": "mode", "17868": "mode1_syscalls", "17869": "mode1_syscalls_32", "17870": "modes", "17871": "modify", "17872": "modinfo_", "17873": "modinfo_attr", "17874": "modinfo_attrs", "17875": "modinfo_coresize", "17876": "modinfo_initsize", "17877": "modinfo_initstate", "17878": "modinfo_refcnt", "17879": "modinfo_srcversion", "17880": "modinfo_taint", "17881": "modinfo_version", "17882": "modlen", "17883": "modmagic", "17884": "modname", "17885": "modprobe_path", "17886": "module", "17887": "module_add_modinfo_attrs", "17888": "module_addr_max", "17889": "module_address_lookup", "17890": "module_alias", "17891": "module_alloc", "17892": "module_alloc_update_bounds", "17893": "module_arch_cleanup", "17894": "module_arch_freeing_init", "17895": "module_attr_show", "17896": "module_attr_store", "17897": "module_attribute", "17898": "module_author", "17899": "module_bug_cleanup", "17900": "module_core", "17901": "module_deallocate", "17902": "module_description", "17903": "module_event", "17904": "module_exit", "17905": "module_finalize", "17906": "module_flags", "17907": "module_flags_taint", "17908": "module_frob_arch_sections", "17909": "module_get", "17910": "module_get_kallsym", "17911": "module_init", "17912": "module_init_ignore_modversions", "17913": "module_init_ignore_vermagic", "17914": "module_is_live", "17915": "module_kallsyms_lookup_name", "17916": "module_kallsyms_on_each_symbol", "17917": "module_kobj_release", "17918": "module_kobject", "17919": "module_kset", "17920": "module_ktype", "17921": "module_layout", "17922": "module_license", "17923": "module_memfree", "17924": "module_mutex", "17925": "module_name", "17926": "module_name_len", "17927": "module_notes_attrs", "17928": "module_notes_read", "17929": "module_notify_list", "17930": "module_param", "17931": "module_param_attrs", "17932": "module_param_named", "17933": "module_param_prefix", "17934": "module_param_sysfs_remove", "17935": "module_param_sysfs_setup", "17936": "module_parm_desc", "17937": "module_put", "17938": "module_ref_base", "17939": "module_refcount", "17940": "module_region", "17941": "module_remove_modinfo_attrs", "17942": "module_sect_attr", "17943": "module_sect_attrs", "17944": "module_sect_show", "17945": "module_sig_check", "17946": "module_sig_string", "17947": "module_signature", "17948": "module_state_coming", "17949": "module_state_going", "17950": "module_state_live", "17951": "module_state_unformed", "17952": "module_sysfs_initialized", "17953": "module_sysfs_ops", "17954": "module_trace_bprintk_format_nb", "17955": "module_trace_bprintk_format_notify", "17956": "module_uevent", "17957": "module_uevent_ops", "17958": "module_unload_free", "17959": "module_unload_init", "17960": "module_use", "17961": "module_version_attribute", "17962": "module_wq", "17963": "modules", "17964": "modules_disabled", "17965": "modules_op", "17966": "modules_open", "17967": "modversion_info", "17968": "mon", "17969": "mon_day", "17970": "mono", "17971": "more", "17972": "more2boost", "17973": "more_balance", "17974": "moreprompt", "17975": "most", "17976": "mount", "17977": "mountopts", "17978": "move", "17979": "move_down", "17980": "move_linked_works", "17981": "move_module", "17982": "move_pages", "17983": "move_queued_task", "17984": "move_type", "17985": "move_up_from_left", "17986": "move_up_from_right", "17987": "moved_load", "17988": "moveimp", "17989": "mp", "17990": "mpi", "17991": "mpnt", "17992": "mpol_dup", "17993": "mpol_f_moron", "17994": "mpol_get", "17995": "mpol_mf_move_all", "17996": "mpol_put", "17997": "mpol_rebind_mm", "17998": "mpol_rebind_step1", "17999": "mpol_rebind_step2", "18000": "mpol_rebind_task", "18001": "mpx_disable_management", "18002": "mpx_enable_management", "18003": "mq_attr", "18004": "mq_curmsgs", "18005": "mq_flags", "18006": "mq_getsetattr", "18007": "mq_maxmsg", "18008": "mq_msgsize", "18009": "mq_notify", "18010": "mq_open", "18011": "mq_sendrecv", "18012": "mqd_t", "18013": "mqdes", "18014": "mqstat", "18015": "ms", "18016": "msdata", "18017": "msec", "18018": "msec_per_sec", "18019": "msec_to_hz_adj32", "18020": "msec_to_hz_mul32", "18021": "msec_to_hz_shr32", "18022": "msecs", "18023": "msecs_to_jiffies", "18024": "msg", "18025": "msg_data", "18026": "msg_file", "18027": "msg_len", "18028": "msg_prio", "18029": "msg_size", "18030": "msg_type", "18031": "msi_alloc_info_t", "18032": "msi_check", "18033": "msi_create_irq_domain", "18034": "msi_desc", "18035": "msi_domain_activate", "18036": "msi_domain_alloc", "18037": "msi_domain_alloc_irqs", "18038": "msi_domain_deactivate", "18039": "msi_domain_free", "18040": "msi_domain_free_irqs", "18041": "msi_domain_info", "18042": "msi_domain_ops", "18043": "msi_domain_ops_check", "18044": "msi_domain_ops_default", "18045": "msi_domain_ops_get_hwirq", "18046": "msi_domain_ops_init", "18047": "msi_domain_ops_prepare", "18048": "msi_domain_ops_set_desc", "18049": "msi_domain_set_affinity", "18050": "msi_domain_update_chip_ops", "18051": "msi_domain_update_dom_ops", "18052": "msi_finish", "18053": "msi_flag_identity_map", "18054": "msi_flag_use_def_chip_ops", "18055": "msi_flag_use_def_dom_ops", "18056": "msi_free", "18057": "msi_get_domain_info", "18058": "msi_init", "18059": "msi_msg", "18060": "msi_prepare", "18061": "msk", "18062": "mskptr", "18063": "mskreg", "18064": "msleep", "18065": "msleep_interruptible", "18066": "mstart", "18067": "much", "18068": "mul", "18069": "mul_u64_u32_shr", "18070": "mult", "18071": "mult_adj", "18072": "multi", "18073": "multi_cpu_stop", "18074": "multi_stop_data", "18075": "multi_stop_disable_irq", "18076": "multi_stop_exit", "18077": "multi_stop_none", "18078": "multi_stop_prepare", "18079": "multi_stop_run", "18080": "multi_stop_state", "18081": "multiplier", "18082": "munlock_vma_page", "18083": "munmap_notifier", "18084": "must", "18085": "mutex", "18086": "mutex_acquire", "18087": "mutex_acquire_nest", "18088": "mutex_can_spin_on_owner", "18089": "mutex_clear_owner", "18090": "mutex_debug_free", "18091": "mutex_debug_init", "18092": "mutex_destroy", "18093": "mutex_init", "18094": "mutex_is_locked", "18095": "mutex_lock", "18096": "mutex_lock_interruptible", "18097": "mutex_lock_interruptible_nested", "18098": "mutex_lock_killable", "18099": "mutex_lock_killable_nested", "18100": "mutex_lock_nested", "18101": "mutex_lock_ops", "18102": "mutex_optimistic_spin", "18103": "mutex_release", "18104": "mutex_remove_waiter", "18105": "mutex_set_owner", "18106": "mutex_spin_on_owner", "18107": "mutex_try_to_acquire", "18108": "mutex_trylock", "18109": "mutex_unlock", "18110": "mutex_waiter", "18111": "mutexes", "18112": "muxed_resource_wait", "18113": "my_grp", "18114": "my_q", "18115": "my_rdp", "18116": "my_scd", "18117": "mylat", "18118": "mynode", "18119": "mypatch", "18120": "n", "18121": "n_balk_blkd_tasks", "18122": "n_balk_boost_tasks", "18123": "n_balk_exp_gp_tasks", "18124": "n_balk_nos", "18125": "n_balk_notblocked", "18126": "n_balk_notyet", "18127": "n_barrier_attempts", "18128": "n_barrier_cbs", "18129": "n_barrier_done", "18130": "n_barrier_successes", "18131": "n_buckets", "18132": "n_cbfloods", "18133": "n_cbs_adopted", "18134": "n_cbs_invoked", "18135": "n_cbs_orphaned", "18136": "n_counters", "18137": "n_ctrs", "18138": "n_descsz", "18139": "n_exp_boosts", "18140": "n_force_qs", "18141": "n_force_qs_gpstart", "18142": "n_force_qs_lh", "18143": "n_force_qs_ngp", "18144": "n_force_qs_snap", "18145": "n_functions", "18146": "n_lock_acquired", "18147": "n_lock_fail", "18148": "n_lock_torture_errors", "18149": "n_logical_preds", "18150": "n_memory", "18151": "n_namesz", "18152": "n_nocbs_invoked", "18153": "n_normal_boosts", "18154": "n_normal_preds", "18155": "n_offline_attempts", "18156": "n_offline_successes", "18157": "n_online_attempts", "18158": "n_online_successes", "18159": "n_preds", "18160": "n_rcu_pending", "18161": "n_rcu_torture_alloc", "18162": "n_rcu_torture_alloc_fail", "18163": "n_rcu_torture_barrier_error", "18164": "n_rcu_torture_boost_failure", "18165": "n_rcu_torture_boost_ktrerror", "18166": "n_rcu_torture_boost_rterror", "18167": "n_rcu_torture_boosts", "18168": "n_rcu_torture_error", "18169": "n_rcu_torture_free", "18170": "n_rcu_torture_mberror", "18171": "n_rcu_torture_timers", "18172": "n_rp_cb_ready", "18173": "n_rp_cpu_needs_gp", "18174": "n_rp_gp_completed", "18175": "n_rp_gp_started", "18176": "n_rp_need_nothing", "18177": "n_rp_nocb_defer_wakeup", "18178": "n_rp_qs_pending", "18179": "n_rp_report_qs", "18180": "n_stress", "18181": "n_tasks_boosted", "18182": "n_type", "18183": "n_utask", "18184": "na", "18185": "name", "18186": "name_buf", "18187": "name_count", "18188": "name_len", "18189": "name_match", "18190": "name_max", "18191": "name_skip", "18192": "name_struct", "18193": "name_to_dev_t", "18194": "name_unique", "18195": "name_user", "18196": "name_version", "18197": "namebuf", "18198": "namefmt", "18199": "namelen", "18200": "nameoff", "18201": "names_list", "18202": "nand", "18203": "nanosleep", "18204": "narg", "18205": "nargs", "18206": "nattr", "18207": "nb", "18208": "nb_args", "18209": "nblock", "18210": "nbut", "18211": "nbytes", "18212": "ncbflooders", "18213": "ncsw", "18214": "ndetected", "18215": "ndoms", "18216": "ndoms_cur", "18217": "ndots", "18218": "ndst", "18219": "ndw", "18220": "nearest_hardwall_ancestor", "18221": "need", "18222": "need_active_balance", "18223": "need_decay", "18224": "need_forkexit_callback", "18225": "need_future_gp", "18226": "need_loop", "18227": "need_more_worker", "18228": "need_prep", "18229": "need_prune", "18230": "need_pull_rt_task", "18231": "need_qs", "18232": "need_rcu_nocb_mask", "18233": "need_rebuild_sched_domains", "18234": "need_resched", "18235": "need_seqretry", "18236": "need_serialize", "18237": "need_sid", "18238": "need_siglock", "18239": "need_to_create_worker", "18240": "needcheck", "18241": "needed", "18242": "needgp", "18243": "needmore", "18244": "needreport", "18245": "needs_unthr", "18246": "needwake", "18247": "neg", "18248": "neg_one", "18249": "negative", "18250": "negp", "18251": "nentry", "18252": "nest", "18253": "nest_lock", "18254": "nested", "18255": "net", "18256": "net_atalk", "18257": "net_atalk_aarp_expiry_time", "18258": "net_atalk_aarp_resolve_time", "18259": "net_atalk_aarp_retransmit_limit", "18260": "net_atalk_aarp_tick_time", "18261": "net_ax25", "18262": "net_ax25_backoff_type", "18263": "net_ax25_connect_mode", "18264": "net_ax25_dama_slave_timeout", "18265": "net_ax25_default_mode", "18266": "net_ax25_extended_window", "18267": "net_ax25_idle_timeout", "18268": "net_ax25_ip_default_mode", "18269": "net_ax25_n2", "18270": "net_ax25_paclen", "18271": "net_ax25_protocol", "18272": "net_ax25_standard_window", "18273": "net_ax25_t1_timeout", "18274": "net_ax25_t2_timeout", "18275": "net_ax25_t3_timeout", "18276": "net_cipsov4_cache_bucket_size", "18277": "net_cipsov4_cache_enable", "18278": "net_cipsov4_rbm_optfmt", "18279": "net_cipsov4_rbm_strictvalid", "18280": "net_core", "18281": "net_core_aevent_etime", "18282": "net_core_aevent_rseqth", "18283": "net_core_budget", "18284": "net_core_dev_weight", "18285": "net_core_max_backlog", "18286": "net_core_msg_burst", "18287": "net_core_msg_cost", "18288": "net_core_optmem_max", "18289": "net_core_rmem_default", "18290": "net_core_rmem_max", "18291": "net_core_somaxconn", "18292": "net_core_warnings", "18293": "net_core_wmem_default", "18294": "net_core_wmem_max", "18295": "net_decnet", "18296": "net_decnet_conf", "18297": "net_decnet_conf_ddcmp", "18298": "net_decnet_conf_dev_forwarding", "18299": "net_decnet_conf_dev_priority", "18300": "net_decnet_conf_dev_t2", "18301": "net_decnet_conf_dev_t3", "18302": "net_decnet_conf_ether", "18303": "net_decnet_conf_gre", "18304": "net_decnet_conf_loopback", "18305": "net_decnet_conf_ppp", "18306": "net_decnet_conf_x25", "18307": "net_decnet_debug_level", "18308": "net_decnet_default_device", "18309": "net_decnet_di_count", "18310": "net_decnet_dn_count", "18311": "net_decnet_dr_count", "18312": "net_decnet_dst_gc_interval", "18313": "net_decnet_mem", "18314": "net_decnet_no_fc_max_cwnd", "18315": "net_decnet_node_address", "18316": "net_decnet_node_name", "18317": "net_decnet_rmem", "18318": "net_decnet_time_wait", "18319": "net_decnet_wmem", "18320": "net_device", "18321": "net_generic", "18322": "net_ipv4", "18323": "net_ipv4_conf", "18324": "net_ipv4_conf_accept_redirects", "18325": "net_ipv4_conf_accept_source_route", "18326": "net_ipv4_conf_arp_accept", "18327": "net_ipv4_conf_arp_announce", "18328": "net_ipv4_conf_arp_ignore", "18329": "net_ipv4_conf_arp_notify", "18330": "net_ipv4_conf_arpfilter", "18331": "net_ipv4_conf_bootp_relay", "18332": "net_ipv4_conf_force_igmp_version", "18333": "net_ipv4_conf_forwarding", "18334": "net_ipv4_conf_log_martians", "18335": "net_ipv4_conf_mc_forwarding", "18336": "net_ipv4_conf_medium_id", "18337": "net_ipv4_conf_nopolicy", "18338": "net_ipv4_conf_noxfrm", "18339": "net_ipv4_conf_promote_secondaries", "18340": "net_ipv4_conf_proxy_arp", "18341": "net_ipv4_conf_rp_filter", "18342": "net_ipv4_conf_secure_redirects", "18343": "net_ipv4_conf_send_redirects", "18344": "net_ipv4_conf_shared_media", "18345": "net_ipv4_conf_tag", "18346": "net_ipv4_default_ttl", "18347": "net_ipv4_dynaddr", "18348": "net_ipv4_forward", "18349": "net_ipv4_icmp_echo_ignore_all", "18350": "net_ipv4_icmp_echo_ignore_broadcasts", "18351": "net_ipv4_icmp_errors_use_inbound_ifaddr", "18352": "net_ipv4_icmp_ignore_bogus_error_responses", "18353": "net_ipv4_icmp_ratelimit", "18354": "net_ipv4_icmp_ratemask", "18355": "net_ipv4_igmp_max_memberships", "18356": "net_ipv4_igmp_max_msf", "18357": "net_ipv4_inet_peer_gc_maxtime", "18358": "net_ipv4_inet_peer_gc_mintime", "18359": "net_ipv4_inet_peer_maxttl", "18360": "net_ipv4_inet_peer_minttl", "18361": "net_ipv4_inet_peer_threshold", "18362": "net_ipv4_ipfrag_high_thresh", "18363": "net_ipv4_ipfrag_low_thresh", "18364": "net_ipv4_ipfrag_secret_interval", "18365": "net_ipv4_ipfrag_time", "18366": "net_ipv4_local_port_range", "18367": "net_ipv4_neigh", "18368": "net_ipv4_netfilter", "18369": "net_ipv4_nf_conntrack_buckets", "18370": "net_ipv4_nf_conntrack_checksum", "18371": "net_ipv4_nf_conntrack_count", "18372": "net_ipv4_nf_conntrack_log_invalid", "18373": "net_ipv4_nf_conntrack_max", "18374": "net_ipv4_nf_conntrack_tcp_be_liberal", "18375": "net_ipv4_nf_conntrack_tcp_loose", "18376": "net_ipv4_nf_conntrack_tcp_max_retrans", "18377": "net_ipv4_no_pmtu_disc", "18378": "net_ipv4_nonlocal_bind", "18379": "net_ipv4_route", "18380": "net_ipv4_route_error_burst", "18381": "net_ipv4_route_error_cost", "18382": "net_ipv4_route_flush", "18383": "net_ipv4_route_gc_elasticity", "18384": "net_ipv4_route_gc_min_interval", "18385": "net_ipv4_route_gc_min_interval_ms", "18386": "net_ipv4_route_gc_thresh", "18387": "net_ipv4_route_gc_timeout", "18388": "net_ipv4_route_max_size", "18389": "net_ipv4_route_min_advmss", "18390": "net_ipv4_route_min_pmtu", "18391": "net_ipv4_route_mtu_expires", "18392": "net_ipv4_route_redirect_load", "18393": "net_ipv4_route_redirect_number", "18394": "net_ipv4_route_redirect_silence", "18395": "net_ipv4_tcp_fin_timeout", "18396": "net_ipv4_tcp_keepalive_intvl", "18397": "net_ipv4_tcp_keepalive_probes", "18398": "net_ipv4_tcp_keepalive_time", "18399": "net_ipv4_tcp_retrans_collapse", "18400": "net_ipv4_tcp_retries1", "18401": "net_ipv4_tcp_retries2", "18402": "net_ipv4_tcp_sack", "18403": "net_ipv4_tcp_syn_retries", "18404": "net_ipv4_tcp_timestamps", "18405": "net_ipv4_tcp_window_scaling", "18406": "net_ipv4_tcp_workaround_signed_windows", "18407": "net_ipv6", "18408": "net_ipv6_accept_ra", "18409": "net_ipv6_accept_ra_defrtr", "18410": "net_ipv6_accept_ra_from_local", "18411": "net_ipv6_accept_ra_pinfo", "18412": "net_ipv6_accept_ra_rt_info_max_plen", "18413": "net_ipv6_accept_ra_rtr_pref", "18414": "net_ipv6_accept_redirects", "18415": "net_ipv6_accept_source_route", "18416": "net_ipv6_autoconf", "18417": "net_ipv6_bindv6only", "18418": "net_ipv6_conf", "18419": "net_ipv6_dad_transmits", "18420": "net_ipv6_force_mld_version", "18421": "net_ipv6_forwarding", "18422": "net_ipv6_hop_limit", "18423": "net_ipv6_icmp", "18424": "net_ipv6_icmp_ratelimit", "18425": "net_ipv6_ip6frag_high_thresh", "18426": "net_ipv6_ip6frag_low_thresh", "18427": "net_ipv6_ip6frag_secret_interval", "18428": "net_ipv6_ip6frag_time", "18429": "net_ipv6_max_addresses", "18430": "net_ipv6_max_desync_factor", "18431": "net_ipv6_mld_max_msf", "18432": "net_ipv6_mtu", "18433": "net_ipv6_neigh", "18434": "net_ipv6_proxy_ndp", "18435": "net_ipv6_regen_max_retry", "18436": "net_ipv6_route", "18437": "net_ipv6_route_gc_elasticity", "18438": "net_ipv6_route_gc_interval", "18439": "net_ipv6_route_gc_min_interval", "18440": "net_ipv6_route_gc_min_interval_ms", "18441": "net_ipv6_route_gc_thresh", "18442": "net_ipv6_route_gc_timeout", "18443": "net_ipv6_route_max_size", "18444": "net_ipv6_route_min_advmss", "18445": "net_ipv6_route_mtu_expires", "18446": "net_ipv6_rtr_probe_interval", "18447": "net_ipv6_rtr_solicit_delay", "18448": "net_ipv6_rtr_solicit_interval", "18449": "net_ipv6_rtr_solicits", "18450": "net_ipv6_temp_prefered_lft", "18451": "net_ipv6_temp_valid_lft", "18452": "net_ipv6_use_tempaddr", "18453": "net_ipx", "18454": "net_ipx_pprop_broadcasting", "18455": "net_irda", "18456": "net_irda_debug", "18457": "net_irda_devname", "18458": "net_irda_discovery", "18459": "net_irda_discovery_slots", "18460": "net_irda_discovery_timeout", "18461": "net_irda_fast_poll", "18462": "net_irda_lap_keepalive_time", "18463": "net_irda_max_baud_rate", "18464": "net_irda_max_noreply_time", "18465": "net_irda_max_tx_data_size", "18466": "net_irda_max_tx_window", "18467": "net_irda_min_tx_turn_time", "18468": "net_irda_slot_timeout", "18469": "net_irda_warn_noreply_time", "18470": "net_llc", "18471": "net_llc2", "18472": "net_llc2_ack_timeout", "18473": "net_llc2_busy_timeout", "18474": "net_llc2_p_timeout", "18475": "net_llc2_rej_timeout", "18476": "net_llc_station", "18477": "net_llc_station_ack_timeout", "18478": "net_neigh_app_solicit", "18479": "net_neigh_delay_probe_time", "18480": "net_neigh_gc_interval", "18481": "net_neigh_gc_stale_time", "18482": "net_neigh_gc_thresh1", "18483": "net_neigh_gc_thresh2", "18484": "net_neigh_gc_thresh3", "18485": "net_neigh_mcast_solicit", "18486": "net_neigh_proxy_qlen", "18487": "net_neigh_reachable_time", "18488": "net_neigh_reachable_time_ms", "18489": "net_neigh_retrans_time_ms", "18490": "net_neigh_ucast_solicit", "18491": "net_neigh_unres_qlen", "18492": "net_netfilter", "18493": "net_netrom", "18494": "net_netrom_default_path_quality", "18495": "net_netrom_link_fails_count", "18496": "net_netrom_network_ttl_initialiser", "18497": "net_netrom_obsolescence_count_initialiser", "18498": "net_netrom_reset", "18499": "net_netrom_routing_control", "18500": "net_netrom_transport_acknowledge_delay", "18501": "net_netrom_transport_busy_delay", "18502": "net_netrom_transport_maximum_tries", "18503": "net_netrom_transport_no_activity_timeout", "18504": "net_netrom_transport_requested_window_size", "18505": "net_netrom_transport_timeout", "18506": "net_nf_conntrack_buckets", "18507": "net_nf_conntrack_checksum", "18508": "net_nf_conntrack_count", "18509": "net_nf_conntrack_frag6_high_thresh", "18510": "net_nf_conntrack_frag6_low_thresh", "18511": "net_nf_conntrack_log_invalid", "18512": "net_nf_conntrack_max", "18513": "net_nf_conntrack_tcp_be_liberal", "18514": "net_nf_conntrack_tcp_loose", "18515": "net_nf_conntrack_tcp_max_retrans", "18516": "net_ns", "18517": "net_proto_conf_all", "18518": "net_proto_conf_default", "18519": "net_rose", "18520": "net_rose_ack_hold_back_timeout", "18521": "net_rose_call_request_timeout", "18522": "net_rose_clear_request_timeout", "18523": "net_rose_link_fail_timeout", "18524": "net_rose_max_vcs", "18525": "net_rose_no_activity_timeout", "18526": "net_rose_reset_request_timeout", "18527": "net_rose_restart_request_timeout", "18528": "net_rose_routing_control", "18529": "net_rose_window_size", "18530": "net_sctp", "18531": "net_sctp_addip_enable", "18532": "net_sctp_association_max_retrans", "18533": "net_sctp_hb_interval", "18534": "net_sctp_max_burst", "18535": "net_sctp_max_init_retransmits", "18536": "net_sctp_path_max_retrans", "18537": "net_sctp_preserve_enable", "18538": "net_sctp_prsctp_enable", "18539": "net_sctp_rcvbuf_policy", "18540": "net_sctp_rto_alpha", "18541": "net_sctp_rto_beta", "18542": "net_sctp_rto_initial", "18543": "net_sctp_rto_max", "18544": "net_sctp_rto_min", "18545": "net_sctp_sack_timeout", "18546": "net_sctp_sndbuf_policy", "18547": "net_sctp_valid_cookie_life", "18548": "net_tcp_abort_on_overflow", "18549": "net_tcp_adv_win_scale", "18550": "net_tcp_allowed_cong_control", "18551": "net_tcp_app_win", "18552": "net_tcp_base_mss", "18553": "net_tcp_cong_control", "18554": "net_tcp_dsack", "18555": "net_tcp_ecn", "18556": "net_tcp_fack", "18557": "net_tcp_frto", "18558": "net_tcp_frto_response", "18559": "net_tcp_low_latency", "18560": "net_tcp_max_orphans", "18561": "net_tcp_max_ssthresh", "18562": "net_tcp_max_syn_backlog", "18563": "net_tcp_max_tw_buckets", "18564": "net_tcp_mem", "18565": "net_tcp_moderate_rcvbuf", "18566": "net_tcp_mtu_probing", "18567": "net_tcp_no_metrics_save", "18568": "net_tcp_orphan_retries", "18569": "net_tcp_reordering", "18570": "net_tcp_rfc1337", "18571": "net_tcp_rmem", "18572": "net_tcp_slow_start_after_idle", "18573": "net_tcp_stdurg", "18574": "net_tcp_synack_retries", "18575": "net_tcp_syncookies", "18576": "net_tcp_tso_win_divisor", "18577": "net_tcp_tw_recycle", "18578": "net_tcp_tw_reuse", "18579": "net_tcp_wmem", "18580": "net_tr", "18581": "net_tr_rif_timeout", "18582": "net_unix", "18583": "net_unix_max_dgram_qlen", "18584": "net_x25", "18585": "net_x25_ack_hold_back_timeout", "18586": "net_x25_call_request_timeout", "18587": "net_x25_clear_request_timeout", "18588": "net_x25_forward", "18589": "net_x25_reset_request_timeout", "18590": "net_x25_restart_request_timeout", "18591": "netlink_ack", "18592": "netlink_audit", "18593": "netlink_capable", "18594": "netlink_cb", "18595": "netlink_has_listeners", "18596": "netlink_kernel_cfg", "18597": "netlink_kernel_create", "18598": "netlink_kernel_release", "18599": "netlink_unicast", "18600": "network_lat_constraints", "18601": "network_lat_notifier", "18602": "network_lat_pm_qos", "18603": "network_throughput_notifier", "18604": "network_throughput_pm_qos", "18605": "network_tput_constraints", "18606": "never", "18607": "new", "18608": "new32", "18609": "new64", "18610": "new_action", "18611": "new_attrs", "18612": "new_base", "18613": "new_bit", "18614": "new_blocked", "18615": "new_bm", "18616": "new_bw", "18617": "new_cap", "18618": "new_cgrp", "18619": "new_class", "18620": "new_clock", "18621": "new_count", "18622": "new_cpu", "18623": "new_cpumask", "18624": "new_cpus", "18625": "new_cred", "18626": "new_cset", "18627": "new_css", "18628": "new_dbg_io_ops", "18629": "new_decode_dev", "18630": "new_dl", "18631": "new_dst_cpu", "18632": "new_exe_file", "18633": "new_ext", "18634": "new_fd", "18635": "new_fdp", "18636": "new_feature", "18637": "new_filter_string", "18638": "new_flag", "18639": "new_fs", "18640": "new_fsp", "18641": "new_func", "18642": "new_hash", "18643": "new_head", "18644": "new_idmap_permitted", "18645": "new_index", "18646": "new_ioc", "18647": "new_ka", "18648": "new_len", "18649": "new_load", "18650": "new_lock", "18651": "new_map", "18652": "new_mask", "18653": "new_mems", "18654": "new_mp", "18655": "new_name_str", "18656": "new_node", "18657": "new_ns", "18658": "new_nsp", "18659": "new_nsproxy", "18660": "new_opcode", "18661": "new_page", "18662": "new_pages", "18663": "new_parent", "18664": "new_pcap", "18665": "new_pgs", "18666": "new_pos", "18667": "new_prog", "18668": "new_rd", "18669": "new_res", "18670": "new_rlim", "18671": "new_sa", "18672": "new_sb", "18673": "new_sc", "18674": "new_set", "18675": "new_setting", "18676": "new_size", "18677": "new_sl", "18678": "new_spec", "18679": "new_ss", "18680": "new_ss_mask", "18681": "new_t", "18682": "new_tasks", "18683": "new_timer", "18684": "new_timer_id", "18685": "new_tp", "18686": "new_ts", "18687": "new_tz", "18688": "new_user", "18689": "new_utsname", "18690": "new_value", "18691": "newblocked", "18692": "newcookie", "18693": "newdev", "18694": "newf", "18695": "newidle_idx", "18696": "newlen", "18697": "newmask", "18698": "newmems", "18699": "newmm", "18700": "newoldstate", "18701": "newprio", "18702": "newset", "18703": "newset32", "18704": "newsize", "18705": "newsp", "18706": "newstate", "18707": "newtail", "18708": "newts", "18709": "newuname", "18710": "newval", "18711": "next", "18712": "next_arg", "18713": "next_balance", "18714": "next_bio", "18715": "next_buddy", "18716": "next_buddy_marked", "18717": "next_color", "18718": "next_cookie", "18719": "next_cpu", "18720": "next_ctx", "18721": "next_decay_max_lb_cost", "18722": "next_entry", "18723": "next_event", "18724": "next_event_type", "18725": "next_group", "18726": "next_index", "18727": "next_insn", "18728": "next_instance", "18729": "next_jiffies", "18730": "next_key", "18731": "next_l", "18732": "next_line", "18733": "next_nb", "18734": "next_node", "18735": "next_nr", "18736": "next_page", "18737": "next_parent", "18738": "next_pi", "18739": "next_pid", "18740": "next_pidmap", "18741": "next_pool", "18742": "next_prio", "18743": "next_queue", "18744": "next_res", "18745": "next_resource", "18746": "next_rq", "18747": "next_scan", "18748": "next_signal", "18749": "next_state", "18750": "next_string", "18751": "next_swap", "18752": "next_task", "18753": "next_task_group", "18754": "next_thread", "18755": "next_timer", "18756": "next_timer_max_delta", "18757": "next_ts", "18758": "next_uentry", "18759": "next_update", "18760": "nextarg", "18761": "nextargp", "18762": "nextc", "18763": "nextevt", "18764": "nextp", "18765": "nextr", "18766": "nextseq", "18767": "nextval", "18768": "nextw", "18769": "nfakewriters", "18770": "nfb", "18771": "nflags", "18772": "nfreed", "18773": "ng", "18774": "ngarbage", "18775": "ngroups", "18776": "ngroups_max", "18777": "nh", "18778": "nhit", "18779": "nice", "18780": "nice_0_load", "18781": "nice_0_shift", "18782": "nice_rlim", "18783": "nice_to_prio", "18784": "nice_to_rlimit", "18785": "niceval", "18786": "nid", "18787": "ninterval", "18788": "nivcsw", "18789": "nj", "18790": "nl", "18791": "nl_cfg_f_nonroot_recv", "18792": "nla_get_u32", "18793": "nla_len", "18794": "nla_policy", "18795": "nla_string", "18796": "nla_total_size", "18797": "nla_u32", "18798": "nlattr", "18799": "nlen", "18800": "nlh", "18801": "nlm_f_ack", "18802": "nlm_f_multi", "18803": "nlmsg_data", "18804": "nlmsg_done", "18805": "nlmsg_flags", "18806": "nlmsg_free", "18807": "nlmsg_hdr", "18808": "nlmsg_hdrlen", "18809": "nlmsg_len", "18810": "nlmsg_multicast", "18811": "nlmsg_new", "18812": "nlmsg_next", "18813": "nlmsg_ok", "18814": "nlmsg_pid", "18815": "nlmsg_put", "18816": "nlmsg_seq", "18817": "nlmsg_type", "18818": "nlmsghdr", "18819": "nloaded", "18820": "nlpd", "18821": "nlsk", "18822": "nmaskbits", "18823": "nmi_watchdog_enabled", "18824": "nmi_watchdog_enabled_bit", "18825": "nmissed", "18826": "nmsk", "18827": "no", "18828": "no_action", "18829": "no_blink", "18830": "no_children", "18831": "no_cmdline_map", "18832": "no_console_suspend", "18833": "no_constraint_value", "18834": "no_irq_affinity", "18835": "no_irq_chip", "18836": "no_join", "18837": "no_llseek", "18838": "no_nice", "18839": "no_numa", "18840": "no_poll_char", "18841": "no_printk", "18842": "no_suspend_depth", "18843": "no_unaligned_warning", "18844": "no_uprobe_events", "18845": "nocb", "18846": "nocb_defer_wakeup", "18847": "nocb_follower_head", "18848": "nocb_follower_tail", "18849": "nocb_follower_wait", "18850": "nocb_gp_head", "18851": "nocb_gp_tail", "18852": "nocb_gp_wq", "18853": "nocb_head", "18854": "nocb_kthread", "18855": "nocb_leader", "18856": "nocb_leader_sleep", "18857": "nocb_leader_wait", "18858": "nocb_next_follower", "18859": "nocb_q_count", "18860": "nocb_q_count_lazy", "18861": "nocb_tail", "18862": "nocb_wq", "18863": "noclean", "18864": "nocompress", "18865": "node", "18866": "node_bit", "18867": "node_distance", "18868": "node_found", "18869": "node_isset", "18870": "node_lock", "18871": "node_mask_none", "18872": "node_online_map", "18873": "node_pfn", "18874": "node_possible_map", "18875": "node_random", "18876": "node_set", "18877": "node_stamp", "18878": "node_states", "18879": "nodelist_parse", "18880": "nodemask", "18881": "nodemask_pr_args", "18882": "nodemask_t", "18883": "nodename", "18884": "nodep", "18885": "nodes", "18886": "nodes_and", "18887": "nodes_clear", "18888": "nodes_empty", "18889": "nodes_equal", "18890": "nodes_intersects", "18891": "nodes_or", "18892": "nodes_setall", "18893": "nodes_subset", "18894": "nodes_weight", "18895": "nohibernate", "18896": "nohz", "18897": "nohz_balance_enter_idle", "18898": "nohz_balance_exit_idle", "18899": "nohz_balance_kick", "18900": "nohz_balancer_kick", "18901": "nohz_flags", "18902": "nohz_full_kick_ipi", "18903": "nohz_full_kick_work", "18904": "nohz_full_kick_work_func", "18905": "nohz_idle", "18906": "nohz_idle_balance", "18907": "nohz_kick_needed", "18908": "nohz_mode", "18909": "nohz_mode_highres", "18910": "nohz_mode_inactive", "18911": "nohz_mode_lowres", "18912": "nohz_stamp", "18913": "nohz_tick_stopped", "18914": "noinline", "18915": "noirq", "18916": "noirqdebug", "18917": "noirqdebug_setup", "18918": "nokprobe_inline", "18919": "nokprobe_symbol", "18920": "non_isolated_cpus", "18921": "none", "18922": "nonlazy_posted", "18923": "nonlazy_posted_snap", "18924": "nonly", "18925": "nonseekable_open", "18926": "nontask_capacity", "18927": "noop", "18928": "noop_llseek", "18929": "noop_ret", "18930": "nop", "18931": "nop_test_accept", "18932": "nop_test_refuse", "18933": "nop_trace", "18934": "noresume", "18935": "norm", "18936": "normal_prio", "18937": "normalize_cfs_quota", "18938": "normalize_rt_tasks", "18939": "normalize_task", "18940": "normalized_sysctl_", "18941": "normalized_sysctl_sched_latency", "18942": "normalized_sysctl_sched_min_granularity", "18943": "normalized_sysctl_sched_wakeup_granularity", "18944": "nosave_region", "18945": "nosave_regions", "18946": "nosect", "18947": "nosmp", "18948": "not", "18949": "not_gpl_only", "18950": "not_in_range", "18951": "not_init", "18952": "not_visited", "18953": "note", "18954": "note_buf_t", "18955": "note_gp_changes", "18956": "note_interrupt", "18957": "notes", "18958": "notes_attr", "18959": "notes_attrs", "18960": "notes_size", "18961": "nother", "18962": "notice", "18963": "notification", "18964": "notification_mask", "18965": "notifier", "18966": "notifier_block", "18967": "notifier_call", "18968": "notifier_call_chain", "18969": "notifier_chain_cond_register", "18970": "notifier_chain_register", "18971": "notifier_chain_unregister", "18972": "notifier_data", "18973": "notifier_from_errno", "18974": "notifier_mask", "18975": "notifier_to_errno", "18976": "notifiers", "18977": "notify", "18978": "notify_bad", "18979": "notify_cpu_starting", "18980": "notify_die", "18981": "notify_done", "18982": "notify_ok", "18983": "notify_on_release", "18984": "notify_stop_mask", "18985": "notrace", "18986": "notrace_hash", "18987": "notused", "18988": "now", "18989": "now_gtod", "18990": "nowarn", "18991": "np", "18992": "nr", "18993": "nr_accumulated_samples", "18994": "nr_actions", "18995": "nr_active", "18996": "nr_active_anon", "18997": "nr_active_file", "18998": "nr_alloc", "18999": "nr_args", "19000": "nr_balance_failed", "19001": "nr_blocks", "19002": "nr_busy", "19003": "nr_busy_cpus", "19004": "nr_bytes", "19005": "nr_callchain_events", "19006": "nr_calls", "19007": "nr_cgrps", "19008": "nr_chain_hlocks", "19009": "nr_comm_events", "19010": "nr_compat_longs", "19011": "nr_context_switches", "19012": "nr_copy_pages", "19013": "nr_cpu_ids", "19014": "nr_cpumask_bits", "19015": "nr_cpus", "19016": "nr_cpus_allowed", "19017": "nr_cpus_bits", "19018": "nr_cpusets", "19019": "nr_cyclic_check_recursions", "19020": "nr_cyclic_checks", "19021": "nr_dirtied", "19022": "nr_dirtied_pause", "19023": "nr_drainers", "19024": "nr_entries", "19025": "nr_events", "19026": "nr_exclusive", "19027": "nr_extents", "19028": "nr_failed_migrations_affine", "19029": "nr_failed_migrations_hot", "19030": "nr_failed_migrations_running", "19031": "nr_faults", "19032": "nr_file_mapped", "19033": "nr_find_usage_backwards_checks", "19034": "nr_find_usage_backwards_recursions", "19035": "nr_find_usage_forwards_checks", "19036": "nr_find_usage_forwards_recursions", "19037": "nr_forced_migrations", "19038": "nr_free", "19039": "nr_free_highpages", "19040": "nr_free_pages", "19041": "nr_freq", "19042": "nr_freq_events", "19043": "nr_garbage", "19044": "nr_hangs", "19045": "nr_hardirq_chains", "19046": "nr_hardirq_read_safe", "19047": "nr_hardirq_read_unsafe", "19048": "nr_hardirq_safe", "19049": "nr_hardirq_unsafe", "19050": "nr_hashed", "19051": "nr_highmem", "19052": "nr_highmem_p", "19053": "nr_hits", "19054": "nr_idle", "19055": "nr_ids", "19056": "nr_in_flight", "19057": "nr_inactive_anon", "19058": "nr_inactive_file", "19059": "nr_io_wait", "19060": "nr_iowait", "19061": "nr_iowait_cpu", "19062": "nr_irq_read_safe", "19063": "nr_irq_read_unsafe", "19064": "nr_irq_safe", "19065": "nr_irq_unsafe", "19066": "nr_irqs", "19067": "nr_irqs_legacy", "19068": "nr_kernel_stack", "19069": "nr_latency", "19070": "nr_list_entries", "19071": "nr_load_updates", "19072": "nr_lock_chains", "19073": "nr_lock_classes", "19074": "nr_loops", "19075": "nr_meta_pages", "19076": "nr_migrations", "19077": "nr_migrations_cold", "19078": "nr_mmap_events", "19079": "nr_mpi", "19080": "nr_node_ids", "19081": "nr_numa_hint_fault_buckets", "19082": "nr_numa_hint_fault_stats", "19083": "nr_numa_hint_fault_types", "19084": "nr_numa_running", "19085": "nr_of_irqs", "19086": "nr_opts", "19087": "nr_pageflags", "19088": "nr_pages", "19089": "nr_pages_same", "19090": "nr_pages_to_update", "19091": "nr_periods", "19092": "nr_preferred_running", "19093": "nr_process_chains", "19094": "nr_processes", "19095": "nr_profile_grp", "19096": "nr_pte_updates", "19097": "nr_ptes", "19098": "nr_pwqs_to_flush", "19099": "nr_range", "19100": "nr_removed", "19101": "nr_retries", "19102": "nr_rq", "19103": "nr_running", "19104": "nr_scan_pages", "19105": "nr_sects", "19106": "nr_segments", "19107": "nr_siblings", "19108": "nr_slab_reclaimable", "19109": "nr_sleeping", "19110": "nr_softirq_chains", "19111": "nr_softirq_read_safe", "19112": "nr_softirq_read_unsafe", "19113": "nr_softirq_safe", "19114": "nr_softirq_unsafe", "19115": "nr_softirqs", "19116": "nr_spread_over", "19117": "nr_stack_trace_entries", "19118": "nr_stat", "19119": "nr_stopped", "19120": "nr_switches", "19121": "nr_syscalls", "19122": "nr_systemwide", "19123": "nr_task_events", "19124": "nr_tasks", "19125": "nr_threads", "19126": "nr_throttled", "19127": "nr_ticks", "19128": "nr_to_call", "19129": "nr_to_init", "19130": "nr_to_read", "19131": "nr_to_write", "19132": "nr_todo", "19133": "nr_uncategorized", "19134": "nr_uninterruptible", "19135": "nr_unused", "19136": "nr_unused_locks", "19137": "nr_waiters", "19138": "nr_wakeups", "19139": "nr_wakeups_affine", "19140": "nr_wakeups_affine_attempts", "19141": "nr_wakeups_idle", "19142": "nr_wakeups_local", "19143": "nr_wakeups_migrate", "19144": "nr_wakeups_passive", "19145": "nr_wakeups_remote", "19146": "nr_wakeups_sync", "19147": "nr_workers", "19148": "nrcpus", "19149": "nreaders", "19150": "nreaders_stress", "19151": "nrealreaders", "19152": "nrealreaders_stress", "19153": "nrealwriters_stress", "19154": "nrq", "19155": "ns", "19156": "ns2usecs", "19157": "ns_alloc_inum", "19158": "ns_capable", "19159": "ns_common", "19160": "ns_free_inum", "19161": "ns_ninterval", "19162": "ns_nval", "19163": "ns_of_pid", "19164": "ns_offset", "19165": "ns_to_jiffies", "19166": "ns_to_ktime", "19167": "ns_to_timespec", "19168": "ns_to_timespec64", "19169": "nsec", "19170": "nsec_conversion", "19171": "nsec_fls", "19172": "nsec_high", "19173": "nsec_jiffie_sc", "19174": "nsec_per_jiffy", "19175": "nsec_per_msec", "19176": "nsec_per_sec", "19177": "nsec_per_usec", "19178": "nsec_rem", "19179": "nsec_to_ahz", "19180": "nsec_to_clock_t", "19181": "nsecps", "19182": "nsecs", "19183": "nsecs_raw", "19184": "nsecs_real", "19185": "nsecs_rem", "19186": "nsecs_str", "19187": "nsecs_to_cputime", "19188": "nsecs_to_cputime64", "19189": "nsecs_to_jiffies", "19190": "nsecs_to_jiffies64", "19191": "nsecs_to_usecs", "19192": "nsections", "19193": "nset", "19194": "nsleep", "19195": "nsleep_restart", "19196": "nslot", "19197": "nsproxy", "19198": "nsproxy_cache_init", "19199": "nsproxy_cachep", "19200": "nsrc", "19201": "nstack", "19202": "nstype", "19203": "nsynctypes", "19204": "nt_prstatus", "19205": "nte", "19206": "nthe", "19207": "nto", "19208": "ntp_clear", "19209": "ntp_err_mult", "19210": "ntp_error", "19211": "ntp_error_shift", "19212": "ntp_init", "19213": "ntp_interval_freq", "19214": "ntp_interval_length", "19215": "ntp_notify_cmos_timer", "19216": "ntp_offset_chunk", "19217": "ntp_phase_limit", "19218": "ntp_scale_shift", "19219": "ntp_synced", "19220": "ntp_tick", "19221": "ntp_tick_length", "19222": "ntp_update_frequency", "19223": "ntp_update_offset", "19224": "ntp_update_offset_fll", "19225": "ntp_validate_timex", "19226": "ntpinterval", "19227": "null", "19228": "null_pm_qos", "19229": "nullsz", "19230": "num", "19231": "num_active_cpus", "19232": "num_chips", "19233": "num_counter_active", "19234": "num_cpus", "19235": "num_cpus_frozen", "19236": "num_ct", "19237": "num_ctors", "19238": "num_debug", "19239": "num_exentries", "19240": "num_ftrace_callsites", "19241": "num_gpl_future_syms", "19242": "num_gpl_syms", "19243": "num_jump_entries", "19244": "num_kp", "19245": "num_loaded", "19246": "num_obj", "19247": "num_online_cpus", "19248": "num_pages", "19249": "num_params", "19250": "num_physpages", "19251": "num_possible_cpus", "19252": "num_possible_nodes", "19253": "num_rcu_lvl", "19254": "num_rcu_lvl_0", "19255": "num_rcu_lvl_1", "19256": "num_rcu_lvl_2", "19257": "num_rcu_lvl_3", "19258": "num_rcu_lvl_4", "19259": "num_rcu_nodes", "19260": "num_syms", "19261": "num_symtab", "19262": "num_tests", "19263": "num_threads", "19264": "num_to_init", "19265": "num_trace_bprintk_fmt", "19266": "num_trace_enums", "19267": "num_trace_events", "19268": "num_tracepoints", "19269": "num_types", "19270": "num_unused_gpl_syms", "19271": "num_unused_syms", "19272": "num_versions", "19273": "numa", "19274": "numa_backplane", "19275": "numa_cpu", "19276": "numa_cpubuf", "19277": "numa_direct", "19278": "numa_faults", "19279": "numa_faults_locality", "19280": "numa_faults_stats", "19281": "numa_favour_higher", "19282": "numa_get_avg_runtime", "19283": "numa_glueless_mesh", "19284": "numa_group", "19285": "numa_level", "19286": "numa_mem", "19287": "numa_membuf", "19288": "numa_migrate_preferred", "19289": "numa_migrate_retry", "19290": "numa_next_scan", "19291": "numa_no_node", "19292": "numa_pages_migrated", "19293": "numa_period_slots", "19294": "numa_period_threshold", "19295": "numa_preferred_nid", "19296": "numa_pwq_tbl", "19297": "numa_pwq_tbl_install", "19298": "numa_resist_lower", "19299": "numa_scan_offset", "19300": "numa_scan_period", "19301": "numa_scan_period_max", "19302": "numa_scan_seq", "19303": "numa_stats", "19304": "numa_topology_type", "19305": "numa_work", "19306": "numa_zonelist_order", "19307": "numa_zonelist_order_handler", "19308": "numa_zonelist_order_len", "19309": "numabalancing_enabled", "19310": "number", "19311": "number_of_wakelocks", "19312": "numbers", "19313": "numchips", "19314": "numregbytes", "19315": "nused", "19316": "nval", "19317": "nvcsw", "19318": "nvec", "19319": "nvec_used", "19320": "nvisit", "19321": "nwatch", "19322": "nwhich", "19323": "nwriters_stress", "19324": "nxt", "19325": "nxtcompleted", "19326": "nxtlist", "19327": "nxttail", "19328": "nyou", "19329": "o", "19330": "o_accmode", "19331": "o_append", "19332": "o_cloexec", "19333": "o_largefile", "19334": "o_rdonly", "19335": "o_rdwr", "19336": "o_trunc", "19337": "o_utask", "19338": "o_wronly", "19339": "oact", "19340": "obj", "19341": "obj_tree", "19342": "object_debug", "19343": "object_size", "19344": "objname", "19345": "objs", "19346": "objtree", "19347": "odebug_state_active", "19348": "odebug_state_notavailable", "19349": "oentry", "19350": "of", "19351": "of_cft", "19352": "of_css", "19353": "of_node", "19354": "of_node_full_name", "19355": "of_node_get", "19356": "of_node_put", "19357": "of_node_to_nid", "19358": "off", "19359": "offline", "19360": "offline_css", "19361": "offline_fqs", "19362": "offline_waitq", "19363": "offp", "19364": "offs", "19365": "offs_boot", "19366": "offs_real", "19367": "offs_tai", "19368": "offset", "19369": "offset64", "19370": "offset_to_vaddr", "19371": "offsetof", "19372": "offsets", "19373": "oflag", "19374": "oflags", "19375": "ok", "19376": "old", "19377": "old32", "19378": "old64", "19379": "old_addr", "19380": "old_base", "19381": "old_bt", "19382": "old_bw", "19383": "old_cgrp", "19384": "old_clock", "19385": "old_contrib", "19386": "old_count", "19387": "old_cset", "19388": "old_css", "19389": "old_dbg_io_ops", "19390": "old_delta", "19391": "old_encode_dev", "19392": "old_entries", "19393": "old_entry", "19394": "old_exe", "19395": "old_exe_file", "19396": "old_ext", "19397": "old_feature", "19398": "old_flag", "19399": "old_flags", "19400": "old_fs", "19401": "old_fsgid", "19402": "old_fsuid", "19403": "old_getrlimit", "19404": "old_gid_t", "19405": "old_hash", "19406": "old_idx", "19407": "old_index", "19408": "old_iowait", "19409": "old_ka", "19410": "old_load", "19411": "old_lock", "19412": "old_lvl", "19413": "old_mems_allowed", "19414": "old_name", "19415": "old_notify", "19416": "old_ns", "19417": "old_opcode", "19418": "old_p", "19419": "old_page", "19420": "old_pcap", "19421": "old_period", "19422": "old_prio", "19423": "old_ptr", "19424": "old_pwq", "19425": "old_rb", "19426": "old_rd", "19427": "old_regs", "19428": "old_rhpp", "19429": "old_rlim", "19430": "old_rp", "19431": "old_runtime", "19432": "old_sa", "19433": "old_sc", "19434": "old_set", "19435": "old_setting", "19436": "old_sigaction", "19437": "old_sigset_t", "19438": "old_size", "19439": "old_spec", "19440": "old_ss", "19441": "old_stop", "19442": "old_tail", "19443": "old_tk", "19444": "old_tu", "19445": "old_uid_t", "19446": "old_userobj", "19447": "old_utsname", "19448": "old_val", "19449": "old_vsyscall_fixup", "19450": "old_write", "19451": "oldcount", "19452": "oldcs", "19453": "oldest", "19454": "oldf", "19455": "oldfs", "19456": "oldlen", "19457": "oldlenp", "19458": "oldloginuid", "19459": "oldmask", "19460": "oldmm", "19461": "oldold_utsname", "19462": "oldpolicy", "19463": "oldprio", "19464": "oldrss", "19465": "oldsessionid", "19466": "oldset", "19467": "oldstarttime", "19468": "oldstate", "19469": "oldtail", "19470": "oldts", "19471": "olduname", "19472": "oldval", "19473": "omsk", "19474": "on", "19475": "on_cpu", "19476": "on_dfl", "19477": "on_each_cpu", "19478": "on_each_cpu_cond", "19479": "on_each_cpu_mask", "19480": "on_exit_work", "19481": "on_list", "19482": "on_null_domain", "19483": "on_rq", "19484": "on_rt_rq", "19485": "on_sig_stack", "19486": "oncpu", "19487": "one", "19488": "one_hundred", "19489": "one_jiffy_scaled", "19490": "one_ss", "19491": "one_ul", "19492": "oneshot", "19493": "online", "19494": "online_cpus", "19495": "online_css", "19496": "only", "19497": "onoff_get_trigger_ops", "19498": "onoff_holdoff", "19499": "onoff_interval", "19500": "onoff_task", "19501": "onstack", "19502": "oom_callback_count", "19503": "oom_callback_wq", "19504": "oom_head", "19505": "oom_killer_disable", "19506": "oom_killer_enable", "19507": "oom_score_adj", "19508": "oom_score_adj_min", "19509": "oops_in_progress", "19510": "oops_setup", "19511": "op", "19512": "op_and", "19513": "op_band", "19514": "op_eq", "19515": "op_ge", "19516": "op_glob", "19517": "op_gt", "19518": "op_le", "19519": "op_lt", "19520": "op_ne", "19521": "op_none", "19522": "op_not", "19523": "op_open_paren", "19524": "op_or", "19525": "opcode", "19526": "opdata", "19527": "open", "19528": "open_softirq", "19529": "operand", "19530": "operand1", "19531": "operand2", "19532": "operation", "19533": "operations", "19534": "ops", "19535": "ops_references_rec", "19536": "ops_traces_mod", "19537": "opstack", "19538": "opstack_op", "19539": "opstr", "19540": "opt", "19541": "opt_kgdb_con", "19542": "opt_kgdb_wait", "19543": "opt_nokgdbroundup", "19544": "opt_pre_handler", "19545": "optimize_all_kprobes", "19546": "optimize_delay", "19547": "optimize_kprobe", "19548": "optimized_kprobe", "19549": "optimizing_list", "19550": "optimizing_work", "19551": "optinsn", "19552": "option", "19553": "options", "19554": "opts", "19555": "or", "19556": "or_softirq_pending", "19557": "order", "19558": "ordered_wq_attrs", "19559": "orig", "19560": "orig_address", "19561": "orig_bm", "19562": "orig_cred", "19563": "orig_end", "19564": "orig_fn", "19565": "orig_p", "19566": "orig_page", "19567": "orig_prog", "19568": "orig_ret_vaddr", "19569": "orig_sig", "19570": "orig_src_load", "19571": "orig_tai", "19572": "original", "19573": "orphan_donelist", "19574": "orphan_donetail", "19575": "orphan_lock", "19576": "orphan_nxtlist", "19577": "orphan_nxttail", "19578": "orphans_remove", "19579": "orphans_remove_sched", "19580": "orphans_remove_work", "19581": "oset", "19582": "osid", "19583": "osq", "19584": "osq_lock", "19585": "osq_lock_init", "19586": "osq_unlock", "19587": "osrelease", "19588": "oss", "19589": "ostype", "19590": "other", "19591": "other_branch", "19592": "other_hash", "19593": "oublock", "19594": "out", "19595": "out_again", "19596": "out_all_pinned", "19597": "out_alloc", "19598": "out_balanced", "19599": "out_bdput", "19600": "out_bug", "19601": "out_cancel_attach", "19602": "out_cancel_ref", "19603": "out_clean", "19604": "out_cleanup", "19605": "out_deactivate", "19606": "out_dec", "19607": "out_destroy", "19608": "out_disable", "19609": "out_enable", "19610": "out_eoi", "19611": "out_err", "19612": "out_err_free", "19613": "out_fail", "19614": "out_finish", "19615": "out_free", "19616": "out_free_ca", "19617": "out_free_cgrp", "19618": "out_free_control_pages", "19619": "out_free_cpus_allowed", "19620": "out_free_cpuusage", "19621": "out_free_desc", "19622": "out_free_digest", "19623": "out_free_id", "19624": "out_free_image", "19625": "out_free_map", "19626": "out_free_new_mask", "19627": "out_free_post_load_bufs", "19628": "out_free_sha_regions", "19629": "out_free_tfm", "19630": "out_ipc", "19631": "out_irq", "19632": "out_iter_end", "19633": "out_kfree_skb", "19634": "out_kill", "19635": "out_locked", "19636": "out_mask", "19637": "out_mput", "19638": "out_net", "19639": "out_no_start", "19640": "out_nocheck", "19641": "out_notify", "19642": "out_ns", "19643": "out_null", "19644": "out_of_line_wait_on_atomic_t", "19645": "out_of_line_wait_on_bit", "19646": "out_of_line_wait_on_bit_lock", "19647": "out_of_line_wait_on_bit_timeout", "19648": "out_one_pinned", "19649": "out_pid", "19650": "out_put", "19651": "out_put_task", "19652": "out_put_task_struct", "19653": "out_putname", "19654": "out_reg", "19655": "out_release", "19656": "out_release_tset", "19657": "out_replace", "19658": "out_reset", "19659": "out_restore", "19660": "out_save", "19661": "out_set", "19662": "out_set_class_cache", "19663": "out_thread", "19664": "out_unlock", "19665": "out_unlock_bdev", "19666": "out_unlock_cgroup", "19667": "out_unlock_set", "19668": "out_unlocked", "19669": "out_unreg", "19670": "out_unreg_holders", "19671": "out_unreg_param", "19672": "out_uts", "19673": "out_va_end", "19674": "outgoingcpu", "19675": "output", "19676": "output_event", "19677": "output_printk", "19678": "outsparse", "19679": "ovalue", "19680": "over", "19681": "overcommit_kbytes_handler", "19682": "overcommit_ratio_handler", "19683": "overflow", "19684": "overflow_count", "19685": "overflow_projid", "19686": "overflowgid", "19687": "overflowuid", "19688": "overhead", "19689": "overload", "19690": "overloaded", "19691": "override", "19692": "override_architecture", "19693": "override_creds", "19694": "override_release", "19695": "override_rlimit", "19696": "overrun", "19697": "overrun_detected", "19698": "overruns", "19699": "overwrite", "19700": "overwrite_flag", "19701": "owatch", "19702": "owner", "19703": "owner_cpu", "19704": "owner_entry", "19705": "ownername", "19706": "owners", "19707": "p", "19708": "p1", "19709": "p2", "19710": "p64", "19711": "p_event", "19712": "p_list", "19713": "p_ns", "19714": "p_rq", "19715": "pacct", "19716": "pacct_struct", "19717": "pack_threadid", "19718": "padata", "19719": "padata_add_cpu", "19720": "padata_alloc", "19721": "padata_alloc_pd", "19722": "padata_alloc_possible", "19723": "padata_attr_ro", "19724": "padata_attr_rw", "19725": "padata_attr_type", "19726": "padata_cpu_callback", "19727": "padata_cpu_hash", "19728": "padata_cpu_parallel", "19729": "padata_cpu_serial", "19730": "padata_default_attrs", "19731": "padata_do_parallel", "19732": "padata_do_serial", "19733": "padata_flush_queues", "19734": "padata_free", "19735": "padata_free_pd", "19736": "padata_get_next", "19737": "padata_index_to_cpu", "19738": "padata_init", "19739": "padata_init_pqueues", "19740": "padata_init_squeues", "19741": "padata_instance", "19742": "padata_invalid", "19743": "padata_list", "19744": "padata_parallel_queue", "19745": "padata_parallel_worker", "19746": "padata_priv", "19747": "padata_register_cpumask_notifier", "19748": "padata_remove_cpu", "19749": "padata_reorder", "19750": "padata_reorder_timer", "19751": "padata_replace", "19752": "padata_reset", "19753": "padata_serial_queue", "19754": "padata_serial_worker", "19755": "padata_set_cpumask", "19756": "padata_set_cpumasks", "19757": "padata_setup_cpumasks", "19758": "padata_start", "19759": "padata_stop", "19760": "padata_sysfs_entry", "19761": "padata_sysfs_ops", "19762": "padata_sysfs_release", "19763": "padata_sysfs_show", "19764": "padata_sysfs_store", "19765": "padata_unregister_cpumask_notifier", "19766": "padata_validate_cpumask", "19767": "page", "19768": "page_add_new_anon_rmap", "19769": "page_address", "19770": "page_cache_release", "19771": "page_cache_shift", "19772": "page_check_address", "19773": "page_cluster", "19774": "page_cpupid_xchg_last", "19775": "page_entries", "19776": "page_is_guard", "19777": "page_is_ram", "19778": "page_kernel", "19779": "page_key_alloc", "19780": "page_key_free", "19781": "page_key_write", "19782": "page_mapped", "19783": "page_mask", "19784": "page_mkwrite", "19785": "page_off", "19786": "page_order", "19787": "page_remove_rmap", "19788": "page_shift", "19789": "page_size", "19790": "page_table_lock", "19791": "page_to_pfn", "19792": "page_zone", "19793": "pageanon", "19794": "pagebusy", "19795": "pageerror", "19796": "pagefault_disable", "19797": "pagefault_enable", "19798": "pagehighmem", "19799": "pager", "19800": "pagereserved", "19801": "pages", "19802": "pages32", "19803": "pages_for_io", "19804": "pages_highmem", "19805": "pageslab", "19806": "pageuptodate", "19807": "panic", "19808": "panic_blink", "19809": "panic_blink_spd", "19810": "panic_block", "19811": "panic_lock", "19812": "panic_notifier_list", "19813": "panic_on_io_nmi", "19814": "panic_on_oops", "19815": "panic_on_unrecovered_nmi", "19816": "panic_on_warn", "19817": "panic_smp_self_stop", "19818": "panic_timeout", "19819": "panic_timer_step", "19820": "par", "19821": "parallel", "19822": "parallel_cpumask", "19823": "parallel_cpumask_attr", "19824": "parallel_data", "19825": "parallel_mask", "19826": "parallel_work", "19827": "param", "19828": "param_array", "19829": "param_array_free", "19830": "param_array_get", "19831": "param_array_ops", "19832": "param_array_set", "19833": "param_attr_show", "19834": "param_attr_store", "19835": "param_attribute", "19836": "param_check_unsafe", "19837": "param_free_charp", "19838": "param_get_", "19839": "param_get_bool", "19840": "param_get_charp", "19841": "param_get_int", "19842": "param_get_invbool", "19843": "param_get_string", "19844": "param_lock", "19845": "param_max_stack", "19846": "param_ops_", "19847": "param_ops_bint", "19848": "param_ops_bool", "19849": "param_ops_charp", "19850": "param_ops_invbool", "19851": "param_ops_string", "19852": "param_set_", "19853": "param_set_bint", "19854": "param_set_bool", "19855": "param_set_charp", "19856": "param_set_copystring", "19857": "param_set_invbool", "19858": "param_sysfs_builtin", "19859": "param_sysfs_init", "19860": "parameqn", "19861": "params", "19862": "paravirt_steal_clock", "19863": "paravirt_steal_enabled", "19864": "paravirt_steal_rq_enabled", "19865": "parent", "19866": "parent_b", "19867": "parent_ca", "19868": "parent_cs", "19869": "parent_css", "19870": "parent_ctx", "19871": "parent_data", "19872": "parent_entity", "19873": "parent_event", "19874": "parent_exec_id", "19875": "parent_freezer", "19876": "parent_gen", "19877": "parent_ip", "19878": "parent_irq", "19879": "parent_kn", "19880": "parent_len", "19881": "parent_map", "19882": "parent_ns", "19883": "parent_path", "19884": "parent_pid_ns", "19885": "parent_quota", "19886": "parent_tidptr", "19887": "parentlen", "19888": "parg", "19889": "park", "19890": "parked", "19891": "parse", "19892": "parse_args", "19893": "parse_cgroupfs_options", "19894": "parse_crashkernel_mem", "19895": "parse_crashkernel_simple", "19896": "parse_crashkernel_suffix", "19897": "parse_error", "19898": "parse_grep", "19899": "parse_init", "19900": "parse_one", "19901": "parse_operand", "19902": "parse_probe_arg", "19903": "parse_probe_vars", "19904": "parse_rcu_nocb_poll", "19905": "parser", "19906": "part", "19907": "part_devt", "19908": "partial_group", "19909": "partition_sched_domains", "19910": "partno", "19911": "pass_exception", "19912": "passed_quiesce", "19913": "passing", "19914": "patch", "19915": "path", "19916": "path1", "19917": "path2", "19918": "path_equal", "19919": "path_is_under", "19920": "path_max", "19921": "path_put", "19922": "pathbuf", "19923": "pathlen", "19924": "pathname", "19925": "pattern", "19926": "paul", "19927": "pause", "19928": "pause_graph_tracing", "19929": "pause_on_oops", "19930": "pause_on_oops_flag", "19931": "pause_on_oops_lock", "19932": "payload", "19933": "pb", "19934": "pbe", "19935": "pbes_per_linked_page", "19936": "pbuf", "19937": "pc", "19938": "pc_clock_adjtime", "19939": "pc_clock_getres", "19940": "pc_clock_gettime", "19941": "pc_clock_settime", "19942": "pc_timer_create", "19943": "pc_timer_delete", "19944": "pc_timer_gettime", "19945": "pc_timer_settime", "19946": "pcache", "19947": "pci_any_id", "19948": "pci_dev", "19949": "pci_dev_driver", "19950": "pci_dev_put", "19951": "pci_driver", "19952": "pci_get_device", "19953": "pci_msi_mask_irq", "19954": "pci_msi_unmask_irq", "19955": "pci_region_flag_mask", "19956": "pcount", "19957": "pcpu", "19958": "pcpu_list", "19959": "pcpumask", "19960": "pcpusec", "19961": "pcred", "19962": "pcs", "19963": "pd", "19964": "pd_list", "19965": "pd_new", "19966": "pd_old", "19967": "pdata", "19968": "pde_data", "19969": "pdeath_signal", "19970": "pdev", "19971": "pdflush_proc_obsolete", "19972": "pdu", "19973": "pdu_buf", "19974": "pdu_data", "19975": "pdu_len", "19976": "pdu_start", "19977": "pe", "19978": "peek_stack", "19979": "pend", "19980": "pending", "19981": "pending_disable", "19982": "pending_kill", "19983": "pending_list", "19984": "pending_mask", "19985": "pending_only", "19986": "pending_updates", "19987": "pending_wakeup", "19988": "pentry", "19989": "pep", "19990": "per", "19991": "per_cpu", "19992": "per_cpu_ptr", "19993": "per_cpu_ref", "19994": "per_cpu_show", "19995": "per_linux", "19996": "per_linux32", "19997": "per_rcu_node_period", "19998": "percent", "19999": "percent_a", "20000": "percent_b", "20001": "percpu", "20002": "percpu_dev_id", "20003": "percpu_dir", "20004": "percpu_down_read", "20005": "percpu_down_write", "20006": "percpu_enabled", "20007": "percpu_free_rwsem", "20008": "percpu_modalloc", "20009": "percpu_modcopy", "20010": "percpu_modfree", "20011": "percpu_pagelist_fraction", "20012": "percpu_pagelist_fraction_sysctl_handler", "20013": "percpu_ref", "20014": "percpu_ref_exit", "20015": "percpu_ref_init", "20016": "percpu_ref_kill", "20017": "percpu_ref_kill_and_confirm", "20018": "percpu_ref_tryget_live", "20019": "percpu_rw_semaphore", "20020": "percpu_size", "20021": "percpu_up_read", "20022": "percpu_up_write", "20023": "perf", "20024": "perf_adjust_freq_unthr_context", "20025": "perf_adjust_period", "20026": "perf_attach_task", "20027": "perf_attach_task_data", "20028": "perf_aux_flag_overwrite", "20029": "perf_aux_flag_truncated", "20030": "perf_aux_gfp", "20031": "perf_aux_output_begin", "20032": "perf_aux_output_end", "20033": "perf_aux_output_skip", "20034": "perf_aux_size", "20035": "perf_branch_entry", "20036": "perf_calculate_period", "20037": "perf_callchain", "20038": "perf_callchain_entry", "20039": "perf_callchain_kernel", "20040": "perf_callchain_store", "20041": "perf_callchain_user", "20042": "perf_cgroup_defer_enabled", "20043": "perf_cgroup_events", "20044": "perf_cgroup_match", "20045": "perf_cgroup_sched_in", "20046": "perf_cgroup_sched_out", "20047": "perf_cgroup_set_shadow_time", "20048": "perf_cgroup_set_timestamp", "20049": "perf_clock", "20050": "perf_comm_event", "20051": "perf_compat_ioctl", "20052": "perf_context_kernel", "20053": "perf_context_user", "20054": "perf_count_hw_cpu_cycles", "20055": "perf_count_sw_cpu_migrations", "20056": "perf_cpu_context", "20057": "perf_cpu_hrtimer_restart", "20058": "perf_cpu_time_max_percent_handler", "20059": "perf_ctx_lock", "20060": "perf_ctx_unlock", "20061": "perf_data_size", "20062": "perf_detach_cgroup", "20063": "perf_duration_warn", "20064": "perf_duration_work", "20065": "perf_ef_reload", "20066": "perf_ef_start", "20067": "perf_ef_update", "20068": "perf_event", "20069": "perf_event__output_id_sample", "20070": "perf_event_attr", "20071": "perf_event_aux", "20072": "perf_event_aux_ctx", "20073": "perf_event_aux_event", "20074": "perf_event_aux_output_cb", "20075": "perf_event_can_stop_tick", "20076": "perf_event_clock", "20077": "perf_event_comm", "20078": "perf_event_comm_event", "20079": "perf_event_comm_match", "20080": "perf_event_comm_output", "20081": "perf_event_context", "20082": "perf_event_context_sched_in", "20083": "perf_event_context_sched_out", "20084": "perf_event_count", "20085": "perf_event_create_kernel_counter", "20086": "perf_event_ctx_activate", "20087": "perf_event_ctx_deactivate", "20088": "perf_event_ctx_lock", "20089": "perf_event_ctx_lock_nested", "20090": "perf_event_ctx_unlock", "20091": "perf_event_ctxp", "20092": "perf_event_disable", "20093": "perf_event_enable", "20094": "perf_event_enable_on_exec", "20095": "perf_event_exec", "20096": "perf_event_for_each", "20097": "perf_event_for_each_child", "20098": "perf_event_fork", "20099": "perf_event_free_bpf_prog", "20100": "perf_event_free_filter", "20101": "perf_event_free_task", "20102": "perf_event_header", "20103": "perf_event_header__init_id", "20104": "perf_event_index", "20105": "perf_event_init_task", "20106": "perf_event_init_userpage", "20107": "perf_event_ioc_disable", "20108": "perf_event_ioc_enable", "20109": "perf_event_ioc_id", "20110": "perf_event_ioc_period", "20111": "perf_event_ioc_refresh", "20112": "perf_event_ioc_reset", "20113": "perf_event_ioc_set_bpf", "20114": "perf_event_ioc_set_filter", "20115": "perf_event_ioc_set_output", "20116": "perf_event_list", "20117": "perf_event_max_sample_rate", "20118": "perf_event_mmap_event", "20119": "perf_event_mmap_match", "20120": "perf_event_mmap_output", "20121": "perf_event_mmap_page", "20122": "perf_event_mutex", "20123": "perf_event_output", "20124": "perf_event_period", "20125": "perf_event_pid", "20126": "perf_event_read", "20127": "perf_event_read_event", "20128": "perf_event_read_group", "20129": "perf_event_read_one", "20130": "perf_event_read_value", "20131": "perf_event_refresh", "20132": "perf_event_release_kernel", "20133": "perf_event_sched_in", "20134": "perf_event_set_bpf_prog", "20135": "perf_event_set_filter", "20136": "perf_event_set_output", "20137": "perf_event_state_active", "20138": "perf_event_state_error", "20139": "perf_event_state_exit", "20140": "perf_event_state_inactive", "20141": "perf_event_state_off", "20142": "perf_event_sync_stat", "20143": "perf_event_task", "20144": "perf_event_task_disable", "20145": "perf_event_task_match", "20146": "perf_event_task_output", "20147": "perf_event_task_sched_in", "20148": "perf_event_task_sched_out", "20149": "perf_event_task_tick", "20150": "perf_event_tid", "20151": "perf_event_time", "20152": "perf_event_update_userpage", "20153": "perf_event_wakeup", "20154": "perf_events", "20155": "perf_fasync", "20156": "perf_fetch_caller_regs", "20157": "perf_fget_light", "20158": "perf_flag_all", "20159": "perf_flag_fd_cloexec", "20160": "perf_flag_fd_no_group", "20161": "perf_flag_fd_output", "20162": "perf_flag_pid_cgroup", "20163": "perf_fops", "20164": "perf_format_group", "20165": "perf_format_id", "20166": "perf_format_total_time_enabled", "20167": "perf_format_total_time_running", "20168": "perf_format_total_times", "20169": "perf_ftrace_event_register", "20170": "perf_ftrace_function_call", "20171": "perf_ftrace_function_disable", "20172": "perf_ftrace_function_enable", "20173": "perf_ftrace_function_register", "20174": "perf_ftrace_function_unregister", "20175": "perf_get_aux", "20176": "perf_get_regs_user", "20177": "perf_group_attach", "20178": "perf_group_detach", "20179": "perf_group_software", "20180": "perf_guest_cbs", "20181": "perf_guest_info_callbacks", "20182": "perf_hes_stopped", "20183": "perf_install_in_context", "20184": "perf_instruction_pointer", "20185": "perf_ioc_flag_group", "20186": "perf_ioctl", "20187": "perf_lock_task_context", "20188": "perf_log_itrace_start", "20189": "perf_log_throttle", "20190": "perf_max_trace_size", "20191": "perf_misc_flags", "20192": "perf_mmap", "20193": "perf_mmap_alloc_page", "20194": "perf_mmap_close", "20195": "perf_mmap_event", "20196": "perf_mmap_fault", "20197": "perf_mmap_free_page", "20198": "perf_mmap_open", "20199": "perf_mmap_to_page", "20200": "perf_mmap_unmark_page", "20201": "perf_mmap_vmops", "20202": "perf_nr_contexts", "20203": "perf_output_begin", "20204": "perf_output_copy", "20205": "perf_output_end", "20206": "perf_output_get_handle", "20207": "perf_output_handle", "20208": "perf_output_put", "20209": "perf_output_put_handle", "20210": "perf_output_read", "20211": "perf_output_read_group", "20212": "perf_output_read_one", "20213": "perf_output_sample", "20214": "perf_output_sample_regs", "20215": "perf_output_sample_ustack", "20216": "perf_output_skip", "20217": "perf_output_wakeup", "20218": "perf_paranoid_cpu", "20219": "perf_paranoid_tracepoint_raw", "20220": "perf_pending_event", "20221": "perf_perm", "20222": "perf_pmu_cap_aux_no_sg", "20223": "perf_pmu_cap_aux_sw_doublebuf", "20224": "perf_pmu_cap_exclusive", "20225": "perf_pmu_disable", "20226": "perf_pmu_enable", "20227": "perf_pmu_sched_task", "20228": "perf_poll", "20229": "perf_prepare_sample", "20230": "perf_probe", "20231": "perf_proc_update_handler", "20232": "perf_read", "20233": "perf_read_event", "20234": "perf_read_hw", "20235": "perf_record_comm", "20236": "perf_record_exit", "20237": "perf_record_fork", "20238": "perf_record_misc_comm_exec", "20239": "perf_record_mmap2", "20240": "perf_record_read", "20241": "perf_record_sample", "20242": "perf_refcount", "20243": "perf_reg_abi", "20244": "perf_reg_value", "20245": "perf_register_guest_info_callbacks", "20246": "perf_regs", "20247": "perf_release", "20248": "perf_remove_from_context", "20249": "perf_remove_from_owner", "20250": "perf_rotate_context", "20251": "perf_sample_addr", "20252": "perf_sample_allowed_ns", "20253": "perf_sample_branch_hv", "20254": "perf_sample_branch_kernel", "20255": "perf_sample_branch_perm_plm", "20256": "perf_sample_branch_stack", "20257": "perf_sample_callchain", "20258": "perf_sample_cpu", "20259": "perf_sample_data", "20260": "perf_sample_data_src", "20261": "perf_sample_event_took", "20262": "perf_sample_id", "20263": "perf_sample_identifier", "20264": "perf_sample_ip", "20265": "perf_sample_period", "20266": "perf_sample_period_ns", "20267": "perf_sample_raw", "20268": "perf_sample_read", "20269": "perf_sample_regs_abi_none", "20270": "perf_sample_regs_intr", "20271": "perf_sample_regs_user", "20272": "perf_sample_stack_user", "20273": "perf_sample_stream_id", "20274": "perf_sample_tid", "20275": "perf_sample_time", "20276": "perf_sample_transaction", "20277": "perf_sample_ustack_size", "20278": "perf_sample_weight", "20279": "perf_sched_cb_dec", "20280": "perf_sched_cb_inc", "20281": "perf_sched_cb_usages", "20282": "perf_sched_events", "20283": "perf_set_shadow_time", "20284": "perf_sw_event_sched", "20285": "perf_swevent_get_recursion_context", "20286": "perf_swevent_put_recursion_context", "20287": "perf_syscall_enter", "20288": "perf_syscall_exit", "20289": "perf_sysenter_disable", "20290": "perf_sysenter_enable", "20291": "perf_sysexit_disable", "20292": "perf_sysexit_enable", "20293": "perf_task_event", "20294": "perf_throttled_count", "20295": "perf_throttled_seq", "20296": "perf_trace_add", "20297": "perf_trace_buf", "20298": "perf_trace_buf_prepare", "20299": "perf_trace_buf_submit", "20300": "perf_trace_del", "20301": "perf_trace_destroy", "20302": "perf_trace_event_close", "20303": "perf_trace_event_init", "20304": "perf_trace_event_open", "20305": "perf_trace_event_perm", "20306": "perf_trace_event_reg", "20307": "perf_trace_event_unreg", "20308": "perf_trace_init", "20309": "perf_trace_t", "20310": "perf_type_hardware", "20311": "perf_unregister_guest_info_callbacks", "20312": "perf_user_stack_pointer", "20313": "perf_ustack_task_size", "20314": "perf_workqueue_init", "20315": "perf_wq", "20316": "perform", "20317": "period", "20318": "period_left", "20319": "period_slot", "20320": "period_timer", "20321": "periodic", "20322": "periods", "20323": "perm", "20324": "perm_gid", "20325": "perm_mode", "20326": "perm_tr", "20327": "perm_tr_len", "20328": "perm_uid", "20329": "permitted", "20330": "pernet_operations", "20331": "persistent_clock_exists", "20332": "persistent_clock_is_local", "20333": "persistent_keyring_register", "20334": "persistent_keyring_register_sem", "20335": "personality", "20336": "pf", "20337": "pf_dumpcore", "20338": "pf_exiting", "20339": "pf_forknoexec", "20340": "pf_freezer_skip", "20341": "pf_frozen", "20342": "pf_kthread", "20343": "pf_mce_early", "20344": "pf_mce_process", "20345": "pf_memalloc", "20346": "pf_mutex_tester", "20347": "pf_no_setaffinity", "20348": "pf_nofreeze", "20349": "pf_nproc_exceeded", "20350": "pf_signaled", "20351": "pf_superpriv", "20352": "pf_suspend_task", "20353": "pf_used_async", "20354": "pf_vcpu", "20355": "pf_wq_worker", "20356": "pflags", "20357": "pfn", "20358": "pfn_down", "20359": "pfn_is_nosave", "20360": "pfn_to_page", "20361": "pfn_up", "20362": "pfn_valid", "20363": "pg", "20364": "pg_any", "20365": "pg_offp", "20366": "pg_safe", "20367": "pg_unsafe_clear", "20368": "pg_unsafe_keep", "20369": "pgd", "20370": "pgd_alloc", "20371": "pgd_free", "20372": "pgid", "20373": "pgoff", "20374": "pgoff_t", "20375": "pgrp", "20376": "phase1_result", "20377": "phase_ts", "20378": "phys", "20379": "phys_to_virt", "20380": "pi", "20381": "pi_blocked_on", "20382": "pi_lock", "20383": "pi_state_cache", "20384": "pi_state_list", "20385": "pi_task", "20386": "pi_tree_entry", "20387": "pi_waiters", "20388": "pi_waiters_leftmost", "20389": "pick_highest_pushable_task", "20390": "pick_next_entity", "20391": "pick_next_pushable_task", "20392": "pick_next_rt_entity", "20393": "pick_next_task", "20394": "pick_next_task_fair", "20395": "pick_next_task_idle", "20396": "pick_next_task_rt", "20397": "pick_rt_task", "20398": "pid", "20399": "pid1", "20400": "pid2", "20401": "pid_alive", "20402": "pid_before", "20403": "pid_cache", "20404": "pid_cachep", "20405": "pid_caches_lh", "20406": "pid_caches_mutex", "20407": "pid_chain", "20408": "pid_count", "20409": "pid_fry", "20410": "pid_hash", "20411": "pid_hashfn", "20412": "pid_link", "20413": "pid_max", "20414": "pid_max_default", "20415": "pid_max_limit", "20416": "pid_max_max", "20417": "pid_max_min", "20418": "pid_namespace", "20419": "pid_namespaces_init", "20420": "pid_nr", "20421": "pid_nr_ns", "20422": "pid_ns", "20423": "pid_ns_cachep", "20424": "pid_ns_ctl_handler", "20425": "pid_ns_ctl_table", "20426": "pid_ns_for_children", "20427": "pid_ns_prepare_proc", "20428": "pid_ns_release_proc", "20429": "pid_t", "20430": "pid_task", "20431": "pid_type", "20432": "pid_vnr", "20433": "pidhash_init", "20434": "pidhash_shift", "20435": "pidhash_size", "20436": "pidlist_allocate", "20437": "pidlist_array_load", "20438": "pidlist_free", "20439": "pidlist_mutex", "20440": "pidlist_too_large", "20441": "pidlist_uniq", "20442": "pidlists", "20443": "pidmap", "20444": "pidmap_entries", "20445": "pidmap_lock", "20446": "pidns_get", "20447": "pidns_hash_adding", "20448": "pidns_install", "20449": "pidns_operations", "20450": "pidns_put", "20451": "pids", "20452": "pids_per_cpu_default", "20453": "pids_per_cpu_min", "20454": "pidtype_max", "20455": "pidtype_pgid", "20456": "pidtype_pid", "20457": "pidtype_sid", "20458": "pin", "20459": "pin_count", "20460": "pin_insert", "20461": "pin_kill", "20462": "pin_remove", "20463": "pinned", "20464": "pinned_groups", "20465": "pinned_sb", "20466": "pinned_vm", "20467": "pinst", "20468": "pinst_has_cpu", "20469": "pip", "20470": "pipe", "20471": "pipe_close", "20472": "pipe_count", "20473": "pipe_inode_info", "20474": "pipe_max_size", "20475": "pipe_min_size", "20476": "pipe_open", "20477": "pipe_proc_fn", "20478": "pipesummary", "20479": "pk", "20480": "pkey_algo_rsa", "20481": "pkey_hash__last", "20482": "pkey_id_x509", "20483": "pks", "20484": "pkt", "20485": "place_entity", "20486": "platform", "20487": "platform_begin", "20488": "platform_device", "20489": "platform_driver", "20490": "platform_end", "20491": "platform_finish", "20492": "platform_hibernation_ops", "20493": "platform_leave", "20494": "platform_mode", "20495": "platform_pre_restore", "20496": "platform_pre_snapshot", "20497": "platform_recover", "20498": "platform_restore_cleanup", "20499": "platform_support", "20500": "please", "20501": "plen", "20502": "plist_add", "20503": "plist_del", "20504": "plist_first", "20505": "plist_first_entry", "20506": "plist_for_each", "20507": "plist_for_each_entry", "20508": "plist_head", "20509": "plist_head_empty", "20510": "plist_head_init", "20511": "plist_last", "20512": "plist_node", "20513": "plist_node_init", "20514": "plug", "20515": "plug_thread", "20516": "pm", "20517": "pm_async", "20518": "pm_async_enabled", "20519": "pm_async_show", "20520": "pm_async_store", "20521": "pm_autosleep_init", "20522": "pm_autosleep_lock", "20523": "pm_autosleep_set_state", "20524": "pm_autosleep_state", "20525": "pm_autosleep_unlock", "20526": "pm_chain_head", "20527": "pm_event_hibernate", "20528": "pm_freezing", "20529": "pm_get_wakeup_count", "20530": "pm_hibernation_prepare", "20531": "pm_labels", "20532": "pm_message_t", "20533": "pm_mutex", "20534": "pm_nosig_freezing", "20535": "pm_notifier", "20536": "pm_notifier_call_chain", "20537": "pm_post_hibernation", "20538": "pm_post_restore", "20539": "pm_post_suspend", "20540": "pm_power_off", "20541": "pm_power_off_prepare", "20542": "pm_prepare_console", "20543": "pm_print_active_wakeup_sources", "20544": "pm_print_times", "20545": "pm_print_times_enabled", "20546": "pm_print_times_init", "20547": "pm_qos_add_notifier", "20548": "pm_qos_add_req", "20549": "pm_qos_add_request", "20550": "pm_qos_array", "20551": "pm_qos_class", "20552": "pm_qos_constraints", "20553": "pm_qos_cpu_dma_lat_default_value", "20554": "pm_qos_cpu_dma_latency", "20555": "pm_qos_dbg_open", "20556": "pm_qos_dbg_show_requests", "20557": "pm_qos_debug_fops", "20558": "pm_qos_default_value", "20559": "pm_qos_flags", "20560": "pm_qos_flags_remove_req", "20561": "pm_qos_flags_request", "20562": "pm_qos_get_value", "20563": "pm_qos_lock", "20564": "pm_qos_max", "20565": "pm_qos_memory_bandwidth_default_value", "20566": "pm_qos_min", "20567": "pm_qos_network_lat_default_value", "20568": "pm_qos_network_throughput_default_value", "20569": "pm_qos_num_classes", "20570": "pm_qos_object", "20571": "pm_qos_power_fops", "20572": "pm_qos_power_init", "20573": "pm_qos_power_miscdev", "20574": "pm_qos_power_open", "20575": "pm_qos_power_read", "20576": "pm_qos_power_release", "20577": "pm_qos_power_write", "20578": "pm_qos_read_value", "20579": "pm_qos_remove_notifier", "20580": "pm_qos_remove_req", "20581": "pm_qos_remove_request", "20582": "pm_qos_req_action", "20583": "pm_qos_request", "20584": "pm_qos_request_active", "20585": "pm_qos_set_value", "20586": "pm_qos_sum", "20587": "pm_qos_update_flags", "20588": "pm_qos_update_req", "20589": "pm_qos_update_request", "20590": "pm_qos_update_request_timeout", "20591": "pm_qos_update_target", "20592": "pm_qos_work_fn", "20593": "pm_restore_console", "20594": "pm_restore_gfp_mask", "20595": "pm_restore_prepare", "20596": "pm_restrict_gfp_mask", "20597": "pm_save_wakeup_count", "20598": "pm_show_wakelocks", "20599": "pm_states", "20600": "pm_suspend", "20601": "pm_suspend_max", "20602": "pm_suspend_mem", "20603": "pm_suspend_min", "20604": "pm_suspend_on", "20605": "pm_suspend_prepare", "20606": "pm_suspend_standby", "20607": "pm_sysrq_init", "20608": "pm_system_wakeup", "20609": "pm_test_level", "20610": "pm_test_show", "20611": "pm_tests", "20612": "pm_wake_lock", "20613": "pm_wake_unlock", "20614": "pm_wakep_autosleep_enabled", "20615": "pm_wakeup_clear", "20616": "pm_wakeup_pending", "20617": "pmask", "20618": "pmd_huge_pte", "20619": "pmod", "20620": "pmsg_freeze", "20621": "pmsg_hibernate", "20622": "pmsg_quiesce", "20623": "pmsg_recover", "20624": "pmsg_restore", "20625": "pmsg_thaw", "20626": "pmtmr", "20627": "pmu", "20628": "pmu_cpu_context", "20629": "pmus", "20630": "pmus_lock", "20631": "pmus_srcu", "20632": "pn", "20633": "pnr", "20634": "pnt", "20635": "pointer", "20636": "points", "20637": "poison_end", "20638": "poison_free", "20639": "poison_inuse", "20640": "pol", "20641": "policy", "20642": "poll", "20643": "poll_spurious_irq_interval", "20644": "poll_spurious_irq_timer", "20645": "poll_spurious_irqs", "20646": "poll_table", "20647": "poll_wait", "20648": "pollhup", "20649": "pollin", "20650": "pollrdnorm", "20651": "pool", "20652": "pool_disassociated", "20653": "pool_id", "20654": "pool_ids", "20655": "pool_mayday_timeout", "20656": "pool_workqueue", "20657": "pop_stack", "20658": "populate_kprobe_blacklist", "20659": "populate_seccomp_data", "20660": "populated", "20661": "populated_cnt", "20662": "populated_kn", "20663": "port", "20664": "portid", "20665": "pos", "20666": "pos_css", "20667": "pos_f", "20668": "posix_clock", "20669": "posix_clock_compat_ioctl", "20670": "posix_clock_desc", "20671": "posix_clock_fasync", "20672": "posix_clock_file_operations", "20673": "posix_clock_ioctl", "20674": "posix_clock_mmap", "20675": "posix_clock_open", "20676": "posix_clock_poll", "20677": "posix_clock_read", "20678": "posix_clock_realtime_adj", "20679": "posix_clock_realtime_get", "20680": "posix_clock_realtime_set", "20681": "posix_clock_register", "20682": "posix_clock_release", "20683": "posix_clock_unregister", "20684": "posix_clocks", "20685": "posix_cpu_timers_can_stop_tick", "20686": "posix_cpu_timers_init", "20687": "posix_cpu_timers_init_group", "20688": "posix_get_boottime", "20689": "posix_get_coarse_res", "20690": "posix_get_monotonic_coarse", "20691": "posix_get_monotonic_raw", "20692": "posix_get_realtime_coarse", "20693": "posix_get_tai", "20694": "posix_ktime_get_ts", "20695": "posix_timer_add", "20696": "posix_timer_by_id", "20697": "posix_timer_event", "20698": "posix_timer_fn", "20699": "posix_timer_id", "20700": "posix_timers", "20701": "posix_timers_cache", "20702": "posix_timers_hashtable", "20703": "posix_timers_register_clock", "20704": "possible", "20705": "post_exception", "20706": "post_handler", "20707": "post_relocation", "20708": "post_schedule", "20709": "post_schedule_rt", "20710": "post_trigger", "20711": "postfix", "20712": "postfix_append_op", "20713": "postfix_append_operand", "20714": "postfix_clear", "20715": "postfix_elt", "20716": "posth_val", "20717": "postponed", "20718": "power", "20719": "power_attr", "20720": "power_down", "20721": "power_kobj", "20722": "power_up", "20723": "poweroff_cmd", "20724": "poweroff_cmd_path_len", "20725": "poweroff_work", "20726": "powner", "20727": "pp", "20728": "ppc_rtas", "20729": "ppid", "20730": "ppm_scale", "20731": "ppm_scale_inv", "20732": "ppm_scale_inv_shift", "20733": "ppos", "20734": "ppp", "20735": "pprev", "20736": "pps_calcnt", "20737": "pps_clear", "20738": "pps_dec_valid", "20739": "pps_errcnt", "20740": "pps_fbase", "20741": "pps_fill_timex", "20742": "pps_freq", "20743": "pps_inc_freq_interval", "20744": "pps_intcnt", "20745": "pps_intcount", "20746": "pps_intmin", "20747": "pps_jitcnt", "20748": "pps_jitter", "20749": "pps_maxwander", "20750": "pps_normalize_ts", "20751": "pps_normtime", "20752": "pps_phase_filter_add", "20753": "pps_phase_filter_get", "20754": "pps_reset_freq_interval", "20755": "pps_set_freq", "20756": "pps_shift", "20757": "pps_stabil", "20758": "pps_stbcnt", "20759": "pps_tf", "20760": "pps_valid", "20761": "ppsfreq", "20762": "pqf", "20763": "pqueue", "20764": "pr_alert", "20765": "pr_cont", "20766": "pr_cont_cgroup_name", "20767": "pr_cont_pool_info", "20768": "pr_cont_work", "20769": "pr_crit", "20770": "pr_crit_once", "20771": "pr_debug", "20772": "pr_devel", "20773": "pr_emerg", "20774": "pr_err", "20775": "pr_fmt", "20776": "pr_get_child_subreaper", "20777": "pr_get_dumpable", "20778": "pr_get_fp_mode", "20779": "pr_get_fpemu", "20780": "pr_get_fpexc", "20781": "pr_get_no_new_privs", "20782": "pr_get_pdeathsig", "20783": "pr_get_thp_disable", "20784": "pr_get_tid_address", "20785": "pr_get_timing", "20786": "pr_get_unalign", "20787": "pr_info", "20788": "pr_info_once", "20789": "pr_mce_kill", "20790": "pr_mce_kill_clear", "20791": "pr_mce_kill_default", "20792": "pr_mce_kill_early", "20793": "pr_mce_kill_get", "20794": "pr_mce_kill_late", "20795": "pr_mce_kill_set", "20796": "pr_mpx_disable_management", "20797": "pr_mpx_enable_management", "20798": "pr_notice", "20799": "pr_notice_once", "20800": "pr_pid", "20801": "pr_reg", "20802": "pr_set_child_subreaper", "20803": "pr_set_dumpable", "20804": "pr_set_fp_mode", "20805": "pr_set_fpemu", "20806": "pr_set_fpexc", "20807": "pr_set_mm", "20808": "pr_set_mm_arg_end", "20809": "pr_set_mm_arg_start", "20810": "pr_set_mm_auxv", "20811": "pr_set_mm_brk", "20812": "pr_set_mm_end_code", "20813": "pr_set_mm_end_data", "20814": "pr_set_mm_env_end", "20815": "pr_set_mm_env_start", "20816": "pr_set_mm_exe_file", "20817": "pr_set_mm_map", "20818": "pr_set_mm_map_size", "20819": "pr_set_mm_start_brk", "20820": "pr_set_mm_start_code", "20821": "pr_set_mm_start_data", "20822": "pr_set_mm_start_stack", "20823": "pr_set_name", "20824": "pr_set_no_new_privs", "20825": "pr_set_pdeathsig", "20826": "pr_set_thp_disable", "20827": "pr_set_timerslack", "20828": "pr_set_timing", "20829": "pr_set_unalign", "20830": "pr_timing_statistical", "20831": "pr_warn", "20832": "pr_warn_once", "20833": "pr_warning", "20834": "prandom_u32", "20835": "prctl", "20836": "prctl_get_tid_address", "20837": "prctl_map", "20838": "prctl_mm_map", "20839": "prctl_set_mm", "20840": "prctl_set_mm_exe_file", "20841": "prctl_set_mm_map", "20842": "prctl_set_seccomp", "20843": "pre_exception", "20844": "pre_handler", "20845": "pre_handler_kretprobe", "20846": "pre_restore", "20847": "pre_snapshot", "20848": "pre_ssout", "20849": "pre_unpark", "20850": "preallocate_image_highmem", "20851": "preallocate_image_memory", "20852": "preallocated_names", "20853": "prec", "20854": "precedence", "20855": "precision", "20856": "pred", "20857": "pred_stack", "20858": "preds", "20859": "preempt", "20860": "preempt_active", "20861": "preempt_check_resched", "20862": "preempt_count", "20863": "preempt_count_add", "20864": "preempt_count_dec", "20865": "preempt_count_equals", "20866": "preempt_count_set", "20867": "preempt_count_sub", "20868": "preempt_disable", "20869": "preempt_disable_ip", "20870": "preempt_disable_notrace", "20871": "preempt_enable", "20872": "preempt_enable_no_resched", "20873": "preempt_enable_notrace", "20874": "preempt_fold_need_resched", "20875": "preempt_mask", "20876": "preempt_notifier", "20877": "preempt_notifier_register", "20878": "preempt_notifier_unregister", "20879": "preempt_notifiers", "20880": "preempt_offset", "20881": "preempt_schedule", "20882": "preempt_schedule_common", "20883": "preempt_schedule_context", "20884": "preempt_schedule_irq", "20885": "preempt_set_need_resched", "20886": "preempt_timestamp", "20887": "preempt_trace", "20888": "preemptible", "20889": "preemption", "20890": "preemptirqsoff_tracer", "20891": "preemptirqsoff_tracer_init", "20892": "preemptoff_tracer", "20893": "preemptoff_tracer_init", "20894": "pref_node_fork", "20895": "prefer_sibling", "20896": "preferred_console", "20897": "preferred_group_nid", "20898": "prefetch", "20899": "prefix", "20900": "prefix_len", "20901": "prefix_max", "20902": "prefix_name", "20903": "preflow_handler", "20904": "preh_val", "20905": "preloaded_csets", "20906": "prelock_base", "20907": "prepare", "20908": "prepare_arch_switch", "20909": "prepare_creds", "20910": "prepare_highmem_image", "20911": "prepare_image", "20912": "prepare_kernel_cred", "20913": "prepare_kprobe", "20914": "prepare_lock_switch", "20915": "prepare_optimized_kprobe", "20916": "prepare_reply", "20917": "prepare_signal", "20918": "prepare_task_switch", "20919": "prepare_to_wait", "20920": "prepare_to_wait_event", "20921": "prepare_to_wait_exclusive", "20922": "prepare_uprobe", "20923": "prepare_uretprobe", "20924": "prepared", "20925": "preparing", "20926": "present", "20927": "preserve_context", "20928": "preset_lpj", "20929": "prev", "20930": "prev_bit", "20931": "prev_chain_key", "20932": "prev_class", "20933": "prev_count", "20934": "prev_cpu", "20935": "prev_cputime", "20936": "prev_ctx", "20937": "prev_eff_load", "20938": "prev_hlock", "20939": "prev_insn_idx", "20940": "prev_irq_time", "20941": "prev_jiffy", "20942": "prev_len", "20943": "prev_lower_first", "20944": "prev_lower_last", "20945": "prev_mm", "20946": "prev_nr", "20947": "prev_offset", "20948": "prev_overruns", "20949": "prev_padding", "20950": "prev_page", "20951": "prev_pid", "20952": "prev_prio", "20953": "prev_state", "20954": "prev_steal_time", "20955": "prev_steal_time_rq", "20956": "prev_subbuf", "20957": "prev_sum_exec_runtime", "20958": "prev_time", "20959": "prev_upper_first", "20960": "prev_upper_last", "20961": "prev_value", "20962": "primary", "20963": "primary_event_id", "20964": "print", "20965": "print_base", "20966": "print_bpf_insn", "20967": "print_cfs_group_stats", "20968": "print_cfs_rq", "20969": "print_cfs_stats", "20970": "print_circular_bug", "20971": "print_counts", "20972": "print_cpu", "20973": "print_cpu_stall", "20974": "print_cpu_stall_fast_no_hz", "20975": "print_cpu_stall_info", "20976": "print_cpu_stall_info_begin", "20977": "print_cpu_stall_info_end", "20978": "print_deadlock_bug", "20979": "print_deadlock_scenario", "20980": "print_disabled", "20981": "print_dl_rq", "20982": "print_dl_stats", "20983": "print_entry", "20984": "print_event_filter", "20985": "print_fatal_signal", "20986": "print_fatal_signals", "20987": "print_fmt", "20988": "print_fn_t", "20989": "print_freed_lock_bug", "20990": "print_graph_abs_time", "20991": "print_graph_comment", "20992": "print_graph_cpu", "20993": "print_graph_duration", "20994": "print_graph_entry", "20995": "print_graph_entry_leaf", "20996": "print_graph_entry_nested", "20997": "print_graph_function", "20998": "print_graph_function_event", "20999": "print_graph_function_flags", "21000": "print_graph_headers", "21001": "print_graph_headers_flags", "21002": "print_graph_irq", "21003": "print_graph_lat_fmt", "21004": "print_graph_proc", "21005": "print_graph_prologue", "21006": "print_graph_return", "21007": "print_header", "21008": "print_held_locks_bug", "21009": "print_ip_ins", "21010": "print_ip_sym", "21011": "print_irq_desc", "21012": "print_irq_lock_scenario", "21013": "print_irqtrace_events", "21014": "print_kernel_ident", "21015": "print_kprobe_event", "21016": "print_kretprobe_event", "21017": "print_lat_header", "21018": "print_line", "21019": "print_line_t", "21020": "print_lock", "21021": "print_lock_contention_bug", "21022": "print_lock_name", "21023": "print_lock_nested_lock_not_held", "21024": "print_lockdep_cache", "21025": "print_lockdep_off", "21026": "print_max", "21027": "print_max_stack", "21028": "print_modules", "21029": "print_name", "21030": "print_name_offset", "21031": "print_once", "21032": "print_one_line", "21033": "print_one_rcu_data", "21034": "print_one_rcu_node_boost", "21035": "print_one_rcu_pending", "21036": "print_one_rcu_state", "21037": "print_oops_end_marker", "21038": "print_other_cpu_stall", "21039": "print_out", "21040": "print_owner", "21041": "print_rq", "21042": "print_rt_rq", "21043": "print_rt_stats", "21044": "print_shortest_lock_dependencies", "21045": "print_stack_trace", "21046": "print_subsystem_event_filter", "21047": "print_symbol", "21048": "print_syscall_exit", "21049": "print_tainted", "21050": "print_task", "21051": "print_tickdevice", "21052": "print_trace_header", "21053": "print_trace_line", "21054": "print_type_", "21055": "print_type_fmt_name", "21056": "print_type_format_", "21057": "print_type_func_name", "21058": "print_type_func_t", "21059": "print_unload_info", "21060": "print_unlock_imbalance_bug", "21061": "print_uprobe_event", "21062": "print_usage_bug", "21063": "print_usage_bug_scenario", "21064": "print_verifier_state", "21065": "print_worker_info", "21066": "printed", "21067": "printed_something", "21068": "printk", "21069": "printk_deferred", "21070": "printk_deferred_once", "21071": "printk_delay_msec", "21072": "printk_lock", "21073": "printk_log", "21074": "printk_once", "21075": "printk_ratelimit", "21076": "printk_ratelimit_state", "21077": "printk_ratelimited", "21078": "printk_task", "21079": "prints", "21080": "prio", "21081": "prio_changed", "21082": "prio_changed_fair", "21083": "prio_changed_idle", "21084": "prio_changed_rt", "21085": "prio_high", "21086": "prio_low", "21087": "prio_pgrp", "21088": "prio_process", "21089": "prio_to_nice", "21090": "prio_to_weight", "21091": "prio_to_wmult", "21092": "prio_user", "21093": "priority", "21094": "priv", "21095": "private", "21096": "private_data", "21097": "prlimit64", "21098": "probe", "21099": "probe_arg", "21100": "probe_event_disable", "21101": "probe_event_enable", "21102": "probe_irq_mask", "21103": "probe_irq_off", "21104": "probe_irq_on", "21105": "probe_kernel_address", "21106": "probe_kernel_read", "21107": "probe_kernel_write", "21108": "probe_kthread_data", "21109": "probe_likely_condition", "21110": "probe_list", "21111": "probe_lock", "21112": "probe_remove_event_call", "21113": "probe_sched_switch", "21114": "probe_sched_wakeup", "21115": "probe_wakeup", "21116": "probe_wakeup_migrate_task", "21117": "probe_wakeup_sched_switch", "21118": "probed_mod", "21119": "probes_open", "21120": "probes_profile_seq_show", "21121": "probes_seq_next", "21122": "probes_seq_op", "21123": "probes_seq_show", "21124": "probes_seq_start", "21125": "probes_seq_stop", "21126": "probes_write", "21127": "probing_active", "21128": "proc", "21129": "proc_caches_init", "21130": "proc_cap_handler", "21131": "proc_cgroupstats_operations", "21132": "proc_cgroupstats_show", "21133": "proc_cleanup_work", "21134": "proc_clear_tty", "21135": "proc_coredump_connector", "21136": "proc_cpuset_show", "21137": "proc_create", "21138": "proc_create_data", "21139": "proc_dir_entry", "21140": "proc_dma_show", "21141": "proc_do_cad_pid", "21142": "proc_dohung_task_timeout_secs", "21143": "proc_dointvec", "21144": "proc_dointvec_jiffies", "21145": "proc_dointvec_minmax", "21146": "proc_dointvec_minmax_coredump", "21147": "proc_dointvec_minmax_sysadmin", "21148": "proc_dointvec_ms_jiffies", "21149": "proc_dointvec_userhz_jiffies", "21150": "proc_dostring", "21151": "proc_dostring_coredump", "21152": "proc_doulongvec_minmax", "21153": "proc_doulongvec_ms_jiffies_minmax", "21154": "proc_event_gid", "21155": "proc_event_uid", "21156": "proc_execdomains_init", "21157": "proc_fork_connector", "21158": "proc_get_long", "21159": "proc_gid_map_write", "21160": "proc_gid_seq_operations", "21161": "proc_handler", "21162": "proc_id_connector", "21163": "proc_iomem_operations", "21164": "proc_ioports_operations", "21165": "proc_kprobes_optimization_handler", "21166": "proc_lock_stat_operations", "21167": "proc_lockdep_chains_operations", "21168": "proc_lockdep_operations", "21169": "proc_lockdep_stats_operations", "21170": "proc_mkdir", "21171": "proc_mnt", "21172": "proc_modules_init", "21173": "proc_modules_operations", "21174": "proc_nmi_watchdog", "21175": "proc_nr_dentry", "21176": "proc_nr_files", "21177": "proc_nr_inodes", "21178": "proc_ns_fget", "21179": "proc_ns_operations", "21180": "proc_pid_init_ino", "21181": "proc_profile_operations", "21182": "proc_projid_map_write", "21183": "proc_projid_seq_operations", "21184": "proc_ptrace_connector", "21185": "proc_put_char", "21186": "proc_put_long", "21187": "proc_remove", "21188": "proc_sched_autogroup_set_nice", "21189": "proc_sched_autogroup_show_task", "21190": "proc_sched_set_task", "21191": "proc_sched_show_task", "21192": "proc_set_size", "21193": "proc_setgroups_show", "21194": "proc_setgroups_write", "21195": "proc_sid_connector", "21196": "proc_skip_char", "21197": "proc_skip_spaces", "21198": "proc_soft_watchdog", "21199": "proc_taint", "21200": "proc_uid_map_write", "21201": "proc_uid_seq_operations", "21202": "proc_user_init_ino", "21203": "proc_watchdog", "21204": "proc_watchdog_common", "21205": "proc_watchdog_thresh", "21206": "proc_watchdog_update", "21207": "proc_work", "21208": "proc_wspace_sep", "21209": "process", "21210": "process_adj_status", "21211": "process_adjtimex_modes", "21212": "process_bpf_exit", "21213": "process_counts", "21214": "process_keyring", "21215": "process_one_work", "21216": "process_ops", "21217": "process_scheduled_works", "21218": "process_srcu", "21219": "process_timeout", "21220": "processed", "21221": "processes", "21222": "procname", "21223": "procs", "21224": "proctitle", "21225": "producer", "21226": "producer_fifo", "21227": "producer_nice", "21228": "production", "21229": "prof_buffer", "21230": "prof_cpu_mask", "21231": "prof_cpu_mask_proc_fops", "21232": "prof_cpu_mask_proc_open", "21233": "prof_cpu_mask_proc_show", "21234": "prof_cpu_mask_proc_write", "21235": "prof_exp", "21236": "prof_len", "21237": "prof_on", "21238": "prof_shift", "21239": "profile_cpu_callback", "21240": "profile_discard_flip_buffers", "21241": "profile_event_register", "21242": "profile_event_unregister", "21243": "profile_flip_buffers", "21244": "profile_flip_mutex", "21245": "profile_graph_entry", "21246": "profile_graph_return", "21247": "profile_grpshift", "21248": "profile_grpsz", "21249": "profile_handoff_task", "21250": "profile_hit", "21251": "profile_hits", "21252": "profile_init", "21253": "profile_munmap", "21254": "profile_nop", "21255": "profile_open", "21256": "profile_pc", "21257": "profile_records_size", "21258": "profile_seq_op", "21259": "profile_setup", "21260": "profile_task_exit", "21261": "profile_tick", "21262": "profile_type", "21263": "profiles_per_page", "21264": "profiling", "21265": "profiling_show", "21266": "profiling_store", "21267": "prog", "21268": "prog_fd", "21269": "prog_type", "21270": "proglen", "21271": "projid", "21272": "projid_m_show", "21273": "projid_m_start", "21274": "projid_map", "21275": "projid_t", "21276": "prompt", "21277": "prot", "21278": "prot_exec", "21279": "prot_read", "21280": "prot_write", "21281": "prove_locking", "21282": "proxy_owner", "21283": "prstatus", "21284": "prune_list", "21285": "prune_one", "21286": "prune_thread", "21287": "prune_tree_thread", "21288": "prv", "21289": "ps", "21290": "pse", "21291": "pse_depth", "21292": "psig", "21293": "pskb_expand_head", "21294": "psp", "21295": "pstart", "21296": "pt_exitkill", "21297": "pt_ptrace_cap", "21298": "pt_ptraced", "21299": "pt_regs", "21300": "pt_regs_to_gdb_regs", "21301": "pt_seized", "21302": "pte_pfn", "21303": "pte_t", "21304": "pte_unmap_unlock", "21305": "ptep", "21306": "ptep_clear_flush_notify", "21307": "ptid", "21308": "ptl", "21309": "ptr", "21310": "ptr_err", "21311": "ptr_to_compat", "21312": "ptr_to_ctx", "21313": "ptr_to_map_value", "21314": "ptr_to_map_value_or_null", "21315": "ptr_to_stack", "21316": "ptrace", "21317": "ptrace_attach", "21318": "ptrace_check_attach", "21319": "ptrace_cont", "21320": "ptrace_detach", "21321": "ptrace_disable", "21322": "ptrace_do_notify", "21323": "ptrace_entry", "21324": "ptrace_event", "21325": "ptrace_event_clone", "21326": "ptrace_event_enabled", "21327": "ptrace_event_fork", "21328": "ptrace_event_pid", "21329": "ptrace_event_seccomp", "21330": "ptrace_event_stop", "21331": "ptrace_event_vfork", "21332": "ptrace_event_vfork_done", "21333": "ptrace_freeze_traced", "21334": "ptrace_get_task_struct", "21335": "ptrace_geteventmsg", "21336": "ptrace_getfdpic", "21337": "ptrace_getfdpic_exec", "21338": "ptrace_getfdpic_interp", "21339": "ptrace_getregset", "21340": "ptrace_getsiginfo", "21341": "ptrace_getsigmask", "21342": "ptrace_has_cap", "21343": "ptrace_init_task", "21344": "ptrace_interrupt", "21345": "ptrace_kill", "21346": "ptrace_listen", "21347": "ptrace_may_access", "21348": "ptrace_message", "21349": "ptrace_mode_attach", "21350": "ptrace_mode_noaudit", "21351": "ptrace_mode_read", "21352": "ptrace_notify", "21353": "ptrace_o_mask", "21354": "ptrace_oldsetoptions", "21355": "ptrace_peek_siginfo", "21356": "ptrace_peekdata", "21357": "ptrace_peeksiginfo", "21358": "ptrace_peeksiginfo_args", "21359": "ptrace_peeksiginfo_shared", "21360": "ptrace_peektext", "21361": "ptrace_pokedata", "21362": "ptrace_poketext", "21363": "ptrace_readdata", "21364": "ptrace_regset", "21365": "ptrace_reparented", "21366": "ptrace_request", "21367": "ptrace_resume", "21368": "ptrace_seize", "21369": "ptrace_setoptions", "21370": "ptrace_setregset", "21371": "ptrace_setsiginfo", "21372": "ptrace_setsigmask", "21373": "ptrace_signal", "21374": "ptrace_signal_deliver", "21375": "ptrace_signal_wake_up", "21376": "ptrace_singleblock", "21377": "ptrace_singlestep", "21378": "ptrace_stop", "21379": "ptrace_syscall", "21380": "ptrace_sysemu", "21381": "ptrace_sysemu_singlestep", "21382": "ptrace_traceme", "21383": "ptrace_trap_notify", "21384": "ptrace_unfreeze_traced", "21385": "ptrace_writedata", "21386": "ptraced", "21387": "pts_norm", "21388": "pty_max", "21389": "pty_nr", "21390": "ptype", "21391": "public_key_signature", "21392": "pull_rt_task", "21393": "pulled_task", "21394": "punc", "21395": "purgatory_buf", "21396": "purgatory_info", "21397": "purgatory_load_addr", "21398": "push_cpu", "21399": "push_flags", "21400": "push_insn", "21401": "push_irq_work_func", "21402": "push_lock", "21403": "push_rt_task", "21404": "push_rt_tasks", "21405": "push_stack", "21406": "push_work", "21407": "pushable_dl_tasks", "21408": "pushable_dl_tasks_leftmost", "21409": "pushable_dl_tasks_root", "21410": "pushable_tasks", "21411": "put", "21412": "put_addr", "21413": "put_callchain_buffers", "21414": "put_callchain_entry", "21415": "put_clock_desc", "21416": "put_compat_itimerspec", "21417": "put_compat_itimerval", "21418": "put_compat_rusage", "21419": "put_cpu", "21420": "put_cpu_ptr", "21421": "put_cpu_var", "21422": "put_cred", "21423": "put_cred_rcu", "21424": "put_cset", "21425": "put_css_set", "21426": "put_css_set_locked", "21427": "put_ctx", "21428": "put_event", "21429": "put_files_struct", "21430": "put_filesystem", "21431": "put_group_info", "21432": "put_io_context", "21433": "put_ipc_ns", "21434": "put_lock_stats", "21435": "put_mnt_ns", "21436": "put_net", "21437": "put_numa_group", "21438": "put_online_cpus", "21439": "put_packet", "21440": "put_page", "21441": "put_pid", "21442": "put_pid_ns", "21443": "put_posix_clock", "21444": "put_prev_entity", "21445": "put_prev_task", "21446": "put_prev_task_fair", "21447": "put_prev_task_fake", "21448": "put_prev_task_idle", "21449": "put_prev_task_rt", "21450": "put_pwq", "21451": "put_pwq_unlocked", "21452": "put_recursion_context", "21453": "put_seccomp_filter", "21454": "put_signal_struct", "21455": "put_system", "21456": "put_task_struct", "21457": "put_tree", "21458": "put_tree_ref", "21459": "put_unbound_pool", "21460": "put_uprobe", "21461": "put_user", "21462": "put_user_ns", "21463": "put_uts_ns", "21464": "putname", "21465": "pvclock_gtod_chain", "21466": "pvclock_gtod_register_notifier", "21467": "pvclock_gtod_unregister_notifier", "21468": "pwd", "21469": "pwq", "21470": "pwq_activate_delayed_work", "21471": "pwq_activate_first_delayed", "21472": "pwq_adjust_max_active", "21473": "pwq_cache", "21474": "pwq_dec_nr_in_flight", "21475": "pwq_tbl", "21476": "pwq_unbound_release_workfn", "21477": "pwqs", "21478": "pwqs_node", "21479": "pwrsw_enabled", "21480": "q", "21481": "qbytes", "21482": "qcfs_rq", "21483": "qhimark", "21484": "ql", "21485": "qlen", "21486": "qlen_last_fqs_check", "21487": "qlen_lazy", "21488": "qll", "21489": "qlowmark", "21490": "qos", "21491": "qrwlock", "21492": "qs_pending", "21493": "qsmask", "21494": "qsmaskinit", "21495": "qsmaskinitnext", "21496": "qsupported", "21497": "queue", "21498": "queue_delayed_work", "21499": "queue_delayed_work_on", "21500": "queue_kthread_work", "21501": "queue_lock", "21502": "queue_read_lock_slowpath", "21503": "queue_stop_cpus_work", "21504": "queue_up_suspend_work", "21505": "queue_work", "21506": "queue_work_on", "21507": "queue_write_lock_slowpath", "21508": "queued", "21509": "quick", "21510": "quota", "21511": "quota_us", "21512": "quote", "21513": "quoted", "21514": "r", "21515": "r1", "21516": "r2", "21517": "r3", "21518": "r4", "21519": "r5", "21520": "r_next", "21521": "r_open", "21522": "r_show", "21523": "r_start", "21524": "r_stop", "21525": "radix", "21526": "radix_tree", "21527": "radix_tree_delete", "21528": "radix_tree_insert", "21529": "radix_tree_lookup", "21530": "rahead", "21531": "raise_softirq", "21532": "raise_softirq_irqoff", "21533": "raised", "21534": "raised_list", "21535": "ram_res", "21536": "ran", "21537": "rand", "21538": "rand1", "21539": "rand_lock", "21540": "random_boot_id", "21541": "random_entropy_count", "21542": "random_poolsize", "21543": "random_read_thresh", "21544": "random_table", "21545": "random_uuid", "21546": "random_write_thresh", "21547": "randomize_va_space", "21548": "range", "21549": "rate_limit", "21550": "ratelimit", "21551": "rating", "21552": "ratio", "21553": "raw", "21554": "raw_", "21555": "raw_cpu_inc", "21556": "raw_cpu_ptr", "21557": "raw_cpu_read", "21558": "raw_cpu_write", "21559": "raw_data", "21560": "raw_init", "21561": "raw_interval", "21562": "raw_local_irq_restore", "21563": "raw_local_irq_save", "21564": "raw_lock", "21565": "raw_notifier_call_chain", "21566": "raw_notifier_chain_register", "21567": "raw_notifier_chain_unregister", "21568": "raw_notifier_head", "21569": "raw_nsecs", "21570": "raw_read_can_lock", "21571": "raw_read_seqcount", "21572": "raw_rq", "21573": "raw_secs", "21574": "raw_smp_processor_id", "21575": "raw_spin_is_locked", "21576": "raw_spin_lock", "21577": "raw_spin_lock_init", "21578": "raw_spin_lock_irq", "21579": "raw_spin_lock_irqsave", "21580": "raw_spin_lock_nested", "21581": "raw_spin_trylock", "21582": "raw_spin_trylock_irqsave", "21583": "raw_spin_unlock", "21584": "raw_spin_unlock_irq", "21585": "raw_spin_unlock_irqrestore", "21586": "raw_spin_unlock_wait", "21587": "raw_spinlock", "21588": "raw_spinlock_t", "21589": "raw_time", "21590": "raw_ts", "21591": "raw_write_can_lock", "21592": "raw_write_seqcount_latch", "21593": "rb", "21594": "rb_add_time_stamp", "21595": "rb_advance_iter", "21596": "rb_advance_reader", "21597": "rb_alignment", "21598": "rb_alloc", "21599": "rb_alloc_aux", "21600": "rb_alloc_aux_page", "21601": "rb_allocate_cpu_buffer", "21602": "rb_allocate_pages", "21603": "rb_arch_alignment", "21604": "rb_buffer_off", "21605": "rb_buffer_peek", "21606": "rb_buffers_disabled_bit", "21607": "rb_buffers_on", "21608": "rb_buffers_on_bit", "21609": "rb_calculate_event_length", "21610": "rb_check_bpage", "21611": "rb_check_list", "21612": "rb_check_pages", "21613": "rb_clear_node", "21614": "rb_commit", "21615": "rb_commit_index", "21616": "rb_cpu_notify", "21617": "rb_data", "21618": "rb_decrement_entry", "21619": "rb_empty_node", "21620": "rb_empty_root", "21621": "rb_end_commit", "21622": "rb_entry", "21623": "rb_erase", "21624": "rb_event_data", "21625": "rb_event_data_length", "21626": "rb_event_discard", "21627": "rb_event_index", "21628": "rb_event_is_commit", "21629": "rb_event_length", "21630": "rb_event_set_padding", "21631": "rb_event_ts_length", "21632": "rb_evnt_hdr_size", "21633": "rb_evnt_min_size", "21634": "rb_first", "21635": "rb_fl_overwrite", "21636": "rb_flag_mask", "21637": "rb_force_8byte_alignment", "21638": "rb_free", "21639": "rb_free_aux", "21640": "rb_free_aux_page", "21641": "rb_free_cpu_buffer", "21642": "rb_free_rcu", "21643": "rb_free_work", "21644": "rb_get_reader_page", "21645": "rb_hammer", "21646": "rb_hammer_test", "21647": "rb_handle_head_page", "21648": "rb_has_aux", "21649": "rb_head_page_activate", "21650": "rb_head_page_deactivate", "21651": "rb_head_page_replace", "21652": "rb_head_page_set", "21653": "rb_head_page_set_head", "21654": "rb_head_page_set_normal", "21655": "rb_head_page_set_update", "21656": "rb_inc_iter", "21657": "rb_inc_page", "21658": "rb_init_page", "21659": "rb_insert_color", "21660": "rb_insert_pages", "21661": "rb_ipi", "21662": "rb_irq_work", "21663": "rb_is_head_page", "21664": "rb_is_reader_page", "21665": "rb_item", "21666": "rb_iter_head_event", "21667": "rb_iter_peek", "21668": "rb_iter_reset", "21669": "rb_last", "21670": "rb_left", "21671": "rb_leftmost", "21672": "rb_len_time_extend", "21673": "rb_len_time_stamp", "21674": "rb_link", "21675": "rb_link_node", "21676": "rb_list_head", "21677": "rb_list_head_clear", "21678": "rb_lost_events", "21679": "rb_max_small_data", "21680": "rb_missed_events", "21681": "rb_missed_stored", "21682": "rb_move_tail", "21683": "rb_next", "21684": "rb_node", "21685": "rb_null_event", "21686": "rb_num_of_entries", "21687": "rb_ok_to_lock", "21688": "rb_page", "21689": "rb_page_commit", "21690": "rb_page_entries", "21691": "rb_page_head", "21692": "rb_page_moved", "21693": "rb_page_normal", "21694": "rb_page_size", "21695": "rb_page_update", "21696": "rb_page_write", "21697": "rb_parent", "21698": "rb_per_cpu_empty", "21699": "rb_prev", "21700": "rb_reader_event", "21701": "rb_remove_pages", "21702": "rb_reserve_next_event", "21703": "rb_reset_cpu", "21704": "rb_reset_reader_page", "21705": "rb_reset_tail", "21706": "rb_right", "21707": "rb_root", "21708": "rb_set_commit_to_write", "21709": "rb_set_head_page", "21710": "rb_set_list_to_head", "21711": "rb_start_commit", "21712": "rb_string", "21713": "rb_tail_page_update", "21714": "rb_test", "21715": "rb_test_buffer_size", "21716": "rb_test_data", "21717": "rb_test_started", "21718": "rb_threads", "21719": "rb_time_stamp", "21720": "rb_try_to_discard", "21721": "rb_update_event", "21722": "rb_update_iter_read_stamp", "21723": "rb_update_pages", "21724": "rb_update_read_stamp", "21725": "rb_update_write_stamp", "21726": "rb_wake_up_waiters", "21727": "rb_wakeups", "21728": "rb_warn_on", "21729": "rb_write_intcnt", "21730": "rb_write_mask", "21731": "rb_write_something", "21732": "rbi", "21733": "rbip", "21734": "rbtree_postorder_for_each_entry_safe", "21735": "rbwork", "21736": "rc", "21737": "rchan", "21738": "rchan_buf", "21739": "rchan_callbacks", "21740": "rchar", "21741": "rcp", "21742": "rcrmp", "21743": "rctx", "21744": "rctxp", "21745": "rcu", "21746": "rcu_accelerate_cbs", "21747": "rcu_access_pointer", "21748": "rcu_adopt_orphan_cbs", "21749": "rcu_advance_cbs", "21750": "rcu_all_qs", "21751": "rcu_assign_pointer", "21752": "rcu_barrier", "21753": "rcu_barrier_bh", "21754": "rcu_barrier_callback", "21755": "rcu_barrier_func", "21756": "rcu_barrier_sched", "21757": "rcu_barrier_tasks", "21758": "rcu_batch", "21759": "rcu_batch_dequeue", "21760": "rcu_batch_empty", "21761": "rcu_batch_init", "21762": "rcu_batch_move", "21763": "rcu_batch_queue", "21764": "rcu_batches", "21765": "rcu_batches_completed", "21766": "rcu_batches_completed_bh", "21767": "rcu_batches_completed_sched", "21768": "rcu_batches_started", "21769": "rcu_batches_started_bh", "21770": "rcu_batches_started_sched", "21771": "rcu_bh", "21772": "rcu_bh_ctrlblk", "21773": "rcu_bh_data", "21774": "rcu_bh_flavor", "21775": "rcu_bh_force_quiescent_state", "21776": "rcu_bh_lock_key", "21777": "rcu_bh_lock_map", "21778": "rcu_bh_ops", "21779": "rcu_bh_qs", "21780": "rcu_bh_state", "21781": "rcu_bh_torture_deferred_free", "21782": "rcu_bh_torture_read_lock", "21783": "rcu_bh_torture_read_unlock", "21784": "rcu_bind_gp_kthread", "21785": "rcu_blocked_node", "21786": "rcu_blocking_is_gp", "21787": "rcu_boost", "21788": "rcu_boost_delay_jiffies", "21789": "rcu_boost_inflight", "21790": "rcu_boost_kthread", "21791": "rcu_boost_kthread_setaffinity", "21792": "rcu_boot_init_nocb_percpu_data", "21793": "rcu_boot_init_percpu_data", "21794": "rcu_bootup_announce", "21795": "rcu_bootup_announce_oddness", "21796": "rcu_busted_ops", "21797": "rcu_busted_torture_deferred_free", "21798": "rcu_callback_key", "21799": "rcu_callback_map", "21800": "rcu_can_boost", "21801": "rcu_capacity", "21802": "rcu_cbs_completed", "21803": "rcu_check_callbacks", "21804": "rcu_check_gp_kthread_starvation", "21805": "rcu_check_quiescent_state", "21806": "rcu_cleanup_after_idle", "21807": "rcu_cleanup_dead_cpu", "21808": "rcu_cleanup_dead_rnp", "21809": "rcu_cleanup_dying_cpu", "21810": "rcu_cleanup_dying_idle_cpu", "21811": "rcu_copy_process", "21812": "rcu_cpu_has_callbacks", "21813": "rcu_cpu_has_work", "21814": "rcu_cpu_kthread", "21815": "rcu_cpu_kthread_cpu", "21816": "rcu_cpu_kthread_loops", "21817": "rcu_cpu_kthread_park", "21818": "rcu_cpu_kthread_setup", "21819": "rcu_cpu_kthread_should_run", "21820": "rcu_cpu_kthread_status", "21821": "rcu_cpu_kthread_task", "21822": "rcu_cpu_notify", "21823": "rcu_cpu_stall_reset", "21824": "rcu_cpu_stall_suppress", "21825": "rcu_cpu_stall_timeout", "21826": "rcu_cpu_thread_spec", "21827": "rcu_ctrlblk", "21828": "rcu_data", "21829": "rcu_delta_jiffies", "21830": "rcu_dereference", "21831": "rcu_dereference_bh", "21832": "rcu_dereference_check", "21833": "rcu_dereference_check_sched_domain", "21834": "rcu_dereference_raw", "21835": "rcu_dereference_raw_notrace", "21836": "rcu_dereference_sched", "21837": "rcu_do_batch", "21838": "rcu_done_tail", "21839": "rcu_dump_cpu_stacks", "21840": "rcu_dynticks", "21841": "rcu_dynticks_task_enter", "21842": "rcu_dynticks_task_exit", "21843": "rcu_early_boot_tests", "21844": "rcu_end_inkernel_boot", "21845": "rcu_eqs_enter", "21846": "rcu_eqs_enter_common", "21847": "rcu_eqs_exit", "21848": "rcu_eqs_exit_common", "21849": "rcu_expedite_gp", "21850": "rcu_expedited", "21851": "rcu_expedited_nesting", "21852": "rcu_fanout_1", "21853": "rcu_fanout_2", "21854": "rcu_fanout_3", "21855": "rcu_fanout_4", "21856": "rcu_fanout_leaf", "21857": "rcu_flavor", "21858": "rcu_for_each_leaf_node", "21859": "rcu_for_each_node_breadth_first", "21860": "rcu_for_each_nonleaf_node_breadth_first", "21861": "rcu_force_qs", "21862": "rcu_force_quiescent_state", "21863": "rcu_fqs_class", "21864": "rcu_free_pool", "21865": "rcu_free_pwq", "21866": "rcu_free_wq", "21867": "rcu_future_gp_cleanup", "21868": "rcu_future_needs_gp", "21869": "rcu_get_root", "21870": "rcu_gp_cleanup", "21871": "rcu_gp_flag_fqs", "21872": "rcu_gp_flag_init", "21873": "rcu_gp_fqs", "21874": "rcu_gp_idle", "21875": "rcu_gp_in_progress", "21876": "rcu_gp_init", "21877": "rcu_gp_is_expedited", "21878": "rcu_gp_kthread", "21879": "rcu_gp_kthread_wake", "21880": "rcu_gp_wait_fqs", "21881": "rcu_gp_wait_gps", "21882": "rcu_gp_wait_init", "21883": "rcu_head", "21884": "rcu_idle_count_callbacks_posted", "21885": "rcu_idle_enter", "21886": "rcu_idle_exit", "21887": "rcu_idle_gp_delay", "21888": "rcu_idle_lazy_gp_delay", "21889": "rcu_implicit_dynticks_qs", "21890": "rcu_init", "21891": "rcu_init_geometry", "21892": "rcu_init_levelspread", "21893": "rcu_init_new_rnp", "21894": "rcu_init_nohz", "21895": "rcu_init_one", "21896": "rcu_init_one_nocb", "21897": "rcu_init_percpu_data", "21898": "rcu_init_pointer", "21899": "rcu_initiate_boost", "21900": "rcu_initiate_boost_trace", "21901": "rcu_irq_enter", "21902": "rcu_irq_exit", "21903": "rcu_is_callbacks_kthread", "21904": "rcu_is_cpu_rrupt_from_idle", "21905": "rcu_is_nocb_cpu", "21906": "rcu_is_watching", "21907": "rcu_jiffies_fqs_div", "21908": "rcu_jiffies_till_force_qs", "21909": "rcu_jiffies_till_stall_check", "21910": "rcu_kick_nohz_cpu", "21911": "rcu_kthread_do_work", "21912": "rcu_kthread_max", "21913": "rcu_kthread_offcpu", "21914": "rcu_kthread_running", "21915": "rcu_kthread_waiting", "21916": "rcu_kthread_yielding", "21917": "rcu_leak_callback", "21918": "rcu_lock_acquire", "21919": "rcu_lock_break", "21920": "rcu_lock_key", "21921": "rcu_lock_map", "21922": "rcu_lock_release", "21923": "rcu_lockdep_assert", "21924": "rcu_lockdep_current_cpu_online", "21925": "rcu_momentary_dyntick_idle", "21926": "rcu_needs_cpu", "21927": "rcu_next_node_entry", "21928": "rcu_next_ready_tail", "21929": "rcu_next_size", "21930": "rcu_next_tail", "21931": "rcu_nmi_enter", "21932": "rcu_nmi_exit", "21933": "rcu_no_completed", "21934": "rcu_nocb_adopt_orphan_cbs", "21935": "rcu_nocb_cpu_needs_barrier", "21936": "rcu_nocb_gp_cleanup", "21937": "rcu_nocb_gp_set", "21938": "rcu_nocb_kthread", "21939": "rcu_nocb_leader_stride", "21940": "rcu_nocb_mask", "21941": "rcu_nocb_need_deferred_wakeup", "21942": "rcu_nocb_poll", "21943": "rcu_nocb_q_lengths", "21944": "rcu_nocb_setup", "21945": "rcu_nocb_wait_gp", "21946": "rcu_node", "21947": "rcu_node_boost_fops", "21948": "rcu_node_boost_open", "21949": "rcu_node_class", "21950": "rcu_node_entry", "21951": "rcu_nogp_wake", "21952": "rcu_nogp_wake_force", "21953": "rcu_nogp_wake_not", "21954": "rcu_nohz_full_cpu", "21955": "rcu_nonidle", "21956": "rcu_note_context_switch", "21957": "rcu_note_voluntary_context_switch", "21958": "rcu_num_lvls", "21959": "rcu_num_nodes", "21960": "rcu_oom_callback", "21961": "rcu_oom_nb", "21962": "rcu_oom_notify", "21963": "rcu_oom_notify_cpu", "21964": "rcu_ops", "21965": "rcu_organize_nocb_kthreads", "21966": "rcu_panic", "21967": "rcu_panic_block", "21968": "rcu_pending", "21969": "rcu_pending_fops", "21970": "rcu_pending_op", "21971": "rcu_pending_open", "21972": "rcu_pm_notify", "21973": "rcu_preempt", "21974": "rcu_preempt_blocked_readers_cgp", "21975": "rcu_preempt_boost_start_gp", "21976": "rcu_preempt_check_blocked_tasks", "21977": "rcu_preempt_check_callbacks", "21978": "rcu_preempt_data", "21979": "rcu_preempt_depth", "21980": "rcu_preempt_do_callbacks", "21981": "rcu_preempt_has_tasks", "21982": "rcu_preempt_note_context_switch", "21983": "rcu_preempt_qs", "21984": "rcu_preempt_state", "21985": "rcu_preempted_readers_exp", "21986": "rcu_prepare_cpu", "21987": "rcu_prepare_for_idle", "21988": "rcu_prepare_kthreads", "21989": "rcu_print_detail_task_stall", "21990": "rcu_print_detail_task_stall_rnp", "21991": "rcu_print_task_stall", "21992": "rcu_print_task_stall_begin", "21993": "rcu_print_task_stall_end", "21994": "rcu_process_callbacks", "21995": "rcu_qs_ctr", "21996": "rcu_qs_ctr_snap", "21997": "rcu_qsctr_help", "21998": "rcu_read_delay", "21999": "rcu_read_lock", "22000": "rcu_read_lock_bh", "22001": "rcu_read_lock_bh_held", "22002": "rcu_read_lock_held", "22003": "rcu_read_lock_nesting", "22004": "rcu_read_lock_sched", "22005": "rcu_read_lock_sched_held", "22006": "rcu_read_unlock", "22007": "rcu_read_unlock_bh", "22008": "rcu_read_unlock_sched", "22009": "rcu_read_unlock_special", "22010": "rcu_register_oom_notifier", "22011": "rcu_report_exp_rnp", "22012": "rcu_report_qs_rdp", "22013": "rcu_report_qs_rnp", "22014": "rcu_report_qs_rsp", "22015": "rcu_report_unblock_qs_rnp", "22016": "rcu_rnp_online_cpus", "22017": "rcu_save_dyntick", "22018": "rcu_sched", "22019": "rcu_sched_ctrlblk", "22020": "rcu_sched_data", "22021": "rcu_sched_flavor", "22022": "rcu_sched_force_quiescent_state", "22023": "rcu_sched_lock_key", "22024": "rcu_sched_lock_map", "22025": "rcu_sched_qs", "22026": "rcu_sched_qs_mask", "22027": "rcu_sched_state", "22028": "rcu_sched_torture_deferred_free", "22029": "rcu_scheduler_active", "22030": "rcu_scheduler_fully_active", "22031": "rcu_scheduler_starting", "22032": "rcu_self_test", "22033": "rcu_self_test_bh", "22034": "rcu_self_test_counter", "22035": "rcu_self_test_sched", "22036": "rcu_send_cbs_to_orphanage", "22037": "rcu_signal_init", "22038": "rcu_sleep_check", "22039": "rcu_softirq", "22040": "rcu_spawn_all_nocb_kthreads", "22041": "rcu_spawn_boost_kthreads", "22042": "rcu_spawn_gp_kthread", "22043": "rcu_spawn_nocb_kthreads", "22044": "rcu_spawn_one_boost_kthread", "22045": "rcu_spawn_one_nocb_kthread", "22046": "rcu_spawn_tasks_kthread", "22047": "rcu_special", "22048": "rcu_stall_delay_delta", "22049": "rcu_stall_rat_delay", "22050": "rcu_start_future_gp", "22051": "rcu_start_gp", "22052": "rcu_start_gp_advanced", "22053": "rcu_state", "22054": "rcu_state_initializer", "22055": "rcu_state_name", "22056": "rcu_state_p", "22057": "rcu_struct_flavors", "22058": "rcu_sync_torture_init", "22059": "rcu_synchronize", "22060": "rcu_sys_is_idle", "22061": "rcu_sysidle_cb", "22062": "rcu_sysidle_check_cpu", "22063": "rcu_sysidle_delay", "22064": "rcu_sysidle_enter", "22065": "rcu_sysidle_exit", "22066": "rcu_sysidle_force_exit", "22067": "rcu_sysidle_full", "22068": "rcu_sysidle_full_noted", "22069": "rcu_sysidle_head", "22070": "rcu_sysidle_init_percpu_data", "22071": "rcu_sysidle_long", "22072": "rcu_sysidle_not", "22073": "rcu_sysidle_report", "22074": "rcu_sysidle_report_gp", "22075": "rcu_sysidle_short", "22076": "rcu_sysrq_end", "22077": "rcu_sysrq_start", "22078": "rcu_task_stall_timeout", "22079": "rcu_tasks_cbs_head", "22080": "rcu_tasks_cbs_lock", "22081": "rcu_tasks_cbs_tail", "22082": "rcu_tasks_cbs_wq", "22083": "rcu_tasks_flavor", "22084": "rcu_tasks_holdout", "22085": "rcu_tasks_holdout_list", "22086": "rcu_tasks_holdouts", "22087": "rcu_tasks_idle_cpu", "22088": "rcu_tasks_kthread", "22089": "rcu_tasks_kthread_mutex", "22090": "rcu_tasks_kthread_ptr", "22091": "rcu_tasks_nvcsw", "22092": "rcu_tasks_torture_deferred_free", "22093": "rcu_test_debug_objects", "22094": "rcu_torture", "22095": "rcu_torture_alloc", "22096": "rcu_torture_barrier", "22097": "rcu_torture_barrier_cbf", "22098": "rcu_torture_barrier_cleanup", "22099": "rcu_torture_barrier_init", "22100": "rcu_torture_batch", "22101": "rcu_torture_boost", "22102": "rcu_torture_boost_cb", "22103": "rcu_torture_cb", "22104": "rcu_torture_cbflood", "22105": "rcu_torture_cbflood_cb", "22106": "rcu_torture_cleanup", "22107": "rcu_torture_count", "22108": "rcu_torture_current", "22109": "rcu_torture_current_version", "22110": "rcu_torture_deferred_free", "22111": "rcu_torture_err_cb", "22112": "rcu_torture_fqs", "22113": "rcu_torture_free", "22114": "rcu_torture_freelist", "22115": "rcu_torture_init", "22116": "rcu_torture_leak_cb", "22117": "rcu_torture_lock", "22118": "rcu_torture_ops", "22119": "rcu_torture_pipe_len", "22120": "rcu_torture_pipe_update", "22121": "rcu_torture_pipe_update_one", "22122": "rcu_torture_print_module_parms", "22123": "rcu_torture_read_lock", "22124": "rcu_torture_read_unlock", "22125": "rcu_torture_reader", "22126": "rcu_torture_removed", "22127": "rcu_torture_stall", "22128": "rcu_torture_stall_init", "22129": "rcu_torture_stats", "22130": "rcu_torture_stats_print", "22131": "rcu_torture_timer", "22132": "rcu_torture_wcount", "22133": "rcu_torture_writer", "22134": "rcu_torture_writer_state", "22135": "rcu_tortures", "22136": "rcu_trace", "22137": "rcu_trace_clock_local", "22138": "rcu_trace_sub_qlen", "22139": "rcu_tree_noncore", "22140": "rcu_try_advance_all_cbs", "22141": "rcu_unexpedite_gp", "22142": "rcu_user_enter", "22143": "rcu_user_exit", "22144": "rcu_verify_early_boot_tests", "22145": "rcu_wait", "22146": "rcu_wait_tail", "22147": "rcu_wake_cond", "22148": "rcubarrier_fops", "22149": "rcubarrier_open", "22150": "rcucblist", "22151": "rcudata", "22152": "rcudata_fops", "22153": "rcudata_open", "22154": "rcudate_op", "22155": "rcudir", "22156": "rcuexp_fops", "22157": "rcuexp_open", "22158": "rcugp_fops", "22159": "rcugp_open", "22160": "rcuhead_debug_descr", "22161": "rcuhead_fixup_activate", "22162": "rcuhier_fops", "22163": "rcuhier_open", "22164": "rcutorture_booster_cleanup", "22165": "rcutorture_booster_init", "22166": "rcutorture_cpu_nb", "22167": "rcutorture_fops", "22168": "rcutorture_get_gp_data", "22169": "rcutorture_open", "22170": "rcutorture_record_progress", "22171": "rcutorture_record_test_transition", "22172": "rcutorture_runnable_init", "22173": "rcutorture_tasks_ops", "22174": "rcutorture_testseq", "22175": "rcutorture_trace_dump", "22176": "rcutorture_type", "22177": "rcutorture_vernum", "22178": "rcutorturename", "22179": "rcutree_trace_cleanup", "22180": "rcutree_trace_init", "22181": "rd", "22182": "rda", "22183": "rdev", "22184": "rdp", "22185": "rdp_last", "22186": "rdp_leader", "22187": "rdp_old_leader", "22188": "rdp_prev", "22189": "rdp_spawn", "22190": "rdtp", "22191": "re", "22192": "re_cnt", "22193": "reached", "22194": "read", "22195": "read_boot_clock", "22196": "read_boot_clock64", "22197": "read_bytes", "22198": "read_can_lock", "22199": "read_char", "22200": "read_cred_subscribers", "22201": "read_delay", "22202": "read_done", "22203": "read_event", "22204": "read_events", "22205": "read_format", "22206": "read_holdtime", "22207": "read_lock", "22208": "read_lock_irq", "22209": "read_lock_irqsave", "22210": "read_mapping_page", "22211": "read_once", "22212": "read_page", "22213": "read_pages", "22214": "read_persistent_clock", "22215": "read_persistent_clock64", "22216": "read_profile", "22217": "read_s64", "22218": "read_seqbegin", "22219": "read_seqbegin_or_lock_irqsave", "22220": "read_seqcount_begin", "22221": "read_seqcount_retry", "22222": "read_seqretry", "22223": "read_size", "22224": "read_stamp", "22225": "read_start", "22226": "read_syscalls", "22227": "read_trylock", "22228": "read_u64", "22229": "read_unlock", "22230": "read_unlock_irq", "22231": "read_unlock_irqrestore", "22232": "read_waittime", "22233": "reader", "22234": "reader_finish", "22235": "reader_lock", "22236": "reader_lock_key", "22237": "reader_page", "22238": "reader_tasks", "22239": "readlock", "22240": "readme", "22241": "readpage", "22242": "readpos", "22243": "readunlock", "22244": "ready", "22245": "real", "22246": "real_blocked", "22247": "real_cred", "22248": "real_end", "22249": "real_ns", "22250": "real_parent", "22251": "real_root_dev", "22252": "real_start_time", "22253": "real_timer", "22254": "real_tk", "22255": "reallocate_resource", "22256": "rear", "22257": "reason", "22258": "rebalance_domains", "22259": "rebind_subsystems", "22260": "rebind_workers", "22261": "reboot", "22262": "reboot_command", "22263": "reboot_cpu", "22264": "reboot_default", "22265": "reboot_force", "22266": "reboot_hard", "22267": "reboot_mode", "22268": "reboot_mutex", "22269": "reboot_notifier_list", "22270": "reboot_pid_ns", "22271": "reboot_type", "22272": "rebuild_sched_domains", "22273": "rebuild_sched_domains_locked", "22274": "rec", "22275": "recalc_sigpending", "22276": "recalc_sigpending_and_wake", "22277": "recalc_sigpending_tsk", "22278": "recent", "22279": "recheck", "22280": "reclaim_distance", "22281": "reclaim_fs", "22282": "reclaim_fs_verbose", "22283": "reclaim_verbose", "22284": "record", "22285": "record_count", "22286": "record_count_len", "22287": "record_count_tag", "22288": "record_disabled", "22289": "record_file_magic", "22290": "record_function_check", "22291": "record_function_ident", "22292": "record_function_tag", "22293": "record_functon_tag_len", "22294": "record_gcov_version", "22295": "record_gp_stall_check_time", "22296": "record_it", "22297": "record_num", "22298": "record_time_stamp", "22299": "record_wakee", "22300": "records", "22301": "recover", "22302": "recursion", "22303": "recursive", "22304": "recycle_rp_inst", "22305": "redo", "22306": "reduce_fls", "22307": "redundant_hardirqs_off", "22308": "redundant_hardirqs_on", "22309": "redundant_softirqs_off", "22310": "redundant_softirqs_on", "22311": "reentry", "22312": "ref", "22313": "ref_count", "22314": "ref_module", "22315": "refcnt", "22316": "refcount", "22317": "referenced_filters", "22318": "references", "22319": "reflect", "22320": "reflush", "22321": "refresh", "22322": "refresh_timer", "22323": "refs", "22324": "refuse", "22325": "refusing", "22326": "reg", "22327": "reg16", "22328": "reg32", "22329": "reg64", "22330": "reg8", "22331": "reg_arg_type", "22332": "reg_base", "22333": "reg_event_syscall_enter", "22334": "reg_event_syscall_exit", "22335": "reg_readl", "22336": "reg_state", "22337": "reg_type_str", "22338": "reg_writel", "22339": "regex", "22340": "regex_lock", "22341": "regex_match_end", "22342": "regex_match_front", "22343": "regex_match_full", "22344": "regex_match_middle", "22345": "regex_type", "22346": "regfn", "22347": "region", "22348": "region_devres", "22349": "region_is_ram", "22350": "register", "22351": "register_aggr_kprobe", "22352": "register_array_map", "22353": "register_console", "22354": "register_cpu_notifier", "22355": "register_default_affinity_proc", "22356": "register_die_notifier", "22357": "register_event_cmds", "22358": "register_event_command", "22359": "register_filesystem", "22360": "register_for_each_vma", "22361": "register_ftrace_command", "22362": "register_ftrace_event", "22363": "register_ftrace_function", "22364": "register_ftrace_function_probe", "22365": "register_ftrace_graph", "22366": "register_ftrace_profiler", "22367": "register_handler_proc", "22368": "register_hotcpu_notifier", "22369": "register_hotmemory_notifier", "22370": "register_htab_map", "22371": "register_irq_proc", "22372": "register_irqsoff", "22373": "register_irqsoff_function", "22374": "register_jprobe", "22375": "register_jprobes", "22376": "register_kprobe", "22377": "register_kprobe_event", "22378": "register_kprobe_prog_ops", "22379": "register_kprobes", "22380": "register_kretprobe", "22381": "register_kretprobes", "22382": "register_lock_class", "22383": "register_module_notifier", "22384": "register_oom_notifier", "22385": "register_pernet_subsys", "22386": "register_pm_notifier", "22387": "register_pm_qos_misc", "22388": "register_preemptirqsoff", "22389": "register_preemptoff", "22390": "register_reboot_notifier", "22391": "register_restart_handler", "22392": "register_rwsem", "22393": "register_sched_domain_sysctl", "22394": "register_snapshot_trigger", "22395": "register_stat_tracer", "22396": "register_syscore_ops", "22397": "register_sysctl_paths", "22398": "register_sysctl_table", "22399": "register_sysrq_key", "22400": "register_trace_block_bio_backmerge", "22401": "register_trace_block_bio_bounce", "22402": "register_trace_block_bio_complete", "22403": "register_trace_block_bio_frontmerge", "22404": "register_trace_block_bio_queue", "22405": "register_trace_block_bio_remap", "22406": "register_trace_block_getrq", "22407": "register_trace_block_plug", "22408": "register_trace_block_rq_abort", "22409": "register_trace_block_rq_complete", "22410": "register_trace_block_rq_insert", "22411": "register_trace_block_rq_issue", "22412": "register_trace_block_rq_remap", "22413": "register_trace_block_rq_requeue", "22414": "register_trace_block_sleeprq", "22415": "register_trace_block_split", "22416": "register_trace_block_unplug", "22417": "register_trace_kprobe", "22418": "register_trace_sched_migrate_task", "22419": "register_trace_sched_switch", "22420": "register_trace_sched_wakeup", "22421": "register_trace_sched_wakeup_new", "22422": "register_trace_sys_enter", "22423": "register_trace_sys_exit", "22424": "register_trace_uprobe", "22425": "register_tracer", "22426": "register_trigger", "22427": "register_trigger_cmds", "22428": "register_trigger_enable_disable_cmds", "22429": "register_trigger_snapshot_cmd", "22430": "register_trigger_stacktrace_cmd", "22431": "register_uprobe_event", "22432": "register_wakeup_function", "22433": "registered", "22434": "registers", "22435": "registration", "22436": "regno", "22437": "regnum", "22438": "regs", "22439": "regs_get_kernel_stack_nth", "22440": "regs_get_register", "22441": "regs_intr", "22442": "regs_query_register_offset", "22443": "regs_return_value", "22444": "regs_user", "22445": "regs_user_copy", "22446": "regset", "22447": "regset_no", "22448": "regsets", "22449": "regular", "22450": "rel", "22451": "rel_msec", "22452": "rel_ts", "22453": "rel_usec", "22454": "relative_expiry_time", "22455": "relative_sleep_states", "22456": "relax_domain_level", "22457": "relay", "22458": "relay_buf_full", "22459": "relay_close", "22460": "relay_file_operations", "22461": "relay_flush", "22462": "relay_hotcpu_callback", "22463": "relay_open", "22464": "relay_reserve", "22465": "releasable_read", "22466": "release", "22467": "release_agent", "22468": "release_agent_path", "22469": "release_agent_path_lock", "22470": "release_agent_work", "22471": "release_all_trace_kprobes", "22472": "release_callchain_buffers", "22473": "release_callchain_buffers_rcu", "22474": "release_child_resources", "22475": "release_maps", "22476": "release_mem_region_adjustable", "22477": "release_node", "22478": "release_posix_timer", "22479": "release_resource", "22480": "release_swap_reader", "22481": "release_swap_writer", "22482": "reloc", "22483": "reloc_start", "22484": "relock", "22485": "relocs", "22486": "rem", "22487": "remain", "22488": "remainder", "22489": "remaining", "22490": "remcom_in_buffer", "22491": "remcom_out_buffer", "22492": "remote", "22493": "remote_clock", "22494": "remote_function", "22495": "remote_function_call", "22496": "remount_fs", "22497": "remove", "22498": "remove_breakpoint", "22499": "remove_buf_file", "22500": "remove_event", "22501": "remove_event_file_dir", "22502": "remove_event_from_tracers", "22503": "remove_filter_string", "22504": "remove_ftrace_list_ops", "22505": "remove_ftrace_ops", "22506": "remove_hash_entry", "22507": "remove_hw_breakpoint", "22508": "remove_info", "22509": "remove_irq", "22510": "remove_links", "22511": "remove_node", "22512": "remove_notes_attrs", "22513": "remove_percpu_irq", "22514": "remove_proc_entry", "22515": "remove_sect_attrs", "22516": "remove_subsystem", "22517": "remove_tasks_in_empty_cpuset", "22518": "remove_wait_queue", "22519": "removed_load", "22520": "removed_mask", "22521": "removed_ops", "22522": "removing", "22523": "rename", "22524": "rename_lock", "22525": "reopt", "22526": "reorder", "22527": "reorder_objects", "22528": "rep_skb", "22529": "repeat", "22530": "replace_filter_string", "22531": "replace_map_fd_with_map_ptr", "22532": "replace_preds", "22533": "replace_system_preds", "22534": "replenish", "22535": "reply", "22536": "report", "22537": "report_bad_irq", "22538": "report_latency", "22539": "report_probe", "22540": "req", "22541": "req_", "22542": "req_cpu", "22543": "req_sync", "22544": "req_type_block_pc", "22545": "reqd_free_pages", "22546": "request", "22547": "request_any_context_irq", "22548": "request_asymmetric_key", "22549": "request_dma", "22550": "request_irq", "22551": "request_key_auth", "22552": "request_percpu_irq", "22553": "request_queue", "22554": "request_resource", "22555": "request_resource_conflict", "22556": "request_skb", "22557": "request_threaded_irq", "22558": "requeue_pending", "22559": "requeue_rt_entity", "22560": "requeue_task_rt", "22561": "required", "22562": "res", "22563": "resched", "22564": "resched_cpu", "22565": "resched_curr", "22566": "resched_mask", "22567": "rescue_wq", "22568": "rescuer", "22569": "rescuer_nice_level", "22570": "rescuer_thread", "22571": "resend", "22572": "resend_irqs", "22573": "resend_tasklet", "22574": "reserve", "22575": "reserve_region_with_split", "22576": "reserve_setup", "22577": "reserved", "22578": "reserved_field_names", "22579": "reserved_pids", "22580": "reserved_size", "22581": "reset", "22582": "reset_counts", "22583": "reset_cpu_stall_ticks", "22584": "reset_dentry", "22585": "reset_entries", "22586": "reset_hung_task", "22587": "reset_hung_task_detector", "22588": "reset_iter", "22589": "reset_iter_read", "22590": "reset_kprobe_instance", "22591": "reset_node", "22592": "reset_on_fork", "22593": "reset_ptenuma_scan", "22594": "reset_read", "22595": "reset_stat_session", "22596": "reset_vma_resv_huge_pages", "22597": "reset_write", "22598": "resize_buffer_duplicate_size", "22599": "resize_disabled", "22600": "resolution", "22601": "resolve_symbol", "22602": "resolve_symbol_wait", "22603": "resource", "22604": "resource_alignment", "22605": "resource_clip", "22606": "resource_constraint", "22607": "resource_contains", "22608": "resource_entry", "22609": "resource_list_create_entry", "22610": "resource_list_destroy_entry", "22611": "resource_list_free", "22612": "resource_lock", "22613": "resource_op", "22614": "resource_size", "22615": "resource_size_t", "22616": "resource_type", "22617": "rest", "22618": "restart", "22619": "restart_block", "22620": "restart_handler_list", "22621": "restart_syscall", "22622": "restart_watchdog_hrtimer", "22623": "restore_altstack", "22624": "restore_cleanup", "22625": "restore_console", "22626": "restore_highmem", "22627": "restore_pblist", "22628": "restore_processor_state", "22629": "restore_unbound_workers_cpumask", "22630": "restorer", "22631": "result", "22632": "resume", "22633": "resume_console", "22634": "resume_delay", "22635": "resume_device_irqs", "22636": "resume_devices", "22637": "resume_file", "22638": "resume_irq", "22639": "resume_irqs", "22640": "resume_swap_area", "22641": "resume_target_kernel", "22642": "resume_wait", "22643": "resuming", "22644": "ret", "22645": "ret_addr", "22646": "ret_entry", "22647": "ret_handler", "22648": "ret_integer", "22649": "ret_ip", "22650": "ret_ptr_to_map_value_or_null", "22651": "ret_stack", "22652": "ret_stack_list", "22653": "ret_state", "22654": "ret_type", "22655": "ret_void", "22656": "retain", "22657": "retarget", "22658": "retarget_shared_pending", "22659": "retfunc", "22660": "retries", "22661": "retry", "22662": "retry_delete", "22663": "retry_find_task", "22664": "retry_task", "22665": "rettime", "22666": "return", "22667": "return_cfs_rq_runtime", "22668": "return_code", "22669": "return_instance", "22670": "return_instances", "22671": "return_normal", "22672": "return_valid", "22673": "retval", "22674": "reuse_unused_kprobe", "22675": "reverse", "22676": "revert_creds", "22677": "revmap_direct_max_irq", "22678": "revmap_size", "22679": "revmap_tree", "22680": "revmap_trees_mutex", "22681": "reweight_entity", "22682": "rewrite_section_headers", "22683": "rgid", "22684": "rgidp", "22685": "rh", "22686": "rh1", "22687": "rh2", "22688": "rhcount", "22689": "rhcount_lazy", "22690": "rhp", "22691": "rhs", "22692": "rhtp", "22693": "ri", "22694": "right", "22695": "right_child", "22696": "rimage", "22697": "ring", "22698": "ring_buffer", "22699": "ring_buffer_all_cpus", "22700": "ring_buffer_alloc", "22701": "ring_buffer_alloc_read_page", "22702": "ring_buffer_attach", "22703": "ring_buffer_benchmark_exit", "22704": "ring_buffer_benchmark_init", "22705": "ring_buffer_bytes_cpu", "22706": "ring_buffer_change_overwrite", "22707": "ring_buffer_commit_overrun_cpu", "22708": "ring_buffer_consume", "22709": "ring_buffer_discard_commit", "22710": "ring_buffer_dropped_events_cpu", "22711": "ring_buffer_empty", "22712": "ring_buffer_empty_cpu", "22713": "ring_buffer_entries", "22714": "ring_buffer_entries_cpu", "22715": "ring_buffer_event", "22716": "ring_buffer_event_data", "22717": "ring_buffer_event_length", "22718": "ring_buffer_expanded", "22719": "ring_buffer_flags", "22720": "ring_buffer_free", "22721": "ring_buffer_free_read_page", "22722": "ring_buffer_get", "22723": "ring_buffer_init", "22724": "ring_buffer_iter", "22725": "ring_buffer_iter_empty", "22726": "ring_buffer_iter_peek", "22727": "ring_buffer_iter_reset", "22728": "ring_buffer_lock_reserve", "22729": "ring_buffer_normalize_time_stamp", "22730": "ring_buffer_oldest_event_ts", "22731": "ring_buffer_overrun_cpu", "22732": "ring_buffer_overruns", "22733": "ring_buffer_page_len", "22734": "ring_buffer_peek", "22735": "ring_buffer_per_cpu", "22736": "ring_buffer_poll_wait", "22737": "ring_buffer_print_entry_header", "22738": "ring_buffer_print_page_header", "22739": "ring_buffer_put", "22740": "ring_buffer_read", "22741": "ring_buffer_read_events_cpu", "22742": "ring_buffer_read_finish", "22743": "ring_buffer_read_page", "22744": "ring_buffer_read_prepare", "22745": "ring_buffer_read_prepare_sync", "22746": "ring_buffer_read_start", "22747": "ring_buffer_record_disable", "22748": "ring_buffer_record_disable_cpu", "22749": "ring_buffer_record_enable", "22750": "ring_buffer_record_enable_cpu", "22751": "ring_buffer_record_is_on", "22752": "ring_buffer_record_off", "22753": "ring_buffer_record_on", "22754": "ring_buffer_reset", "22755": "ring_buffer_reset_cpu", "22756": "ring_buffer_resize", "22757": "ring_buffer_set_clock", "22758": "ring_buffer_size", "22759": "ring_buffer_swap_cpu", "22760": "ring_buffer_time_stamp", "22761": "ring_buffer_unlock_commit", "22762": "ring_buffer_wait", "22763": "ring_buffer_wakeup", "22764": "ring_buffer_writable", "22765": "ring_buffer_write", "22766": "ring_iter", "22767": "ring_size", "22768": "ringbuf_type_data", "22769": "ringbuf_type_data_type_len_max", "22770": "ringbuf_type_padding", "22771": "ringbuf_type_time_extend", "22772": "ringbuf_type_time_stamp", "22773": "rl", "22774": "rlen", "22775": "rlim", "22776": "rlim64", "22777": "rlim64_infinity", "22778": "rlim64_is_infinity", "22779": "rlim64_to_rlim", "22780": "rlim_cur", "22781": "rlim_infinity", "22782": "rlim_max", "22783": "rlim_nlimits", "22784": "rlim_rtprio", "22785": "rlim_to_rlim64", "22786": "rlimit", "22787": "rlimit64", "22788": "rlimit_cpu", "22789": "rlimit_data", "22790": "rlimit_fsize", "22791": "rlimit_memlock", "22792": "rlimit_nofile", "22793": "rlimit_nproc", "22794": "rlimit_rtprio", "22795": "rlimit_rttime", "22796": "rlimit_sigpending", "22797": "rlist", "22798": "rloc", "22799": "rlock", "22800": "rmb", "22801": "rmdir", "22802": "rmt", "22803": "rmtp", "22804": "rn", "22805": "rname", "22806": "rnd", "22807": "rnp", "22808": "rnp_c", "22809": "rnp_index", "22810": "rnp_leaf", "22811": "rnp_old", "22812": "rnp_p", "22813": "rnp_root", "22814": "rnp_up", "22815": "ro_size", "22816": "robust_list", "22817": "robust_list_limit", "22818": "roffs", "22819": "rollback", "22820": "room_left", "22821": "root", "22822": "root_cgrp", "22823": "root_cpuacct", "22824": "root_cpuacct_cpuusage", "22825": "root_cs", "22826": "root_css", "22827": "root_domain", "22828": "root_irq_dir", "22829": "root_list", "22830": "root_mnt", "22831": "root_node", "22832": "root_swap", "22833": "root_task_group", "22834": "root_task_group_load", "22835": "root_user", "22836": "rotate", "22837": "rotate_ctx", "22838": "rotate_disable", "22839": "rotor", "22840": "round_jiffies", "22841": "round_jiffies_common", "22842": "round_jiffies_relative", "22843": "round_up", "22844": "roundup", "22845": "roundup_pow_of_two", "22846": "rp", "22847": "rp1", "22848": "rpage", "22849": "rpdu", "22850": "rpm_idle", "22851": "rpm_resume", "22852": "rpm_return_int", "22853": "rpm_suspend", "22854": "rpos", "22855": "rps", "22856": "rq", "22857": "rq0_min_vruntime", "22858": "rq1", "22859": "rq2", "22860": "rq_attach_root", "22861": "rq_clock", "22862": "rq_clock_skip_update", "22863": "rq_clock_task", "22864": "rq_cpu", "22865": "rq_cpu_time", "22866": "rq_data_dir", "22867": "rq_disk", "22868": "rq_last_tick_reset", "22869": "rq_nohz_flag_bits", "22870": "rq_of", "22871": "rq_of_rt_rq", "22872": "rq_of_rt_se", "22873": "rq_offline", "22874": "rq_offline_fair", "22875": "rq_offline_rt", "22876": "rq_online", "22877": "rq_online_fair", "22878": "rq_online_rt", "22879": "rq_sched_info", "22880": "rq_sched_info_arrive", "22881": "rq_sched_info_depart", "22882": "rq_sched_info_dequeued", "22883": "rqcf_act_skip", "22884": "rqcf_req_skip", "22885": "rqtp", "22886": "rr_interval", "22887": "rr_timeslice", "22888": "rrln", "22889": "rrsp", "22890": "rsa", "22891": "rsh", "22892": "rsize", "22893": "rsp", "22894": "rspdir", "22895": "rspin_until_writer_unlock", "22896": "rss", "22897": "rss_stat", "22898": "rt", "22899": "rt_avg", "22900": "rt_b", "22901": "rt_bandwidth", "22902": "rt_bandwidth_enabled", "22903": "rt_clear_overload", "22904": "rt_constraints_mutex", "22905": "rt_delta", "22906": "rt_entity_is_task", "22907": "rt_max_tries", "22908": "rt_mutex", "22909": "rt_mutex_adjust_pi", "22910": "rt_mutex_check_prio", "22911": "rt_mutex_deadlock_account_lock", "22912": "rt_mutex_deadlock_account_unlock", "22913": "rt_mutex_debug_task_free", "22914": "rt_mutex_finish_proxy_lock", "22915": "rt_mutex_full_chainwalk", "22916": "rt_mutex_get_top_task", "22917": "rt_mutex_has_waiters", "22918": "rt_mutex_init_proxy_locked", "22919": "rt_mutex_init_task", "22920": "rt_mutex_lock", "22921": "rt_mutex_lock_interruptible", "22922": "rt_mutex_min_chainwalk", "22923": "rt_mutex_next_owner", "22924": "rt_mutex_owner", "22925": "rt_mutex_owner_maskall", "22926": "rt_mutex_print_deadlock", "22927": "rt_mutex_proxy_unlock", "22928": "rt_mutex_setprio", "22929": "rt_mutex_start_proxy_lock", "22930": "rt_mutex_timed_futex_lock", "22931": "rt_mutex_top_waiter", "22932": "rt_mutex_unlock", "22933": "rt_mutex_waiter", "22934": "rt_nr_boosted", "22935": "rt_nr_migratory", "22936": "rt_nr_running", "22937": "rt_nr_total", "22938": "rt_overloaded", "22939": "rt_period", "22940": "rt_period_timer", "22941": "rt_period_us", "22942": "rt_policy", "22943": "rt_prio", "22944": "rt_prio_array", "22945": "rt_priority", "22946": "rt_push_ipi", "22947": "rt_push_ipi_executing", "22948": "rt_push_ipi_restart", "22949": "rt_queued", "22950": "rt_rq", "22951": "rt_rq_iter_t", "22952": "rt_rq_of_se", "22953": "rt_rq_throttled", "22954": "rt_runtime", "22955": "rt_runtime_lock", "22956": "rt_runtime_share", "22957": "rt_runtime_us", "22958": "rt_sched_class", "22959": "rt_schedulable_data", "22960": "rt_se", "22961": "rt_se_boosted", "22962": "rt_se_nr_running", "22963": "rt_se_prio", "22964": "rt_set_overload", "22965": "rt_sigaction", "22966": "rt_sigpending", "22967": "rt_sigprocmask", "22968": "rt_sigqueueinfo", "22969": "rt_sigsuspend", "22970": "rt_sigtimedwait", "22971": "rt_task", "22972": "rt_task_of", "22973": "rt_tgsigqueueinfo", "22974": "rt_throttled", "22975": "rt_time", "22976": "rtc", "22977": "rtc_class", "22978": "rtc_device", "22979": "rtc_read_time", "22980": "rtc_set_alarm", "22981": "rtc_time", "22982": "rtc_time_to_tm", "22983": "rtc_timer", "22984": "rtc_timer_init", "22985": "rtc_tm_to_time", "22986": "rtc_wkalrm", "22987": "rtcdev", "22988": "rtcdev_lock", "22989": "rtctimer", "22990": "rtcv_snap", "22991": "rtime", "22992": "rtmutex_chainwalk", "22993": "rtmutex_common", "22994": "rtn", "22995": "rtn_tp", "22996": "rto_count", "22997": "rto_mask", "22998": "rto_next_cpu", "22999": "rtort_free", "23000": "rtort_mbtest", "23001": "rtort_pipe_count", "23002": "rtort_rcu", "23003": "rtree", "23004": "rtree_next_node", "23005": "rtree_node", "23006": "rtst", "23007": "rttest_event", "23008": "rttest_lock", "23009": "rttest_lockcont", "23010": "rttest_lockint", "23011": "rttest_lockintnowait", "23012": "rttest_locknowait", "23013": "rttest_nop", "23014": "rttest_reset", "23015": "rttest_resetevent", "23016": "rttest_schedot", "23017": "rttest_schedrt", "23018": "rttest_signal", "23019": "rttest_subsys", "23020": "rttest_unlock", "23021": "rtws_cond_get", "23022": "rtws_cond_sync", "23023": "rtws_def_free", "23024": "rtws_delay", "23025": "rtws_exp_sync", "23026": "rtws_fixed_delay", "23027": "rtws_replace", "23028": "rtws_stopping", "23029": "rtws_stutter", "23030": "rtws_sync", "23031": "ru", "23032": "ru_idrss", "23033": "ru_inblock", "23034": "ru_isrss", "23035": "ru_ixrss", "23036": "ru_majflt", "23037": "ru_maxrss", "23038": "ru_minflt", "23039": "ru_msgrcv", "23040": "ru_msgsnd", "23041": "ru_nivcsw", "23042": "ru_nsignals", "23043": "ru_nswap", "23044": "ru_nvcsw", "23045": "ru_oublock", "23046": "ru_stime", "23047": "ru_utime", "23048": "ruid", "23049": "ruidp", "23050": "rule", "23051": "rules", "23052": "run", "23053": "run_delay", "23054": "run_ksoftirqd", "23055": "run_list", "23056": "run_local_timers", "23057": "run_node", "23058": "run_posix_cpu_timers", "23059": "run_rebalance_domains", "23060": "run_threads", "23061": "run_time", "23062": "run_timer_softirq", "23063": "run_tracer_selftest", "23064": "runnable", "23065": "runnable_avg", "23066": "runnable_avg_sum", "23067": "runnable_avg_yn_inv", "23068": "runnable_avg_yn_sum", "23069": "runnable_contrib", "23070": "runnable_load_avg", "23071": "running", "23072": "running_avg_sum", "23073": "running_clock", "23074": "running_helpers", "23075": "running_helpers_timeout", "23076": "running_helpers_waitq", "23077": "running_list", "23078": "running_sample_length", "23079": "running_timer", "23080": "running_trace_list", "23081": "running_trace_lock", "23082": "runqueues", "23083": "runtime", "23084": "runtime_enabled", "23085": "runtime_expires", "23086": "runtime_inf", "23087": "runtime_refresh_within", "23088": "runtime_remaining", "23089": "runtime_was_enabled", "23090": "rusage", "23091": "rusage_both", "23092": "rusage_children", "23093": "rusage_self", "23094": "rusage_thread", "23095": "rw", "23096": "rw_lock_irq_ops", "23097": "rw_lock_ops", "23098": "rw_sem", "23099": "rw_semaphore", "23100": "rwbs", "23101": "rwbs_len", "23102": "rwlock", "23103": "rwlock_bug", "23104": "rwlock_bug_on", "23105": "rwlock_init", "23106": "rwlock_magic", "23107": "rwlock_t", "23108": "rwsem", "23109": "rwsem_acquire", "23110": "rwsem_acquire_nest", "23111": "rwsem_acquire_read", "23112": "rwsem_active_mask", "23113": "rwsem_active_read_bias", "23114": "rwsem_active_write_bias", "23115": "rwsem_atomic_add", "23116": "rwsem_atomic_update", "23117": "rwsem_can_spin_on_owner", "23118": "rwsem_clear_owner", "23119": "rwsem_down_read_failed", "23120": "rwsem_down_write_failed", "23121": "rwsem_downgrade_wake", "23122": "rwsem_is_locked", "23123": "rwsem_key", "23124": "rwsem_lock_ops", "23125": "rwsem_optimistic_spin", "23126": "rwsem_release", "23127": "rwsem_set_owner", "23128": "rwsem_spin_on_owner", "23129": "rwsem_try_write_lock", "23130": "rwsem_try_write_lock_unqueued", "23131": "rwsem_unlocked_value", "23132": "rwsem_waiter", "23133": "rwsem_waiter_type", "23134": "rwsem_waiting_bias", "23135": "rwsem_waiting_for_read", "23136": "rwsem_waiting_for_write", "23137": "rwsem_wake", "23138": "rwsem_wake_any", "23139": "rwsem_wake_read_owned", "23140": "rwsem_wake_readers", "23141": "rwsem_wake_type", "23142": "s", "23143": "s16", "23144": "s2", "23145": "s32", "23146": "s64", "23147": "s8", "23148": "s_alloc", "23149": "s_data", "23150": "s_dev", "23151": "s_dst", "23152": "s_ifmt", "23153": "s_ifreg", "23154": "s_irugo", "23155": "s_irusr", "23156": "s_irwxugo", "23157": "s_isreg", "23158": "s_iwgrp", "23159": "s_iwoth", "23160": "s_iwusr", "23161": "s_next", "23162": "s_show", "23163": "s_src", "23164": "s_start", "23165": "s_stop", "23166": "s_time_gran", "23167": "s_type", "23168": "sa", "23169": "sa_flags", "23170": "sa_handler", "23171": "sa_mask", "23172": "sa_nocldstop", "23173": "sa_nocldwait", "23174": "sa_nodefer", "23175": "sa_nomask", "23176": "sa_none", "23177": "sa_oneshot", "23178": "sa_restorer", "23179": "sa_rootdomain", "23180": "sa_sd", "23181": "sa_sd_storage", "23182": "sabbr", "23183": "safe", "23184": "safe_highmem_bm", "23185": "safe_highmem_pages", "23186": "safe_needed", "23187": "safe_pages_list", "23188": "same", "23189": "same_magic", "23190": "same_root", "23191": "same_thread_group", "23192": "sample", "23193": "sample_data", "23194": "sample_freq", "23195": "sample_id_all", "23196": "sample_len_ns", "23197": "sample_period", "23198": "sample_regs_intr", "23199": "sample_regs_user", "23200": "sample_stack_user", "23201": "sample_step", "23202": "sample_type", "23203": "sanity_check_segment_list", "23204": "sas_ss_flags", "23205": "sas_ss_size", "23206": "sas_ss_sp", "23207": "sattr", "23208": "sav_total", "23209": "save", "23210": "save_adjust", "23211": "save_current_task", "23212": "save_defcmd_set", "23213": "save_flags", "23214": "save_ftrace_enabled", "23215": "save_global_flags", "23216": "save_global_trampoline", "23217": "save_highmem", "23218": "save_image", "23219": "save_image_lzo", "23220": "save_info", "23221": "save_len", "23222": "save_max", "23223": "save_processor_state", "23224": "save_stack_trace", "23225": "save_stack_trace_regs", "23226": "save_stack_trace_tsk", "23227": "save_timestamp", "23228": "save_trace", "23229": "saveable", "23230": "saveable_highmem_page", "23231": "saved", "23232": "saved_auxv", "23233": "saved_cmdlines", "23234": "saved_cmdlines_buffer", "23235": "saved_cmdlines_default", "23236": "saved_cmdlines_size", "23237": "saved_ftrace_func", "23238": "saved_instr", "23239": "saved_latency", "23240": "saved_max_active", "23241": "saved_max_pfn", "23242": "saved_sigmask", "23243": "saved_tracer", "23244": "savedcmd", "23245": "sb", "23246": "sbe_balanced", "23247": "sbe_count", "23248": "sbe_pushed", "23249": "sbf_balanced", "23250": "sbf_count", "23251": "sbf_pushed", "23252": "sbuf", "23253": "sc", "23254": "scale", "23255": "scale_freq", "23256": "scale_load", "23257": "scale_load_down", "23258": "scale_rt_capacity", "23259": "scale_stime", "23260": "scaled", "23261": "scaled_busy_load_per_task", "23262": "scan", "23263": "scan_size", "23264": "scancode", "23265": "scd", "23266": "scenario", "23267": "sched", "23268": "sched_annotate_sleep", "23269": "sched_attr", "23270": "sched_attr_size_ver0", "23271": "sched_autogroup_create_attach", "23272": "sched_autogroup_detach", "23273": "sched_autogroup_exit", "23274": "sched_autogroup_fork", "23275": "sched_avg", "23276": "sched_avg_period", "23277": "sched_avg_update", "23278": "sched_batch", "23279": "sched_can_stop_tick", "23280": "sched_capacity_scale", "23281": "sched_capacity_shift", "23282": "sched_cfs_bandwidth_slice", "23283": "sched_cfs_period_timer", "23284": "sched_cfs_slack_timer", "23285": "sched_class", "23286": "sched_class_highest", "23287": "sched_clk", "23288": "sched_clock", "23289": "sched_clock_cpu", "23290": "sched_clock_data", "23291": "sched_clock_idle_sleep_event", "23292": "sched_clock_idle_wakeup_event", "23293": "sched_clock_init", "23294": "sched_clock_irqtime", "23295": "sched_clock_local", "23296": "sched_clock_remote", "23297": "sched_clock_running", "23298": "sched_clock_stable", "23299": "sched_clock_tick", "23300": "sched_clock_work", "23301": "sched_contributes_to_load", "23302": "sched_count", "23303": "sched_cpu_active", "23304": "sched_cpu_inactive", "23305": "sched_create_group", "23306": "sched_deadline", "23307": "sched_debug", "23308": "sched_debug_enabled", "23309": "sched_debug_header", "23310": "sched_debug_lock", "23311": "sched_debug_setup", "23312": "sched_debug_show", "23313": "sched_debug_start", "23314": "sched_destroy_group", "23315": "sched_dl_do_global", "23316": "sched_dl_entity", "23317": "sched_dl_global_validate", "23318": "sched_domain", "23319": "sched_domain_attr", "23320": "sched_domain_debug", "23321": "sched_domain_debug_one", "23322": "sched_domain_level_max", "23323": "sched_domain_span", "23324": "sched_domain_topology", "23325": "sched_domain_topology_level", "23326": "sched_domains_curr_level", "23327": "sched_domains_mutex", "23328": "sched_domains_numa_distance", "23329": "sched_domains_numa_levels", "23330": "sched_domains_numa_masks", "23331": "sched_domains_numa_masks_update", "23332": "sched_domains_tmpmask", "23333": "sched_entity", "23334": "sched_exec", "23335": "sched_exp", "23336": "sched_feat", "23337": "sched_feat_fops", "23338": "sched_feat_keys", "23339": "sched_feat_open", "23340": "sched_feat_set", "23341": "sched_feat_show", "23342": "sched_feat_write", "23343": "sched_fifo", "23344": "sched_find_first_bit", "23345": "sched_flag_reset_on_fork", "23346": "sched_flags", "23347": "sched_fork", "23348": "sched_get_priority_max", "23349": "sched_get_priority_min", "23350": "sched_getaffinity", "23351": "sched_getattr", "23352": "sched_getparam", "23353": "sched_goidle", "23354": "sched_group", "23355": "sched_group_capacity", "23356": "sched_group_cpus", "23357": "sched_group_mask", "23358": "sched_group_rt_period", "23359": "sched_group_rt_runtime", "23360": "sched_group_set_rt_period", "23361": "sched_group_set_rt_runtime", "23362": "sched_group_set_shares", "23363": "sched_idle", "23364": "sched_ilb_notifier", "23365": "sched_in", "23366": "sched_info", "23367": "sched_info_arrive", "23368": "sched_info_depart", "23369": "sched_info_dequeued", "23370": "sched_info_on", "23371": "sched_info_queued", "23372": "sched_info_reset_dequeued", "23373": "sched_info_switch", "23374": "sched_init_debug", "23375": "sched_init_granularity", "23376": "sched_init_numa", "23377": "sched_init_smp", "23378": "sched_latency", "23379": "sched_load_resolution", "23380": "sched_load_scale", "23381": "sched_load_shift", "23382": "sched_max_numa_distance", "23383": "sched_min_granularity", "23384": "sched_move_task", "23385": "sched_nice", "23386": "sched_normal", "23387": "sched_nr_latency", "23388": "sched_nr_migrate_break", "23389": "sched_numa_topology_type", "23390": "sched_numa_warn", "23391": "sched_offline_group", "23392": "sched_online_group", "23393": "sched_ops", "23394": "sched_out", "23395": "sched_param", "23396": "sched_period", "23397": "sched_policy", "23398": "sched_preempt_enable_no_resched", "23399": "sched_priority", "23400": "sched_proc_update_handler", "23401": "sched_profiling", "23402": "sched_read_attr", "23403": "sched_ref", "23404": "sched_register_mutex", "23405": "sched_reset_on_fork", "23406": "sched_rr", "23407": "sched_rr_get_interval", "23408": "sched_rr_handler", "23409": "sched_rr_timeslice", "23410": "sched_rt_avg_update", "23411": "sched_rt_bandwidth", "23412": "sched_rt_bandwidth_account", "23413": "sched_rt_can_attach", "23414": "sched_rt_do_global", "23415": "sched_rt_entity", "23416": "sched_rt_global_constraints", "23417": "sched_rt_global_validate", "23418": "sched_rt_handler", "23419": "sched_rt_period", "23420": "sched_rt_period_mask", "23421": "sched_rt_period_rt_rq", "23422": "sched_rt_period_timer", "23423": "sched_rt_rq_dequeue", "23424": "sched_rt_rq_enqueue", "23425": "sched_rt_runtime", "23426": "sched_rt_runtime_exceeded", "23427": "sched_runtime", "23428": "sched_set_stop_task", "23429": "sched_setaffinity", "23430": "sched_setattr", "23431": "sched_setnuma", "23432": "sched_setscheduler", "23433": "sched_setscheduler_nocheck", "23434": "sched_show_numa", "23435": "sched_show_task", "23436": "sched_skew_tick", "23437": "sched_slice", "23438": "sched_softirq", "23439": "sched_submit_work", "23440": "sched_task", "23441": "sched_task_group", "23442": "sched_timer", "23443": "sched_torture_read_lock", "23444": "sched_torture_read_unlock", "23445": "sched_ttwu_pending", "23446": "sched_tunable_scaling", "23447": "sched_tunable_scaling_names", "23448": "sched_tunablescaling_end", "23449": "sched_tunablescaling_linear", "23450": "sched_tunablescaling_log", "23451": "sched_tunablescaling_none", "23452": "sched_vslice", "23453": "sched_wakeup_granularity", "23454": "schedpar", "23455": "schedstat_add", "23456": "schedstat_inc", "23457": "schedstat_set", "23458": "schedstat_start", "23459": "schedstat_version", "23460": "schedule", "23461": "schedule_debug", "23462": "schedule_delayed_work", "23463": "schedule_hrtimeout", "23464": "schedule_hrtimeout_range", "23465": "schedule_next_timer", "23466": "schedule_on_each_cpu", "23467": "schedule_orphans_remove", "23468": "schedule_preempt_disabled", "23469": "schedule_rt_mutex", "23470": "schedule_rt_mutex_test", "23471": "schedule_tail", "23472": "schedule_timeout", "23473": "schedule_timeout_interruptible", "23474": "schedule_timeout_uninterruptible", "23475": "schedule_user", "23476": "schedule_work", "23477": "schedule_work_on", "23478": "scheduled", "23479": "scheduler_ipi", "23480": "scheduler_running", "23481": "scheduler_tick", "23482": "scheduler_tick_max_deferment", "23483": "sci_ptr", "23484": "scnprintf", "23485": "scons_pwroff", "23486": "sconsole", "23487": "score", "23488": "score_nearby_nodes", "23489": "scpu", "23490": "sd", "23491": "sd_alloc_ctl_cpu_table", "23492": "sd_alloc_ctl_domain_table", "23493": "sd_alloc_ctl_entry", "23494": "sd_asym", "23495": "sd_asym_packing", "23496": "sd_attr_init", "23497": "sd_balance_exec", "23498": "sd_balance_fork", "23499": "sd_balance_newidle", "23500": "sd_balance_wake", "23501": "sd_busy", "23502": "sd_ctl_dir", "23503": "sd_ctl_root", "23504": "sd_data", "23505": "sd_degenerate", "23506": "sd_flag", "23507": "sd_flags", "23508": "sd_free_ctl_entry", "23509": "sd_init", "23510": "sd_init_name", "23511": "sd_lb_stats", "23512": "sd_llc", "23513": "sd_llc_id", "23514": "sd_llc_size", "23515": "sd_load_balance", "23516": "sd_local", "23517": "sd_numa", "23518": "sd_numa_mask", "23519": "sd_overlap", "23520": "sd_parent", "23521": "sd_parent_degenerate", "23522": "sd_prefer_sibling", "23523": "sd_serialize", "23524": "sd_share_cpucapacity", "23525": "sd_share_pkg_resources", "23526": "sd_share_powerdomain", "23527": "sd_sysctl_header", "23528": "sd_wake_affine", "23529": "sd_weight", "23530": "sdd", "23531": "sdelta", "23532": "sdg", "23533": "sds", "23534": "sdtl_overlap", "23535": "se", "23536": "se_depth", "23537": "search", "23538": "search_exception_tables", "23539": "search_extable", "23540": "search_module_extables", "23541": "searchprompt", "23542": "sec", "23543": "sec_conversion", "23544": "sec_fls", "23545": "sec_jiffie_sc", "23546": "secbase", "23547": "seccomp", "23548": "seccomp_assign_mode", "23549": "seccomp_attach_filter", "23550": "seccomp_can_sync_threads", "23551": "seccomp_check_filter", "23552": "seccomp_data", "23553": "seccomp_debug", "23554": "seccomp_filter", "23555": "seccomp_filter_flag_mask", "23556": "seccomp_filter_flag_tsync", "23557": "seccomp_filter_free", "23558": "seccomp_may_assign_mode", "23559": "seccomp_mode", "23560": "seccomp_mode_disabled", "23561": "seccomp_mode_filter", "23562": "seccomp_mode_strict", "23563": "seccomp_phase1", "23564": "seccomp_phase1_ok", "23565": "seccomp_phase1_skip", "23566": "seccomp_phase2", "23567": "seccomp_prepare_filter", "23568": "seccomp_prepare_user_filter", "23569": "seccomp_ret_action", "23570": "seccomp_ret_allow", "23571": "seccomp_ret_data", "23572": "seccomp_ret_errno", "23573": "seccomp_ret_kill", "23574": "seccomp_ret_trace", "23575": "seccomp_ret_trap", "23576": "seccomp_run_filters", "23577": "seccomp_send_sigsys", "23578": "seccomp_set_mode_filter", "23579": "seccomp_set_mode_strict", "23580": "seccomp_sync_threads", "23581": "secctx", "23582": "sechdr", "23583": "sechdrs", "23584": "sechdrs_c", "23585": "secid", "23586": "second", "23587": "second_length", "23588": "second_overflow", "23589": "second_pass", "23590": "seconds", "23591": "secs", "23592": "secs_to_cputime", "23593": "secsize", "23594": "secstrings", "23595": "sect", "23596": "sect_attrs", "23597": "sect_empty", "23598": "section", "23599": "section_addr", "23600": "section_objs", "23601": "sector", "23602": "sector_from", "23603": "sector_t", "23604": "secure_computing_strict", "23605": "securebits", "23606": "securebits_default", "23607": "security", "23608": "security_audit_rule_free", "23609": "security_audit_rule_init", "23610": "security_audit_rule_known", "23611": "security_audit_rule_match", "23612": "security_capable", "23613": "security_capable_noaudit", "23614": "security_capget", "23615": "security_cred_alloc_blank", "23616": "security_cred_free", "23617": "security_inode_getsecid", "23618": "security_ipc_getsecid", "23619": "security_kernel_create_files_as", "23620": "security_kernel_module_from_file", "23621": "security_kernel_module_request", "23622": "security_prepare_creds", "23623": "security_ptrace_access_check", "23624": "security_ptrace_traceme", "23625": "security_release_secctx", "23626": "security_secid_to_secctx", "23627": "security_settime", "23628": "security_task_create", "23629": "security_task_fix_setuid", "23630": "security_task_free", "23631": "security_task_getpgid", "23632": "security_task_getscheduler", "23633": "security_task_getsecid", "23634": "security_task_getsid", "23635": "security_task_kill", "23636": "security_task_prctl", "23637": "security_task_setnice", "23638": "security_task_setpgid", "23639": "security_task_setrlimit", "23640": "security_task_setscheduler", "23641": "security_vm_enough_memory_mm", "23642": "see", "23643": "seed", "23644": "seg", "23645": "segment", "23646": "segment_bytes", "23647": "segments", "23648": "segv_bnderr", "23649": "seize", "23650": "seized", "23651": "select", "23652": "select_bucket", "23653": "select_comparison_fn", "23654": "select_fallback_rq", "23655": "select_idle_sibling", "23656": "select_insn", "23657": "select_task_rq", "23658": "select_task_rq_fair", "23659": "select_task_rq_idle", "23660": "select_task_rq_rt", "23661": "selected_console", "23662": "self", "23663": "self_exec_id", "23664": "selfmag", "23665": "selfparking", "23666": "selftest", "23667": "selinux_audit_rule_update", "23668": "selinux_is_enabled", "23669": "sem", "23670": "semaphore", "23671": "semaphore_waiter", "23672": "send", "23673": "send_cpu_listeners", "23674": "send_mayday", "23675": "send_ready", "23676": "send_reply", "23677": "send_sig", "23678": "send_sig_forced", "23679": "send_sig_info", "23680": "send_sig_noinfo", "23681": "send_sig_priv", "23682": "send_signal", "23683": "send_sigqueue", "23684": "sep", "23685": "separate_irq_context", "23686": "seq", "23687": "seq_buf_bprintf", "23688": "seq_buf_buffer_left", "23689": "seq_buf_has_overflowed", "23690": "seq_buf_path", "23691": "seq_buf_print_seq", "23692": "seq_buf_printf", "23693": "seq_buf_putc", "23694": "seq_buf_putmem", "23695": "seq_buf_putmem_hex", "23696": "seq_buf_to_user", "23697": "seq_buf_used", "23698": "seq_buf_vprintf", "23699": "seq_cft", "23700": "seq_css", "23701": "seq_file", "23702": "seq_header", "23703": "seq_line", "23704": "seq_list_next", "23705": "seq_list_start", "23706": "seq_list_start_head", "23707": "seq_lock_time", "23708": "seq_lseek", "23709": "seq_next", "23710": "seq_nr", "23711": "seq_ns", "23712": "seq_open", "23713": "seq_operations", "23714": "seq_ops", "23715": "seq_print_ip_sym", "23716": "seq_print_sym_offset", "23717": "seq_print_sym_short", "23718": "seq_print_user_ip", "23719": "seq_print_userip_objs", "23720": "seq_printf", "23721": "seq_put_field", "23722": "seq_put_hex_field", "23723": "seq_putc", "23724": "seq_puts", "23725": "seq_read", "23726": "seq_release", "23727": "seq_release_private", "23728": "seq_show", "23729": "seq_start", "23730": "seq_start_token", "23731": "seq_stats", "23732": "seq_stop", "23733": "seq_time", "23734": "seq_user_ns", "23735": "seq_write", "23736": "seq_write_gcov_u32", "23737": "seq_write_gcov_u64", "23738": "seqcount_init", "23739": "seqcount_t", "23740": "seqlock_init", "23741": "seqlock_t", "23742": "sequence", "23743": "sequential_io", "23744": "sequential_io_avg", "23745": "serial", "23746": "serial_cpumask", "23747": "serial_cpumask_attr", "23748": "serial_mask", "23749": "serial_nr", "23750": "serial_work", "23751": "server", "23752": "session", "23753": "session_id", "23754": "session_keyring", "23755": "session_list", "23756": "sessionid", "23757": "set", "23758": "set32", "23759": "set_alarm", "23760": "set_all_modules_text_ro", "23761": "set_all_modules_text_rw", "23762": "set_bit", "23763": "set_blocksize", "23764": "set_buf_size", "23765": "set_buffer", "23766": "set_buffer_entries", "23767": "set_child_tid", "23768": "set_cmdline", "23769": "set_cmdline_ftrace", "23770": "set_cond", "23771": "set_cpu_active", "23772": "set_cpu_itimer", "23773": "set_cpu_online", "23774": "set_cpu_possible", "23775": "set_cpu_present", "23776": "set_cpu_rq_start_time", "23777": "set_cpu_sd_state_busy", "23778": "set_cpu_sd_state_idle", "23779": "set_cpus_allowed", "23780": "set_cpus_allowed_ptr", "23781": "set_cpus_allowed_rt", "23782": "set_create_files_as", "23783": "set_cred_subscribers", "23784": "set_cred_user_ns", "23785": "set_curr_task", "23786": "set_curr_task_fair", "23787": "set_curr_task_idle", "23788": "set_curr_task_rt", "23789": "set_current_blocked", "23790": "set_current_groups", "23791": "set_current_state", "23792": "set_desc", "23793": "set_domain_attribute", "23794": "set_dumpable", "23795": "set_endian", "23796": "set_filter", "23797": "set_flag", "23798": "set_fp_mode", "23799": "set_fpemu_ctl", "23800": "set_fpexc_ctl", "23801": "set_freezable", "23802": "set_fs", "23803": "set_ftrace_dump_on_oops", "23804": "set_ftrace_early_filters", "23805": "set_ftrace_filter", "23806": "set_ftrace_notrace", "23807": "set_ftrace_pid", "23808": "set_ftrace_pid_function", "23809": "set_ftrace_pid_task", "23810": "set_ftrace_swapper", "23811": "set_function_trace_op", "23812": "set_graph_array", "23813": "set_graph_function", "23814": "set_graph_notrace", "23815": "set_hw_breakpoint", "23816": "set_irq_regs", "23817": "set_irq_wake_real", "23818": "set_kprobe_instance", "23819": "set_last_buddy", "23820": "set_last_pid", "23821": "set_license", "23822": "set_load_weight", "23823": "set_max_threads", "23824": "set_mb", "23825": "set_memory_nx", "23826": "set_memory_ro", "23827": "set_memory_rw", "23828": "set_memory_x", "23829": "set_mems_allowed", "23830": "set_mm_exe_file", "23831": "set_mode", "23832": "set_next_buddy", "23833": "set_next_entity", "23834": "set_next_event", "23835": "set_next_ktime", "23836": "set_normalized_timespec", "23837": "set_normalized_timespec64", "23838": "set_notify_resume", "23839": "set_nr_and_not_polling", "23840": "set_nr_if_polling", "23841": "set_ns", "23842": "set_numabalancing_state", "23843": "set_one_prio", "23844": "set_one_prio_perm", "23845": "set_orig_insn", "23846": "set_page_attributes", "23847": "set_page_private", "23848": "set_personality", "23849": "set_post_schedule", "23850": "set_preempt_need_resched", "23851": "set_print_fmt", "23852": "set_process_cpu_timer", "23853": "set_pte_at_notify", "23854": "set_restore_sigmask", "23855": "set_robust_list", "23856": "set_rq_offline", "23857": "set_rq_online", "23858": "set_sample_period", "23859": "set_sched_clock_stable", "23860": "set_sched_topology", "23861": "set_section_ro_nx", "23862": "set_skip_buddy", "23863": "set_softirq_pending", "23864": "set_special_pids", "23865": "set_state", "23866": "set_state_oneshot", "23867": "set_state_periodic", "23868": "set_state_shutdown", "23869": "set_str", "23870": "set_swbp", "23871": "set_syscall_print_fmt", "23872": "set_sysctl", "23873": "set_table_entry", "23874": "set_task_comm", "23875": "set_task_cpu", "23876": "set_task_rq", "23877": "set_task_stack_end_magic", "23878": "set_task_state", "23879": "set_thread_flag", "23880": "set_tid_address", "23881": "set_timer_slack", "23882": "set_to_char", "23883": "set_trace_boot_clock", "23884": "set_trace_boot_options", "23885": "set_tracepoint_printk", "23886": "set_tracer_flag", "23887": "set_tracing_thresh", "23888": "set_trigger_filter", "23889": "set_tsc_ctl", "23890": "set_tsk_need_resched", "23891": "set_tsk_thread_flag", "23892": "set_tsk_trace_trace", "23893": "set_unalign_ctl", "23894": "set_user", "23895": "set_user_nice", "23896": "set_work_data", "23897": "set_work_pool_and_clear_pending", "23898": "set_work_pool_and_keep_pending", "23899": "set_work_pwq", "23900": "set_worker_desc", "23901": "setdomainname", "23902": "setfsgid", "23903": "setfsgid16", "23904": "setfsuid", "23905": "setfsuid16", "23906": "setgid", "23907": "setgid16", "23908": "setgroups16", "23909": "setgroups_allowed", "23910": "sethostname", "23911": "setitimer", "23912": "setjmp_pre_handler", "23913": "setmax_mm_hiwater_rss", "23914": "setns", "23915": "setpageprivate", "23916": "setparam_policy", "23917": "setpgid", "23918": "setregid", "23919": "setregid16", "23920": "setresgid", "23921": "setresgid16", "23922": "setresuid16", "23923": "setreuid", "23924": "setreuid16", "23925": "setrlimit", "23926": "setsid", "23927": "settimeofday", "23928": "setting", "23929": "setuid16", "23930": "setup", "23931": "setup_affinity", "23932": "setup_autogroup", "23933": "setup_aux", "23934": "setup_crash_kexec_post_notifiers", "23935": "setup_elfcorehdr", "23936": "setup_forced_irqthreads", "23937": "setup_irq", "23938": "setup_load_info", "23939": "setup_max_cpus", "23940": "setup_modinfo", "23941": "setup_modinfo_", "23942": "setup_percpu_irq", "23943": "setup_print_fatal_signals", "23944": "setup_profiling_timer", "23945": "setup_relax_domain_level", "23946": "setup_test_suspend", "23947": "setup_thread_stack", "23948": "setup_timer", "23949": "setup_timer_on_stack", "23950": "setup_trace_event", "23951": "sf", "23952": "sf_crc32_mode", "23953": "sf_nocompress_mode", "23954": "sf_platform_mode", "23955": "sg", "23956": "sg_big_buff", "23957": "sg_cpus", "23958": "sg_imbalanced", "23959": "sg_lb_stats", "23960": "sg_mask", "23961": "sg_span", "23962": "sgc", "23963": "sgetmask", "23964": "sgid", "23965": "sgidp", "23966": "sgs", "23967": "sh_addr", "23968": "sh_addralign", "23969": "sh_entsize", "23970": "sh_flags", "23971": "sh_info", "23972": "sh_link", "23973": "sh_name", "23974": "sh_offset", "23975": "sh_size", "23976": "sh_type", "23977": "sha256_digest_size", "23978": "sha_region_sz", "23979": "sha_regions", "23980": "shadow_ctx_time", "23981": "shadow_pid", "23982": "shadow_timekeeper", "23983": "shallowest_idle_cpu", "23984": "shardware", "23985": "shared", "23986": "shared_pending", "23987": "shared_vm", "23988": "sharedram", "23989": "shares", "23990": "shares_mutex", "23991": "shareval", "23992": "shash_desc", "23993": "shdr", "23994": "shf_alloc", "23995": "shf_execinstr", "23996": "shf_write", "23997": "shift", "23998": "shift_change", "23999": "shift_pll", "24000": "shift_right", "24001": "shm_init_task", "24002": "shmem_mapping", "24003": "shmem_read_mapping_page", "24004": "shn_abs", "24005": "shn_common", "24006": "shn_loreserve", "24007": "shn_undef", "24008": "shnum", "24009": "short", "24010": "shortdelay_us", "24011": "should_free", "24012": "should_numa_migrate_memory", "24013": "should_resched", "24014": "should_stop", "24015": "should_we_balance", "24016": "show", "24017": "show_active", "24018": "show_available_triggers", "24019": "show_coresize", "24020": "show_cpumask", "24021": "show_event_seq_ops", "24022": "show_header", "24023": "show_initsize", "24024": "show_initstate", "24025": "show_interrupts", "24026": "show_irq_affinity", "24027": "show_kprobe_addr", "24028": "show_modinfo_", "24029": "show_mutex", "24030": "show_one_rcugp", "24031": "show_options", "24032": "show_pwq", "24033": "show_rcu_gp_kthreads", "24034": "show_rcu_node_boost", "24035": "show_rcu_pending", "24036": "show_rcubarrier", "24037": "show_rcudata", "24038": "show_rcuexp", "24039": "show_rcugp", "24040": "show_rcuhier", "24041": "show_rcutorture", "24042": "show_refcnt", "24043": "show_regs", "24044": "show_schedstat", "24045": "show_set_event_seq_ops", "24046": "show_special", "24047": "show_stack", "24048": "show_state_filter", "24049": "show_taint", "24050": "show_unhandled_signals", "24051": "show_workqueue_state", "24052": "shows", "24053": "sht_nobits", "24054": "sht_note", "24055": "sht_rel", "24056": "sht_rela", "24057": "sht_symtab", "24058": "shuffint", "24059": "shuffle_idle_cpu", "24060": "shuffle_interval", "24061": "shuffle_task", "24062": "shuffle_task_list", "24063": "shuffle_task_mutex", "24064": "shuffle_tmp_mask", "24065": "shuffler_task", "24066": "shutdown", "24067": "shutdown_secs", "24068": "shutdown_task", "24069": "shutdown_time", "24070": "si", "24071": "si1", "24072": "si2", "24073": "si_addr", "24074": "si_addr_lsb", "24075": "si_arch", "24076": "si_band", "24077": "si_call_addr", "24078": "si_code", "24079": "si_errno", "24080": "si_fd", "24081": "si_fromkernel", "24082": "si_fromuser", "24083": "si_kernel", "24084": "si_load_shift", "24085": "si_lower", "24086": "si_meminfo", "24087": "si_overrun", "24088": "si_pid", "24089": "si_private", "24090": "si_ptr", "24091": "si_signo", "24092": "si_status", "24093": "si_stime", "24094": "si_swapinfo", "24095": "si_sys_private", "24096": "si_syscall", "24097": "si_tid", "24098": "si_timer", "24099": "si_tkill", "24100": "si_trapno", "24101": "si_uid", "24102": "si_upper", "24103": "si_user", "24104": "si_utime", "24105": "si_value", "24106": "sibling", "24107": "sibling_list", "24108": "sibling_only", "24109": "siblings", "24110": "sid", "24111": "sig", "24112": "sig_block", "24113": "sig_data", "24114": "sig_dfl", "24115": "sig_enforce", "24116": "sig_fatal", "24117": "sig_handler", "24118": "sig_handler_ignored", "24119": "sig_ign", "24120": "sig_ignored", "24121": "sig_kernel_coredump", "24122": "sig_kernel_ignore", "24123": "sig_kernel_only", "24124": "sig_kernel_stop", "24125": "sig_kernel_stop_mask", "24126": "sig_len", "24127": "sig_ok", "24128": "sig_setmask", "24129": "sig_task_ignored", "24130": "sig_unblock", "24131": "sigaction", "24132": "sigaddset", "24133": "sigaddsetmask", "24134": "sigalrm", "24135": "sigaltstack", "24136": "sigandnsets", "24137": "sigandsets", "24138": "sigbus", "24139": "sigchld", "24140": "sigcnt", "24141": "sigcont", "24142": "sigdelset", "24143": "sigdelsetmask", "24144": "sigemptyset", "24145": "sigev_none", "24146": "sigev_notify", "24147": "sigev_notify_thread_id", "24148": "sigev_signal", "24149": "sigev_signo", "24150": "sigev_thread", "24151": "sigev_thread_id", "24152": "sigev_value", "24153": "sigevent", "24154": "sigevent_t", "24155": "sigfpe", "24156": "sigh", "24157": "sighand", "24158": "sighand_cachep", "24159": "sighand_ctor", "24160": "sighand_struct", "24161": "sighup", "24162": "sigill", "24163": "siginfo", "24164": "siginfo_t", "24165": "siginitset", "24166": "sigint", "24167": "sigio", "24168": "sigisemptyset", "24169": "sigismember", "24170": "sigkill", "24171": "sigkill_pending", "24172": "siglock", "24173": "sigmask", "24174": "sign", "24175": "signal", "24176": "signal_cachep", "24177": "signal_cld_continued", "24178": "signal_cld_mask", "24179": "signal_cld_stopped", "24180": "signal_delivered", "24181": "signal_group_coredump", "24182": "signal_group_exit", "24183": "signal_pending", "24184": "signal_pending_state", "24185": "signal_pt_regs", "24186": "signal_setup_done", "24187": "signal_stop_continued", "24188": "signal_stop_stopped", "24189": "signal_struct", "24190": "signal_unkillable", "24191": "signal_wake_up", "24192": "signal_wake_up_state", "24193": "signalfd_cleanup", "24194": "signalfd_notify", "24195": "signalfd_wqh", "24196": "signals", "24197": "signals_init", "24198": "signed", "24199": "signer", "24200": "signer_len", "24201": "signo", "24202": "signotset", "24203": "signr", "24204": "sigorsets", "24205": "sigpending", "24206": "sigprocmask", "24207": "sigq", "24208": "sigqueue", "24209": "sigqueue_alloc", "24210": "sigqueue_cachep", "24211": "sigqueue_free", "24212": "sigqueue_prealloc", "24213": "sigquit", "24214": "sigrtmax", "24215": "sigrtmin", "24216": "sigsegv", "24217": "sigset_from_compat", "24218": "sigset_t", "24219": "sigset_to_compat", "24220": "sigsetsize", "24221": "sigstop", "24222": "sigsuspend", "24223": "sigsys", "24224": "sigterm", "24225": "sigtrap", "24226": "sigusr1", "24227": "sigusr2", "24228": "simple", "24229": "simple_align_resource", "24230": "simple_open", "24231": "simple_read_from_buffer", "24232": "simple_strtol", "24233": "simple_strtoul", "24234": "simplify_symbols", "24235": "simulate", "24236": "single_depth_nesting", "24237": "single_open", "24238": "single_release", "24239": "single_task_running", "24240": "sival_int", "24241": "sixty", "24242": "size", "24243": "size_bits", "24244": "size_buf", "24245": "size_t", "24246": "sizeof", "24247": "sizeof_trace_entry", "24248": "sizeof_trace_kprobe", "24249": "sizeof_trace_uprobe", "24250": "sizeop", "24251": "sk", "24252": "sk_buff", "24253": "sk_buff_head", "24254": "sk_sndtimeo", "24255": "skb", "24256": "skb_clone", "24257": "skb_copy", "24258": "skb_copy_bits", "24259": "skb_cur", "24260": "skb_dequeue", "24261": "skb_get", "24262": "skb_mac_header", "24263": "skb_network_header", "24264": "skb_next", "24265": "skb_put", "24266": "skb_queue_head_init", "24267": "skb_queue_len", "24268": "skb_queue_purge", "24269": "skb_queue_tail", "24270": "skb_tail_pointer", "24271": "skb_tailroom", "24272": "skbp", "24273": "skew", "24274": "skew_prefix", "24275": "skew_tick", "24276": "skf_ll_off", "24277": "skf_net_off", "24278": "skip", "24279": "skip_full_check", "24280": "skip_it", "24281": "skip_lines", "24282": "skip_more", "24283": "skip_spaces", "24284": "skip_time_extend", "24285": "skip_wait", "24286": "skipped_entries", "24287": "sl", "24288": "slab_destroy_by_rcu", "24289": "slab_hwcache_align", "24290": "slab_is_available", "24291": "slab_notrack", "24292": "slab_panic", "24293": "slack", "24294": "slack_hz", "24295": "slack_runtime", "24296": "slack_timer", "24297": "slaves_in_kgdb", "24298": "sleep", "24299": "sleep_jf", "24300": "sleep_length", "24301": "sleep_max", "24302": "sleep_profiling", "24303": "sleep_start", "24304": "sleep_time", "24305": "sleep_time_bin", "24306": "sleep_usecs", "24307": "sleeping_thread_to_gdb_regs", "24308": "sleeptime_injected", "24309": "slen", "24310": "slice", "24311": "slice_max", "24312": "sln", "24313": "slot", "24314": "slot_addr", "24315": "slot_clean", "24316": "slot_count", "24317": "slot_dirty", "24318": "slot_nr", "24319": "slot_type", "24320": "slot_used", "24321": "slots_per_page", "24322": "slow_acct_process", "24323": "slow_read_ctr", "24324": "slowpath_args", "24325": "slows", "24326": "sm_ref", "24327": "small_event_size", "24328": "smp_announce", "24329": "smp_call_func_t", "24330": "smp_call_function", "24331": "smp_call_function_any", "24332": "smp_call_function_many", "24333": "smp_call_function_single", "24334": "smp_call_function_single_async", "24335": "smp_cpus_done", "24336": "smp_debug_locks_warn_on", "24337": "smp_hotplug_thread", "24338": "smp_load_acquire", "24339": "smp_mb", "24340": "smp_mb__after_atomic", "24341": "smp_mb__after_unlock_lock", "24342": "smp_mb__before_atomic", "24343": "smp_mb__before_spinlock", "24344": "smp_processor_id", "24345": "smp_read_barrier_depends", "24346": "smp_rmb", "24347": "smp_send_reschedule", "24348": "smp_store_release", "24349": "smp_wmb", "24350": "smpboot_create_threads", "24351": "smpboot_destroy_threads", "24352": "smpboot_h", "24353": "smpboot_park_thread", "24354": "smpboot_park_threads", "24355": "smpboot_register_percpu_thread", "24356": "smpboot_thread_call", "24357": "smpboot_thread_data", "24358": "smpboot_thread_fn", "24359": "smpboot_thread_init", "24360": "smpboot_thread_notifier", "24361": "smpboot_threads_lock", "24362": "smpboot_unpark_thread", "24363": "smpboot_unpark_threads", "24364": "smpboot_unregister_percpu_thread", "24365": "smt", "24366": "smt_gain", "24367": "sname", "24368": "snap", "24369": "snap_done", "24370": "snapshot", "24371": "snapshot_additional_pages", "24372": "snapshot_alloc_swap_page", "24373": "snapshot_atomic_restore", "24374": "snapshot_avail_swap_size", "24375": "snapshot_compat_ioctl", "24376": "snapshot_count_trigger", "24377": "snapshot_count_trigger_ops", "24378": "snapshot_create_image", "24379": "snapshot_data", "24380": "snapshot_device", "24381": "snapshot_device_available", "24382": "snapshot_device_init", "24383": "snapshot_fops", "24384": "snapshot_free", "24385": "snapshot_freeze", "24386": "snapshot_get_image_size", "24387": "snapshot_get_trigger_ops", "24388": "snapshot_handle", "24389": "snapshot_image_loaded", "24390": "snapshot_ioc_magic", "24391": "snapshot_ioc_maxnr", "24392": "snapshot_ioctl", "24393": "snapshot_minor", "24394": "snapshot_open", "24395": "snapshot_platform_support", "24396": "snapshot_power_off", "24397": "snapshot_pref_image_size", "24398": "snapshot_raw", "24399": "snapshot_read", "24400": "snapshot_read_next", "24401": "snapshot_release", "24402": "snapshot_s2ram", "24403": "snapshot_set_swap_area", "24404": "snapshot_state", "24405": "snapshot_trigger", "24406": "snapshot_trigger_ops", "24407": "snapshot_trigger_print", "24408": "snapshot_unfreeze", "24409": "snapshot_write", "24410": "snapshot_write_finalize", "24411": "snapshot_write_next", "24412": "snd_portid", "24413": "snode", "24414": "snprint_stack_trace", "24415": "snprintf", "24416": "sock", "24417": "sock_filter", "24418": "sock_fprog", "24419": "sock_net", "24420": "sockaddr", "24421": "sockaddr_len", "24422": "sockaddr_storage", "24423": "socketcall", "24424": "soft", "24425": "soft_disable", "24426": "soft_lockup_hrtimer_cnt", "24427": "soft_lockup_nmi_warn", "24428": "soft_watchdog_enabled", "24429": "soft_watchdog_enabled_bit", "24430": "soft_watchdog_warn", "24431": "softirq", "24432": "softirq_action", "24433": "softirq_bit", "24434": "softirq_context", "24435": "softirq_count", "24436": "softirq_disable_event", "24437": "softirq_disable_ip", "24438": "softirq_disable_offset", "24439": "softirq_enable_event", "24440": "softirq_enable_ip", "24441": "softirq_init", "24442": "softirq_lock_offset", "24443": "softirq_mask", "24444": "softirq_offset", "24445": "softirq_shift", "24446": "softirq_snap", "24447": "softirq_threads", "24448": "softirq_to_name", "24449": "softirq_vec", "24450": "softirq_verbose", "24451": "softirqs_enabled", "24452": "softirqs_off_events", "24453": "softirqs_on_events", "24454": "softlockup_all_cpu_backtrace", "24455": "softlockup_panic", "24456": "softlockup_task_ptr_saved", "24457": "softlockup_touch_sync", "24458": "softlockup_watchdog", "24459": "software", "24460": "software_resume", "24461": "some", "24462": "sort", "24463": "sort_extable", "24464": "sort_main_extable", "24465": "source", "24466": "source_entry", "24467": "source_list", "24468": "source_load", "24469": "sp", "24470": "sp_list", "24471": "space", "24472": "spaces", "24473": "span", "24474": "span_weight", "24475": "spanned_pages", "24476": "spare_pages", "24477": "sparse_irq_lock", "24478": "spawn_ksoftirqd", "24479": "special", "24480": "specific_send_sig_info", "24481": "specified", "24482": "spilled_regs", "24483": "spin", "24484": "spin_acquire", "24485": "spin_acquire_nest", "24486": "spin_bug", "24487": "spin_bug_on", "24488": "spin_dump", "24489": "spin_is_locked", "24490": "spin_lock", "24491": "spin_lock_bh", "24492": "spin_lock_init", "24493": "spin_lock_irq", "24494": "spin_lock_irq_ops", "24495": "spin_lock_irqsave", "24496": "spin_lock_mutex", "24497": "spin_lock_nested", "24498": "spin_lock_ops", "24499": "spin_msec", "24500": "spin_needbreak", "24501": "spin_release", "24502": "spin_retry", "24503": "spin_trylock", "24504": "spin_trylock_bh", "24505": "spin_unlock", "24506": "spin_unlock_bh", "24507": "spin_unlock_irq", "24508": "spin_unlock_irqrestore", "24509": "spin_unlock_mutex", "24510": "spincnt", "24511": "spinlock_magic", "24512": "spinlock_owner_init", "24513": "spinlock_size", "24514": "spinlock_t", "24515": "splice_pipe", "24516": "splice_read", "24517": "split_ns", "24518": "split_page", "24519": "split_rss_counting", "24520": "spread", "24521": "spread0", "24522": "spread_flag_changed", "24523": "sprint_backtrace", "24524": "sprint_symbol", "24525": "sprint_symbol_no_offset", "24526": "sprintf", "24527": "spurious_deferred", "24528": "squeue", "24529": "sr1", "24530": "sr2", "24531": "src", "24532": "src_capacity", "24533": "src_cfs_rq", "24534": "src_cgrp", "24535": "src_cpu", "24536": "src_cset", "24537": "src_csets", "24538": "src_load", "24539": "src_nid", "24540": "src_op", "24541": "src_reg", "24542": "src_reg_type", "24543": "src_root", "24544": "src_rq", "24545": "src_stats", "24546": "src_task", "24547": "src_tree", "24548": "srctree", "24549": "srcu", "24550": "srcu_advance_batches", "24551": "srcu_barrier", "24552": "srcu_batches_completed", "24553": "srcu_callback_batch", "24554": "srcu_collect_new", "24555": "srcu_ctl", "24556": "srcu_flavor", "24557": "srcu_flip", "24558": "srcu_init_notifier_head", "24559": "srcu_interval", "24560": "srcu_invoke_callbacks", "24561": "srcu_notifier_call_chain", "24562": "srcu_notifier_chain_register", "24563": "srcu_notifier_chain_unregister", "24564": "srcu_notifier_head", "24565": "srcu_ops", "24566": "srcu_read_delay", "24567": "srcu_read_lock", "24568": "srcu_read_lock_held", "24569": "srcu_read_unlock", "24570": "srcu_readers_active", "24571": "srcu_readers_active_idx", "24572": "srcu_readers_active_idx_check", "24573": "srcu_readers_seq_idx", "24574": "srcu_reschedule", "24575": "srcu_retry_check_delay", "24576": "srcu_struct", "24577": "srcu_struct_array", "24578": "srcu_torture_barrier", "24579": "srcu_torture_call", "24580": "srcu_torture_completed", "24581": "srcu_torture_deferred_free", "24582": "srcu_torture_read_lock", "24583": "srcu_torture_read_unlock", "24584": "srcu_torture_stats", "24585": "srcu_torture_synchronize", "24586": "srcu_torture_synchronize_expedited", "24587": "srcversion", "24588": "ss", "24589": "ss_disable", "24590": "ss_flags", "24591": "ss_mask", "24592": "ss_onstack", "24593": "ss_size", "24594": "ss_sp", "24595": "ssbpt", "24596": "sscanf", "24597": "ssecs", "24598": "ssetmask", "24599": "ssid", "24600": "ssize_t", "24601": "ssleep", "24602": "sstep_cpu", "24603": "sstep_tries", "24604": "st", "24605": "st_info", "24606": "st_l", "24607": "st_mem_", "24608": "st_mem_b", "24609": "st_mem_dw", "24610": "st_mem_h", "24611": "st_mem_w", "24612": "st_name", "24613": "st_shndx", "24614": "st_size", "24615": "st_t", "24616": "st_value", "24617": "sta_clockerr", "24618": "sta_freqhold", "24619": "sta_mode", "24620": "sta_nano", "24621": "sta_pll", "24622": "sta_ppserror", "24623": "sta_ppsfreq", "24624": "sta_ppsjitter", "24625": "sta_ppssignal", "24626": "sta_ppstime", "24627": "sta_ppswander", "24628": "sta_ronly", "24629": "sta_unsync", "24630": "stabil", "24631": "stack", "24632": "stack_canary", "24633": "stack_dump_index", "24634": "stack_dump_trace", "24635": "stack_end_magic", "24636": "stack_entry", "24637": "stack_invalid", "24638": "stack_max_size", "24639": "stack_max_size_fops", "24640": "stack_max_size_read", "24641": "stack_max_size_write", "24642": "stack_misc", "24643": "stack_node", "24644": "stack_relative", "24645": "stack_size", "24646": "stack_skip", "24647": "stack_slot_type", "24648": "stack_spill", "24649": "stack_start", "24650": "stack_sysctl_mutex", "24651": "stack_t", "24652": "stack_trace", "24653": "stack_trace_entries", "24654": "stack_trace_filter", "24655": "stack_trace_filter_buf", "24656": "stack_trace_filter_fops", "24657": "stack_trace_filter_open", "24658": "stack_trace_fops", "24659": "stack_trace_init", "24660": "stack_trace_open", "24661": "stack_trace_seq_ops", "24662": "stack_trace_sysctl", "24663": "stack_tracer_enabled", "24664": "stack_user_size", "24665": "stack_vm", "24666": "stackend", "24667": "stacktrace", "24668": "stacktrace_count_probe_ops", "24669": "stacktrace_count_trigger", "24670": "stacktrace_count_trigger_ops", "24671": "stacktrace_get_trigger_ops", "24672": "stacktrace_probe_ops", "24673": "stacktrace_trigger", "24674": "stacktrace_trigger_ops", "24675": "stacktrace_trigger_print", "24676": "stall", "24677": "stall_cpu", "24678": "stall_cpu_holdoff", "24679": "stall_task", "24680": "stamp", "24681": "standard_param_def", "24682": "standby", "24683": "start", "24684": "start_addr", "24685": "start_bandwidth_timer", "24686": "start_branch_trace", "24687": "start_brk", "24688": "start_cfs_slack_bandwidth", "24689": "start_code", "24690": "start_comm", "24691": "start_critical_timing", "24692": "start_critical_timings", "24693": "start_data", "24694": "start_debit", "24695": "start_flush_work", "24696": "start_func", "24697": "start_func_tracer", "24698": "start_graph_tracing", "24699": "start_index", "24700": "start_irqsoff_tracer", "24701": "start_lba", "24702": "start_lock", "24703": "start_pfn", "24704": "start_pg", "24705": "start_pid", "24706": "start_rt_bandwidth", "24707": "start_sect", "24708": "start_site", "24709": "start_stack", "24710": "start_time", "24711": "start_tstamp", "24712": "start_txn", "24713": "start_wakeup_tracer", "24714": "started", "24715": "startf", "24716": "starting_runtime", "24717": "starttime", "24718": "stask", "24719": "stat", "24720": "stat_addr", "24721": "stat_cmp", "24722": "stat_dir", "24723": "stat_headers", "24724": "stat_interval", "24725": "stat_mutex", "24726": "stat_nam", "24727": "stat_next", "24728": "stat_node", "24729": "stat_release", "24730": "stat_root", "24731": "stat_seq_init", "24732": "stat_seq_next", "24733": "stat_seq_show", "24734": "stat_seq_start", "24735": "stat_seq_stop", "24736": "stat_session", "24737": "stat_show", "24738": "stat_start", "24739": "state", "24740": "state_filter", "24741": "state_list_mark", "24742": "state_name", "24743": "state_names", "24744": "state_rcu_head_queued", "24745": "state_rcu_head_ready", "24746": "state_show", "24747": "state_to_char", "24748": "state_use_accessors", "24749": "state_verbose", "24750": "state_verbose_f", "24751": "states", "24752": "states_equal", "24753": "static", "24754": "static_branch_", "24755": "static_key", "24756": "static_key_", "24757": "static_key_check_use", "24758": "static_key_deferred", "24759": "static_key_enabled", "24760": "static_key_false", "24761": "static_key_init", "24762": "static_key_init_false", "24763": "static_key_initialized", "24764": "static_key_mod", "24765": "static_key_slow_dec", "24766": "static_key_slow_dec_deferred", "24767": "static_key_slow_inc", "24768": "static_lockdep_map_init", "24769": "static_obj", "24770": "static_prio", "24771": "statistics", "24772": "statp", "24773": "stats", "24774": "stats_lock", "24775": "stats_task", "24776": "status", "24777": "status_use_accessors", "24778": "statusp", "24779": "stb_weak", "24780": "stbcnt", "24781": "std", "24782": "std_nice", "24783": "stddev", "24784": "steal", "24785": "steal_account_process_tick", "24786": "steal_ct", "24787": "stepping", "24788": "still_pending", "24789": "stime", "24790": "stimescaled", "24791": "stmt", "24792": "stop", "24793": "stop_a_enabled", "24794": "stop_at", "24795": "stop_branch_trace", "24796": "stop_count", "24797": "stop_cpus", "24798": "stop_cpus_lock", "24799": "stop_cpus_mutex", "24800": "stop_cpus_work", "24801": "stop_critical_timing", "24802": "stop_critical_timings", "24803": "stop_func_tracer", "24804": "stop_irqsoff_tracer", "24805": "stop_machine", "24806": "stop_machine_from_inactive_cpu", "24807": "stop_machine_initialized", "24808": "stop_one_cpu", "24809": "stop_one_cpu_nowait", "24810": "stop_sched_class", "24811": "stop_trace_on_warning", "24812": "stop_two_cpus", "24813": "stop_wakeup_tracer", "24814": "stopper", "24815": "store", "24816": "store_cpumask", "24817": "store_gcov_u32", "24818": "store_gcov_u64", "24819": "store_stacktrace", "24820": "store_trace_args", "24821": "store_uevent", "24822": "stp", "24823": "str", "24824": "str_item", "24825": "str_len", "24826": "str_loc", "24827": "strcat", "24828": "strchr", "24829": "strcmp", "24830": "strcpy", "24831": "strcspn", "24832": "stream_id", "24833": "strict_iomem", "24834": "strict_iomem_checks", "24835": "strict_read_checks", "24836": "strim", "24837": "string", "24838": "string_size", "24839": "strlcpy", "24840": "strlen", "24841": "strncasecmp", "24842": "strncat", "24843": "strncmp", "24844": "strncpy", "24845": "strncpy_from_user", "24846": "strndup_user", "24847": "strnlen_user", "24848": "strnstr", "24849": "stroffs", "24850": "strong_try_module_get", "24851": "strpbrk", "24852": "strrchr", "24853": "strsect", "24854": "strsep", "24855": "strstarts", "24856": "strstr", "24857": "strstrip", "24858": "strtab", "24859": "strtab_size", "24860": "strtobool", "24861": "strtolfn", "24862": "struct", "24863": "struct_name", "24864": "stt_object", "24865": "stub_timer", "24866": "stutter", "24867": "stutter_pause_test", "24868": "stutter_task", "24869": "stutter_wait", "24870": "stx_mem_", "24871": "stx_mem_b", "24872": "stx_mem_dw", "24873": "stx_mem_h", "24874": "stx_mem_w", "24875": "stx_xadd_dw", "24876": "stx_xadd_w", "24877": "sub", "24878": "sub_info", "24879": "sub_nr_running", "24880": "subbuf", "24881": "subbuf_start", "24882": "subclass", "24883": "subkeys", "24884": "submit", "24885": "submit_bio", "24886": "subprocess_info", "24887": "subscribers", "24888": "subset", "24889": "subset_ns", "24890": "subsys", "24891": "subsys_initcall", "24892": "subsys_mask", "24893": "subsys_system_register", "24894": "subsys_virtual_register", "24895": "subsystem", "24896": "subsystem_filter_read", "24897": "subsystem_filter_write", "24898": "subsystem_open", "24899": "subsystem_release", "24900": "subsystems", "24901": "subtime", "24902": "subtract_blocked_load_contrib", "24903": "subtract_range", "24904": "subtree_control", "24905": "success", "24906": "suffix", "24907": "suffix_high", "24908": "suffix_low", "24909": "suffix_null", "24910": "suffix_tbl", "24911": "suid", "24912": "suid_dump_disable", "24913": "suid_dump_root", "24914": "suid_dump_user", "24915": "suid_dumpable", "24916": "suidp", "24917": "sum", "24918": "sum_exec_runtime", "24919": "sum_forward_deps", "24920": "sum_nr_running", "24921": "sum_offline", "24922": "sum_online", "24923": "sum_sched_runtime", "24924": "sum_sleep_runtime", "24925": "sum_weighted_load", "24926": "super_block", "24927": "supported", "24928": "suppress", "24929": "suspend", "24930": "suspend_console", "24931": "suspend_device_irq", "24932": "suspend_device_irqs", "24933": "suspend_devices_and_enter", "24934": "suspend_enter", "24935": "suspend_freeze_processes", "24936": "suspend_resume", "24937": "suspend_state_t", "24938": "suspend_test_finish", "24939": "suspend_test_start", "24940": "suspend_test_start_time", "24941": "suspend_thaw_processes", "24942": "suspend_type", "24943": "suspend_work", "24944": "suspending", "24945": "swahw32", "24946": "swap", "24947": "swap_area", "24948": "swap_free", "24949": "swap_map_handle", "24950": "swap_map_page", "24951": "swap_map_page_list", "24952": "swap_offset", "24953": "swap_page", "24954": "swap_read_page", "24955": "swap_reader_finish", "24956": "swap_type_of", "24957": "swap_write_page", "24958": "swap_writer_finish", "24959": "swapdev_block", "24960": "swapin_count", "24961": "swapin_delay", "24962": "swapin_delay_total", "24963": "swdev", "24964": "switch", "24965": "switch_count", "24966": "switch_mm", "24967": "switch_task_namespaces", "24968": "switch_to", "24969": "switched", "24970": "switched_from", "24971": "switched_from_fair", "24972": "switched_from_rt", "24973": "switched_to", "24974": "switched_to_fair", "24975": "switched_to_idle", "24976": "switched_to_rt", "24977": "switching", "24978": "swp_entry", "24979": "swp_offset", "24980": "swsusp_alloc", "24981": "swsusp_arch_resume", "24982": "swsusp_arch_suspend", "24983": "swsusp_check", "24984": "swsusp_close", "24985": "swsusp_extent", "24986": "swsusp_extents", "24987": "swsusp_extents_insert", "24988": "swsusp_free", "24989": "swsusp_header", "24990": "swsusp_header_init", "24991": "swsusp_info", "24992": "swsusp_page_is_forbidden", "24993": "swsusp_page_is_free", "24994": "swsusp_read", "24995": "swsusp_resume_block", "24996": "swsusp_resume_device", "24997": "swsusp_save", "24998": "swsusp_set_page_forbidden", "24999": "swsusp_set_page_free", "25000": "swsusp_show_speed", "25001": "swsusp_swap_check", "25002": "swsusp_swap_in_use", "25003": "swsusp_unmark", "25004": "swsusp_unset_page_forbidden", "25005": "swsusp_unset_page_free", "25006": "swsusp_write", "25007": "sym", "25008": "sym_buf", "25009": "sym_end", "25010": "sym_flags", "25011": "sym_name", "25012": "sym_start", "25013": "symaddr", "25014": "symbol", "25015": "symbol_array", "25016": "symbol_cache", "25017": "symbol_end", "25018": "symbol_name", "25019": "symbol_offset", "25020": "symbol_put_addr", "25021": "symbol_start", "25022": "symbolic", "25023": "symbols", "25024": "symbolsize", "25025": "symname", "25026": "symnum", "25027": "symoffs", "25028": "syms", "25029": "symsearch", "25030": "symsec", "25031": "symsect", "25032": "symtab", "25033": "symtab_p", "25034": "symtab_p2", "25035": "symversion", "25036": "sync", "25037": "sync_cmos_work", "25038": "sync_filesystems", "25039": "sync_rcu_preempt_exp_count", "25040": "sync_rcu_preempt_exp_done", "25041": "sync_rcu_preempt_exp_init1", "25042": "sync_rcu_preempt_exp_init2", "25043": "sync_rcu_preempt_exp_mutex", "25044": "sync_rcu_preempt_exp_wq", "25045": "sync_read", "25046": "synced", "25047": "synchronize_hardirq", "25048": "synchronize_irq", "25049": "synchronize_net", "25050": "synchronize_rcu", "25051": "synchronize_rcu_bh", "25052": "synchronize_rcu_bh_expedited", "25053": "synchronize_rcu_busted", "25054": "synchronize_rcu_expedited", "25055": "synchronize_rcu_tasks", "25056": "synchronize_sched", "25057": "synchronize_sched_expedited", "25058": "synchronize_sched_expedited_cpu_stop", "25059": "synchronize_srcu", "25060": "synchronize_srcu_exp_trycount", "25061": "synchronize_srcu_expedited", "25062": "synchronize_srcu_trycount", "25063": "synchronous_mask", "25064": "syncing", "25065": "synctype", "25066": "sys32_quotactl", "25067": "sys_accept", "25068": "sys_accept4", "25069": "sys_acct", "25070": "sys_add_key", "25071": "sys_bdflush", "25072": "sys_bind", "25073": "sys_bpf", "25074": "sys_capget", "25075": "sys_capset", "25076": "sys_chown", "25077": "sys_chown16", "25078": "sys_clock_adjtime", "25079": "sys_clock_getres", "25080": "sys_clock_gettime", "25081": "sys_clock_nanosleep", "25082": "sys_clock_settime", "25083": "sys_connect", "25084": "sys_data", "25085": "sys_delete_module", "25086": "sys_epoll_create", "25087": "sys_epoll_create1", "25088": "sys_epoll_ctl", "25089": "sys_epoll_pwait", "25090": "sys_epoll_wait", "25091": "sys_eventfd", "25092": "sys_eventfd2", "25093": "sys_execveat", "25094": "sys_fadvise64", "25095": "sys_fadvise64_64", "25096": "sys_fanotify_init", "25097": "sys_fanotify_mark", "25098": "sys_fchown", "25099": "sys_fchown16", "25100": "sys_finit_module", "25101": "sys_flock", "25102": "sys_futex", "25103": "sys_get_mempolicy", "25104": "sys_get_robust_list", "25105": "sys_getegid16", "25106": "sys_geteuid16", "25107": "sys_getgid16", "25108": "sys_getgroups", "25109": "sys_getgroups16", "25110": "sys_getpeername", "25111": "sys_getpgid", "25112": "sys_getresgid", "25113": "sys_getresgid16", "25114": "sys_getresuid", "25115": "sys_getresuid16", "25116": "sys_getsockname", "25117": "sys_getsockopt", "25118": "sys_getuid16", "25119": "sys_halt", "25120": "sys_init_module", "25121": "sys_inotify_add_watch", "25122": "sys_inotify_init", "25123": "sys_inotify_init1", "25124": "sys_inotify_rm_watch", "25125": "sys_io_cancel", "25126": "sys_io_destroy", "25127": "sys_io_getevents", "25128": "sys_io_setup", "25129": "sys_io_submit", "25130": "sys_ioprio_get", "25131": "sys_ioprio_set", "25132": "sys_ipc", "25133": "sys_kcmp", "25134": "sys_kexec_file_load", "25135": "sys_kexec_load", "25136": "sys_keyctl", "25137": "sys_lchown", "25138": "sys_lchown16", "25139": "sys_listen", "25140": "sys_lookup_dcookie", "25141": "sys_madvise", "25142": "sys_mbind", "25143": "sys_memfd_create", "25144": "sys_migrate_pages", "25145": "sys_mincore", "25146": "sys_mlock", "25147": "sys_mlockall", "25148": "sys_move_pages", "25149": "sys_mprotect", "25150": "sys_mq_getsetattr", "25151": "sys_mq_notify", "25152": "sys_mq_open", "25153": "sys_mq_timedreceive", "25154": "sys_mq_timedsend", "25155": "sys_mq_unlink", "25156": "sys_mremap", "25157": "sys_msgctl", "25158": "sys_msgget", "25159": "sys_msgrcv", "25160": "sys_msgsnd", "25161": "sys_msync", "25162": "sys_munlock", "25163": "sys_munlockall", "25164": "sys_name_to_handle_at", "25165": "sys_ni_syscall", "25166": "sys_old_getrlimit", "25167": "sys_open_by_handle_at", "25168": "sys_pciconfig_iobase", "25169": "sys_pciconfig_read", "25170": "sys_pciconfig_write", "25171": "sys_perf_event_open", "25172": "sys_perf_refcount_enter", "25173": "sys_perf_refcount_exit", "25174": "sys_power_off", "25175": "sys_process_vm_readv", "25176": "sys_process_vm_writev", "25177": "sys_quotactl", "25178": "sys_recv", "25179": "sys_recvfrom", "25180": "sys_recvmmsg", "25181": "sys_recvmsg", "25182": "sys_refcount_enter", "25183": "sys_refcount_exit", "25184": "sys_remap_file_pages", "25185": "sys_request_key", "25186": "sys_restart", "25187": "sys_rt_sigpending", "25188": "sys_rt_sigprocmask", "25189": "sys_rt_sigsuspend", "25190": "sys_s390_pci_mmio_read", "25191": "sys_s390_pci_mmio_write", "25192": "sys_sched_yield", "25193": "sys_seccomp", "25194": "sys_semctl", "25195": "sys_semget", "25196": "sys_semop", "25197": "sys_semtimedop", "25198": "sys_send", "25199": "sys_sendmmsg", "25200": "sys_sendmsg", "25201": "sys_sendto", "25202": "sys_set_mempolicy", "25203": "sys_set_robust_list", "25204": "sys_setfsgid", "25205": "sys_setfsgid16", "25206": "sys_setfsuid", "25207": "sys_setfsuid16", "25208": "sys_setgid", "25209": "sys_setgid16", "25210": "sys_setgroups", "25211": "sys_setgroups16", "25212": "sys_setregid", "25213": "sys_setregid16", "25214": "sys_setresgid", "25215": "sys_setresgid16", "25216": "sys_setresuid", "25217": "sys_setresuid16", "25218": "sys_setreuid", "25219": "sys_setreuid16", "25220": "sys_setsockopt", "25221": "sys_setuid", "25222": "sys_setuid16", "25223": "sys_sgetmask", "25224": "sys_shmat", "25225": "sys_shmctl", "25226": "sys_shmdt", "25227": "sys_shmget", "25228": "sys_shutdown", "25229": "sys_signalfd", "25230": "sys_signalfd4", "25231": "sys_sigpending", "25232": "sys_socket", "25233": "sys_socketcall", "25234": "sys_socketpair", "25235": "sys_spu_create", "25236": "sys_spu_run", "25237": "sys_ssetmask", "25238": "sys_subpage_prot", "25239": "sys_swapoff", "25240": "sys_swapon", "25241": "sys_sync", "25242": "sys_sysfs", "25243": "sys_syslog", "25244": "sys_timer_create", "25245": "sys_timer_gettime", "25246": "sys_timer_settime", "25247": "sys_timerfd_create", "25248": "sys_timerfd_gettime", "25249": "sys_timerfd_settime", "25250": "sys_tz", "25251": "sys_uselib", "25252": "sys_vm86", "25253": "sys_vm86old", "25254": "sys_wait4", "25255": "sys_waitid", "25256": "syscall", "25257": "syscall_define0", "25258": "syscall_define1", "25259": "syscall_define2", "25260": "syscall_define3", "25261": "syscall_define4", "25262": "syscall_define5", "25263": "syscall_define6", "25264": "syscall_enter_define_fields", "25265": "syscall_enter_register", "25266": "syscall_exit_define_fields", "25267": "syscall_exit_register", "25268": "syscall_field", "25269": "syscall_get_arch", "25270": "syscall_get_arguments", "25271": "syscall_get_enter_fields", "25272": "syscall_get_nr", "25273": "syscall_get_return_value", "25274": "syscall_metadata", "25275": "syscall_nr", "25276": "syscall_nr_to_meta", "25277": "syscall_rollback", "25278": "syscall_set_return_value", "25279": "syscall_trace_enter", "25280": "syscall_trace_exit", "25281": "syscall_trace_lock", "25282": "syscall_tracepoint_update", "25283": "syscall_whitelist", "25284": "syscalls_metadata", "25285": "syscore_ops", "25286": "syscore_resume", "25287": "syscore_shutdown", "25288": "syscore_suspend", "25289": "syscr", "25290": "sysctl", "25291": "sysctl_", "25292": "sysctl_admin_reserve_kbytes", "25293": "sysctl_base_table", "25294": "sysctl_compact_memory", "25295": "sysctl_compact_unevictable_allowed", "25296": "sysctl_compaction_handler", "25297": "sysctl_drop_caches", "25298": "sysctl_extfrag_handler", "25299": "sysctl_extfrag_threshold", "25300": "sysctl_getname", "25301": "sysctl_hugetlb_shm_group", "25302": "sysctl_hung_task_check_count", "25303": "sysctl_hung_task_panic", "25304": "sysctl_hung_task_timeout_secs", "25305": "sysctl_hung_task_warnings", "25306": "sysctl_ieee_emulation_warnings", "25307": "sysctl_init", "25308": "sysctl_kprobes_optimization", "25309": "sysctl_legacy_va_layout", "25310": "sysctl_lowmem_reserve_ratio", "25311": "sysctl_max_map_count", "25312": "sysctl_max_threads", "25313": "sysctl_memory_failure_early_kill", "25314": "sysctl_memory_failure_recovery", "25315": "sysctl_min_slab_ratio", "25316": "sysctl_min_slab_ratio_sysctl_handler", "25317": "sysctl_min_unmapped_ratio", "25318": "sysctl_min_unmapped_ratio_sysctl_handler", "25319": "sysctl_nr_open", "25320": "sysctl_nr_open_max", "25321": "sysctl_nr_open_min", "25322": "sysctl_nr_trim_pages", "25323": "sysctl_numa_balancing", "25324": "sysctl_numa_balancing_scan_delay", "25325": "sysctl_numa_balancing_scan_period_max", "25326": "sysctl_numa_balancing_scan_period_min", "25327": "sysctl_numa_balancing_scan_size", "25328": "sysctl_oom_dump_tasks", "25329": "sysctl_oom_kill_allocating_task", "25330": "sysctl_overcommit_kbytes", "25331": "sysctl_overcommit_memory", "25332": "sysctl_overcommit_ratio", "25333": "sysctl_panic_on_oom", "25334": "sysctl_panic_on_stackoverflow", "25335": "sysctl_perf_cpu_time_max_percent", "25336": "sysctl_perf_event_mlock", "25337": "sysctl_perf_event_paranoid", "25338": "sysctl_perf_event_sample_rate", "25339": "sysctl_protected_hardlinks", "25340": "sysctl_protected_symlinks", "25341": "sysctl_sched_autogroup_enabled", "25342": "sysctl_sched_cfs_bandwidth_slice", "25343": "sysctl_sched_child_runs_first", "25344": "sysctl_sched_features", "25345": "sysctl_sched_latency", "25346": "sysctl_sched_migration_cost", "25347": "sysctl_sched_min_granularity", "25348": "sysctl_sched_nr_migrate", "25349": "sysctl_sched_rt_period", "25350": "sysctl_sched_rt_runtime", "25351": "sysctl_sched_shares_window", "25352": "sysctl_sched_time_avg", "25353": "sysctl_sched_tunable_scaling", "25354": "sysctl_sched_wakeup_granularity", "25355": "sysctl_softlockup_all_cpu_backtrace", "25356": "sysctl_stat_interval", "25357": "sysctl_timer_migration", "25358": "sysctl_tsb_ratio", "25359": "sysctl_user_reserve_kbytes", "25360": "sysctl_vfs_cache_pressure", "25361": "sysctl_writes_legacy", "25362": "sysctl_writes_strict", "25363": "sysctl_writes_warn", "25364": "syscw", "25365": "sysfs_attr_init", "25366": "sysfs_bin_attr_init", "25367": "sysfs_blk_trace_attr_show", "25368": "sysfs_blk_trace_attr_store", "25369": "sysfs_create_bin_file", "25370": "sysfs_create_file", "25371": "sysfs_create_group", "25372": "sysfs_create_link", "25373": "sysfs_get_uname", "25374": "sysfs_ops", "25375": "sysfs_remove_bin_file", "25376": "sysfs_remove_file", "25377": "sysfs_remove_group", "25378": "sysfs_remove_link", "25379": "sysfs_show_current_tick_dev", "25380": "sysfs_test_command", "25381": "sysfs_test_status", "25382": "sysfs_unbind_tick_dev", "25383": "sysinfo", "25384": "syslog", "25385": "syslog_idx", "25386": "syslog_partial", "25387": "syslog_prev", "25388": "syslog_seq", "25389": "sysname", "25390": "sysrq_dbg_op", "25391": "sysrq_enable_boot", "25392": "sysrq_handle_dbg", "25393": "sysrq_key_op", "25394": "sysrq_poweroff_op", "25395": "sysrq_sched_debug_show", "25396": "sysrq_sysctl_handler", "25397": "sysrq_toggle_support", "25398": "system", "25399": "system_booting", "25400": "system_certificate_list", "25401": "system_certificate_list_size", "25402": "system_enable_read", "25403": "system_enable_write", "25404": "system_entering_hibernation", "25405": "system_fl_free_name", "25406": "system_freezable_power_efficient_wq", "25407": "system_freezable_wq", "25408": "system_freezing_cnt", "25409": "system_halt", "25410": "system_highpri_wq", "25411": "system_long_wq", "25412": "system_power_efficient_wq", "25413": "system_power_off", "25414": "system_ram", "25415": "system_refcount", "25416": "system_refcount_dec", "25417": "system_refcount_inc", "25418": "system_restart", "25419": "system_running", "25420": "system_state", "25421": "system_states", "25422": "system_tr_open", "25423": "system_trusted_keyring", "25424": "system_trusted_keyring_init", "25425": "system_unbound_wq", "25426": "system_wq", "25427": "systems", "25428": "sysvsem", "25429": "sz", "25430": "t", "25431": "t0", "25432": "t1", "25433": "t2", "25434": "t3", "25435": "t_action", "25436": "t_bytes", "25437": "t_error", "25438": "t_hash", "25439": "t_hash_next", "25440": "t_hash_show", "25441": "t_hash_start", "25442": "t_next", "25443": "t_sec", "25444": "t_sector", "25445": "t_show", "25446": "t_start", "25447": "t_stop", "25448": "t_uid", "25449": "table", "25450": "table_lock", "25451": "tablep", "25452": "tag", "25453": "tag_chunk", "25454": "tag_mount", "25455": "tagged", "25456": "taglen", "25457": "tai", "25458": "tai_offset", "25459": "tail", "25460": "tail_page", "25461": "taint", "25462": "taint_bad_page", "25463": "taint_cpu_out_of_spec", "25464": "taint_crap", "25465": "taint_die", "25466": "taint_firmware_workaround", "25467": "taint_forced_module", "25468": "taint_forced_rmmod", "25469": "taint_livepatch", "25470": "taint_machine_check", "25471": "taint_oot_module", "25472": "taint_overridden_acpi_table", "25473": "taint_proprietary_module", "25474": "taint_softlockup", "25475": "taint_unsigned_module", "25476": "taint_user", "25477": "taint_warn", "25478": "tainted_mask", "25479": "taints", "25480": "take_cpu_down", "25481": "take_cpu_down_param", "25482": "taken", "25483": "takeover_tasklets", "25484": "takes", "25485": "targ", "25486": "target", "25487": "target2", "25488": "target_attrs", "25489": "target_auid", "25490": "target_comm", "25491": "target_cpu", "25492": "target_entry", "25493": "target_entry1", "25494": "target_list", "25495": "target_load", "25496": "target_pid", "25497": "target_rq", "25498": "target_sessionid", "25499": "target_sid", "25500": "target_uid", "25501": "target_value", "25502": "tarray", "25503": "task", "25504": "task1", "25505": "task2", "25506": "task_active_pid_ns", "25507": "task_ca", "25508": "task_can_attach", "25509": "task_capacity", "25510": "task_cfs_rq", "25511": "task_cgroup_from_root", "25512": "task_cgroup_path", "25513": "task_clear_jobctl_pending", "25514": "task_clear_jobctl_trapping", "25515": "task_clear_spread_page", "25516": "task_clear_spread_slab", "25517": "task_comm_len", "25518": "task_contributes_to_load", "25519": "task_cpu", "25520": "task_cputime", "25521": "task_cputime_adjusted", "25522": "task_cputime_scaled", "25523": "task_creation", "25524": "task_cred_xxx", "25525": "task_cs", "25526": "task_css", "25527": "task_css_check", "25528": "task_css_is_root", "25529": "task_css_set", "25530": "task_ctx", "25531": "task_ctx_data", "25532": "task_ctx_nr", "25533": "task_ctx_sched_out", "25534": "task_ctx_size", "25535": "task_curr", "25536": "task_current", "25537": "task_dead", "25538": "task_delay_info", "25539": "task_delta", "25540": "task_event", "25541": "task_exit_notifier", "25542": "task_faults", "25543": "task_faults_idx", "25544": "task_fork", "25545": "task_fork_fair", "25546": "task_frag", "25547": "task_free_notifier", "25548": "task_freezer", "25549": "task_function_call", "25550": "task_group", "25551": "task_group_account_field", "25552": "task_group_is_autogroup", "25553": "task_group_lock", "25554": "task_group_path", "25555": "task_groups", "25556": "task_gtime", "25557": "task_h_load", "25558": "task_handoff_register", "25559": "task_handoff_unregister", "25560": "task_has_dl_policy", "25561": "task_has_mempolicy", "25562": "task_has_pi_waiters", "25563": "task_has_rt_policy", "25564": "task_hot", "25565": "task_interruptible", "25566": "task_io_accounting_init", "25567": "task_io_get_inblock", "25568": "task_io_get_oublock", "25569": "task_is_stopped", "25570": "task_is_stopped_or_traced", "25571": "task_is_traced", "25572": "task_killable", "25573": "task_list", "25574": "task_lock", "25575": "task_move_group", "25576": "task_move_group_fair", "25577": "task_nice", "25578": "task_no_new_privs", "25579": "task_node", "25580": "task_normal", "25581": "task_nr_scan_windows", "25582": "task_numa_assign", "25583": "task_numa_compare", "25584": "task_numa_env", "25585": "task_numa_fault", "25586": "task_numa_find_cpu", "25587": "task_numa_free", "25588": "task_numa_group", "25589": "task_numa_group_id", "25590": "task_numa_migrate", "25591": "task_numa_placement", "25592": "task_numa_work", "25593": "task_of", "25594": "task_on_rq_migrating", "25595": "task_on_rq_queued", "25596": "task_parked", "25597": "task_participate_group_stop", "25598": "task_pgrp", "25599": "task_pid", "25600": "task_pid_nr", "25601": "task_pid_nr_ns", "25602": "task_pid_vnr", "25603": "task_pos", "25604": "task_ppid_nr", "25605": "task_pt_regs", "25606": "task_rlimit", "25607": "task_rlimit_max", "25608": "task_rq", "25609": "task_rq_lock", "25610": "task_rq_unlock", "25611": "task_running", "25612": "task_scan_max", "25613": "task_scan_min", "25614": "task_sched_runtime", "25615": "task_session", "25616": "task_set_jobctl_pending", "25617": "task_set_no_new_privs", "25618": "task_set_spread_page", "25619": "task_set_spread_slab", "25620": "task_size", "25621": "task_sleep", "25622": "task_stack_end_corrupted", "25623": "task_state_change", "25624": "task_state_char", "25625": "task_state_to_char_str", "25626": "task_stopped", "25627": "task_struct", "25628": "task_struct_cachep", "25629": "task_tgid", "25630": "task_tgid_nr", "25631": "task_tgid_nr_ns", "25632": "task_tgid_vnr", "25633": "task_thread_info", "25634": "task_tick", "25635": "task_tick_fair", "25636": "task_tick_idle", "25637": "task_tick_numa", "25638": "task_tick_rt", "25639": "task_top_pi_waiter", "25640": "task_traced", "25641": "task_uid", "25642": "task_uninterruptible", "25643": "task_unlock", "25644": "task_user_regset_view", "25645": "task_waking", "25646": "task_waking_fair", "25647": "task_wants_autogroup", "25648": "task_weight", "25649": "task_woken", "25650": "task_woken_rt", "25651": "task_work_add", "25652": "task_work_cancel", "25653": "task_work_func_t", "25654": "task_work_run", "25655": "task_works", "25656": "taskimp", "25657": "tasklet", "25658": "tasklet_action", "25659": "tasklet_hi_action", "25660": "tasklet_hi_schedule", "25661": "tasklet_hi_vec", "25662": "tasklet_hrtimer", "25663": "tasklet_hrtimer_init", "25664": "tasklet_init", "25665": "tasklet_kill", "25666": "tasklet_kill_immediate", "25667": "tasklet_schedule", "25668": "tasklet_softirq", "25669": "tasklet_state_run", "25670": "tasklet_state_sched", "25671": "tasklet_struct", "25672": "tasklet_trylock", "25673": "tasklet_unlock", "25674": "tasklet_unlock_wait", "25675": "tasklet_vec", "25676": "tasklist_lock", "25677": "tasks", "25678": "tasks_frozen", "25679": "tasks_head", "25680": "tasks_ops", "25681": "tasks_rcu_exit_srcu", "25682": "tasks_timeline", "25683": "tasks_torture_read_lock", "25684": "tasks_torture_read_unlock", "25685": "taskstats", "25686": "taskstats_cache", "25687": "taskstats_cmd_attr_deregister_cpumask", "25688": "taskstats_cmd_attr_max", "25689": "taskstats_cmd_attr_pid", "25690": "taskstats_cmd_attr_register_cpumask", "25691": "taskstats_cmd_attr_tgid", "25692": "taskstats_cmd_get", "25693": "taskstats_cmd_get_policy", "25694": "taskstats_cmd_new", "25695": "taskstats_cpumask_maxlen", "25696": "taskstats_exit", "25697": "taskstats_genl_name", "25698": "taskstats_genl_version", "25699": "taskstats_init", "25700": "taskstats_init_early", "25701": "taskstats_needs_padding", "25702": "taskstats_ops", "25703": "taskstats_packet_size", "25704": "taskstats_seqnum", "25705": "taskstats_tgid_alloc", "25706": "taskstats_tgid_free", "25707": "taskstats_type_pid", "25708": "taskstats_type_tgid", "25709": "taskstats_user_cmd", "25710": "taskstats_version", "25711": "taskweight", "25712": "tb", "25713": "tb_fmt", "25714": "tbase_get_base", "25715": "tbase_get_deferrable", "25716": "tbase_get_irqsafe", "25717": "tbl", "25718": "tbl_data", "25719": "tbl_size", "25720": "tbuf", "25721": "tc", "25722": "tcd_param", "25723": "tconv", "25724": "tcred", "25725": "td", "25726": "tdata", "25727": "te_blk_io_trace", "25728": "tell_cpu_to_push", "25729": "temp_attr", "25730": "temp_end", "25731": "temp_num", "25732": "temp_start", "25733": "template", "25734": "ten_thousand", "25735": "test", "25736": "test_and_clear_bit", "25737": "test_and_set_bit", "25738": "test_bit", "25739": "test_boost", "25740": "test_boost_duration", "25741": "test_boost_interval", "25742": "test_callback", "25743": "test_core", "25744": "test_cpus", "25745": "test_devices", "25746": "test_enable_data", "25747": "test_filter_data", "25748": "test_filter_data_t", "25749": "test_first", "25750": "test_freezer", "25751": "test_func", "25752": "test_kprobe", "25753": "test_malloc", "25754": "test_max", "25755": "test_mutex", "25756": "test_no_idle_hz", "25757": "test_none", "25758": "test_opcodes", "25759": "test_platform", "25760": "test_pred_visited", "25761": "test_pred_visited_fn", "25762": "test_probe1", "25763": "test_probe2", "25764": "test_probe3", "25765": "test_rec_ops_needs_regs", "25766": "test_rec_probe", "25767": "test_recsafe_probe", "25768": "test_regs_probe", "25769": "test_repeat_count_current", "25770": "test_repeat_count_max", "25771": "test_ringbuffer", "25772": "test_spinlock", "25773": "test_spinlock_irq", "25774": "test_state", "25775": "test_state_label", "25776": "test_suspend", "25777": "test_suspend_seconds", "25778": "test_taint", "25779": "test_thread", "25780": "test_thread_data", "25781": "test_thread_flag", "25782": "test_time_stamp", "25783": "test_tsk_need_resched", "25784": "test_tsk_trace_trace", "25785": "test_type", "25786": "test_wakealarm", "25787": "test_walk_pred_cb", "25788": "test_work", "25789": "text_len", "25790": "text_mutex", "25791": "text_size", "25792": "tfc", "25793": "tfm", "25794": "tg", "25795": "tg_cfs_bandwidth", "25796": "tg_cfs_schedulable_down", "25797": "tg_contrib", "25798": "tg_get_cfs_period", "25799": "tg_get_cfs_quota", "25800": "tg_has_rt_tasks", "25801": "tg_load_contrib", "25802": "tg_nop", "25803": "tg_rt_schedulable", "25804": "tg_runnable_contrib", "25805": "tg_set_cfs_bandwidth", "25806": "tg_set_cfs_period", "25807": "tg_set_cfs_quota", "25808": "tg_set_rt_bandwidth", "25809": "tg_throttle_down", "25810": "tg_unthrottle_up", "25811": "tg_visitor", "25812": "tg_weight", "25813": "tgid", "25814": "tgstime", "25815": "tgutime", "25816": "than", "25817": "that", "25818": "that_cpu", "25819": "thaw", "25820": "thaw_kernel_threads", "25821": "thaw_processes", "25822": "thaw_workqueues", "25823": "the", "25824": "these", "25825": "third", "25826": "this", "25827": "this_clock", "25828": "this_cpu", "25829": "this_cpu_cpumask_var_ptr", "25830": "this_cpu_dec", "25831": "this_cpu_inc", "25832": "this_cpu_inc_return", "25833": "this_cpu_ksoftirqd", "25834": "this_cpu_ptr", "25835": "this_cpu_read", "25836": "this_cpu_write", "25837": "this_cpupid", "25838": "this_css", "25839": "this_eff_load", "25840": "this_flusher", "25841": "this_group", "25842": "this_len", "25843": "this_load", "25844": "this_module", "25845": "this_rq", "25846": "this_rq_lock", "25847": "this_scd", "25848": "this_syscall", "25849": "this_tr", "25850": "those", "25851": "thr", "25852": "thr_query", "25853": "thread", "25854": "thread_ack", "25855": "thread_comm", "25856": "thread_data", "25857": "thread_flags", "25858": "thread_fn", "25859": "thread_group", "25860": "thread_group_cputime", "25861": "thread_group_cputime_adjusted", "25862": "thread_group_cputime_init", "25863": "thread_group_cputimer", "25864": "thread_group_empty", "25865": "thread_group_leader", "25866": "thread_head", "25867": "thread_info", "25868": "thread_info_cache", "25869": "thread_info_cache_init", "25870": "thread_keyring", "25871": "thread_mask", "25872": "thread_node", "25873": "thread_should_run", "25874": "thread_size", "25875": "thread_size_order", "25876": "threadfn", "25877": "threadgroup", "25878": "threadgroup_change_begin", "25879": "threadgroup_change_end", "25880": "threadgroup_lock", "25881": "threadgroup_unlock", "25882": "threadid", "25883": "threadinfo_gfp", "25884": "threads", "25885": "threads_active", "25886": "threads_handled", "25887": "threads_handled_last", "25888": "threads_oneshot", "25889": "thref", "25890": "thresh", "25891": "threshold", "25892": "throttle_cfs_rq", "25893": "throttle_count", "25894": "throttled", "25895": "throttled_cfs_rq", "25896": "throttled_clock", "25897": "throttled_clock_task", "25898": "throttled_clock_task_time", "25899": "throttled_hierarchy", "25900": "throttled_lb_pair", "25901": "throttled_list", "25902": "throttled_time", "25903": "ti", "25904": "tick", "25905": "tick_bc_dev", "25906": "tick_broadcast", "25907": "tick_broadcast_clear_oneshot", "25908": "tick_broadcast_control", "25909": "tick_broadcast_device", "25910": "tick_broadcast_enter", "25911": "tick_broadcast_force", "25912": "tick_broadcast_force_mask", "25913": "tick_broadcast_forced", "25914": "tick_broadcast_init", "25915": "tick_broadcast_init_next_event", "25916": "tick_broadcast_init_sysfs", "25917": "tick_broadcast_lock", "25918": "tick_broadcast_mask", "25919": "tick_broadcast_mode", "25920": "tick_broadcast_off", "25921": "tick_broadcast_on", "25922": "tick_broadcast_oneshot_active", "25923": "tick_broadcast_oneshot_available", "25924": "tick_broadcast_oneshot_control", "25925": "tick_broadcast_oneshot_mask", "25926": "tick_broadcast_pending_mask", "25927": "tick_broadcast_set_affinity", "25928": "tick_broadcast_set_event", "25929": "tick_broadcast_setup_oneshot", "25930": "tick_broadcast_start_periodic", "25931": "tick_broadcast_state", "25932": "tick_broadcast_switch_to_oneshot", "25933": "tick_broadcast_update_freq", "25934": "tick_cancel_sched_timer", "25935": "tick_check_broadcast_device", "25936": "tick_check_broadcast_expired", "25937": "tick_check_new_device", "25938": "tick_check_oneshot_broadcast_this_cpu", "25939": "tick_check_oneshot_change", "25940": "tick_check_replacement", "25941": "tick_cleanup_dead_cpu", "25942": "tick_clock_notify", "25943": "tick_cpu_device", "25944": "tick_cpu_sched", "25945": "tick_device", "25946": "tick_device_is_functional", "25947": "tick_device_mode", "25948": "tick_device_setup_broadcast_func", "25949": "tick_device_uses_broadcast", "25950": "tick_do_broadcast", "25951": "tick_do_periodic_broadcast", "25952": "tick_do_timer_boot", "25953": "tick_do_timer_cpu", "25954": "tick_do_timer_none", "25955": "tick_do_update_jiffies64", "25956": "tick_error", "25957": "tick_get_broadcast_device", "25958": "tick_get_broadcast_mask", "25959": "tick_get_broadcast_oneshot_mask", "25960": "tick_get_device", "25961": "tick_get_tick_dev", "25962": "tick_get_tick_sched", "25963": "tick_gtod", "25964": "tick_handle_oneshot_broadcast", "25965": "tick_handle_periodic", "25966": "tick_handle_periodic_broadcast", "25967": "tick_handover_do_timer", "25968": "tick_init_highres", "25969": "tick_init_jiffy_update", "25970": "tick_init_sysfs", "25971": "tick_install_broadcast_device", "25972": "tick_install_replacement", "25973": "tick_irq_enter", "25974": "tick_irq_exit", "25975": "tick_is_broadcast_device", "25976": "tick_is_oneshot_available", "25977": "tick_length", "25978": "tick_length_base", "25979": "tick_next_period", "25980": "tick_nohz_account_idle_ticks", "25981": "tick_nohz_active", "25982": "tick_nohz_enabled", "25983": "tick_nohz_enabled_snap", "25984": "tick_nohz_full_cpu", "25985": "tick_nohz_full_enabled", "25986": "tick_nohz_full_kick", "25987": "tick_nohz_full_kick_all", "25988": "tick_nohz_full_kick_cpu", "25989": "tick_nohz_full_mask", "25990": "tick_nohz_full_running", "25991": "tick_nohz_full_setup", "25992": "tick_nohz_full_stop_tick", "25993": "tick_nohz_get_sleep_length", "25994": "tick_nohz_handler", "25995": "tick_nohz_idle_enter", "25996": "tick_nohz_idle_exit", "25997": "tick_nohz_init", "25998": "tick_nohz_irq_enter", "25999": "tick_nohz_irq_exit", "26000": "tick_nohz_kick_tick", "26001": "tick_nohz_mode", "26002": "tick_nohz_reprogram", "26003": "tick_nohz_restart", "26004": "tick_nohz_restart_sched_tick", "26005": "tick_nohz_start_idle", "26006": "tick_nohz_stop_idle", "26007": "tick_nohz_stop_sched_tick", "26008": "tick_nohz_switch_to_nohz", "26009": "tick_nohz_task_switch", "26010": "tick_nohz_tick_stopped", "26011": "tick_nohz_update_jiffies", "26012": "tick_nsec", "26013": "tick_oneshot_mode_active", "26014": "tick_oneshot_notify", "26015": "tick_oneshot_possible", "26016": "tick_percpu_dev", "26017": "tick_period", "26018": "tick_program_event", "26019": "tick_raw", "26020": "tick_receive_broadcast", "26021": "tick_resume", "26022": "tick_resume_broadcast", "26023": "tick_resume_broadcast_oneshot", "26024": "tick_resume_check_broadcast", "26025": "tick_resume_oneshot", "26026": "tick_sched", "26027": "tick_sched_do_timer", "26028": "tick_sched_handle", "26029": "tick_sched_timer", "26030": "tick_set_periodic_handler", "26031": "tick_setup_hrtimer_broadcast", "26032": "tick_setup_oneshot", "26033": "tick_setup_periodic", "26034": "tick_setup_sched_timer", "26035": "tick_shutdown", "26036": "tick_shutdown_broadcast", "26037": "tick_shutdown_broadcast_oneshot", "26038": "tick_stopped", "26039": "tick_suspend", "26040": "tick_suspend_broadcast", "26041": "tick_switch_to_oneshot", "26042": "tick_usec", "26043": "tickdev_mode_oneshot", "26044": "tickdev_mode_periodic", "26045": "ticks", "26046": "ticks_this_gp", "26047": "ticks_title", "26048": "ticks_value", "26049": "tid", "26050": "tid_addr", "26051": "tid_entry", "26052": "tidptr", "26053": "tif_memdie", "26054": "tif_nohz", "26055": "tif_notsc", "26056": "tif_polling_nrflag", "26057": "tif_seccomp", "26058": "tif_sigpending", "26059": "tif_syscall_audit", "26060": "tif_syscall_emu", "26061": "tif_syscall_trace", "26062": "tif_uprobe", "26063": "till_stall_check", "26064": "time", "26065": "time64_t", "26066": "time_adjust", "26067": "time_after", "26068": "time_after_eq", "26069": "time_before", "26070": "time_before_eq", "26071": "time_constant", "26072": "time_delta", "26073": "time_enabled", "26074": "time_error", "26075": "time_esterror", "26076": "time_freq", "26077": "time_hardirqs_off", "26078": "time_hardirqs_on", "26079": "time_is_before_jiffies", "26080": "time_left", "26081": "time_maxerror", "26082": "time_offset", "26083": "time_ok", "26084": "time_passed", "26085": "time_reftime", "26086": "time_running", "26087": "time_slice", "26088": "time_squared", "26089": "time_stamp", "26090": "time_start", "26091": "time_state", "26092": "time_status", "26093": "time_stop", "26094": "time_t", "26095": "time_tai", "26096": "timecounter", "26097": "timecounter_cyc2time", "26098": "timecounter_init", "26099": "timecounter_read", "26100": "timecounter_read_delta", "26101": "timed_out", "26102": "timekeeper", "26103": "timekeeper_lock", "26104": "timekeeping", "26105": "timekeeping_adjust", "26106": "timekeeping_apply_adjustment", "26107": "timekeeping_check_update", "26108": "timekeeping_clocktai", "26109": "timekeeping_forward_now", "26110": "timekeeping_freqadjust", "26111": "timekeeping_get_delta", "26112": "timekeeping_get_ns", "26113": "timekeeping_get_tai_offset", "26114": "timekeeping_init", "26115": "timekeeping_init_ops", "26116": "timekeeping_inject_offset", "26117": "timekeeping_inject_sleeptime64", "26118": "timekeeping_internal", "26119": "timekeeping_last_warning", "26120": "timekeeping_max_deferment", "26121": "timekeeping_notify", "26122": "timekeeping_overflow_seen", "26123": "timekeeping_resume", "26124": "timekeeping_rtc_skipresume", "26125": "timekeeping_rtc_skipsuspend", "26126": "timekeeping_set_tai_offset", "26127": "timekeeping_suspend", "26128": "timekeeping_suspend_time", "26129": "timekeeping_suspended", "26130": "timekeeping_syscore_ops", "26131": "timekeeping_underflow_seen", "26132": "timekeeping_update", "26133": "timekeeping_valid_for_hres", "26134": "timeout", "26135": "timeout_jiffies", "26136": "timeout_ms", "26137": "timeout_ns", "26138": "timeout_start", "26139": "timeout_us", "26140": "timer", "26141": "timer_abstime", "26142": "timer_active", "26143": "timer_cpu_notify", "26144": "timer_create", "26145": "timer_debug_descr", "26146": "timer_debug_hint", "26147": "timer_del", "26148": "timer_delete", "26149": "timer_delete_hook", "26150": "timer_entry_static", "26151": "timer_event_spec", "26152": "timer_fixup_activate", "26153": "timer_fixup_assert_init", "26154": "timer_fixup_free", "26155": "timer_fixup_init", "26156": "timer_flag", "26157": "timer_flag_mask", "26158": "timer_get", "26159": "timer_getoverrun", "26160": "timer_gettime", "26161": "timer_id", "26162": "timer_jiffies", "26163": "timer_list", "26164": "timer_list_iter", "26165": "timer_not_pinned", "26166": "timer_pending", "26167": "timer_pinned", "26168": "timer_register_cpu_notifier", "26169": "timer_retry", "26170": "timer_set", "26171": "timer_set_base", "26172": "timer_settime", "26173": "timer_slack_ns", "26174": "timer_softirq", "26175": "timer_stats", "26176": "timer_stats_account_timer", "26177": "timer_stats_active", "26178": "timer_stats_flag_deferrable", "26179": "timer_stats_timer_clear_start_info", "26180": "timer_stats_timer_set_start_info", "26181": "timer_stats_update_stats", "26182": "timer_t", "26183": "timerf", "26184": "timerqueue", "26185": "timerqueue_add", "26186": "timerqueue_del", "26187": "timerqueue_getnext", "26188": "timerqueue_head", "26189": "timers", "26190": "times", "26191": "timespec", "26192": "timespec64", "26193": "timespec64_add", "26194": "timespec64_add_ns", "26195": "timespec64_compare", "26196": "timespec64_sub", "26197": "timespec64_to_ktime", "26198": "timespec64_to_timespec", "26199": "timespec64_valid_strict", "26200": "timespec_add_ns", "26201": "timespec_add_safe", "26202": "timespec_sub", "26203": "timespec_to_jiffies", "26204": "timespec_to_ktime", "26205": "timespec_to_ns", "26206": "timespec_to_timespec64", "26207": "timespec_trunc", "26208": "timespec_valid", "26209": "timestamp", "26210": "timeval", "26211": "timeval_to_cputime", "26212": "timeval_to_jiffies", "26213": "timeval_to_ktime", "26214": "timeval_to_ns", "26215": "timeval_valid", "26216": "timex", "26217": "timezone", "26218": "timr", "26219": "tiny", "26220": "title", "26221": "tk", "26222": "tk_clear_ntp", "26223": "tk_clock_was_set", "26224": "tk_core", "26225": "tk_debug_account_sleep_time", "26226": "tk_debug_show_sleep_time", "26227": "tk_fast", "26228": "tk_fast_mono", "26229": "tk_fast_raw", "26230": "tk_mirror", "26231": "tk_normalize_xtime", "26232": "tk_offs_boot", "26233": "tk_offs_max", "26234": "tk_offs_real", "26235": "tk_offs_tai", "26236": "tk_offsets", "26237": "tk_read_base", "26238": "tk_set_wall_to_mono", "26239": "tk_set_xtime", "26240": "tk_setup_internals", "26241": "tk_update_ktime_data", "26242": "tk_update_sleep_time", "26243": "tk_xtime", "26244": "tk_xtime_add", "26245": "tkf", "26246": "tkr", "26247": "tkr_dummy", "26248": "tkr_mono", "26249": "tkr_raw", "26250": "tl", "26251": "tlb_migrate_finish", "26252": "tloc", "26253": "tls_val", "26254": "tm", "26255": "tm_hour", "26256": "tm_mday", "26257": "tm_min", "26258": "tm_mon", "26259": "tm_ref", "26260": "tm_sec", "26261": "tm_year", "26262": "tmono", "26263": "tmp", "26264": "tmp_attrs", "26265": "tmp_bitmap", "26266": "tmp_cs", "26267": "tmp_cset", "26268": "tmp_hex", "26269": "tmp_iter_page", "26270": "tmp_l", "26271": "tmp_link", "26272": "tmp_links", "26273": "tmp_list", "26274": "tmp_p", "26275": "tmp_raw", "26276": "tmp_seq", "26277": "tmp_sgs", "26278": "tmp_ss_mask", "26279": "tmp_task", "26280": "tmpbuflen", "26281": "tmpmask", "26282": "tmpstr", "26283": "tmptaint", "26284": "tmr", "26285": "tms", "26286": "tms_cstime", "26287": "tms_cutime", "26288": "tms_stime", "26289": "tms_utime", "26290": "tn", "26291": "tne", "26292": "tnf_fault_local", "26293": "tnf_migrate_fail", "26294": "tnf_migrated", "26295": "tnf_no_group", "26296": "tnf_shared", "26297": "tnt", "26298": "tnts", "26299": "to", "26300": "to_acct", "26301": "to_alloc", "26302": "to_change", "26303": "to_cpumask", "26304": "to_delayed_work", "26305": "to_free_highmem", "26306": "to_free_normal", "26307": "to_kthread", "26308": "to_live_kthread", "26309": "to_module_attr", "26310": "to_module_kobject", "26311": "to_param_attr", "26312": "to_pid_ns", "26313": "to_ratio", "26314": "to_remove", "26315": "to_remove_page", "26316": "to_rtc_device", "26317": "to_send", "26318": "to_tell", "26319": "to_user_ns", "26320": "to_uts_ns", "26321": "to_wakeup", "26322": "tocopy", "26323": "todo", "26324": "tofree", "26325": "tok", "26326": "token", "26327": "tolerance", "26328": "tolower", "26329": "tomono", "26330": "too", "26331": "too_long", "26332": "too_many_workers", "26333": "took", "26334": "top_cpuset", "26335": "top_down", "26336": "top_op", "26337": "top_trace_array", "26338": "topology_sd_flags", "26339": "torture_cleanup_begin", "26340": "torture_cleanup_end", "26341": "torture_create_kthread", "26342": "torture_flag", "26343": "torture_init_begin", "26344": "torture_init_end", "26345": "torture_kthread_stopping", "26346": "torture_lock_busted_write_delay", "26347": "torture_lock_busted_write_lock", "26348": "torture_lock_busted_write_unlock", "26349": "torture_lock_spin_write_unlock_irq", "26350": "torture_must_stop", "26351": "torture_must_stop_irq", "26352": "torture_mutex", "26353": "torture_mutex_delay", "26354": "torture_mutex_lock", "26355": "torture_mutex_unlock", "26356": "torture_onoff", "26357": "torture_onoff_cleanup", "26358": "torture_onoff_failures", "26359": "torture_onoff_init", "26360": "torture_onoff_stats", "26361": "torture_ops", "26362": "torture_param", "26363": "torture_random", "26364": "torture_random_add", "26365": "torture_random_mult", "26366": "torture_random_refresh", "26367": "torture_random_state", "26368": "torture_runnable", "26369": "torture_rwlock", "26370": "torture_rwlock_read_delay", "26371": "torture_rwlock_read_lock", "26372": "torture_rwlock_read_lock_irq", "26373": "torture_rwlock_read_unlock", "26374": "torture_rwlock_read_unlock_irq", "26375": "torture_rwlock_write_delay", "26376": "torture_rwlock_write_lock", "26377": "torture_rwlock_write_lock_irq", "26378": "torture_rwlock_write_unlock", "26379": "torture_rwlock_write_unlock_irq", "26380": "torture_rwsem", "26381": "torture_rwsem_down_read", "26382": "torture_rwsem_down_write", "26383": "torture_rwsem_read_delay", "26384": "torture_rwsem_up_read", "26385": "torture_rwsem_up_write", "26386": "torture_rwsem_write_delay", "26387": "torture_shuffle", "26388": "torture_shuffle_cleanup", "26389": "torture_shuffle_init", "26390": "torture_shuffle_task_register", "26391": "torture_shuffle_task_unregister_all", "26392": "torture_shuffle_tasks", "26393": "torture_shutdown", "26394": "torture_shutdown_absorb", "26395": "torture_shutdown_cleanup", "26396": "torture_shutdown_hook", "26397": "torture_shutdown_init", "26398": "torture_shutdown_nb", "26399": "torture_shutdown_notify", "26400": "torture_spin_lock_write_delay", "26401": "torture_spin_lock_write_lock", "26402": "torture_spin_lock_write_lock_irq", "26403": "torture_spin_lock_write_unlock", "26404": "torture_spinlock", "26405": "torture_stop_kthread", "26406": "torture_stutter", "26407": "torture_stutter_cleanup", "26408": "torture_stutter_init", "26409": "torture_type", "26410": "tot_reqs", "26411": "total", "26412": "total_alloc", "26413": "total_bw", "26414": "total_capacity", "26415": "total_dropped", "26416": "total_events", "26417": "total_faults", "26418": "total_forks", "26419": "total_insns", "26420": "total_len", "26421": "total_load", "26422": "total_lost", "26423": "total_numa_faults", "26424": "total_read", "26425": "total_ref_count", "26426": "total_size", "26427": "total_time_enabled", "26428": "total_time_running", "26429": "total_value", "26430": "total_vm", "26431": "total_written", "26432": "totalcpuusage", "26433": "totalhigh", "26434": "totalram", "26435": "totalram_pages", "26436": "totalswap", "26437": "totqlen", "26438": "touch_all_softlockup_watchdogs", "26439": "touch_nmi_watchdog", "26440": "touch_softlockup_watchdog", "26441": "touch_softlockup_watchdog_sync", "26442": "touch_ts", "26443": "toupper", "26444": "tp", "26445": "tp_", "26446": "tp_args", "26447": "tp_event", "26448": "tp_fast_assign", "26449": "tp_flag_profile", "26450": "tp_flag_registered", "26451": "tp_flag_trace", "26452": "tp_list", "26453": "tp_printk", "26454": "tp_proto", "26455": "tp_struct__entry", "26456": "tpadding", "26457": "tps", "26458": "tptr", "26459": "tr", "26460": "tr_a", "26461": "tr_b", "26462": "trace", "26463": "trace_access_lock", "26464": "trace_access_lock_init", "26465": "trace_access_unlock", "26466": "trace_active", "26467": "trace_add_event_call", "26468": "trace_array", "26469": "trace_array_cpu", "26470": "trace_array_fl_global", "26471": "trace_array_get", "26472": "trace_array_printk", "26473": "trace_array_printk_buf", "26474": "trace_array_put", "26475": "trace_array_vprintk", "26476": "trace_assign_type", "26477": "trace_benchmark", "26478": "trace_benchmark_event", "26479": "trace_benchmark_event_enabled", "26480": "trace_benchmark_reg", "26481": "trace_benchmark_unreg", "26482": "trace_blk", "26483": "trace_blk_event", "26484": "trace_blk_event_funcs", "26485": "trace_blk_opt_classic", "26486": "trace_boot_clock", "26487": "trace_boot_clock_buf", "26488": "trace_boot_options", "26489": "trace_boot_options_buf", "26490": "trace_bprint", "26491": "trace_bprintk_fmt", "26492": "trace_bprintk_fmt_list", "26493": "trace_bprintk_fmt_start", "26494": "trace_bputs", "26495": "trace_branch", "26496": "trace_branch_disable", "26497": "trace_branch_enable", "26498": "trace_branch_event", "26499": "trace_branch_funcs", "26500": "trace_branch_print", "26501": "trace_buf", "26502": "trace_buf_size", "26503": "trace_buf_size_default", "26504": "trace_buffer", "26505": "trace_buffer_bit", "26506": "trace_buffer_irq_bit", "26507": "trace_buffer_iter", "26508": "trace_buffer_lock_reserve", "26509": "trace_buffer_nmi_bit", "26510": "trace_buffer_sirq_bit", "26511": "trace_buffer_unlock_commit", "26512": "trace_call_bpf", "26513": "trace_clear_recursion", "26514": "trace_clock", "26515": "trace_clock_global", "26516": "trace_clock_jiffies", "26517": "trace_clock_local", "26518": "trace_clock_struct", "26519": "trace_cmdline_lock", "26520": "trace_cmdline_save", "26521": "trace_context_mask", "26522": "trace_control_bit", "26523": "trace_create_file", "26524": "trace_create_new_event", "26525": "trace_create_savedcmd", "26526": "trace_ctx", "26527": "trace_ctx_event", "26528": "trace_ctx_funcs", "26529": "trace_ctx_hex", "26530": "trace_ctx_print", "26531": "trace_ctx_raw", "26532": "trace_ctxwake_bin", "26533": "trace_ctxwake_hex", "26534": "trace_ctxwake_print", "26535": "trace_ctxwake_raw", "26536": "trace_current_buffer_lock_reserve", "26537": "trace_default_header", "26538": "trace_define_common_fields", "26539": "trace_define_field", "26540": "trace_destroy_fields", "26541": "trace_display_graph", "26542": "trace_do_benchmark", "26543": "trace_dump_stack", "26544": "trace_empty", "26545": "trace_entry", "26546": "trace_enum_map", "26547": "trace_enum_map_head", "26548": "trace_enum_map_item", "26549": "trace_enum_map_tail", "26550": "trace_enum_maps", "26551": "trace_enum_mutex", "26552": "trace_enums", "26553": "trace_event", "26554": "trace_event_buffer_lock_reserve", "26555": "trace_event_enable_cmd_record", "26556": "trace_event_enable_disable", "26557": "trace_event_enum_update", "26558": "trace_event_fl_cap_any", "26559": "trace_event_fl_filtered", "26560": "trace_event_fl_ignore_enable", "26561": "trace_event_fl_kprobe", "26562": "trace_event_fl_no_set_filter", "26563": "trace_event_fl_tracepoint", "26564": "trace_event_fl_use_call_filter", "26565": "trace_event_fl_was_enabled", "26566": "trace_event_fn", "26567": "trace_event_functions", "26568": "trace_event_init", "26569": "trace_event_raw_init", "26570": "trace_event_read_lock", "26571": "trace_event_read_unlock", "26572": "trace_event_sem", "26573": "trace_event_trigger_enable_disable", "26574": "trace_events", "26575": "trace_events_filter_test", "26576": "trace_file_lat_fmt", "26577": "trace_file_size", "26578": "trace_file_time_in_ns", "26579": "trace_find_cmdline", "26580": "trace_find_event_field", "26581": "trace_find_mark", "26582": "trace_find_next_entry", "26583": "trace_find_next_entry_inc", "26584": "trace_flag_hardirq", "26585": "trace_flag_irqs_nosupport", "26586": "trace_flag_irqs_off", "26587": "trace_flag_need_resched", "26588": "trace_flag_preempt_resched", "26589": "trace_flag_softirq", "26590": "trace_flag_type", "26591": "trace_flags", "26592": "trace_fn", "26593": "trace_fn_bin", "26594": "trace_fn_event", "26595": "trace_fn_funcs", "26596": "trace_fn_hex", "26597": "trace_fn_raw", "26598": "trace_fn_trace", "26599": "trace_format_open", "26600": "trace_ftrace_bit", "26601": "trace_ftrace_irq_bit", "26602": "trace_ftrace_max", "26603": "trace_ftrace_nmi_bit", "26604": "trace_ftrace_sirq_bit", "26605": "trace_ftrace_start", "26606": "trace_func_graph_ent_t", "26607": "trace_func_graph_ret_t", "26608": "trace_func_opt_stack", "26609": "trace_func_size", "26610": "trace_function", "26611": "trace_get_context_bit", "26612": "trace_get_fields", "26613": "trace_get_syscall_nr", "26614": "trace_get_user", "26615": "trace_graph_ent", "26616": "trace_graph_entry", "26617": "trace_graph_entry_watchdog", "26618": "trace_graph_function", "26619": "trace_graph_indent", "26620": "trace_graph_print_abs_time", "26621": "trace_graph_print_cpu", "26622": "trace_graph_print_duration", "26623": "trace_graph_print_fill_mask", "26624": "trace_graph_print_fill_shift", "26625": "trace_graph_print_irqs", "26626": "trace_graph_print_overhead", "26627": "trace_graph_print_overrun", "26628": "trace_graph_print_proc", "26629": "trace_graph_print_tail", "26630": "trace_graph_ret", "26631": "trace_graph_return", "26632": "trace_graph_thresh_entry", "26633": "trace_graph_thresh_return", "26634": "trace_handle_return", "26635": "trace_hardirq_context", "26636": "trace_hardirq_enter", "26637": "trace_hardirq_exit", "26638": "trace_hardirqs_enabled", "26639": "trace_hardirqs_off", "26640": "trace_hardirqs_off_caller", "26641": "trace_hardirqs_on", "26642": "trace_hardirqs_on_caller", "26643": "trace_header_multi_read", "26644": "trace_include_file", "26645": "trace_include_path", "26646": "trace_init_global_iter", "26647": "trace_internal_bit", "26648": "trace_internal_irq_bit", "26649": "trace_internal_nmi_bit", "26650": "trace_internal_sirq_bit", "26651": "trace_irq_bit", "26652": "trace_irq_handler_entry", "26653": "trace_irq_handler_exit", "26654": "trace_iter_annotate", "26655": "trace_iter_bin", "26656": "trace_iter_block", "26657": "trace_iter_branch", "26658": "trace_iter_context_info", "26659": "trace_iter_function", "26660": "trace_iter_graph_time", "26661": "trace_iter_hex", "26662": "trace_iter_irq_info", "26663": "trace_iter_latency_fmt", "26664": "trace_iter_markers", "26665": "trace_iter_overwrite", "26666": "trace_iter_preemptonly", "26667": "trace_iter_print_parent", "26668": "trace_iter_printk", "26669": "trace_iter_printk_msgonly", "26670": "trace_iter_raw", "26671": "trace_iter_record_cmd", "26672": "trace_iter_sleep_time", "26673": "trace_iter_stacktrace", "26674": "trace_iter_stop_on_free", "26675": "trace_iter_sym_addr", "26676": "trace_iter_sym_mask", "26677": "trace_iter_sym_offset", "26678": "trace_iter_sym_userobj", "26679": "trace_iter_userstacktrace", "26680": "trace_iter_verbose", "26681": "trace_iterator", "26682": "trace_iterator_flags", "26683": "trace_itimer_expire", "26684": "trace_itimer_state", "26685": "trace_keep_overwrite", "26686": "trace_kprobe", "26687": "trace_kprobe_has_gone", "26688": "trace_kprobe_is_on_module", "26689": "trace_kprobe_is_return", "26690": "trace_kprobe_module_callback", "26691": "trace_kprobe_module_nb", "26692": "trace_kprobe_offset", "26693": "trace_kprobe_symbol", "26694": "trace_kprobe_within_module", "26695": "trace_latency_header", "26696": "trace_likely_condition", "26697": "trace_list_max", "26698": "trace_list_start", "26699": "trace_lock_acquire", "26700": "trace_lock_acquired", "26701": "trace_lock_contended", "26702": "trace_lock_release", "26703": "trace_lookup_stack", "26704": "trace_mark", "26705": "trace_marker", "26706": "trace_mmio_map", "26707": "trace_mmio_rw", "26708": "trace_mmiotrace_map", "26709": "trace_mmiotrace_rw", "26710": "trace_module_add_events", "26711": "trace_module_free", "26712": "trace_module_get", "26713": "trace_module_has_bad_taint", "26714": "trace_module_nb", "26715": "trace_module_notify", "26716": "trace_module_remove_events", "26717": "trace_nop_print", "26718": "trace_note", "26719": "trace_note_time", "26720": "trace_note_tsk", "26721": "trace_on", "26722": "trace_ops", "26723": "trace_options", "26724": "trace_opts", "26725": "trace_overrun", "26726": "trace_parser", "26727": "trace_parser_clear", "26728": "trace_parser_cont", "26729": "trace_parser_get_init", "26730": "trace_parser_loaded", "26731": "trace_parser_put", "26732": "trace_pipe", "26733": "trace_pipe_raw", "26734": "trace_pm_qos_add_request", "26735": "trace_pm_qos_remove_request", "26736": "trace_pm_qos_update_flags", "26737": "trace_pm_qos_update_request", "26738": "trace_pm_qos_update_request_timeout", "26739": "trace_pm_qos_update_target", "26740": "trace_preempt_off", "26741": "trace_preempt_on", "26742": "trace_print", "26743": "trace_print_bprintk_msg_only", "26744": "trace_print_bputs_msg_only", "26745": "trace_print_context", "26746": "trace_print_flags", "26747": "trace_print_flags_u64", "26748": "trace_print_graph_duration", "26749": "trace_print_lat_context", "26750": "trace_print_lat_fmt", "26751": "trace_print_printk_msg_only", "26752": "trace_print_seq", "26753": "trace_printk", "26754": "trace_printk_init_buffers", "26755": "trace_printk_seq", "26756": "trace_printk_start_comm", "26757": "trace_probe", "26758": "trace_probe_is_enabled", "26759": "trace_probe_is_registered", "26760": "trace_rcu_barrier", "26761": "trace_rcu_batch_end", "26762": "trace_rcu_batch_start", "26763": "trace_rcu_callback", "26764": "trace_rcu_dyntick", "26765": "trace_rcu_fqs", "26766": "trace_rcu_future_gp", "26767": "trace_rcu_future_grace_period", "26768": "trace_rcu_grace_period", "26769": "trace_rcu_grace_period_init", "26770": "trace_rcu_invoke_callback", "26771": "trace_rcu_invoke_kfree_callback", "26772": "trace_rcu_kfree_callback", "26773": "trace_rcu_nocb_wake", "26774": "trace_rcu_preempt_task", "26775": "trace_rcu_quiescent_state_report", "26776": "trace_rcu_torture_read", "26777": "trace_rcu_unlock_preempted_task", "26778": "trace_rcu_utilization", "26779": "trace_record_cmdline_disabled", "26780": "trace_recursion", "26781": "trace_recursion_clear", "26782": "trace_recursion_set", "26783": "trace_recursion_test", "26784": "trace_recursive_lock", "26785": "trace_recursive_unlock", "26786": "trace_reg", "26787": "trace_reg_perf_add", "26788": "trace_reg_perf_close", "26789": "trace_reg_perf_del", "26790": "trace_reg_perf_open", "26791": "trace_reg_perf_register", "26792": "trace_reg_perf_unregister", "26793": "trace_reg_register", "26794": "trace_reg_unregister", "26795": "trace_remove_event_call", "26796": "trace_save_cmdline", "26797": "trace_sched_kthread_stop", "26798": "trace_sched_kthread_stop_ret", "26799": "trace_sched_migrate_task", "26800": "trace_sched_move_numa", "26801": "trace_sched_pi_setprio", "26802": "trace_sched_process_fork", "26803": "trace_sched_process_hang", "26804": "trace_sched_stat_blocked", "26805": "trace_sched_stat_iowait", "26806": "trace_sched_stat_runtime", "26807": "trace_sched_stat_sleep", "26808": "trace_sched_stat_wait", "26809": "trace_sched_stick_numa", "26810": "trace_sched_swap_numa", "26811": "trace_sched_switch", "26812": "trace_sched_wait_task", "26813": "trace_sched_wake_idle_without_ipi", "26814": "trace_sched_wakeup", "26815": "trace_sched_wakeup_new", "26816": "trace_search_list", "26817": "trace_selftest", "26818": "trace_selftest_dynamic_test_func", "26819": "trace_selftest_dynamic_test_func2", "26820": "trace_selftest_function_recursion", "26821": "trace_selftest_function_regs", "26822": "trace_selftest_ops", "26823": "trace_selftest_recursion_cnt", "26824": "trace_selftest_regs_found", "26825": "trace_selftest_regs_not_found", "26826": "trace_selftest_regs_start", "26827": "trace_selftest_regs_stat", "26828": "trace_selftest_startup_branch", "26829": "trace_selftest_startup_dynamic_tracing", "26830": "trace_selftest_startup_function", "26831": "trace_selftest_startup_function_graph", "26832": "trace_selftest_startup_irqsoff", "26833": "trace_selftest_startup_nop", "26834": "trace_selftest_startup_preemptirqsoff", "26835": "trace_selftest_startup_preemptoff", "26836": "trace_selftest_startup_sched_switch", "26837": "trace_selftest_startup_wakeup", "26838": "trace_selftest_test_dyn_cnt", "26839": "trace_selftest_test_dyn_func", "26840": "trace_selftest_test_global_cnt", "26841": "trace_selftest_test_global_func", "26842": "trace_selftest_test_probe1_cnt", "26843": "trace_selftest_test_probe1_func", "26844": "trace_selftest_test_probe2_cnt", "26845": "trace_selftest_test_probe2_func", "26846": "trace_selftest_test_probe3_cnt", "26847": "trace_selftest_test_probe3_func", "26848": "trace_selftest_test_recursion_func", "26849": "trace_selftest_test_recursion_safe_func", "26850": "trace_selftest_test_regs_func", "26851": "trace_seq", "26852": "trace_seq_bitmask", "26853": "trace_seq_bprintf", "26854": "trace_seq_buf_left", "26855": "trace_seq_buf_used", "26856": "trace_seq_buffer_ptr", "26857": "trace_seq_has_overflowed", "26858": "trace_seq_init", "26859": "trace_seq_path", "26860": "trace_seq_printf", "26861": "trace_seq_putc", "26862": "trace_seq_putmem", "26863": "trace_seq_putmem_hex", "26864": "trace_seq_puts", "26865": "trace_seq_to_buffer", "26866": "trace_seq_to_user", "26867": "trace_seq_used", "26868": "trace_seq_vprintf", "26869": "trace_set_clr_event", "26870": "trace_signal_already_pending", "26871": "trace_signal_deliver", "26872": "trace_signal_delivered", "26873": "trace_signal_generate", "26874": "trace_signal_ignored", "26875": "trace_signal_lose_info", "26876": "trace_signal_overflow_fail", "26877": "trace_softirq_context", "26878": "trace_softirq_entry", "26879": "trace_softirq_exit", "26880": "trace_softirq_raise", "26881": "trace_softirqs_enabled", "26882": "trace_softirqs_off", "26883": "trace_softirqs_on", "26884": "trace_stack", "26885": "trace_stack_print", "26886": "trace_stat_seq_ops", "26887": "trace_state", "26888": "trace_stop_cmdline_recording", "26889": "trace_suspend_resume", "26890": "trace_system", "26891": "trace_task_newtask", "26892": "trace_test_and_set_recursion", "26893": "trace_test_buffer", "26894": "trace_test_buffer_cpu", "26895": "trace_tick_stop", "26896": "trace_timer_cancel", "26897": "trace_timer_expire_entry", "26898": "trace_timer_expire_exit", "26899": "trace_timer_init", "26900": "trace_timer_start", "26901": "trace_type", "26902": "trace_type_handled", "26903": "trace_type_no_consume", "26904": "trace_type_partial_line", "26905": "trace_type_unhandled", "26906": "trace_types", "26907": "trace_types_lock", "26908": "trace_uprobe", "26909": "trace_uprobe_filter", "26910": "trace_uprobe_register", "26911": "trace_user_enter", "26912": "trace_user_exit", "26913": "trace_user_stack", "26914": "trace_valid_entry", "26915": "trace_vbprintk", "26916": "trace_vprintk", "26917": "trace_wake", "26918": "trace_wake_event", "26919": "trace_wake_funcs", "26920": "trace_wake_hex", "26921": "trace_wake_print", "26922": "trace_wake_raw", "26923": "trace_wakeup_test_thread", "26924": "trace_workqueue_activate_work", "26925": "trace_workqueue_execute_end", "26926": "trace_workqueue_execute_start", "26927": "trace_workqueue_queue_work", "26928": "traceable", "26929": "traced", "26930": "tracefs", "26931": "tracefs_create_dir", "26932": "tracefs_create_file", "26933": "tracefs_remove", "26934": "tracefs_remove_recursive", "26935": "tracehook_signal_handler", "26936": "traceoff", "26937": "traceoff_count_probe_ops", "26938": "traceoff_count_trigger", "26939": "traceoff_count_trigger_ops", "26940": "traceoff_probe_ops", "26941": "traceoff_trigger", "26942": "traceoff_trigger_ops", "26943": "traceoff_trigger_print", "26944": "traceon", "26945": "traceon_count_probe_ops", "26946": "traceon_count_trigger", "26947": "traceon_count_trigger_ops", "26948": "traceon_probe_ops", "26949": "traceon_trigger", "26950": "traceon_trigger_ops", "26951": "traceon_trigger_print", "26952": "tracepoint", "26953": "tracepoint_iter_lock", "26954": "tracepoint_print_iter", "26955": "tracepoint_printk", "26956": "tracepoint_probe_register", "26957": "tracepoint_probe_unregister", "26958": "tracepoint_string", "26959": "tracepoint_synchronize_unregister", "26960": "tracepoints_ptrs", "26961": "traceprobe_command", "26962": "traceprobe_conflict_field_name", "26963": "traceprobe_free_probe_arg", "26964": "traceprobe_parse_probe_arg", "26965": "traceprobe_probes_write", "26966": "traceprobe_split_symbol_offset", "26967": "traceprobe_update_arg", "26968": "tracer", "26969": "tracer_enabled", "26970": "tracer_flags", "26971": "tracer_init", "26972": "tracer_irqs_off", "26973": "tracer_opt", "26974": "tracer_preempt_off", "26975": "tracer_stat", "26976": "tracer_tracing_is_on", "26977": "tracer_tracing_off", "26978": "tracer_tracing_on", "26979": "tracers", "26980": "traces", "26981": "tracing", "26982": "tracing_alloc_snapshot", "26983": "tracing_buffer_mask", "26984": "tracing_cpu", "26985": "tracing_cpumask", "26986": "tracing_disabled", "26987": "tracing_dl", "26988": "tracing_get_trace_entry", "26989": "tracing_graph_pause", "26990": "tracing_init_dentry", "26991": "tracing_is_disabled", "26992": "tracing_is_enabled", "26993": "tracing_is_on", "26994": "tracing_iter_reset", "26995": "tracing_lseek", "26996": "tracing_max_latency", "26997": "tracing_off", "26998": "tracing_off_permanent", "26999": "tracing_on", "27000": "tracing_open_generic", "27001": "tracing_record_cmdline", "27002": "tracing_reset", "27003": "tracing_reset_all_online_cpus", "27004": "tracing_reset_current", "27005": "tracing_reset_online_cpus", "27006": "tracing_sched_register", "27007": "tracing_sched_switch_trace", "27008": "tracing_sched_unregister", "27009": "tracing_sched_wakeup_trace", "27010": "tracing_selftest_disabled", "27011": "tracing_selftest_running", "27012": "tracing_set_tracer", "27013": "tracing_snapshot", "27014": "tracing_start", "27015": "tracing_start_cmdline_record", "27016": "tracing_start_function_trace", "27017": "tracing_start_sched_switch", "27018": "tracing_stat_fops", "27019": "tracing_stat_init", "27020": "tracing_stat_open", "27021": "tracing_stat_release", "27022": "tracing_stop", "27023": "tracing_stop_cmdline_record", "27024": "tracing_stop_function_trace", "27025": "tracing_stop_sched_switch", "27026": "tracing_stop_tr", "27027": "tracing_thresh", "27028": "tracing_update_buffers", "27029": "tramp_name", "27030": "trampoline", "27031": "trampoline_size", "27032": "trampoline_vaddr", "27033": "transfer_pid", "27034": "translate_user_vaddr", "27035": "trap", "27036": "trapnr", "27037": "tree", "27038": "tree_count", "27039": "tree_entry", "27040": "tree_list", "27041": "trees", "27042": "trial", "27043": "trial_cpus", "27044": "trialcs", "27045": "trigger", "27046": "trigger_all_cpu_backtrace", "27047": "trigger_allbutself_cpu_backtrace", "27048": "trigger_cmd_mutex", "27049": "trigger_commands", "27050": "trigger_data", "27051": "trigger_data_free", "27052": "trigger_disable_cmd", "27053": "trigger_enable", "27054": "trigger_enable_cmd", "27055": "trigger_load_balance", "27056": "trigger_next", "27057": "trigger_ops", "27058": "trigger_process_regex", "27059": "trigger_show", "27060": "trigger_snapshot_cmd", "27061": "trigger_stacktrace_cmd", "27062": "trigger_start", "27063": "trigger_stop", "27064": "trigger_traceoff_cmd", "27065": "trigger_traceon_cmd", "27066": "trigger_type", "27067": "triggers", "27068": "trim_init_extable", "27069": "trim_marked", "27070": "trs_count", "27071": "trs_state", "27072": "trsp", "27073": "true", "27074": "true_branch", "27075": "truesize", "27076": "truncated", "27077": "try_check_zero", "27078": "try_force_unload", "27079": "try_get_online_cpus", "27080": "try_misrouted_irq", "27081": "try_module_get", "27082": "try_one_irq", "27083": "try_online_node", "27084": "try_reader_grant", "27085": "try_release_module_ref", "27086": "try_stop_cpus", "27087": "try_stop_module", "27088": "try_to_del_timer_sync", "27089": "try_to_force_load", "27090": "try_to_free_swap", "27091": "try_to_freeze", "27092": "try_to_freeze_tasks", "27093": "try_to_grab_pending", "27094": "try_to_optimize_kprobe", "27095": "try_to_push_tasks", "27096": "try_to_suspend", "27097": "try_to_wake_up", "27098": "try_to_wake_up_local", "27099": "trycount", "27100": "trying", "27101": "trylock", "27102": "trylock_loop", "27103": "ts", "27104": "ts64", "27105": "ts_comm_len", "27106": "ts_delta", "27107": "ts_delta_test", "27108": "ts_mask", "27109": "ts_new", "27110": "ts_nsec", "27111": "ts_raw", "27112": "ts_real", "27113": "ts_rem", "27114": "ts_shift", "27115": "tsave", "27116": "tsc", "27117": "tsdelta", "27118": "tset", "27119": "tsk", "27120": "tsk1", "27121": "tsk2", "27122": "tsk_bw", "27123": "tsk_cache_hot", "27124": "tsk_cpus_allowed", "27125": "tsk_fork_get_node", "27126": "tsk_is_pi_blocked", "27127": "tsk_restore_flags", "27128": "tstamp", "27129": "tstamp_enabled", "27130": "tstamp_running", "27131": "tstamp_stopped", "27132": "tstat_hash_mask", "27133": "tstat_hash_size", "27134": "tstat_hash_table", "27135": "tstat_hashentry", "27136": "tstat_lookup", "27137": "tstats_lookup_lock", "27138": "tstruct", "27139": "tt", "27140": "ttime_delta", "27141": "ttime_extend", "27142": "ttimer", "27143": "ttramp", "27144": "ttwu_activate", "27145": "ttwu_count", "27146": "ttwu_do_activate", "27147": "ttwu_do_wakeup", "27148": "ttwu_local", "27149": "ttwu_move_affine", "27150": "ttwu_move_balance", "27151": "ttwu_queue", "27152": "ttwu_queue_remote", "27153": "ttwu_remote", "27154": "ttwu_stat", "27155": "ttwu_wake_remote", "27156": "tty", "27157": "tty_audit_fork", "27158": "tty_devnum", "27159": "tty_kref_get", "27160": "tty_struct", "27161": "ttya", "27162": "ttyb", "27163": "ttype", "27164": "ttype_len", "27165": "ttys", "27166": "ttys0", "27167": "ttys1", "27168": "tu", "27169": "turning_on", "27170": "tv", "27171": "tv1", "27172": "tv2", "27173": "tv3", "27174": "tv4", "27175": "tv5", "27176": "tv64", "27177": "tv_list", "27178": "tv_nsec", "27179": "tv_sec", "27180": "tv_usec", "27181": "tvec", "27182": "tvec_base", "27183": "tvec_bases", "27184": "tvn_bits", "27185": "tvn_mask", "27186": "tvn_size", "27187": "tvr_bits", "27188": "tvr_mask", "27189": "two", "27190": "tx", "27191": "txc", "27192": "txc_p", "27193": "txn", "27194": "type", "27195": "type_info", "27196": "type_len", "27197": "type_str", "27198": "typedef", "27199": "typeof", "27200": "types", "27201": "tz", "27202": "tz_minuteswest", "27203": "u", "27204": "u16", "27205": "u32", "27206": "u32_max", "27207": "u64", "27208": "u64_to_ptr", "27209": "u8", "27210": "u_dst", "27211": "u_event", "27212": "u_src", "27213": "u_swap_area", "27214": "uaddr", "27215": "uaddr2", "27216": "uaf", "27217": "uargs", "27218": "uattr", "27219": "ubuf", "27220": "ubytes", "27221": "uc", "27222": "ucb", "27223": "uchunk", "27224": "udd", "27225": "udelay", "27226": "udelay_test_debugfs_file", "27227": "udelay_test_iterations", "27228": "udelay_test_lock", "27229": "udelay_test_open", "27230": "udelay_test_show", "27231": "udelay_test_single", "27232": "udelay_test_usecs", "27233": "udelay_test_write", "27234": "udelta", "27235": "uentry", "27236": "uevent", "27237": "uevent_filter", "27238": "uevent_helper", "27239": "uevent_helper_path_len", "27240": "uevent_helper_show", "27241": "uevent_helper_store", "27242": "uevent_seqnum", "27243": "uevent_seqnum_show", "27244": "ufd", "27245": "uid", "27246": "uid_cache_init", "27247": "uid_cachep", "27248": "uid_eq", "27249": "uid_gid_extent", "27250": "uid_gid_map", "27251": "uid_gid_map_max_extents", "27252": "uid_gt", "27253": "uid_gte", "27254": "uid_hash_find", "27255": "uid_hash_insert", "27256": "uid_hash_remove", "27257": "uid_keyring", "27258": "uid_lt", "27259": "uid_lte", "27260": "uid_m_show", "27261": "uid_m_start", "27262": "uid_map", "27263": "uid_t", "27264": "uid_valid", "27265": "uidhash_bits", "27266": "uidhash_lock", "27267": "uidhash_mask", "27268": "uidhash_node", "27269": "uidhash_sz", "27270": "uidhash_table", "27271": "uidhashentry", "27272": "uinfo", "27273": "uinsns_per_page", "27274": "uint", "27275": "uint32_t", "27276": "uint64_t", "27277": "uint_cmp_ge", "27278": "uint_max", "27279": "uiov", "27280": "ukey", "27281": "ullong", "27282": "ullong_max", "27283": "ulong", "27284": "ulong2long", "27285": "ulong_cmp_ge", "27286": "ulong_cmp_lt", "27287": "ulong_max", "27288": "um", "27289": "umask", "27290": "umh_complete", "27291": "umh_disable_depth", "27292": "umh_disabled", "27293": "umh_freezing", "27294": "umh_killable", "27295": "umh_no_wait", "27296": "umh_sysctl_lock", "27297": "umh_wait_exec", "27298": "umh_wait_proc", "27299": "umhelper_sem", "27300": "umod", "27301": "umode_t", "27302": "unable", "27303": "unaccount_event", "27304": "unaccount_event_cpu", "27305": "unaligned_dump_stack", "27306": "unaligned_enabled", "27307": "uname", "27308": "uname26", "27309": "unapply_uprobe", "27310": "unbind_device", "27311": "unbind_work", "27312": "unblock_all_signals", "27313": "unblocked", "27314": "unbound_attrs", "27315": "unbound_pool_hash", "27316": "unbound_pwq_by_node", "27317": "unbound_release_work", "27318": "unbound_std_wq_attrs", "27319": "unc", "27320": "unc_len", "27321": "unclone_ctx", "27322": "undef", "27323": "undo", "27324": "undo_list", "27325": "unewset", "27326": "unext_key", "27327": "unfreeze_cgroup", "27328": "unhandled_signal", "27329": "uninitialized_var", "27330": "union", "27331": "unique_pmu", "27332": "unknown", "27333": "unknown_module_param_cb", "27334": "unknown_nmi_panic", "27335": "unknown_value", "27336": "unlikely", "27337": "unlimited", "27338": "unlink_mod", "27339": "unloaded_info", "27340": "unlock", "27341": "unlock_and_return", "27342": "unlock_creds", "27343": "unlock_device_hotplug", "27344": "unlock_out", "27345": "unlock_page", "27346": "unlock_system_sleep", "27347": "unlock_task_sighand", "27348": "unlock_tasklist", "27349": "unlock_timer", "27350": "unlocked_ioctl", "27351": "unmap", "27352": "unmask", "27353": "unmask_irq", "27354": "unmask_threaded_irq", "27355": "unoptimize_kprobe", "27356": "unoptimizing_list", "27357": "unpack_orig_pfns", "27358": "unpark", "27359": "unpause_graph_tracing", "27360": "unreachable", "27361": "unreg", "27362": "unreg_event_syscall_enter", "27363": "unreg_event_syscall_exit", "27364": "unregister", "27365": "unregister_console", "27366": "unregister_cpu_notifier", "27367": "unregister_die_notifier", "27368": "unregister_event_command", "27369": "unregister_fair_sched_group", "27370": "unregister_ftrace_event", "27371": "unregister_ftrace_function", "27372": "unregister_ftrace_function_probe_func", "27373": "unregister_ftrace_graph", "27374": "unregister_ftrace_profiler", "27375": "unregister_handler_proc", "27376": "unregister_hotcpu_notifier", "27377": "unregister_irq_proc", "27378": "unregister_irqsoff_function", "27379": "unregister_jprobe", "27380": "unregister_jprobes", "27381": "unregister_kprobe", "27382": "unregister_kprobe_event", "27383": "unregister_kprobes", "27384": "unregister_kretprobe", "27385": "unregister_kretprobes", "27386": "unregister_module_notifier", "27387": "unregister_pm_notifier", "27388": "unregister_reboot_notifier", "27389": "unregister_restart_handler", "27390": "unregister_sched_domain_sysctl", "27391": "unregister_stat_tracer", "27392": "unregister_sysctl_table", "27393": "unregister_sysrq_key", "27394": "unregister_trace_block_bio_backmerge", "27395": "unregister_trace_block_bio_bounce", "27396": "unregister_trace_block_bio_complete", "27397": "unregister_trace_block_bio_frontmerge", "27398": "unregister_trace_block_bio_queue", "27399": "unregister_trace_block_bio_remap", "27400": "unregister_trace_block_getrq", "27401": "unregister_trace_block_plug", "27402": "unregister_trace_block_rq_abort", "27403": "unregister_trace_block_rq_complete", "27404": "unregister_trace_block_rq_insert", "27405": "unregister_trace_block_rq_issue", "27406": "unregister_trace_block_rq_remap", "27407": "unregister_trace_block_rq_requeue", "27408": "unregister_trace_block_sleeprq", "27409": "unregister_trace_block_split", "27410": "unregister_trace_block_unplug", "27411": "unregister_trace_kprobe", "27412": "unregister_trace_sched_migrate_task", "27413": "unregister_trace_sched_switch", "27414": "unregister_trace_sched_wakeup", "27415": "unregister_trace_sched_wakeup_new", "27416": "unregister_trace_sys_enter", "27417": "unregister_trace_sys_exit", "27418": "unregister_trace_uprobe", "27419": "unregister_trigger", "27420": "unregister_trigger_enable_disable_cmds", "27421": "unregister_uprobe_event", "27422": "unregister_wakeup_function", "27423": "unregistered", "27424": "unroll_tree_refs", "27425": "unsafe", "27426": "unsafe_ptr", "27427": "unset_module_core_ro_nx", "27428": "unset_module_init_ro_nx", "27429": "unshare", "27430": "unshare_fd", "27431": "unshare_files", "27432": "unshare_flags", "27433": "unshare_fs", "27434": "unshare_nsproxy_namespaces", "27435": "unshare_userns", "27436": "unsigned", "27437": "unstable", "27438": "unsupported", "27439": "untag_chunk", "27440": "unthrottle_cfs_rq", "27441": "unthrottle_offline_cfs_rqs", "27442": "unusable_pages", "27443": "unused", "27444": "unused1", "27445": "unused2", "27446": "unused3", "27447": "unused_crcs", "27448": "unused_dev_name", "27449": "unused_gpl_crcs", "27450": "unused_gpl_syms", "27451": "unused_syms", "27452": "unwind", "27453": "uoffset", "27454": "uoss", "27455": "uoss_ptr", "27456": "up", "27457": "up_console_sem", "27458": "up_read", "27459": "up_read_non_owner", "27460": "up_write", "27461": "update", "27462": "update_all_ops", "27463": "update_avg", "27464": "update_bitfield_fetch_param", "27465": "update_blocked_averages", "27466": "update_cfs_rq", "27467": "update_cfs_rq_blocked_load", "27468": "update_cfs_rq_h_load", "27469": "update_cfs_shares", "27470": "update_cgrp_time_from_cpuctx", "27471": "update_cgrp_time_from_event", "27472": "update_cnt", "27473": "update_cond_flag", "27474": "update_context_time", "27475": "update_count", "27476": "update_cpu_capacity", "27477": "update_cpu_load_active", "27478": "update_cpu_load_nohz", "27479": "update_cpumask", "27480": "update_cpumasks_hier", "27481": "update_curr", "27482": "update_curr_fair", "27483": "update_curr_idle", "27484": "update_curr_rt", "27485": "update_deref_fetch_param", "27486": "update_domain_attr", "27487": "update_domain_attr_tree", "27488": "update_done", "27489": "update_entity_load_avg", "27490": "update_event_printk", "27491": "update_event_times", "27492": "update_fast_ctr", "27493": "update_fast_timekeeper", "27494": "update_flag", "27495": "update_ftrace_function", "27496": "update_function_graph_func", "27497": "update_group_capacity", "27498": "update_group_times", "27499": "update_idle_cpu_load", "27500": "update_if_frozen", "27501": "update_iter", "27502": "update_load_add", "27503": "update_load_set", "27504": "update_load_sub", "27505": "update_lsm_rule", "27506": "update_max_interval", "27507": "update_max_tr", "27508": "update_max_tr_single", "27509": "update_min_vruntime", "27510": "update_next_balance", "27511": "update_nodemask", "27512": "update_nodemasks_hier", "27513": "update_numa_active_node_mask", "27514": "update_numa_stats", "27515": "update_pages_handler", "27516": "update_pages_work", "27517": "update_perf_cpu_limits", "27518": "update_process_times", "27519": "update_protections", "27520": "update_pvclock_gtod", "27521": "update_relax_domain_level", "27522": "update_rlimit_cpu", "27523": "update_rmtp", "27524": "update_rq_clock", "27525": "update_rq_clock_task", "27526": "update_rq_runnable_avg", "27527": "update_rt_migration", "27528": "update_runtime_enabled", "27529": "update_sd_lb_stats", "27530": "update_sd_pick_busiest", "27531": "update_sg_lb_stats", "27532": "update_state", "27533": "update_stats_curr_start", "27534": "update_stats_dequeue", "27535": "update_stats_enqueue", "27536": "update_stats_wait_end", "27537": "update_stats_wait_start", "27538": "update_symbol_cache", "27539": "update_sysctl", "27540": "update_task_scan_period", "27541": "update_tasks_cpumask", "27542": "update_tasks_flags", "27543": "update_tasks_nodemask", "27544": "update_thresh", "27545": "update_top_cache_domain", "27546": "update_traceon_count", "27547": "update_ts_time_stats", "27548": "update_vsyscall", "27549": "update_vsyscall_old", "27550": "update_vsyscall_tz", "27551": "update_wall_time", "27552": "update_watchdog", "27553": "update_watchdog_all_cpus", "27554": "upending", "27555": "upid", "27556": "upper_first", "27557": "upper_last", "27558": "uprobe", "27559": "uprobe_apply", "27560": "uprobe_buffer_disable", "27561": "uprobe_buffer_enable", "27562": "uprobe_buffer_get", "27563": "uprobe_buffer_init", "27564": "uprobe_buffer_put", "27565": "uprobe_buffer_refcnt", "27566": "uprobe_clear_state", "27567": "uprobe_consumer", "27568": "uprobe_copy_insn", "27569": "uprobe_copy_process", "27570": "uprobe_cpu_buffer", "27571": "uprobe_deny_signal", "27572": "uprobe_dispatch_data", "27573": "uprobe_dispatcher", "27574": "uprobe_dup_mmap", "27575": "uprobe_end_dup_mmap", "27576": "uprobe_event_define_fields", "27577": "uprobe_event_system", "27578": "uprobe_events_ops", "27579": "uprobe_exception_nb", "27580": "uprobe_filter_ctx", "27581": "uprobe_filter_event", "27582": "uprobe_filter_is_empty", "27583": "uprobe_filter_mmap", "27584": "uprobe_filter_register", "27585": "uprobe_filter_unregister", "27586": "uprobe_free_utask", "27587": "uprobe_funcs", "27588": "uprobe_get_swbp_addr", "27589": "uprobe_get_trap_addr", "27590": "uprobe_handler_mask", "27591": "uprobe_handler_remove", "27592": "uprobe_is_active", "27593": "uprobe_list", "27594": "uprobe_lock", "27595": "uprobe_mmap", "27596": "uprobe_munmap", "27597": "uprobe_notify_resume", "27598": "uprobe_opcode_t", "27599": "uprobe_perf_close", "27600": "uprobe_perf_filter", "27601": "uprobe_perf_func", "27602": "uprobe_perf_open", "27603": "uprobe_post_sstep_notifier", "27604": "uprobe_pre_sstep_notifier", "27605": "uprobe_profile_ops", "27606": "uprobe_register", "27607": "uprobe_start_dup_mmap", "27608": "uprobe_swbp_insn", "27609": "uprobe_swbp_insn_size", "27610": "uprobe_task", "27611": "uprobe_trace_entry_head", "27612": "uprobe_trace_func", "27613": "uprobe_unregister", "27614": "uprobe_warn", "27615": "uprobe_write_opcode", "27616": "uprobe_xol_slot_bytes", "27617": "uprobes_fetch_type_table", "27618": "uprobes_hash_sz", "27619": "uprobes_mmap_hash", "27620": "uprobes_mmap_mutex", "27621": "uprobes_state", "27622": "uprobes_tree", "27623": "uprobes_treelock", "27624": "uptime", "27625": "uptr", "27626": "uretprobe_dispatcher", "27627": "uretprobe_perf_func", "27628": "uretprobe_trace_func", "27629": "uru", "27630": "us", "27631": "usable", "27632": "usage", "27633": "usage_bit", "27634": "usage_mask", "27635": "usage_str", "27636": "usage_traces", "27637": "use", "27638": "use_default", "27639": "use_dfl", "27640": "use_dfl_pwq", "27641": "use_kmalloc", "27642": "use_max_tr", "27643": "use_split_pmd_ptlocks", "27644": "use_task_css_set_links", "27645": "use_ww_ctx", "27646": "usec_per_msec", "27647": "usec_per_sec", "27648": "usec_rem", "27649": "usec_to_hz_adj32", "27650": "usec_to_hz_mul32", "27651": "usec_to_hz_shr32", "27652": "usecs", "27653": "usecs_rem", "27654": "usecs_str", "27655": "usecs_to_jiffies", "27656": "used", "27657": "used_map_cnt", "27658": "used_maps", "27659": "used_space", "27660": "user", "27661": "user_auxv", "27662": "user_disable_single_step", "27663": "user_enable_block_step", "27664": "user_enable_single_step", "27665": "user_extra", "27666": "user_filter", "27667": "user_hz", "27668": "user_lock_limit", "27669": "user_locked", "27670": "user_mask_ptr", "27671": "user_mode", "27672": "user_namespace", "27673": "user_namespaces_init", "27674": "user_ns", "27675": "user_ns_cachep", "27676": "user_only", "27677": "user_page", "27678": "user_regset", "27679": "user_regset_view", "27680": "user_stack", "27681": "user_stack_pointer", "27682": "user_struct", "27683": "user_tick", "27684": "user_tv", "27685": "usermodehelper_bset", "27686": "usermodehelper_disable", "27687": "usermodehelper_disabled", "27688": "usermodehelper_disabled_waitq", "27689": "usermodehelper_enable", "27690": "usermodehelper_inheritable", "27691": "usermodehelper_init", "27692": "usermodehelper_read_lock_wait", "27693": "usermodehelper_read_trylock", "27694": "usermodehelper_table", "27695": "userns_fixup_signal_uid", "27696": "userns_flags", "27697": "userns_get", "27698": "userns_init_flags", "27699": "userns_install", "27700": "userns_may_setgroups", "27701": "userns_operations", "27702": "userns_put", "27703": "userns_setgroups_allowed", "27704": "userns_state_mutex", "27705": "userpg", "27706": "users", "27707": "userstack_entry", "27708": "uset", "27709": "ushort", "27710": "ushrt_max", "27711": "using_ftrace_ops_list_func", "27712": "usize", "27713": "usleep_range", "27714": "uspertick", "27715": "usrc", "27716": "uss", "27717": "uss32", "27718": "uss_ptr", "27719": "ut", "27720": "utask", "27721": "utask_running", "27722": "utask_sstep", "27723": "utask_sstep_ack", "27724": "utask_sstep_trapped", "27725": "uthese", "27726": "utilization_avg_contrib", "27727": "utilization_delta", "27728": "utilization_load_avg", "27729": "utime", "27730": "utimescaled", "27731": "utp", "27732": "uts", "27733": "uts_namespace", "27734": "uts_ns", "27735": "uts_proc_domainname", "27736": "uts_proc_hostname", "27737": "uts_proc_notify", "27738": "uts_release", "27739": "uts_sem", "27740": "utsname", "27741": "utsns_get", "27742": "utsns_install", "27743": "utsns_operations", "27744": "utsns_put", "27745": "utv", "27746": "utx", "27747": "uuid", "27748": "uvalue", "27749": "v", "27750": "v0", "27751": "v1", "27752": "v2", "27753": "va", "27754": "va_copy", "27755": "va_end", "27756": "va_list", "27757": "va_start", "27758": "vaddr", "27759": "vaddr_to_offset", "27760": "val", "27761": "val2", "27762": "val3", "27763": "val_a", "27764": "val_b", "27765": "val_idx", "27766": "valid", "27767": "valid_signal", "27768": "valid_state", "27769": "valid_vma", "27770": "validate_chain", "27771": "validate_change", "27772": "validate_coredump_safety", "27773": "validate_creds", "27774": "validate_creds_for_do_exit", "27775": "validate_prctl_map", "27776": "valp", "27777": "value", "27778": "value_regno", "27779": "value_size", "27780": "values", "27781": "var", "27782": "variable", "27783": "varray", "27784": "vattr", "27785": "vb", "27786": "vc", "27787": "vcaps", "27788": "vd", "27789": "vdiff", "27790": "vdso32_enabled", "27791": "vdso_enabled", "27792": "ve", "27793": "vec", "27794": "vec_nr", "27795": "vendor", "27796": "ver", "27797": "verbose", "27798": "verbose_torout_errstring", "27799": "verbose_torout_string", "27800": "verif_pid", "27801": "verifier_env", "27802": "verifier_stack_elem", "27803": "verifier_state", "27804": "verifier_state_list", "27805": "verify_export_symbols", "27806": "verify_opcode", "27807": "verify_read", "27808": "verify_write", "27809": "vermagic", "27810": "vermagic_string", "27811": "vernum", "27812": "vers", "27813": "versindex", "27814": "version", "27815": "version_code", "27816": "version_sysfs_builtin", "27817": "versions", "27818": "very_verbose", "27819": "vf", "27820": "vfork", "27821": "vfork_done", "27822": "vfree", "27823": "vfs_cap_flags_effective", "27824": "vfs_cap_revision_mask", "27825": "vfs_cap_revision_shift", "27826": "vfs_getattr", "27827": "vfs_read", "27828": "vfs_statfs", "27829": "vfsmount", "27830": "vfsmount_mark", "27831": "vg", "27832": "vh", "27833": "via", "27834": "victim", "27835": "view", "27836": "virq", "27837": "virt", "27838": "virt_addr_valid", "27839": "virt_exp", "27840": "virt_to_head_page", "27841": "virt_to_page", "27842": "virt_to_phys", "27843": "virtmem", "27844": "virtual", "27845": "visible", "27846": "vleft", "27847": "vm_account", "27848": "vm_area_cachep", "27849": "vm_area_struct", "27850": "vm_block_dump", "27851": "vm_bug_on_mm", "27852": "vm_denywrite", "27853": "vm_dirty_background", "27854": "vm_dirty_bytes", "27855": "vm_dirty_ratio", "27856": "vm_dontcopy", "27857": "vm_dontdump", "27858": "vm_dontexpand", "27859": "vm_drop_pagecache", "27860": "vm_end", "27861": "vm_exec", "27862": "vm_fault", "27863": "vm_fault_sigbus", "27864": "vm_file", "27865": "vm_flags", "27866": "vm_flags_t", "27867": "vm_highmem_is_dirtyable", "27868": "vm_hugetlb", "27869": "vm_hugetlb_group", "27870": "vm_init_def_mask", "27871": "vm_io", "27872": "vm_laptop_mode", "27873": "vm_legacy_va_layout", "27874": "vm_locked", "27875": "vm_lowmem_reserve_ratio", "27876": "vm_max_map_count", "27877": "vm_mayexec", "27878": "vm_mayshare", "27879": "vm_min_free_kbytes", "27880": "vm_min_slab", "27881": "vm_min_unmapped", "27882": "vm_mm", "27883": "vm_next", "27884": "vm_nohugepage", "27885": "vm_operations_struct", "27886": "vm_ops", "27887": "vm_overcommit_memory", "27888": "vm_overcommit_ratio", "27889": "vm_page_cluster", "27890": "vm_page_prot", "27891": "vm_panic_on_oom", "27892": "vm_percpu_pagelist_fraction", "27893": "vm_pgoff", "27894": "vm_prev", "27895": "vm_rb", "27896": "vm_read", "27897": "vm_shared", "27898": "vm_start", "27899": "vm_stat_account", "27900": "vm_swappiness", "27901": "vm_table", "27902": "vm_unacct_memory", "27903": "vm_vdso_enabled", "27904": "vm_vfs_cache_pressure", "27905": "vm_write", "27906": "vm_zone_reclaim_mode", "27907": "vma", "27908": "vma_dup_policy", "27909": "vma_end", "27910": "vma_has_uprobes", "27911": "vma_interval_tree_foreach", "27912": "vma_interval_tree_insert_after", "27913": "vma_migratable", "27914": "vma_pages", "27915": "vma_policy", "27916": "vma_policy_mof", "27917": "vma_size", "27918": "vmacache", "27919": "vmacache_flush", "27920": "vmacache_seqnum", "27921": "vmalloc", "27922": "vmalloc_exec", "27923": "vmalloc_sync_all", "27924": "vmalloc_to_page", "27925": "vmalloc_user", "27926": "vmcoreinfo_bytes", "27927": "vmcoreinfo_data", "27928": "vmcoreinfo_max_size", "27929": "vmcoreinfo_note", "27930": "vmcoreinfo_note_size", "27931": "vmcoreinfo_size", "27932": "vmf", "27933": "vmlinux_symbol_str", "27934": "vmstart", "27935": "vnr", "27936": "void", "27937": "vp", "27938": "vpid", "27939": "vprintk", "27940": "vruntime", "27941": "vscnprintf", "27942": "vsize", "27943": "vsnprintf", "27944": "vtime_account_idle", "27945": "vtime_account_system", "27946": "vtime_account_user", "27947": "vtime_accounting_enabled", "27948": "vtime_common_account_irq_enter", "27949": "vtime_common_task_switch", "27950": "vtime_delta", "27951": "vtime_gen_account_irq_exit", "27952": "vtime_guest_enter", "27953": "vtime_guest_exit", "27954": "vtime_init_idle", "27955": "vtime_seqlock", "27956": "vtime_sleeping", "27957": "vtime_snap", "27958": "vtime_snap_whence", "27959": "vtime_sys", "27960": "vtime_task_switch", "27961": "vtime_user", "27962": "vtime_user_enter", "27963": "vtime_user_exit", "27964": "vzalloc", "27965": "w", "27966": "w1", "27967": "w2", "27968": "w4", "27969": "w8", "27970": "wait", "27971": "wait4", "27972": "wait_again", "27973": "wait_atomic_t_bit_nr", "27974": "wait_bit", "27975": "wait_bit_action_f", "27976": "wait_bit_key", "27977": "wait_bit_queue", "27978": "wait_blkd_tasks", "27979": "wait_chldexit", "27980": "wait_count", "27981": "wait_done", "27982": "wait_event", "27983": "wait_event_interruptible", "27984": "wait_event_interruptible_timeout", "27985": "wait_for_auditd", "27986": "wait_for_completion", "27987": "wait_for_completion_killable", "27988": "wait_for_device_probe", "27989": "wait_for_helper", "27990": "wait_for_kprobe_optimizer", "27991": "wait_for_threads", "27992": "wait_for_vfork_done", "27993": "wait_list", "27994": "wait_lock", "27995": "wait_max", "27996": "wait_on_bit", "27997": "wait_on_page_locked", "27998": "wait_on_pipe", "27999": "wait_queue_head_t", "28000": "wait_queue_t", "28001": "wait_rcu_gp", "28002": "wait_start", "28003": "wait_sum", "28004": "wait_table", "28005": "wait_table_bits", "28006": "wait_task_inactive", "28007": "wait_woken", "28008": "waiter", "28009": "waiters", "28010": "waiters_leftmost", "28011": "waiters_pending", "28012": "waitid", "28013": "waiting", "28014": "waitq", "28015": "waitqueue_active", "28016": "waittime", "28017": "waittime_stamp", "28018": "wake", "28019": "wake_active", "28020": "wake_affine", "28021": "wake_atomic_t_function", "28022": "wake_bit_function", "28023": "wake_cpu", "28024": "wake_depth", "28025": "wake_enabled", "28026": "wake_entry", "28027": "wake_flags", "28028": "wake_idx", "28029": "wake_list", "28030": "wake_nocb_leader", "28031": "wake_threads_waitq", "28032": "wake_type", "28033": "wake_up", "28034": "wake_up_all", "28035": "wake_up_all_idle_cpus", "28036": "wake_up_atomic_t", "28037": "wake_up_bit", "28038": "wake_up_full_nohz_cpu", "28039": "wake_up_idle_cpu", "28040": "wake_up_if_idle", "28041": "wake_up_interruptible", "28042": "wake_up_new_task", "28043": "wake_up_nohz_cpu", "28044": "wake_up_process", "28045": "wake_up_state", "28046": "wake_up_worker", "28047": "wake_wide", "28048": "wakee", "28049": "wakee_flip_decay_ts", "28050": "wakee_flips", "28051": "wakelock", "28052": "wakelock_lookup_add", "28053": "wakelocks_gc", "28054": "wakelocks_gc_count", "28055": "wakelocks_limit_exceeded", "28056": "wakelocks_lock", "28057": "wakelocks_lru_add", "28058": "wakelocks_lru_list", "28059": "wakelocks_lru_most_recent", "28060": "wakelocks_tree", "28061": "wakeme_after_rcu", "28062": "wakeup", "28063": "wakeup_busy", "28064": "wakeup_count", "28065": "wakeup_cpu", "28066": "wakeup_current_cpu", "28067": "wakeup_dl", "28068": "wakeup_dl_tracer", "28069": "wakeup_dl_tracer_init", "28070": "wakeup_events", "28071": "wakeup_flag_changed", "28072": "wakeup_full", "28073": "wakeup_function_set", "28074": "wakeup_gran", "28075": "wakeup_graph_entry", "28076": "wakeup_graph_return", "28077": "wakeup_interval", "28078": "wakeup_lock", "28079": "wakeup_preempt_entity", "28080": "wakeup_preemption", "28081": "wakeup_print_header", "28082": "wakeup_print_line", "28083": "wakeup_prio", "28084": "wakeup_reset", "28085": "wakeup_rt", "28086": "wakeup_rt_tracer", "28087": "wakeup_rt_tracer_init", "28088": "wakeup_set_flag", "28089": "wakeup_softirqd", "28090": "wakeup_source", "28091": "wakeup_source_add", "28092": "wakeup_source_register", "28093": "wakeup_source_unregister", "28094": "wakeup_task", "28095": "wakeup_test_data", "28096": "wakeup_trace", "28097": "wakeup_trace_close", "28098": "wakeup_trace_open", "28099": "wakeup_tracer", "28100": "wakeup_tracer_call", "28101": "wakeup_tracer_init", "28102": "wakeup_tracer_reset", "28103": "wakeup_tracer_start", "28104": "wakeup_tracer_stop", "28105": "wakeup_watermark", "28106": "wakewrite", "28107": "walk", "28108": "walk_iomem_res", "28109": "walk_pred_abort", "28110": "walk_pred_default", "28111": "walk_pred_parent", "28112": "walk_pred_tree", "28113": "walk_return", "28114": "walk_system_ram_range", "28115": "walk_system_ram_res", "28116": "walk_tg_tree", "28117": "walk_tg_tree_from", "28118": "walker", "28119": "wall_to_monotonic", "28120": "want", "28121": "want_affine", "28122": "want_early", "28123": "wants_signal", "28124": "warn", "28125": "warn_bad_state", "28126": "warn_cpu_offline", "28127": "warn_deprecated_v2", "28128": "warn_failed_init_tracer", "28129": "warn_legacy_capability_use", "28130": "warn_no_rtc", "28131": "warn_no_thread", "28132": "warn_on", "28133": "warn_on_once", "28134": "warn_once", "28135": "warn_ratelimit", "28136": "warn_slowpath_common", "28137": "warn_slowpath_fmt", "28138": "warn_slowpath_fmt_taint", "28139": "warn_slowpath_null", "28140": "warn_sysctl_write", "28141": "warned", "28142": "warned_broken_hierarchy", "28143": "warning", "28144": "warning_freq", "28145": "warp_clock", "28146": "was", "28147": "was_freezing", "28148": "was_frozen", "28149": "was_periodic", "28150": "was_set", "28151": "was_stopped", "28152": "watch", "28153": "watch_found", "28154": "watchdog", "28155": "watchdog_cleanup", "28156": "watchdog_disable", "28157": "watchdog_disable_all_cpus", "28158": "watchdog_enable", "28159": "watchdog_enable_all_cpus", "28160": "watchdog_enabled", "28161": "watchdog_ev", "28162": "watchdog_hrtimer", "28163": "watchdog_interrupt_count", "28164": "watchdog_nmi_disable", "28165": "watchdog_nmi_disable_all", "28166": "watchdog_nmi_enable", "28167": "watchdog_nmi_enable_all", "28168": "watchdog_nmi_touch", "28169": "watchdog_overflow_callback", "28170": "watchdog_param", "28171": "watchdog_proc_mutex", "28172": "watchdog_running", "28173": "watchdog_set_prio", "28174": "watchdog_should_run", "28175": "watchdog_stamp", "28176": "watchdog_task", "28177": "watchdog_threads", "28178": "watchdog_thresh", "28179": "watchdog_timer_fn", "28180": "watchdog_touch_ts", "28181": "watchdog_user_enabled", "28182": "watches", "28183": "watermark", "28184": "way", "28185": "wchar", "28186": "wcount", "28187": "wd_attr", "28188": "wd_hw_attr", "28189": "wd_last", "28190": "wd_now", "28191": "we", "28192": "weak", "28193": "weight", "28194": "weight_idleprio", "28195": "weighted_cpuload", "28196": "wf_fork", "28197": "wf_migrated", "28198": "wf_sync", "28199": "wfc", "28200": "wg", "28201": "what", "28202": "what2act", "28203": "when", "28204": "whence", "28205": "which", "28206": "which_clock", "28207": "whichcpu", "28208": "while", "28209": "while_each_pid_task", "28210": "while_each_pid_thread", "28211": "while_each_thread", "28212": "while_for_each_event_file", "28213": "while_for_each_ftrace_op", "28214": "while_for_each_ftrace_rec", "28215": "who", "28216": "why", "28217": "width", "28218": "will", "28219": "will_be_gpl_only", "28220": "windows", "28221": "with", "28222": "within", "28223": "within_kprobe_blacklist", "28224": "within_module", "28225": "within_module_core", "28226": "within_module_init", "28227": "without", "28228": "wl", "28229": "wl_gc_count_max", "28230": "wl_gc_time_sec", "28231": "wlist", "28232": "wm", "28233": "wmb", "28234": "wmult_const", "28235": "wmult_idleprio", "28236": "wmult_shift", "28237": "woke_up", "28238": "woken", "28239": "woken_wake_function", "28240": "word", "28241": "words", "28242": "work", "28243": "work1", "28244": "work2", "28245": "work_buf", "28246": "work_busy", "28247": "work_busy_pending", "28248": "work_busy_running", "28249": "work_color", "28250": "work_color_to_flags", "28251": "work_cpu_unbound", "28252": "work_data_bits", "28253": "work_debug_descr", "28254": "work_debug_hint", "28255": "work_exited", "28256": "work_fixup_activate", "28257": "work_fixup_free", "28258": "work_fixup_init", "28259": "work_flags", "28260": "work_for_cpu", "28261": "work_for_cpu_fn", "28262": "work_func_t", "28263": "work_is_canceling", "28264": "work_list", "28265": "work_next_color", "28266": "work_no_color", "28267": "work_nr_colors", "28268": "work_offq_canceling", "28269": "work_offq_pool_none", "28270": "work_offq_pool_shift", "28271": "work_on_cpu", "28272": "work_pending", "28273": "work_static", "28274": "work_struct", "28275": "work_struct_color_shift", "28276": "work_struct_delayed", "28277": "work_struct_delayed_bit", "28278": "work_struct_flag_mask", "28279": "work_struct_linked", "28280": "work_struct_linked_bit", "28281": "work_struct_pending", "28282": "work_struct_pending_bit", "28283": "work_struct_pwq", "28284": "work_struct_static_bit", "28285": "work_struct_wq_data_mask", "28286": "worker", "28287": "worker_attach_to_pool", "28288": "worker_clr_flags", "28289": "worker_cpu_intensive", "28290": "worker_desc_len", "28291": "worker_detach_from_pool", "28292": "worker_die", "28293": "worker_enter_idle", "28294": "worker_flags", "28295": "worker_ida", "28296": "worker_idle", "28297": "worker_leave_idle", "28298": "worker_not_running", "28299": "worker_pool", "28300": "worker_pool_assign_id", "28301": "worker_pool_idr", "28302": "worker_prep", "28303": "worker_ptr", "28304": "worker_rebound", "28305": "worker_set_flags", "28306": "worker_thread", "28307": "worker_unbound", "28308": "workers", "28309": "worklist", "28310": "workp", "28311": "workqueue", "28312": "workqueue_attrs", "28313": "workqueue_congested", "28314": "workqueue_cpu_down_callback", "28315": "workqueue_freezing", "28316": "workqueue_set_max_active", "28317": "workqueue_struct", "28318": "workqueue_sysfs_register", "28319": "workqueue_sysfs_unregister", "28320": "workqueues", "28321": "works", "28322": "would", "28323": "wq", "28324": "wq_barrier", "28325": "wq_barrier_func", "28326": "wq_busy", "28327": "wq_calc_node_cpumask", "28328": "wq_clamp_max_active", "28329": "wq_cpu_intensive", "28330": "wq_cpumask_show", "28331": "wq_cpumask_store", "28332": "wq_dev", "28333": "wq_device", "28334": "wq_device_release", "28335": "wq_dfl_active", "28336": "wq_flag_exclusive", "28337": "wq_flag_woken", "28338": "wq_flusher", "28339": "wq_freezable", "28340": "wq_highpri", "28341": "wq_max_active", "28342": "wq_mayday_lock", "28343": "wq_name_len", "28344": "wq_nice_show", "28345": "wq_nice_store", "28346": "wq_numa_enabled", "28347": "wq_numa_init", "28348": "wq_numa_possible_cpumask", "28349": "wq_numa_show", "28350": "wq_numa_store", "28351": "wq_pool_ids_show", "28352": "wq_pool_mutex", "28353": "wq_power_efficient", "28354": "wq_subsys", "28355": "wq_sysfs", "28356": "wq_sysfs_groups", "28357": "wq_sysfs_init", "28358": "wq_sysfs_prep_attrs", "28359": "wq_sysfs_unbound_attrs", "28360": "wq_unbind_fn", "28361": "wq_unbound", "28362": "wq_unbound_max_active", "28363": "wq_update_unbound_numa", "28364": "wq_update_unbound_numa_attrs_buf", "28365": "wq_worker_sleeping", "28366": "wq_worker_waking_up", "28367": "wqattrs_equal", "28368": "wqattrs_hash", "28369": "wrap_max", "28370": "wrap_min", "28371": "wraps", "28372": "write", "28373": "write_bufsize", "28374": "write_bytes", "28375": "write_can_lock", "28376": "write_char", "28377": "write_ctr", "28378": "write_delay", "28379": "write_holdtime", "28380": "write_irq_affinity", "28381": "write_iteration", "28382": "write_lock", "28383": "write_lock_irq", "28384": "write_lock_irqsave", "28385": "write_mask", "28386": "write_mem_msg", "28387": "write_once", "28388": "write_page", "28389": "write_profile", "28390": "write_s64", "28391": "write_seqcount_begin", "28392": "write_seqcount_end", "28393": "write_seqlock", "28394": "write_seqlock_irqsave", "28395": "write_sequnlock", "28396": "write_sequnlock_irqrestore", "28397": "write_stamp", "28398": "write_syscalls", "28399": "write_u64", "28400": "write_unlock", "28401": "write_unlock_irq", "28402": "write_unlock_irqrestore", "28403": "write_waitq", "28404": "write_waittime", "28405": "writelock", "28406": "writer_task", "28407": "writer_tasks", "28408": "writes", "28409": "writeunlock", "28410": "written", "28411": "wrk", "28412": "wrt_sysctl", "28413": "ws", "28414": "wtm", "28415": "ww", "28416": "ww_acquire_ctx", "28417": "ww_class", "28418": "ww_ctx", "28419": "ww_mutex", "28420": "ww_mutex_deadlock_injection", "28421": "ww_mutex_lock_acquired", "28422": "ww_mutex_set_context_fastpath", "28423": "ww_mutex_set_context_slowpath", "28424": "ww_mutex_unlock", "28425": "x", "28426": "x86", "28427": "xacct_add_tsk", "28428": "xchg", "28429": "xfs_buf_age", "28430": "xfs_buf_timer", "28431": "xfs_errlevel", "28432": "xfs_filestream_timer", "28433": "xfs_inherit_noatime", "28434": "xfs_inherit_nodfrg", "28435": "xfs_inherit_nodump", "28436": "xfs_inherit_nosym", "28437": "xfs_inherit_sync", "28438": "xfs_panic_mask", "28439": "xfs_rotorstep", "28440": "xfs_sgid_inherit", "28441": "xfs_stats_clear", "28442": "xfs_symlink_mode", "28443": "xfs_syncd_timer", "28444": "xinterval", "28445": "xlate", "28446": "xmitcsum", "28447": "xol_add_vma", "28448": "xol_area", "28449": "xol_free_insn_slot", "28450": "xol_get_insn_slot", "28451": "xol_take_insn_slot", "28452": "xol_vaddr", "28453": "xor", "28454": "xt", "28455": "xtime_interval", "28456": "xtime_nsec", "28457": "xtime_remainder", "28458": "xtime_sec", "28459": "xtime_update", "28460": "xyz", "28461": "y", "28462": "year", "28463": "yes", "28464": "yield", "28465": "yield_task", "28466": "yield_task_fair", "28467": "yield_task_rt", "28468": "yield_to", "28469": "yield_to_task", "28470": "yield_to_task_fair", "28471": "yielded", "28472": "yld_count", "28473": "you", "28474": "your", "28475": "z", "28476": "zalloc_cpumask_var", "28477": "zalloc_cpumask_var_node", "28478": "zap_class", "28479": "zap_other_threads", "28480": "zap_pid_ns_processes", "28481": "zd", "28482": "zero", "28483": "zero_buf", "28484": "zero_buf_sz", "28485": "zero_cpu_stall_ticks", "28486": "zero_page", "28487": "zombie", "28488": "zone", "28489": "zone_end", "28490": "zone_end_pfn", "28491": "zone_found", "28492": "zone_page_state", "28493": "zone_reclaim_mode", "28494": "zone_start", "28495": "zone_start_pfn", "28496": "zones", "28497": "{", "28498": "|", "28499": "||", "28500": "}", "28501": "~"}, "vocab_size": 28502}